<!-- doc/src/sgml/gist.sgml -->

<chapter id="gist">
<!-- pgdoc-cn_start sig_en=262964cdc4326b8c30faeb4b5179d61f sig_cn_org=None source=14.1 
<title>GiST Indexes</title>
________________________________________________________-->
<title>GiST 索引</title>
<!-- pgdoc-cn_end sig_en=262964cdc4326b8c30faeb4b5179d61f -->

<!-- pgdoc-cn_start sig_en=a6db6ba029c695714d0f6a4dbeda97f3 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>index</primary>
    <secondary>GiST</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>index</primary>
    <secondary>GiST</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=a6db6ba029c695714d0f6a4dbeda97f3 -->

<sect1 id="gist-intro">
<!-- pgdoc-cn_start sig_en=c2fcf93c611ba5f3baff759a5cc428dd sig_cn_org=None source=14.1 
 <title>Introduction</title>
________________________________________________________-->
 <title>简介</title>
<!-- pgdoc-cn_end sig_en=c2fcf93c611ba5f3baff759a5cc428dd -->

<!-- pgdoc-cn_start sig_en=4fe6191cd6f4e7f9faf7595cb66a9d6e sig_cn_org=None source=14.1 
 <para>
   <acronym>GiST</acronym> stands for Generalized Search Tree.  It is a
   balanced, tree-structured access method, that acts as a base template in
   which to implement arbitrary indexing schemes. B-trees, R-trees and many
   other indexing schemes can be implemented in <acronym>GiST</acronym>.
 </para>
________________________________________________________-->
 <para>
   <acronym>GiST</acronym>表示通用搜索树。它是一种平衡的树结构的访问方法，它作为一种模板可用来实现任意索引模式。B 树、R 树和很多其他索引模式都可以在<acronym>GiST</acronym>中实现。
 </para>
<!-- pgdoc-cn_end sig_en=4fe6191cd6f4e7f9faf7595cb66a9d6e -->

<!-- pgdoc-cn_start sig_en=36a61deebfa0e4a35426e0452ffea5a6 sig_cn_org=None source=14.1 
 <para>
  One advantage of <acronym>GiST</acronym> is that it allows the development
  of custom data types with the appropriate access methods, by
  an expert in the domain of the data type, rather than a database expert.
 </para>
________________________________________________________-->
 <para>
  <acronym>GiST</acronym>的一个优势是它允许自定义数据类型的领域专家使用合适的访问方法开发自定义数据类型，而不是让数据库专家来开发。
 </para>
<!-- pgdoc-cn_end sig_en=36a61deebfa0e4a35426e0452ffea5a6 -->

<!-- pgdoc-cn_start sig_en=0015cd480be5f2df49cdc1a6baff68f2 sig_cn_org=None source=14.1 
  <para>
    Some of the information here is derived from the University of California
    at Berkeley's GiST Indexing Project
    <ulink url="http://gist.cs.berkeley.edu/">web site</ulink> and
    Marcel Kornacker's thesis,
    <ulink url="http://www.sai.msu.su/~megera/postgres/gist/papers/concurrency/access-methods-for-next-generation.pdf.gz">
    Access Methods for Next-Generation Database Systems</ulink>.
    The <acronym>GiST</acronym>
    implementation in <productname>PostgreSQL</productname> is primarily
    maintained by Teodor Sigaev and Oleg Bartunov, and there is more
    information on their
    <ulink url="http://www.sai.msu.su/~megera/postgres/gist/">web site</ulink>.
  </para>
________________________________________________________-->
  <para>
    这里的一些信息是来自加州大学伯克利分校的 GiST 索引项目<ulink url="http://gist.cs.berkeley.edu/">网站</ulink>和 Marcel Kornacker 的学位论文<ulink url="http://www.sai.msu.su/~megera/postgres/gist/papers/concurrency/access-methods-for-next-generation.pdf.gz">Access Methods for Next-Generation Database Systems</ulink>。<productname>PostgreSQL</productname>中的<acronym>GiST</acronym>实现主要由 Teodor Sigaev 和 Oleg Bartunov 维护，在他们的<ulink url="http://www.sai.msu.su/~megera/postgres/gist/">网站</ulink>上有更多信息。
  </para>
<!-- pgdoc-cn_end sig_en=0015cd480be5f2df49cdc1a6baff68f2 -->

</sect1>

<sect1 id="gist-builtin-opclasses">
<!-- pgdoc-cn_start sig_en=f3fa348aa7b75a7cd90f4d3569e72437 sig_cn_org=None source=14.1 
 <title>Built-in Operator Classes</title>
________________________________________________________-->
 <title>内建操作符类</title>
<!-- pgdoc-cn_end sig_en=f3fa348aa7b75a7cd90f4d3569e72437 -->

<!-- pgdoc-cn_start sig_en=7b21fda42faf5b4b07713b44091d630d sig_cn_org=None source=14.1 
 <para>
  The core <productname>PostgreSQL</productname> distribution
  includes the <acronym>GiST</acronym> operator classes shown in
  <xref linkend="gist-builtin-opclasses-table"/>.
  (Some of the optional modules described in <xref linkend="contrib"/>
  provide additional <acronym>GiST</acronym> operator classes.)
 </para>
________________________________________________________-->
 <para>
  <productname>PostgreSQL</productname>核心发布中包括如<xref linkend="gist-builtin-opclasses-table"/>中所示的<acronym>GiST</acronym>操作符类（<xref linkend="contrib"/>中描述的一些可选模块提供了额外的<acronym>GiST</acronym>操作符类）。
 </para>
<!-- pgdoc-cn_end sig_en=7b21fda42faf5b4b07713b44091d630d -->

  <table id="gist-builtin-opclasses-table">
<!-- pgdoc-cn_start sig_en=f54fb650b44b7f3740675bf7fc023e42 sig_cn_org=None source=14.1 
   <title>Built-in <acronym>GiST</acronym> Operator Classes</title>
________________________________________________________-->
   <title>内建<acronym>GiST</acronym>操作符类</title>
<!-- pgdoc-cn_end sig_en=f54fb650b44b7f3740675bf7fc023e42 -->
   <tgroup cols="3">
     <colspec colname="col1" colwidth="2*"/>
     <colspec colname="col2" colwidth="3*"/>
     <colspec colname="col3" colwidth="2*"/>
    <thead>
<!-- pgdoc-cn_start sig_en=54f7eb31e973dc3b41587e9b821b9270 sig_cn_org=None source=14.1 
     <row>
      <entry>Name</entry>
      <entry>Indexable Operators</entry>
      <entry>Ordering Operators</entry>
     </row>
________________________________________________________-->
     <row>
      <entry>名称</entry>
      <entry>可索引操作符</entry>
      <entry>排序操作符</entry>
     </row>
<!-- pgdoc-cn_end sig_en=54f7eb31e973dc3b41587e9b821b9270 -->
    </thead>
    <tbody>
     <row>
      <entry valign="middle" morerows="11"><literal>box_ops</literal></entry>
      <entry><literal>&lt;&lt; (box, box)</literal></entry>
      <entry valign="middle" morerows="11"><literal>&lt;-&gt; (box, point)</literal></entry>
     </row>
     <row><entry><literal>&amp;&lt; (box, box)</literal></entry></row>
     <row><entry><literal>&amp;&amp; (box, box)</literal></entry></row>
     <row><entry><literal>&amp;&gt; (box, box)</literal></entry></row>
     <row><entry><literal>&gt;&gt; (box, box)</literal></entry></row>
     <row><entry><literal>~= (box, box)</literal></entry></row>
     <row><entry><literal>@&gt; (box, box)</literal></entry></row>
     <row><entry><literal>&lt;@ (box, box)</literal></entry></row>
     <row><entry><literal>&amp;&lt;| (box, box)</literal></entry></row>
     <row><entry><literal>&lt;&lt;| (box, box)</literal></entry></row>
     <row><entry><literal>|&gt;&gt; (box, box)</literal></entry></row>
     <row><entry><literal>|&amp;&gt; (box, box)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="11"><literal>circle_ops</literal></entry>
      <entry><literal>&lt;&lt; (circle, circle)</literal></entry>
      <entry valign="middle" morerows="11"><literal>&lt;-&gt; (circle, point)</literal></entry>
     </row>
     <row><entry><literal>&amp;&lt; (circle, circle)</literal></entry></row>
     <row><entry><literal>&amp;&gt; (circle, circle)</literal></entry></row>
     <row><entry><literal>&gt;&gt; (circle, circle)</literal></entry></row>
     <row><entry><literal>&lt;@ (circle, circle)</literal></entry></row>
     <row><entry><literal>@&gt; (circle, circle)</literal></entry></row>
     <row><entry><literal>~= (circle, circle)</literal></entry></row>
     <row><entry><literal>&amp;&amp; (circle, circle)</literal></entry></row>
     <row><entry><literal>|&gt;&gt; (circle, circle)</literal></entry></row>
     <row><entry><literal>&lt;&lt;| (circle, circle)</literal></entry></row>
     <row><entry><literal>&amp;&lt;| (circle, circle)</literal></entry></row>
     <row><entry><literal>|&amp;&gt; (circle, circle)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="10"><literal>inet_ops</literal></entry>
      <entry><literal>&lt;&lt; (inet, inet)</literal></entry>
      <entry valign="middle" morerows="10"></entry>
     </row>
     <row><entry><literal>&lt;&lt;= (inet, inet)</literal></entry></row>
     <row><entry><literal>&gt;&gt; (inet, inet)</literal></entry></row>
     <row><entry><literal>&gt;&gt;= (inet, inet)</literal></entry></row>
     <row><entry><literal>= (inet, inet)</literal></entry></row>
     <row><entry><literal>&lt;&gt; (inet, inet)</literal></entry></row>
     <row><entry><literal>&lt; (inet, inet)</literal></entry></row>
     <row><entry><literal>&lt;= (inet, inet)</literal></entry></row>
     <row><entry><literal>&gt; (inet, inet)</literal></entry></row>
     <row><entry><literal>&gt;= (inet, inet)</literal></entry></row>
     <row><entry><literal>&amp;&amp; (inet, inet)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="17"><literal>multirange_ops</literal></entry>
      <entry><literal>= (anymultirange, anymultirange)</literal></entry>
      <entry valign="middle" morerows="17"></entry>
     </row>
     <row><entry><literal>&amp;&amp; (anymultirange, anymultirange)</literal></entry></row>
     <row><entry><literal>&amp;&amp; (anymultirange, anyrange)</literal></entry></row>
     <row><entry><literal>@&gt; (anymultirange, anyelement)</literal></entry></row>
     <row><entry><literal>@&gt; (anymultirange, anymultirange)</literal></entry></row>
     <row><entry><literal>@&gt; (anymultirange, anyrange)</literal></entry></row>
     <row><entry><literal>&lt;@ (anymultirange, anymultirange)</literal></entry></row>
     <row><entry><literal>&lt;@ (anymultirange, anyrange)</literal></entry></row>
     <row><entry><literal>&lt;&lt; (anymultirange, anymultirange)</literal></entry></row>
     <row><entry><literal>&lt;&lt; (anymultirange, anyrange)</literal></entry></row>
     <row><entry><literal>&gt;&gt; (anymultirange, anymultirange)</literal></entry></row>
     <row><entry><literal>&gt;&gt; (anymultirange, anyrange)</literal></entry></row>
     <row><entry><literal>&amp;&lt; (anymultirange, anymultirange)</literal></entry></row>
     <row><entry><literal>&amp;&lt; (anymultirange, anyrange)</literal></entry></row>
     <row><entry><literal>&amp;&gt; (anymultirange, anymultirange)</literal></entry></row>
     <row><entry><literal>&amp;&gt; (anymultirange, anyrange)</literal></entry></row>
     <row><entry><literal>-|- (anymultirange, anymultirange)</literal></entry></row>
     <row><entry><literal>-|- (anymultirange, anyrange)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="7"><literal>point_ops</literal></entry>
      <entry><literal>|&gt;&gt; (point, point)</literal></entry>
      <entry valign="middle" morerows="7"><literal>&lt;-&gt; (point, point)</literal></entry>
     </row>
     <row><entry><literal>&lt;&lt; (point, point)</literal></entry></row>
     <row><entry><literal>&gt;&gt; (point, point)</literal></entry></row>
     <row><entry><literal>&lt;&lt;| (point, point)</literal></entry></row>
     <row><entry><literal>~= (point, point)</literal></entry></row>
     <row><entry><literal>&lt;@ (point, box)</literal></entry></row>
     <row><entry><literal>&lt;@ (point, polygon)</literal></entry></row>
     <row><entry><literal>&lt;@ (point, circle)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="11"><literal>poly_ops</literal></entry>
      <entry><literal>&lt;&lt; (polygon, polygon)</literal></entry>
      <entry valign="middle" morerows="11"><literal>&lt;-&gt; (polygon, point)</literal></entry>
     </row>
     <row><entry><literal>&amp;&lt; (polygon, polygon)</literal></entry></row>
     <row><entry><literal>&amp;&gt; (polygon, polygon)</literal></entry></row>
     <row><entry><literal>&gt;&gt; (polygon, polygon)</literal></entry></row>
     <row><entry><literal>&lt;@ (polygon, polygon)</literal></entry></row>
     <row><entry><literal>@&gt; (polygon, polygon)</literal></entry></row>
     <row><entry><literal>~= (polygon, polygon)</literal></entry></row>
     <row><entry><literal>&amp;&amp; (polygon, polygon)</literal></entry></row>
     <row><entry><literal>&lt;&lt;| (polygon, polygon)</literal></entry></row>
     <row><entry><literal>&amp;&lt;| (polygon, polygon)</literal></entry></row>
     <row><entry><literal>|&amp;&gt; (polygon, polygon)</literal></entry></row>
     <row><entry><literal>|&gt;&gt; (polygon, polygon)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="17"><literal>range_ops</literal></entry>
      <entry><literal>= (anyrange, anyrange)</literal></entry>
      <entry valign="middle" morerows="17"></entry>
     </row>
     <row><entry><literal>&amp;&amp; (anyrange, anyrange)</literal></entry></row>
     <row><entry><literal>&amp;&amp; (anyrange, anymultirange)</literal></entry></row>
     <row><entry><literal>@&gt; (anyrange, anyelement)</literal></entry></row>
     <row><entry><literal>@&gt; (anyrange, anyrange)</literal></entry></row>
     <row><entry><literal>@&gt; (anyrange, anymultirange)</literal></entry></row>
     <row><entry><literal>&lt;@ (anyrange, anyrange)</literal></entry></row>
     <row><entry><literal>&lt;@ (anyrange, anymultirange)</literal></entry></row>
     <row><entry><literal>&lt;&lt; (anyrange, anyrange)</literal></entry></row>
     <row><entry><literal>&lt;&lt; (anyrange, anymultirange)</literal></entry></row>
     <row><entry><literal>&gt;&gt; (anyrange, anyrange)</literal></entry></row>
     <row><entry><literal>&gt;&gt; (anyrange, anymultirange)</literal></entry></row>
     <row><entry><literal>&amp;&lt; (anyrange, anyrange)</literal></entry></row>
     <row><entry><literal>&amp;&lt; (anyrange, anymultirange)</literal></entry></row>
     <row><entry><literal>&amp;&gt; (anyrange, anyrange)</literal></entry></row>
     <row><entry><literal>&amp;&gt; (anyrange, anymultirange)</literal></entry></row>
     <row><entry><literal>-|- (anyrange, anyrange)</literal></entry></row>
     <row><entry><literal>-|- (anyrange, anymultirange)</literal></entry></row>

     <row>
      <entry valign="middle" morerows="1"><literal>tsquery_ops</literal></entry>
      <entry><literal>&lt;@ (tsquery, tsquery)</literal></entry>
      <entry valign="middle" morerows="1"></entry>
     </row>
     <row><entry><literal>@&gt; (tsquery, tsquery)</literal></entry></row>
     <row>
      <entry valign="middle"><literal>tsvector_ops</literal></entry>
      <entry><literal>@@ (tsvector, tsquery)</literal></entry>
      <entry></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!-- pgdoc-cn_start sig_en=5bba73c0e1f6a8a04b455f12bdd27816 sig_cn_org=None source=14.1 
 <para>
  For historical reasons, the <literal>inet_ops</literal> operator class is
  not the default class for types <type>inet</type> and <type>cidr</type>.
  To use it, mention the class name in <command>CREATE INDEX</command>,
  for example
<programlisting>
CREATE INDEX ON my_table USING GIST (my_inet_column inet_ops);
</programlisting>
 </para>
________________________________________________________-->
 <para>
  由于历史原因，<literal>inet_ops</literal>操作符类不是类型<type>inet</type>和<type>cidr</type>的默认操作符类。要使用它，需要在<command>CREATE INDEX</command>中指明操作符类的名称，例如
<programlisting>
CREATE INDEX ON my_table USING GIST (my_inet_column inet_ops);
</programlisting>
 </para>
<!-- pgdoc-cn_end sig_en=5bba73c0e1f6a8a04b455f12bdd27816 -->

</sect1>

<sect1 id="gist-extensibility">
<!-- pgdoc-cn_start sig_en=ed1e3bcf1b14b8aa337d0a5ec7bf0665 sig_cn_org=None source=14.1 
 <title>Extensibility</title>
________________________________________________________-->
 <title>可扩展性</title>
<!-- pgdoc-cn_end sig_en=ed1e3bcf1b14b8aa337d0a5ec7bf0665 -->

<!-- pgdoc-cn_start sig_en=6499efb74e5763b5b39a93ea74821b10 sig_cn_org=None source=14.1 
 <para>
   Traditionally, implementing a new index access method meant a lot of
   difficult work.  It was necessary to understand the inner workings of the
   database, such as the lock manager and Write-Ahead Log.  The
   <acronym>GiST</acronym> interface has a high level of abstraction,
   requiring the access method implementer only to implement the semantics of
   the data type being accessed.  The <acronym>GiST</acronym> layer itself
   takes care of concurrency, logging and searching the tree structure.
 </para>
________________________________________________________-->
 <para>
   在传统上，实现一种新的索引访问方法意味着很多困难的工作。开发者必须要理解数据库的内部工作，例如锁管理器和预写式日志。<acronym>GiST</acronym>接口有一个高层的抽象，要求访问方法实现者只实现要被访问的数据类型的语义。<acronym>GiST</acronym>层本身会处理并发、日志和对树结构的搜索。
 </para>
<!-- pgdoc-cn_end sig_en=6499efb74e5763b5b39a93ea74821b10 -->

<!-- pgdoc-cn_start sig_en=c3ccd89c966b2e8bf9dea1ed4a0212c5 sig_cn_org=None source=14.1 
 <para>
   This extensibility should not be confused with the extensibility of the
   other standard search trees in terms of the data they can handle.  For
   example, <productname>PostgreSQL</productname> supports extensible B-trees
   and hash indexes. That means that you can use
   <productname>PostgreSQL</productname> to build a B-tree or hash over any
   data type you want. But B-trees only support range predicates
   (<literal>&lt;</literal>, <literal>=</literal>, <literal>&gt;</literal>),
   and hash indexes only support equality queries.
 </para>
________________________________________________________-->
 <para>
   这种可扩展性不应该与其他标准搜索树对于它们所处理的数据上的可扩展性混淆。例如，<productname>PostgreSQL</productname>支持可扩展的 B 树和哈希索引。也就是说你可以用<productname>PostgreSQL</productname>在任何你想要的数据类型上构建一个 B 树或哈希。但是 B 树只支持范围谓词（<literal>&lt;</literal>、<literal>=</literal>、<literal>&gt;</literal>），而哈希索引支持等值查询。
 </para>
<!-- pgdoc-cn_end sig_en=c3ccd89c966b2e8bf9dea1ed4a0212c5 -->

<!-- pgdoc-cn_start sig_en=eb6f386029033eddbdf7c7334237f0f0 sig_cn_org=None source=14.1 
 <para>
   So if you index, say, an image collection with a
   <productname>PostgreSQL</productname> B-tree, you can only issue queries
   such as <quote>is imagex equal to imagey</quote>, <quote>is imagex less
   than imagey</quote> and <quote>is imagex greater than imagey</quote>.
   Depending on how you define <quote>equals</quote>, <quote>less than</quote>
   and <quote>greater than</quote> in this context, this could be useful.
   However, by using a <acronym>GiST</acronym> based index, you could create
   ways to ask domain-specific questions, perhaps <quote>find all images of
   horses</quote> or <quote>find all over-exposed images</quote>.
 </para>
________________________________________________________-->
 <para>
   这样如果你用一个<productname>PostgreSQL</productname>的 B 树索引一个图像集合，你只能发出例如<quote>imagex 等于 imagey 吗</quote>、<quote>imagex 小于 imagey 吗</quote>以及<quote>imagex 大于 imagey 吗</quote>的查询。取决于你如何在这种上下文中定义<quote>等于</quote>、<quote>小于</quote>和<quote>大于</quote>，这可能会有用。但是，通过使用一个基于<acronym>GiST</acronym>的索引，你可以创建提问领域相关问题的方法，可能是<quote>找所有马的图片</quote>或者<quote>找所有曝光过度的图片</quote>。
 </para>
<!-- pgdoc-cn_end sig_en=eb6f386029033eddbdf7c7334237f0f0 -->

<!-- pgdoc-cn_start sig_en=0e0fb75462d9de726e18a84f67b5bfd9 sig_cn_org=None source=14.1 
 <para>
   All it takes to get a <acronym>GiST</acronym> access method up and running
   is to implement several user-defined methods, which define the behavior of
   keys in the tree. Of course these methods have to be pretty fancy to
   support fancy queries, but for all the standard queries (B-trees,
   R-trees, etc.) they're relatively straightforward. In short,
   <acronym>GiST</acronym> combines extensibility along with generality, code
   reuse, and a clean interface.
  </para>
________________________________________________________-->
 <para>
   建立一个<acronym>GiST</acronym>访问方法并让其运行的所有工作是实现几个用户定义的方法，它们定义了树中键的行为。当然这些方法必须相当特别来支持特别的查询，但是对于所有标准查询（B 树、R 树等）它们相对直接。简而言之，<acronym>GiST</acronym>在可扩展性之上结合了通用型、代码重用和一个干净的接口。
  </para>
<!-- pgdoc-cn_end sig_en=0e0fb75462d9de726e18a84f67b5bfd9 -->

<!-- pgdoc-cn_start sig_en=423987f0f0cef90522055d466b198c73 sig_cn_org=None source=14.1 
 <para>
   There are five methods that an index operator class for
   <acronym>GiST</acronym> must provide, and six that are optional.
   Correctness of the index is ensured
   by proper implementation of the <function>same</function>, <function>consistent</function>
   and <function>union</function> methods, while efficiency (size and speed) of the
   index will depend on the <function>penalty</function> and <function>picksplit</function>
   methods.
   Two optional methods are <function>compress</function> and
   <function>decompress</function>, which allow an index to have internal tree data of
   a different type than the data it indexes. The leaves are to be of the
   indexed data type, while the other tree nodes can be of any C struct (but
   you still have to follow <productname>PostgreSQL</productname> data type rules here,
   see about <literal>varlena</literal> for variable sized data). If the tree's
   internal data type exists at the SQL level, the <literal>STORAGE</literal> option
   of the <command>CREATE OPERATOR CLASS</command> command can be used.
   The optional eighth method is <function>distance</function>, which is needed
   if the operator class wishes to support ordered scans (nearest-neighbor
   searches). The optional ninth method <function>fetch</function> is needed if the
   operator class wishes to support index-only scans, except when the
   <function>compress</function> method is omitted. The optional tenth method
   <function>options</function> is needed if the operator class has
   user-specified parameters.
   The optional eleventh method <function>sortsupport</function> is used to
   speed up building a <acronym>GiST</acronym> index.
 </para>
________________________________________________________-->
 <para>
   一个用于<acronym>GiST</acronym>的索引操作符类必须提供六种方法，并且还有五种可选的方法。
   索引的正确性由正确实现的<function>same</function>、<function>consistent</function>和<function>union</function>方法保证，而索引的效率（尺寸和速度）将依赖于<function>penalty</function>和<function>picksplit</function>方法。
   两种可选的方法是<function>compress</function>和<function>decompress</function>，它们允许一个索引能对内部数据使用一种不同于被其索引的数据的类型。
   叶子是被索引的数据类型，而其他树结点可以是任何 C 结构（但是你仍必须遵循<productname>PostgreSQL</productname>的数据类型规则，见用于可变尺寸数据的<literal>varlena</literal>）。
   如果树的内部数据类型在 SQL 层上存在，可以使用<command>CREATE OPERATOR CLASS</command>命令的<literal>STORAGE</literal>选项。
   可选的第八个方法是<function>distance</function>，如果操作符类希望支持有序扫描（最近邻搜索）就需要它。
   如果该操作符希望支持只用索引的扫描，则需要可选的第九个方法<function>fetch</function>，但<function>compress</function>方法被省略时不需要。
   如果操作符类有用户指定的参数，则需要第10个<function>options</function>方法选项。
   可选的第十一种方法<function>sortsupport</function>用于加速构建<acronym>GiST</acronym>索引。
 </para>
<!-- pgdoc-cn_end sig_en=423987f0f0cef90522055d466b198c73 -->

 <variablelist>
    <varlistentry>
     <term><function>consistent</function></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=17caa7e47295b092f7bc0bba40977f87 sig_cn_org=None source=14.1 
      <para>
       Given an index entry <literal>p</literal> and a query value <literal>q</literal>,
       this function determines whether the index entry is
       <quote>consistent</quote> with the query; that is, could the predicate
       <quote><replaceable>indexed_column</replaceable>
       <replaceable>indexable_operator</replaceable> <literal>q</literal></quote> be true for
       any row represented by the index entry?  For a leaf index entry this is
       equivalent to testing the indexable condition, while for an internal
       tree node this determines whether it is necessary to scan the subtree
       of the index represented by the tree node.  When the result is
       <literal>true</literal>, a <literal>recheck</literal> flag must also be returned.
       This indicates whether the predicate is certainly true or only possibly
       true.  If <literal>recheck</literal> = <literal>false</literal> then the index has
       tested the predicate condition exactly, whereas if <literal>recheck</literal>
       = <literal>true</literal> the row is only a candidate match.  In that case the
       system will automatically evaluate the
       <replaceable>indexable_operator</replaceable> against the actual row value to see
       if it is really a match.  This convention allows
       <acronym>GiST</acronym> to support both lossless and lossy index
       structures.
      </para>
________________________________________________________-->
      <para>
       给定一个索引项<literal>p</literal>和一个查询值<literal>q</literal>，这个函数决定该索引项是否与该查询<quote>一致</quote>，就是说：是否该索引项表示的行使得谓词<quote><replaceable>indexed_column</replaceable><replaceable>indexable_operator</replaceable> <literal>q</literal></quote>为真？对于一个叶子索引项，这等效于测试索引条件；而对于一个内部树结点，这会决定是否需要扫描由该树结点表示的索引子树。当结果为<literal>true</literal>时，还必须返回一个<literal>recheck</literal>标志。这指示该谓词一定为真或者只是可能为真。如果<literal>recheck</literal> = <literal>false</literal>那么该索引已经完全测试过该谓词条件，而如果<literal>recheck</literal> = <literal>true</literal>则该行只是一个候选匹配。在那种情况下，系统将根据实际的行值自动评估<replaceable>indexable_operator</replaceable>来看它是否真的是一个匹配。这允许<acronym>GiST</acronym>同时支持有损和无损的索引结构。
      </para>
<!-- pgdoc-cn_end sig_en=17caa7e47295b092f7bc0bba40977f87 -->

<!-- pgdoc-cn_start sig_en=f7101bd884edcdfef73cfa54aaf026ff sig_cn_org=None source=14.1 
      <para>
        The <acronym>SQL</acronym> declaration of the function must look like this:

<programlisting>
CREATE OR REPLACE FUNCTION my_consistent(internal, data_type, smallint, oid, internal)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        And the matching code in the C module could then follow this skeleton:

<programlisting>
PG_FUNCTION_INFO_V1(my_consistent);

Datum
my_consistent(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    data_type  *query = PG_GETARG_DATA_TYPE_P(1);
    StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);
    /* Oid subtype = PG_GETARG_OID(3); */
    bool       *recheck = (bool *) PG_GETARG_POINTER(4);
    data_type  *key = DatumGetDataType(entry-&gt;key);
    bool        retval;

    /*
     * determine return value as a function of strategy, key and query.
     *
     * Use GIST_LEAF(entry) to know where you're called in the index tree,
     * which comes handy when supporting the = operator for example (you could
     * check for non empty union() in non-leaf nodes and equality in leaf
     * nodes).
     */

    *recheck = true;        /* or false if check is exact */

    PG_RETURN_BOOL(retval);
}
</programlisting>

       Here, <varname>key</varname> is an element in the index and <varname>query</varname>
       the value being looked up in the index. The <literal>StrategyNumber</literal>
       parameter indicates which operator of your operator class is being
       applied &mdash; it matches one of the operator numbers in the
       <command>CREATE OPERATOR CLASS</command> command.
      </para>
________________________________________________________-->
      <para>
        该函数的<acronym>SQL</acronym>声明必须看起来像这样：

<programlisting>
CREATE OR REPLACE FUNCTION my_consistent(internal, data_type, smallint, oid, internal)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        在 C 模块中匹配的代码则应该遵循这样的框架：

<programlisting>
PG_FUNCTION_INFO_V1(my_consistent);

Datum
my_consistent(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    data_type  *query = PG_GETARG_DATA_TYPE_P(1);
    StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);
    /* Oid subtype = PG_GETARG_OID(3); */
    bool       *recheck = (bool *) PG_GETARG_POINTER(4);
    data_type  *key = DatumGetDataType(entry-&gt;key);
    bool        retval;

    /*
     * 根据策略、键和查询确定返回值。
     *
     * 使用 GIST_LEAF(entry) 可以了解当前函数是在索引树的哪里被调用，
     * 这在支持例如 = 操作符时很方便（可以在非叶子节点中检查非空 union()
     * 以及在叶子节点中检查等值）。
     */

    *recheck = true;        /* 如果检查是准确的则返回 false */

    PG_RETURN_BOOL(retval);
}
</programlisting>

       这里，<varname>key</varname>是该索引中的一个元素而<varname>query</varname>是在该索引中查找的值。<literal>StrategyNumber</literal>参数指示在你的操作符类中哪个操作符被应用 &mdash; 它匹配<command>CREATE OPERATOR CLASS</command>命令中的操作符编号之一。
      </para>
<!-- pgdoc-cn_end sig_en=f7101bd884edcdfef73cfa54aaf026ff -->

<!-- pgdoc-cn_start sig_en=a691e071b08e5413e4ffe58c0279ade9 sig_cn_org=None source=14.1 
      <para>
       Depending on which operators you have included in the class, the data
       type of <varname>query</varname> could vary with the operator, since it will
       be whatever type is on the right-hand side of the operator, which might
       be different from the indexed data type appearing on the left-hand side.
       (The above code skeleton assumes that only one type is possible; if
       not, fetching the <varname>query</varname> argument value would have to depend
       on the operator.)  It is recommended that the SQL declaration of
       the <function>consistent</function> function use the opclass's indexed data
       type for the <varname>query</varname> argument, even though the actual type
       might be something else depending on the operator.
      </para>
________________________________________________________-->
      <para>
       取决于在操作符类中包含着哪些操作符，<varname>query</varname>的数据类型可能随着操作符而变化，因为它可能是该操作符右手边的任何类型，而这种类型可能和出现在其左手边的被索引数据类型不同（上面的代码框架假定只有一种类型；如果不是这样，取<varname>query</varname>参数值的方式可能必须取决于操作符）。
       我们推荐让<function>consistent</function>函数的 SQL 声明对<varname>query</varname>参数使用操作符类的被索引数据类型，即便实际类型可能是其他依赖于操作符的类型也是如此。
      </para>
<!-- pgdoc-cn_end sig_en=a691e071b08e5413e4ffe58c0279ade9 -->

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>union</function></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=bdeccf8ea00f1dba7406b2aa3be86cef sig_cn_org=None source=14.1 
      <para>
       This method consolidates information in the tree.  Given a set of
       entries, this function generates a new index entry that represents
       all the given entries.
      </para>
________________________________________________________-->
      <para>
       这个方法联合树中的信息。给定一组项，这个函数产生一个新的索引项，它表示所有给定的项。
      </para>
<!-- pgdoc-cn_end sig_en=bdeccf8ea00f1dba7406b2aa3be86cef -->

<!-- pgdoc-cn_start sig_en=f32bb5d4dd25e86edaff47e71792f57e sig_cn_org=None source=14.1 
      <para>
        The <acronym>SQL</acronym> declaration of the function must look like this:

<programlisting>
CREATE OR REPLACE FUNCTION my_union(internal, internal)
RETURNS storage_type
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        And the matching code in the C module could then follow this skeleton:

<programlisting>
PG_FUNCTION_INFO_V1(my_union);

Datum
my_union(PG_FUNCTION_ARGS)
{
    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);
    GISTENTRY  *ent = entryvec-&gt;vector;
    data_type  *out,
               *tmp,
               *old;
    int         numranges,
                i = 0;

    numranges = entryvec-&gt;n;
    tmp = DatumGetDataType(ent[0].key);
    out = tmp;

    if (numranges == 1)
    {
        out = data_type_deep_copy(tmp);

        PG_RETURN_DATA_TYPE_P(out);
    }

    for (i = 1; i &lt; numranges; i++)
    {
        old = out;
        tmp = DatumGetDataType(ent[i].key);
        out = my_union_implementation(out, tmp);
    }

    PG_RETURN_DATA_TYPE_P(out);
}
</programlisting>
      </para>
________________________________________________________-->
      <para>
        该函数的<acronym>SQL</acronym>声明必须看起来像这样：

<programlisting>
CREATE OR REPLACE FUNCTION my_union(internal, internal)
RETURNS storage_type
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        在 C 模块中匹配的代码则应该遵循这样的框架：

<programlisting>
PG_FUNCTION_INFO_V1(my_union);

Datum
my_union(PG_FUNCTION_ARGS)
{
    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);
    GISTENTRY  *ent = entryvec-&gt;vector;
    data_type  *out,
               *tmp,
               *old;
    int         numranges,
                i = 0;

    numranges = entryvec-&gt;n;
    tmp = DatumGetDataType(ent[0].key);
    out = tmp;

    if (numranges == 1)
    {
        out = data_type_deep_copy(tmp);

        PG_RETURN_DATA_TYPE_P(out);
    }

    for (i = 1; i &lt; numranges; i++)
    {
        old = out;
        tmp = DatumGetDataType(ent[i].key);
        out = my_union_implementation(out, tmp);
    }

    PG_RETURN_DATA_TYPE_P(out);
}
</programlisting>
      </para>
<!-- pgdoc-cn_end sig_en=f32bb5d4dd25e86edaff47e71792f57e -->

<!-- pgdoc-cn_start sig_en=ef8deba0e8658d9680dfaa57ca29b0b3 sig_cn_org=None source=14.1 
      <para>
        As you can see, in this skeleton we're dealing with a data type
        where <literal>union(X, Y, Z) = union(union(X, Y), Z)</literal>. It's easy
        enough to support data types where this is not the case, by
        implementing the proper union algorithm in this
        <acronym>GiST</acronym> support method.
      </para>
________________________________________________________-->
      <para>
        如你所见，在这个框架中我们处理一种数据类型<literal>union(X, Y, Z) = union(union(X, Y), Z)</literal>。通过在这个<acronym>GiST</acronym>支持方法中实现正确的联合算法，支持不是这种情况的数据类型足够简单。
      </para>
<!-- pgdoc-cn_end sig_en=ef8deba0e8658d9680dfaa57ca29b0b3 -->

<!-- pgdoc-cn_start sig_en=38de4f1c2f158f9f4cf030f83c7ae351 sig_cn_org=None source=14.1 
      <para>
        The result of the <function>union</function> function must be a value of the
        index's storage type, whatever that is (it might or might not be
        different from the indexed column's type).  The <function>union</function>
        function should return a pointer to newly <function>palloc()</function>ed
        memory. You can't just return the input value as-is, even if there is
        no type change.
      </para>
________________________________________________________-->
      <para>
        <function>union</function>函数的结果必须是该索引的存储类型的一个值，它可能与被索引列的类型不同，也可能相同。<function>union</function>函数应该返回一个指针指向新<function>palloc()</function>的内存。不能照原样返回输入值，即使没有类型改变也不能。
      </para>
<!-- pgdoc-cn_end sig_en=38de4f1c2f158f9f4cf030f83c7ae351 -->

<!-- pgdoc-cn_start sig_en=0fdeab5f7916c122251db5617a1964d2 sig_cn_org=None source=14.1 
      <para>
       As shown above, the <function>union</function> function's
       first <type>internal</type> argument is actually
       a <structname>GistEntryVector</structname> pointer.  The second argument is a
       pointer to an integer variable, which can be ignored.  (It used to be
       required that the <function>union</function> function store the size of its
       result value into that variable, but this is no longer necessary.)
      </para>
________________________________________________________-->
      <para>
       如上所示，<function>union</function>函数的第一个<type>internal</type>参数实际上是一个<structname>GistEntryVector</structname>指针。第二个参数是一个指向整数变量的指针，它可以被忽略（过去要求<function>union</function>函数将其结果值的尺寸存储在这个变量中，但现在这已不再必要）。
      </para>
<!-- pgdoc-cn_end sig_en=0fdeab5f7916c122251db5617a1964d2 -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>compress</function></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=c326928e855749be3988057ec5a54e1c sig_cn_org=None source=14.1 
      <para>
       Converts a data item into a format suitable for physical storage in
       an index page.
       If the <function>compress</function> method is omitted, data items are stored
       in the index without modification.
      </para>
________________________________________________________-->
      <para>
       把数据项转换成适合于一个索引页面中物理存储的格式。如果<function>compress</function>方法被省略，数据项会被不加修改地存储在索引中。
      </para>
<!-- pgdoc-cn_end sig_en=c326928e855749be3988057ec5a54e1c -->

<!-- pgdoc-cn_start sig_en=2e69e204f72c71c59ffb5863ea8235b5 sig_cn_org=None source=14.1 
      <para>
        The <acronym>SQL</acronym> declaration of the function must look like this:

<programlisting>
CREATE OR REPLACE FUNCTION my_compress(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        And the matching code in the C module could then follow this skeleton:

<programlisting>
PG_FUNCTION_INFO_V1(my_compress);

Datum
my_compress(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    GISTENTRY  *retval;

    if (entry-&gt;leafkey)
    {
        /* replace entry-&gt;key with a compressed version */
        compressed_data_type *compressed_data = palloc(sizeof(compressed_data_type));

        /* fill *compressed_data from entry-&gt;key ... */

        retval = palloc(sizeof(GISTENTRY));
        gistentryinit(*retval, PointerGetDatum(compressed_data),
                      entry-&gt;rel, entry-&gt;page, entry-&gt;offset, FALSE);
    }
    else
    {
        /* typically we needn't do anything with non-leaf entries */
        retval = entry;
    }

    PG_RETURN_POINTER(retval);
}
</programlisting>
      </para>
________________________________________________________-->
      <para>
        该函数的<acronym>SQL</acronym>声明必须看起来像这样：

<programlisting>
CREATE OR REPLACE FUNCTION my_compress(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        在 C 模块中匹配的代码则应该遵循这样的框架：

<programlisting>
PG_FUNCTION_INFO_V1(my_compress);

Datum
my_compress(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    GISTENTRY  *retval;

    if (entry-&gt;leafkey)
    {
        /* 用一个压缩版本替换 entry-&gt;key */
        compressed_data_type *compressed_data = palloc(sizeof(compressed_data_type));

        /* 从 entry-&gt;key ... 填充 *compressed_data */

        retval = palloc(sizeof(GISTENTRY));
        gistentryinit(*retval, PointerGetDatum(compressed_data),
                      entry-&gt;rel, entry-&gt;page, entry-&gt;offset, FALSE);
    }
    else
    {
        /* 通常我们不需要对非叶子项做任何事情 */
        retval = entry;
    }

    PG_RETURN_POINTER(retval);
}
</programlisting>
      </para>
<!-- pgdoc-cn_end sig_en=2e69e204f72c71c59ffb5863ea8235b5 -->

<!-- pgdoc-cn_start sig_en=c92f1f24060abec8386ac30efdec8fec sig_cn_org=None source=14.1 
      <para>
       You have to adapt <replaceable>compressed_data_type</replaceable> to the specific
       type you're converting to in order to compress your leaf nodes, of
       course.
      </para>
________________________________________________________-->
      <para>
       当然，为了压缩你的叶结点，你必须把<replaceable>compressed_data_type</replaceable>改编成你正在转换到的指定类型。
      </para>
<!-- pgdoc-cn_end sig_en=c92f1f24060abec8386ac30efdec8fec -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>decompress</function></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=864f813f9756ff097a28c8c4d813bd8f sig_cn_org=None source=14.1 
      <para>
       Converts the stored representation of a data item into a format that
       can be manipulated by the other GiST methods in the operator class.
       If the <function>decompress</function> method is omitted, it is assumed that
       the other GiST methods can work directly on the stored data format.
       (<function>decompress</function> is not necessarily the reverse of
       the <function>compress</function> method; in particular,
       if <function>compress</function> is lossy then it's impossible
       for <function>decompress</function> to exactly reconstruct the original
       data.  <function>decompress</function> is not necessarily equivalent
       to <function>fetch</function>, either, since the other GiST methods might not
       require full reconstruction of the data.)
      </para>
________________________________________________________-->
      <para>
       将一个数据项的存储表达转换成该操作符类中其他GiST方法能够操纵的格式。如果<function>decompress</function>方法被省略，则假设其他GiST方法能够直接在存储的数据格式上工作（<function>decompress</function>不一定要是<function>compress</function>方法的逆操作，特别是如果<function>compress</function>是有损的，那么<function>decompress</function>是不可能准确地重构原始数据的。<function>decompress</function>也不一定与<function>fetch</function>等效，因为其他GiST方法可能不需要数据的完整重构）。
      </para>
<!-- pgdoc-cn_end sig_en=864f813f9756ff097a28c8c4d813bd8f -->

<!-- pgdoc-cn_start sig_en=dd474d9edb2d4668d15e435cf5456eac sig_cn_org=None source=14.1 
      <para>
        The <acronym>SQL</acronym> declaration of the function must look like this:

<programlisting>
CREATE OR REPLACE FUNCTION my_decompress(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        And the matching code in the C module could then follow this skeleton:

<programlisting>
PG_FUNCTION_INFO_V1(my_decompress);

Datum
my_decompress(PG_FUNCTION_ARGS)
{
    PG_RETURN_POINTER(PG_GETARG_POINTER(0));
}
</programlisting>

        The above skeleton is suitable for the case where no decompression
        is needed.  (But, of course, omitting the method altogether is even
        easier, and is recommended in such cases.)
      </para>
________________________________________________________-->
      <para>
        该函数的<acronym>SQL</acronym>声明必须看起来像这样：

<programlisting>
CREATE OR REPLACE FUNCTION my_decompress(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        在 C 模块中匹配的代码则应该遵循这样的框架：

<programlisting>
PG_FUNCTION_INFO_V1(my_decompress);

Datum
my_decompress(PG_FUNCTION_ARGS)
{
    PG_RETURN_POINTER(PG_GETARG_POINTER(0));
}
</programlisting>

        上述框架适合于不需要解压的情况（但是，将该方法一并省去当然更加容易，并且在这种情况下推荐这样做）。
      </para>
<!-- pgdoc-cn_end sig_en=dd474d9edb2d4668d15e435cf5456eac -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>penalty</function></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=e22b47e10e92b44640ac91a92a312e27 sig_cn_org=None source=14.1 
      <para>
       Returns a value indicating the <quote>cost</quote> of inserting the new
       entry into a particular branch of the tree.  Items will be inserted
       down the path of least <function>penalty</function> in the tree.
       Values returned by <function>penalty</function> should be non-negative.
       If a negative value is returned, it will be treated as zero.
      </para>
________________________________________________________-->
      <para>
       返回一个值，它指示在树的一个特定分支插入新项的<quote>代价</quote>。项将被插入到树中具有最小<function>penalty</function>的路径中。<function>penalty</function>返回的值应该为非负。如果一个赋值被返回，它将被当作零来处理。
      </para>
<!-- pgdoc-cn_end sig_en=e22b47e10e92b44640ac91a92a312e27 -->

<!-- pgdoc-cn_start sig_en=b0889bc6073d6acf9f64d8fdeeca2bfc sig_cn_org=None source=14.1 
      <para>
        The <acronym>SQL</acronym> declaration of the function must look like this:

<programlisting>
CREATE OR REPLACE FUNCTION my_penalty(internal, internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;  -&minus; in some cases penalty functions need not be strict
</programlisting>

        And the matching code in the C module could then follow this skeleton:

<programlisting>
PG_FUNCTION_INFO_V1(my_penalty);

Datum
my_penalty(PG_FUNCTION_ARGS)
{
    GISTENTRY  *origentry = (GISTENTRY *) PG_GETARG_POINTER(0);
    GISTENTRY  *newentry = (GISTENTRY *) PG_GETARG_POINTER(1);
    float      *penalty = (float *) PG_GETARG_POINTER(2);
    data_type  *orig = DatumGetDataType(origentry-&gt;key);
    data_type  *new = DatumGetDataType(newentry-&gt;key);

    *penalty = my_penalty_implementation(orig, new);
    PG_RETURN_POINTER(penalty);
}
</programlisting>

        For historical reasons, the <function>penalty</function> function doesn't
        just return a <type>float</type> result; instead it has to store the value
        at the location indicated by the third argument.  The return
        value per se is ignored, though it's conventional to pass back the
        address of that argument.
      </para>
________________________________________________________-->
      <para>
        该函数的<acronym>SQL</acronym>声明必须看起来像这样：

<programlisting>
CREATE OR REPLACE FUNCTION my_penalty(internal, internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;  -- in some cases penalty functions need not be strict
</programlisting>

        在 C 模块中匹配的代码则应该遵循这样的框架：

<programlisting>
PG_FUNCTION_INFO_V1(my_penalty);

Datum
my_penalty(PG_FUNCTION_ARGS)
{
    GISTENTRY  *origentry = (GISTENTRY *) PG_GETARG_POINTER(0);
    GISTENTRY  *newentry = (GISTENTRY *) PG_GETARG_POINTER(1);
    float      *penalty = (float *) PG_GETARG_POINTER(2);
    data_type  *orig = DatumGetDataType(origentry-&gt;key);
    data_type  *new = DatumGetDataType(newentry-&gt;key);

    *penalty = my_penalty_implementation(orig, new);
    PG_RETURN_POINTER(penalty);
}
</programlisting>

        由于历史原因，<function>penalty</function>函数不只是返回一个<type>float</type>结果，而是必须把该值存储在由第三个参数指定的位置。虽然传回该参数的地址符合惯例，但返回值本身可以被忽略。
      </para>
<!-- pgdoc-cn_end sig_en=b0889bc6073d6acf9f64d8fdeeca2bfc -->

<!-- pgdoc-cn_start sig_en=8f1e4c967394d787e4018bf1d9496f56 sig_cn_org=None source=14.1 
      <para>
        The <function>penalty</function> function is crucial to good performance of
        the index. It'll get used at insertion time to determine which branch
        to follow when choosing where to add the new entry in the tree. At
        query time, the more balanced the index, the quicker the lookup.
      </para>
________________________________________________________-->
      <para>
        <function>penalty</function>函数对于索引的好性能是至关重要的。在插入时，当要选择在树中的哪个位置加入新项时，这个函数有助于决定应该顺着哪个分支进行。在查询时，索引越平衡，查找越快速。
      </para>
<!-- pgdoc-cn_end sig_en=8f1e4c967394d787e4018bf1d9496f56 -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>picksplit</function></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=5e5f30e4de9be1df8f1d3c3a01ece620 sig_cn_org=None source=14.1 
      <para>
       When an index page split is necessary, this function decides which
       entries on the page are to stay on the old page, and which are to move
       to the new page.
      </para>
________________________________________________________-->
      <para>
       当需要一次索引页面分裂时，这个函数决定在该页面上哪些项会留在旧页面上，以及哪些项会移动到新页面上。
      </para>
<!-- pgdoc-cn_end sig_en=5e5f30e4de9be1df8f1d3c3a01ece620 -->

<!-- pgdoc-cn_start sig_en=01554d52d207cde2be663ee301fdcd5b sig_cn_org=None source=14.1 
      <para>
        The <acronym>SQL</acronym> declaration of the function must look like this:

<programlisting>
CREATE OR REPLACE FUNCTION my_picksplit(internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        And the matching code in the C module could then follow this skeleton:

<programlisting>
PG_FUNCTION_INFO_V1(my_picksplit);

Datum
my_picksplit(PG_FUNCTION_ARGS)
{
    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);
    GIST_SPLITVEC *v = (GIST_SPLITVEC *) PG_GETARG_POINTER(1);
    OffsetNumber maxoff = entryvec-&gt;n - 1;
    GISTENTRY  *ent = entryvec-&gt;vector;
    int         i,
                nbytes;
    OffsetNumber *left,
               *right;
    data_type  *tmp_union;
    data_type  *unionL;
    data_type  *unionR;
    GISTENTRY **raw_entryvec;

    maxoff = entryvec-&gt;n - 1;
    nbytes = (maxoff + 1) * sizeof(OffsetNumber);

    v-&gt;spl_left = (OffsetNumber *) palloc(nbytes);
    left = v-&gt;spl_left;
    v-&gt;spl_nleft = 0;

    v-&gt;spl_right = (OffsetNumber *) palloc(nbytes);
    right = v-&gt;spl_right;
    v-&gt;spl_nright = 0;

    unionL = NULL;
    unionR = NULL;

    /* Initialize the raw entry vector. */
    raw_entryvec = (GISTENTRY **) malloc(entryvec-&gt;n * sizeof(void *));
    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))
        raw_entryvec[i] = &amp;(entryvec-&gt;vector[i]);

    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))
    {
        int         real_index = raw_entryvec[i] - entryvec-&gt;vector;

        tmp_union = DatumGetDataType(entryvec-&gt;vector[real_index].key);
        Assert(tmp_union != NULL);

        /*
         * Choose where to put the index entries and update unionL and unionR
         * accordingly. Append the entries to either v-&gt;spl_left or
         * v-&gt;spl_right, and care about the counters.
         */

        if (my_choice_is_left(unionL, curl, unionR, curr))
        {
            if (unionL == NULL)
                unionL = tmp_union;
            else
                unionL = my_union_implementation(unionL, tmp_union);

            *left = real_index;
            ++left;
            ++(v-&gt;spl_nleft);
        }
        else
        {
            /*
             * Same on the right
             */
        }
    }

    v-&gt;spl_ldatum = DataTypeGetDatum(unionL);
    v-&gt;spl_rdatum = DataTypeGetDatum(unionR);
    PG_RETURN_POINTER(v);
}
</programlisting>

       Notice that the <function>picksplit</function> function's result is delivered
       by modifying the passed-in <structname>v</structname> structure.  The return
       value per se is ignored, though it's conventional to pass back the
       address of <structname>v</structname>.
      </para>
________________________________________________________-->
      <para>
        该函数的<acronym>SQL</acronym>声明必须看起来像这样：

<programlisting>
CREATE OR REPLACE FUNCTION my_picksplit(internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        在 C 模块中匹配的代码则应该遵循这样的框架：

<programlisting>
PG_FUNCTION_INFO_V1(my_picksplit);

Datum
my_picksplit(PG_FUNCTION_ARGS)
{
    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);
    GIST_SPLITVEC *v = (GIST_SPLITVEC *) PG_GETARG_POINTER(1);
    OffsetNumber maxoff = entryvec-&gt;n - 1;
    GISTENTRY  *ent = entryvec-&gt;vector;
    int         i,
                nbytes;
    OffsetNumber *left,
               *right;
    data_type  *tmp_union;
    data_type  *unionL;
    data_type  *unionR;
    GISTENTRY **raw_entryvec;

    maxoff = entryvec-&gt;n - 1;
    nbytes = (maxoff + 1) * sizeof(OffsetNumber);

    v-&gt;spl_left = (OffsetNumber *) palloc(nbytes);
    left = v-&gt;spl_left;
    v-&gt;spl_nleft = 0;

    v-&gt;spl_right = (OffsetNumber *) palloc(nbytes);
    right = v-&gt;spl_right;
    v-&gt;spl_nright = 0;

    unionL = NULL;
    unionR = NULL;

    /* 初始化裸的项向量。 */
    raw_entryvec = (GISTENTRY **) malloc(entryvec-&gt;n * sizeof(void *));
    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))
        raw_entryvec[i] = &amp;(entryvec-&gt;vector[i]);

    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))
    {
        int         real_index = raw_entryvec[i] - entryvec-&gt;vector;

        tmp_union = DatumGetDataType(entryvec-&gt;vector[real_index].key);
        Assert(tmp_union != NULL);

        /*
         * 选择在哪里放置索引项并且相应地更新 unionL 和 unionR。
         * 把项追加到 v-&gt;spl_left 或者 v-&gt;spl_right，并且设置好计数器。
         */

        if (my_choice_is_left(unionL, curl, unionR, curr))
        {
            if (unionL == NULL)
                unionL = tmp_union;
            else
                unionL = my_union_implementation(unionL, tmp_union);

            *left = real_index;
            ++left;
            ++(v-&gt;spl_nleft);
        }
        else
        {
            /*
             * 和在右边的过程相同
             */
        }
    }

    v-&gt;spl_ldatum = DataTypeGetDatum(unionL);
    v-&gt;spl_rdatum = DataTypeGetDatum(unionR);
    PG_RETURN_POINTER(v);
}
</programlisting>

       注意<function>picksplit</function>函数的结果通过修改传入的<structname>v</structname>结构来传递。尽管传回<structname>v</structname>的地址符合惯例，但返回值本身可以被忽略。
      </para>
<!-- pgdoc-cn_end sig_en=01554d52d207cde2be663ee301fdcd5b -->

<!-- pgdoc-cn_start sig_en=d260514875eda8ebfab945a68bbfc213 sig_cn_org=None source=14.1 
      <para>
        Like <function>penalty</function>, the <function>picksplit</function> function
        is crucial to good performance of the index.  Designing suitable
        <function>penalty</function> and <function>picksplit</function> implementations
        is where the challenge of implementing well-performing
        <acronym>GiST</acronym> indexes lies.
      </para>
________________________________________________________-->
      <para>
        和<function>penalty</function>一样，<function>picksplit</function>函数对于索引的好性能至关重要。设计合适的<function>penalty</function>和<function>picksplit</function>是实现一个好的<acronym>GiST</acronym>索引中最大的挑战。
      </para>
<!-- pgdoc-cn_end sig_en=d260514875eda8ebfab945a68bbfc213 -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>same</function></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=2051ba4bd47015a764e739a9c7c879fd sig_cn_org=None source=14.1 
      <para>
       Returns true if two index entries are identical, false otherwise.
       (An <quote>index entry</quote> is a value of the index's storage type,
       not necessarily the original indexed column's type.)
      </para>
________________________________________________________-->
      <para>
       如果两个索引项相同则返回真，否则返回假（一个<quote>索引项</quote>是该索引的存储类型的一个值，而不一定是原始被索引列类型的值）。
      </para>
<!-- pgdoc-cn_end sig_en=2051ba4bd47015a764e739a9c7c879fd -->

<!-- pgdoc-cn_start sig_en=71c57c95bbbbbf82f23cf0d24e6fcdac sig_cn_org=None source=14.1 
      <para>
        The <acronym>SQL</acronym> declaration of the function must look like this:

<programlisting>
CREATE OR REPLACE FUNCTION my_same(storage_type, storage_type, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        And the matching code in the C module could then follow this skeleton:

<programlisting>
PG_FUNCTION_INFO_V1(my_same);

Datum
my_same(PG_FUNCTION_ARGS)
{
    prefix_range *v1 = PG_GETARG_PREFIX_RANGE_P(0);
    prefix_range *v2 = PG_GETARG_PREFIX_RANGE_P(1);
    bool       *result = (bool *) PG_GETARG_POINTER(2);

    *result = my_eq(v1, v2);
    PG_RETURN_POINTER(result);
}
</programlisting>

        For historical reasons, the <function>same</function> function doesn't
        just return a Boolean result; instead it has to store the flag
        at the location indicated by the third argument.  The return
        value per se is ignored, though it's conventional to pass back the
        address of that argument.
      </para>
________________________________________________________-->
      <para>
        该函数的<acronym>SQL</acronym>声明必须看起来像这样：

<programlisting>
CREATE OR REPLACE FUNCTION my_same(storage_type, storage_type, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        在 C 模块中匹配的代码则应该遵循这样的框架：

<programlisting>
PG_FUNCTION_INFO_V1(my_same);

Datum
my_same(PG_FUNCTION_ARGS)
{
    prefix_range *v1 = PG_GETARG_PREFIX_RANGE_P(0);
    prefix_range *v2 = PG_GETARG_PREFIX_RANGE_P(1);
    bool       *result = (bool *) PG_GETARG_POINTER(2);

    *result = my_eq(v1, v2);
    PG_RETURN_POINTER(result);
}
</programlisting>

        由于历史原因，<function>same</function>函数不只返回一个布尔结果。相反它必须把该标志存储在第三个参数指示的位置。尽管传回该参数的地址符合惯例，但返回值本身可以被忽略。
      </para>
<!-- pgdoc-cn_end sig_en=71c57c95bbbbbf82f23cf0d24e6fcdac -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>distance</function></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=ec796ae854184667809774b0792cdd66 sig_cn_org=None source=14.1 
      <para>
       Given an index entry <literal>p</literal> and a query value <literal>q</literal>,
       this function determines the index entry's
       <quote>distance</quote> from the query value.  This function must be
       supplied if the operator class contains any ordering operators.
       A query using the ordering operator will be implemented by returning
       index entries with the smallest <quote>distance</quote> values first,
       so the results must be consistent with the operator's semantics.
       For a leaf index entry the result just represents the distance to
       the index entry; for an internal tree node, the result must be the
       smallest distance that any child entry could have.
      </para>
________________________________________________________-->
      <para>
       给定一个索引项<literal>p</literal>和一个查询值<literal>q</literal>，这个函数决定两者之间的<quote>距离</quote>。如果操作符类包含任何排序操作符，就必须提供这个函数。一个使用排序操作符的查询将首先返回具有最小<quote>距离</quote>值的索引项，因此结果必须与操作符的语义一致。对于一个页索引项，结果只表示到索引项的距离；对于一个内部树结点，结果必须是到任何子项的最小距离。
      </para>
<!-- pgdoc-cn_end sig_en=ec796ae854184667809774b0792cdd66 -->

<!-- pgdoc-cn_start sig_en=e8f8d7f8649488a8cc92d4cb4bc6aecc sig_cn_org=None source=14.1 
      <para>
        The <acronym>SQL</acronym> declaration of the function must look like this:

<programlisting>
CREATE OR REPLACE FUNCTION my_distance(internal, data_type, smallint, oid, internal)
RETURNS float8
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        And the matching code in the C module could then follow this skeleton:

<programlisting>
PG_FUNCTION_INFO_V1(my_distance);

Datum
my_distance(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    data_type  *query = PG_GETARG_DATA_TYPE_P(1);
    StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);
    /* Oid subtype = PG_GETARG_OID(3); */
    /* bool *recheck = (bool *) PG_GETARG_POINTER(4); */
    data_type  *key = DatumGetDataType(entry-&gt;key);
    double      retval;

    /*
     * determine return value as a function of strategy, key and query.
     */

    PG_RETURN_FLOAT8(retval);
}
</programlisting>

       The arguments to the <function>distance</function> function are identical to
       the arguments of the <function>consistent</function> function.
      </para>
________________________________________________________-->
      <para>
        该函数的<acronym>SQL</acronym>声明必须看起来像这样：

<programlisting>
CREATE OR REPLACE FUNCTION my_distance(internal, data_type, smallint, oid, internal)
RETURNS float8
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        在 C 模块中匹配的代码则应该遵循这样的框架：

<programlisting>
PG_FUNCTION_INFO_V1(my_distance);

Datum
my_distance(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    data_type  *query = PG_GETARG_DATA_TYPE_P(1);
    StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);
    /* Oid subtype = PG_GETARG_OID(3); */
    /* bool *recheck = (bool *) PG_GETARG_POINTER(4); */
    data_type  *key = DatumGetDataType(entry-&gt;key);
    double      retval;

    /*
     * determine return value as a function of strategy, key and query.
     */

    PG_RETURN_FLOAT8(retval);
}
</programlisting>

       <function>distance</function>函数的参数和<function>consistent</function>函数的相同。
      </para>
<!-- pgdoc-cn_end sig_en=e8f8d7f8649488a8cc92d4cb4bc6aecc -->

<!-- pgdoc-cn_start sig_en=8ef6b7a82c753061264add81a236f69f sig_cn_org=None source=14.1 
      <para>
       Some approximation is allowed when determining the distance, so long
       as the result is never greater than the entry's actual distance. Thus,
       for example, distance to a bounding box is usually sufficient in
       geometric applications.  For an internal tree node, the distance
       returned must not be greater than the distance to any of the child
       nodes. If the returned distance is not exact, the function must set
       <literal>*recheck</literal> to true. (This is not necessary for internal tree
       nodes; for them, the calculation is always assumed to be inexact.) In
       this case the executor will calculate the accurate distance after
       fetching the tuple from the heap, and reorder the tuples if necessary.
      </para>
________________________________________________________-->
      <para>
       在决定距离时允许有某种近似，只要结果不要超过该项的实际距离即可。因此，例如在几何应用中到一个外包盒的距离就足够了。对于一个内部树节点，返回的距离不能超过到其任意一个子节点的距离。如果返回的距离不准确，该函数必须设置<literal>*recheck</literal>为真（这对于内部树节点是不必要的，对于它们，计算总是被假定为不准确）。在这种情况下，执行器将在从堆中取出元组后计算精确的距离，并且在必要时记录这些元组。
      </para>
<!-- pgdoc-cn_end sig_en=8ef6b7a82c753061264add81a236f69f -->

<!-- pgdoc-cn_start sig_en=4a345fea88897c6dc838fc202548a79c sig_cn_org=None source=14.1 
      <para>
       If the distance function returns <literal>*recheck = true</literal> for any
       leaf node, the original ordering operator's return type must
       be <type>float8</type> or <type>float4</type>, and the distance function's
       result values must be comparable to those of the original ordering
       operator, since the executor will sort using both distance function
       results and recalculated ordering-operator results.  Otherwise, the
       distance function's result values can be any finite <type>float8</type>
       values, so long as the relative order of the result values matches the
       order returned by the ordering operator.  (Infinity and minus infinity
       are used internally to handle cases such as nulls, so it is not
       recommended that <function>distance</function> functions return these values.)
      </para>
________________________________________________________-->
      <para>
       如果距离函数对任意叶子节点都返回<literal>*recheck = true</literal>，初始的排序操作符的返回类型必须是<type>float8</type>或者<type>float4</type>，并且距离函数的结果值必须能和初始排序操作符的结果进行比较，因为执行器将使用距离函数结果和重新计算的排序操作符结果进行排序。否则，该距离函数的结果值可以是任意有限的<type>float8</type>值，只要这些结果值的相对顺序匹配该排序操作符返回的顺序（在内部会使用无穷以及负无穷来处理空值等情况，因此我们不推荐<function>distance</function>函数返回这些值）。
      </para>
<!-- pgdoc-cn_end sig_en=4a345fea88897c6dc838fc202548a79c -->

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>fetch</function></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=79b70ff775a57a5c9c515246ce33c4fd sig_cn_org=None source=14.1 
      <para>
       Converts the compressed index representation of a data item into the
       original data type, for index-only scans. The returned data must be an
       exact, non-lossy copy of the originally indexed value.
      </para>
________________________________________________________-->
      <para>
       为只用索引的扫描将一个数据项压缩过的索引表达转换成原始的数据类型。被返回的数据必须是原始被索引值的一份准确的、非有损的拷贝。
      </para>
<!-- pgdoc-cn_end sig_en=79b70ff775a57a5c9c515246ce33c4fd -->

<!-- pgdoc-cn_start sig_en=1b2870f5b352d8d607d5a770d2c6c018 sig_cn_org=None source=14.1 
      <para>
        The <acronym>SQL</acronym> declaration of the function must look like this:

<programlisting>
CREATE OR REPLACE FUNCTION my_fetch(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        The argument is a pointer to a <structname>GISTENTRY</structname> struct. On
        entry, its <structfield>key</structfield> field contains a non-NULL leaf datum in
        compressed form. The return value is another <structname>GISTENTRY</structname>
        struct, whose <structfield>key</structfield> field contains the same datum in its
        original, uncompressed form. If the opclass's compress function does
        nothing for leaf entries, the <function>fetch</function> method can return the
        argument as-is.  Or, if the opclass does not have a compress function,
        the <function>fetch</function> method can be omitted as well, since it would
        necessarily be a no-op.
       </para>
________________________________________________________-->
      <para>
        该函数的<acronym>SQL</acronym>声明必须看起来像这样：

<programlisting>
CREATE OR REPLACE FUNCTION my_fetch(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

        参数是一个指向<structname>GISTENTRY</structname>结构的指针。在项上，它的<structfield>key</structfield>域包含一个压缩形式的非-NULL 叶子数据。返回值是另一个<structname>GISTENTRY</structname>结构，其<structfield>key</structfield>域包含同一数据的原始的未压缩形式。如果操作符类的压缩函数不对叶子项做任何事情，<function>fetch</function>方法可以原样返回参数。或者，如果该opclass没有一个压缩函数，则<function>fetch</function>方法也可以被省略，因为它必须是一个空操作。
       </para>
<!-- pgdoc-cn_end sig_en=1b2870f5b352d8d607d5a770d2c6c018 -->

<!-- pgdoc-cn_start sig_en=95600332a39a5fe7b9e02e2881225d89 sig_cn_org=None source=14.1 
       <para>
        The matching code in the C module could then follow this skeleton:

<programlisting>
PG_FUNCTION_INFO_V1(my_fetch);

Datum
my_fetch(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    input_data_type *in = DatumGetPointer(entry->key);
    fetched_data_type *fetched_data;
    GISTENTRY  *retval;

    retval = palloc(sizeof(GISTENTRY));
    fetched_data = palloc(sizeof(fetched_data_type));

    /*
     * Convert 'fetched_data' into the a Datum of the original datatype.
     */

    /* fill *retval from fetched_data. */
    gistentryinit(*retval, PointerGetDatum(converted_datum),
                  entry->rel, entry->page, entry->offset, FALSE);

    PG_RETURN_POINTER(retval);
}
</programlisting>
      </para>
________________________________________________________-->
       <para>
        C 模块中相应的代码可能会遵循下面的框架：

<programlisting>
PG_FUNCTION_INFO_V1(my_fetch);

Datum
my_fetch(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    input_data_type *in = DatumGetPointer(entry->key);
    fetched_data_type *fetched_data;
    GISTENTRY  *retval;

    retval = palloc(sizeof(GISTENTRY));
    fetched_data = palloc(sizeof(fetched_data_type));

    /*
     * 将 'fetched_data' 转换成原始数据类型的一个 Datum。
     */

    /* 从 fetched_data. 填充 *retval。 */
    gistentryinit(*retval, PointerGetDatum(converted_datum),
                  entry->rel, entry->page, entry->offset, FALSE);

    PG_RETURN_POINTER(retval);
}
</programlisting>
      </para>
<!-- pgdoc-cn_end sig_en=95600332a39a5fe7b9e02e2881225d89 -->

<!-- pgdoc-cn_start sig_en=05b6db335697723f372d4121d5d00551 sig_cn_org=None source=14.1 
      <para>
       If the compress method is lossy for leaf entries, the operator class
       cannot support index-only scans, and must not define
       a <function>fetch</function> function.
      </para>
________________________________________________________-->
      <para>
       如果该压缩方法对于叶子项是有损的，操作符类就不能支持只用索引的扫描，并且不能定义<function>fetch</function>函数。
      </para>
<!-- pgdoc-cn_end sig_en=05b6db335697723f372d4121d5d00551 -->

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>options</function></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=b19a172c4345434dfaf27918c4294f82 sig_cn_org=None source=14.1 
      <para>
       Allows definition of user-visible parameters that control operator
       class behavior.
      </para>
________________________________________________________-->
      <para>
       允许定义控制操作符类行为的用户可见参数。
      </para>
<!-- pgdoc-cn_end sig_en=b19a172c4345434dfaf27918c4294f82 -->

<!-- pgdoc-cn_start sig_en=e1bc31518367487ed67939889b20e5e4 sig_cn_org=None source=14.1 
      <para>
        The <acronym>SQL</acronym> declaration of the function must look like this:

<programlisting>
CREATE OR REPLACE FUNCTION my_options(internal)
RETURNS void
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>
      </para>
________________________________________________________-->
      <para>
        该函数的<acronym>SQL</acronym>声明必须看起来如下所示:

<programlisting>
CREATE OR REPLACE FUNCTION my_options(internal)
RETURNS void
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>
      </para>
<!-- pgdoc-cn_end sig_en=e1bc31518367487ed67939889b20e5e4 -->

<!-- pgdoc-cn_start sig_en=05ae6edaf070b86f092a6e322a7a0620 sig_cn_org=None source=14.1 
      <para>
       The function is passed a pointer to a <structname>local_relopts</structname>
       struct, which needs to be filled with a set of operator class
       specific options.  The options can be accessed from other support
       functions using the <literal>PG_HAS_OPCLASS_OPTIONS()</literal> and
       <literal>PG_GET_OPCLASS_OPTIONS()</literal> macros.
      </para>
________________________________________________________-->
      <para>
       向函数传递一个指向<structname>local_relopts</structname>结构体的指针，该结构体需要用一组特定于操作符类的选项来填充。
       可以使用<literal>PG_HAS_OPCLASS_OPTIONS()</literal> 和 <literal>PG_GET_OPCLASS_OPTIONS()</literal>宏从其他支持函数访问这些选项。
      </para>
<!-- pgdoc-cn_end sig_en=05ae6edaf070b86f092a6e322a7a0620 -->

<!-- pgdoc-cn_start sig_en=fa477fb591998a53b40198f034861b7f sig_cn_org=None source=14.1 
       <para>
        An example implementation of my_options() and parameters use
        from other support functions are given below:

<programlisting>
typedef enum MyEnumType
{
    MY_ENUM_ON,
    MY_ENUM_OFF,
    MY_ENUM_AUTO
} MyEnumType;

typedef struct
{
    int32   vl_len_;    /* varlena header (do not touch directly!) */
    int     int_param;  /* integer parameter */
    double  real_param; /* real parameter */
    MyEnumType enum_param; /* enum parameter */
    int     str_param;  /* string parameter */
} MyOptionsStruct;

/* String representation of enum values */
static relopt_enum_elt_def myEnumValues[] =
{
    {"on", MY_ENUM_ON},
    {"off", MY_ENUM_OFF},
    {"auto", MY_ENUM_AUTO},
    {(const char *) NULL}   /* list terminator */
};

static char *str_param_default = "default";

/*
 * Sample validator: checks that string is not longer than 8 bytes.
 */
static void
validate_my_string_relopt(const char *value)
{
    if (strlen(value) > 8)
        ereport(ERROR,
                (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
                 errmsg("str_param must be at most 8 bytes")));
}

/*
 * Sample filler: switches characters to lower case.
 */
static Size
fill_my_string_relopt(const char *value, void *ptr)
{
    char   *tmp = str_tolower(value, strlen(value), DEFAULT_COLLATION_OID);
    int     len = strlen(tmp);

    if (ptr)
        strcpy((char *) ptr, tmp);

    pfree(tmp);
    return len + 1;
}

PG_FUNCTION_INFO_V1(my_options);

Datum
my_options(PG_FUNCTION_ARGS)
{
    local_relopts *relopts = (local_relopts *) PG_GETARG_POINTER(0);

    init_local_reloptions(relopts, sizeof(MyOptionsStruct));
    add_local_int_reloption(relopts, "int_param", "integer parameter",
                            100, 0, 1000000,
                            offsetof(MyOptionsStruct, int_param));
    add_local_real_reloption(relopts, "real_param", "real parameter",
                             1.0, 0.0, 1000000.0,
                             offsetof(MyOptionsStruct, real_param));
    add_local_enum_reloption(relopts, "enum_param", "enum parameter",
                             myEnumValues, MY_ENUM_ON,
                             "Valid values are: \"on\", \"off\" and \"auto\".",
                             offsetof(MyOptionsStruct, enum_param));
    add_local_string_reloption(relopts, "str_param", "string parameter",
                               str_param_default,
                               &amp;validate_my_string_relopt,
                               &amp;fill_my_string_relopt,
                               offsetof(MyOptionsStruct, str_param));

    PG_RETURN_VOID();
}

PG_FUNCTION_INFO_V1(my_compress);

Datum
my_compress(PG_FUNCTION_ARGS)
{
    int     int_param = 100;
    double  real_param = 1.0;
    MyEnumType enum_param = MY_ENUM_ON;
    char   *str_param = str_param_default;

    /*
     * Normally, when opclass contains 'options' method, then options are always
     * passed to support functions.  However, if you add 'options' method to
     * existing opclass, previously defined indexes have no options, so the
     * check is required.
     */
    if (PG_HAS_OPCLASS_OPTIONS())
    {
        MyOptionsStruct *options = (MyOptionsStruct *) PG_GET_OPCLASS_OPTIONS();

        int_param = options->int_param;
        real_param = options->real_param;
        enum_param = options->enum_param;
        str_param = GET_STRING_RELOPTION(options, str_param);
    }

    /* the rest implementation of support function */
}

</programlisting>
      </para>
________________________________________________________-->
       <para>
        下面给出了my_options()和其他支持函数参数的示例实现:

<programlisting>
typedef enum MyEnumType
{
    MY_ENUM_ON,
    MY_ENUM_OFF,
    MY_ENUM_AUTO
} MyEnumType;

typedef struct
{
    int32   vl_len_;    /* varlena header (do not touch directly!) */
    int     int_param;  /* integer parameter */
    double  real_param; /* real parameter */
    MyEnumType enum_param; /* enum parameter */
    int     str_param;  /* string parameter */
} MyOptionsStruct;

/* String representation of enum values */
static relopt_enum_elt_def myEnumValues[] =
{
    {"on", MY_ENUM_ON},
    {"off", MY_ENUM_OFF},
    {"auto", MY_ENUM_AUTO},
    {(const char *) NULL}   /* list terminator */
};

static char *str_param_default = "default";

/*
 * Sample validator: checks that string is not longer than 8 bytes.
 */
static void
validate_my_string_relopt(const char *value)
{
    if (strlen(value) > 8)
        ereport(ERROR,
                (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
                 errmsg("str_param must be at most 8 bytes")));
}

/*
 * Sample filler: switches characters to lower case.
 */
static Size
fill_my_string_relopt(const char *value, void *ptr)
{
    char   *tmp = str_tolower(value, strlen(value), DEFAULT_COLLATION_OID);
    int     len = strlen(tmp);

    if (ptr)
        strcpy((char *) ptr, tmp);

    pfree(tmp);
    return len + 1;
}

PG_FUNCTION_INFO_V1(my_options);

Datum
my_options(PG_FUNCTION_ARGS)
{
    local_relopts *relopts = (local_relopts *) PG_GETARG_POINTER(0);

    init_local_reloptions(relopts, sizeof(MyOptionsStruct));
    add_local_int_reloption(relopts, "int_param", "integer parameter",
                            100, 0, 1000000,
                            offsetof(MyOptionsStruct, int_param));
    add_local_real_reloption(relopts, "real_param", "real parameter",
                             1.0, 0.0, 1000000.0,
                             offsetof(MyOptionsStruct, real_param));
    add_local_enum_reloption(relopts, "enum_param", "enum parameter",
                             myEnumValues, MY_ENUM_ON,
                             "Valid values are: \"on\", \"off\" and \"auto\".",
                             offsetof(MyOptionsStruct, enum_param));
    add_local_string_reloption(relopts, "str_param", "string parameter",
                               str_param_default,
                               &amp;validate_my_string_relopt,
                               &amp;fill_my_string_relopt,
                               offsetof(MyOptionsStruct, str_param));

    PG_RETURN_VOID();
}

PG_FUNCTION_INFO_V1(my_compress);

Datum
my_compress(PG_FUNCTION_ARGS)
{
    int     int_param = 100;
    double  real_param = 1.0;
    MyEnumType enum_param = MY_ENUM_ON;
    char   *str_param = str_param_default;

    /*
     * Normally, when opclass contains 'options' method, then options are always
     * passed to support functions.  However, if you add 'options' method to
     * existing opclass, previously defined indexes have no options, so the
     * check is required.
     */
    if (PG_HAS_OPCLASS_OPTIONS())
    {
        MyOptionsStruct *options = (MyOptionsStruct *) PG_GET_OPCLASS_OPTIONS();

        int_param = options->int_param;
        real_param = options->real_param;
        enum_param = options->enum_param;
        str_param = GET_STRING_RELOPTION(options, str_param);
    }

    /* the rest implementation of support function */
}

</programlisting>
      </para>
<!-- pgdoc-cn_end sig_en=fa477fb591998a53b40198f034861b7f -->

<!-- pgdoc-cn_start sig_en=3bb47bf752e4bb7427c2cdeac86d1560 sig_cn_org=None source=14.1 
      <para>
       Since the representation of the key in <acronym>GiST</acronym> is
       flexible, it may depend on user-specified parameters.  For instance,
       the length of key signature may be specified.  See
       <literal>gtsvector_options()</literal> for example.
      </para>
________________________________________________________-->
      <para>
       由于<acronym>GiST</acronym>中的键表示是弹性的，它可能依赖于用户指定的参数。
       例如，可以指定密钥签名的长度。示例可参见<literal>gtsvector_options()</literal>。
      </para>
<!-- pgdoc-cn_end sig_en=3bb47bf752e4bb7427c2cdeac86d1560 -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>sortsupport</function></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=e1b49521f4ae548a415e321f3522ee38 sig_cn_org=None source=14.1 
      <para>
       Returns a comparator function to sort data in a way that preserves
       locality. It is used by <command>CREATE INDEX</command> and
       <command>REINDEX</command> commands. The quality of the created index
       depends on how well the sort order determined by the comparator function
       preserves locality of the inputs.
      </para>
________________________________________________________-->
      <para>
       返回一个比较器函数来排序数据，以保留位置的方式。
       它被<command>CREATE INDEX</command>和<command>REINDEX</command>命令使用。
       创建索引的质量取决于排序顺序的好坏，而排序顺序的质量则是由输入的比较器函数保留位置所决定的。
      </para>
<!-- pgdoc-cn_end sig_en=e1b49521f4ae548a415e321f3522ee38 -->
<!-- pgdoc-cn_start sig_en=71d6530098fde3c79084e551a36ea669 sig_cn_org=None source=14.1 
      <para>
       The <function>sortsupport</function> method is optional. If it is not
       provided, <command>CREATE INDEX</command> builds the index by inserting
       each tuple to the tree using the <function>penalty</function> and
       <function>picksplit</function> functions, which is much slower.
      </para>
________________________________________________________-->
      <para>
       <function>sortsupport</function>方法是可选的。
       如果它没有被提供，<command>CREATE INDEX</command> 命令通过使用<function>penalty</function> 和 <function>picksplit</function> 函数把每个元组插入到树来构建索引，这要慢得多。
      </para>
<!-- pgdoc-cn_end sig_en=71d6530098fde3c79084e551a36ea669 -->

<!-- pgdoc-cn_start sig_en=72569eb6115fdde354b189bff0c4b7e5 sig_cn_org=None source=14.1 
      <para>
       The <acronym>SQL</acronym> declaration of the function must look like
       this:

<programlisting>
CREATE OR REPLACE FUNCTION my_sortsupport(internal)
RETURNS void
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

       The argument is a pointer to a <structname>SortSupport</structname>
       struct. At a minimum, the function must fill in its comparator field.
       The comparator takes three arguments: two Datums to compare, and
       a pointer to the <structname>SortSupport</structname> struct. The
       Datums are the two indexed values in the format that they are stored
       in the index; that is, in the format returned by the
       <function>compress</function> method. The full API is defined in
       <filename>src/include/utils/sortsupport.h</filename>.
       </para>
________________________________________________________-->
      <para>
        函数的 <acronym>SQL</acronym> 声明必须看起来像这样：

<programlisting>
CREATE OR REPLACE FUNCTION my_sortsupport(internal)
RETURNS void
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</programlisting>

       参数指向到<structname>SortSupport</structname>结构。
       至少，函数必须填写它的比较器区域。
       比较器有三个参数：两个要进行比较的数据，还有一个指向<structname>SortSupport</structname> 结构的指针。
       数据是两个索引值，以它们在索引中排序的格式的格式；也就是说，以<function>compress</function>方法返回的格式。
       完整的API在<filename>src/include/utils/sortsupport.h</filename>中定义。
       </para>
<!-- pgdoc-cn_end sig_en=72569eb6115fdde354b189bff0c4b7e5 -->

<!-- pgdoc-cn_start sig_en=4f58beab48338fea13dac55c6508ebbc sig_cn_org=None source=14.1 
       <para>
        The matching code in the C module could then follow this skeleton:

<programlisting>
PG_FUNCTION_INFO_V1(my_sortsupport);

static int
my_fastcmp(Datum x, Datum y, SortSupport ssup)
{
  /* establish order between x and y by computing some sorting value z */

  int z1 = ComputeSpatialCode(x);
  int z2 = ComputeSpatialCode(y);

  return z1 == z2 ? 0 : z1 > z2 ? 1 : -1;
}

Datum
my_sortsupport(PG_FUNCTION_ARGS)
{
  SortSupport ssup = (SortSupport) PG_GETARG_POINTER(0);

  ssup->comparator = my_fastcmp;
  PG_RETURN_VOID();
}
</programlisting>
      </para>
________________________________________________________-->
       <para>
        C模块中的匹配代码可以遵循下述这样的框架:

<programlisting>
PG_FUNCTION_INFO_V1(my_sortsupport);

static int
my_fastcmp(Datum x, Datum y, SortSupport ssup)
{
  /* establish order between x and y by computing some sorting value z */

  int z1 = ComputeSpatialCode(x);
  int z2 = ComputeSpatialCode(y);

  return z1 == z2 ? 0 : z1 > z2 ? 1 : -1;
}

Datum
my_sortsupport(PG_FUNCTION_ARGS)
{
  SortSupport ssup = (SortSupport) PG_GETARG_POINTER(0);

  ssup->comparator = my_fastcmp;
  PG_RETURN_VOID();
}
</programlisting>
      </para>
<!-- pgdoc-cn_end sig_en=4f58beab48338fea13dac55c6508ebbc -->
     </listitem>
    </varlistentry>
  </variablelist>

<!-- pgdoc-cn_start sig_en=19a9611de0693a13f51856e1e3f22fbd sig_cn_org=None source=14.1 
  <para>
   All the GiST support methods are normally called in short-lived memory
   contexts; that is, <varname>CurrentMemoryContext</varname> will get reset after
   each tuple is processed.  It is therefore not very important to worry about
   pfree'ing everything you palloc.  However, in some cases it's useful for a
   support method to cache data across repeated calls.  To do that, allocate
   the longer-lived data in <literal>fcinfo-&gt;flinfo-&gt;fn_mcxt</literal>, and
   keep a pointer to it in <literal>fcinfo-&gt;flinfo-&gt;fn_extra</literal>.  Such
   data will survive for the life of the index operation (e.g., a single GiST
   index scan, index build, or index tuple insertion).  Be careful to pfree
   the previous value when replacing a <literal>fn_extra</literal> value, or the leak
   will accumulate for the duration of the operation.
  </para>
________________________________________________________-->
  <para>
   所有的 GiST 支持方法通常都在一个短暂存在的内存上下文中被调用；就是说，每个元组被处理之后<varname>CurrentMemoryContext</varname>将被重置。因此没有必要操心释放你 palloc 的所有东西。但是，在某些情况下，一个支持方法在重复调用之间缓存数据是有用的。要这样做，将这些长期生存的数据分配在<literal>fcinfo-&gt;flinfo-&gt;fn_mcxt</literal>中，并且在<literal>fcinfo-&gt;flinfo-&gt;fn_extra</literal>中保持一个到它的指针。这种数据将在索引操作期间都存在（例如一次 GiST 索引扫描、索引构建或索引元组插入）。注意当替换一个<literal>fn_extra</literal>值时要释放之前的值，否则在操作期间该泄露会累积。
  </para>
<!-- pgdoc-cn_end sig_en=19a9611de0693a13f51856e1e3f22fbd -->

</sect1>

<sect1 id="gist-implementation">
<!-- pgdoc-cn_start sig_en=05afc0ba076ec1f3b376592bf28077e0 sig_cn_org=None source=14.1 
 <title>Implementation</title>
________________________________________________________-->
 <title>实现</title>
<!-- pgdoc-cn_end sig_en=05afc0ba076ec1f3b376592bf28077e0 -->

 <sect2 id="gist-buffering-build">
<!-- pgdoc-cn_start sig_en=49faaeee5911a2ac84b6fad868432e70 sig_cn_org=None source=14.1 
  <title>GiST Index Build Methods</title>
________________________________________________________-->
  <title>GiST 索引构建方法</title>
<!-- pgdoc-cn_end sig_en=49faaeee5911a2ac84b6fad868432e70 -->

<!-- pgdoc-cn_start sig_en=fe41d65ea5d78077196fea22113ac21f sig_cn_org=None source=14.1 
  <para>
   The simplest way to build a GiST index is just to insert all the entries,
   one by one.  This tends to be slow for large indexes, because if the
   index tuples are scattered across the index and the index is large enough
   to not fit in cache, a lot of random I/O will be
   needed.  <productname>PostgreSQL</productname> supports two alternative
   methods for initial build of a GiST index: <firstterm>sorted</firstterm>
   and <firstterm>buffered</firstterm> modes.
  </para>
________________________________________________________-->
  <para>
   构建GiST索引最简单的方法就是插入全部条目，一个接一个。
   对大的索引这个会趋向于变慢，因为如果索引元组是分散的跨越索引，并且索引大到Cache容不下的时候，将会需要大量随机I/O。
   <productname>PostgreSQL</productname>支持两个可供选择的方法以供GiST索引的初始化构建：<firstterm>sorted</firstterm> 和 <firstterm>buffered</firstterm> 方法。
  </para>
<!-- pgdoc-cn_end sig_en=fe41d65ea5d78077196fea22113ac21f -->

<!-- pgdoc-cn_start sig_en=73ab624e72cf5070c4426e0fd551c388 sig_cn_org=None source=14.1 
  <para>
   The sorted method is only available if each of the opclasses used by the
   index provides a <function>sortsupport</function> function, as described
   in <xref linkend="gist-extensibility"/>.  If they do, this method is
   usually the best, so it is used by default.
  </para>
________________________________________________________-->
  <para>
   排序(sorted)的方法仅在用于索引的每个opclasses提供<function>sortsupport</function>函数的时候有效，就像<xref linkend="gist-extensibility"/>中所描述的。
   如果满足，这个方法通常是最好的，所以它是缺省使用的。
  </para>
<!-- pgdoc-cn_end sig_en=73ab624e72cf5070c4426e0fd551c388 -->

<!-- pgdoc-cn_start sig_en=5e8ae16a1f22b3eb24e800547302f4f4 sig_cn_org=None source=14.1 
  <para>
   The buffered method works by not inserting tuples directly into the index
   right away.  It can dramatically reduce the amount of random I/O needed
   for non-ordered data sets.  For well-ordered data sets the benefit is
   smaller or non-existent, because only a small number of pages receive new
   tuples at a time, and those pages fit in cache even if the index as a
   whole does not.
  </para>
________________________________________________________-->
  <para>
   缓冲(buffered)的方法不直接立刻插入元组到索引。
   它能明显的减少非排序数据集所需要的随机I/O的数量。
   对于良好排序的数据集，这个收益很小甚至不存在，因为那时只有少数页面会接收新元组，并且那些页面也适合缓存，即便整个索引不能放在缓存中。
  </para>
<!-- pgdoc-cn_end sig_en=5e8ae16a1f22b3eb24e800547302f4f4 -->

<!-- pgdoc-cn_start sig_en=f2bd578424b4a54983c3c07a4cd649a9 sig_cn_org=None source=14.1 
  <para>
   The buffered method needs to call the <function>penalty</function>
   function more often than the simple method does, which consumes some
   extra CPU resources. Also, the buffers need temporary disk space, up to
   the size of the resulting index. Buffering can also influence the quality
   of the resulting index, in both positive and negative directions. That
   influence depends on various factors, like the distribution of the input
   data and the operator class implementation.
  </para>
________________________________________________________-->
  <para>
   缓冲方法比简单的方法需要更频繁的调用<function>penalty</function>，这样会消耗额外的CPU资源。
   还有，缓冲需要临时磁盘空间，最大为结果索引的尺寸。
   缓冲也可能影响结果索引的质量，不管是正向还是负向。
   这种影响取决于多种因素，如输入数据的分布和操作符类的实现。
  </para>
<!-- pgdoc-cn_end sig_en=f2bd578424b4a54983c3c07a4cd649a9 -->

<!-- pgdoc-cn_start sig_en=eb3fa4a9bb0fe4bdf5cafa9bd21be827 sig_cn_org=None source=14.1 
  <para>
   If sorting is not possible, then by default a GiST index build switches
   to the buffering method when the index size reaches
   <xref linkend="guc-effective-cache-size"/>.  Buffering can be manually
   forced or prevented by the <literal>buffering</literal> parameter to the
   CREATE INDEX command.  The default behavior is good for most cases, but
   turning buffering off might speed up the build somewhat if the input data
   is ordered.
  </para>
________________________________________________________-->
  <para>
   如果排序为不可能，则默认情况下，当索引尺寸达到<xref linkend="guc-effective-cache-size"/>时，一个 GiST 索引构建会切换到缓冲方法。
   缓冲可以通过 CREATE INDEX 命令的<literal>buffering</literal>参数手工强制或阻止。
   默认行为对大部分情况是好的，但是如果输入数据是排序好的，关闭缓冲特性可能会加速构建过程。
  </para>
<!-- pgdoc-cn_end sig_en=eb3fa4a9bb0fe4bdf5cafa9bd21be827 -->

 </sect2>
</sect1>

<sect1 id="gist-examples">
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
 <title>Examples</title>
________________________________________________________-->
 <title>示例</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=6ff10bba8774ab13b6ba21db9940324f sig_cn_org=None source=14.1 
 <para>
  The <productname>PostgreSQL</productname> source distribution includes
  several examples of index methods implemented using
  <acronym>GiST</acronym>.  The core system currently provides text search
  support (indexing for <type>tsvector</type> and <type>tsquery</type>) as well as
  R-Tree equivalent functionality for some of the built-in geometric data types
  (see <filename>src/backend/access/gist/gistproc.c</filename>).  The following
  <filename>contrib</filename> modules also contain <acronym>GiST</acronym>
  operator classes:

 <variablelist>
  <varlistentry>
   <term><filename>btree_gist</filename></term>
   <listitem>
    <para>B-tree equivalent functionality for several data types</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>cube</filename></term>
   <listitem>
    <para>Indexing for multidimensional cubes</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>hstore</filename></term>
   <listitem>
    <para>Module for storing (key, value) pairs</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>intarray</filename></term>
   <listitem>
    <para>RD-Tree for one-dimensional array of int4 values</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>ltree</filename></term>
   <listitem>
    <para>Indexing for tree-like structures</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>pg_trgm</filename></term>
   <listitem>
    <para>Text similarity using trigram matching</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>seg</filename></term>
   <listitem>
    <para>Indexing for <quote>float ranges</quote></para>
   </listitem>
  </varlistentry>
 </variablelist>
 </para>
________________________________________________________-->
 <para>
  <productname>PostgreSQL</productname>源码包包括了多个用<acronym>GiST</acronym>实现的索引方法的例子。核心系统当前提供文本搜索支持（用于<type>tsvector</type>和<type>tsquery</type>的索引）以及用于一些内建几何数据类型（<filename>src/backend/access/gist/gistproc.c</filename>）的 R 树等效功能。下列<filename>contrib</filename>模块也包含<acronym>GiST</acronym>操作符类：

 <variablelist>
  <varlistentry>
   <term><filename>btree_gist</filename></term>
   <listitem>
    <para>多种数据类型的 B 树等效功能</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>cube</filename></term>
   <listitem>
    <para>多维立方体的索引</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>hstore</filename></term>
   <listitem>
    <para>存储键值对的模块</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>intarray</filename></term>
   <listitem>
    <para>一维 int4 值数组的 RD 树</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>ltree</filename></term>
   <listitem>
    <para>树状结构的索引</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>pg_trgm</filename></term>
   <listitem>
    <para>使用 trigram 匹配的文本相似性</para>
   </listitem>
  </varlistentry>

  <varlistentry>
   <term><filename>seg</filename></term>
   <listitem>
    <para><quote>float ranges</quote>的索引</para>
   </listitem>
  </varlistentry>
 </variablelist>
 </para>
<!-- pgdoc-cn_end sig_en=6ff10bba8774ab13b6ba21db9940324f -->

</sect1>

</chapter>
