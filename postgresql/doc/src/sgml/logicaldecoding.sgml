<!-- doc/src/sgml/logicaldecoding.sgml -->
 <chapter id="logicaldecoding">
<!-- pgdoc-cn_start sig_en=5765aea3e63ec3a4c2f7a118b5d0b012 sig_cn_org=None source=14.1 
  <title>Logical Decoding</title>
________________________________________________________-->
  <title>逻辑解码</title>
<!-- pgdoc-cn_end sig_en=5765aea3e63ec3a4c2f7a118b5d0b012 -->
<!-- pgdoc-cn_start sig_en=91d00b1a06d9f745a3eeb874de46419e sig_cn_org=None source=14.1 
  <indexterm zone="logicaldecoding">
   <primary>Logical Decoding</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="logicaldecoding">
   <primary>逻辑解码</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=91d00b1a06d9f745a3eeb874de46419e -->
<!-- pgdoc-cn_start sig_en=caa550ab8d2ceef48f75d7aefa4aec70 sig_cn_org=None source=14.1 
  <para>
   PostgreSQL provides infrastructure to stream the modifications performed
   via SQL to external consumers.  This functionality can be used for a
   variety of purposes, including replication solutions and auditing.
  </para>
________________________________________________________-->
  <para>
   PostgreSQL 提供了方法将所执行的修改通过 SQL 以流的方式传送给外部消费者。
   这种功能可以被用于多种目的，包括复制方案以及审计。
  </para>
<!-- pgdoc-cn_end sig_en=caa550ab8d2ceef48f75d7aefa4aec70 -->

<!-- pgdoc-cn_start sig_en=bfc7bca5cb19c628407fadc92c45ac55 sig_cn_org=None source=14.1 
  <para>
   Changes are sent out in streams identified by logical replication slots.
  </para>
________________________________________________________-->
  <para>
   在流中被送出的更改通过逻辑复制槽标识。
  </para>
<!-- pgdoc-cn_end sig_en=bfc7bca5cb19c628407fadc92c45ac55 -->

<!-- pgdoc-cn_start sig_en=69aca6784bb9c0940effa9f0d4335542 sig_cn_org=None source=14.1 
  <para>
   The format in which those changes are streamed is determined by the output
   plugin used.  An example plugin is provided in the PostgreSQL distribution.
   Additional plugins can be
   written to extend the choice of available formats without modifying any
   core code.
   Every output plugin has access to each individual new row produced
   by <command>INSERT</command> and the new row version created
   by <command>UPDATE</command>.  Availability of old row versions for
   <command>UPDATE</command> and <command>DELETE</command> depends on
   the configured replica identity (see <xref linkend="sql-altertable-replica-identity"/>).
  </para>
________________________________________________________-->
  <para>
   流式传输这些更改的格式由使用的输出插件决定。
   PostgreSQL 发布中包括了一个例子插件。
   可以编写额外的插件来扩展可用的格式选择，而无需修改任何核心代码。
   每一个输出插件都能访问每一个由<command>INSERT</command>产生的新行以及每一个由 <command>UPDATE</command>创建的新行版本。
   <command>UPDATE</command>和<command>DELETE</command> 的旧行版本的可用性取决于配置的复制标识（见 <xref linkend="sql-altertable-replica-identity"/>）。
  </para>
<!-- pgdoc-cn_end sig_en=69aca6784bb9c0940effa9f0d4335542 -->

<!-- pgdoc-cn_start sig_en=67421064361658d76c82e85cd382ef1d sig_cn_org=None source=14.1 
  <para>
   Changes can be consumed either using the streaming replication protocol
   (see <xref linkend="protocol-replication"/> and
   <xref linkend="logicaldecoding-walsender"/>), or by calling functions
   via SQL (see <xref linkend="logicaldecoding-sql"/>). It is also possible
   to write additional methods of consuming the output of a replication slot
   without modifying core code
   (see <xref linkend="logicaldecoding-writer"/>).
  </para>
________________________________________________________-->
  <para>
   可以通过流复制协议（见<xref linkend="protocol-replication"/>和
   <xref linkend="logicaldecoding-walsender"/>）或者通过 SQL 调用函数（
   <xref linkend="logicaldecoding-sql"/>）来接收流式传送的更改。也可以编写额外的
   接收复制槽输出的模块而无需修改核心代码（
   <xref linkend="logicaldecoding-writer"/>）。
  </para>
<!-- pgdoc-cn_end sig_en=67421064361658d76c82e85cd382ef1d -->

  <sect1 id="logicaldecoding-example">
<!-- pgdoc-cn_start sig_en=da143fb06fd6d8d9c0ba47516eae570c sig_cn_org=None source=14.1 
   <title>Logical Decoding Examples</title>
________________________________________________________-->
   <title>逻辑解码的例子</title>
<!-- pgdoc-cn_end sig_en=da143fb06fd6d8d9c0ba47516eae570c -->

<!-- pgdoc-cn_start sig_en=d3802df0d50b0f4fbe8f8e9793105666 sig_cn_org=None source=14.1 
   <para>
    The following example demonstrates controlling logical decoding using the
    SQL interface.
   </para>
________________________________________________________-->
   <para>
    下面的例子演示了使用 SQL 接口控制逻辑解码。
   </para>
<!-- pgdoc-cn_end sig_en=d3802df0d50b0f4fbe8f8e9793105666 -->

<!-- pgdoc-cn_start sig_en=cabf40e6cc31762d11e368082723da28 sig_cn_org=None source=14.1 
   <para>
    Before you can use logical decoding, you must set
    <xref linkend="guc-wal-level"/> to <literal>logical</literal> and
    <xref linkend="guc-max-replication-slots"/> to at least 1.  Then, you
    should connect to the target database (in the example
    below, <literal>postgres</literal>) as a superuser.
   </para>
________________________________________________________-->
   <para>
    在你能使用逻辑解码之前，你必须设置<xref linkend="guc-wal-level"/>为
    <literal>logical</literal>，并且<xref linkend="guc-max-replication-slots"/>
    必须至少被设置为 1。然后，你应该作为一个超级用户连接到目标数据库（在下面
    的例子中是<literal>postgres</literal>）。
   </para>
<!-- pgdoc-cn_end sig_en=cabf40e6cc31762d11e368082723da28 -->

<!-- pgdoc-cn_start sig_en=96bbcde3bd622cab37d660602f24b09c sig_cn_org=96bbcde3bd622cab37d660602f24b09c source=15.7 
<programlisting>
postgres=# -&minus; Create a slot named 'regression_slot' using the output plugin 'test_decoding'
postgres=# SELECT * FROM pg_create_logical_replication_slot('regression_slot', 'test_decoding', false, true);
    slot_name    |    lsn
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-
 regression_slot | 0/16B1970
(1 row)

postgres=# SELECT slot_name, plugin, slot_type, database, active, restart_lsn, confirmed_flush_lsn FROM pg_replication_slots;
    slot_name    |    plugin     | slot_type | database | active | restart_lsn | confirmed_flush_lsn
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 regression_slot | test_decoding | logical   | postgres | f      | 0/16A4408   | 0/16A4440
(1 row)

postgres=# -&minus; There are no changes to see yet
postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
 lsn | xid | data
-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-&minus;
(0 rows)

postgres=# CREATE TABLE data(id serial primary key, data text);
CREATE TABLE

postgres=# -&minus; DDL isn't replicated, so all you'll see is the transaction
postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    |  xid  |     data
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 0/BA2DA58 | 10297 | BEGIN 10297
 0/BA5A5A0 | 10297 | COMMIT 10297
(2 rows)

postgres=# -&minus; Once changes are read, they're consumed and not emitted
postgres=# -&minus; in a subsequent call:
postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
 lsn | xid | data
-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-&minus;
(0 rows)

postgres=# BEGIN;
postgres=*# INSERT INTO data(data) VALUES('1');
postgres=*# INSERT INTO data(data) VALUES('2');
postgres=*# COMMIT;

postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    |  xid  |                          data
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 0/BA5A688 | 10298 | BEGIN 10298
 0/BA5A6F0 | 10298 | table public.data: INSERT: id[integer]:1 data[text]:'1'
 0/BA5A7F8 | 10298 | table public.data: INSERT: id[integer]:2 data[text]:'2'
 0/BA5A8A8 | 10298 | COMMIT 10298
(4 rows)

postgres=# INSERT INTO data(data) VALUES('3');

postgres=# -&minus; You can also peek ahead in the change stream without consuming changes
postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL);
    lsn    |  xid  |                          data
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 0/BA5A8E0 | 10299 | BEGIN 10299
 0/BA5A8E0 | 10299 | table public.data: INSERT: id[integer]:3 data[text]:'3'
 0/BA5A990 | 10299 | COMMIT 10299
(3 rows)

postgres=# -&minus; The next call to pg_logical_slot_peek_changes() returns the same changes again
postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL);
    lsn    |  xid  |                          data
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 0/BA5A8E0 | 10299 | BEGIN 10299
 0/BA5A8E0 | 10299 | table public.data: INSERT: id[integer]:3 data[text]:'3'
 0/BA5A990 | 10299 | COMMIT 10299
(3 rows)

postgres=# -&minus; options can be passed to output plugin, to influence the formatting
postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'include-timestamp', 'on');
    lsn    |  xid  |                          data
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 0/BA5A8E0 | 10299 | BEGIN 10299
 0/BA5A8E0 | 10299 | table public.data: INSERT: id[integer]:3 data[text]:'3'
 0/BA5A990 | 10299 | COMMIT 10299 (at 2017-05-10 12:07:21.272494-04)
(3 rows)

postgres=# -&minus; Remember to destroy a slot you no longer need to stop it consuming
postgres=# -&minus; server resources:
postgres=# SELECT pg_drop_replication_slot('regression_slot');
 pg_drop_replication_slot
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-

(1 row)
</programlisting>
________________________________________________________-->
<programlisting>
postgres=# -- Create a slot named 'regression_slot' using the output plugin 'test_decoding'
postgres=# SELECT * FROM pg_create_logical_replication_slot('regression_slot', 'test_decoding', false, true);
    slot_name    |    lsn
-----------------+-----------
 regression_slot | 0/16B1970
(1 row)

postgres=# SELECT slot_name, plugin, slot_type, database, active, restart_lsn, confirmed_flush_lsn FROM pg_replication_slots;
    slot_name    |    plugin     | slot_type | database | active | restart_lsn | confirmed_flush_lsn
-----------------+---------------+-----------+----------+--------+-------------+-----------------
 regression_slot | test_decoding | logical   | postgres | f      | 0/16A4408   | 0/16A4440
(1 row)

postgres=# -- There are no changes to see yet
postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
 lsn | xid | data
-----+-----+------
(0 rows)

postgres=# CREATE TABLE data(id serial primary key, data text);
CREATE TABLE

postgres=# -- DDL isn't replicated, so all you'll see is the transaction
postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    |  xid  |     data
-----------+-------+--------------
 0/BA2DA58 | 10297 | BEGIN 10297
 0/BA5A5A0 | 10297 | COMMIT 10297
(2 rows)

postgres=# -- Once changes are read, they're consumed and not emitted
postgres=# -- in a subsequent call:
postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
 lsn | xid | data
-----+-----+------
(0 rows)

postgres=# BEGIN;
postgres=*# INSERT INTO data(data) VALUES('1');
postgres=*# INSERT INTO data(data) VALUES('2');
postgres=*# COMMIT;

postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    |  xid  |                          data
-----------+-------+---------------------------------------------------------
 0/BA5A688 | 10298 | BEGIN 10298
 0/BA5A6F0 | 10298 | table public.data: INSERT: id[integer]:1 data[text]:'1'
 0/BA5A7F8 | 10298 | table public.data: INSERT: id[integer]:2 data[text]:'2'
 0/BA5A8A8 | 10298 | COMMIT 10298
(4 rows)

postgres=# INSERT INTO data(data) VALUES('3');

postgres=# -- You can also peek ahead in the change stream without consuming changes
postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL);
    lsn    |  xid  |                          data
-----------+-------+---------------------------------------------------------
 0/BA5A8E0 | 10299 | BEGIN 10299
 0/BA5A8E0 | 10299 | table public.data: INSERT: id[integer]:3 data[text]:'3'
 0/BA5A990 | 10299 | COMMIT 10299
(3 rows)

postgres=# -- The next call to pg_logical_slot_peek_changes() returns the same changes again
postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL);
    lsn    |  xid  |                          data
-----------+-------+---------------------------------------------------------
 0/BA5A8E0 | 10299 | BEGIN 10299
 0/BA5A8E0 | 10299 | table public.data: INSERT: id[integer]:3 data[text]:'3'
 0/BA5A990 | 10299 | COMMIT 10299
(3 rows)

postgres=# -- options can be passed to output plugin, to influence the formatting
postgres=# SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'include-timestamp', 'on');
    lsn    |  xid  |                          data
-----------+-------+---------------------------------------------------------
 0/BA5A8E0 | 10299 | BEGIN 10299
 0/BA5A8E0 | 10299 | table public.data: INSERT: id[integer]:3 data[text]:'3'
 0/BA5A990 | 10299 | COMMIT 10299 (at 2017-05-10 12:07:21.272494-04)
(3 rows)

postgres=# -- Remember to destroy a slot you no longer need to stop it consuming
postgres=# -- server resources:
postgres=# SELECT pg_drop_replication_slot('regression_slot');
 pg_drop_replication_slot
-----------------------

(1 row)
</programlisting>
<!-- pgdoc-cn_end sig_en=96bbcde3bd622cab37d660602f24b09c -->

<!-- pgdoc-cn_start sig_en=75a2de540441d5aa208258651b64bda8 sig_cn_org=33f7493f20b0c00473fd958a22c4281b source=15.7 
   <para>
    The following examples shows how logical decoding is controlled over the
    streaming replication protocol, using the
    program <xref linkend="app-pgrecvlogical"/> included in the PostgreSQL
    distribution.  This requires that client authentication is set up to allow
    replication connections
    (see <xref linkend="streaming-replication-authentication"/>) and
    that <varname>max_wal_senders</varname> is set sufficiently high to allow
    an additional connection.  The second example shows how to stream two-phase
    transactions.  Before you use two-phase commands, you must set
    <xref linkend="guc-max-prepared-transactions"/> to at least 1.
   </para>
________________________________________________________-->
   <para>
    以下示例显示了如何通过流复制协议控制逻辑解码，使用PostgreSQL分发中包含的程序<xref linkend="app-pgrecvlogical"/>。
    这要求客户端身份验证已设置为允许复制连接
    (参见<xref linkend="streaming-replication-authentication"/>)，并且<varname>max_wal_senders</varname>设置得足够高，以允许额外的连接。
    第二个示例显示了如何流式传输两阶段事务。在使用两阶段命令之前，必须将<xref linkend="guc-max-prepared-transactions"/>设置为至少1。
</para>
<!-- pgdoc-cn_end sig_en=75a2de540441d5aa208258651b64bda8 -->
<!-- pgdoc-cn_start sig_en=f98d45f2c0d3c6674c3ed063adbaefc9 sig_cn_org=f98d45f2c0d3c6674c3ed063adbaefc9 source=15.7 
<programlisting>
Example 1:
$ pg_recvlogical -d postgres -&minus;slot=test -&minus;create-slot
$ pg_recvlogical -d postgres -&minus;slot=test -&minus;start -f -
<keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo>
$ psql -d postgres -c "INSERT INTO data(data) VALUES('4');"
$ fg
BEGIN 693
table public.data: INSERT: id[integer]:4 data[text]:'4'
COMMIT 693
<keycombo action="simul"><keycap>Control</keycap><keycap>C</keycap></keycombo>
$ pg_recvlogical -d postgres -&minus;slot=test -&minus;drop-slot

Example 2:
$ pg_recvlogical -d postgres -&minus;slot=test -&minus;create-slot -&minus;two-phase
$ pg_recvlogical -d postgres -&minus;slot=test -&minus;start -f -
<keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo>
$ psql -d postgres -c "BEGIN;INSERT INTO data(data) VALUES('5');PREPARE TRANSACTION 'test';"
$ fg
BEGIN 694
table public.data: INSERT: id[integer]:5 data[text]:'5'
PREPARE TRANSACTION 'test', txid 694
<keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo>
$ psql -d postgres -c "COMMIT PREPARED 'test';"
$ fg
COMMIT PREPARED 'test', txid 694
<keycombo action="simul"><keycap>Control</keycap><keycap>C</keycap></keycombo>
$ pg_recvlogical -d postgres -&minus;slot=test -&minus;drop-slot
</programlisting>
________________________________________________________-->
<programlisting>
Example 1:
$ pg_recvlogical -d postgres --slot=test --create-slot
$ pg_recvlogical -d postgres --slot=test --start -f -
<keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo>
$ psql -d postgres -c "INSERT INTO data(data) VALUES('4');"
$ fg
BEGIN 693
table public.data: INSERT: id[integer]:4 data[text]:'4'
COMMIT 693
<keycombo action="simul"><keycap>Control</keycap><keycap>C</keycap></keycombo>
$ pg_recvlogical -d postgres --slot=test --drop-slot

Example 2:
$ pg_recvlogical -d postgres --slot=test --create-slot --two-phase
$ pg_recvlogical -d postgres --slot=test --start -f -
<keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo>
$ psql -d postgres -c "BEGIN;INSERT INTO data(data) VALUES('5');PREPARE TRANSACTION 'test';"
$ fg
BEGIN 694
table public.data: INSERT: id[integer]:5 data[text]:'5'
PREPARE TRANSACTION 'test', txid 694
<keycombo action="simul"><keycap>Control</keycap><keycap>Z</keycap></keycombo>
$ psql -d postgres -c "COMMIT PREPARED 'test';"
$ fg
COMMIT PREPARED 'test', txid 694
<keycombo action="simul"><keycap>Control</keycap><keycap>C</keycap></keycombo>
$ pg_recvlogical -d postgres --slot=test --drop-slot
</programlisting>
<!-- pgdoc-cn_end sig_en=f98d45f2c0d3c6674c3ed063adbaefc9 -->

<!-- pgdoc-cn_start sig_en=861127346730843580b7c630a9b3405b sig_cn_org=None source=14.1 
  <para>
  The following example shows SQL interface that can be used to decode prepared
  transactions. Before you use two-phase commit commands, you must set
  <varname>max_prepared_transactions</varname> to at least 1. You must also have
  set the two-phase parameter as 'true' while creating the slot using
  <function>pg_create_logical_replication_slot</function>
  Note that we will stream the entire transaction after the commit if it
  is not already decoded.
  </para>
________________________________________________________-->
  <para>
  下面的示例展示了可用于解码准备好的事务的SQL接口。
  在使用两阶段提交命令之前，你必须将<varname>max_prepared_transactions</varname>设置到至少为1。
  在使用<function>pg_create_logical_replication_slot</function>创建槽时，还必须将两阶段参数设置为'true'。
  如果尚未解码，注意我们将在提交后流处理整个事务。
  </para>
<!-- pgdoc-cn_end sig_en=861127346730843580b7c630a9b3405b -->
<!-- pgdoc-cn_start sig_en=1461f8fa0f26defbd7ee0e8eee8140ae sig_cn_org=1461f8fa0f26defbd7ee0e8eee8140ae source=15.7 
<programlisting>
postgres=# BEGIN;
postgres=*# INSERT INTO data(data) VALUES('5');
postgres=*# PREPARE TRANSACTION 'test_prepared1';

postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    | xid |                          data
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 0/1689DC0 | 529 | BEGIN 529
 0/1689DC0 | 529 | table public.data: INSERT: id[integer]:3 data[text]:'5'
 0/1689FC0 | 529 | PREPARE TRANSACTION 'test_prepared1', txid 529
(3 rows)

postgres=# COMMIT PREPARED 'test_prepared1';
postgres=# select * from pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    | xid |                    data
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 0/168A060 | 529 | COMMIT PREPARED 'test_prepared1', txid 529
(4 row)

postgres=#-&minus; you can also rollback a prepared transaction
postgres=# BEGIN;
postgres=*# INSERT INTO data(data) VALUES('6');
postgres=*# PREPARE TRANSACTION 'test_prepared2';
postgres=# select * from pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    | xid |                          data
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 0/168A180 | 530 | BEGIN 530
 0/168A1E8 | 530 | table public.data: INSERT: id[integer]:4 data[text]:'6'
 0/168A430 | 530 | PREPARE TRANSACTION 'test_prepared2', txid 530
(3 rows)

postgres=# ROLLBACK PREPARED 'test_prepared2';
postgres=# select * from pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    | xid |                     data
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 0/168A4B8 | 530 | ROLLBACK PREPARED 'test_prepared2', txid 530
(1 row)
</programlisting>
________________________________________________________-->
<programlisting>
postgres=# BEGIN;
postgres=*# INSERT INTO data(data) VALUES('5');
postgres=*# PREPARE TRANSACTION 'test_prepared1';

postgres=# SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    | xid |                          data
-----------+-----+---------------------------------------------------------
 0/1689DC0 | 529 | BEGIN 529
 0/1689DC0 | 529 | table public.data: INSERT: id[integer]:3 data[text]:'5'
 0/1689FC0 | 529 | PREPARE TRANSACTION 'test_prepared1', txid 529
(3 rows)

postgres=# COMMIT PREPARED 'test_prepared1';
postgres=# select * from pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    | xid |                    data
-----------+-----+--------------------------------------------
 0/168A060 | 529 | COMMIT PREPARED 'test_prepared1', txid 529
(4 row)

postgres=#-- you can also rollback a prepared transaction
postgres=# BEGIN;
postgres=*# INSERT INTO data(data) VALUES('6');
postgres=*# PREPARE TRANSACTION 'test_prepared2';
postgres=# select * from pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    | xid |                          data
-----------+-----+---------------------------------------------------------
 0/168A180 | 530 | BEGIN 530
 0/168A1E8 | 530 | table public.data: INSERT: id[integer]:4 data[text]:'6'
 0/168A430 | 530 | PREPARE TRANSACTION 'test_prepared2', txid 530
(3 rows)

postgres=# ROLLBACK PREPARED 'test_prepared2';
postgres=# select * from pg_logical_slot_get_changes('regression_slot', NULL, NULL);
    lsn    | xid |                     data
-----------+-----+----------------------------------------------
 0/168A4B8 | 530 | ROLLBACK PREPARED 'test_prepared2', txid 530
(1 row)
</programlisting>
<!-- pgdoc-cn_end sig_en=1461f8fa0f26defbd7ee0e8eee8140ae -->
</sect1>

  <sect1 id="logicaldecoding-explanation">
<!-- pgdoc-cn_start sig_en=d1353432d5310d03fdcca6600c08c8d8 sig_cn_org=None source=14.1 
   <title>Logical Decoding Concepts</title>
________________________________________________________-->
   <title>逻辑解码概念</title>
<!-- pgdoc-cn_end sig_en=d1353432d5310d03fdcca6600c08c8d8 -->
   <sect2>
<!-- pgdoc-cn_start sig_en=5765aea3e63ec3a4c2f7a118b5d0b012 sig_cn_org=None source=14.1 
    <title>Logical Decoding</title>
________________________________________________________-->
    <title>逻辑解码</title>
<!-- pgdoc-cn_end sig_en=5765aea3e63ec3a4c2f7a118b5d0b012 -->

<!-- pgdoc-cn_start sig_en=8f7077e8c6a29163af96a093db06fc53 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>Logical Decoding</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>逻辑解码</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=8f7077e8c6a29163af96a093db06fc53 -->

<!-- pgdoc-cn_start sig_en=b307193addec72811298dc00a39e237c sig_cn_org=None source=14.1 
    <para>
     Logical decoding is the process of extracting all persistent changes
     to a database's tables into a coherent, easy to understand format which
     can be interpreted without detailed knowledge of the database's internal
     state.
    </para>
________________________________________________________-->
    <para>
     逻辑解码是一种将对数据库表的所有持久更改抽取到一种清晰、易于理解的格式
     的处理，这种技术允许在不了解数据库内部状态的详细知识的前提下解释该格式。
    </para>
<!-- pgdoc-cn_end sig_en=b307193addec72811298dc00a39e237c -->

<!-- pgdoc-cn_start sig_en=5c1963553b7b62e89161b9647ec59e53 sig_cn_org=None source=14.1 
    <para>
     In <productname>PostgreSQL</productname>, logical decoding is implemented
     by decoding the contents of the <link linkend="wal">write-ahead
     log</link>, which describe changes on a storage level, into an
     application-specific form such as a stream of tuples or SQL statements.
    </para>
________________________________________________________-->
    <para>
     在<productname>PostgreSQL</productname>中，逻辑解码通过解码
     <link linkend="wal">预写式日志</link>的内容来实现，预写式日志描述了存储
     层面上的更改，而逻辑解码则会把更改解码成一种应用相关的形式，例如一个元组
     流或者 SQL 语句流。
    </para>
<!-- pgdoc-cn_end sig_en=5c1963553b7b62e89161b9647ec59e53 -->
   </sect2>

   <sect2 id="logicaldecoding-replication-slots">
<!-- pgdoc-cn_start sig_en=54403e923fb60e0c6a8ac1f8e26059a4 sig_cn_org=None source=14.1 
    <title>Replication Slots</title>
________________________________________________________-->
    <title>复制槽</title>
<!-- pgdoc-cn_end sig_en=54403e923fb60e0c6a8ac1f8e26059a4 -->

<!-- pgdoc-cn_start sig_en=367b4fd5edf537e4235694eb25556a19 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>replication slot</primary>
     <secondary>logical replication</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>复制槽</primary>
     <secondary>逻辑复制</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=367b4fd5edf537e4235694eb25556a19 -->

<!-- pgdoc-cn_start sig_en=7099cb4221e5bfd325cd13bbbc7b55b6 sig_cn_org=None source=14.1 
    <para>
     In the context of logical replication, a slot represents a stream of
     changes that can be replayed to a client in the order they were made on
     the origin server. Each slot streams a sequence of changes from a single
     database.
    </para>
________________________________________________________-->
    <para>
     在逻辑复制的环境下，一个槽表示一个更改流，这些更改可以在客户机上以它们在原服务器上产生的顺序被重播。每一个流从一个单一数据库中流式传送更改序列。
    </para>
<!-- pgdoc-cn_end sig_en=7099cb4221e5bfd325cd13bbbc7b55b6 -->

    <note>
<!-- pgdoc-cn_start sig_en=0bad264550365d115a50b791069f07ac sig_cn_org=None source=14.1 
     <para><productname>PostgreSQL</productname> also has streaming replication slots
     (see <xref linkend="streaming-replication"/>), but they are used somewhat
     differently there.
     </para>
________________________________________________________-->
     <para><productname>PostgreSQL</productname>也有流复制槽（见<xref linkend="streaming-replication"/>），但是它们的使用有所不同。
     </para>
<!-- pgdoc-cn_end sig_en=0bad264550365d115a50b791069f07ac -->
    </note>

<!-- pgdoc-cn_start sig_en=7f877e7c512be29bcf80a789f794f98f sig_cn_org=None source=14.1 
    <para>
     A replication slot has an identifier that is unique across all databases
     in a <productname>PostgreSQL</productname> cluster. Slots persist
     independently of the connection using them and are crash-safe.
    </para>
________________________________________________________-->
    <para>
     一个复制槽在一个<productname>PostgreSQL</productname>集簇的所
     有数据库之间具有一个唯一的标识符。槽在使用它们的连接之间保持独立并且
     对于崩溃是安全的。
    </para>
<!-- pgdoc-cn_end sig_en=7f877e7c512be29bcf80a789f794f98f -->

<!-- pgdoc-cn_start sig_en=69d518432eb433082caa2357ddfbbf42 sig_cn_org=None source=14.1 
    <para>
     A logical slot will emit each change just once in normal operation.
     The current position of each slot is persisted only at checkpoint, so in
     the case of a crash the slot may return to an earlier LSN, which will
     then cause recent changes to be sent again when the server restarts.
     Logical decoding clients are responsible for avoiding ill effects from
     handling the same message more than once.  Clients may wish to record
     the last LSN they saw when decoding and skip over any repeated data or
     (when using the replication protocol) request that decoding start from
     that LSN rather than letting the server determine the start point.
     The Replication Progress Tracking feature is designed for this purpose,
     refer to <link linkend="replication-origins">replication origins</link>.
    </para>
________________________________________________________-->
    <para>
     在常规操作中，一个逻辑槽只会把每次更改发出一次。
     只有在检查点时才会持久化每一个槽的当前位置，因此如果发生崩溃，槽可能会回到一个较早的 LSN，这会导致服务器重启时再次发送最近的更改。
     逻辑解码客户端负责避免多次处理同一消息导致的副作用。
     客户端可能会希望在解码时记录它们看到的最新的 LSN，并且跳过任何从该 LSN 解码得到的重复数据或者（使用复制协议时的）请求，而不是让服务器来决定开始点。
     复制进度跟踪特性就是为此服务的，请参考<link linkend="replication-origins">复制源头</link>。
    </para>
<!-- pgdoc-cn_end sig_en=69d518432eb433082caa2357ddfbbf42 -->

<!-- pgdoc-cn_start sig_en=e2e56e7e4d8b0ebd578605f92b037855 sig_cn_org=None source=14.1 
    <para>
     Multiple independent slots may exist for a single database. Each slot has
     its own state, allowing different consumers to receive changes from
     different points in the database change stream. For most applications, a
     separate slot will be required for each consumer.
    </para>
________________________________________________________-->
    <para>
     对于同一个数据库可能会存在多个独立的槽。每一个槽有自己的状态，允许不
     同的消费者从该数据库的更改流中的不同点开始接收更改。对于大多数应用，
     每一个消费者都将要求一个单独的槽。
    </para>
<!-- pgdoc-cn_end sig_en=e2e56e7e4d8b0ebd578605f92b037855 -->

<!-- pgdoc-cn_start sig_en=201ae0fa37a617500db34ab669eb6116 sig_cn_org=None source=14.1 
    <para>
     A logical replication slot knows nothing about the state of the
     receiver(s).  It's even possible to have multiple different receivers using
     the same slot at different times; they'll just get the changes following
     on from when the last receiver stopped consuming them. Only one receiver
     may consume changes from a slot at any given time.
    </para>
________________________________________________________-->
    <para>
     逻辑复制槽完全不知道接收者的状态。甚至可能会有多个不同的接收者在不同
     时间使用同一个槽，它们将只是从上一个接收者停止消费更改的地方开始得到
     更改。但在任一给定时刻，只有一个接收者可以从一个槽中消费更改。
    </para>
<!-- pgdoc-cn_end sig_en=201ae0fa37a617500db34ab669eb6116 -->

    <caution>
<!-- pgdoc-cn_start sig_en=97080d8175b91d03e72f0ab0754dafc6 sig_cn_org=None source=14.1 
     <para>
      Replication slots persist across crashes and know nothing about the state
      of their consumer(s). They will prevent removal of required resources
      even when there is no connection using them. This consumes storage
      because neither required WAL nor required rows from the system catalogs
      can be removed by <command>VACUUM</command> as long as they are required by a replication
      slot.  In extreme cases this could cause the database to shut down to prevent
      transaction ID wraparound (see <xref linkend="vacuum-for-wraparound"/>).
      So if a slot is no longer required it should be dropped.
     </para>
________________________________________________________-->
     <para>
      复制槽可以在崩溃时保持，并且不知道其消费者的状态。即便没有连接使用它们，
      它们也将阻止移除所需的资源。这会消耗存储，因为只要还有一个复制槽需要，
      WAL 和来自于系统目录的行就不能被<command>VACUUM</command>移除。在极端情况下这会导致数据库关闭以防止事务ID回卷（见<xref linkend="vacuum-for-wraparound"/>）。因此如果不再需要一个槽，那就应该删除它。
     </para>
<!-- pgdoc-cn_end sig_en=97080d8175b91d03e72f0ab0754dafc6 -->
    </caution>
   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=ded379b5949495b55be2d933191ceb69 sig_cn_org=None source=14.1 
    <title>Output Plugins</title>
________________________________________________________-->
    <title>输出插件</title>
<!-- pgdoc-cn_end sig_en=ded379b5949495b55be2d933191ceb69 -->
<!-- pgdoc-cn_start sig_en=3705e8c96137a7fb8198cd3f867de106 sig_cn_org=None source=14.1 
    <para>
     Output plugins transform the data from the write-ahead log's internal
     representation into the format the consumer of a replication slot desires.
    </para>
________________________________________________________-->
    <para>
     输出插件将数据从预写式日志的内部表示转换成复制槽的消费者所需的格式。
    </para>
<!-- pgdoc-cn_end sig_en=3705e8c96137a7fb8198cd3f867de106 -->
   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=e09b524131dc5b18ce4f62eb330238fe sig_cn_org=None source=14.1 
    <title>Exported Snapshots</title>
________________________________________________________-->
    <title>导出快照</title>
<!-- pgdoc-cn_end sig_en=e09b524131dc5b18ce4f62eb330238fe -->
<!-- pgdoc-cn_start sig_en=cdc7c35a173c8c986d3e8f8e3c3da401 sig_cn_org=acc32f57923e3347bc10bb5f290556d9 source=15.7 
    <para>
     When a new replication slot is created using the streaming replication
     interface (see <xref linkend="protocol-replication-create-replication-slot"/>), a
     snapshot is exported
     (see <xref linkend="functions-snapshot-synchronization"/>), which will show
     exactly the state of the database after which all changes will be
     included in the change stream. This can be used to create a new replica by
     using <link linkend="sql-set-transaction"><literal>SET TRANSACTION
     SNAPSHOT</literal></link> to read the state of the database at the moment
     the slot was created. This transaction can then be used to dump the
     database's state at that point in time, which afterwards can be updated
     using the slot's contents without losing any changes.
    </para>
________________________________________________________-->
    <para>
     当使用流复制接口创建一个新的复制槽时（参见<xref linkend="protocol-replication-create-replication-slot"/>），
     会导出一个快照（参见<xref linkend="functions-snapshot-synchronization"/>），
     这将准确显示数据库在创建槽之后的状态，之后所有更改都将包含在更改流中。
     这可以用来通过使用<link linkend="sql-set-transaction"><literal>SET TRANSACTION SNAPSHOT</literal></link>
     来读取创建槽时数据库的状态，从而创建一个新的副本。
     然后可以使用该事务来转储数据库在那个时间点的状态，之后可以使用槽的内容更新而不会丢失任何更改。
</para>
<!-- pgdoc-cn_end sig_en=cdc7c35a173c8c986d3e8f8e3c3da401 -->
<!-- pgdoc-cn_start sig_en=4fa41773e554af782d86264254b3fb1a sig_cn_org=None source=14.1 
    <para>
     Creation of a snapshot is not always possible.  In particular, it will
     fail when connected to a hot standby.  Applications that do not require
     snapshot export may suppress it with the <literal>NOEXPORT_SNAPSHOT</literal>
     option.
    </para>
________________________________________________________-->
    <para>
     并非总能够创建快照。特别是在连接到热备时，快照创建将会失败。不要求快照导出的应用可以用<literal>NOEXPORT_SNAPSHOT</literal>选项来抑制它。
     option.
    </para>
<!-- pgdoc-cn_end sig_en=4fa41773e554af782d86264254b3fb1a -->
   </sect2>
  </sect1>

  <sect1 id="logicaldecoding-walsender">
<!-- pgdoc-cn_start sig_en=ad985c3ca2885e3259df317728080373 sig_cn_org=None source=14.1 
   <title>Streaming Replication Protocol Interface</title>
________________________________________________________-->
   <title>流复制协议接口</title>
<!-- pgdoc-cn_end sig_en=ad985c3ca2885e3259df317728080373 -->

<!-- pgdoc-cn_start sig_en=633d0e1e6e044256bc50ad3812b1cdcb sig_cn_org=None source=14.1 
   <para>
    The commands
    <itemizedlist>
     <listitem>
      <para><literal>CREATE_REPLICATION_SLOT <replaceable>slot_name</replaceable> LOGICAL <replaceable>output_plugin</replaceable></literal></para>
     </listitem>

     <listitem>
      <para><literal>DROP_REPLICATION_SLOT <replaceable>slot_name</replaceable></literal> <optional> <literal>WAIT</literal> </optional></para>
     </listitem>

     <listitem>
      <para><literal>START_REPLICATION SLOT <replaceable>slot_name</replaceable> LOGICAL ...</literal></para>
     </listitem>
    </itemizedlist>
    are used to create, drop, and stream changes from a replication
    slot, respectively. These commands are only available over a replication
    connection; they cannot be used via SQL.
    See <xref linkend="protocol-replication"/> for details on these commands.
   </para>
________________________________________________________-->
   <para>
    命令
    <itemizedlist>
     <listitem>
      <para><literal>CREATE_REPLICATION_SLOT <replaceable>slot_name</replaceable> LOGICAL <replaceable>output_plugin</replaceable></literal></para>
     </listitem>

     <listitem>
      <para><literal>DROP_REPLICATION_SLOT <replaceable>slot_name</replaceable></literal> <optional> <literal>WAIT</literal> </optional></para>
     </listitem>

     <listitem>
      <para><literal>START_REPLICATION SLOT <replaceable>slot_name</replaceable> LOGICAL ...</literal></para>
     </listitem>
    </itemizedlist>
    被用来创建、删除以及流式传送一个复制槽。这些命令只能在一个复制连接上使用。
    它们不同通过 SQL 使用。这些命令的详情请见
    <xref linkend="protocol-replication"/>。
   </para>
<!-- pgdoc-cn_end sig_en=633d0e1e6e044256bc50ad3812b1cdcb -->

<!-- pgdoc-cn_start sig_en=9b720300ad1d2039253f6b0bd0649d0c sig_cn_org=None source=14.1 
   <para>
    The command <xref linkend="app-pgrecvlogical"/> can be used to control
    logical decoding over a streaming replication connection.  (It uses
    these commands internally.)
   </para>
________________________________________________________-->
   <para>
    命令<xref linkend="app-pgrecvlogical"/>可以被用来控制一个流复制连接上的逻辑
    解码（它在内部使用上述命令）。
   </para>
<!-- pgdoc-cn_end sig_en=9b720300ad1d2039253f6b0bd0649d0c -->
  </sect1>

  <sect1 id="logicaldecoding-sql">
<!-- pgdoc-cn_start sig_en=7e38323a17be06781a10d37ad1efd326 sig_cn_org=None source=14.1 
   <title>Logical Decoding <acronym>SQL</acronym> Interface</title>
________________________________________________________-->
   <title>逻辑解码的 <acronym>SQL</acronym> 接口</title>
<!-- pgdoc-cn_end sig_en=7e38323a17be06781a10d37ad1efd326 -->

<!-- pgdoc-cn_start sig_en=ec8f95d48025b0fa6307b2aaf6e36ef3 sig_cn_org=None source=14.1 
   <para>
     See <xref linkend="functions-replication"/> for detailed documentation on
     the SQL-level API for interacting with logical decoding.
   </para>
________________________________________________________-->
   <para>
     与逻辑解码互动的 SQL 层 API 详见<xref linkend="functions-replication"/>。
   </para>
<!-- pgdoc-cn_end sig_en=ec8f95d48025b0fa6307b2aaf6e36ef3 -->

<!-- pgdoc-cn_start sig_en=cdb83a3319520ba50650b39e8a92e983 sig_cn_org=None source=14.1 
   <para>
    Synchronous replication (see <xref linkend="synchronous-replication"/>) is
    only supported on replication slots used over the streaming replication interface. The
    function interface and additional, non-core interfaces do not support
    synchronous replication.
   </para>
________________________________________________________-->
   <para>
    同步复制（见<xref linkend="synchronous-replication"/>）只在使用流复制接口的复制槽上
    支持。函数接口以及额外的、非核心的接口不支持同步复制。
   </para>
<!-- pgdoc-cn_end sig_en=cdb83a3319520ba50650b39e8a92e983 -->
  </sect1>

  <sect1 id="logicaldecoding-catalogs">
<!-- pgdoc-cn_start sig_en=995403c443285e981e5aee2ebb17f476 sig_cn_org=None source=14.1 
   <title>System Catalogs Related to Logical Decoding</title>
________________________________________________________-->
   <title>与逻辑解码相关的系统目录</title>
<!-- pgdoc-cn_end sig_en=995403c443285e981e5aee2ebb17f476 -->

<!-- pgdoc-cn_start sig_en=4dda2f3019faaae47a359e2e0186ee92 sig_cn_org=None source=14.1 
   <para>
    The <link linkend="view-pg-replication-slots"><structname>pg_replication_slots</structname></link>
    view and the
    <link linkend="monitoring-pg-stat-replication-view">
    <structname>pg_stat_replication</structname></link>
    view provide information about the current state of replication slots and
    streaming replication connections respectively. These views apply to both physical and
    logical replication. The
    <link linkend="monitoring-pg-stat-replication-slots-view">
    <structname>pg_stat_replication_slots</structname></link>
    view provides statistics information about the logical replication slots.
   </para>
________________________________________________________-->
   <para>
    <link linkend="view-pg-replication-slots"><structname>pg_replication_slots</structname></link> 视图和<link linkend="monitoring-pg-stat-replication-view"><structname>pg_stat_replication</structname></link> 视图分别提供了有关复制槽和流复制连接的当前状态的信息。
    这些视图适用于物理和逻辑复制。
    <link linkend="monitoring-pg-stat-replication-slots-view"> <structname>pg_stat_replication_slots</structname></link> 视图提供了关于逻辑复制槽的统计信息。
   </para>
<!-- pgdoc-cn_end sig_en=4dda2f3019faaae47a359e2e0186ee92 -->
  </sect1>

  <sect1 id="logicaldecoding-output-plugin">
<!-- pgdoc-cn_start sig_en=31fcbfef55e4718569090ec49f033c66 sig_cn_org=None source=14.1 
   <title>Logical Decoding Output Plugins</title>
________________________________________________________-->
   <title>逻辑解码输出插件</title>
<!-- pgdoc-cn_end sig_en=31fcbfef55e4718569090ec49f033c66 -->
<!-- pgdoc-cn_start sig_en=ab20a45cb1bb30095a31923af5f4e1c0 sig_cn_org=None source=14.1 
   <para>
    An example output plugin can be found in the
    <link linkend="test-decoding">
     <filename>contrib/test_decoding</filename>
    </link>
    subdirectory of the PostgreSQL source tree.
   </para>
________________________________________________________-->
   <para>
    可以在 PostgreSQL 源码树的
    <link linkend="test-decoding">
     <filename>contrib/test_decoding</filename>
    </link>子目录中找到一个输出插件的例子。
   </para>
<!-- pgdoc-cn_end sig_en=ab20a45cb1bb30095a31923af5f4e1c0 -->
   <sect2 id="logicaldecoding-output-init">
<!-- pgdoc-cn_start sig_en=8d16305f2752deab0dc9cbc450e53871 sig_cn_org=None source=14.1 
    <title>Initialization Function</title>
________________________________________________________-->
    <title>初始化函数</title>
<!-- pgdoc-cn_end sig_en=8d16305f2752deab0dc9cbc450e53871 -->
<!-- pgdoc-cn_start sig_en=3b101e7cfc448265adc8b691089f1455 sig_cn_org=None source=14.1 
    <indexterm zone="logicaldecoding-output-init">
     <primary>_PG_output_plugin_init</primary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="logicaldecoding-output-init">
     <primary>_PG_output_plugin_init</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=3b101e7cfc448265adc8b691089f1455 -->
<!-- pgdoc-cn_start sig_en=8bbb3ad350df98f9f62471ff5290f112 sig_cn_org=None source=14.1 
    <para>
     An output plugin is loaded by dynamically loading a shared library with
     the output plugin's name as the library base name. The normal library
     search path is used to locate the library. To provide the required output
     plugin callbacks and to indicate that the library is actually an output
     plugin it needs to provide a function named
     <function>_PG_output_plugin_init</function>. This function is passed a
     struct that needs to be filled with the callback function pointers for
     individual actions.
<programlisting>
typedef struct OutputPluginCallbacks
{
    LogicalDecodeStartupCB startup_cb;
    LogicalDecodeBeginCB begin_cb;
    LogicalDecodeChangeCB change_cb;
    LogicalDecodeTruncateCB truncate_cb;
    LogicalDecodeCommitCB commit_cb;
    LogicalDecodeMessageCB message_cb;
    LogicalDecodeFilterByOriginCB filter_by_origin_cb;
    LogicalDecodeShutdownCB shutdown_cb;
    LogicalDecodeFilterPrepareCB filter_prepare_cb;
    LogicalDecodeBeginPrepareCB begin_prepare_cb;
    LogicalDecodePrepareCB prepare_cb;
    LogicalDecodeCommitPreparedCB commit_prepared_cb;
    LogicalDecodeRollbackPreparedCB rollback_prepared_cb;
    LogicalDecodeStreamStartCB stream_start_cb;
    LogicalDecodeStreamStopCB stream_stop_cb;
    LogicalDecodeStreamAbortCB stream_abort_cb;
    LogicalDecodeStreamPrepareCB stream_prepare_cb;
    LogicalDecodeStreamCommitCB stream_commit_cb;
    LogicalDecodeStreamChangeCB stream_change_cb;
    LogicalDecodeStreamMessageCB stream_message_cb;
    LogicalDecodeStreamTruncateCB stream_truncate_cb;
} OutputPluginCallbacks;

typedef void (*LogicalOutputPluginInit) (struct OutputPluginCallbacks *cb);
</programlisting>
     The <function>begin_cb</function>, <function>change_cb</function>
     and <function>commit_cb</function> callbacks are required,
     while <function>startup_cb</function>,
     <function>filter_by_origin_cb</function>, <function>truncate_cb</function>,
     and <function>shutdown_cb</function> are optional.
     If <function>truncate_cb</function> is not set but a
     <command>TRUNCATE</command> is to be decoded, the action will be ignored.
    </para>
________________________________________________________-->
    <para>
     一个输出插件是通过动态载入一个以输出插件名称作为基础名称的共享库来载入的。
     将使用普通的库搜索路径来定位该库。为了提供所要求的输出插件回调并且指示该
     库确实是一个输出插件，需要提供一个名为
     <function>_PG_output_plugin_init</function>的函数。这个函数会被传入一个
     结构，其中被填充了各个动作的回调函数指针。
<programlisting>
typedef struct OutputPluginCallbacks
{
    LogicalDecodeStartupCB startup_cb;
    LogicalDecodeBeginCB begin_cb;
    LogicalDecodeChangeCB change_cb;
    LogicalDecodeTruncateCB truncate_cb;
    LogicalDecodeCommitCB commit_cb;
    LogicalDecodeMessageCB message_cb;
    LogicalDecodeFilterByOriginCB filter_by_origin_cb;
    LogicalDecodeShutdownCB shutdown_cb;
    LogicalDecodeFilterPrepareCB filter_prepare_cb;
    LogicalDecodeBeginPrepareCB begin_prepare_cb;
    LogicalDecodePrepareCB prepare_cb;
    LogicalDecodeCommitPreparedCB commit_prepared_cb;
    LogicalDecodeRollbackPreparedCB rollback_prepared_cb;
    LogicalDecodeStreamStartCB stream_start_cb;
    LogicalDecodeStreamStopCB stream_stop_cb;
    LogicalDecodeStreamAbortCB stream_abort_cb;
    LogicalDecodeStreamPrepareCB stream_prepare_cb;
    LogicalDecodeStreamCommitCB stream_commit_cb;
    LogicalDecodeStreamChangeCB stream_change_cb;
    LogicalDecodeStreamMessageCB stream_message_cb;
    LogicalDecodeStreamTruncateCB stream_truncate_cb;
} OutputPluginCallbacks;

typedef void (*LogicalOutputPluginInit) (struct OutputPluginCallbacks *cb);
</programlisting>
     回调函数<function>begin_cb</function>、<function>change_cb</function>
     以及<function>commit_cb</function>是必需的，而
     <function>startup_cb</function>、<function>filter_by_origin_cb</function>、<function>truncate_cb</function>
     和<function>shutdown_cb</function>是可选的。如果没有设置<function>truncate_cb</function>但是要对一个<command>TRUNCATE</command>进行编码，则该动作将被忽略。
    </para>
<!-- pgdoc-cn_end sig_en=8bbb3ad350df98f9f62471ff5290f112 -->

<!-- pgdoc-cn_start sig_en=b4088a65f71132021fe6d517eccb1f09 sig_cn_org=None source=14.1 
    <para>
     An output plugin may also define functions to support streaming of large,
     in-progress transactions. The <function>stream_start_cb</function>,
     <function>stream_stop_cb</function>, <function>stream_abort_cb</function>,
     <function>stream_commit_cb</function>, <function>stream_change_cb</function>,
     and <function>stream_prepare_cb</function>
     are required, while <function>stream_message_cb</function> and
     <function>stream_truncate_cb</function> are optional.
    </para>
________________________________________________________-->
    <para>
     输出插件也可以定义支持大的、在处理事务的流的函数。
     <function>stream_start_cb</function>、<function>stream_stop_cb</function>、<function>stream_abort_cb</function>、<function>stream_commit_cb</function>、<function>stream_change_cb</function>、 和 <function>stream_prepare_cb</function>是需要的， <function>stream_message_cb</function> 和 <function>stream_truncate_cb</function> 是可选的。
    </para>
<!-- pgdoc-cn_end sig_en=b4088a65f71132021fe6d517eccb1f09 -->

<!-- pgdoc-cn_start sig_en=ad0fe36d68da48b0a836d35e9e7e0ef0 sig_cn_org=None source=14.1 
    <para>
    An output plugin may also define functions to support two-phase commits,
    which allows actions to be decoded on the <command>PREPARE TRANSACTION</command>.
    The <function>begin_prepare_cb</function>, <function>prepare_cb</function>,
    <function>stream_prepare_cb</function>,
    <function>commit_prepared_cb</function> and <function>rollback_prepared_cb</function>
    callbacks are required, while <function>filter_prepare_cb</function> is optional.
    </para>
________________________________________________________-->
    <para>
    输出插件还可以定义支持两阶段提交的函数，允许活动在<command>PREPARE TRANSACTION</command>上被解码。
    <function>begin_prepare_cb</function>, <function>prepare_cb</function>、<function>stream_prepare_cb</function>、<function>commit_prepared_cb</function> 和 <function>rollback_prepared_cb</function>回调是需要的，<function>filter_prepare_cb</function> 是可选的。
    </para>
<!-- pgdoc-cn_end sig_en=ad0fe36d68da48b0a836d35e9e7e0ef0 -->
   </sect2>

   <sect2 id="logicaldecoding-capabilities">
<!-- pgdoc-cn_start sig_en=2bbc5a8174a9ab68389ecc4997fb9c04 sig_cn_org=None source=14.1 
    <title>Capabilities</title>
________________________________________________________-->
    <title>能力</title>
<!-- pgdoc-cn_end sig_en=2bbc5a8174a9ab68389ecc4997fb9c04 -->

<!-- pgdoc-cn_start sig_en=188b9f2fa2137c9faac77919f172bd50 sig_cn_org=None source=14.1 
    <para>
     To decode, format and output changes, output plugins can use most of the
     backend's normal infrastructure, including calling output functions. Read
     only access to relations is permitted as long as only relations are
     accessed that either have been created by <command>initdb</command> in
     the <literal>pg_catalog</literal> schema, or have been marked as user
     provided catalog tables using
<programlisting>
ALTER TABLE user_catalog_table SET (user_catalog_table = true);
CREATE TABLE another_catalog_table(data text) WITH (user_catalog_table = true);
</programlisting>
     Note that access to user catalog tables or regular system catalog tables
     in the output plugins has to be done via the <literal>systable_*</literal>
     scan APIs only. Access via the <literal>heap_*</literal> scan APIs will
     error out. Additionally, any actions leading to transaction ID assignment
     are prohibited. That, among others, includes writing to tables, performing
     DDL changes, and calling <literal>pg_current_xact_id()</literal>.
    </para>
________________________________________________________-->
    <para>
     要解码、格式化并且输出更改，输出插件可以使用大部分后端的标准功能，包括调用
     输出函数。只要访问的关系是<command>initdb</command>在
     <literal>pg_catalog</literal>模式中创建的或者被使用
<programlisting>
ALTER TABLE user_catalog_table SET (user_catalog_table = true);
CREATE TABLE another_catalog_table(data text) WITH (user_catalog_table = true);
</programlisting>
     注意要访问输出插件中的用户目录表或常规系统目录表，只能通过<literal>systable_*</literal> 扫描 APIs完成。
     通过<literal>heap_*</literal> 扫描 APIs访问将出错
     此外标记为用户提供的系统表，就允许对关系的只读访问。
     任何导致事务 ID 分配的动作都被禁止。
     其中包括写表、执行 DDL 更改以及调用<literal>pg_current_xact_id()</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=188b9f2fa2137c9faac77919f172bd50 -->
   </sect2>

   <sect2 id="logicaldecoding-output-mode">
<!-- pgdoc-cn_start sig_en=9bbfb821e237ea6042b01fbca6eccbad sig_cn_org=None source=14.1 
    <title>Output Modes</title>
________________________________________________________-->
    <title>输出模式</title>
<!-- pgdoc-cn_end sig_en=9bbfb821e237ea6042b01fbca6eccbad -->

<!-- pgdoc-cn_start sig_en=de4c4092e1583f7ddb55bb49cc75ec43 sig_cn_org=None source=14.1 
    <para>
     Output plugin callbacks can pass data to the consumer in nearly arbitrary
     formats. For some use cases, like viewing the changes via SQL, returning
     data in a data type that can contain arbitrary data (e.g., <type>bytea</type>) is
     cumbersome. If the output plugin only outputs textual data in the
     server's encoding, it can declare that by
     setting <literal>OutputPluginOptions.output_type</literal>
     to <literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</literal> instead
     of <literal>OUTPUT_PLUGIN_BINARY_OUTPUT</literal> in
     the <link linkend="logicaldecoding-output-plugin-startup">startup
     callback</link>. In that case, all the data has to be in the server's encoding
     so that a <type>text</type> datum can contain it. This is checked in assertion-enabled
     builds.
    </para>
________________________________________________________-->
    <para>
     输出插件回调可以以近乎任意格式向消费者传递数据。对于某些用例，例如通过 SQL 
     查看更改，以可能包含任何数据的数据类型（例如<type>bytea</type>）返回数据
     可能会很麻烦。如果输出插件只输出服务器编码的文本数据，它可以在
     <link linkend="logicaldecoding-output-plugin-startup">启动回调</link>中通过把<literal>OutputPluginOptions.output_type</literal>设
     置为<literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</literal>替代
     <literal>OUTPUT_PLUGIN_BINARY_OUTPUT</literal>来声明这一点。在这种情况下，
     所有的数据必须是属于服务器的编码，这样一个<type>text</type>数据就能包含它。在
     启用了断言的编译中会检查这一点。
    </para>
<!-- pgdoc-cn_end sig_en=de4c4092e1583f7ddb55bb49cc75ec43 -->
   </sect2>

   <sect2 id="logicaldecoding-output-plugin-callbacks">
<!-- pgdoc-cn_start sig_en=12419e97f675becd780556a04ffa69f2 sig_cn_org=None source=14.1 
    <title>Output Plugin Callbacks</title>
________________________________________________________-->
    <title>输出插件回调</title>
<!-- pgdoc-cn_end sig_en=12419e97f675becd780556a04ffa69f2 -->

<!-- pgdoc-cn_start sig_en=c16cde897335337d0d471bb924d4f91e sig_cn_org=None source=14.1 
    <para>
     An output plugin gets notified about changes that are happening via
     various callbacks it needs to provide.
    </para>
________________________________________________________-->
    <para>
     一个输出插件需要提供一些回调，它通过它们得到有关更改发生的通知。
    </para>
<!-- pgdoc-cn_end sig_en=c16cde897335337d0d471bb924d4f91e -->

<!-- pgdoc-cn_start sig_en=616f79a33308c78c5ae47f9b48eb70a8 sig_cn_org=None source=14.1 
    <para>
     Concurrent transactions are decoded in commit order, and only changes
     belonging to a specific transaction are decoded between
     the <literal>begin</literal> and <literal>commit</literal>
     callbacks. Transactions that were rolled back explicitly or implicitly
     never get
     decoded. Successful savepoints are
     folded into the transaction containing them in the order they were
     executed within that transaction. A transaction that is prepared for
     a two-phase commit using <command>PREPARE TRANSACTION</command> will
     also be decoded if the output plugin callbacks needed for decoding
     them are provided. It is possible that the current prepared transaction
     which is being decoded is aborted concurrently via a
     <command>ROLLBACK PREPARED</command> command. In that case, the logical
     decoding of this transaction will be aborted too. All the changes of such
     a transaction are skipped once the abort is detected and the
     <function>prepare_cb</function> callback is invoked. Thus even in case of
     a concurrent abort, enough information is provided to the output plugin
     for it to properly deal with <command>ROLLBACK PREPARED</command> once
     that is decoded.
    </para>
________________________________________________________-->
    <para>
     并发事务以提交顺序被解码，并且只有属于特定事务的更改会在 <literal>begin</literal>和<literal>commit</literal>回调之间被解码。
	 被显式或隐式回滚的事务不会被解码。
	 成功的检查点被折叠到包含它们的事务中，并且保持它们在该事务中被执行的顺序。
     如果提供了解码它们所需要的输出插件回调，那么使用<command>PREPARE TRANSACTION</command>为两阶段提交准备的事务也将被解码。
     有可能通过<command>ROLLBACK PREPARED</command>命令并发地中止正在解码的当前准备好的事务。
     在这种情况下，该事务的逻辑解码也将被中止。
     一旦检测到中止并且调用<function>prepare_cb</function>回调，就会跳过此事务的所有更改。
     因此即使在并发中止的情况下，也会向输出插件提供足够的信息，以便一旦解码后它可以正确应对<command>ROLLBACK PREPARED</command>。
    </para>
<!-- pgdoc-cn_end sig_en=616f79a33308c78c5ae47f9b48eb70a8 -->

    <note>
<!-- pgdoc-cn_start sig_en=1e711d5e9d0e4471ef916ae4df060f3a sig_cn_org=None source=14.1 
     <para>
      Only transactions that have already safely been flushed to disk will be
      decoded. That can lead to a <command>COMMIT</command> not immediately being decoded in a
      directly following <literal>pg_logical_slot_get_changes()</literal>
      when <varname>synchronous_commit</varname> is set
      to <literal>off</literal>.
     </para>
________________________________________________________-->
     <para>
      只有已经被安全地刷入磁盘的事务将会被解码。当
      <varname>synchronous_commit</varname>被设置为<literal>off</literal>
      时，这会导致一个<command>COMMIT</command>在随后的
      <literal>pg_logical_slot_get_changes()</literal>中不会立即被解码。
     </para>
<!-- pgdoc-cn_end sig_en=1e711d5e9d0e4471ef916ae4df060f3a -->
    </note>

    <sect3 id="logicaldecoding-output-plugin-startup">
<!-- pgdoc-cn_start sig_en=77c3a594b4a09e95feb7d004caf92be0 sig_cn_org=None source=14.1 
     <title>Startup Callback</title>
________________________________________________________-->
     <title>启动回调</title>
<!-- pgdoc-cn_end sig_en=77c3a594b4a09e95feb7d004caf92be0 -->
<!-- pgdoc-cn_start sig_en=ce9e851231559af56e6ac063fed8611c sig_cn_org=None source=14.1 
     <para>
      The optional <function>startup_cb</function> callback is called whenever
      a replication slot is created or asked to stream changes, independent
      of the number of changes that are ready to be put out.
<programlisting>
typedef void (*LogicalDecodeStartupCB) (struct LogicalDecodingContext *ctx,
                                        OutputPluginOptions *options,
                                        bool is_init);
</programlisting>
      The <literal>is_init</literal> parameter will be true when the
      replication slot is being created and false
      otherwise. <parameter>options</parameter> points to a struct of options
      that output plugins can set:
<programlisting>
typedef struct OutputPluginOptions
{
    OutputPluginOutputType output_type;
    bool        receive_rewrites;
} OutputPluginOptions;
</programlisting>
      <literal>output_type</literal> has to either be set to
      <literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</literal>
      or <literal>OUTPUT_PLUGIN_BINARY_OUTPUT</literal>. See also
      <xref linkend="logicaldecoding-output-mode"/>.
      If <literal>receive_rewrites</literal> is true, the output plugin will
      also be called for changes made by heap rewrites during certain DDL
      operations.  These are of interest to plugins that handle DDL
      replication, but they require special handling.
     </para>
________________________________________________________-->
     <para>
      只要一个复制槽被创建或者被要求流式传送更改，可选的
      <function>startup_cb</function>回调就会被调用，不管有多少更改准备输出。
<programlisting>
typedef void (*LogicalDecodeStartupCB) (struct LogicalDecodingContext *ctx,
                                        OutputPluginOptions *options,
                                        bool is_init);
</programlisting>
      当复制槽被创建时，<literal>is_init</literal>参数将为真，否则为假。
      <parameter>options</parameter>指向一个输出插件可以设置的选项
      的结构：
<programlisting>
typedef struct OutputPluginOptions
{
    OutputPluginOutputType output_type;
    bool        receive_rewrites;
} OutputPluginOptions;
</programlisting>
      <literal>output_type</literal>必须被设置为
      <literal>OUTPUT_PLUGIN_TEXTUAL_OUTPUT</literal>
      或者<literal>OUTPUT_PLUGIN_BINARY_OUTPUT</literal>。另见
      <xref linkend="logicaldecoding-output-mode"/>。如果<literal>receive_rewrites</literal>为真，还将为在某些DDL操作期间的堆重写造成的更改调用输出插件。这些是处理DDL复制的插件感兴趣的事情，但是它们要求特殊的处理。
     </para>
<!-- pgdoc-cn_end sig_en=ce9e851231559af56e6ac063fed8611c -->

<!-- pgdoc-cn_start sig_en=c28720f10f50ef1163c56c9917a50e6b sig_cn_org=None source=14.1 
     <para>
      The startup callback should validate the options present in
      <literal>ctx-&gt;output_plugin_options</literal>. If the output plugin
      needs to have a state, it can
      use <literal>ctx-&gt;output_plugin_private</literal> to store it.
     </para>
________________________________________________________-->
     <para>
      启动回调应该验证出现在
      <literal>ctx-&gt;output_plugin_options</literal>中的选项。如果输出插件
      需要有一个状态，它可以使用
      <literal>ctx-&gt;output_plugin_private</literal>来存储之。
     </para>
<!-- pgdoc-cn_end sig_en=c28720f10f50ef1163c56c9917a50e6b -->
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-shutdown">
<!-- pgdoc-cn_start sig_en=68b3ee2e7b46796aed869d754422c63d sig_cn_org=None source=14.1 
     <title>Shutdown Callback</title>
________________________________________________________-->
     <title>关闭回调</title>
<!-- pgdoc-cn_end sig_en=68b3ee2e7b46796aed869d754422c63d -->

<!-- pgdoc-cn_start sig_en=601923ebd183a9e6a6696af1eda5dbec sig_cn_org=None source=14.1 
     <para>
      The optional <function>shutdown_cb</function> callback is called
      whenever a formerly active replication slot is not used anymore and can
      be used to deallocate resources private to the output plugin. The slot
      isn't necessarily being dropped, streaming is just being stopped.
<programlisting>
typedef void (*LogicalDecodeShutdownCB) (struct LogicalDecodingContext *ctx);
</programlisting>
     </para>
________________________________________________________-->
     <para>
      只要一个之前活跃的复制槽不再使用，就会调用可选的
      <function>shutdown_cb</function>回调，它可以被用来释放输出插件
      私有的资源。该槽并不一定需要被删除，只要其中的流被停止即可。
<programlisting>
typedef void (*LogicalDecodeShutdownCB) (struct LogicalDecodingContext *ctx);
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=601923ebd183a9e6a6696af1eda5dbec -->
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-begin">
<!-- pgdoc-cn_start sig_en=c5f4cda08b6d34e4fe492745c426548e sig_cn_org=None source=14.1 
     <title>Transaction Begin Callback</title>
________________________________________________________-->
     <title>事务开始回调</title>
<!-- pgdoc-cn_end sig_en=c5f4cda08b6d34e4fe492745c426548e -->

<!-- pgdoc-cn_start sig_en=046b82396d5a2653b76bb54e279f5db3 sig_cn_org=None source=14.1 
     <para>
      The required <function>begin_cb</function> callback is called whenever a
      start of a committed transaction has been decoded. Aborted transactions
      and their contents never get decoded.
<programlisting>
typedef void (*LogicalDecodeBeginCB) (struct LogicalDecodingContext *ctx,
                                      ReorderBufferTXN *txn);
</programlisting>
      The <parameter>txn</parameter> parameter contains meta information about
      the transaction, like the time stamp at which it has been committed and
      its XID.
     </para>
________________________________________________________-->
     <para>
      只要一个已提交事务的开始动作被解码，就会调用必须提供的
      <function>begin_cb</function>回调。被中止的事务及其内容不会被解码。
<programlisting>
typedef void (*LogicalDecodeBeginCB) (struct LogicalDecodingContext *ctx,
                                      ReorderBufferTXN *txn);
</programlisting>
      <parameter>txn</parameter>参数包含有关该事务的元信息，例如该
      事务被提交的时间戳以及该事务的 XID。
     </para>
<!-- pgdoc-cn_end sig_en=046b82396d5a2653b76bb54e279f5db3 -->
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-commit">
<!-- pgdoc-cn_start sig_en=5e9a777f81ee1c6ea28f373b4e787232 sig_cn_org=None source=14.1 
     <title>Transaction End Callback</title>
________________________________________________________-->
     <title>事务结束回调</title>
<!-- pgdoc-cn_end sig_en=5e9a777f81ee1c6ea28f373b4e787232 -->

<!-- pgdoc-cn_start sig_en=6a7fb68dee816b25e67bc3e624a86e5c sig_cn_org=None source=14.1 
     <para>
      The required <function>commit_cb</function> callback is called whenever
      a transaction commit has been
      decoded. The <function>change_cb</function> callbacks for all modified
      rows will have been called before this, if there have been any modified
      rows.
<programlisting>
typedef void (*LogicalDecodeCommitCB) (struct LogicalDecodingContext *ctx,
                                       ReorderBufferTXN *txn,
                                       XLogRecPtr commit_lsn);
</programlisting>
     </para>
________________________________________________________-->
     <para>
      只要一个已提交事务的提交动作被解码，就会调用必须提供的
      <function>commit_cb</function>回调。在此之前，如果有任何被修改
      的行，将为所有被修改的行调用<function>change_cb</function>回调。
<programlisting>
typedef void (*LogicalDecodeCommitCB) (struct LogicalDecodingContext *ctx,
                                       ReorderBufferTXN *txn,
                                       XLogRecPtr commit_lsn);
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=6a7fb68dee816b25e67bc3e624a86e5c -->
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-change">
<!-- pgdoc-cn_start sig_en=4a165c4cd182fee3a2980e4acf0f865c sig_cn_org=None source=14.1 
     <title>Change Callback</title>
________________________________________________________-->
     <title>更改回调</title>
<!-- pgdoc-cn_end sig_en=4a165c4cd182fee3a2980e4acf0f865c -->

<!-- pgdoc-cn_start sig_en=a39d32e525eead780cef7c7e14c486e9 sig_cn_org=None source=14.1 
     <para>
      The required <function>change_cb</function> callback is called for every
      individual row modification inside a transaction, may it be
      an <command>INSERT</command>, <command>UPDATE</command>,
      or <command>DELETE</command>. Even if the original command modified
      several rows at once the callback will be called individually for each
      row. The <function>change_cb</function> callback may access system or
      user catalog tables to aid in the process of outputting the row
      modification details. In case of decoding a prepared (but yet
      uncommitted) transaction or decoding of an uncommitted transaction, this
      change callback might also error out due to simultaneous rollback of
      this very same transaction. In that case, the logical decoding of this
      aborted transaction is stopped gracefully.
<programlisting>
typedef void (*LogicalDecodeChangeCB) (struct LogicalDecodingContext *ctx,
                                       ReorderBufferTXN *txn,
                                       Relation relation,
                                       ReorderBufferChange *change);
</programlisting>
      The <parameter>ctx</parameter> and <parameter>txn</parameter> parameters
      have the same contents as for the <function>begin_cb</function>
      and <function>commit_cb</function> callbacks, but additionally the
      relation descriptor <parameter>relation</parameter> points to the
      relation the row belongs to and a struct
      <parameter>change</parameter> describing the row modification are passed
      in.
     </para>
________________________________________________________-->
     <para>
      对于一个事务中的每一个行修改，都将调用必须提供的<function>change_cb</function>回调，这种修改可能是一个<command>INSERT</command>、<command>UPDATE</command>或者<command>DELETE</command>。
      即使原始命令一次修改了多行，该回调也会为其中的每一行调用一次。
      <function>change_cb</function>回调可以访问系统或用户目录表，以帮助输出行修改细节的过程。
      在解码一个准备好的(但仍未提交)事务或解码一个未提交的事务的情况下，这个更改回调也可能由于同时回滚这一相同事务而出错。
      在这种情况下，对这个中止事务的逻辑解码被优雅的停止。
<programlisting>
typedef void (*LogicalDecodeChangeCB) (struct LogicalDecodingContext *ctx,
                                       ReorderBufferTXN *txn,
                                       Relation relation,
                                       ReorderBufferChange *change);
</programlisting>
      <parameter>ctx</parameter>和<parameter>txn</parameter>参数与
      <function>begin_cb</function>和<function>commit_cb</function>
      回调具有相同的内容，但是额外多出一个关系描述符
      <parameter>relation</parameter>指向该行所属的关系以及一个结构
      <parameter>change</parameter>描述被传入的行修改。
     </para>
<!-- pgdoc-cn_end sig_en=a39d32e525eead780cef7c7e14c486e9 -->

     <note>
<!-- pgdoc-cn_start sig_en=acd411ab213d1ff13adee0f465678687 sig_cn_org=None source=14.1 
      <para>
       Only changes in user defined tables that are not unlogged
       (see <xref linkend="sql-createtable-unlogged"/>) and not temporary
       (see <xref linkend="sql-createtable-temporary"/>) can be extracted using
       logical decoding.
      </para>
________________________________________________________-->
      <para>
       只有没有被标记为“不做日志”（见
       <xref linkend="sql-createtable-unlogged"/>）并且非临时（见
       <xref linkend="sql-createtable-temporary"/>）的用户定义表中的
       更改才能用逻辑解码抽取。
      </para>
<!-- pgdoc-cn_end sig_en=acd411ab213d1ff13adee0f465678687 -->
     </note>
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-truncate">
<!-- pgdoc-cn_start sig_en=9496eecb5781309ec4a96fdaf640a097 sig_cn_org=None source=14.1 
     <title>Truncate Callback</title>
________________________________________________________-->
     <title>截断回调</title>
<!-- pgdoc-cn_end sig_en=9496eecb5781309ec4a96fdaf640a097 -->

<!-- pgdoc-cn_start sig_en=2fc80257f69751ee39dc936ea0b22c88 sig_cn_org=None source=14.1 
     <para>
      The <function>truncate_cb</function> callback is called for a
      <command>TRUNCATE</command> command.
<programlisting>
typedef void (*LogicalDecodeTruncateCB) (struct LogicalDecodingContext *ctx,
                                         ReorderBufferTXN *txn,
                                         int nrelations,
                                         Relation relations[],
                                         ReorderBufferChange *change);
</programlisting>
      The parameters are analogous to the <function>change_cb</function>
      callback.  However, because <command>TRUNCATE</command> actions on
      tables connected by foreign keys need to be executed together, this
      callback receives an array of relations instead of just a single one.
      See the description of the <xref linkend="sql-truncate"/> statement for
      details.
     </para>
________________________________________________________-->
     <para>
      <function>truncate_cb</function>回调会为一个<command>TRUNCATE</command>命令被调用。
<programlisting>
typedef void (*LogicalDecodeTruncateCB) (struct LogicalDecodingContext *ctx,
                                         ReorderBufferTXN *txn,
                                         int nrelations,
                                         Relation relations[],
                                         ReorderBufferChange *change);
</programlisting>
      参数类似于<function>change_cb</function>回调。不过，由于通过外键连接起来的表上的<command>TRUNCATE</command>动作需要一起被执行，这个回调会接收到一个关系的数组而不是单个关系。详情请见对<xref linkend="sql-truncate"/>语句的介绍。
     </para>
<!-- pgdoc-cn_end sig_en=2fc80257f69751ee39dc936ea0b22c88 -->
    </sect3>

     <sect3 id="logicaldecoding-output-plugin-filter-origin">
<!-- pgdoc-cn_start sig_en=4c68e2fcf252d6a524c5137f8944dbff sig_cn_org=None source=14.1 
     <title>Origin Filter Callback</title>
________________________________________________________-->
     <title>源过滤器回调</title>
<!-- pgdoc-cn_end sig_en=4c68e2fcf252d6a524c5137f8944dbff -->

<!-- pgdoc-cn_start sig_en=b82b9e06d5012dfdc236e6126fb4e5f0 sig_cn_org=None source=14.1 
     <para>
       The optional <function>filter_by_origin_cb</function> callback
       is called to determine whether data that has been replayed
       from <parameter>origin_id</parameter> is of interest to the
       output plugin.
<programlisting>
typedef bool (*LogicalDecodeFilterByOriginCB) (struct LogicalDecodingContext *ctx,
                                               RepOriginId origin_id);
</programlisting>
      The <parameter>ctx</parameter> parameter has the same contents
      as for the other callbacks. No information but the origin is
      available. To signal that changes originating on the passed in
      node are irrelevant, return true, causing them to be filtered
      away; false otherwise. The other callbacks will not be called
      for transactions and changes that have been filtered away.
     </para>
________________________________________________________-->
     <para>
       可选的<function>filter_by_origin_cb</function>回调被用来
       决定从<parameter>origin_id</parameter>重放的数据是否是
       输出插件感兴趣的数据。
<programlisting>
typedef bool (*LogicalDecodeFilterByOriginCB) (struct LogicalDecodingContext *ctx,
                                               RepOriginId origin_id);
</programlisting>
      <parameter>ctx</parameter>参数具有和其他回调相同的内容。
      对这个回调只有复制源的信息可用。要标志传进来的节点上发生的
      更改是无关的，返回真，这会导致这些更改被过滤掉，否则返回假。
      对于被过滤掉的事务和更改将不会调用其他回调。
     </para>
<!-- pgdoc-cn_end sig_en=b82b9e06d5012dfdc236e6126fb4e5f0 -->
<!-- pgdoc-cn_start sig_en=1a6062bba47b01a15d92e8a53c8e7ab0 sig_cn_org=None source=14.1 
     <para>
       This is useful when implementing cascading or multidirectional
       replication solutions. Filtering by the origin allows to
       prevent replicating the same changes back and forth in such
       setups.  While transactions and changes also carry information
       about the origin, filtering via this callback is noticeably
       more efficient.
     </para>
________________________________________________________-->
     <para>
       在实现级联或者多向复制方案时，这个回调可以派上用场。用源头
       过滤允许阻止在这样的设置下来回地复制同样的更改。虽然事务和
       更改也携带了有关源头的信息，通过这个回调过滤明显更有效些。
     </para>
<!-- pgdoc-cn_end sig_en=1a6062bba47b01a15d92e8a53c8e7ab0 -->
     </sect3>

    <sect3 id="logicaldecoding-output-plugin-message">
<!-- pgdoc-cn_start sig_en=92a2829f1d3a0228af54eff6d1b8e89f sig_cn_org=None source=14.1 
     <title>Generic Message Callback</title>
________________________________________________________-->
     <title>通用消息回调</title>
<!-- pgdoc-cn_end sig_en=92a2829f1d3a0228af54eff6d1b8e89f -->

<!-- pgdoc-cn_start sig_en=5e46f628adbec8bd058f58456c0c69d7 sig_cn_org=None source=14.1 
     <para>
      The optional <function>message_cb</function> callback is called whenever
      a logical decoding message has been decoded.
<programlisting>
typedef void (*LogicalDecodeMessageCB) (struct LogicalDecodingContext *ctx,
                                        ReorderBufferTXN *txn,
                                        XLogRecPtr message_lsn,
                                        bool transactional,
                                        const char *prefix,
                                        Size message_size,
                                        const char *message);
</programlisting>
      The <parameter>txn</parameter> parameter contains meta information about
      the transaction, like the time stamp at which it has been committed and
      its XID. Note however that it can be NULL when the message is
      non-transactional and the XID was not assigned yet in the transaction
      which logged the message. The <parameter>lsn</parameter> has WAL
      location of the message. The <parameter>transactional</parameter> says
      if the message was sent as transactional or not. Similar to the change
      callback, in case of decoding a prepared (but yet uncommitted)
      transaction or decoding of an uncommitted transaction, this message
      callback might also error out due to simultaneous rollback of
      this very same transaction. In that case, the logical decoding of this
      aborted transaction is stopped gracefully.

      The <parameter>prefix</parameter> is arbitrary null-terminated prefix
      which can be used for identifying interesting messages for the current
      plugin. And finally the <parameter>message</parameter> parameter holds
      the actual message of <parameter>message_size</parameter> size.
     </para>
________________________________________________________-->
     <para>
      只要一个逻辑解码消息被解码出来，可选的<function>message_cb</function>回调就会被调用。
<programlisting>
typedef void (*LogicalDecodeMessageCB) (struct LogicalDecodingContext *ctx,
                                        ReorderBufferTXN *txn,
                                        XLogRecPtr message_lsn,
                                        bool transactional,
                                        const char *prefix,
                                        Size message_size,
                                        const char *message);
</programlisting>
      <parameter>txn</parameter>参数包含关于该事务的元信息，如被提交的时间戳和 XID。
      不过要注意，当消息是非事务性的并且记录该消息的事务中还没有被分配 XID 时，这个参数可以为 NULL。
      <parameter>lsn</parameter>是该消息的 WAL 位置。
      <parameter>transactional</parameter>说明该消息是否为事务性的。
      类似于变更回调，在解码一个准备好的(但仍未提交)事务或解码一个未提交的事务的情况下，此消息回调也可能由于同时回滚这一相同事务而出错。
      在这种情况下，这个中止事务的逻辑解码被优雅的停止。
      <parameter>prefix</parameter>是一个任意的空终结的前缀，它当前插件被用来标识感兴趣的消息。
      最后的<parameter>message</parameter>参数保存着大小为<parameter>message_size</parameter>的消息。
     </para>
<!-- pgdoc-cn_end sig_en=5e46f628adbec8bd058f58456c0c69d7 -->
<!-- pgdoc-cn_start sig_en=1b92e3ec074d4108d05b3e3c148e7628 sig_cn_org=None source=14.1 
     <para>
      Extra care should be taken to ensure that the prefix the output plugin
      considers interesting is unique. Using name of the extension or the
      output plugin itself is often a good choice.
     </para>
________________________________________________________-->
     <para>
      应该格外小心确保输出插件用于标识感兴趣消息的前缀是唯一的。建议使用扩展或者输出插件本身的名称。
     </para>
<!-- pgdoc-cn_end sig_en=1b92e3ec074d4108d05b3e3c148e7628 -->
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-filter-prepare">
<!-- pgdoc-cn_start sig_en=2d5273cbbcd5e191bd1f57438927e683 sig_cn_org=None source=14.1 
     <title>Prepare Filter Callback</title>
________________________________________________________-->
     <title>准备过滤器回调</title>
<!-- pgdoc-cn_end sig_en=2d5273cbbcd5e191bd1f57438927e683 -->

<!-- pgdoc-cn_start sig_en=ef660bb54eb4faf46b36f7865c40d88c sig_cn_org=None source=14.1 
     <para>
       The optional <function>filter_prepare_cb</function> callback
       is called to determine whether data that is part of the current
       two-phase commit transaction should be considered for decoding
       at this prepare stage or later as a regular one-phase transaction at
       <command>COMMIT PREPARED</command> time. To signal that
       decoding should be skipped, return <literal>true</literal>;
       <literal>false</literal> otherwise. When the callback is not
       defined, <literal>false</literal> is assumed (i.e. no filtering, all
       transactions using two-phase commit are decoded in two phases as well).
<programlisting>
typedef bool (*LogicalDecodeFilterPrepareCB) (struct LogicalDecodingContext *ctx,
                                              TransactionId xid,
                                              const char *gid);
</programlisting>
       The <parameter>ctx</parameter> parameter has the same contents as for
       the other callbacks. The parameters <parameter>xid</parameter>
       and <parameter>gid</parameter> provide two different ways to identify
       the transaction.  The later <command>COMMIT PREPARED</command> or
       <command>ROLLBACK PREPARED</command> carries both identifiers,
       providing an output plugin the choice of what to use.
     </para>
________________________________________________________-->
     <para>
       可选的<function>filter_prepare_cb</function>回调被调用，以决定作为当前两阶段提交事务一部分的数据是否考虑在这个准备阶段进行解码，还是以后在<command>COMMIT PREPARED</command>时作为常规的一阶段事务。
       要表示要跳过解码，返回<literal>true</literal>;否则是<literal>false</literal>。
       如果回调没有被定义，则假定<literal>false</literal>(也就是说，没有过滤，所有使用两阶段提交的事务也在两个阶段进行解码)。
<programlisting>
typedef bool (*LogicalDecodeFilterPrepareCB) (struct LogicalDecodingContext *ctx,
                                              TransactionId xid,
                                              const char *gid);
</programlisting>
       <parameter>ctx</parameter>参数与其他回调具有相同的内容。
       参数<parameter>xid</parameter>和<parameter>gid</parameter>提供了两种不同的方式以标识事务。
       后面的<command>COMMIT PREPARED</command>或<command>ROLLBACK PREPARED</command>携带这两个标识符，提供了输出插件可用的选项。
     </para>
<!-- pgdoc-cn_end sig_en=ef660bb54eb4faf46b36f7865c40d88c -->
<!-- pgdoc-cn_start sig_en=a9b3ee9d5d6dcbf78c5afe30cd70f66b sig_cn_org=None source=14.1 
     <para>
       The callback may be invoked multiple times per transaction to decode
       and must provide the same static answer for a given pair of
       <parameter>xid</parameter> and <parameter>gid</parameter> every time
       it is called.
     </para>
________________________________________________________-->
     <para>
       每个事务可以多次调用回调来解码，并且在每次它被调用时，必须为给定的<parameter>xid</parameter> 和 <parameter>gid</parameter>对提供相同的静态答案。
     </para>
<!-- pgdoc-cn_end sig_en=a9b3ee9d5d6dcbf78c5afe30cd70f66b -->
     </sect3>

    <sect3 id="logicaldecoding-output-plugin-begin-prepare">
<!-- pgdoc-cn_start sig_en=970cea90e0164f7d44d13ecfcce531f8 sig_cn_org=None source=14.1 
     <title>Transaction Begin Prepare Callback</title>
________________________________________________________-->
     <title>事务开始准备回调</title>
<!-- pgdoc-cn_end sig_en=970cea90e0164f7d44d13ecfcce531f8 -->

<!-- pgdoc-cn_start sig_en=3138404df76364b6cde14962885e7959 sig_cn_org=538438b59e384ad63ee7feba3523b566 source=15.7 
     <para>
      The required <function>begin_prepare_cb</function> callback is called
      whenever the start of a prepared transaction has been decoded. The
      <parameter>gid</parameter> field, which is part of the
      <parameter>txn</parameter> parameter, can be used in this callback to
      check if the plugin has already received this <command>PREPARE</command>
      in which case it can either error out or skip the remaining changes of
      the transaction.
<programlisting>
typedef void (*LogicalDecodeBeginPrepareCB) (struct LogicalDecodingContext *ctx,
                                             ReorderBufferTXN *txn);
</programlisting>
     </para>
________________________________________________________-->
     <para>
      必需的<function>begin_prepare_cb</function>回调函数在已解码准备事务的开始时被调用。
      <parameter>gid</parameter>字段是<parameter>txn</parameter>参数的一部分，可以在此回调函数中使用，
      以检查插件是否已经接收到此<command>PREPARE</command>，在这种情况下，它可以出错或跳过事务的其余更改。
<programlisting>
typedef void (*LogicalDecodeBeginPrepareCB) (struct LogicalDecodingContext *ctx,
                                             ReorderBufferTXN *txn);
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=3138404df76364b6cde14962885e7959 -->
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-prepare">
<!-- pgdoc-cn_start sig_en=37c9c7a2fe7c6b8fced53177d3cd9e32 sig_cn_org=None source=14.1 
     <title>Transaction Prepare Callback</title>
________________________________________________________-->
     <title>事务准备回调</title>
<!-- pgdoc-cn_end sig_en=37c9c7a2fe7c6b8fced53177d3cd9e32 -->

<!-- pgdoc-cn_start sig_en=a8b07264ae1473bcec41eb7d9af92b9d sig_cn_org=None source=14.1 
     <para>
      The required <function>prepare_cb</function> callback is called whenever
      a transaction which is prepared for two-phase commit has been
      decoded. The <function>change_cb</function> callback for all modified
      rows will have been called before this, if there have been any modified
      rows. The <parameter>gid</parameter> field, which is part of the
      <parameter>txn</parameter> parameter, can be used in this callback.
<programlisting>
typedef void (*LogicalDecodePrepareCB) (struct LogicalDecodingContext *ctx,
                                        ReorderBufferTXN *txn,
                                        XLogRecPtr prepare_lsn);
</programlisting>
     </para>
________________________________________________________-->
     <para>
      所需的<function>prepare_cb</function>回调被调用，当为两阶段提交准备的事务被解码的时候。
      如果有任何修改的行，那么所有修改行的<function>change_cb</function>回调将在这之前被调用。
      <parameter>gid</parameter>字段，是<parameter>txn</parameter>参数的一部分，可以在这个回调中使用。
<programlisting>
typedef void (*LogicalDecodePrepareCB) (struct LogicalDecodingContext *ctx,
                                        ReorderBufferTXN *txn,
                                        XLogRecPtr prepare_lsn);
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=a8b07264ae1473bcec41eb7d9af92b9d -->
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-commit-prepared">
<!-- pgdoc-cn_start sig_en=ec1ed45609c2ad5e122b94adb811fe92 sig_cn_org=None source=14.1 
     <title>Transaction Commit Prepared Callback</title>
________________________________________________________-->
     <title>事务提交准备回调</title>
<!-- pgdoc-cn_end sig_en=ec1ed45609c2ad5e122b94adb811fe92 -->

<!-- pgdoc-cn_start sig_en=41a201c49a33522ee6eec906883411a4 sig_cn_org=None source=14.1 
     <para>
      The required <function>commit_prepared_cb</function> callback is called
      whenever a transaction <command>COMMIT PREPARED</command> has been decoded.
      The <parameter>gid</parameter> field, which is part of the
      <parameter>txn</parameter> parameter, can be used in this callback.
<programlisting>
typedef void (*LogicalDecodeCommitPreparedCB) (struct LogicalDecodingContext *ctx,
                                               ReorderBufferTXN *txn,
                                               XLogRecPtr commit_lsn);
</programlisting>
     </para>
________________________________________________________-->
     <para>
      所需要的<function>commit_prepared_cb</function>回调被调用，当事务<command>COMMIT PREPARED</command>被解码时。
      <parameter>gid</parameter>字段，是<parameter>txn</parameter> 参数的一部分，可以在这个回调中使用。
<programlisting>
typedef void (*LogicalDecodeCommitPreparedCB) (struct LogicalDecodingContext *ctx,
                                               ReorderBufferTXN *txn,
                                               XLogRecPtr commit_lsn);
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=41a201c49a33522ee6eec906883411a4 -->
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-rollback-prepared">
<!-- pgdoc-cn_start sig_en=0a2e0c02c8817049840fc9b6f7898718 sig_cn_org=None source=14.1 
     <title>Transaction Rollback Prepared Callback</title>
________________________________________________________-->
     <title>事务回滚准备回滚</title>
<!-- pgdoc-cn_end sig_en=0a2e0c02c8817049840fc9b6f7898718 -->

<!-- pgdoc-cn_start sig_en=b17c6b8b5a4f1411e2d1360921ec5810 sig_cn_org=None source=14.1 
     <para>
      The required <function>rollback_prepared_cb</function> callback is called
      whenever a transaction <command>ROLLBACK PREPARED</command> has been
      decoded. The <parameter>gid</parameter> field, which is part of the
      <parameter>txn</parameter> parameter, can be used in this callback. The
      parameters <parameter>prepare_end_lsn</parameter> and
      <parameter>prepare_time</parameter> can be used to check if the plugin
      has received this <command>PREPARE TRANSACTION</command> in which case
      it can apply the rollback, otherwise, it can skip the rollback operation. The
      <parameter>gid</parameter> alone is not sufficient because the downstream
      node can have a prepared transaction with same identifier.
<programlisting>
typedef void (*LogicalDecodeRollbackPreparedCB) (struct LogicalDecodingContext *ctx,
                                                 ReorderBufferTXN *txn,
                                                 XLogRecPtr prepare_end_lsn,
                                                 TimestampTz prepare_time);
</programlisting>
     </para>
________________________________________________________-->
     <para>
      所需要的<function>rollback_prepared_cb</function>回调被调用，当事务<command>ROLLBACK PREPARED</command>被解码时。
      <parameter>gid</parameter>字段，是<parameter>txn</parameter>参数的一部分，可以在这个回调中使用。
      参数<parameter>prepare_end_lsn</parameter> 和 <parameter>prepare_time</parameter>可用于检查插件是否已经收到这个<command>PREPARE TRANSACTION</command>，在这种情况下，它可以应用回滚，否则，它可以跳过回滚操作。
      单独的<parameter>gid</parameter>是不够的，因为下游节点可以有一个具有相同标识符的准备事务。
<programlisting>
typedef void (*LogicalDecodeRollbackPreparedCB) (struct LogicalDecodingContext *ctx,
                                                 ReorderBufferTXN *txn,
                                                 XLogRecPtr prepare_end_lsn,
                                                 TimestampTz prepare_time);
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=b17c6b8b5a4f1411e2d1360921ec5810 -->
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-stream-start">
<!-- pgdoc-cn_start sig_en=ae89bdc2b6405e52a900c654a35f4251 sig_cn_org=None source=14.1 
     <title>Stream Start Callback</title>
________________________________________________________-->
     <title>流开始回调</title>
<!-- pgdoc-cn_end sig_en=ae89bdc2b6405e52a900c654a35f4251 -->
<!-- pgdoc-cn_start sig_en=ff1719ef8d90880e09dcea06ba266d8f sig_cn_org=None source=14.1 
     <para>
      The <function>stream_start_cb</function> callback is called when opening
      a block of streamed changes from an in-progress transaction.
<programlisting>
typedef void (*LogicalDecodeStreamStartCB) (struct LogicalDecodingContext *ctx,
                                            ReorderBufferTXN *txn);
</programlisting>
     </para>
________________________________________________________-->
     <para>
      <function>stream_start_cb</function>回调被调用，在打开一个正在进行的事务中的流更改的块的时候。
<programlisting>
typedef void (*LogicalDecodeStreamStartCB) (struct LogicalDecodingContext *ctx,
                                            ReorderBufferTXN *txn);
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=ff1719ef8d90880e09dcea06ba266d8f -->
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-stream-stop">
<!-- pgdoc-cn_start sig_en=cf8dde56bd7ca519fb0bf159f169be07 sig_cn_org=None source=14.1 
     <title>Stream Stop Callback</title>
________________________________________________________-->
     <title>流停止回调</title>
<!-- pgdoc-cn_end sig_en=cf8dde56bd7ca519fb0bf159f169be07 -->
<!-- pgdoc-cn_start sig_en=f44a993769b8896a306d8a142a737829 sig_cn_org=None source=14.1 
     <para>
      The <function>stream_stop_cb</function> callback is called when closing
      a block of streamed changes from an in-progress transaction.
<programlisting>
typedef void (*LogicalDecodeStreamStopCB) (struct LogicalDecodingContext *ctx,
                                           ReorderBufferTXN *txn);
</programlisting>
     </para>
________________________________________________________-->
     <para>
      <function>stream_stop_cb</function>回调被调用，在关闭正在进行的事务中的流更改的块时。
<programlisting>
typedef void (*LogicalDecodeStreamStopCB) (struct LogicalDecodingContext *ctx,
                                           ReorderBufferTXN *txn);
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=f44a993769b8896a306d8a142a737829 -->
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-stream-abort">
<!-- pgdoc-cn_start sig_en=bc382b61bde6e027bba8d91f4bba9b0d sig_cn_org=None source=14.1 
     <title>Stream Abort Callback</title>
________________________________________________________-->
     <title>流中止回调</title>
<!-- pgdoc-cn_end sig_en=bc382b61bde6e027bba8d91f4bba9b0d -->
<!-- pgdoc-cn_start sig_en=46fbe152a5e8f6df7a6661643e86b518 sig_cn_org=None source=14.1 
     <para>
      The <function>stream_abort_cb</function> callback is called to abort
      a previously streamed transaction.
<programlisting>
typedef void (*LogicalDecodeStreamAbortCB) (struct LogicalDecodingContext *ctx,
                                            ReorderBufferTXN *txn,
                                            XLogRecPtr abort_lsn);
</programlisting>
     </para>
________________________________________________________-->
     <para>
      <function>stream_abort_cb</function> 被调用，以中止先前的流事务。
<programlisting>
typedef void (*LogicalDecodeStreamAbortCB) (struct LogicalDecodingContext *ctx,
                                            ReorderBufferTXN *txn,
                                            XLogRecPtr abort_lsn);
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=46fbe152a5e8f6df7a6661643e86b518 -->
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-stream-prepare">
<!-- pgdoc-cn_start sig_en=b675c5beed5b6e0114f128cbfabc2601 sig_cn_org=None source=14.1 
     <title>Stream Prepare Callback</title>
________________________________________________________-->
     <title>流准备回调</title>
<!-- pgdoc-cn_end sig_en=b675c5beed5b6e0114f128cbfabc2601 -->
<!-- pgdoc-cn_start sig_en=9712182de5afc618a314f32e0929c108 sig_cn_org=None source=14.1 
     <para>
      The <function>stream_prepare_cb</function> callback is called to prepare
      a previously streamed transaction as part of a two-phase commit.
<programlisting>
typedef void (*LogicalDecodeStreamPrepareCB) (struct LogicalDecodingContext *ctx,
                                              ReorderBufferTXN *txn,
                                              XLogRecPtr prepare_lsn);
</programlisting>
     </para>
________________________________________________________-->
     <para>
      <function>stream_prepare_cb</function> 回调被调用，以准备一个先前的流事务，作为两阶段提交的一部分。
<programlisting>
typedef void (*LogicalDecodeStreamPrepareCB) (struct LogicalDecodingContext *ctx,
                                              ReorderBufferTXN *txn,
                                              XLogRecPtr prepare_lsn);
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=9712182de5afc618a314f32e0929c108 -->
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-stream-commit">
<!-- pgdoc-cn_start sig_en=8230fdaf81e8681759ae14fbf917a490 sig_cn_org=None source=14.1 
     <title>Stream Commit Callback</title>
________________________________________________________-->
     <title>流提交回调</title>
<!-- pgdoc-cn_end sig_en=8230fdaf81e8681759ae14fbf917a490 -->
<!-- pgdoc-cn_start sig_en=7efae13a41f000944e9d7c72edf786db sig_cn_org=None source=14.1 
     <para>
      The <function>stream_commit_cb</function> callback is called to commit
      a previously streamed transaction.
<programlisting>
typedef void (*LogicalDecodeStreamCommitCB) (struct LogicalDecodingContext *ctx,
                                             ReorderBufferTXN *txn,
                                             XLogRecPtr commit_lsn);
</programlisting>
     </para>
________________________________________________________-->
     <para>
      <function>stream_commit_cb</function> 回调被调用，以提交一个先前的流事务。
<programlisting>
typedef void (*LogicalDecodeStreamCommitCB) (struct LogicalDecodingContext *ctx,
                                             ReorderBufferTXN *txn,
                                             XLogRecPtr commit_lsn);
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=7efae13a41f000944e9d7c72edf786db -->
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-stream-change">
<!-- pgdoc-cn_start sig_en=8f980a47ddf681c095d73a061c9bd191 sig_cn_org=None source=14.1 
     <title>Stream Change Callback</title>
________________________________________________________-->
     <title>流更改回调</title>
<!-- pgdoc-cn_end sig_en=8f980a47ddf681c095d73a061c9bd191 -->
<!-- pgdoc-cn_start sig_en=fad05a74b503c2003f4fba054652e410 sig_cn_org=None source=14.1 
     <para>
      The <function>stream_change_cb</function> callback is called when sending
      a change in a block of streamed changes (demarcated by
      <function>stream_start_cb</function> and <function>stream_stop_cb</function> calls).
      The actual changes are not displayed as the transaction can abort at a later
      point in time and we don't decode changes for aborted transactions.
<programlisting>
typedef void (*LogicalDecodeStreamChangeCB) (struct LogicalDecodingContext *ctx,
                                             ReorderBufferTXN *txn,
                                             Relation relation,
                                             ReorderBufferChange *change);
</programlisting>
     </para>
________________________________________________________-->
     <para>
      <function>stream_change_cb</function>回调被调用，在发送流更改块中的更改时(由<function>stream_start_cb</function> 和 <function>stream_stop_cb</function>调用划分)。
      实际的更改不会显示，因为事务可以在稍后的点及时中止，并且我们不会解码已中止的事务的更改。
<programlisting>
typedef void (*LogicalDecodeStreamChangeCB) (struct LogicalDecodingContext *ctx,
                                             ReorderBufferTXN *txn,
                                             Relation relation,
                                             ReorderBufferChange *change);
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=fad05a74b503c2003f4fba054652e410 -->
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-stream-message">
<!-- pgdoc-cn_start sig_en=ea4fac16a8174ad007b2a39137722e94 sig_cn_org=None source=14.1 
     <title>Stream Message Callback</title>
________________________________________________________-->
     <title>流消息回调</title>
<!-- pgdoc-cn_end sig_en=ea4fac16a8174ad007b2a39137722e94 -->
<!-- pgdoc-cn_start sig_en=28fab54554eb41a68217af5724d9e522 sig_cn_org=None source=14.1 
     <para>
      The <function>stream_message_cb</function> callback is called when sending
      a generic message in a block of streamed changes (demarcated by
      <function>stream_start_cb</function> and <function>stream_stop_cb</function> calls).
      The message contents for transactional messages are not displayed as the transaction
      can abort at a later point in time and we don't decode changes for aborted
      transactions.
<programlisting>
typedef void (*LogicalDecodeStreamMessageCB) (struct LogicalDecodingContext *ctx,
                                              ReorderBufferTXN *txn,
                                              XLogRecPtr message_lsn,
                                              bool transactional,
                                              const char *prefix,
                                              Size message_size,
                                              const char *message);
</programlisting>
     </para>
________________________________________________________-->
     <para>
      <function>stream_message_cb</function>回调被调用，在流更改块中发送通用消息时(由<function>stream_start_cb</function> 和 <function>stream_stop_cb</function>调用划分)。
      事务性消息的消息内容不会显示，因为事务可以在稍后的点及时中止，而且我们不会解码已中止事务的更改。
<programlisting>
typedef void (*LogicalDecodeStreamMessageCB) (struct LogicalDecodingContext *ctx,
                                              ReorderBufferTXN *txn,
                                              XLogRecPtr message_lsn,
                                              bool transactional,
                                              const char *prefix,
                                              Size message_size,
                                              const char *message);
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=28fab54554eb41a68217af5724d9e522 -->
    </sect3>

    <sect3 id="logicaldecoding-output-plugin-stream-truncate">
<!-- pgdoc-cn_start sig_en=6e95cf5697c9ba51b01744fd2e85fa36 sig_cn_org=None source=14.1 
     <title>Stream Truncate Callback</title>
________________________________________________________-->
     <title>流截断回调</title>
<!-- pgdoc-cn_end sig_en=6e95cf5697c9ba51b01744fd2e85fa36 -->
<!-- pgdoc-cn_start sig_en=d3a2465223d94c3ce48f7c1694c99bec sig_cn_org=None source=14.1 
     <para>
      The <function>stream_truncate_cb</function> callback is called for a
      <command>TRUNCATE</command> command in a block of streamed changes
      (demarcated by <function>stream_start_cb</function> and
      <function>stream_stop_cb</function> calls).
<programlisting>
typedef void (*LogicalDecodeStreamTruncateCB) (struct LogicalDecodingContext *ctx,
                                               ReorderBufferTXN *txn,
                                               int nrelations,
                                               Relation relations[],
                                               ReorderBufferChange *change);
</programlisting>
      The parameters are analogous to the <function>stream_change_cb</function>
      callback.  However, because <command>TRUNCATE</command> actions on
      tables connected by foreign keys need to be executed together, this
      callback receives an array of relations instead of just a single one.
      See the description of the <xref linkend="sql-truncate"/> statement for
      details.
     </para>
________________________________________________________-->
     <para>
      <function>stream_truncate_cb</function>回调被调用，用于在流更改的块中的 <command>TRUNCATE</command>命令(由<function>stream_start_cb</function> 和 <function>stream_stop_cb</function>调用划分)。
<programlisting>
typedef void (*LogicalDecodeStreamTruncateCB) (struct LogicalDecodingContext *ctx,
                                               ReorderBufferTXN *txn,
                                               int nrelations,
                                               Relation relations[],
                                               ReorderBufferChange *change);
</programlisting>
      此参数与<function>stream_change_cb</function>回调相似。
      但是，因为对由外键连接的表的<command>TRUNCATE</command>操作需要一起执行，因此该回调接收一个关系数组，而不仅是单个关系。
      详细信息请参见<xref linkend="sql-truncate"/>语句的描述。
     </para>
<!-- pgdoc-cn_end sig_en=d3a2465223d94c3ce48f7c1694c99bec -->
    </sect3>

   </sect2>

   <sect2 id="logicaldecoding-output-plugin-output">
<!-- pgdoc-cn_start sig_en=97c81f0c365b518789365eb9a86391c8 sig_cn_org=None source=14.1 
    <title>Functions for Producing Output</title>
________________________________________________________-->
    <title>用于产生输出的函数</title>
<!-- pgdoc-cn_end sig_en=97c81f0c365b518789365eb9a86391c8 -->

<!-- pgdoc-cn_start sig_en=cb166f55c192b2d4ed88c69b931378b2 sig_cn_org=None source=14.1 
    <para>
     To actually produce output, output plugins can write data to
     the <literal>StringInfo</literal> output buffer
     in <literal>ctx-&gt;out</literal> when inside
     the <function>begin_cb</function>, <function>commit_cb</function>,
     or <function>change_cb</function> callbacks. Before writing to the output
     buffer, <function>OutputPluginPrepareWrite(ctx, last_write)</function> has
     to be called, and after finishing writing to the
     buffer, <function>OutputPluginWrite(ctx, last_write)</function> has to be
     called to perform the write. The <parameter>last_write</parameter>
     indicates whether a particular write was the callback's last write.
    </para>
________________________________________________________-->
    <para>
     在<function>begin_cb</function>、<function>commit_cb</function>或者
      <function>change_cb</function>回调中，为了实际产生输出，
      输出插件可以把数据写入到<literal>ctx-&gt;out</literal>中的
      <literal>StringInfo</literal>输出缓冲区中。在写出到输出缓冲区之前，必须先
      调用<function>OutputPluginPrepareWrite(ctx, last_write)</function>，在完
      成写入到缓冲区后，必须调用
      <function>OutputPluginWrite(ctx, last_write)</function>来执行写出。
      <parameter>last_write</parameter>指出一次特定的写出是否为该回调的最后
      一次写出。
    </para>
<!-- pgdoc-cn_end sig_en=cb166f55c192b2d4ed88c69b931378b2 -->

<!-- pgdoc-cn_start sig_en=e0b54c93e06fca911e0ec6fac8a480e0 sig_cn_org=None source=14.1 
    <para>
     The following example shows how to output data to the consumer of an
     output plugin:
<programlisting>
OutputPluginPrepareWrite(ctx, true);
appendStringInfo(ctx->out, "BEGIN %u", txn->xid);
OutputPluginWrite(ctx, true);
</programlisting>
    </para>
________________________________________________________-->
    <para>
     下面的例子展示了如何把数据输出给一个输出插件的消费者：
<programlisting>
OutputPluginPrepareWrite(ctx, true);
appendStringInfo(ctx->out, "BEGIN %u", txn->xid);
OutputPluginWrite(ctx, true);
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=e0b54c93e06fca911e0ec6fac8a480e0 -->
   </sect2>
  </sect1>

  <sect1 id="logicaldecoding-writer">
<!-- pgdoc-cn_start sig_en=33656815fd338715b986467cde643896 sig_cn_org=None source=14.1 
   <title>Logical Decoding Output Writers</title>
________________________________________________________-->
   <title>逻辑解码输出写入器</title>
<!-- pgdoc-cn_end sig_en=33656815fd338715b986467cde643896 -->

<!-- pgdoc-cn_start sig_en=1e1844c2ba820c1a8c2b98a2fc360922 sig_cn_org=None source=14.1 
   <para>
    It is possible to add more output methods for logical decoding.
    For details, see
    <filename>src/backend/replication/logical/logicalfuncs.c</filename>.
    Essentially, three functions need to be provided: one to read WAL, one to
    prepare writing output, and one to write the output
    (see <xref linkend="logicaldecoding-output-plugin-output"/>).
   </para>
________________________________________________________-->
   <para>
    可以为逻辑解码增加更多输出方法。详情可见
    <filename>src/backend/replication/logical/logicalfuncs.c</filename>。
    本质上，需要提供三个函数：一个读取 WAL，一个准备写输出，另一个写输出（
    见<xref linkend="logicaldecoding-output-plugin-output"/>）。
   </para>
<!-- pgdoc-cn_end sig_en=1e1844c2ba820c1a8c2b98a2fc360922 -->
  </sect1>

  <sect1 id="logicaldecoding-synchronous">
<!-- pgdoc-cn_start sig_en=58e409ffc10585b3c8f72a7411439879 sig_cn_org=None source=14.1 
   <title>Synchronous Replication Support for Logical Decoding</title>
________________________________________________________-->
   <title>逻辑解码的同步复制支持</title>
<!-- pgdoc-cn_end sig_en=58e409ffc10585b3c8f72a7411439879 -->
   <sect2>
<!-- pgdoc-cn_start sig_en=13508788fd8dee2d1f9c928870e99338 sig_cn_org=None source=14.1 
    <title>Overview</title>
________________________________________________________-->
    <title>概述</title>
<!-- pgdoc-cn_end sig_en=13508788fd8dee2d1f9c928870e99338 -->

<!-- pgdoc-cn_start sig_en=e0e88e4f7bbc9288868f71aceb1b91f8 sig_cn_org=None source=14.1 
    <para>
     Logical decoding can be used to build
     <link linkend="synchronous-replication">synchronous
     replication</link> solutions with the same user interface as synchronous
     replication for <link linkend="streaming-replication">streaming
     replication</link>.  To do this, the streaming replication interface
     (see <xref linkend="logicaldecoding-walsender"/>) must be used to stream out
     data. Clients have to send <literal>Standby status update (F)</literal>
     (see <xref linkend="protocol-replication"/>) messages, just like streaming
     replication clients do.
    </para>
________________________________________________________-->
    <para>
     逻辑解码可以被用来构建    <link linkend="synchronous-replication">同步复制</link>方案，该方案具有和<link linkend="streaming-replication">流复制</link>的同步复制相同的用户接口。
     要这样做，流复制接口（见<xref linkend="logicaldecoding-walsender"/>）必须被用来流式传出数据。
     正如流复制客户端所作的一样，逻辑解码的客户端必须发出 <literal>后备机状态更新 (F)</literal>（见<xref linkend="protocol-replication"/>）消息。
    </para>
<!-- pgdoc-cn_end sig_en=e0e88e4f7bbc9288868f71aceb1b91f8 -->

    <note>
<!-- pgdoc-cn_start sig_en=9d5c51b6330361bbf563bc9347517cf8 sig_cn_org=None source=14.1 
     <para>
      A synchronous replica receiving changes via logical decoding will work in
      the scope of a single database. Since, in contrast to
      that, <parameter>synchronous_standby_names</parameter> currently is
      server wide, this means this technique will not work properly if more
      than one database is actively used.
     </para>
________________________________________________________-->
     <para>
      一个通过逻辑解码接收更改的同步复制机将工作在一个单一数据库的范围内。
      因为与之相反，<parameter>synchronous_standby_names</parameter> 当前是服务器范围的，这意味着如果有多于一个数据库被活跃地使用，这种技术将无法正常工作。
     </para>
<!-- pgdoc-cn_end sig_en=9d5c51b6330361bbf563bc9347517cf8 -->
    </note>
   </sect2>

   <sect2 id="logicaldecoding-synchronous-caveats">
<!-- pgdoc-cn_start sig_en=6aecf7221ae7403619467c1e1a1a629b sig_cn_org=None source=14.1 
    <title>Caveats</title>
________________________________________________________-->
    <title>警告</title>
<!-- pgdoc-cn_end sig_en=6aecf7221ae7403619467c1e1a1a629b -->

<!-- pgdoc-cn_start sig_en=05e77676a654cae8b837c0af7e9fdf3c sig_cn_org=None source=14.1 
    <para>
     In synchronous replication setup, a deadlock can happen, if the transaction
     has locked [user] catalog tables exclusively. See
     <xref linkend="logicaldecoding-capabilities"/> for information on user
     catalog tables. This is because logical decoding of transactions can lock
     catalog tables to access them. To avoid this users must refrain from taking
     an exclusive lock on [user] catalog tables. This can happen in the following
     ways:

     <itemizedlist>
      <listitem>
       <para>
        Issuing an explicit <command>LOCK</command> on <structname>pg_class</structname>
        in a transaction.
       </para>
      </listitem>

      <listitem>
       <para>
        Perform <command>CLUSTER</command> on <structname>pg_class</structname> in
        a transaction.
       </para>
      </listitem>

      <listitem>
       <para>
        <command>PREPARE TRANSACTION</command> after <command>LOCK</command> command
        on <structname>pg_class</structname> and allow logical decoding of two-phase
        transactions.
       </para>
      </listitem>

      <listitem>
       <para>
        <command>PREPARE TRANSACTION</command> after <command>CLUSTER</command>
        command on <structname>pg_trigger</structname> and allow logical decoding of
        two-phase transactions. This will lead to deadlock only when published table
        have a trigger.
       </para>
      </listitem>

      <listitem>
       <para>
        Executing <command>TRUNCATE</command> on [user] catalog table in a
        transaction.
       </para>
      </listitem>
     </itemizedlist>

     Note that these commands that can cause deadlock apply to not only explicitly
     indicated system catalog tables above but also to any other [user] catalog
     table.
    </para>
________________________________________________________-->
    <para>
     在同步复制设置中，死锁可能发生，如果事务排它地锁定了[user]目录表的话。
     有关用户目录表的信息，参见<xref linkend="logicaldecoding-capabilities"/>。
     这是因为事务的逻辑解码可以锁定目录表以便访问它们。
     为了避免这种情况，用户必须避免对[user]目录表执行排它锁。
     这可以通过以下方式发生:

     <itemizedlist>
      <listitem>
       <para>
        在事务中，在<structname>pg_class</structname>上发出显式<command>LOCK</command>。
       </para>
      </listitem>

      <listitem>
       <para>
        在事务中，在<structname>pg_class</structname>上执行 <command>CLUSTER</command>。
       </para>
      </listitem>

      <listitem>
       <para>
        在<structname>pg_class</structname>上<command>LOCK</command>命令之后的<command>PREPARE TRANSACTION</command>，并且允许对两阶段事务的逻辑解码。
       </para>
      </listitem>

      <listitem>
       <para>
        在<structname>pg_trigger</structname>上的<command>CLUSTER</command>命令之后的<command>PREPARE TRANSACTION</command>，并且允许对两阶段事务的逻辑解码。
        只有在发布的表有触发器时，这将会导致死锁。
       </para>
      </listitem>

      <listitem>
       <para>
        在事务中，在[user]目录表上执行<command>TRUNCATE</command>。
       </para>
      </listitem>
     </itemizedlist>

     注意，这些可能导致死锁的命令，不仅适用于上面显式标示的系统目录表，而且还适用于任何其他[user]目录表。
    </para>
<!-- pgdoc-cn_end sig_en=05e77676a654cae8b837c0af7e9fdf3c -->
   </sect2>
  </sect1>

  <sect1 id="logicaldecoding-streaming">
<!-- pgdoc-cn_start sig_en=3204bb78453a0d846a0718c756317741 sig_cn_org=None source=14.1 
   <title>Streaming of Large Transactions for Logical Decoding</title>
________________________________________________________-->
   <title>用于逻辑解码的大事务的流</title>
<!-- pgdoc-cn_end sig_en=3204bb78453a0d846a0718c756317741 -->

<!-- pgdoc-cn_start sig_en=7f7d05b27d57fb7e2b011eee91008a91 sig_cn_org=None source=14.1 
   <para>
    The basic output plugin callbacks (e.g., <function>begin_cb</function>,
    <function>change_cb</function>, <function>commit_cb</function> and
    <function>message_cb</function>) are only invoked when the transaction
    actually commits. The changes are still decoded from the transaction
    log, but are only passed to the output plugin at commit (and discarded
    if the transaction aborts).
   </para>
________________________________________________________-->
   <para>
    基本输出插件回调(例如，<function>begin_cb</function>,<function>change_cb</function>, <function>commit_cb</function> 和 <function>message_cb</function>)只在事务实际提交时调用。
    更改仍然从事务日志中解码，但只在提交时传递给输出插件(如果事务中止，则丢弃)。
   </para>
<!-- pgdoc-cn_end sig_en=7f7d05b27d57fb7e2b011eee91008a91 -->

<!-- pgdoc-cn_start sig_en=6432e06e41dfb2d06b3e04d18fd7c067 sig_cn_org=None source=14.1 
   <para>
    This means that while the decoding happens incrementally, and may spill
    to disk to keep memory usage under control, all the decoded changes have
    to be transmitted when the transaction finally commits (or more precisely,
    when the commit is decoded from the transaction log). Depending on the
    size of the transaction and network bandwidth, the transfer time may
    significantly increase the apply lag.
   </para>
________________________________________________________-->
   <para>
    这意味着虽然解码是增量进行的，并且可能溢出到磁盘以保持内存使用是可控的，
    当事务最终提交时(或者更准确地说，当提交已从事务日志中解码时)，必须传送所有已解码的更改。
    根据事务的大小和网络带宽，传输时间可能会显著增加应用时间间隔。
   </para>
<!-- pgdoc-cn_end sig_en=6432e06e41dfb2d06b3e04d18fd7c067 -->

<!-- pgdoc-cn_start sig_en=865a72ee25d01807a2f49d0c64516e0f sig_cn_org=8afbfbdd10295095c082609474af1b29 source=15.7 
   <para>
    To reduce the apply lag caused by large transactions, an output plugin
    may provide additional callback to support incremental streaming of
    in-progress transactions. There are multiple required streaming callbacks
    (<function>stream_start_cb</function>, <function>stream_stop_cb</function>,
    <function>stream_abort_cb</function>, <function>stream_commit_cb</function>
    and <function>stream_change_cb</function>) and two optional callbacks
    (<function>stream_message_cb</function> and <function>stream_truncate_cb</function>).
    Also, if streaming of two-phase commands is to be supported, then additional
    callbacks must be provided. (See <xref linkend="logicaldecoding-two-phase-commits"/>
    for details).
   </para>
________________________________________________________-->
   <para>
    为了减少大事务引起的应用延迟，输出插件可以提供额外的回调来支持正在进行中事务的增量流式传输。
    有多个必需的流式传输回调（<function>stream_start_cb</function>、<function>stream_stop_cb</function>、
    <function>stream_abort_cb</function>、<function>stream_commit_cb</function>和<function>stream_change_cb</function>），
    以及两个可选的回调（<function>stream_message_cb</function>和<function>stream_truncate_cb</function>）。
    此外，如果要支持两阶段命令的流式传输，则必须提供额外的回调。（有关详细信息，请参见<xref linkend="logicaldecoding-two-phase-commits"/>）。
</para>
<!-- pgdoc-cn_end sig_en=865a72ee25d01807a2f49d0c64516e0f -->

<!-- pgdoc-cn_start sig_en=8091181c0019f50309704c8736c75dbb sig_cn_org=688d07814762140dc6b43453a3b08ec4 source=15.7 
   <para>
    When streaming an in-progress transaction, the changes (and messages) are
    streamed in blocks demarcated by <function>stream_start_cb</function>
    and <function>stream_stop_cb</function> callbacks. Once all the decoded
    changes are transmitted, the transaction can be committed using the
    <function>stream_commit_cb</function> callback
    (or possibly aborted using the <function>stream_abort_cb</function> callback).
    If two-phase commits are supported, the transaction can be prepared using the
    <function>stream_prepare_cb</function> callback,
    <command>COMMIT PREPARED</command> using the
    <function>commit_prepared_cb</function> callback or aborted using the
    <function>rollback_prepared_cb</function>.
   </para>
________________________________________________________-->
   <para>
    当流式传输正在进行的事务时，更改（和消息）以由<function>stream_start_cb</function>和<function>stream_stop_cb</function>回调标记的块进行流式传输。
    一旦所有解码的更改被传输，事务可以使用<function>stream_commit_cb</function>回调提交
    （或可能使用<function>stream_abort_cb</function>回调中止）。
    如果支持两阶段提交，事务可以使用<function>stream_prepare_cb</function>回调准备，
    使用<command>COMMIT PREPARED</command>并使用<function>commit_prepared_cb</function>回调或使用<function>rollback_prepared_cb</function>中止。
   </para>
<!-- pgdoc-cn_end sig_en=8091181c0019f50309704c8736c75dbb -->

<!-- pgdoc-cn_start sig_en=2fb437ac5323846ebaf09b8f6a0bb506 sig_cn_org=9b1731eff8491801e66f584122588be4 source=15.7 
   <para>
    One example sequence of streaming callback calls for one transaction may
    look like this:
<programlisting>
stream_start_cb(...);   &lt;-&minus; start of first block of changes
  stream_change_cb(...);
  stream_change_cb(...);
  stream_message_cb(...);
  stream_change_cb(...);
  ...
  stream_change_cb(...);
stream_stop_cb(...);    &lt;-&minus; end of first block of changes

stream_start_cb(...);   &lt;-&minus; start of second block of changes
  stream_change_cb(...);
  stream_change_cb(...);
  stream_change_cb(...);
  ...
  stream_message_cb(...);
  stream_change_cb(...);
stream_stop_cb(...);    &lt;-&minus; end of second block of changes


[a. when using normal commit]
stream_commit_cb(...);    &lt;-&minus; commit of the streamed transaction

[b. when using two-phase commit]
stream_prepare_cb(...);   &lt;-&minus; prepare the streamed transaction
commit_prepared_cb(...);  &lt;-&minus; commit of the prepared transaction
</programlisting>
   </para>
________________________________________________________-->
   <para>
    一个事务的流式回调调用示例可能如下所示：
<programlisting>
stream_start_cb(...);   &lt;-- 开始第一个更改块
  stream_change_cb(...);
  stream_change_cb(...);
  stream_message_cb(...);
  stream_change_cb(...);
  ...
  stream_change_cb(...);
stream_stop_cb(...);    &lt;-- 结束第一个更改块

stream_start_cb(...);   &lt;-- 开始第二个更改块
  stream_change_cb(...);
  stream_change_cb(...);
  stream_change_cb(...);
  ...
  stream_message_cb(...);
  stream_change_cb(...);
stream_stop_cb(...);    &lt;-- 结束第二个更改块


[a. 使用普通提交时]
stream_commit_cb(...);    &lt;-- 提交流式事务

[b. 使用两阶段提交时]
stream_prepare_cb(...);   &lt;-- 准备流式事务
commit_prepared_cb(...);  &lt;-- 提交准备好的事务
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=2fb437ac5323846ebaf09b8f6a0bb506 -->

<!-- pgdoc-cn_start sig_en=d34eb6e3b24a58447708508f18618ff8 sig_cn_org=None source=14.1 
   <para>
    The actual sequence of callback calls may be more complicated, of course.
    There may be blocks for multiple streamed transactions, some of the
    transactions may get aborted, etc.
   </para>
________________________________________________________-->
   <para>
    当然，回调调用的实际顺序可能更复杂。
    可能会有多个流事务的块，一些事务也许会被中止，等等。
   </para>
<!-- pgdoc-cn_end sig_en=d34eb6e3b24a58447708508f18618ff8 -->

<!-- pgdoc-cn_start sig_en=d16e21bf82f3f33db5885dcf71737005 sig_cn_org=None source=14.1 
   <para>
    Similar to spill-to-disk behavior, streaming is triggered when the total
    amount of changes decoded from the WAL (for all in-progress transactions)
    exceeds the limit defined by <varname>logical_decoding_work_mem</varname> setting.
    At that point, the largest top-level transaction (measured by the amount of memory
    currently used for decoded changes) is selected and streamed.  However, in
    some cases we still have to spill to disk even if streaming is enabled
    because we exceed the memory threshold but still have not decoded the
    complete tuple e.g., only decoded toast table insert but not the main table
    insert.
   </para>
________________________________________________________-->
   <para>
    与溢出到磁盘的行为类似，流会被触发，当从WAL(对于所有正在进行的事务)解码的更改总数超过<varname>logical_decoding_work_mem</varname>设置定义的限制时。
    此时，最大的顶级事务(通过当前用于解码更改的内存量来衡量)会被选择并流式处理。
    然而，在某些情况下，即使启用了流，我们仍然必须溢出到磁盘，因为我们超过了内存阈值，但仍然没有解码完整的元组，例如，只解码toast表插入，但没有主表插入。
   </para>
<!-- pgdoc-cn_end sig_en=d16e21bf82f3f33db5885dcf71737005 -->

<!-- pgdoc-cn_start sig_en=72894f4d8bc467a93e23bd3ea91ad84d sig_cn_org=None source=14.1 
   <para>
    Even when streaming large transactions, the changes are still applied in
    commit order, preserving the same guarantees as the non-streaming mode.
   </para>
________________________________________________________-->
   <para>
    即使在流式处理大型事务时，更改仍然按照提交顺序应用，保留了与非流式模式相同的保证。
   </para>
<!-- pgdoc-cn_end sig_en=72894f4d8bc467a93e23bd3ea91ad84d -->

  </sect1>

  <sect1 id="logicaldecoding-two-phase-commits">
<!-- pgdoc-cn_start sig_en=760006f16e020bf12541adbea8a5b942 sig_cn_org=None source=14.1 
   <title>Two-phase Commit Support for Logical Decoding</title>
________________________________________________________-->
   <title>对逻辑解码的两阶段提交支持</title>
<!-- pgdoc-cn_end sig_en=760006f16e020bf12541adbea8a5b942 -->

<!-- pgdoc-cn_start sig_en=b39c7aee287d729ab38ea0e36e570721 sig_cn_org=None source=14.1 
   <para>
    With the basic output plugin callbacks (eg., <function>begin_cb</function>,
    <function>change_cb</function>, <function>commit_cb</function> and
    <function>message_cb</function>) two-phase commit commands like
    <command>PREPARE TRANSACTION</command>, <command>COMMIT PREPARED</command>
    and <command>ROLLBACK PREPARED</command> are not decoded. While the
    <command>PREPARE TRANSACTION</command> is ignored,
    <command>COMMIT PREPARED</command> is decoded as a <command>COMMIT</command>
    and <command>ROLLBACK PREPARED</command> is decoded as a
    <command>ROLLBACK</command>.
   </para>
________________________________________________________-->
   <para>
    使用基本输出插件回调(例如;<function>begin_cb</function>,<function>change_cb</function>, <function>commit_cb</function> 和 <function>message_cb</function>)两阶段提交命令，像<command>PREPARE TRANSACTION</command>, <command>COMMIT PREPARED</command> 和 <command>ROLLBACK PREPARED</command>不被解码。
    当<command>PREPARE TRANSACTION</command>被忽略时，<command>COMMIT PREPARED</command>被解码为<command>COMMIT</command>， 并且<command>ROLLBACK PREPARED</command>被解码为<command>ROLLBACK</command>。
   </para>
<!-- pgdoc-cn_end sig_en=b39c7aee287d729ab38ea0e36e570721 -->

<!-- pgdoc-cn_start sig_en=7af68066c4c135e54a1b69064f58b8d0 sig_cn_org=None source=14.1 
   <para>
    To support the streaming of two-phase commands, an output plugin needs to
    provide additional callbacks. There are multiple two-phase commit callbacks
    that are required, (<function>begin_prepare_cb</function>,
    <function>prepare_cb</function>, <function>commit_prepared_cb</function>,
    <function>rollback_prepared_cb</function> and
    <function>stream_prepare_cb</function>) and an optional callback
    (<function>filter_prepare_cb</function>).
   </para>
________________________________________________________-->
   <para>
    为了支持两阶段命令的流，输出插件需要提供附加的回调。
    有多个需要的两阶段提交回调，(<function>begin_prepare_cb</function>,<function>prepare_cb</function>, <function>commit_prepared_cb</function>,<function>rollback_prepared_cb</function> 和 <function>stream_prepare_cb</function>)以及一个可选的回调(<function>filter_prepare_cb</function>)。
   </para>
<!-- pgdoc-cn_end sig_en=7af68066c4c135e54a1b69064f58b8d0 -->

<!-- pgdoc-cn_start sig_en=706af8077a0cfababcadf0ac75a09425 sig_cn_org=None source=14.1 
   <para>
    If the output plugin callbacks for decoding two-phase commit commands are
    provided, then on <command>PREPARE TRANSACTION</command>, the changes of
    that transaction are decoded, passed to the output plugin, and the
    <function>prepare_cb</function> callback is invoked. This differs from the
    basic decoding setup where changes are only passed to the output plugin
    when a transaction is committed. The start of a prepared transaction is
    indicated by the <function>begin_prepare_cb</function> callback.
   </para>
________________________________________________________-->
   <para>
    如果提供了解码两阶段提交命令的输出插件回调，那么在<command>PREPARE TRANSACTION</command>上，该事务的更改被解码，传递给输出插件，并调用<function>prepare_cb</function>回调。
    这与只有在提交事务时才将更改传递给输出插件的基本解码设置不同。
    准备好的事务的开始由<function>begin_prepare_cb</function>回调指示。
   </para>
<!-- pgdoc-cn_end sig_en=706af8077a0cfababcadf0ac75a09425 -->

<!-- pgdoc-cn_start sig_en=788f36b470dfa8999110c275587913bb sig_cn_org=None source=14.1 
   <para>
    When a prepared transaction is rolled back using the
    <command>ROLLBACK PREPARED</command>, then the
    <function>rollback_prepared_cb</function> callback is invoked and when the
    prepared transaction is committed using <command>COMMIT PREPARED</command>,
    then the <function>commit_prepared_cb</function> callback is invoked.
   </para>
________________________________________________________-->
   <para>
    当使用<command>ROLLBACK PREPARED</command>回滚一个准备好的事务时，则调用<function>rollback_prepared_cb</function>回调，当准备好的事务使用<command>COMMIT PREPARED</command>提交时，则调用<function>commit_prepared_cb</function>回调。
   </para>
<!-- pgdoc-cn_end sig_en=788f36b470dfa8999110c275587913bb -->

<!-- pgdoc-cn_start sig_en=18f6cdfc55aa0cb90386a66b8284dd34 sig_cn_org=None source=14.1 
   <para>
    Optionally the output plugin can define filtering rules via
    <function>filter_prepare_cb</function> to decode only specific transaction
    in two phases.  This can be achieved by pattern matching on the
    <parameter>gid</parameter> or via lookups using the
    <parameter>xid</parameter>.
   </para>
________________________________________________________-->
   <para>
    可选的，输出插件还可以通过<function>filter_prepare_cb</function>定义过滤规则，以在两个阶段中只解码特定的事务。
    这可以通过在<parameter>gid</parameter>上进行模式匹配或通过使用<parameter>xid</parameter>查找来实现。
   </para>
<!-- pgdoc-cn_end sig_en=18f6cdfc55aa0cb90386a66b8284dd34 -->

<!-- pgdoc-cn_start sig_en=bdf55173ab2d55630df759780358f7e6 sig_cn_org=None source=14.1 
   <para>
    The users that want to decode prepared transactions need to be careful about
    below mentioned points:

    <itemizedlist>
     <listitem>
      <para>
       If the prepared transaction has locked [user] catalog tables exclusively
       then decoding prepare can block till the main transaction is committed.
      </para>
     </listitem>

     <listitem>
      <para>
       The logical replication solution that builds distributed two phase commit
       using this feature can deadlock if the prepared transaction has locked
       [user] catalog tables exclusively. To avoid this users must refrain from
       having locks on catalog tables (e.g. explicit <command>LOCK</command> command)
       in such transactions.
       See <xref linkend="logicaldecoding-synchronous-caveats"/> for the details.
      </para>
     </listitem>
    </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    想要解码准备好的事务的用户，需要注意以下提到的几点:

    <itemizedlist>
     <listitem>
      <para>
       如果准备的事务排它地锁定了[user]目录表，那么解码准备可以阻塞，直到主事务被提交。
      </para>
     </listitem>

     <listitem>
      <para>
       用此特性构建分布式两阶段提交的逻辑复制解决方案可能会死锁，如果准备好的事务排它地锁定了[user]目录表的话。
       为了避免这种情况，用户必须避免在这样的事务中在编目表上加锁(例如显式的<command>LOCK</command>命令)。
       详请参阅<xref linkend="logicaldecoding-synchronous-caveats"/>。
      </para>
     </listitem>
    </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=bdf55173ab2d55630df759780358f7e6 -->

  </sect1>
 </chapter>
