<!-- doc/src/sgml/advanced.sgml -->

 <chapter id="tutorial-advanced">
<!-- pgdoc-cn_start sig_en=721b22b3ea91afd1d769d361ca132ef3 sig_cn_org=None source=14.1 
  <title>Advanced Features</title>
________________________________________________________-->
  <title>高级特性</title>
<!-- pgdoc-cn_end sig_en=721b22b3ea91afd1d769d361ca132ef3 -->

  <sect1 id="tutorial-advanced-intro">
<!-- pgdoc-cn_start sig_en=c2fcf93c611ba5f3baff759a5cc428dd sig_cn_org=None source=14.1 
   <title>Introduction</title>
________________________________________________________-->
   <title>简介</title>
<!-- pgdoc-cn_end sig_en=c2fcf93c611ba5f3baff759a5cc428dd -->

<!-- pgdoc-cn_start sig_en=12fdaddbde0308faa73d09d92c97441f sig_cn_org=None source=14.1 
   <para>
    In the previous chapter we have covered the basics of using
    <acronym>SQL</acronym> to store and access your data in
    <productname>PostgreSQL</productname>.  We will now discuss some
    more advanced features of <acronym>SQL</acronym> that simplify
    management and prevent loss or corruption of your data.  Finally,
    we will look at some <productname>PostgreSQL</productname>
    extensions.
   </para>
________________________________________________________-->
   <para>
    在之前的章节里我们已经涉及了使用<acronym>SQL</acronym>在<productname>PostgreSQL</productname>中存储和访问数据的基础知识。现在我们将要讨论<acronym>SQL</acronym>中一些更高级的特性，这些特性有助于简化管理和防止数据丢失或损坏。最后，我们还将介绍一些<productname>PostgreSQL</productname>扩展。
   </para>
<!-- pgdoc-cn_end sig_en=12fdaddbde0308faa73d09d92c97441f -->

<!-- pgdoc-cn_start sig_en=3442b2863f3333347b4b4fc090662dfa sig_cn_org=None source=14.1 
   <para>
    This chapter will on occasion refer to examples found in <xref
    linkend="tutorial-sql"/> to change or improve them, so it will be
    useful to have read that chapter.  Some examples from
    this chapter can also be found in
    <filename>advanced.sql</filename> in the tutorial directory.  This
    file also contains some sample data to load, which is not
    repeated here.  (Refer to <xref linkend="tutorial-sql-intro"/> for
    how to use the file.)
   </para>
________________________________________________________-->
   <para>
    本章有时将引用<xref
    linkend="tutorial-sql"/>中的例子并对其进行改变或改进以便于阅读本章。本章中的某些例子可以在教程目录的<filename>advanced.sql</filename>文件中找到。该文件也包含一些样例数据，在这里就不在赘述（查看<xref linkend="tutorial-sql-intro"/>了解如何使用该文件）。
   </para>
<!-- pgdoc-cn_end sig_en=3442b2863f3333347b4b4fc090662dfa -->
  </sect1>


  <sect1 id="tutorial-views">
<!-- pgdoc-cn_start sig_en=7448c77b4ae04bebc4ffc05c780a5e82 sig_cn_org=None source=14.1 
   <title>Views</title>
________________________________________________________-->
   <title>视图</title>
<!-- pgdoc-cn_end sig_en=7448c77b4ae04bebc4ffc05c780a5e82 -->

<!-- pgdoc-cn_start sig_en=562847e5a2a24047d5df84bac009d7f2 sig_cn_org=None source=14.1 
   <indexterm zone="tutorial-views">
    <primary>view</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="tutorial-views">
    <primary>view</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=562847e5a2a24047d5df84bac009d7f2 -->

<!-- pgdoc-cn_start sig_en=a4df5447d5f191710821fa8b8afbd57a sig_cn_org=None source=14.1 
   <para>
    Refer back to the queries in <xref linkend="tutorial-join"/>.
    Suppose the combined listing of weather records and city location
    is of particular interest to your application, but you do not want
    to type the query each time you need it.  You can create a
    <firstterm>view</firstterm> over the query, which gives a name to
    the query that you can refer to like an ordinary table:

<programlisting>
CREATE VIEW myview AS
    SELECT name, temp_lo, temp_hi, prcp, date, location
        FROM weather, cities
        WHERE city = name;

SELECT * FROM myview;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    回想一下<xref linkend="tutorial-join"/>中的查询。假设天气记录和城市位置的组合列表对我们的应用有用，但我们又不想每次需要使用它时都敲入整个查询。我们可以在该查询上创建一个<firstterm>视图</firstterm>，这会给该查询一个名字，我们可以像使用一个普通表一样来使用它：

<programlisting>
CREATE VIEW myview AS
    SELECT name, temp_lo, temp_hi, prcp, date, location
        FROM weather, cities
        WHERE city = name;

SELECT * FROM myview;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=a4df5447d5f191710821fa8b8afbd57a -->

<!-- pgdoc-cn_start sig_en=10796c02436a97a499f74c2f8dbf1880 sig_cn_org=None source=14.1 
   <para>
    Making liberal use of views is a key aspect of good SQL database
    design.  Views allow you to encapsulate the details of the
    structure of your tables, which might change as your application
    evolves, behind consistent interfaces.
   </para>
________________________________________________________-->
   <para>
    对视图的使用是成就一个好的SQL数据库设计的关键方面。视图允许用户通过始终如一的接口封装表的结构细节，这样可以避免表结构随着应用的进化而改变。
   </para>
<!-- pgdoc-cn_end sig_en=10796c02436a97a499f74c2f8dbf1880 -->

<!-- pgdoc-cn_start sig_en=ab867b9b6d4d93a31280fcaca82b4de7 sig_cn_org=None source=14.1 
   <para>
    Views can be used in almost any place a real table can be used.
    Building views upon other views is not uncommon.
   </para>
________________________________________________________-->
   <para>
    视图几乎可以用在任何可以使用表的地方。在其他视图基础上创建视图也并不少见。
   </para>
<!-- pgdoc-cn_end sig_en=ab867b9b6d4d93a31280fcaca82b4de7 -->
  </sect1>


  <sect1 id="tutorial-fk">
<!-- pgdoc-cn_start sig_en=2e1bee7418a81d4028f47ffa09044a6f sig_cn_org=None source=14.1 
   <title>Foreign Keys</title>
________________________________________________________-->
   <title>外键</title>
<!-- pgdoc-cn_end sig_en=2e1bee7418a81d4028f47ffa09044a6f -->

<!-- pgdoc-cn_start sig_en=14ea3e6b288b472d70808ff3eda501be sig_cn_org=None source=14.1 
   <indexterm zone="tutorial-fk">
    <primary>foreign key</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="tutorial-fk">
    <primary>foreign key</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=14ea3e6b288b472d70808ff3eda501be -->

<!-- pgdoc-cn_start sig_en=b21c4597c66dd7860c692542895a2e53 sig_cn_org=None source=14.1 
   <indexterm zone="tutorial-fk">
    <primary>referential integrity</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="tutorial-fk">
    <primary>referential integrity</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=b21c4597c66dd7860c692542895a2e53 -->

<!-- pgdoc-cn_start sig_en=b60b1862834e44a47dd1071a58dcd306 sig_cn_org=None source=14.1 
   <para>
    Recall the <classname>weather</classname> and
    <classname>cities</classname> tables from <xref
    linkend="tutorial-sql"/>.  Consider the following problem:  You
    want to make sure that no one can insert rows in the
    <classname>weather</classname> table that do not have a matching
    entry in the <classname>cities</classname> table.  This is called
    maintaining the <firstterm>referential integrity</firstterm> of
    your data.  In simplistic database systems this would be
    implemented (if at all) by first looking at the
    <classname>cities</classname> table to check if a matching record
    exists, and then inserting or rejecting the new
    <classname>weather</classname> records.  This approach has a
    number of problems and is very inconvenient, so
    <productname>PostgreSQL</productname> can do this for you.
   </para>
________________________________________________________-->
   <para>
    回想第2章中的<classname>weather</classname>和<classname>cities</classname>表。考虑以下问题：我们希望确保在<classname>cities</classname>表中有相应项之前任何人都不能在<classname>weather</classname>表中插入行。这叫做维持数据的<firstterm>引用完整性</firstterm>。在过分简化的数据库系统中，可以通过先检查<classname>cities</classname>表中是否有匹配的记录存在，然后决定应该接受还是拒绝即将插入<classname>weather</classname>表的行。这种方法有一些问题且并不方便，于是<productname>PostgreSQL</productname>可以为我们来解决：
   </para>
<!-- pgdoc-cn_end sig_en=b60b1862834e44a47dd1071a58dcd306 -->

<!-- pgdoc-cn_start sig_en=f20015c7b1466f5e4578bd49bef8a22a sig_cn_org=None source=14.1 
   <para>
    The new declaration of the tables would look like this:

<programlisting>
CREATE TABLE cities (
        name     varchar(80) primary key,
        location point
);

CREATE TABLE weather (
        city      varchar(80) references cities(name),
        temp_lo   int,
        temp_hi   int,
        prcp      real,
        date      date
);
</programlisting>

    Now try inserting an invalid record:

<programlisting>
INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');
</programlisting>

<screen>
ERROR:  insert or update on table "weather" violates foreign key constraint "weather_city_fkey"
DETAIL:  Key (city)=(Berkeley) is not present in table "cities".
</screen>
   </para>
________________________________________________________-->
   <para>
    新的表定义如下：

<programlisting>
CREATE TABLE cities (
        name     varchar(80) primary key,
        location point
);

CREATE TABLE weather (
        city      varchar(80) references cities(name),
        temp_lo   int,
        temp_hi   int,
        prcp      real,
        date      date
);
</programlisting>

    现在尝试插入一个非法的记录：

<programlisting>
INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');
</programlisting>

<screen>
ERROR:  insert or update on table "weather" violates foreign key constraint "weather_city_fkey"
DETAIL:  Key (city)=(Berkeley) is not present in table "cities".
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=f20015c7b1466f5e4578bd49bef8a22a -->

<!-- pgdoc-cn_start sig_en=6368958eaf7638acbcecbb2dbb9c5b75 sig_cn_org=None source=14.1 
   <para>
    The behavior of foreign keys can be finely tuned to your
    application.  We will not go beyond this simple example in this
    tutorial, but just refer you to <xref linkend="ddl"/>
    for more information.  Making correct use of
    foreign keys will definitely improve the quality of your database
    applications, so you are strongly encouraged to learn about them.
   </para>
________________________________________________________-->
   <para>
    外键的行为可以很好地根据应用来调整。我们不会在这个教程里更深入地介绍，读者可以参考<xref linkend="ddl"/>中的信息。正确使用外键无疑会提高数据库应用的质量，因此强烈建议用户学会如何使用它们。
   </para>
<!-- pgdoc-cn_end sig_en=6368958eaf7638acbcecbb2dbb9c5b75 -->
  </sect1>


  <sect1 id="tutorial-transactions">
<!-- pgdoc-cn_start sig_en=affeceef395cc78437893315eb4e4491 sig_cn_org=None source=14.1 
   <title>Transactions</title>
________________________________________________________-->
   <title>事务</title>
<!-- pgdoc-cn_end sig_en=affeceef395cc78437893315eb4e4491 -->

<!-- pgdoc-cn_start sig_en=36e66d2046ca706e2a6f696314c9249a sig_cn_org=None source=14.1 
   <indexterm zone="tutorial-transactions">
    <primary>transaction</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="tutorial-transactions">
    <primary>transaction</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=36e66d2046ca706e2a6f696314c9249a -->

<!-- pgdoc-cn_start sig_en=42ae81adcde9bf087be5c6930ad21355 sig_cn_org=None source=14.1 
   <para>
    <firstterm>Transactions</firstterm> are a fundamental concept of all database
    systems.  The essential point of a transaction is that it bundles
    multiple steps into a single, all-or-nothing operation.  The intermediate
    states between the steps are not visible to other concurrent transactions,
    and if some failure occurs that prevents the transaction from completing,
    then none of the steps affect the database at all.
   </para>
________________________________________________________-->
   <para>
    <firstterm>事务</firstterm>是所有数据库系统的基础概念。事务最重要的一点是它将多个步骤捆绑成了一个单一的、要么全完成要么全不完成的操作。步骤之间的中间状态对于其他并发事务是不可见的，并且如果有某些错误发生导致事务不能完成，则其中任何一个步骤都不会对数据库造成影响。
   </para>
<!-- pgdoc-cn_end sig_en=42ae81adcde9bf087be5c6930ad21355 -->

<!-- pgdoc-cn_start sig_en=675e8cdb12ff2b44b2478c568b563de5 sig_cn_org=None source=14.1 
   <para>
    For example, consider a bank database that contains balances for various
    customer accounts, as well as total deposit balances for branches.
    Suppose that we want to record a payment of $100.00 from Alice's account
    to Bob's account.  Simplifying outrageously, the SQL commands for this
    might look like:

<programlisting>
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
UPDATE branches SET balance = balance - 100.00
    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Alice');
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Bob';
UPDATE branches SET balance = balance + 100.00
    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Bob');
</programlisting>
   </para>
________________________________________________________-->
   <para>
    例如，考虑一个保存着多个客户账户余额和支行总存款额的银行数据库。假设我们希望记录一笔从Alice的账户到Bob的账户的额度为100.00美元的转账。在最大程度地简化后，涉及到的SQL命令是：

<programlisting>
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
UPDATE branches SET balance = balance - 100.00
    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Alice');
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Bob';
UPDATE branches SET balance = balance + 100.00
    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Bob');
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=675e8cdb12ff2b44b2478c568b563de5 -->

<!-- pgdoc-cn_start sig_en=06f8008b534821857e328272c5429316 sig_cn_org=None source=14.1 
   <para>
    The details of these commands are not important here; the important
    point is that there are several separate updates involved to accomplish
    this rather simple operation.  Our bank's officers will want to be
    assured that either all these updates happen, or none of them happen.
    It would certainly not do for a system failure to result in Bob
    receiving $100.00 that was not debited from Alice.  Nor would Alice long
    remain a happy customer if she was debited without Bob being credited.
    We need a guarantee that if something goes wrong partway through the
    operation, none of the steps executed so far will take effect.  Grouping
    the updates into a <firstterm>transaction</firstterm> gives us this guarantee.
    A transaction is said to be <firstterm>atomic</firstterm>: from the point of
    view of other transactions, it either happens completely or not at all.
   </para>
________________________________________________________-->
   <para>
    这些命令的细节在这里并不重要，关键点是为了完成这个相当简单的操作涉及到多个独立的更新。我们的银行职员希望确保这些更新要么全部发生，或者全部不发生。当然不能发生因为系统错误导致Bob收到100美元而Alice并未被扣款的情况。Alice当然也不希望自己被扣款而Bob没有收到钱。我们需要一种保障，当操作中途某些错误发生时已经执行的步骤不会产生效果。将这些更新组织成一个<firstterm>事务</firstterm>就可以给我们这种保障。一个事务被称为是<firstterm>原子的</firstterm>：从其他事务的角度来看，它要么整个发生要么完全不发生。
   </para>
<!-- pgdoc-cn_end sig_en=06f8008b534821857e328272c5429316 -->

<!-- pgdoc-cn_start sig_en=8e560f53080fef361bb666c38c9b4495 sig_cn_org=None source=14.1 
   <para>
    We also want a
    guarantee that once a transaction is completed and acknowledged by
    the database system, it has indeed been permanently recorded
    and won't be lost even if a crash ensues shortly thereafter.
    For example, if we are recording a cash withdrawal by Bob,
    we do not want any chance that the debit to his account will
    disappear in a crash just after he walks out the bank door.
    A transactional database guarantees that all the updates made by
    a transaction are logged in permanent storage (i.e., on disk) before
    the transaction is reported complete.
   </para>
________________________________________________________-->
   <para>
    我们同样希望能保证一旦一个事务被数据库系统完成并认可，它就被永久地记录下来且即便其后发生崩溃也不会被丢失。例如，如果我们正在记录Bob的一次现金提款，我们当然不希望他刚走出银行大门，对他账户的扣款就消失。一个事务型数据库保证一个事务在被报告为完成之前它所做的所有更新都被记录在持久存储（即磁盘）。
   </para>
<!-- pgdoc-cn_end sig_en=8e560f53080fef361bb666c38c9b4495 -->

<!-- pgdoc-cn_start sig_en=f476ebc04981646602ed65989966696b sig_cn_org=None source=14.1 
   <para>
    Another important property of transactional databases is closely
    related to the notion of atomic updates: when multiple transactions
    are running concurrently, each one should not be able to see the
    incomplete changes made by others.  For example, if one transaction
    is busy totalling all the branch balances, it would not do for it
    to include the debit from Alice's branch but not the credit to
    Bob's branch, nor vice versa.  So transactions must be all-or-nothing
    not only in terms of their permanent effect on the database, but
    also in terms of their visibility as they happen.  The updates made
    so far by an open transaction are invisible to other transactions
    until the transaction completes, whereupon all the updates become
    visible simultaneously.
   </para>
________________________________________________________-->
   <para>
    事务型数据库的另一个重要性质与原子更新的概念紧密相关：当多个事务并发运行时，每一个都不能看到其他事务未完成的修改。例如，如果一个事务正忙着总计所有支行的余额，它不会只包括Alice的支行的扣款而不包括Bob的支行的存款，或者反之。所以事务的全做或全不做并不只体现在它们对数据库的持久影响，也体现在它们发生时的可见性。一个事务所做的更新在它完成之前对于其他事务是不可见的，而之后所有的更新将同时变得可见。
   </para>
<!-- pgdoc-cn_end sig_en=f476ebc04981646602ed65989966696b -->

<!-- pgdoc-cn_start sig_en=ee546117ff50e0cea4da41640145f12f sig_cn_org=None source=14.1 
   <para>
    In <productname>PostgreSQL</productname>, a transaction is set up by surrounding
    the SQL commands of the transaction with
    <command>BEGIN</command> and <command>COMMIT</command> commands.  So our banking
    transaction would actually look like:

<programlisting>
BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
-&minus; etc etc
COMMIT;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname>中，开启一个事务需要将SQL命令用<command>BEGIN</command>和<command>COMMIT</command>命令包围起来。因此我们的银行事务看起来会是这样：

<programlisting>
BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
-- etc etc
COMMIT;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=ee546117ff50e0cea4da41640145f12f -->

<!-- pgdoc-cn_start sig_en=d5328a596a17c4136baf83959a7307d5 sig_cn_org=None source=14.1 
   <para>
    If, partway through the transaction, we decide we do not want to
    commit (perhaps we just noticed that Alice's balance went negative),
    we can issue the command <command>ROLLBACK</command> instead of
    <command>COMMIT</command>, and all our updates so far will be canceled.
   </para>
________________________________________________________-->
   <para>
    如果，在事务执行中我们并不想提交（或许是我们注意到Alice的余额不足），我们可以发出<command>ROLLBACK</command>命令而不是<command>COMMIT</command>命令，这样所有目前的更新将会被取消。
   </para>
<!-- pgdoc-cn_end sig_en=d5328a596a17c4136baf83959a7307d5 -->

<!-- pgdoc-cn_start sig_en=cc13b8e83e74e59f2dac0aaf46aa617a sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> actually treats every SQL statement as being
    executed within a transaction.  If you do not issue a <command>BEGIN</command>
    command,
    then each individual statement has an implicit <command>BEGIN</command> and
    (if successful) <command>COMMIT</command> wrapped around it.  A group of
    statements surrounded by <command>BEGIN</command> and <command>COMMIT</command>
    is sometimes called a <firstterm>transaction block</firstterm>.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>实际上将每一个SQL语句都作为一个事务来执行。如果我们没有发出<command>BEGIN</command>命令，则每个独立的语句都会被加上一个隐式的<command>BEGIN</command>以及（如果成功）<command>COMMIT</command>来包围它。一组被<command>BEGIN</command>和<command>COMMIT</command>包围的语句也被称为一个<firstterm>事务块</firstterm>。
   </para>
<!-- pgdoc-cn_end sig_en=cc13b8e83e74e59f2dac0aaf46aa617a -->

   <note>
<!-- pgdoc-cn_start sig_en=40a59b5b5ec277e939f21b9a54c2546f sig_cn_org=None source=14.1 
    <para>
     Some client libraries issue <command>BEGIN</command> and <command>COMMIT</command>
     commands automatically, so that you might get the effect of transaction
     blocks without asking.  Check the documentation for the interface
     you are using.
    </para>
________________________________________________________-->
    <para>
     某些客户端库会自动发出<command>BEGIN</command>和<command>COMMIT</command>命令，因此我们可能会在不被告知的情况下得到事务块的效果。具体请查看所使用的接口文档。
    </para>
<!-- pgdoc-cn_end sig_en=40a59b5b5ec277e939f21b9a54c2546f -->
   </note>

<!-- pgdoc-cn_start sig_en=0e1a60a262c37c3a3411ab750158b679 sig_cn_org=None source=14.1 
   <para>
    It's possible to control the statements in a transaction in a more
    granular fashion through the use of <firstterm>savepoints</firstterm>.  Savepoints
    allow you to selectively discard parts of the transaction, while
    committing the rest.  After defining a savepoint with
    <command>SAVEPOINT</command>, you can if needed roll back to the savepoint
    with <command>ROLLBACK TO</command>.  All the transaction's database changes
    between defining the savepoint and rolling back to it are discarded, but
    changes earlier than the savepoint are kept.
   </para>
________________________________________________________-->
   <para>
    也可以利用<firstterm>保存点</firstterm>来以更细的粒度来控制一个事务中的语句。保存点允许我们有选择性地放弃事务的一部分而提交剩下的部分。在使用<command>SAVEPOINT</command>定义一个保存点后，我们可以在必要时利用<command>ROLLBACK TO</command>回滚到该保存点。该事务中位于保存点和回滚点之间的数据库修改都会被放弃，但是早于该保存点的修改则会被保存。
   </para>
<!-- pgdoc-cn_end sig_en=0e1a60a262c37c3a3411ab750158b679 -->

<!-- pgdoc-cn_start sig_en=5aa03ef7c32c443c491c9829c697003f sig_cn_org=None source=14.1 
   <para>
    After rolling back to a savepoint, it continues to be defined, so you can
    roll back to it several times.  Conversely, if you are sure you won't need
    to roll back to a particular savepoint again, it can be released, so the
    system can free some resources.  Keep in mind that either releasing or
    rolling back to a savepoint
    will automatically release all savepoints that were defined after it.
   </para>
________________________________________________________-->
   <para>
    在回滚到保存点之后，它的定义依然存在，因此我们可以多次回滚到它。反过来，如果确定不再需要回滚到特定的保存点，它可以被释放以便系统释放一些资源。记住不管是释放保存点还是回滚到保存点都会释放定义在该保存点之后的所有其他保存点。
   </para>
<!-- pgdoc-cn_end sig_en=5aa03ef7c32c443c491c9829c697003f -->

<!-- pgdoc-cn_start sig_en=e660451299cf0b05548c82cfd40fa930 sig_cn_org=None source=14.1 
   <para>
    All this is happening within the transaction block, so none of it
    is visible to other database sessions.  When and if you commit the
    transaction block, the committed actions become visible as a unit
    to other sessions, while the rolled-back actions never become visible
    at all.
   </para>
________________________________________________________-->
   <para>
    所有这些都发生在一个事务块内，因此这些对于其他数据库会话都不可见。当提交整个事务块时，被提交的动作将作为一个单元变得对其他会话可见，而被回滚的动作则永远不会变得可见。
   </para>
<!-- pgdoc-cn_end sig_en=e660451299cf0b05548c82cfd40fa930 -->

<!-- pgdoc-cn_start sig_en=382859acaa96cab0ed0e14f905f3af77 sig_cn_org=None source=14.1 
   <para>
    Remembering the bank database, suppose we debit $100.00 from Alice's
    account, and credit Bob's account, only to find later that we should
    have credited Wally's account.  We could do it using savepoints like
    this:

<programlisting>
BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
SAVEPOINT my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Bob';
-&minus; oops ... forget that and use Wally's account
ROLLBACK TO my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Wally';
COMMIT;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    记住那个银行数据库，假设我们从Alice的账户扣款100美元，然后存款到Bob的账户，结果直到最后才发现我们应该存到Wally的账户。我们可以通过使用保存点来做这件事：

<programlisting>
BEGIN;
UPDATE accounts SET balance = balance - 100.00
    WHERE name = 'Alice';
SAVEPOINT my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Bob';
-- oops ... forget that and use Wally's account
ROLLBACK TO my_savepoint;
UPDATE accounts SET balance = balance + 100.00
    WHERE name = 'Wally';
COMMIT;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=382859acaa96cab0ed0e14f905f3af77 -->

<!-- pgdoc-cn_start sig_en=651ac72b7dd7192b597e09fbc19d1204 sig_cn_org=None source=14.1 
   <para>
    This example is, of course, oversimplified, but there's a lot of control
    possible in a transaction block through the use of savepoints.
    Moreover, <command>ROLLBACK TO</command> is the only way to regain control of a
    transaction block that was put in aborted state by the
    system due to an error, short of rolling it back completely and starting
    again.
   </para>
________________________________________________________-->
   <para>
    当然，这个例子是被过度简化的，但是在一个事务块中使用保存点存在很多种控制可能性。此外，<command>ROLLBACK TO</command>是唯一的途径来重新控制一个由于错误被系统置为中断状态的事务块，而不是完全回滚它并重新启动。
   </para>
<!-- pgdoc-cn_end sig_en=651ac72b7dd7192b597e09fbc19d1204 -->

  </sect1>


  <sect1 id="tutorial-window">
<!-- pgdoc-cn_start sig_en=76ea9c961a8f82e30eea3e8fd99e47b4 sig_cn_org=None source=14.1 
   <title>Window Functions</title>
________________________________________________________-->
   <title>窗口函数</title>
<!-- pgdoc-cn_end sig_en=76ea9c961a8f82e30eea3e8fd99e47b4 -->

<!-- pgdoc-cn_start sig_en=cf9cb9ba797a27c15b773bb7c632ca98 sig_cn_org=None source=14.1 
   <indexterm zone="tutorial-window">
    <primary>window function</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="tutorial-window">
    <primary>window function</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=cf9cb9ba797a27c15b773bb7c632ca98 -->

<!-- pgdoc-cn_start sig_en=e9598ed93449c935013cd4c48d53f604 sig_cn_org=None source=14.1 
   <para>
    A <firstterm>window function</firstterm> performs a calculation across a set of
    table rows that are somehow related to the current row.  This is comparable
    to the type of calculation that can be done with an aggregate function.
    However, window functions do not cause rows to become grouped into a single
    output row like non-window aggregate calls would.  Instead, the
    rows retain their separate identities.  Behind the scenes, the window
    function is able to access more than just the current row of the query
    result.
   </para>
________________________________________________________-->
   <para>
    一个<firstterm>窗口函数</firstterm>在一系列与当前行有某种关联的表行上执行一种计算。这与一个聚集函数所完成的计算有可比之处。但是窗口函数并不会使多行被聚集成一个单独的输出行，这与通常的非窗口聚集函数不同。取而代之，行保留它们独立的标识。在这些现象背后，窗口函数可以访问的不仅仅是查询结果的当前行。
   </para>
<!-- pgdoc-cn_end sig_en=e9598ed93449c935013cd4c48d53f604 -->

<!-- pgdoc-cn_start sig_en=f2a4f818191e3daff78b2649c95496f0 sig_cn_org=750a37040ca0f8b0ccfab532f0d69686 source=15.7 
   <para>
    Here is an example that shows how to compare each employee's salary
    with the average salary in his or her department:

<programlisting>
SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary;
</programlisting>

<screen>
  depname  | empno | salary |          avg
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 develop   |    11 |   5200 | 5020.0000000000000000
 develop   |     7 |   4200 | 5020.0000000000000000
 develop   |     9 |   4500 | 5020.0000000000000000
 develop   |     8 |   6000 | 5020.0000000000000000
 develop   |    10 |   5200 | 5020.0000000000000000
 personnel |     5 |   3500 | 3700.0000000000000000
 personnel |     2 |   3900 | 3700.0000000000000000
 sales     |     3 |   4800 | 4866.6666666666666667
 sales     |     1 |   5000 | 4866.6666666666666667
 sales     |     4 |   4800 | 4866.6666666666666667
(10 rows)
</screen>

    The first three output columns come directly from the table
    <structname>empsalary</structname>, and there is one output row for each row in the
    table.  The fourth column represents an average taken across all the table
    rows that have the same <structfield>depname</structfield> value as the current row.
    (This actually is the same function as the non-window <function>avg</function>
    aggregate, but the <literal>OVER</literal> clause causes it to be
    treated as a window function and computed across the window frame.)
   </para>
________________________________________________________-->
   <para>
    这是一个示例，展示了如何比较每位员工的工资与其所在部门的平均工资：

<programlisting>
SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary;
</programlisting>

<screen>
  depname  | empno | salary |          avg
-----------+-------+--------+-----------------------
 develop   |    11 |   5200 | 5020.0000000000000000
 develop   |     7 |   4200 | 5020.0000000000000000
 develop   |     9 |   4500 | 5020.0000000000000000
 develop   |     8 |   6000 | 5020.0000000000000000
 develop   |    10 |   5200 | 5020.0000000000000000
 personnel |     5 |   3500 | 3700.0000000000000000
 personnel |     2 |   3900 | 3700.0000000000000000
 sales     |     3 |   4800 | 4866.6666666666666667
 sales     |     1 |   5000 | 4866.6666666666666667
 sales     |     4 |   4800 | 4866.6666666666666667
(10 rows)
</screen>

    前三列的输出直接来自表<structname>empsalary</structname>，每行都有一个输出行。
    第四列表示对具有与当前行相同<structfield>depname</structfield>值的所有表行进行的平均值。
    （实际上，这与非窗口<function>avg</function>聚合函数相同，但<literal>OVER</literal>子句使其被视为窗口函数并计算在窗口帧上。）
</para>
<!-- pgdoc-cn_end sig_en=f2a4f818191e3daff78b2649c95496f0 -->

<!-- pgdoc-cn_start sig_en=d245f364f87def567187afe8d30b0c25 sig_cn_org=None source=14.1 
   <para>
    A window function call always contains an <literal>OVER</literal> clause
    directly following the window function's name and argument(s).  This is what
    syntactically distinguishes it from a normal function or non-window
    aggregate.  The <literal>OVER</literal> clause determines exactly how the
    rows of the query are split up for processing by the window function.
    The <literal>PARTITION BY</literal> clause within <literal>OVER</literal>
    divides the rows into groups, or partitions, that share the same
    values of the <literal>PARTITION BY</literal> expression(s).  For each row,
    the window function is computed across the rows that fall into the
    same partition as the current row.
   </para>
________________________________________________________-->
   <para>
    一个窗口函数调用总是包含一个直接跟在窗口函数名及其参数之后的<literal>OVER</literal>子句。这使得它从句法上和一个普通函数或非窗口函数区分开来。<literal>OVER</literal>子句决定究竟查询中的哪些行被分离出来由窗口函数处理。<literal>OVER</literal>子句中的<literal>PARTITION BY</literal>子句指定了将具有相同<literal>PARTITION BY</literal>表达式值的行分到组或者分区。对于每一行，窗口函数都会在当前行同一分区的行上进行计算。
   </para>
<!-- pgdoc-cn_end sig_en=d245f364f87def567187afe8d30b0c25 -->

<!-- pgdoc-cn_start sig_en=e11cda428afbb726a458732385b9ded3 sig_cn_org=64c9a47bef4c66a76ba0821ed8d4db90 source=15.7 
   <para>
    You can also control the order in which rows are processed by
    window functions using <literal>ORDER BY</literal> within <literal>OVER</literal>.
    (The window <literal>ORDER BY</literal> does not even have to match the
    order in which the rows are output.)  Here is an example:

<programlisting>
SELECT depname, empno, salary,
       rank() OVER (PARTITION BY depname ORDER BY salary DESC)
FROM empsalary;
</programlisting>

<screen>
  depname  | empno | salary | rank
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;
 develop   |     8 |   6000 |    1
 develop   |    10 |   5200 |    2
 develop   |    11 |   5200 |    2
 develop   |     9 |   4500 |    4
 develop   |     7 |   4200 |    5
 personnel |     2 |   3900 |    1
 personnel |     5 |   3500 |    2
 sales     |     1 |   5000 |    1
 sales     |     4 |   4800 |    2
 sales     |     3 |   4800 |    2
(10 rows)
</screen>

    As shown here, the <function>rank</function> function produces a numerical rank
    for each distinct <literal>ORDER BY</literal> value in the current row's
    partition, using the order defined by the <literal>ORDER BY</literal> clause.
    <function>rank</function> needs no explicit parameter, because its behavior
    is entirely determined by the <literal>OVER</literal> clause.
   </para>
________________________________________________________-->
   <para>
    您还可以通过在<literal>OVER</literal>中使用<literal>ORDER BY</literal>来控制窗口函数处理行的顺序。
    （窗口<literal>ORDER BY</literal>甚至不必与输出行的顺序匹配。）以下是一个示例：

<programlisting>
SELECT depname, empno, salary,
       rank() OVER (PARTITION BY depname ORDER BY salary DESC)
FROM empsalary;
</programlisting>

<screen>
  depname  | empno | salary | rank
-----------+-------+--------+------
 develop   |     8 |   6000 |    1
 develop   |    10 |   5200 |    2
 develop   |    11 |   5200 |    2
 develop   |     9 |   4500 |    4
 develop   |     7 |   4200 |    5
 personnel |     2 |   3900 |    1
 personnel |     5 |   3500 |    2
 sales     |     1 |   5000 |    1
 sales     |     4 |   4800 |    2
 sales     |     3 |   4800 |    2
(10 rows)
</screen>

    如此所示，<function>rank</function>函数为当前行的分区中每个不同的<literal>ORDER BY</literal>值产生一个数字排名，
    使用<literal>ORDER BY</literal>子句定义的顺序。<function>rank</function>不需要显式参数，因为其行为完全由<literal>OVER</literal>子句确定。
</para>
<!-- pgdoc-cn_end sig_en=e11cda428afbb726a458732385b9ded3 -->

<!-- pgdoc-cn_start sig_en=081ff30fdf55677871a41162214f6dc9 sig_cn_org=None source=14.1 
   <para>
    The rows considered by a window function are those of the <quote>virtual
    table</quote> produced by the query's <literal>FROM</literal> clause as filtered by its
    <literal>WHERE</literal>, <literal>GROUP BY</literal>, and <literal>HAVING</literal> clauses
    if any.  For example, a row removed because it does not meet the
    <literal>WHERE</literal> condition is not seen by any window function.
    A query can contain multiple window functions that slice up the data
    in different ways using different <literal>OVER</literal> clauses, but
    they all act on the same collection of rows defined by this virtual table.
   </para>
________________________________________________________-->
   <para>
    一个窗口函数所考虑的行属于那些通过查询的<literal>FROM</literal>子句产生并通过<literal>WHERE</literal>、<literal>GROUP BY</literal>、<literal>HAVING</literal>过滤的<quote>虚拟表</quote>。例如，一个由于不满足<literal>WHERE</literal>条件被删除的行是不会被任何窗口函数所见的。在一个查询中可以包含多个窗口函数，每个窗口函数都可以用不同的<literal>OVER</literal>子句来按不同方式划分数据，但是它们都作用在由虚拟表定义的同一个行集上。
   </para>
<!-- pgdoc-cn_end sig_en=081ff30fdf55677871a41162214f6dc9 -->

<!-- pgdoc-cn_start sig_en=43632b417fa5bc55e3dde19bab7cf2bb sig_cn_org=None source=14.1 
   <para>
    We already saw that <literal>ORDER BY</literal> can be omitted if the ordering
    of rows is not important.  It is also possible to omit <literal>PARTITION
    BY</literal>, in which case there is a single partition containing all rows.
   </para>
________________________________________________________-->
   <para>
    我们已经看到如果行的顺序不重要时<literal>ORDER BY</literal>可以忽略。<literal>PARTITION BY</literal>同样也可以被忽略，在这种情况下会产生一个包含所有行的分区。
   </para>
<!-- pgdoc-cn_end sig_en=43632b417fa5bc55e3dde19bab7cf2bb -->

<!-- pgdoc-cn_start sig_en=ba90affce7c9bb6141520362625f9fce sig_cn_org=None source=14.1 
   <para>
    There is another important concept associated with window functions:
    for each row, there is a set of rows within its partition called its
    <firstterm>window frame</firstterm>.  Some window functions act only
    on the rows of the window frame, rather than of the whole partition.
    By default, if <literal>ORDER BY</literal> is supplied then the frame consists of
    all rows from the start of the partition up through the current row, plus
    any following rows that are equal to the current row according to the
    <literal>ORDER BY</literal> clause.  When <literal>ORDER BY</literal> is omitted the
    default frame consists of all rows in the partition.
     <footnote>
      <para>
       There are options to define the window frame in other ways, but
       this tutorial does not cover them.  See
       <xref linkend="syntax-window-functions"/> for details.
      </para>
     </footnote>
    Here is an example using <function>sum</function>:
   </para>
________________________________________________________-->
   <para>
    这里有一个与窗口函数相关的重要概念：对于每一行，在它的分区中的行集被称为它的窗口帧。 一些窗口函数只作用在<firstterm>窗口帧</firstterm>中的行上，而不是整个分区。默认情况下，如果使用<literal>ORDER BY</literal>，则帧包括从分区开始到当前行的所有行，以及后续任何与当前行在<literal>ORDER BY</literal>子句上相等的行。如果<literal>ORDER BY</literal>被忽略，则默认帧包含整个分区中所有的行。
     <footnote>
      <para>
       还有些选项用于以其他方式定义窗口帧，但是这不包括在本教程内。详见<xref linkend="syntax-window-functions"/>。
      </para>
     </footnote>
    下面是使用<function>sum</function>的例子：
   </para>
<!-- pgdoc-cn_end sig_en=ba90affce7c9bb6141520362625f9fce -->

<!-- pgdoc-cn_start sig_en=cabdec3c24aac143588cb97c2dc43029 sig_cn_org=None source=14.1 
<programlisting>
SELECT salary, sum(salary) OVER () FROM empsalary;
</programlisting>
________________________________________________________-->
<programlisting>
SELECT salary, sum(salary) OVER () FROM empsalary;
</programlisting>
<!-- pgdoc-cn_end sig_en=cabdec3c24aac143588cb97c2dc43029 -->

<!-- pgdoc-cn_start sig_en=7d69d86aed19838af3477eb62d6268c6 sig_cn_org=0107c23a45d5653c921d9e4e337db75b source=15.7 
<screen>
 salary |  sum
-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
   5200 | 47100
   5000 | 47100
   3500 | 47100
   4800 | 47100
   3900 | 47100
   4200 | 47100
   4500 | 47100
   4800 | 47100
   6000 | 47100
   5200 | 47100
(10 rows)
</screen>
________________________________________________________-->
<screen>
 salary |  sum
--------+-------
   5200 | 47100
   5000 | 47100
   3500 | 47100
   4800 | 47100
   3900 | 47100
   4200 | 47100
   4500 | 47100
   4800 | 47100
   6000 | 47100
   5200 | 47100
(10 rows)
</screen>
<!-- pgdoc-cn_end sig_en=7d69d86aed19838af3477eb62d6268c6 -->

<!-- pgdoc-cn_start sig_en=8a24bbafd7d42d57a88859eed16bcc3b sig_cn_org=None source=14.1 
   <para>
    Above, since there is no <literal>ORDER BY</literal> in the <literal>OVER</literal>
    clause, the window frame is the same as the partition, which for lack of
    <literal>PARTITION BY</literal> is the whole table; in other words each sum is
    taken over the whole table and so we get the same result for each output
    row.  But if we add an <literal>ORDER BY</literal> clause, we get very different
    results:
   </para>
________________________________________________________-->
   <para>
    如上所示，由于在<literal>OVER</literal>子句中没有<literal>ORDER BY</literal>，窗口帧和分区一样，而如果缺少<literal>PARTITION BY</literal>则和整个表一样。换句话说，每个合计都会在整个表上进行，这样我们为每一个输出行得到的都是相同的结果。但是如果我们加上一个<literal>ORDER BY</literal>子句，我们会得到非常不同的结果：
   </para>
<!-- pgdoc-cn_end sig_en=8a24bbafd7d42d57a88859eed16bcc3b -->

<!-- pgdoc-cn_start sig_en=175b6e802e8cf4422d2dad951f890d5c sig_cn_org=None source=14.1 
<programlisting>
SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary;
</programlisting>
________________________________________________________-->
<programlisting>
SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary;
</programlisting>
<!-- pgdoc-cn_end sig_en=175b6e802e8cf4422d2dad951f890d5c -->

<!-- pgdoc-cn_start sig_en=b442190722aef4e54a74082045fc03f6 sig_cn_org=60ecdf4757499f3be20f5dd598063971 source=15.7 
<screen>
 salary |  sum
-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
   3500 |  3500
   3900 |  7400
   4200 | 11600
   4500 | 16100
   4800 | 25700
   4800 | 25700
   5000 | 30700
   5200 | 41100
   5200 | 41100
   6000 | 47100
(10 rows)
</screen>
________________________________________________________-->
<screen>
 salary |  sum
--------+-------
   3500 |  3500
   3900 |  7400
   4200 | 11600
   4500 | 16100
   4800 | 25700
   4800 | 25700
   5000 | 30700
   5200 | 41100
   5200 | 41100
   6000 | 47100
(10 rows)
</screen>
<!-- pgdoc-cn_end sig_en=b442190722aef4e54a74082045fc03f6 -->

<!-- pgdoc-cn_start sig_en=778f765b9acaab669bac4c22a20b42da sig_cn_org=None source=14.1 
   <para>
    Here the sum is taken from the first (lowest) salary up through the
    current one, including any duplicates of the current one (notice the
    results for the duplicated salaries).
   </para>
________________________________________________________-->
   <para>
    这里的合计是从第一个（最低的）薪水一直到当前行，包括任何与当前行相同的行（注意相同薪水行的结果）。
   </para>
<!-- pgdoc-cn_end sig_en=778f765b9acaab669bac4c22a20b42da -->

<!-- pgdoc-cn_start sig_en=ce1cb9ab0390c49620137723308a6b23 sig_cn_org=None source=14.1 
   <para>
    Window functions are permitted only in the <literal>SELECT</literal> list
    and the <literal>ORDER BY</literal> clause of the query. They are forbidden
    elsewhere, such as in <literal>GROUP BY</literal>, <literal>HAVING</literal>
    and <literal>WHERE</literal> clauses.  This is because they logically
    execute after the processing of those clauses.  Also, window functions
    execute after non-window aggregate functions.  This means it is valid to
    include an aggregate function call in the arguments of a window function,
    but not vice versa.
   </para>
________________________________________________________-->
   <para>
    窗口函数只允许出现在查询的<literal>SELECT</literal>列表和<literal>ORDER BY</literal>子句中。它们不允许出现在其他地方，例如<literal>GROUP BY</literal>、<literal>HAVING</literal>和<literal>WHERE</literal>子句中。这是因为窗口函数的执行逻辑是在处理完这些子句之后。另外，窗口函数在非窗口聚集函数之后执行。这意味着可以在窗口函数的参数中包括一个聚集函数，但反过来不行。
   </para>
<!-- pgdoc-cn_end sig_en=ce1cb9ab0390c49620137723308a6b23 -->

<!-- pgdoc-cn_start sig_en=5c296eb71993fda144ddab5e843918e5 sig_cn_org=None source=14.1 
   <para>
    If there is a need to filter or group rows after the window calculations
    are performed, you can use a sub-select.  For example:

<programlisting>
SELECT depname, empno, salary, enroll_date
FROM
  (SELECT depname, empno, salary, enroll_date,
          rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos
     FROM empsalary
  ) AS ss
WHERE pos &lt; 3;
</programlisting>

    The above query only shows the rows from the inner query having
    <literal>rank</literal> less than 3.
   </para>
________________________________________________________-->
   <para>
    如果需要在窗口计算执行后进行过滤或者分组，我们可以使用子查询。例如：

<programlisting>
SELECT depname, empno, salary, enroll_date
FROM
  (SELECT depname, empno, salary, enroll_date,
          rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos
     FROM empsalary
  ) AS ss
WHERE pos &lt; 3;
</programlisting>

    上述查询仅仅显示了内层查询中<literal>rank</literal>低于3的结果。
   </para>
<!-- pgdoc-cn_end sig_en=5c296eb71993fda144ddab5e843918e5 -->

<!-- pgdoc-cn_start sig_en=928524dbdb23046966df44b09d80e041 sig_cn_org=None source=14.1 
   <para>
    When a query involves multiple window functions, it is possible to write
    out each one with a separate <literal>OVER</literal> clause, but this is
    duplicative and error-prone if the same windowing behavior is wanted
    for several functions.  Instead, each windowing behavior can be named
    in a <literal>WINDOW</literal> clause and then referenced in <literal>OVER</literal>.
    For example:

<programlisting>
SELECT sum(salary) OVER w, avg(salary) OVER w
  FROM empsalary
  WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);
</programlisting>
   </para>
________________________________________________________-->
   <para>
    当一个查询涉及到多个窗口函数时，可以将每一个分别写在一个独立的<literal>OVER</literal>子句中。但如果多个函数要求同一个窗口行为时，这种做法是冗余的而且容易出错的。替代方案是，每一个窗口行为可以被放在一个命名的<literal>WINDOW</literal>子句中，然后在<literal>OVER</literal>中引用它。例如：

<programlisting>
SELECT sum(salary) OVER w, avg(salary) OVER w
  FROM empsalary
  WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=928524dbdb23046966df44b09d80e041 -->

<!-- pgdoc-cn_start sig_en=f7cfab166995b0d96bf00818a1b37ffa sig_cn_org=None source=14.1 
   <para>
    More details about window functions can be found in
    <xref linkend="syntax-window-functions"/>,
    <xref linkend="functions-window"/>,
    <xref linkend="queries-window"/>, and the
    <xref linkend="sql-select"/> reference page.
   </para>
________________________________________________________-->
   <para>
    关于窗口函数的更多细节可以在<xref linkend="syntax-window-functions"/>、<xref linkend="functions-window"/>、<xref linkend="queries-window"/>以及<xref linkend="sql-select"/>参考页中找到。
   </para>
<!-- pgdoc-cn_end sig_en=f7cfab166995b0d96bf00818a1b37ffa -->
  </sect1>


  <sect1 id="tutorial-inheritance">
<!-- pgdoc-cn_start sig_en=402ce8e5e5c53d3b32e1e9b0026d33d1 sig_cn_org=None source=14.1 
   <title>Inheritance</title>
________________________________________________________-->
   <title>继承</title>
<!-- pgdoc-cn_end sig_en=402ce8e5e5c53d3b32e1e9b0026d33d1 -->

<!-- pgdoc-cn_start sig_en=4072d51584246a29989996318bc21a6f sig_cn_org=None source=14.1 
   <indexterm zone="tutorial-inheritance">
    <primary>inheritance</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="tutorial-inheritance">
    <primary>inheritance</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=4072d51584246a29989996318bc21a6f -->

<!-- pgdoc-cn_start sig_en=dee629a49b7dad4471882f29d2d9ab8b sig_cn_org=None source=14.1 
   <para>
    Inheritance is a concept from object-oriented databases.  It opens
    up interesting new possibilities of database design.
   </para>
________________________________________________________-->
   <para>
    继承是面向对象数据库中的概念。它展示了数据库设计的新的可能性。
   </para>
<!-- pgdoc-cn_end sig_en=dee629a49b7dad4471882f29d2d9ab8b -->

<!-- pgdoc-cn_start sig_en=fe9118ca44670f71fd053fb50d1e34e0 sig_cn_org=None source=14.1 
   <para>
    Let's create two tables:  A table <classname>cities</classname>
    and a table <classname>capitals</classname>.  Naturally, capitals
    are also cities, so you want some way to show the capitals
    implicitly when you list all cities.  If you're really clever you
    might invent some scheme like this:

<programlisting>
CREATE TABLE capitals (
  name       text,
  population real,
  elevation  int,    -&minus; (in ft)
  state      char(2)
);

CREATE TABLE non_capitals (
  name       text,
  population real,
  elevation  int     -&minus; (in ft)
);

CREATE VIEW cities AS
  SELECT name, population, elevation FROM capitals
    UNION
  SELECT name, population, elevation FROM non_capitals;
</programlisting>

    This works OK as far as querying goes, but it gets ugly when you
    need to update several rows, for one thing.
   </para>
________________________________________________________-->
   <para>
    让我们创建两个表：表<classname>cities</classname>和表<classname>capitals</classname>。自然地，首都也是城市，所以我们需要有某种方式能够在列举所有城市的时候也隐式地包含首都。如果真的聪明，我们会设计如下的模式：

<programlisting>
CREATE TABLE capitals (
  name       text,
  population real,
  elevation  int,    -- (in ft)
  state      char(2)
);

CREATE TABLE non_capitals (
  name       text,
  population real,
  elevation  int     -- (in ft)
);

CREATE VIEW cities AS
  SELECT name, population, elevation FROM capitals
    UNION
  SELECT name, population, elevation FROM non_capitals;
</programlisting>

    这个模式对于查询而言工作正常，但是当我们需要更新一些行时它就变得不好用了。
   </para>
<!-- pgdoc-cn_end sig_en=fe9118ca44670f71fd053fb50d1e34e0 -->

<!-- pgdoc-cn_start sig_en=b196a5b9d456141bc695710d70274fe9 sig_cn_org=None source=14.1 
   <para>
    A better solution is this:

<programlisting>
CREATE TABLE cities (
  name       text,
  population real,
  elevation  int     -&minus; (in ft)
);

CREATE TABLE capitals (
  state      char(2) UNIQUE NOT NULL
) INHERITS (cities);
</programlisting>
   </para>
________________________________________________________-->
   <para>
    更好的方案是：

<programlisting>
CREATE TABLE cities (
  name       text,
  population real,
  elevation  int     -- (in ft)
);

CREATE TABLE capitals (
  state      char(2) UNIQUE NOT NULL
) INHERITS (cities);
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=b196a5b9d456141bc695710d70274fe9 -->

<!-- pgdoc-cn_start sig_en=fa1248d0251bc159083295982911c8fb sig_cn_org=None source=14.1 
   <para>
    In this case, a row of <classname>capitals</classname>
    <firstterm>inherits</firstterm> all columns (<structfield>name</structfield>,
    <structfield>population</structfield>, and <structfield>elevation</structfield>) from its
    <firstterm>parent</firstterm>, <classname>cities</classname>.  The
    type of the column <structfield>name</structfield> is
    <type>text</type>, a native <productname>PostgreSQL</productname>
    type for variable length character strings.  The
    <classname>capitals</classname> table has
    an additional column, <structfield>state</structfield>, which shows its
    state abbreviation.  In
    <productname>PostgreSQL</productname>, a table can inherit from
    zero or more other tables.
   </para>
________________________________________________________-->
   <para>
    在这种情况下，一个<classname>capitals</classname>的行从它的<firstterm>父亲</firstterm><classname>cities</classname><firstterm>继承</firstterm>了所有列（<structfield>name</structfield>、<structfield>population</structfield>和<structfield>elevation</structfield>）。
    列<structfield>name</structfield>的类型是<type>text</type>，一种用于变长字符串的本地<productname>PostgreSQL</productname>类型。
    <classname>capitals</classname>表有一个附加列，<structfield>state</structfield>，用于显示他们的州缩写。
    在<productname>PostgreSQL</productname>中，一个表可以从0个或者多个表继承。
   </para>
<!-- pgdoc-cn_end sig_en=fa1248d0251bc159083295982911c8fb -->

<!-- pgdoc-cn_start sig_en=ec3f698eb1b8223ea7ac31574aa0d228 sig_cn_org=None source=14.1 
   <para>
    For example, the  following  query finds the  names  of  all  cities,
    including  state capitals, that are located at an elevation
    over 500 feet:

<programlisting>
SELECT name, elevation
  FROM cities
  WHERE elevation &gt; 500;
</programlisting>

    which returns:

<screen>
   name    | elevation
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-
 Las Vegas |      2174
 Mariposa  |      1953
 Madison   |       845
(3 rows)
</screen>
   </para>
________________________________________________________-->
   <para>
    例如，如下查询可以寻找所有海拔500尺以上的城市名称，包括州首都：

<programlisting>
SELECT name, elevation
  FROM cities
  WHERE elevation &gt; 500;
</programlisting>

    返回为:

<screen>
   name    | elevation
-----------+-----------
 Las Vegas |      2174
 Mariposa  |      1953
 Madison   |       845
(3 rows)
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=ec3f698eb1b8223ea7ac31574aa0d228 -->

<!-- pgdoc-cn_start sig_en=187ebd1bde3954db592ed7f8dfa432ea sig_cn_org=None source=14.1 
   <para>
    On the other hand, the  following  query  finds
    all  the cities that are not state capitals and
    are situated at an elevation over 500 feet:

<programlisting>
SELECT name, elevation
    FROM ONLY cities
    WHERE elevation &gt; 500;
</programlisting>

<screen>
   name    | elevation
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-
 Las Vegas |      2174
 Mariposa  |      1953
(2 rows)
</screen>
   </para>
________________________________________________________-->
   <para>
    在另一方面，下面的查询可以查找所有海拔高于500尺且不是州首府的城市：

<programlisting>
SELECT name, elevation
    FROM ONLY cities
    WHERE elevation &gt; 500;
</programlisting>

<screen>
   name    | elevation
-----------+-----------
 Las Vegas |      2174
 Mariposa  |      1953
(2 rows)
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=187ebd1bde3954db592ed7f8dfa432ea -->

<!-- pgdoc-cn_start sig_en=8a8cc58eff15a3e8cc644a71591e4676 sig_cn_org=None source=14.1 
   <para>
    Here the <literal>ONLY</literal> before <literal>cities</literal>
    indicates that the query should be run over only the
    <classname>cities</classname> table, and not tables below
    <classname>cities</classname> in the inheritance hierarchy.  Many
    of the commands that we have already discussed &mdash;
    <command>SELECT</command>, <command>UPDATE</command>, and
    <command>DELETE</command> &mdash; support this <literal>ONLY</literal>
    notation.
   </para>
________________________________________________________-->
   <para>
    其中<classname>cities</classname>之前的<literal>ONLY</literal>用于指示查询只在<classname>cities</classname>表上进行而不会涉及到继承层次中位于<classname>cities</classname>之下的其他表。很多我们已经讨论过的命令 &mdash; <command>SELECT</command>、<command>UPDATE</command> 和<command>DELETE</command> &mdash; 都支持这个<literal>ONLY</literal>记号。
   </para>
<!-- pgdoc-cn_end sig_en=8a8cc58eff15a3e8cc644a71591e4676 -->

   <note>
<!-- pgdoc-cn_start sig_en=041c3272006e3975f03008b3f4ff90dc sig_cn_org=None source=14.1 
    <para>
     Although inheritance is frequently useful, it has not been integrated
     with unique constraints or foreign keys, which limits its usefulness.
     See <xref linkend="ddl-inherit"/> for more detail.
    </para>
________________________________________________________-->
    <para>
     尽管继承很有用，但是它还未与唯一约束或外键集成，这也限制了它的可用性。更多详情见<xref linkend="ddl-inherit"/>。
    </para>
<!-- pgdoc-cn_end sig_en=041c3272006e3975f03008b3f4ff90dc -->
   </note>
  </sect1>


  <sect1 id="tutorial-conclusion">
<!-- pgdoc-cn_start sig_en=ee20820e37844ecacfc8e6c322012448 sig_cn_org=None source=14.1 
   <title>Conclusion</title>
________________________________________________________-->
   <title>小结</title>
<!-- pgdoc-cn_end sig_en=ee20820e37844ecacfc8e6c322012448 -->

<!-- pgdoc-cn_start sig_en=197e38a22b4f5192b06586da582639c9 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> has many features not
    touched upon in this tutorial introduction, which has been
    oriented toward newer users of <acronym>SQL</acronym>.  These
    features are discussed in more detail in the remainder of this
    book.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>中有很多特性在这个面向<acronym>SQL</acronym>新用户的教程中并未触及。有关这些特性的更多详情将在本书的后续部分进行讨论。
   </para>
<!-- pgdoc-cn_end sig_en=197e38a22b4f5192b06586da582639c9 -->

<!-- pgdoc-cn_start sig_en=aa986938db0ca0493a8bb77225fb0add sig_cn_org=None source=14.1 
   <para>
    If you feel you need more introductory material, please visit the PostgreSQL
    <ulink url="https://www.postgresql.org">web site</ulink>
    for links to more resources.
   </para>
________________________________________________________-->
   <para>
    如果需要更多介绍材料，请访问 PostgreSQL <ulink url="https://www.postgresql.org">官方网站</ulink>来获得更多资源链接。
   </para>
<!-- pgdoc-cn_end sig_en=aa986938db0ca0493a8bb77225fb0add -->
  </sect1>
 </chapter>
