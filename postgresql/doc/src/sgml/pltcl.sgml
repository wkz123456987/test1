<!-- doc/src/sgml/pltcl.sgml -->

 <chapter id="pltcl">
<!-- pgdoc-cn_start sig_en=ac456dda676cef8b0c3a6bc3120412ec sig_cn_org=None source=14.1 
  <title>PL/Tcl &mdash; Tcl Procedural Language</title>
________________________________________________________-->
  <title>PL/Tcl &mdash; Tcl 过程语言</title>
<!-- pgdoc-cn_end sig_en=ac456dda676cef8b0c3a6bc3120412ec -->

<!-- pgdoc-cn_start sig_en=5c2f5751bda71c967775d56405ec7c1a sig_cn_org=None source=14.1 
  <indexterm zone="pltcl">
   <primary>PL/Tcl</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="pltcl">
   <primary>PL/Tcl</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=5c2f5751bda71c967775d56405ec7c1a -->

<!-- pgdoc-cn_start sig_en=10b1dd8d9010fcc355bb82a60a12bf58 sig_cn_org=None source=14.1 
  <indexterm zone="pltcl">
   <primary>Tcl</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="pltcl">
   <primary>Tcl</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=10b1dd8d9010fcc355bb82a60a12bf58 -->

<!-- pgdoc-cn_start sig_en=02488cb7877b45a21e6c76316eb2900b sig_cn_org=None source=14.1 
  <para>
   PL/Tcl is a loadable procedural language for the
   <productname>PostgreSQL</productname> database system
   that enables the <ulink url="https://www.tcl.tk/">
   Tcl language</ulink> to be used to write
   <productname>PostgreSQL</productname> functions and procedures.
  </para>
________________________________________________________-->
  <para>
   PL/Tcl 是一种用于<productname>PostgreSQL</productname>数据库系统的可载入过程语言， 它可以让<ulink url="https://www.tcl.tk/">Tcl 语言</ulink>被用来编写<productname>PostgreSQL</productname>函数和存储过程。
  </para>
<!-- pgdoc-cn_end sig_en=02488cb7877b45a21e6c76316eb2900b -->

  <!-- **** PL/Tcl overview **** -->

  <sect1 id="pltcl-overview">
<!-- pgdoc-cn_start sig_en=13508788fd8dee2d1f9c928870e99338 sig_cn_org=None source=14.1 
   <title>Overview</title>
________________________________________________________-->
   <title>概述</title>
<!-- pgdoc-cn_end sig_en=13508788fd8dee2d1f9c928870e99338 -->

<!-- pgdoc-cn_start sig_en=903252001b3b537ee62687451bf8f79f sig_cn_org=None source=14.1 
   <para>
    PL/Tcl offers most of the capabilities a function writer has in
    the C language, with a few restrictions, and with the addition of
    the powerful string processing libraries that are available for
    Tcl.
   </para>
________________________________________________________-->
   <para>
    PL/Tcl 提供了大部分函数编写者在 C 语言中能够获得的能力，虽然有一些限制，但是却额外提供了 Tcl 中强大的字符串处理库。
   </para>
<!-- pgdoc-cn_end sig_en=903252001b3b537ee62687451bf8f79f -->
<!-- pgdoc-cn_start sig_en=bb5113ee144f3d44a3c9b2ba46c1de01 sig_cn_org=None source=14.1 
   <para>
    One compelling <emphasis>good</emphasis> restriction is that
    everything is executed from within the safety of the context of a
    Tcl interpreter.  In addition to the limited command set of safe
    Tcl, only a few commands are available to access the database via
    SPI and to raise messages via <function>elog()</function>.  PL/Tcl
    provides no way to access internals of the database server or to
    gain OS-level access under the permissions of the
    <productname>PostgreSQL</productname> server process, as a C
    function can do.  Thus, unprivileged database users can be trusted
    to use this language; it does not give them unlimited authority.
   </para>
________________________________________________________-->
   <para>
    一种强制性的<emphasis>好</emphasis>限制是所有被执行的东西都处于 Tcl 解释器的安全上下文中。除了安全 Tcl 的有限的命令集合之外，只有几个通过 SPI 访问数据库的命令以及通过<function>elog()</function>产生消息的命令。PL/Tcl 没有提供访问数据库服务器内部或者在<productname>PostgreSQL</productname>服务器进程权限之下得到 OS-级访问的方法，而 C 函数是可以那样做的。因此，非特权数据库用户可以使用这种语言，它不会给予他们无限制的权利。
   </para>
<!-- pgdoc-cn_end sig_en=bb5113ee144f3d44a3c9b2ba46c1de01 -->
<!-- pgdoc-cn_start sig_en=2370e780ef16e62cf5dee5c0d4645394 sig_cn_org=None source=14.1 
   <para>
    The other notable implementation restriction is that Tcl functions
    cannot be used to create input/output functions for new data
    types.
   </para>
________________________________________________________-->
   <para>
    其他值得注意的实现限制是 Tcl 函数不能被用来创建新数据类型的输入/输出函数。
   </para>
<!-- pgdoc-cn_end sig_en=2370e780ef16e62cf5dee5c0d4645394 -->
<!-- pgdoc-cn_start sig_en=0074f241814990986def9607ee75a7d4 sig_cn_org=None source=14.1 
   <para>
    Sometimes it is desirable to write Tcl functions that are not restricted
    to safe Tcl.  For example, one might want a Tcl function that sends
    email.  To handle these cases, there is a variant of <application>PL/Tcl</application> called <literal>PL/TclU</literal>
    (for untrusted Tcl).  This is exactly the same language except that a full
    Tcl interpreter is used.  <emphasis>If <application>PL/TclU</application> is used, it must be
    installed as an untrusted procedural language</emphasis> so that only
    database superusers can create functions in it.  The writer of a <application>PL/TclU</application>
    function must take care that the function cannot be used to do anything
    unwanted, since it will be able to do anything that could be done by
    a user logged in as the database administrator.
   </para>
________________________________________________________-->
   <para>
    有时候我们想要编写不受安全 Tcl 限制的 Tcl 函数。例如，我们可能想要一个能发送电子邮件的 Tcl 函数。要处理这些情况，可以使用一种<application>PL/Tcl</application>的变体，它被称为<literal>PL/TclU</literal>（用于非可信 Tcl）。它其实是完全相同的一种语言，不过它使用了一个完整的 Tcl 解释器。<emphasis>如果使用了<application>PL/TclU</application>，它必须被安装为一种非可信的过程语言</emphasis>，这样只有数据库超级用户可以用它来创建函数。<application>PL/TclU</application>函数的编写者必须注意该函数不能被用来做其设计目的之外的事情，因为该函数能做一个作为数据库管理员登录的用户可以做的任何事情。
   </para>
<!-- pgdoc-cn_end sig_en=0074f241814990986def9607ee75a7d4 -->
<!-- pgdoc-cn_start sig_en=802c84041d2209d3e4d0feb3eadc998c sig_cn_org=None source=14.1 
   <para>
    The shared object code for the <application>PL/Tcl</application> and
    <application>PL/TclU</application> call handlers is automatically built and
    installed in the <productname>PostgreSQL</productname> library
    directory if Tcl support is specified in the configuration step of
    the installation procedure.  To install <application>PL/Tcl</application>
    and/or <application>PL/TclU</application> in a particular database, use the
    <command>CREATE EXTENSION</command> command, for example
    <literal>CREATE EXTENSION pltcl</literal> or
    <literal>CREATE EXTENSION pltclu</literal>.
   </para>
________________________________________________________-->
   <para>
    如果在安装过程的配置步骤中指定了 Tcl 支持，<application>PL/Tcl</application>以及<application>PL/TclU</application>调用处理器的共享对象代码会被自动编译并且被安装在<productname>PostgreSQL</productname>的库目录中。要在一个特定数据库中安装<application>PL/Tcl</application>或者<application>PL/TclU</application>，请使用<command>CREATE EXTENSION</command>命令，例如<literal>CREATE EXTENSION pltcl</literal>或者<literal>CREATE EXTENSION pltclu</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=802c84041d2209d3e4d0feb3eadc998c -->
  </sect1>

  <!-- **** PL/Tcl description **** -->

   <sect1 id="pltcl-functions">
<!-- pgdoc-cn_start sig_en=d353cc0fb5cdce747b680abbf66880a2 sig_cn_org=None source=14.1 
    <title>PL/Tcl Functions and Arguments</title>
________________________________________________________-->
    <title>PL/Tcl 函数和参数</title>
<!-- pgdoc-cn_end sig_en=d353cc0fb5cdce747b680abbf66880a2 -->

<!-- pgdoc-cn_start sig_en=ccc090ad57e6861b9db6a4e766fd9648 sig_cn_org=None source=14.1 
    <para>
     To create a function in the <application>PL/Tcl</application> language, use
     the standard <xref linkend="sql-createfunction"/> syntax:

<programlisting>
CREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-types</replaceable>) RETURNS <replaceable>return-type</replaceable> AS $$
    # PL/Tcl function body
$$ LANGUAGE pltcl;
</programlisting>

     <application>PL/TclU</application> is the same, except that the language has to be specified as
     <literal>pltclu</literal>.
    </para>
________________________________________________________-->
    <para>
     要用<application>PL/Tcl</application>语言创建函数，可使用标准的<xref linkend="sql-createfunction"/>语法：

<programlisting>
CREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-types</replaceable>) RETURNS <replaceable>return-type</replaceable> AS $$
    # PL/Tcl function body
$$ LANGUAGE pltcl;
</programlisting>

     <application>PL/TclU</application>的函数是一样的语法，只是语言被指定为<literal>pltclu</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=ccc090ad57e6861b9db6a4e766fd9648 -->

<!-- pgdoc-cn_start sig_en=312f8d0cb0692fe9d1d75a12db07f117 sig_cn_org=None source=14.1 
    <para>
     The body of the function is simply a piece of Tcl script.
     When the function is called, the argument values are passed to the
     Tcl script as variables named <literal>1</literal>
     ... <literal><replaceable>n</replaceable></literal>.  The result is
     returned from the Tcl code in the usual way, with
     a <literal>return</literal> statement.  In a procedure, the return value
     from the Tcl code is ignored.
    </para>
________________________________________________________-->
    <para>
     函数的主体就是一个 Tcl 脚本。当函数被调用时，参数值会被以变量名<literal>$1</literal> ... <literal>$<replaceable>n</replaceable></literal>传递给该Tcl脚本。结果会以常见的方式通过一个<literal>return</literal>语句从 Tcl 脚本中返回。在一个过程中，Tcl代码的返回值会被忽略。
    </para>
<!-- pgdoc-cn_end sig_en=312f8d0cb0692fe9d1d75a12db07f117 -->

<!-- pgdoc-cn_start sig_en=6dc2153074b2d629f8bdd0ca48066e06 sig_cn_org=None source=14.1 
    <para>
     For example, a function
     returning the greater of two integer values could be defined as:

<programlisting>
CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS $$
    if {$1 &gt; $2} {return $1}
    return $2
$$ LANGUAGE pltcl STRICT;
</programlisting>

     Note the clause <literal>STRICT</literal>, which saves us from
     having to think about null input values: if a null value is passed, the
     function will not be called at all, but will just return a null
     result automatically.
    </para>
________________________________________________________-->
    <para>
     例如，一个返回两个整数值中较大值的函数可以定义为：

<programlisting>
CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS $$
    if {$1 &gt; $2} {return $1}
    return $2
$$ LANGUAGE pltcl STRICT;
</programlisting>

     注意子句<literal>STRICT</literal>，它让我们不用去操心空输入值：如果空值被传入，函数根本就不会被调用，而是自动地返回一个空结果。
    </para>
<!-- pgdoc-cn_end sig_en=6dc2153074b2d629f8bdd0ca48066e06 -->

<!-- pgdoc-cn_start sig_en=66405e30f48c5bc6e51db2240a244b45 sig_cn_org=None source=14.1 
    <para>
     In a nonstrict function,
     if the actual value of an argument is null, the corresponding
     <literal>$<replaceable>n</replaceable></literal> variable will be set to an empty string.
     To detect whether a particular argument is null, use the function
     <literal>argisnull</literal>.  For example, suppose that we wanted <function>tcl_max</function>
     with one null and one nonnull argument to return the nonnull
     argument, rather than null:

<programlisting>
CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS $$
    if {[argisnull 1]} {
        if {[argisnull 2]} { return_null }
        return $2
    }
    if {[argisnull 2]} { return $1 }
    if {$1 &gt; $2} {return $1}
    return $2
$$ LANGUAGE pltcl;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     在非严格函数中，如果一个参数的实际值为空，对应的<literal>$<replaceable>n</replaceable></literal>变量将被设置为一个空串。为了检测一个特定参数是否为空，可使用函数<literal>argisnull</literal>。例如，假设我们想要带有一个空参数和一个非空参数并且返回非空参数的<function>tcl_max</function>：

<programlisting>
CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS $$
    if {[argisnull 1]} {
        if {[argisnull 2]} { return_null }
        return $2
    }
    if {[argisnull 2]} { return $1 }
    if {$1 &gt; $2} {return $1}
    return $2
$$ LANGUAGE pltcl;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=66405e30f48c5bc6e51db2240a244b45 -->

<!-- pgdoc-cn_start sig_en=d0709271b9b875346481f10f8ef0d787 sig_cn_org=None source=14.1 
    <para>
     As shown above,
     to return a null value from a PL/Tcl function, execute
     <literal>return_null</literal>.  This can be done whether the
     function is strict or not.
    </para>
________________________________________________________-->
    <para>
     如上所述，要从一个 PL/Tcl 函数返回空值，可执行<literal>return_null</literal>。不管函数是严格还是非严格都可以这样做。
    </para>
<!-- pgdoc-cn_end sig_en=d0709271b9b875346481f10f8ef0d787 -->

<!-- pgdoc-cn_start sig_en=e5d0fcaa1a9c06950afcdee306d7a0dc sig_cn_org=None source=14.1 
    <para>
     Composite-type arguments are passed to the function as Tcl
     arrays.  The element names of the array are the attribute names
     of the composite type. If an attribute in the passed row has the
     null value, it will not appear in the array. Here is an example:

<programlisting>
CREATE TABLE employee (
    name text,
    salary integer,
    age integer
);

CREATE FUNCTION overpaid(employee) RETURNS boolean AS $$
    if {200000.0 &lt; $1(salary)} {
        return "t"
    }
    if {$1(age) &lt; 30 &amp;&amp; 100000.0 &lt; $1(salary)} {
        return "t"
    }
    return "f"
$$ LANGUAGE pltcl;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     组合类型参数会被作为 Tcl 数组传递给函数。该数组的元素名就是组合类型的属性值。如果被传入行的一个属性为空值，它不会出现在数组中。这里是一个例子：

<programlisting>
CREATE TABLE employee (
    name text,
    salary integer,
    age integer
);

CREATE FUNCTION overpaid(employee) RETURNS boolean AS $$
    if {200000.0 &lt; $1(salary)} {
        return "t"
    }
    if {$1(age) &lt; 30 &amp;&amp; 100000.0 &lt; $1(salary)} {
        return "t"
    }
    return "f"
$$ LANGUAGE pltcl;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=e5d0fcaa1a9c06950afcdee306d7a0dc -->

<!-- pgdoc-cn_start sig_en=5b8ad1ec94f27a00d90c0fc5e9f7f533 sig_cn_org=None source=14.1 
    <para>
     PL/Tcl functions can return composite-type results, too.  To do this,
     the Tcl code must return a list of column name/value pairs matching
     the expected result type.  Any column names omitted from the list
     are returned as nulls, and an error is raised if there are unexpected
     column names.  Here is an example:

<programlisting>
CREATE FUNCTION square_cube(in int, out squared int, out cubed int) AS $$
    return [list squared [expr {$1 * $1}] cubed [expr {$1 * $1 * $1}]]
$$ LANGUAGE pltcl;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     PL/Tcl函数也能返回组合类型的结果。要返回组合类型结果，Tcl代码必须返回匹配预期结果类型的“列名/值”对的列表。任何从该列表中省略的列名将被返回为空，如果有预期之外的列名则会报出错误。这里是一个例子：

<programlisting>
CREATE FUNCTION square_cube(in int, out squared int, out cubed int) AS $$
    return [list squared [expr {$1 * $1}] cubed [expr {$1 * $1 * $1}]]
$$ LANGUAGE pltcl;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=5b8ad1ec94f27a00d90c0fc5e9f7f533 -->

<!-- pgdoc-cn_start sig_en=a2a3a7c070a424d29d3512b4e453ab56 sig_cn_org=None source=14.1 
    <para>
     Output arguments of procedures are returned in the same way, for example:

<programlisting>
CREATE PROCEDURE tcl_triple(INOUT a integer, INOUT b integer) AS $$
    return [list a [expr {$1 * 3}] b [expr {$2 * 3}]]
$$ LANGUAGE pltcl;

CALL tcl_triple(5, 10);
</programlisting>
    </para>
________________________________________________________-->
    <para>
     过程的输出参数以相同的方式返回，例如：

<programlisting>
CREATE PROCEDURE tcl_triple(INOUT a integer, INOUT b integer) AS $$
    return [list a [expr {$1 * 3}] b [expr {$2 * 3}]]
$$ LANGUAGE pltcl;

CALL tcl_triple(5, 10);
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=a2a3a7c070a424d29d3512b4e453ab56 -->

    <tip>
<!-- pgdoc-cn_start sig_en=aac07dbc57ef81c7766a009a8c2ab389 sig_cn_org=None source=14.1 
     <para>
      The result list can be made from an array representation of the
      desired tuple with the <literal>array get</literal> Tcl command.  For example:

<programlisting>
CREATE FUNCTION raise_pay(employee, delta int) RETURNS employee AS $$
    set 1(salary) [expr {$1(salary) + $2}]
    return [array get 1]
$$ LANGUAGE pltcl;
</programlisting>
     </para>
________________________________________________________-->
     <para>
      结果列表可以用Tcl的<literal>array get</literal>命令从想得到的元组的数组表示中造出。例如：

<programlisting>
CREATE FUNCTION raise_pay(employee, delta int) RETURNS employee AS $$
    set 1(salary) [expr {$1(salary) + $2}]
    return [array get 1]
$$ LANGUAGE pltcl;
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=aac07dbc57ef81c7766a009a8c2ab389 -->
    </tip>

<!-- pgdoc-cn_start sig_en=15dec743674f87887eb90920f6674452 sig_cn_org=None source=14.1 
    <para>
     PL/Tcl functions can return sets.  To do this, the Tcl code should
     call <function>return_next</function> once per row to be returned,
     passing either the appropriate value when returning a scalar type,
     or a list of column name/value pairs when returning a composite type.
     Here is an example returning a scalar type:

<programlisting>
CREATE FUNCTION sequence(int, int) RETURNS SETOF int AS $$
    for {set i $1} {$i &lt; $2} {incr i} {
        return_next $i
    }
$$ LANGUAGE pltcl;
</programlisting>

     and here is one returning a composite type:

<programlisting>
CREATE FUNCTION table_of_squares(int, int) RETURNS TABLE (x int, x2 int) AS $$
    for {set i $1} {$i &lt; $2} {incr i} {
        return_next [list x $i x2 [expr {$i * $i}]]
    }
$$ LANGUAGE pltcl;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     PL/Tcl函数能够返回集合。要返回集合，Tcl代码应该对每一个要返回的行调用一次<function>return_next</function>，在返回标量类型时传入合适的值或者在返回组合类型时传入“列名/值”堆的列表。这里是一个返回标量类型的例子：

<programlisting>
CREATE FUNCTION sequence(int, int) RETURNS SETOF int AS $$
    for {set i $1} {$i &lt; $2} {incr i} {
        return_next $i
    }
$$ LANGUAGE pltcl;
</programlisting>

     这里是一个返回组合类型的例子：

<programlisting>
CREATE FUNCTION table_of_squares(int, int) RETURNS TABLE (x int, x2 int) AS $$
    for {set i $1} {$i &lt; $2} {incr i} {
        return_next [list x $i x2 [expr {$i * $i}]]
    }
$$ LANGUAGE pltcl;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=15dec743674f87887eb90920f6674452 -->

   </sect1>

   <sect1 id="pltcl-data">
<!-- pgdoc-cn_start sig_en=b7672c4e9d7e343829e7b4efd0a4d45f sig_cn_org=None source=14.1 
    <title>Data Values in PL/Tcl</title>
________________________________________________________-->
    <title>PL/Tcl 中的数据值</title>
<!-- pgdoc-cn_end sig_en=b7672c4e9d7e343829e7b4efd0a4d45f -->

<!-- pgdoc-cn_start sig_en=601b7359e241035e55deb3051955af59 sig_cn_org=None source=14.1 
    <para>
     The argument values supplied to a PL/Tcl function's code are simply
     the input arguments converted to text form (just as if they had been
     displayed by a <command>SELECT</command> statement).  Conversely, the
     <literal>return</literal> and <literal>return_next</literal> commands will accept
     any string that is acceptable input format for the function's declared
     result type, or for the specified column of a composite result type.
    </para>
________________________________________________________-->
    <para>
     提供给 PL/Tcl 函数代码的参数值是输入参数简单转换而成的文本形式（就像被<command>SELECT</command>语句显示的那样）。反过来，<literal>return</literal>和<literal>return_next</literal>命令将接受任何字符串，只要它是该函数声明的返回类型的可接受的输入格式，或者是组合结果类型的指定列的可接受输入格式。
    </para>
<!-- pgdoc-cn_end sig_en=601b7359e241035e55deb3051955af59 -->

   </sect1>

   <sect1 id="pltcl-global">
<!-- pgdoc-cn_start sig_en=bcfab542d12731bb70749ce7b5af4fc4 sig_cn_org=None source=14.1 
    <title>Global Data in PL/Tcl</title>
________________________________________________________-->
    <title>PL/Tcl 中的全局数据</title>
<!-- pgdoc-cn_end sig_en=bcfab542d12731bb70749ce7b5af4fc4 -->

<!-- pgdoc-cn_start sig_en=965cc5e1721adccde4ae508f6dee7672 sig_cn_org=None source=14.1 
    <indexterm zone="pltcl-global">
     <primary>global data</primary>
     <secondary>in PL/Tcl</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="pltcl-global">
     <primary>global data</primary>
     <secondary>in PL/Tcl</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=965cc5e1721adccde4ae508f6dee7672 -->

<!-- pgdoc-cn_start sig_en=1480cae798f61986ebb268d2b3be9a7b sig_cn_org=None source=14.1 
    <para>
     Sometimes it
     is useful to have some global data that is held between two
     calls to a function or is shared between different functions.
     This is easily done in PL/Tcl, but there are some restrictions that
     must be understood.
    </para>
________________________________________________________-->
    <para>
     有时候需要在同一个函数的两次调用间保持某些全局数据或者在不同的函数之间共享全局数据。在 PL/Tcl 中这很容易做到，但是必须了解一些限制。
    </para>
<!-- pgdoc-cn_end sig_en=1480cae798f61986ebb268d2b3be9a7b -->

<!-- pgdoc-cn_start sig_en=4eadc34732d96c16436090aa97646ec8 sig_cn_org=6329cf70ca5975b5dd6695d6021be645 source=15.7 
    <para>
     For security reasons, PL/Tcl executes functions called by any one SQL
     role in a separate Tcl interpreter for that role.  This prevents
     accidental or malicious interference by one user with the behavior of
     another user's PL/Tcl functions.  Each such interpreter will have its own
     values for any <quote>global</quote> Tcl variables.  Thus, two PL/Tcl
     functions will share the same global variables if and only if they are
     executed by the same SQL role.  In an application wherein a single
     session executes code under multiple SQL roles (via <literal>SECURITY
     DEFINER</literal> functions, use of <command>SET ROLE</command>, etc.) you may need to
     take explicit steps to ensure that PL/Tcl functions can share data.  To
     do that, make sure that functions that should communicate are owned by
     the same user, and mark them <literal>SECURITY DEFINER</literal>.  You must of
     course take care that such functions can't be used to do anything
     unintended.
    </para>
________________________________________________________-->
    <para>
     出于安全原因，PL/Tcl为每个SQL角色调用的函数在一个单独的Tcl解释器中执行。
     这可以防止一个用户意外或恶意干扰另一个用户的PL/Tcl函数行为。
     每个这样的解释器将有自己的值用于任何<quote>全局</quote>的Tcl变量。
     因此，只有当它们由相同的SQL角色执行时，两个PL/Tcl函数才会共享相同的全局变量。
     在一个应用程序中，一个会话通过<literal>SECURITY DEFINER</literal>函数、使用<command>SET ROLE</command>等方式执行多个SQL角色的代码时，
     您可能需要采取明确步骤来确保PL/Tcl函数可以共享数据。
     为此，请确保应该通信的函数由同一用户拥有，并标记为<literal>SECURITY DEFINER</literal>。
     当然，您必须小心，这些函数不能被用于执行任何意外操作。
    </para>
<!-- pgdoc-cn_end sig_en=4eadc34732d96c16436090aa97646ec8 -->

<!-- pgdoc-cn_start sig_en=01041c8f840426afbd95748002153d1d sig_cn_org=None source=14.1 
    <para>
     All PL/TclU functions used in a session execute in the same Tcl
     interpreter, which of course is distinct from the interpreter(s)
     used for PL/Tcl functions.  So global data is automatically shared
     between PL/TclU functions.  This is not considered a security risk
     because all PL/TclU functions execute at the same trust level,
     namely that of a database superuser.
    </para>
________________________________________________________-->
    <para>
     在一个会话中使用的所有 PL/TclU 函数都在同一个 Tcl 解释器中执行，这当然与用于 PL/Tcl 函数的解释器不同。因此，在 PL/TclU 函数之间会自动地共享全局数据。这并不是一种安全性风险，因为所有的 PL/TclU 函数都在同样的信任级别上执行，即都以数据库超级用户的级别执行。
    </para>
<!-- pgdoc-cn_end sig_en=01041c8f840426afbd95748002153d1d -->

<!-- pgdoc-cn_start sig_en=bf3747a56b069104d708871ab5eea159 sig_cn_org=None source=14.1 
    <para>
     To help protect PL/Tcl functions from unintentionally interfering
     with each other, a global
     array is made available to each function via the <function>upvar</function>
     command. The global name of this variable is the function's internal
     name, and the local name is <literal>GD</literal>.  It is recommended that
     <literal>GD</literal> be used
     for persistent private data of a function.  Use regular Tcl global
     variables only for values that you specifically intend to be shared among
     multiple functions.  (Note that the <literal>GD</literal> arrays are only
     global within a particular interpreter, so they do not bypass the
     security restrictions mentioned above.)
    </para>
________________________________________________________-->
    <para>
     为了保护 PL/Tcl 函数不会无意间彼此干扰，通过<function>upvar</function>命令可以建立一个对每个函数可用的全局数组。这个变量的全局名称是该函数的内部名称，并且本地名称为<literal>GD</literal>。推荐使用<literal>GD</literal>来保持一个函数的持久私有数据。只对你特别希望在多个函数之间共享的值使用常规的 Tcl 全局变量（注意<literal>GD</literal>数组只在一个特定的解释器中是全局的，因此它们不会绕过上文提到的安全性限制）。
    </para>
<!-- pgdoc-cn_end sig_en=bf3747a56b069104d708871ab5eea159 -->

<!-- pgdoc-cn_start sig_en=ef8088a27037555d63a44604cc8c1567 sig_cn_org=None source=14.1 
    <para>
     An example of using <literal>GD</literal> appears in the
     <function>spi_execp</function> example below.
    </para>
________________________________________________________-->
    <para>
     下文的<function>spi_execp</function>例子中有一个使用<literal>GD</literal>的例子。
    </para>
<!-- pgdoc-cn_end sig_en=ef8088a27037555d63a44604cc8c1567 -->
   </sect1>

   <sect1 id="pltcl-dbaccess">
<!-- pgdoc-cn_start sig_en=82f76431d298571ff533fe7772c7aa71 sig_cn_org=None source=14.1 
    <title>Database Access from PL/Tcl</title>
________________________________________________________-->
    <title>从 PL/Tcl 访问数据库</title>
<!-- pgdoc-cn_end sig_en=82f76431d298571ff533fe7772c7aa71 -->

<!-- pgdoc-cn_start sig_en=d194693f9108e186739b2b86a0e8710d sig_cn_org=786adbb743979796370439225e916183 source=15.7 
    <para>
     In this section, we follow the usual Tcl convention of using question
     marks, rather than brackets, to indicate an optional element in a
     syntax synopsis.  The following commands are available to access
     the database from the body of a PL/Tcl function:

    <variablelist>

     <varlistentry>
________________________________________________________-->
    <para>
     在本节中，我们遵循通常的Tcl约定，使用问号而不是方括号来表示语法概要中的可选元素。以下命令可用于从PL/Tcl函数体中访问数据库：

    <variablelist>

     <varlistentry>
<!-- pgdoc-cn_end sig_en=d194693f9108e186739b2b86a0e8710d -->
      <term><literal><function>spi_exec</function> <optional role="tcl">-count <replaceable>n</replaceable></optional> <optional role="tcl">-array <replaceable>name</replaceable></optional> <replaceable>command</replaceable> <optional role="tcl"><replaceable>loop-body</replaceable></optional></literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=ef6803eb2e68c5000362bbb93de19b03 sig_cn_org=b690019c58b54fd17fe2f3c553d09047 source=15.7 
       <para>
        Executes an SQL command given as a string.  An error in the command
        causes an error to be raised.  Otherwise, the return value of <function>spi_exec</function>
        is the number of rows processed (selected, inserted, updated, or
        deleted) by the command, or zero if the command is a utility
        statement.  In addition, if the command is a <command>SELECT</command> statement, the
        values of the selected columns are placed in Tcl variables as
        described below.
       </para>
________________________________________________________-->
       <para>
        执行作为字符串给出的SQL命令。命令中的错误会引发错误。否则，<function>spi_exec</function>的返回值是命令处理的行数（选择、插入、更新或删除），如果命令是实用程序语句，则返回值为零。此外，如果命令是<command>SELECT</command>语句，则所选列的值将按照下面描述的方式放入Tcl变量中。
       </para>
<!-- pgdoc-cn_end sig_en=ef6803eb2e68c5000362bbb93de19b03 -->
<!-- pgdoc-cn_start sig_en=1c341eb9327ff6dc17d9ba6037055823 sig_cn_org=dccfaa68ee941fd24f9c602ddcfd0d7c source=15.7 
       <para>
        The optional <literal>-count</literal> value tells
        <function>spi_exec</function> to stop
        once <replaceable>n</replaceable> rows have been retrieved,
        much as if the query included a <literal>LIMIT</literal> clause.
        If <replaceable>n</replaceable> is zero, the query is run to
        completion, the same as when <literal>-count</literal> is omitted.
       </para>
________________________________________________________-->
       <para>
        可选的<literal>-count</literal>值告诉<function>spi_exec</function>在检索到<replaceable>n</replaceable>行后停止，
        就像查询包含<literal>LIMIT</literal>子句一样。
        如果<replaceable>n</replaceable>为零，则查询运行到完成，与省略<literal>-count</literal>时相同。
</para>
<!-- pgdoc-cn_end sig_en=1c341eb9327ff6dc17d9ba6037055823 -->
<!-- pgdoc-cn_start sig_en=399e3a61d74e8742f6f004654ff3b35b sig_cn_org=9268beb9fc0c577c1815692b6dbe4374 source=15.7 
       <para>
        If the command is a <command>SELECT</command> statement, the values of the
        result columns are placed into Tcl variables named after the columns.
        If the <literal>-array</literal> option is given, the column values are
        instead stored into elements of the named associative array, with the
        column names used as array indexes.  In addition, the current row
        number within the result (counting from zero) is stored into the array
        element named <quote><literal>.tupno</literal></quote>, unless that name is
        in use as a column name in the result.
       </para>
________________________________________________________-->
       <para>
        如果命令是<command>SELECT</command>语句，则结果列的值将放入以列名命名的Tcl变量中。
        如果给定了<literal>-array</literal>选项，则列值将存储在命名的关联数组的元素中，
        列名用作数组索引。此外，结果中的当前行号（从零开始计数）将存储在数组元素中，
        该数组元素命名为<quote><literal>.tupno</literal></quote>，除非该名称在结果中用作列名。
</para>
<!-- pgdoc-cn_end sig_en=399e3a61d74e8742f6f004654ff3b35b -->
<!-- pgdoc-cn_start sig_en=7b520577cf5cbff42115d772bce78f7f sig_cn_org=f02a4de5e91e5de8a4bdf44d8b692c2e source=15.7 
       <para>
        If the command is a <command>SELECT</command> statement and no <replaceable>loop-body</replaceable>
        script is given, then only the first row of results are stored into
        Tcl variables or array elements; remaining rows, if any, are ignored.
        No storing occurs if the query returns no rows.  (This case can be
        detected by checking the result of <function>spi_exec</function>.)
        For example:
<programlisting>
spi_exec "SELECT count(*) AS cnt FROM pg_proc"
</programlisting>
        will set the Tcl variable <literal>$cnt</literal> to the number of rows in
        the <structname>pg_proc</structname> system catalog.
       </para>
________________________________________________________-->
       <para>
        如果命令是一个<command>SELECT</command>语句，并且没有给出<replaceable>loop-body</replaceable>
        脚本，则只有结果的第一行被存储到Tcl变量或数组元素中；如果有剩余的行，则被忽略。
        如果查询没有返回行，则不会发生存储。（可以通过检查<function>spi_exec</function>的结果来检测这种情况。）
        例如：
<programlisting>
spi_exec "SELECT count(*) AS cnt FROM pg_proc"
</programlisting>
        将把Tcl变量<literal>$cnt</literal>设置为<structname>pg_proc</structname>系统目录中的行数。
       </para>
<!-- pgdoc-cn_end sig_en=7b520577cf5cbff42115d772bce78f7f -->
<!-- pgdoc-cn_start sig_en=d4c88c6cdd728c1d0fa8823455343fd1 sig_cn_org=e3a9be894fd18fb1edb09e88d432f1ea source=15.7 
       <para>
        If the optional <replaceable>loop-body</replaceable> argument is given, it is
        a piece of Tcl script that is executed once for each row in the
        query result.  (<replaceable>loop-body</replaceable> is ignored if the given
        command is not a <command>SELECT</command>.)
        The values of the current row's columns
        are stored into Tcl variables or array elements before each iteration.
        For example:
<programlisting>
spi_exec -array C "SELECT * FROM pg_class" {
    elog DEBUG "have table $C(relname)"
}
</programlisting>
        will print a log message for every row of <literal>pg_class</literal>.  This
        feature works similarly to other Tcl looping constructs; in
        particular <literal>continue</literal> and <literal>break</literal> work in the
        usual way inside the loop body.
       </para>
________________________________________________________-->
       <para>
        如果给定了可选的<replaceable>loop-body</replaceable>参数，它是一段Tcl脚本，对查询结果中的每一行执行一次。
        （如果给定的命令不是<command>SELECT</command>，则会忽略<replaceable>loop-body</replaceable>。）
        当前行的列的值在每次迭代之前存储到Tcl变量或数组元素中。
        例如：
<programlisting>
spi_exec -array C "SELECT * FROM pg_class" {
    elog DEBUG "have table $C(relname)"
}
</programlisting>
        将为每一行<literal>pg_class</literal>打印一个日志消息。这个特性类似于其他Tcl循环结构；特别是<literal>continue</literal>和<literal>break</literal>在循环体内部的工作方式与通常相同。
       </para>
<!-- pgdoc-cn_end sig_en=d4c88c6cdd728c1d0fa8823455343fd1 -->
<!-- pgdoc-cn_start sig_en=a1c40e2e559cbbc8cc6926c05ab59dd3 sig_cn_org=3386aaa9348b09e536ee92b570d06d49 source=15.7 
       <para>
        If a column of a query result is null, the target
        variable for it is <quote>unset</quote> rather than being set.
       </para>
________________________________________________________-->
       <para>
        如果查询结果的某一列为空，那么对应的目标变量将被设置为<quote>未设置</quote>，而不是被设置。
       </para>
<!-- pgdoc-cn_end sig_en=a1c40e2e559cbbc8cc6926c05ab59dd3 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>spi_prepare</function> <replaceable>query</replaceable> <replaceable>typelist</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=941066397cadb74e4f80325e3b61b8cb sig_cn_org=130d767b2510b3d55fa0a54703692efe source=15.7 
       <para>
        Prepares and saves a query plan for later execution.  The
        saved plan will be retained for the life of the current
        session.<indexterm><primary>preparing a query</primary>
        <secondary>in PL/Tcl</secondary></indexterm>
       </para>
________________________________________________________-->
       <para>
        准备并保存查询计划以供以后执行。保存的计划将在当前会话的生命周期内保留。
        <indexterm><primary>准备查询</primary>
        <secondary>在PL/Tcl中</secondary></indexterm>
       </para>
<!-- pgdoc-cn_end sig_en=941066397cadb74e4f80325e3b61b8cb -->
<!-- pgdoc-cn_start sig_en=bf0a5878e79840b3b340bc31b479ffad sig_cn_org=c43500d72adcfb1d722c33ec9d9b332c source=15.7 
       <para>
        The query can use parameters, that is, placeholders for
        values to be supplied whenever the plan is actually executed.
        In the query string, refer to parameters
        by the symbols <literal>$1</literal> ... <literal>$<replaceable>n</replaceable></literal>.
        If the query uses parameters, the names of the parameter types
        must be given as a Tcl list.  (Write an empty list for
        <replaceable>typelist</replaceable> if no parameters are used.)
       </para>
________________________________________________________-->
       <para>
        查询可以使用参数，即值在实际执行计划时提供的占位符。
        在查询字符串中，通过符号<literal>$1</literal> ... <literal>$<replaceable>n</replaceable></literal>引用参数。
        如果查询使用参数，则必须将参数类型的名称给出为Tcl列表。
        （如果不使用参数，请写一个空列表给<replaceable>typelist</replaceable>。）
       </para>
<!-- pgdoc-cn_end sig_en=bf0a5878e79840b3b340bc31b479ffad -->
<!-- pgdoc-cn_start sig_en=04c0ccd1798514d0f3c708cbc72ed52d sig_cn_org=a317879fa9027139762219eccc8e020a source=15.7 
       <para>
        The return value from <function>spi_prepare</function> is a query ID
        to be used in subsequent calls to <function>spi_execp</function>. See
        <function>spi_execp</function> for an example.
       </para>
________________________________________________________-->
       <para>
        <function>spi_prepare</function>的返回值是一个查询ID，用于在后续调用<function>spi_execp</function>时使用。
        有关示例，请参见<function>spi_execp</function>。
       </para>
<!-- pgdoc-cn_end sig_en=04c0ccd1798514d0f3c708cbc72ed52d -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal><function>spi_execp</function> <optional role="tcl">-count <replaceable>n</replaceable></optional> <optional role="tcl">-array <replaceable>name</replaceable></optional> <optional role="tcl">-nulls <replaceable>string</replaceable></optional> <replaceable>queryid</replaceable> <optional role="tcl"><replaceable>value-list</replaceable></optional> <optional role="tcl"><replaceable>loop-body</replaceable></optional></literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=b3fbf59ad65b214edd108358014a89ef sig_cn_org=9ee9f7c6cdc69939c10b6671e9c4e16b source=15.7 
       <para>
        Executes a query previously prepared with <function>spi_prepare</function>.
        <replaceable>queryid</replaceable> is the ID returned by
        <function>spi_prepare</function>.  If the query references parameters,
        a <replaceable>value-list</replaceable> must be supplied.  This
        is a Tcl list of actual values for the parameters.  The list must be
        the same length as the parameter type list previously given to
        <function>spi_prepare</function>.  Omit <replaceable>value-list</replaceable>
        if the query has no parameters.
       </para>
________________________________________________________-->
       <para>
        执行之前使用<function>spi_prepare</function>准备的查询。
        <replaceable>queryid</replaceable>是<function>spi_prepare</function>返回的ID。
        如果查询引用了参数，则必须提供<replaceable>value-list</replaceable>。
        这是参数的实际值的Tcl列表。列表的长度必须与之前提供给<function>spi_prepare</function>的参数类型列表相同。
        如果查询没有参数，则省略<replaceable>value-list</replaceable>。
       </para>
<!-- pgdoc-cn_end sig_en=b3fbf59ad65b214edd108358014a89ef -->
<!-- pgdoc-cn_start sig_en=a49c705c62b4acdf56506af04f23d0a5 sig_cn_org=b3fa2ede000805006159c3e3e8a74291 source=15.7 
       <para>
        The optional value for <literal>-nulls</literal> is a string of spaces and
        <literal>'n'</literal> characters telling <function>spi_execp</function>
        which of the parameters are null values. If given, it must have exactly the
        same length as the <replaceable>value-list</replaceable>.  If it
        is not given, all the parameter values are nonnull.
       </para>
________________________________________________________-->
       <para>
        可选值<literal>-nulls</literal>是由空格和<literal>'n'</literal>字符组成的字符串，告诉<function>spi_execp</function>哪些参数是空值。
        如果提供了，它必须与<replaceable>value-list</replaceable>的长度完全相同。如果没有提供，所有参数值都是非空的。
</para>
<!-- pgdoc-cn_end sig_en=a49c705c62b4acdf56506af04f23d0a5 -->
<!-- pgdoc-cn_start sig_en=507cf8ccbcbd1947e37d2831f8051837 sig_cn_org=22d460733749a1b00d390668744d598a source=15.7 
       <para>
        Except for the way in which the query and its parameters are specified,
        <function>spi_execp</function> works just like <function>spi_exec</function>.
        The <literal>-count</literal>, <literal>-array</literal>, and
        <replaceable>loop-body</replaceable> options are the same,
        and so is the result value.
       </para>
________________________________________________________-->
       <para>
        除了查询及其参数的指定方式外，<function>spi_execp</function>的工作方式与<function>spi_exec</function>相同。
        <literal>-count</literal>，<literal>-array</literal>和<replaceable>loop-body</replaceable>选项也相同，结果值也相同。
</para>
<!-- pgdoc-cn_end sig_en=507cf8ccbcbd1947e37d2831f8051837 -->
<!-- pgdoc-cn_start sig_en=fa0d1e40572a2c714372cce9077785a5 sig_cn_org=ae638cde58140b217151490dab04ea3f source=15.7 
       <para>
        Here's an example of a PL/Tcl function using a prepared plan:

<programlisting>
CREATE FUNCTION t1_count(integer, integer) RETURNS integer AS $$
    if {![ info exists GD(plan) ]} {
        # prepare the saved plan on the first call
        set GD(plan) [ spi_prepare \
                "SELECT count(*) AS cnt FROM t1 WHERE num &gt;= \$1 AND num &lt;= \$2" \
                [ list int4 int4 ] ]
    }
    spi_execp -count 1 $GD(plan) [ list $1 $2 ]
    return $cnt
$$ LANGUAGE pltcl;
</programlisting>

        We need backslashes inside the query string given to
        <function>spi_prepare</function> to ensure that the
        <literal>$<replaceable>n</replaceable></literal> markers will be passed
        through to <function>spi_prepare</function> as-is, and not replaced by Tcl
        variable substitution.

       </para>
________________________________________________________-->
       <para>
        这是一个使用准备计划的PL/Tcl函数的示例：

<programlisting>
CREATE FUNCTION t1_count(integer, integer) RETURNS integer AS $$
    if {![ info exists GD(plan) ]} {
        # 在第一次调用时准备保存的计划
        set GD(plan) [ spi_prepare \
                "SELECT count(*) AS cnt FROM t1 WHERE num &gt;= \$1 AND num &lt;= \$2" \
                [ list int4 int4 ] ]
    }
    spi_execp -count 1 $GD(plan) [ list $1 $2 ]
    return $cnt
$$ LANGUAGE pltcl;
</programlisting>

        我们需要在传递给<function>spi_prepare</function>的查询字符串中使用反斜杠，
        以确保<literal>$<replaceable>n</replaceable></literal>标记将原样传递给
        <function>spi_prepare</function>，而不会被Tcl变量替换。

       </para>
<!-- pgdoc-cn_end sig_en=fa0d1e40572a2c714372cce9077785a5 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>subtransaction</function> <replaceable>command</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=f0064b03cc9f4d332653df9ae8ad39e3 sig_cn_org=885342c3b67e779e6b6d35089719fc24 source=15.7 
       <para>
        The Tcl script contained in <replaceable>command</replaceable> is
        executed within an SQL subtransaction.  If the script returns an
        error, that entire subtransaction is rolled back before returning the
        error out to the surrounding Tcl code.
        See <xref linkend="pltcl-subtransactions"/> for more details and an
        example.
       </para>
________________________________________________________-->
       <para>
        包含在<replaceable>command</replaceable>中的Tcl脚本在SQL子事务中执行。
        如果脚本返回错误，整个子事务将被回滚，然后将错误返回给周围的Tcl代码。
        有关更多详细信息和示例，请参见<xref linkend="pltcl-subtransactions"/>。
       </para>
<!-- pgdoc-cn_end sig_en=f0064b03cc9f4d332653df9ae8ad39e3 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>quote</function> <replaceable>string</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=d52f2ed5886f90640a9fac20549ec9eb sig_cn_org=116942c8884313a487430c249f7e9f33 source=15.7 
       <para>
        Doubles all occurrences of single quote and backslash characters
        in the given string.  This can be used to safely quote strings
        that are to be inserted into SQL commands given
        to <function>spi_exec</function> or
        <function>spi_prepare</function>.
        For example, think about an SQL command string like:

<programlisting>
"SELECT '$val' AS ret"
</programlisting>

        where the Tcl variable <literal>val</literal> actually contains
        <literal>doesn't</literal>. This would result
        in the final command string:

<programlisting>
SELECT 'doesn't' AS ret
</programlisting>

        which would cause a parse error during
        <function>spi_exec</function> or
        <function>spi_prepare</function>.
        To work properly, the submitted command should contain:

<programlisting>
SELECT 'doesn''t' AS ret
</programlisting>

        which can be formed in PL/Tcl using:

<programlisting>
"SELECT '[ quote $val ]' AS ret"
</programlisting>

        One advantage of <function>spi_execp</function> is that you don't
        have to quote parameter values like this, since the parameters are never
        parsed as part of an SQL command string.
       </para>
________________________________________________________-->
       <para>
        双倍所有出现的单引号和反斜杠字符在给定的字符串中。这可以用来安全地引用要插入到给定的SQL命令中的字符串
        给<function>spi_exec</function>或<function>spi_prepare</function>。例如，考虑一个类似的SQL命令字符串：

<programlisting>
"SELECT '$val' AS ret"
</programlisting>

        其中Tcl变量<literal>val</literal>实际包含<literal>doesn't</literal>。这将导致最终的命令字符串：

<programlisting>
SELECT 'doesn't' AS ret
</programlisting>

        这将在<function>spi_exec</function>或<function>spi_prepare</function>期间导致解析错误。
        为了正常工作，提交的命令应包含：

<programlisting>
SELECT 'doesn''t' AS ret
</programlisting>

        这可以在PL/Tcl中使用以下方式形成：

<programlisting>
"SELECT '[ quote $val ]' AS ret"
</programlisting>

        <function>spi_execp</function>的一个优点是，您不必像这样引用参数值，因为参数永远不会被解析为SQL命令字符串的一部分。
       </para>
<!-- pgdoc-cn_end sig_en=d52f2ed5886f90640a9fac20549ec9eb -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=ef6cfd21e4c651c1946813af6a557e0c sig_cn_org=f667b9e31c20c41c86117f60b8b7f812 source=15.7 
      <term>
       <function>elog</function> <replaceable>level</replaceable> <replaceable>msg</replaceable>
       <indexterm>
        <primary>elog</primary>
        <secondary>in PL/Tcl</secondary>
       </indexterm>
      </term>
________________________________________________________-->
      <term>
       <function>elog</function> <replaceable>级别</replaceable> <replaceable>消息</replaceable>
       <indexterm>
        <primary>elog</primary>
        <secondary>在PL/Tcl中</secondary>
       </indexterm>
      </term>
<!-- pgdoc-cn_end sig_en=ef6cfd21e4c651c1946813af6a557e0c -->
      <listitem>
<!-- pgdoc-cn_start sig_en=122f729585dc7b46c5fce567dc95741f sig_cn_org=a793683f060da50707c5e49400a466b1 source=15.7 
       <para>
        Emits a log or error message. Possible levels are
        <literal>DEBUG</literal>, <literal>LOG</literal>, <literal>INFO</literal>,
        <literal>NOTICE</literal>, <literal>WARNING</literal>, <literal>ERROR</literal>, and
        <literal>FATAL</literal>. <literal>ERROR</literal>
        raises an error condition; if this is not trapped by the surrounding
        Tcl code, the error propagates out to the calling query, causing
        the current transaction or subtransaction to be aborted.  This
        is effectively the same as the Tcl <literal>error</literal> command.
        <literal>FATAL</literal> aborts the transaction and causes the current
        session to shut down.  (There is probably no good reason to use
        this error level in PL/Tcl functions, but it's provided for
        completeness.)  The other levels only generate messages of different
        priority levels.
        Whether messages of a particular priority are reported to the client,
        written to the server log, or both is controlled by the
        <xref linkend="guc-log-min-messages"/> and
        <xref linkend="guc-client-min-messages"/> configuration
        variables. See <xref linkend="runtime-config"/>
        and <xref linkend="pltcl-error-handling"/>
        for more information.
       </para>
________________________________________________________-->
       <para>
        发出日志或错误消息。可能的级别包括
        <literal>DEBUG</literal>，<literal>LOG</literal>，<literal>INFO</literal>，
        <literal>NOTICE</literal>，<literal>WARNING</literal>，<literal>ERROR</literal>和
        <literal>FATAL</literal>。 <literal>ERROR</literal>
        引发错误条件；如果周围的Tcl代码没有捕获到这个错误，
        错误将传播到调用查询，导致当前事务或子事务被中止。这
        实际上与Tcl的<literal>error</literal>命令相同。
        <literal>FATAL</literal>中止事务并导致当前
        会话关闭。(在PL/Tcl函数中使用这个错误级别可能没有什么好理由，
        但为了完整性而提供。)其他级别只生成不同
        优先级的消息。
        特定优先级的消息是否报告给客户端，
        写入服务器日志，或两者都由
        <xref linkend="guc-log-min-messages"/>和
        <xref linkend="guc-client-min-messages"/>配置
        变量控制。参见<xref linkend="runtime-config"/>
        和<xref linkend="pltcl-error-handling"/>
        了解更多信息。
       </para>
<!-- pgdoc-cn_end sig_en=122f729585dc7b46c5fce567dc95741f -->
      </listitem>
     </varlistentry>

    </variablelist>
    </para>

   </sect1>

   <sect1 id="pltcl-trigger">
<!-- pgdoc-cn_start sig_en=5ade1dafc9c787a49ffcfe5d4643b2dc sig_cn_org=None source=14.1 
    <title>Trigger Functions in PL/Tcl</title>
________________________________________________________-->
    <title>PL/Tcl 中的触发器函数</title>
<!-- pgdoc-cn_end sig_en=5ade1dafc9c787a49ffcfe5d4643b2dc -->

<!-- pgdoc-cn_start sig_en=78d13f6594fcbd0b403ea2ed5c190adf sig_cn_org=None source=14.1 
    <indexterm>
     <primary>trigger</primary>
     <secondary>in PL/Tcl</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>trigger</primary>
     <secondary>in PL/Tcl</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=78d13f6594fcbd0b403ea2ed5c190adf -->

<!-- pgdoc-cn_start sig_en=50c8b8a9cc358aaebf2062dea7bf74ee sig_cn_org=None source=14.1 
    <para>
     Trigger functions can be written in PL/Tcl.
     <productname>PostgreSQL</productname> requires that a function that is to be called
     as a trigger must be declared as a function with no arguments
     and a return type of <literal>trigger</literal>.
    </para>
________________________________________________________-->
    <para>
     触发器函数也可以用 PL/Tcl 编写。<productname>PostgreSQL</productname>要求能作为触发器被调用的函数必须被声明为没有参数并且返回类型为<literal>trigger</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=50c8b8a9cc358aaebf2062dea7bf74ee -->
<!-- pgdoc-cn_start sig_en=7e624fe4b30ebef9eb8d004fe4eb7d02 sig_cn_org=None source=14.1 
    <para>
     The information from the trigger manager is passed to the function body
     in the following variables:

     <variablelist>

      <varlistentry>
       <term><varname>$TG_name</varname></term>
       <listitem>
        <para>
         The name of the trigger from the <command>CREATE TRIGGER</command> statement.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_relid</varname></term>
       <listitem>
        <para>
         The object ID of the table that caused the trigger function
         to be invoked.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_table_name</varname></term>
       <listitem>
        <para>
         The name of the table that caused the trigger function
         to be invoked.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_table_schema</varname></term>
       <listitem>
        <para>
         The schema of the table that caused the trigger function
         to be invoked.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_relatts</varname></term>
       <listitem>
        <para>
         A Tcl list of the table column names, prefixed with an empty list
         element. So looking up a column name in the list with <application>Tcl</application>'s
         <function>lsearch</function> command returns the element's number starting
         with 1 for the first column, the same way the columns are customarily
         numbered in <productname>PostgreSQL</productname>.  (Empty list
         elements also appear in the positions of columns that have been
         dropped, so that the attribute numbering is correct for columns
         to their right.)
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_when</varname></term>
       <listitem>
        <para>
         The string <literal>BEFORE</literal>, <literal>AFTER</literal>, or
         <literal>INSTEAD OF</literal>, depending on the type of trigger event.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_level</varname></term>
       <listitem>
        <para>
         The string <literal>ROW</literal> or <literal>STATEMENT</literal> depending on the
         type of trigger event.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_op</varname></term>
       <listitem>
        <para>
         The string <literal>INSERT</literal>, <literal>UPDATE</literal>,
         <literal>DELETE</literal>, or <literal>TRUNCATE</literal> depending on the type of
         trigger event.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$NEW</varname></term>
       <listitem>
        <para>
         An associative array containing the values of the new table
         row for <command>INSERT</command> or <command>UPDATE</command> actions, or
         empty for <command>DELETE</command>.  The array is indexed by column
         name.  Columns that are null will not appear in the array.
         This is not set for statement-level triggers.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$OLD</varname></term>
       <listitem>
        <para>
         An associative array containing the values of the old table
         row for <command>UPDATE</command> or <command>DELETE</command> actions, or
         empty for <command>INSERT</command>.  The array is indexed by column
         name.  Columns that are null will not appear in the array.
         This is not set for statement-level triggers.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$args</varname></term>
       <listitem>
        <para>
         A Tcl list of the arguments to the function as given in the
         <command>CREATE TRIGGER</command> statement. These arguments are also accessible as
         <literal>$1</literal> ... <literal>$<replaceable>n</replaceable></literal> in the function body.
        </para>
       </listitem>
      </varlistentry>

     </variablelist>
    </para>
________________________________________________________-->
    <para>
     来自于触发器管理器的信息通过下列变量被传递给函数体：

     <variablelist>

      <varlistentry>
       <term><varname>$TG_name</varname></term>
       <listitem>
        <para>
         <command>CREATE TRIGGER</command>语句中触发器的名字。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_relid</varname></term>
       <listitem>
        <para>
         导致触发器函数被调用的表的对象 ID。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_table_name</varname></term>
       <listitem>
        <para>
         导致触发器函数被调用的表的名字。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_table_schema</varname></term>
       <listitem>
        <para>
         导致触发器函数被调用的表所在的模式。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_relatts</varname></term>
       <listitem>
        <para>
         表列名的 Tcl 列表，前面放上一个空列表元素。因此用<application>Tcl</application>的<function>lsearch</function>命令在该列表中查找一个列名返回的元素编号会从 1 开始（对于第一列），这和<productname>PostgreSQL</productname>中的自定义编号是同样的方式（空列表元数也出现在被删除的列的位置上，这样其右边的列的属性编号才是正确的）。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_when</varname></term>
       <listitem>
        <para>
         可以为<literal>BEFORE</literal>、<literal>AFTER</literal>或者<literal>INSTEAD OF</literal>，具体的选择取决于触发器事件的类型。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_level</varname></term>
       <listitem>
        <para>
         可以为<literal>ROW</literal>或者<literal>STATEMENT</literal>，取决于触发器事件的类型。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_op</varname></term>
       <listitem>
        <para>
         可以为<literal>INSERT</literal>、<literal>UPDATE</literal>、<literal>DELETE</literal>或者<literal>TRUNCATE</literal>，取决于触发器事件的类型。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$NEW</varname></term>
       <listitem>
        <para>
         对于<command>INSERT</command>或者<command>UPDATE</command>动作是一个包含着新表行值的关联数组，对于<command>DELETE</command>为空。该数组以列名为索引。为空的列不会出现在数组中。对于语句级触发器这个变量不会被设置。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$OLD</varname></term>
       <listitem>
        <para>
         对于<command>UPDATE</command>或者<command>DELETE</command>动作是一个包含着新表行值的关联数组，对于<command>INSERT</command>为空。该数组以列名为索引。为空的列不会出现在数组中。对于语句级触发器这个变量不会被设置。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$args</varname></term>
       <listitem>
        <para>
         在<command>CREATE TRIGGER</command>语句中对过程给出的参数的 Tcl 列表。在过程体中也可以用<literal>$1</literal> ... <literal>$<replaceable>n</replaceable></literal>来访问这些参数。
        </para>
       </listitem>
      </varlistentry>

     </variablelist>
    </para>
<!-- pgdoc-cn_end sig_en=7e624fe4b30ebef9eb8d004fe4eb7d02 -->

<!-- pgdoc-cn_start sig_en=75f5c6368f57d3e0a438df80fd6a506d sig_cn_org=None source=14.1 
    <para>
     The return value from a trigger function can be one of the strings
     <literal>OK</literal> or <literal>SKIP</literal>, or a list of column name/value pairs.
     If the return value is <literal>OK</literal>,
     the operation (<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>)
     that fired the trigger will proceed
     normally. <literal>SKIP</literal> tells the trigger manager to silently suppress
     the operation for this row. If a list is returned, it tells PL/Tcl to
     return a modified row to the trigger manager; the contents of the
     modified row are specified by the column names and values in the list.
     Any columns not mentioned in the list are set to null.
     Returning a modified row is only meaningful
     for row-level <literal>BEFORE</literal> <command>INSERT</command> or <command>UPDATE</command>
     triggers, for which the modified row will be inserted instead of the one
     given in <varname>$NEW</varname>; or for row-level <literal>INSTEAD OF</literal>
     <command>INSERT</command> or <command>UPDATE</command> triggers where the returned row
     is used as the source data for <command>INSERT RETURNING</command> or
     <command>UPDATE RETURNING</command> clauses.
     In row-level <literal>BEFORE</literal> <command>DELETE</command> or <literal>INSTEAD
     OF</literal> <command>DELETE</command> triggers, returning a modified row has the same
     effect as returning <literal>OK</literal>, that is the operation proceeds.
     The trigger return value is ignored for all other types of triggers.
    </para>
________________________________________________________-->
    <para>
     一个触发器函数的返回值可以是字符串<literal>OK</literal>或者<literal>SKIP</literal>，或者是一个“列名/值”对的列表。如果返回值是<literal>OK</literal>，引发该触发器的操作（<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>）将正常继续下去。<literal>SKIP</literal>告诉触发器管理器悄悄地抑制对这一行的该操作。如果返回一个列表，它告诉PL/Tcl返回一个被修改的行给触发器管理器，这个被修改的行的内容由列表中的列名和值指定。该列表中没有提到的任何列会被设置为空。返回被修改行只对行级<literal>BEFORE</literal> <command>INSERT</command>或<command>UPDATE</command>触发器有意义，对它们来说这个被修改的行将被插入而不是插入<varname>$NEW</varname>中给出的行。返回被修改行还对行级<literal>INSTEAD OF</literal>
     <command>INSERT</command>或<command>UPDATE</command>触发器有意义，其中被返回的行被用作<command>INSERT RETURNING</command>或<command>UPDATE RETURNING</command>子句的源数据。在行级<literal>BEFORE</literal> <command>DELETE</command>或<literal>INSTEAD OF</literal> <command>DELETE</command>触发器中，返回一个被修改行的效果和返回<literal>OK</literal>的效果相同，即操作继续。对所有其他类型的触发器来说，触发器返回值会被忽略。
    </para>
<!-- pgdoc-cn_end sig_en=75f5c6368f57d3e0a438df80fd6a506d -->

    <tip>
<!-- pgdoc-cn_start sig_en=39f389b4991aa616b4a7e6ac068fd4d5 sig_cn_org=None source=14.1 
     <para>
      The result list can be made from an array representation of the
      modified tuple with the <literal>array get</literal> Tcl command.
     </para>
________________________________________________________-->
     <para>
      结果列表可以用Tcl的<literal>array get</literal>命令从被修改的元组的数组表示中造出。
     </para>
<!-- pgdoc-cn_end sig_en=39f389b4991aa616b4a7e6ac068fd4d5 -->
    </tip>

<!-- pgdoc-cn_start sig_en=8c8f7ba05caf5abe31f0b3a54c92dde9 sig_cn_org=None source=14.1 
    <para>
     Here's a little example trigger function that forces an integer value
     in a table to keep track of the number of updates that are performed on the
     row. For new rows inserted, the value is initialized to 0 and then
     incremented on every update operation.

<programlisting>
CREATE FUNCTION trigfunc_modcount() RETURNS trigger AS $$
    switch $TG_op {
        INSERT {
            set NEW($1) 0
        }
        UPDATE {
            set NEW($1) $OLD($1)
            incr NEW($1)
        }
        default {
            return OK
        }
    }
    return [array get NEW]
$$ LANGUAGE pltcl;

CREATE TABLE mytab (num integer, description text, modcnt integer);

CREATE TRIGGER trig_mytab_modcount BEFORE INSERT OR UPDATE ON mytab
    FOR EACH ROW EXECUTE FUNCTION trigfunc_modcount('modcnt');
</programlisting>

     Notice that the trigger function itself does not know the column
     name; that's supplied from the trigger arguments.  This lets the
     trigger function be reused with different tables.
    </para>
________________________________________________________-->
    <para>
     这里有一个触发器函数的例子，它用一个表中的整数值来跟踪在行上被执行的更新数。对于被插入的新行，该值被初始化为 0 并且之后在每一次更新操作时被加一。

<programlisting>
CREATE FUNCTION trigfunc_modcount() RETURNS trigger AS $$
    switch $TG_op {
        INSERT {
            set NEW($1) 0
        }
        UPDATE {
            set NEW($1) $OLD($1)
            incr NEW($1)
        }
        default {
            return OK
        }
    }
    return [array get NEW]
$$ LANGUAGE pltcl;

CREATE TABLE mytab (num integer, description text, modcnt integer);

CREATE TRIGGER trig_mytab_modcount BEFORE INSERT OR UPDATE ON mytab
    FOR EACH ROW EXECUTE FUNCTION trigfunc_modcount('modcnt');
</programlisting>

     注意触发器函数本身不知道列名，列名由触发器参数提供。这让触发器函数可以被重用于不同的表。
    </para>
<!-- pgdoc-cn_end sig_en=8c8f7ba05caf5abe31f0b3a54c92dde9 -->
   </sect1>

   <sect1 id="pltcl-event-trigger">
<!-- pgdoc-cn_start sig_en=304c1bbe415a5f8a0c6c3b459e77a9e3 sig_cn_org=None source=14.1 
    <title>Event Trigger Functions in PL/Tcl</title>
________________________________________________________-->
    <title>PL/Tcl 中的事件触发器函数</title>
<!-- pgdoc-cn_end sig_en=304c1bbe415a5f8a0c6c3b459e77a9e3 -->

<!-- pgdoc-cn_start sig_en=326245c4fca3d32cd9520b24efd9858e sig_cn_org=None source=14.1 
    <indexterm>
     <primary>event trigger</primary>
     <secondary>in PL/Tcl</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>event trigger</primary>
     <secondary>in PL/Tcl</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=326245c4fca3d32cd9520b24efd9858e -->

<!-- pgdoc-cn_start sig_en=921c39b6560ebdac30a9ce3d8c8c4204 sig_cn_org=None source=14.1 
    <para>
     Event trigger functions can be written in PL/Tcl.
     <productname>PostgreSQL</productname> requires that a function that is
     to be called as an event trigger must be declared as a function with no
     arguments and a return type of <literal>event_trigger</literal>.
    </para>
________________________________________________________-->
    <para>
     事件触发器函数也可以用 PL/Tcl 编写。<productname>PostgreSQL</productname>要求能作为事件触发器被调用的函数必须被声明为没有参数并且返回类型为<literal>event_trigger</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=921c39b6560ebdac30a9ce3d8c8c4204 -->
<!-- pgdoc-cn_start sig_en=e029c86bc0dc5aeb3ed2aae6f54dd4a7 sig_cn_org=None source=14.1 
    <para>
     The information from the trigger manager is passed to the function body
     in the following variables:

     <variablelist>

      <varlistentry>
       <term><varname>$TG_event</varname></term>
       <listitem>
        <para>
         The name of the event the trigger is fired for.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_tag</varname></term>
       <listitem>
        <para>
         The command tag for which the trigger is fired.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
________________________________________________________-->
    <para>
     来自于触发器管理器的信息通过下列变量被传递给函数体：

     <variablelist>

      <varlistentry>
       <term><varname>$TG_event</varname></term>
       <listitem>
        <para>
         触发器为其引发的事件名。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><varname>$TG_tag</varname></term>
       <listitem>
        <para>
         触发器为其引发的命令标签。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
<!-- pgdoc-cn_end sig_en=e029c86bc0dc5aeb3ed2aae6f54dd4a7 -->

<!-- pgdoc-cn_start sig_en=fc5b70ebf5ab609b25d0f0859d3966ce sig_cn_org=None source=14.1 
    <para>
     The return value of the trigger function is ignored.
    </para>
________________________________________________________-->
    <para>
     触发器函数的返回值被忽略。
    </para>
<!-- pgdoc-cn_end sig_en=fc5b70ebf5ab609b25d0f0859d3966ce -->

<!-- pgdoc-cn_start sig_en=3db5ff03502d01891c3e4d08c5942583 sig_cn_org=None source=14.1 
    <para>
     Here's a little example event trigger function that simply raises
     a <literal>NOTICE</literal> message each time a supported command is
     executed:

<programlisting>
CREATE OR REPLACE FUNCTION tclsnitch() RETURNS event_trigger AS $$
  elog NOTICE "tclsnitch: $TG_event $TG_tag"
$$ LANGUAGE pltcl;

CREATE EVENT TRIGGER tcl_a_snitch ON ddl_command_start EXECUTE FUNCTION tclsnitch();
</programlisting>
    </para>
________________________________________________________-->
    <para>
     这里是一个事件触发器函数的小例子，它在所支持的命令每次执行时简单地产生一个<literal>NOTICE</literal>消息：

<programlisting>
CREATE OR REPLACE FUNCTION tclsnitch() RETURNS event_trigger AS $$
  elog NOTICE "tclsnitch: $TG_event $TG_tag"
$$ LANGUAGE pltcl;

CREATE EVENT TRIGGER tcl_a_snitch ON ddl_command_start EXECUTE FUNCTION tclsnitch();
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=3db5ff03502d01891c3e4d08c5942583 -->
   </sect1>

   <sect1 id="pltcl-error-handling">
<!-- pgdoc-cn_start sig_en=69b9ad5942d3e8fc30d3f5f921a04db5 sig_cn_org=None source=14.1 
    <title>Error Handling in PL/Tcl</title>
________________________________________________________-->
    <title>PL/Tcl 中的错误处理</title>
<!-- pgdoc-cn_end sig_en=69b9ad5942d3e8fc30d3f5f921a04db5 -->

<!-- pgdoc-cn_start sig_en=443a715148ea00ac9d28593d9bd7b43d sig_cn_org=None source=14.1 
    <indexterm>
     <primary>exceptions</primary>
     <secondary>in PL/Tcl</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>exceptions</primary>
     <secondary>in PL/Tcl</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=443a715148ea00ac9d28593d9bd7b43d -->

<!-- pgdoc-cn_start sig_en=939d912715dec9479ae3c806080c1382 sig_cn_org=None source=14.1 
    <para>
     Tcl code within or called from a PL/Tcl function can raise an error,
     either by executing some invalid operation or by generating an error
     using the Tcl <function>error</function> command or
     PL/Tcl's <function>elog</function> command.  Such errors can be caught
     within Tcl using the Tcl <function>catch</function> command.  If an
     error is not caught but is allowed to propagate out to the top level of
     execution of the PL/Tcl function, it is reported as an SQL error in the
     function's calling query.
    </para>
________________________________________________________-->
    <para>
     PL/Tcl 函数中的 Tcl 代码或者从 PL/Tcl 函数中调用的代码可以抛出一个错误，错误可以由执行某些非法操作产生或者通过使用 Tcl <function>error</function>命令或者 PL/Tcl 的<function>elog</function>命令产生。Tcl 中可以使用 Tcl <function>catch</function>命令捕获这类错误。如果一个错误没有被捕捉但是被允许传播到该PL/Tcl函数执行的顶层，它会在该函数的调用查询中被报告为一个SQL错误。
    </para>
<!-- pgdoc-cn_end sig_en=939d912715dec9479ae3c806080c1382 -->

<!-- pgdoc-cn_start sig_en=71f29446a2b316481ff3f8ab4be2ab7f sig_cn_org=None source=14.1 
    <para>
     Conversely, SQL errors that occur within PL/Tcl's
     <function>spi_exec</function>, <function>spi_prepare</function>,
     and <function>spi_execp</function> commands are reported as Tcl errors,
     so they are catchable by Tcl's <function>catch</function> command.
     (Each of these PL/Tcl commands runs its SQL operation in a
     subtransaction, which is rolled back on error, so that any
     partially-completed operation is automatically cleaned up.)
     Again, if an error propagates out to the top level without being caught,
     it turns back into an SQL error.
    </para>
________________________________________________________-->
    <para>
     相反，在 PL/Tcl 的<function>spi_exec</function>、<function>spi_prepare</function>以及<function>spi_execp</function>命令中发生的SQL错误会被报告为 Tcl 错误，因此它们也可以被 Tcl 的<function>catch</function>命令捕获（这些PL/Tcl命令中的每一个都在一个子事务中运行它的SQL操作，该子事务在错误时会被回滚，这样任何部分完成的操作也会被自动清除）。同样地，如果一个错误被传播到顶层而没有被捕获，它会转变成SQL错误。
    </para>
<!-- pgdoc-cn_end sig_en=71f29446a2b316481ff3f8ab4be2ab7f -->

<!-- pgdoc-cn_start sig_en=1f39a6b3acc6e0333a3a7f9d2e4897ec sig_cn_org=None source=14.1 
    <para>
     Tcl provides an <varname>errorCode</varname> variable that can represent
     additional information about an error in a form that is easy for Tcl
     programs to interpret.  The contents are in Tcl list format, and the
     first word identifies the subsystem or library reporting the error;
     beyond that the contents are left to the individual subsystem or
     library.  For database errors reported by PL/Tcl commands, the first
     word is <literal>POSTGRES</literal>, the second word is the PostgreSQL
     version number, and additional words are field name/value pairs
     providing detailed information about the error.
     Fields <varname>SQLSTATE</varname>, <varname>condition</varname>,
     and <varname>message</varname> are always supplied
     (the first two represent the error code and condition name as shown
     in <xref linkend="errcodes-appendix"/>).
     Fields that may be present include
     <varname>detail</varname>, <varname>hint</varname>, <varname>context</varname>,
     <varname>schema</varname>, <varname>table</varname>, <varname>column</varname>,
     <varname>datatype</varname>, <varname>constraint</varname>,
     <varname>statement</varname>, <varname>cursor_position</varname>,
     <varname>filename</varname>, <varname>lineno</varname>, and
     <varname>funcname</varname>.
    </para>
________________________________________________________-->
    <para>
     Tcl 提供了一个<varname>errorCode</varname>变量，它表示有关于一个错误的附加信息，它的格式易于 Tcl 程序解释。该变量的内容符合 Tcl 列表格式，第一个词标识报告该错误的子系统或者库，之后的内容则留给子系统或者库来填充。对于 PL/Tcl 命令报告的数据库错误，第一个词是<literal>POSTGRES</literal>，第二个词是 PostgreSQL 的版本号，剩下的部分是域名称/域值构成的对，它们提供有关该错误的详细信息。域<varname>SQLSTATE</varname>、<varname>condition</varname>以及<varname>message</varname>总是会被提供（前两个表示<xref linkend="errcodes-appendix"/>中所示的错误代码和情况名称）。可能出现的域包括
     <varname>detail</varname>、<varname>hint</varname>、<varname>context</varname>、
     <varname>schema</varname>、<varname>table</varname>、<varname>column</varname>、
     <varname>datatype</varname>、<varname>constraint</varname>、
     <varname>statement</varname>、<varname>cursor_position</varname>、
     <varname>filename</varname>、<varname>lineno</varname>以及
     <varname>funcname</varname>。
    </para>
<!-- pgdoc-cn_end sig_en=1f39a6b3acc6e0333a3a7f9d2e4897ec -->

<!-- pgdoc-cn_start sig_en=8e7907e43c1467514a59cb6f6dcab7a1 sig_cn_org=None source=14.1 
    <para>
     A convenient way to work with PL/Tcl's <varname>errorCode</varname>
     information is to load it into an array, so that the field names become
     array subscripts.  Code for doing that might look like
<programlisting>
if {[catch { spi_exec $sql_command }]} {
    if {[lindex $::errorCode 0] == "POSTGRES"} {
        array set errorArray $::errorCode
        if {$errorArray(condition) == "undefined_table"} {
            # deal with missing table
        } else {
            # deal with some other type of SQL error
        }
    }
}
</programlisting>
     (The double colons explicitly specify that <varname>errorCode</varname>
     is a global variable.)
    </para>
________________________________________________________-->
    <para>
     使用 PL/Tcl 的<varname>errorCode</varname>信息的一种便捷方式是把它载入到一个数组中，这样域名称就变成了数组下标。这样做的代码看起来像这样
<programlisting>
if {[catch { spi_exec $sql_command }]} {
    if {[lindex $::errorCode 0] == "POSTGRES"} {
        array set errorArray $::errorCode
        if {$errorArray(condition) == "undefined_table"} {
            # deal with missing table
        } else {
            # deal with some other type of SQL error
        }
    }
}
</programlisting>
     （双冒号显式地指定<varname>errorCode</varname>是一个全局变量）。
    </para>
<!-- pgdoc-cn_end sig_en=8e7907e43c1467514a59cb6f6dcab7a1 -->
   </sect1>

   <sect1 id="pltcl-subtransactions">
<!-- pgdoc-cn_start sig_en=814b68f6d4adf04c9dd444bf8fc8b865 sig_cn_org=None source=14.1 
    <title>Explicit Subtransactions in PL/Tcl</title>
________________________________________________________-->
    <title>PL/Tcl中的显式子事务</title>
<!-- pgdoc-cn_end sig_en=814b68f6d4adf04c9dd444bf8fc8b865 -->

<!-- pgdoc-cn_start sig_en=f5bb5442ef0b22f85d4ffa1a17bdd186 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>subtransactions</primary>
     <secondary>in PL/Tcl</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>subtransactions</primary>
     <secondary>in PL/Tcl</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=f5bb5442ef0b22f85d4ffa1a17bdd186 -->

<!-- pgdoc-cn_start sig_en=57baa8ee348d23516fb3a572e67f1e09 sig_cn_org=None source=14.1 
    <para>
     Recovering from errors caused by database access as described in
     <xref linkend="pltcl-error-handling"/> can lead to an undesirable
     situation where some operations succeed before one of them fails,
     and after recovering from that error the data is left in an
     inconsistent state.  PL/Tcl offers a solution to this problem in
     the form of explicit subtransactions.
    </para>
________________________________________________________-->
    <para>
     从<xref linkend="pltcl-error-handling"/>中介绍的数据库访问导致的错误中恢复可能导致一种不可取的情况，其中一些操作在它们中的一个失败前成功完成，并且在从错误中恢复过来后数据还处于一种不一致的状态。PL/Tcl以显式子事务的形式为这类问题提供了一个解决方案。
    </para>
<!-- pgdoc-cn_end sig_en=57baa8ee348d23516fb3a572e67f1e09 -->

<!-- pgdoc-cn_start sig_en=963530e5b78b123b5d7f72cdf97c2275 sig_cn_org=None source=14.1 
    <para>
     Consider a function that implements a transfer between two accounts:
<programlisting>
CREATE FUNCTION transfer_funds() RETURNS void AS $$
    if [catch {
        spi_exec "UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'"
        spi_exec "UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'"
    } errormsg] {
        set result [format "error transferring funds: %s" $errormsg]
    } else {
        set result "funds transferred successfully"
    }
    spi_exec "INSERT INTO operations (result) VALUES ('[quote $result]')"
$$ LANGUAGE pltcl;
</programlisting>
     If the second <command>UPDATE</command> statement results in an
     exception being raised, this function will log the failure, but
     the result of the first <command>UPDATE</command> will
     nevertheless be committed.  In other words, the funds will be
     withdrawn from Joe's account, but will not be transferred to
     Mary's account.  This happens because each <function>spi_exec</function>
     is a separate subtransaction, and only one of those subtransactions
     got rolled back.
    </para>
________________________________________________________-->
    <para>
     考虑一个在两个账户间实现转账的函数：
<programlisting>
CREATE FUNCTION transfer_funds() RETURNS void AS $$
    if [catch {
        spi_exec "UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'"
        spi_exec "UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'"
    } errormsg] {
        set result [format "error transferring funds: %s" $errormsg]
    } else {
        set result "funds transferred successfully"
    }
    spi_exec "INSERT INTO operations (result) VALUES ('[quote $result]')"
$$ LANGUAGE pltcl;
</programlisting>
     如果第二个<command>UPDATE</command>语句导致一个异常，这个函数将记下该失败，但是第一个<command>UPDATE</command>的结果将被提交。换句话说，资金将从Joe的账户中被取走，但不会被转到Mary的账户。这是因为每个<function>spi_exec</function>都是一个单独的子事务，并且那些子事务中只有一个被回滚。
    </para>
<!-- pgdoc-cn_end sig_en=963530e5b78b123b5d7f72cdf97c2275 -->

<!-- pgdoc-cn_start sig_en=43738b9aebe5fa4e7c3fc8c294ca302c sig_cn_org=None source=14.1 
    <para>
     To handle such cases, you can wrap multiple database operations in an
     explicit subtransaction, which will succeed or roll back as a whole.
     PL/Tcl provides a <function>subtransaction</function> command to manage
     this.  We can rewrite our function as:
<programlisting>
CREATE FUNCTION transfer_funds2() RETURNS void AS $$
    if [catch {
        subtransaction {
            spi_exec "UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'"
            spi_exec "UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'"
        }
    } errormsg] {
        set result [format "error transferring funds: %s" $errormsg]
    } else {
        set result "funds transferred successfully"
    }
    spi_exec "INSERT INTO operations (result) VALUES ('[quote $result]')"
$$ LANGUAGE pltcl;
</programlisting>
     Note that use of <function>catch</function> is still required for this
     purpose.  Otherwise the error would propagate to the top level of the
     function, preventing the desired insertion into
     the <structname>operations</structname> table.
     The <function>subtransaction</function> command does not trap errors, it
     only assures that all database operations executed inside its scope will
     be rolled back together when an error is reported.
    </para>
________________________________________________________-->
    <para>
     为了处理这类情况，你可以把多个数据库操作包裹在一个显式子事务中，它将作为一个整体成功完成或者回滚。PL/Tcl提供了一个<function>subtransaction</function>命令来做这件事情。我们可以把我们的函数写成：
<programlisting>
CREATE FUNCTION transfer_funds2() RETURNS void AS $$
    if [catch {
        subtransaction {
            spi_exec "UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'"
            spi_exec "UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'"
        }
    } errormsg] {
        set result [format "error transferring funds: %s" $errormsg]
    } else {
        set result "funds transferred successfully"
    }
    spi_exec "INSERT INTO operations (result) VALUES ('[quote $result]')"
$$ LANGUAGE pltcl;
</programlisting>
     注意，为了实现这个目的仍要求使用<function>catch</function>。否则错误将传播到该函数的顶层，导致想要对<structname>operations</structname>表的插入被阻止。<function>subtransaction</function>命令不会捕捉错误，它仅确保报告错误时在其范围内执行的所有数据库操作将被一起回滚。
    </para>
<!-- pgdoc-cn_end sig_en=43738b9aebe5fa4e7c3fc8c294ca302c -->

<!-- pgdoc-cn_start sig_en=fe5ce12fc579be876e552c55a86f2c1d sig_cn_org=None source=14.1 
    <para>
     A rollback of an explicit subtransaction occurs on any error reported
     by the contained Tcl code, not only errors originating from database
     access.  Thus a regular Tcl exception raised inside
     a <function>subtransaction</function> command will also cause the
     subtransaction to be rolled back.  However, non-error exits out of the
     contained Tcl code (for instance, due to <function>return</function>) do
     not cause a rollback.
    </para>
________________________________________________________-->
    <para>
     一个显式子事务的回滚发生在包含它的Tcl代码报告任何错误时，而不仅仅是数据库访问导致的错误。因此一个<function>subtransaction</function>命令中发生的常规Tcl异常也将导致该子事务被回滚。不过，无错误退出到包含子事务的Tcl代码外面（例如，由于<function>return</function>）不会导致回滚。
    </para>
<!-- pgdoc-cn_end sig_en=fe5ce12fc579be876e552c55a86f2c1d -->
   </sect1>

   <sect1 id="pltcl-transactions">
<!-- pgdoc-cn_start sig_en=168b9264e23c07090b9e1a29f31a5165 sig_cn_org=None source=14.1 
    <title>Transaction Management</title>
________________________________________________________-->
    <title>事务管理</title>
<!-- pgdoc-cn_end sig_en=168b9264e23c07090b9e1a29f31a5165 -->

<!-- pgdoc-cn_start sig_en=dcf6b035e4dff982db3586b309f9cdcb sig_cn_org=None source=14.1 
    <para>
     In a procedure called from the top level or an anonymous code block
     (<command>DO</command> command) called from the top level it is possible
     to control transactions.  To commit the current transaction, call the
     <literal>commit</literal> command.  To roll back the current transaction,
     call the <literal>rollback</literal> command.  (Note that it is not
     possible to run the SQL commands <command>COMMIT</command> or
     <command>ROLLBACK</command> via <function>spi_exec</function> or similar.
     It has to be done using these functions.)  After a transaction is ended,
     a new transaction is automatically started, so there is no separate
     command for that.
    </para>
________________________________________________________-->
    <para>
     在从顶层调用的过程中或者从顶层调用的匿名代码块（<command>DO</command>命令）中，可以控制事务。要提交当前的事务，可调用<literal>commit</literal>。要回滚当前事务，可调用<literal>rollback</literal>（注意不能通过<function>spi_exec</function>或类似的函数运行SQL命令<command>COMMIT</command>或者<command>ROLLBACK</command>。这类工作必须用这些函数完成）。在事务结束以后，一个新的事务会自动开始，因此没有独立的函数用来开始新事务。
    </para>
<!-- pgdoc-cn_end sig_en=dcf6b035e4dff982db3586b309f9cdcb -->

<!-- pgdoc-cn_start sig_en=2e518c4103a416a7e460662c4070a0e5 sig_cn_org=None source=14.1 
    <para>
     Here is an example:
<programlisting>
CREATE PROCEDURE transaction_test1()
LANGUAGE pltcl
AS $$
for {set i 0} {$i &lt; 10} {incr i} {
    spi_exec "INSERT INTO test1 (a) VALUES ($i)"
    if {$i % 2 == 0} {
        commit
    } else {
        rollback
    }
}
$$;

CALL transaction_test1();
</programlisting>
    </para>
________________________________________________________-->
    <para>
     这里是一个例子：
<programlisting>
CREATE PROCEDURE transaction_test1()
LANGUAGE pltcl
AS $$
for {set i 0} {$i &lt; 10} {incr i} {
    spi_exec "INSERT INTO test1 (a) VALUES ($i)"
    if {$i % 2 == 0} {
        commit
    } else {
        rollback
    }
}
$$;

CALL transaction_test1();
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=2e518c4103a416a7e460662c4070a0e5 -->

<!-- pgdoc-cn_start sig_en=2fc9e515af7da4f1142e700398558a81 sig_cn_org=None source=14.1 
    <para>
     Transactions cannot be ended when an explicit subtransaction is active.
    </para>
________________________________________________________-->
    <para>
     当一个显式的子事务处于活跃状态时，事务不能被结束。
    </para>
<!-- pgdoc-cn_end sig_en=2fc9e515af7da4f1142e700398558a81 -->
   </sect1>

   <sect1 id="pltcl-config">
<!-- pgdoc-cn_start sig_en=4af3454d1419327beffeba7674645ff0 sig_cn_org=None source=14.1 
    <title>PL/Tcl Configuration</title>
________________________________________________________-->
    <title>PL/Tcl配置</title>
<!-- pgdoc-cn_end sig_en=4af3454d1419327beffeba7674645ff0 -->

<!-- pgdoc-cn_start sig_en=0f5426d90e1fb3f41e8fca36e139958a sig_cn_org=None source=14.1 
    <para>
     This section lists configuration parameters that
     affect <application>PL/Tcl</application>.
    </para>
________________________________________________________-->
    <para>
     这一节列举影响<application>PL/Tcl</application>的配置参数。
    </para>
<!-- pgdoc-cn_end sig_en=0f5426d90e1fb3f41e8fca36e139958a -->

    <variablelist>

     <varlistentry id="guc-pltcl-start-proc" xreflabel="pltcl.start_proc">
<!-- pgdoc-cn_start sig_en=da0d2fc10a99b1e16be23758fe9a2941 sig_cn_org=None source=14.1 
      <term>
       <varname>pltcl.start_proc</varname> (<type>string</type>)
       <indexterm>
        <primary><varname>pltcl.start_proc</varname> configuration parameter</primary>
       </indexterm>
      </term>
________________________________________________________-->
      <term>
       <varname>pltcl.start_proc</varname> (<type>string</type>)
       <indexterm>
        <primary><varname>pltcl.start_proc</varname> configuration parameter</primary>
       </indexterm>
      </term>
<!-- pgdoc-cn_end sig_en=da0d2fc10a99b1e16be23758fe9a2941 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=b76f76919bf5eb70552a6bc8e53c4402 sig_cn_org=None source=14.1 
       <para>
        This parameter, if set to a nonempty string, specifies the name
        (possibly schema-qualified) of a parameterless PL/Tcl function that
        is to be executed whenever a new Tcl interpreter is created for
        PL/Tcl.  Such a function can perform per-session initialization, such
        as loading additional Tcl code.  A new Tcl interpreter is created
        when a PL/Tcl function is first executed in a database session, or
        when an additional interpreter has to be created because a PL/Tcl
        function is called by a new SQL role.
       </para>
________________________________________________________-->
       <para>
        如果被设置为一个非空字符串，这个参数指定一个无参数PL/Tcl函数的名称（可能是方案限定的），只要为PL/Tcl创建一个新的Tcl解释器，就会执行这个函数。这样一个函数可以执行针对会话的初始化，例如载入额外的Tcl代码。当一个PL/Tcl在一个数据库会话中被第一次执行时，或者由于一个PL/Tcl函数被一个新的SQL角色调用而必须创建一个额外的解释器时，一个新的Tcl解释器会被创建。
       </para>
<!-- pgdoc-cn_end sig_en=b76f76919bf5eb70552a6bc8e53c4402 -->

<!-- pgdoc-cn_start sig_en=a46763a0dbae884daf630ff32cce94b3 sig_cn_org=None source=14.1 
       <para>
        The referenced function must be written in the <literal>pltcl</literal>
        language, and must not be marked <literal>SECURITY DEFINER</literal>.
        (These restrictions ensure that it runs in the interpreter it's
        supposed to initialize.)  The current user must have permission to
        call it, too.
       </para>
________________________________________________________-->
       <para>
        被引用的函数必须用<literal>pltcl</literal>语言编写，并且不能被标记为<literal>SECURITY DEFINER</literal>（这些限制确保它运行在它应该要初始化的解释器中）。当前用户也必须有权限调用它。
       </para>
<!-- pgdoc-cn_end sig_en=a46763a0dbae884daf630ff32cce94b3 -->

<!-- pgdoc-cn_start sig_en=f252ace5ec31e1125bd983686e000b27 sig_cn_org=None source=14.1 
       <para>
        If the function fails with an error it will abort the function call
        that caused the new interpreter to be created and propagate out to
        the calling query, causing the current transaction or subtransaction
        to be aborted.  Any actions already done within Tcl won't be undone;
        however, that interpreter won't be used again.  If the language is
        used again the initialization will be attempted again within a fresh
        Tcl interpreter.
       </para>
________________________________________________________-->
       <para>
        如果该函数带着一个错误失败，它将中止导致新解释器创建的函数并且把错误传播到调用查询，进而导致当前事务或子事务被中止。在Tcl中已完成的任何动作将不会被撤销，不过，那个解释器将不会被再次使用。如果该语言被再次使用，则初始化将在一个全新的Tcl解释器中被再次尝试。
       </para>
<!-- pgdoc-cn_end sig_en=f252ace5ec31e1125bd983686e000b27 -->

<!-- pgdoc-cn_start sig_en=6d63aba153ed5e821dfa90fda3a73562 sig_cn_org=None source=14.1 
       <para>
        Only superusers can change this setting.  Although this setting
        can be changed within a session, such changes will not affect Tcl
        interpreters that have already been created.
       </para>
________________________________________________________-->
       <para>
        只有超级用户能够更改这个设置。尽管这个设置能在会话中更改，但这种更改将不会影响已经被创建的Tcl解释器。
       </para>
<!-- pgdoc-cn_end sig_en=6d63aba153ed5e821dfa90fda3a73562 -->
      </listitem>
     </varlistentry>

     <varlistentry id="guc-pltclu-start-proc" xreflabel="pltclu.start_proc">
<!-- pgdoc-cn_start sig_en=c0578f5dcb1901a0e3a9f70b5c2cb2e6 sig_cn_org=None source=14.1 
      <term>
       <varname>pltclu.start_proc</varname> (<type>string</type>)
       <indexterm>
        <primary><varname>pltclu.start_proc</varname> configuration parameter</primary>
       </indexterm>
      </term>
________________________________________________________-->
      <term>
       <varname>pltclu.start_proc</varname> (<type>string</type>)
       <indexterm>
        <primary><varname>pltclu.start_proc</varname>配置参数</primary>
       </indexterm>
      </term>
<!-- pgdoc-cn_end sig_en=c0578f5dcb1901a0e3a9f70b5c2cb2e6 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=d8c7c6e3cda8e6d9b862164a71d51f8b sig_cn_org=None source=14.1 
       <para>
        This parameter is exactly like <varname>pltcl.start_proc</varname>,
        except that it applies to PL/TclU.  The referenced function must
        be written in the <literal>pltclu</literal> language.
       </para>
________________________________________________________-->
       <para>
        这个参数与<varname>pltcl.start_proc</varname>几乎一模一样，只不过它适用于PL/TclU。被引用的函数必须用<literal>pltclu</literal>语言编写。
       </para>
<!-- pgdoc-cn_end sig_en=d8c7c6e3cda8e6d9b862164a71d51f8b -->
      </listitem>
     </varlistentry>

    </variablelist>
   </sect1>

   <sect1 id="pltcl-procnames">
<!-- pgdoc-cn_start sig_en=c52b6eb7f8a11527455e4566ebf13a23 sig_cn_org=None source=14.1 
    <title>Tcl Procedure Names</title>
________________________________________________________-->
    <title>Tcl 过程名</title>
<!-- pgdoc-cn_end sig_en=c52b6eb7f8a11527455e4566ebf13a23 -->

<!-- pgdoc-cn_start sig_en=1553c5341f29f2ab3ebd6151128ecb14 sig_cn_org=None source=14.1 
    <para>
     In <productname>PostgreSQL</productname>, the same function name can be used for
     different function definitions as long as the number of arguments or their types
     differ. Tcl, however, requires all procedure names to be distinct.
     PL/Tcl deals with this by making the internal Tcl procedure names contain
     the object
     ID of the function from the system table <structname>pg_proc</structname> as part of their name. Thus,
     <productname>PostgreSQL</productname> functions with the same name
     and different argument types will be different Tcl procedures, too.  This
     is not normally a concern for a PL/Tcl programmer, but it might be visible
     when debugging.
    </para>
________________________________________________________-->
    <para>
     在<productname>PostgreSQL</productname>，同一个函数名可以被用于不同的函数定义，只要它们的参数个数或者类型不同。不过，Tcl 要求所有过程名必须能区分。PL/Tcl 通过让内部 Tcl 过程名称包含该函数在系统表<structname>pg_proc</structname>中的对象 ID 作为名称的一部分来解决这样的限制。因此，具有相同名称和不同参数类型的<productname>PostgreSQL</productname>函数也将是不同的 Tcl 过程。这对 PL/Tcl 程序员来说通常不需要关心，但是在调试时可见。
    </para>
<!-- pgdoc-cn_end sig_en=1553c5341f29f2ab3ebd6151128ecb14 -->

   </sect1>
 </chapter>
