<!-- doc/src/sgml/xfunc.sgml -->

 <sect1 id="xfunc">
<!-- pgdoc-cn_start sig_en=789d70c9a393c67a078e0fc6925f1938 sig_cn_org=None source=14.1 
  <title>User-Defined Functions</title>
________________________________________________________-->
  <title>用户定义的函数</title>
<!-- pgdoc-cn_end sig_en=789d70c9a393c67a078e0fc6925f1938 -->

<!-- pgdoc-cn_start sig_en=c00fa08c21edc7fc52dc70da72145dff sig_cn_org=None source=14.1 
  <indexterm zone="xfunc">
   <primary>function</primary>
   <secondary>user-defined</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="xfunc">
   <primary>function</primary>
   <secondary>user-defined</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=c00fa08c21edc7fc52dc70da72145dff -->

<!-- pgdoc-cn_start sig_en=7b0568ed507978faf826d8fd885744c2 sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> provides four kinds of
   functions:

   <itemizedlist>
    <listitem>
     <para>
      query language functions (functions written in
      <acronym>SQL</acronym>) (<xref linkend="xfunc-sql"/>)
     </para>
    </listitem>
    <listitem>
     <para>
      procedural language functions (functions written in, for
      example, <application>PL/pgSQL</application> or <application>PL/Tcl</application>)
      (<xref linkend="xfunc-pl"/>)
     </para>
    </listitem>
    <listitem>
     <para>
      internal functions (<xref linkend="xfunc-internal"/>)
     </para>
    </listitem>
    <listitem>
     <para>
      C-language functions (<xref linkend="xfunc-c"/>)
     </para>
    </listitem>
   </itemizedlist>
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>提供四种函数：

   <itemizedlist>
    <listitem>
     <para>
      查询语言函数（用<acronym>SQL</acronym>编写的函数）（<xref linkend="xfunc-sql"/>）
     </para>
    </listitem>
    <listitem>
     <para>
      过程语言函数（例如，用<application>PL/pgSQL</application>或<application>PL/Tcl</application>编写的函数）（<xref linkend="xfunc-pl"/>）
     </para>
    </listitem>
    <listitem>
     <para>
      内部函数（<xref linkend="xfunc-internal"/>）
     </para>
    </listitem>
    <listitem>
     <para>
      C 语言函数（<xref linkend="xfunc-c"/>）
     </para>
    </listitem>
   </itemizedlist>
  </para>
<!-- pgdoc-cn_end sig_en=7b0568ed507978faf826d8fd885744c2 -->

<!-- pgdoc-cn_start sig_en=94152856fac459c2828809069bd81f00 sig_cn_org=None source=14.1 
  <para>
   Every kind
   of  function  can take base types, composite types, or
   combinations of these as arguments (parameters). In addition,
   every kind of function can return a base type or
   a composite type.  Functions can also be defined to return
   sets of base or composite values.
  </para>
________________________________________________________-->
  <para>
   每一类函数可以采用基本类型、组合类型或者它们的组合作为参数。此外，每一类函数可以返回一个基本类型或一个组合类型。函数也能被定义成返回基本类型或组合类型值的集合。
  </para>
<!-- pgdoc-cn_end sig_en=94152856fac459c2828809069bd81f00 -->

<!-- pgdoc-cn_start sig_en=b35bc033fe91f3f080c01dc5836d7934 sig_cn_org=None source=14.1 
  <para>
   Many kinds of functions can take or return certain pseudo-types
   (such as polymorphic types), but the available facilities vary.
   Consult the description of each kind of function for more details.
  </para>
________________________________________________________-->
  <para>
   很多类函数可以接受或者返回特定的伪类型（例如，多态类型），但是可用的功能会变化。详情可以参考每一种函数的描述。
  </para>
<!-- pgdoc-cn_end sig_en=b35bc033fe91f3f080c01dc5836d7934 -->

<!-- pgdoc-cn_start sig_en=41fe0ecc0582bc380e8409812f30afef sig_cn_org=None source=14.1 
  <para>
   It's easiest to define <acronym>SQL</acronym>
   functions, so we'll start by discussing those.
   Most of the concepts presented for <acronym>SQL</acronym> functions
   will carry over to the other types of functions.
  </para>
________________________________________________________-->
  <para>
   定义<acronym>SQL</acronym>函数最容易，因此我们将从讨论<acronym>SQL</acronym>函数开始。大部分<acronym>SQL</acronym>函数的概念也能用到其他类型的函数上。
  </para>
<!-- pgdoc-cn_end sig_en=41fe0ecc0582bc380e8409812f30afef -->

<!-- pgdoc-cn_start sig_en=307ce6e2bdf3cee951ba8329beac7ee3 sig_cn_org=None source=14.1 
  <para>
   Throughout this chapter, it can be useful to look at the reference
   page of the <link linkend="sql-createfunction"><command>CREATE
   FUNCTION</command></link> command to
   understand the examples better.  Some examples from this chapter
   can be found in <filename>funcs.sql</filename> and
   <filename>funcs.c</filename> in the <filename>src/tutorial</filename>
   directory in the <productname>PostgreSQL</productname> source
   distribution.
  </para>
________________________________________________________-->
  <para>
   在这一章中，查看<link linkend="sql-createfunction"><command>CREATE FUNCTION</command></link>命令的参考页有助于更好地理解例子。
   这章中的一些例子可以在<productname>PostgreSQL</productname>源代码发布的<filename>src/tutorial</filename>目录中的<filename>funcs.sql</filename>和<filename>funcs.c</filename>中找到。
  </para>
<!-- pgdoc-cn_end sig_en=307ce6e2bdf3cee951ba8329beac7ee3 -->
  </sect1>

  <sect1 id="xproc">
<!-- pgdoc-cn_start sig_en=51b8ce16f87d140a2e0bbfe06b806fba sig_cn_org=None source=14.1 
   <title>User-Defined Procedures</title>
________________________________________________________-->
   <title>用户定义的过程</title>
<!-- pgdoc-cn_end sig_en=51b8ce16f87d140a2e0bbfe06b806fba -->

<!-- pgdoc-cn_start sig_en=ef2d6622f574c983028268b58cf059a2 sig_cn_org=None source=14.1 
  <indexterm zone="xproc">
   <primary>procedure</primary>
   <secondary>user-defined</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="xproc">
   <primary>procedure</primary>
   <secondary>user-defined</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=ef2d6622f574c983028268b58cf059a2 -->

<!-- pgdoc-cn_start sig_en=723327cc63fa33f83f2a0eb2ff32e1ec sig_cn_org=None source=14.1 
   <para>
    A procedure is a database object similar to a function.
    The key differences are:

    <itemizedlist>
     <listitem>
      <para>
       Procedures are defined with
       the <link linkend="sql-createprocedure"><command>CREATE
       PROCEDURE</command></link> command, not <command>CREATE
       FUNCTION</command>.
      </para>
     </listitem>
     <listitem>
      <para>
       Procedures do not return a function value; hence <command>CREATE
       PROCEDURE</command> lacks a <literal>RETURNS</literal> clause.
       However, procedures can instead return data to their callers via
       output parameters.
      </para>
     </listitem>
     <listitem>
      <para>
       While a function is called as part of a query or DML command, a
       procedure is called in isolation using
       the <link linkend="sql-call"><command>CALL</command></link> command.
      </para>
     </listitem>
     <listitem>
      <para>
       A procedure can commit or roll back transactions during its
       execution (then automatically beginning a new transaction), so long
       as the invoking <command>CALL</command> command is not part of an
       explicit transaction block.  A function cannot do that.
      </para>
     </listitem>
     <listitem>
      <para>
       Certain function attributes, such as strictness, don't apply to
       procedures.  Those attributes control how the function is
       used in a query, which isn't relevant to procedures.
      </para>
     </listitem>
    </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    过程是一个类似于函数的数据库对象。
	关键差异是：

    <itemizedlist>
     <listitem>
      <para>
       过程是由 <link linkend="sql-createprocedure"><command>CREATE PROCEDURE</command></link> 命令定义，而不是 <command>CREATE FUNCTION</command>。
      </para>
     </listitem>
     <listitem>
      <para>
       过程不返回函数值；因此<command>CREATE PROCEDURE</command> 缺少 <literal>RETURNS</literal> 子句。
       然而，过程可以通过输出参数返回数据到它们的调用器。
      </para>
     </listitem>
     <listitem>
      <para>
       当函数可以作为查询或DML命令的一部分调用时，过程用<link linkend="sql-call"><command>CALL</command></link>命令孤立的调用。
      </para>
     </listitem>
     <listitem>
      <para>
       在执行期间过程可以提交或回滚事务(而后自动开始一个新事物)，只要调用<command>CALL</command>命令不是显式事务块的一部分。函数做不了这个。
      </para>
     </listitem>
     <listitem>
      <para>
       某些函数属性，例如严格性，没有应用于过程。
       这些属性控制如何在查询中使用函数，与过程不相关。
      </para>
     </listitem>
    </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=723327cc63fa33f83f2a0eb2ff32e1ec -->

<!-- pgdoc-cn_start sig_en=2ba138955296c63c964c264e5297068a sig_cn_org=None source=14.1 
   <para>
    The explanations in the following sections about how to define
    user-defined functions apply to procedures as well, except for the
    points made above.
   </para>
________________________________________________________-->
   <para>
    后面章节中关于如何定义用户定义的函数的解释同样适用于过程，除了上面指出的那些点。
   </para>
<!-- pgdoc-cn_end sig_en=2ba138955296c63c964c264e5297068a -->

<!-- pgdoc-cn_start sig_en=d90525c25c74bd34abe392d77bf3a5f8 sig_cn_org=None source=14.1 
   <para>
    Collectively, functions and procedures are also known
    as <firstterm>routines</firstterm><indexterm><primary>routine</primary></indexterm>.
    There are commands such as <link linkend="sql-alterroutine"><command>ALTER ROUTINE</command></link>
    and <link linkend="sql-droproutine"><command>DROP ROUTINE</command></link> that can operate on functions and
    procedures without having to know which kind it is.  Note, however, that
    there is no <literal>CREATE ROUTINE</literal> command.
   </para>
________________________________________________________-->
   <para>
    函数和过程一起构成了<firstterm>例程</firstterm><indexterm><primary>routine</primary></indexterm>。
    有<link linkend="sql-alterroutine"><command>ALTER ROUTINE</command></link> 和 <link linkend="sql-droproutine"><command>DROP ROUTINE</command></link>这样的命令可以操作函数和过程而不需要知道它们是哪一种。
    不过，要注意没有<literal>CREATE ROUTINE</literal>命令。
   </para>
<!-- pgdoc-cn_end sig_en=d90525c25c74bd34abe392d77bf3a5f8 -->
  </sect1>

  <sect1 id="xfunc-sql">
<!-- pgdoc-cn_start sig_en=76ccbd723ad7b308346a93d86fd37d11 sig_cn_org=None source=14.1 
   <title>Query Language (<acronym>SQL</acronym>) Functions</title>
________________________________________________________-->
   <title>查询语言（<acronym>SQL</acronym>）函数</title>
<!-- pgdoc-cn_end sig_en=76ccbd723ad7b308346a93d86fd37d11 -->

<!-- pgdoc-cn_start sig_en=e89ef723babab9690afe386c65d28b86 sig_cn_org=None source=14.1 
   <indexterm zone="xfunc-sql">
    <primary>function</primary>
    <secondary>user-defined</secondary>
    <tertiary>in SQL</tertiary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="xfunc-sql">
    <primary>函数</primary>
    <secondary>用户定义的</secondary>
    <tertiary>in SQL</tertiary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=e89ef723babab9690afe386c65d28b86 -->

<!-- pgdoc-cn_start sig_en=aae0a501546d81faf6280f4ae7f50018 sig_cn_org=None source=14.1 
   <para>
    SQL functions execute an arbitrary list of SQL statements, returning
    the result of the last query in the list.
    In the simple (non-set)
    case, the first row of the last query's result will be returned.
    (Bear in mind that <quote>the first row</quote> of a multirow
    result is not well-defined unless you use <literal>ORDER BY</literal>.)
    If the last query happens
    to return no rows at all, the null value will be returned.
   </para>
________________________________________________________-->
   <para>
    SQL 函数执行一个由任意 SQL 语句构成的列表，返回列表中最后一个查询的结果。在简单（非集合）的情况中，最后一个查询的结果的第一行将被返回（记住一个多行结果的<quote>第一行</quote>不是良定义的，除非你使用<literal>ORDER BY</literal>）。如果最后一个查询正好根本不返回行，将会返回空值。
   </para>
<!-- pgdoc-cn_end sig_en=aae0a501546d81faf6280f4ae7f50018 -->

<!-- pgdoc-cn_start sig_en=0ed62b282303c4ebdcaf415977908325 sig_cn_org=None source=14.1 
   <para>
    Alternatively, an SQL function can be declared to return a set (that is,
    multiple rows) by specifying the function's return type as <literal>SETOF
    <replaceable>sometype</replaceable></literal>, or equivalently by declaring it as
    <literal>RETURNS TABLE(<replaceable>columns</replaceable>)</literal>.  In this case
    all rows of the last query's result are returned.  Further details appear
    below.
   </para>
________________________________________________________-->
   <para>
    或者，一个 SQL 函数可以通过指定函数的返回类型为<literal>SETOF <replaceable>sometype</replaceable></literal>被声明为返回一个集合（也就是多个行），或者等效地声明它为<literal>RETURNS TABLE(<replaceable>columns</replaceable>)</literal>。在这种情况下，最后一个查询的结果的所有行会被返回。下文将给出进一步的细节。
   </para>
<!-- pgdoc-cn_end sig_en=0ed62b282303c4ebdcaf415977908325 -->

<!-- pgdoc-cn_start sig_en=86daabc610de2d6fdcbf4711c4f2ac6f sig_cn_org=None source=14.1 
   <para>
    The body of an SQL function must be a list of SQL
    statements separated by semicolons.  A semicolon after the last
    statement is optional.  Unless the function is declared to return
    <type>void</type>, the last statement must be a <command>SELECT</command>,
    or an <command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command>
    that has a <literal>RETURNING</literal> clause.
   </para>
________________________________________________________-->
   <para>
    一个 SQL 函数的主体必须是一个由分号分隔的 SQL 语句的列表。最后一个语句之后的分号是可选的。除非函数被声明为返回<type>void</type>，最后一个语句必须是一个<command>SELECT</command>或者一个带有<literal>RETURNING</literal>子句的<command>INSERT</command>、<command>UPDATE</command>或者<command>DELETE</command>。
   </para>
<!-- pgdoc-cn_end sig_en=86daabc610de2d6fdcbf4711c4f2ac6f -->

<!-- pgdoc-cn_start sig_en=a451f4ecca7438bae01a21b2ef1a3c4e sig_cn_org=472d27ff94f55c82cda85ca5fcd52e51 source=15.7 
    <para>
     Any collection of commands in the  <acronym>SQL</acronym>
     language can be packaged together and defined as a function.
     Besides <command>SELECT</command> queries, the commands can include data
     modification queries (<command>INSERT</command>,
     <command>UPDATE</command>, <command>DELETE</command>, and
     <command>MERGE</command>), as well as
     other SQL commands. (You cannot use transaction control commands, e.g.,
     <command>COMMIT</command>, <command>SAVEPOINT</command>, and some utility
     commands, e.g.,  <literal>VACUUM</literal>, in <acronym>SQL</acronym> functions.)
     However, the final command
     must be a <command>SELECT</command> or have a <literal>RETURNING</literal>
     clause that returns whatever is
     specified as the function's return type.  Alternatively, if you
     want to define an SQL function that performs actions but has no
     useful value to return, you can define it as returning <type>void</type>.
     For example, this function removes rows with negative salaries from
     the <literal>emp</literal> table:

<screen>
CREATE FUNCTION clean_emp() RETURNS void AS '
    DELETE FROM emp
        WHERE salary &lt; 0;
' LANGUAGE SQL;

SELECT clean_emp();

 clean_emp
-&minus;-&minus;-&minus;-&minus;-&minus;-

(1 row)
</screen>
    </para>
________________________________________________________-->
    <para>
     任何在<acronym>SQL</acronym>语言中的命令集合都可以打包在一起并定义为一个函数。
     除了<command>SELECT</command>查询外，这些命令可以包括数据修改查询(<command>INSERT</command>、
     <command>UPDATE</command>、<command>DELETE</command>和<command>MERGE</command>)，以及
     其他SQL命令。(在<acronym>SQL</acronym>函数中不能使用事务控制命令，例如，
     <command>COMMIT</command>、<command>SAVEPOINT</command>，以及一些实用命令，例如，
     <literal>VACUUM</literal>。)
     然而，最终命令必须是一个<command>SELECT</command>或具有返回函数返回类型的<literal>RETURNING</literal>子句。
     或者，如果您想定义一个执行操作但没有有用值返回的SQL函数，可以将其定义为返回<type>void</type>。
     例如，此函数从<literal>emp</literal>表中删除负薪水的行:

<screen>
CREATE FUNCTION clean_emp() RETURNS void AS '
    DELETE FROM emp
        WHERE salary &lt; 0;
' LANGUAGE SQL;

SELECT clean_emp();

 clean_emp
-----------

(1 row)
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=a451f4ecca7438bae01a21b2ef1a3c4e -->

<!-- pgdoc-cn_start sig_en=788a6e0fecc42da8694533da6c544aa1 sig_cn_org=None source=14.1 
    <para>
     You can also write this as a procedure, thus avoiding the issue of the
     return type.  For example:
<screen>
CREATE PROCEDURE clean_emp() AS '
    DELETE FROM emp
        WHERE salary &lt; 0;
' LANGUAGE SQL;

CALL clean_emp();
</screen>
     In simple cases like this, the difference between a function returning
     <type>void</type> and a procedure is mostly stylistic.  However,
     procedures offer additional functionality such as transaction control
     that is not available in functions.  Also, procedures are SQL standard
     whereas returning <type>void</type> is a PostgreSQL extension.
    </para>
________________________________________________________-->
    <para>
     你也可以把这个写为一个过程，那样避免返回类型的问题。
     例如：
<screen>
CREATE PROCEDURE clean_emp() AS '
    DELETE FROM emp
        WHERE salary &lt; 0;
' LANGUAGE SQL;

CALL clean_emp();
</screen>
     在像这样的简单情况中，函数与过程返回<type>void</type>的差异主要是风格上面的。
     然而，过程提供函数中不具备的附加的功能性例如事务控制。
     而且，过程是SQL标准，然而返回<type>void</type>是PostgreSQL扩展。
    </para>
<!-- pgdoc-cn_end sig_en=788a6e0fecc42da8694533da6c544aa1 -->

    <note>
<!-- pgdoc-cn_start sig_en=8a95babc3ff3dd9b75c6e00381ca2525 sig_cn_org=None source=14.1 
     <para>
      The entire body of an SQL function is parsed before any of it is
      executed.  While an SQL function can contain commands that alter
      the system catalogs (e.g., <command>CREATE TABLE</command>), the effects
      of such commands will not be visible during parse analysis of
      later commands in the function.  Thus, for example,
      <literal>CREATE TABLE foo (...); INSERT INTO foo VALUES(...);</literal>
      will not work as desired if packaged up into a single SQL function,
      since <structname>foo</structname> won't exist yet when the <command>INSERT</command>
      command is parsed.  It's recommended to use <application>PL/pgSQL</application>
      instead of an SQL function in this type of situation.
     </para>
________________________________________________________-->
     <para>
      在被执行前，SQL 函数的整个主体都要被解析。虽然 SQL 函数可以包含修改系统目录的命令（如<command>CREATE TABLE</command>），但这类命令的效果对于该函数中后续命令的解析分析不可见。例如，如果把<literal>CREATE TABLE foo (...); INSERT INTO foo VALUES(...);</literal>打包到一个 SQL 函数中是得不到预期效果的，因为在解析<command>INSERT</command>命令时<structname>foo</structname>还不存在。在这类情况下，推荐使用<application>PL/pgSQL</application>而不是 SQL 函数。
     </para>
<!-- pgdoc-cn_end sig_en=8a95babc3ff3dd9b75c6e00381ca2525 -->
   </note>

<!-- pgdoc-cn_start sig_en=275b9d1a76e55504fde1564ece61647b sig_cn_org=None source=14.1 
   <para>
    The syntax of the <command>CREATE FUNCTION</command> command requires
    the function body to be written as a string constant.  It is usually
    most convenient to use dollar quoting (see <xref
    linkend="sql-syntax-dollar-quoting"/>) for the string constant.
    If you choose to use regular single-quoted string constant syntax,
    you must double single quote marks (<literal>'</literal>) and backslashes
    (<literal>\</literal>) (assuming escape string syntax) in the body of
    the function (see <xref linkend="sql-syntax-strings"/>).
   </para>
________________________________________________________-->
   <para>
    <command>CREATE FUNCTION</command>命令的语法要求函数体被写作一个字符串常量。使用用于字符串常量的美元引用通常最方便（见<xref linkend="sql-syntax-dollar-quoting"/>）。你过你选择使用常规的单引号引用的字符串常量语法，你必须在函数体中双写单引号（<literal>'</literal>）和反斜线（<literal>\</literal>）（假定转义字符串语法）（见<xref linkend="sql-syntax-strings"/>）。
   </para>
<!-- pgdoc-cn_end sig_en=275b9d1a76e55504fde1564ece61647b -->

   <sect2 id="xfunc-sql-function-arguments">
<!-- pgdoc-cn_start sig_en=604e6265a872570d6917d717bf8ed486 sig_cn_org=None source=14.1 
    <title>Arguments for <acronym>SQL</acronym> Functions</title>
________________________________________________________-->
    <title><acronym>SQL</acronym>函数的参数</title>
<!-- pgdoc-cn_end sig_en=604e6265a872570d6917d717bf8ed486 -->

<!-- pgdoc-cn_start sig_en=8d7c2a0a58ec4c8c1ac5dd2b8697535b sig_cn_org=None source=14.1 
   <indexterm>
    <primary>function</primary>
    <secondary>named argument</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>函数</primary>
    <secondary>命名参数</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=8d7c2a0a58ec4c8c1ac5dd2b8697535b -->

<!-- pgdoc-cn_start sig_en=7c1979b830b947a7b5f562ab868ac5f2 sig_cn_org=None source=14.1 
    <para>
     Arguments of an SQL function can be referenced in the function
     body using either names or numbers.  Examples of both methods appear
     below.
    </para>
________________________________________________________-->
    <para>
     一个 SQL 函数的参数可以在函数体中用名称或编号引用。下面会有两种方法的例子。
    </para>
<!-- pgdoc-cn_end sig_en=7c1979b830b947a7b5f562ab868ac5f2 -->

<!-- pgdoc-cn_start sig_en=dfd20f095bac6f18a65c01c16eacd224 sig_cn_org=None source=14.1 
    <para>
     To use a name, declare the function argument as having a name, and
     then just write that name in the function body.  If the argument name
     is the same as any column name in the current SQL command within the
     function, the column name will take precedence.  To override this,
     qualify the argument name with the name of the function itself, that is
     <literal><replaceable>function_name</replaceable>.<replaceable>argument_name</replaceable></literal>.
     (If this would conflict with a qualified column name, again the column
     name wins.  You can avoid the ambiguity by choosing a different alias for
     the table within the SQL command.)
    </para>
________________________________________________________-->
    <para>
     要使用一个名称，将函数参数声明为带有一个名称，然后在函数体中只写该名称。如果参数名称与函数内当前 SQL 命令中的任意列名相同，列名将优先。如果不想这样，可以用函数本身的名称来限定参数名，也就是<literal><replaceable>function_name</replaceable>.<replaceable>argument_name</replaceable></literal>（如果这会与一个被限定的列名冲突，照例还是列名赢得优先。你可以通过为 SQL 命令中的表选择一个不同的别名来避免这种混淆）。
    </para>
<!-- pgdoc-cn_end sig_en=dfd20f095bac6f18a65c01c16eacd224 -->

<!-- pgdoc-cn_start sig_en=4b63df87641251e91f5c862dc2faf84d sig_cn_org=None source=14.1 
    <para>
     In the older numeric approach, arguments are referenced using the syntax
     <literal>$<replaceable>n</replaceable></literal>: <literal>$1</literal> refers to the first input
     argument, <literal>$2</literal> to the second, and so on.  This will work
     whether or not the particular argument was declared with a name.
    </para>
________________________________________________________-->
    <para>
     在更旧的数字方法中，参数可以用语法<literal>$<replaceable>n</replaceable></literal>引用：<literal>$1</literal>指的是第一个输入参数，<literal>$2</literal>指的是第二个，以此类推。不管特定的参数是否使用名称声明，这种方法都有效。
    </para>
<!-- pgdoc-cn_end sig_en=4b63df87641251e91f5c862dc2faf84d -->

<!-- pgdoc-cn_start sig_en=db4458fce2fde2c4f4a8beee8740222c sig_cn_org=None source=14.1 
    <para>
     If an argument is of a composite type, then the dot notation,
     e.g., <literal><replaceable>argname</replaceable>.<replaceable>fieldname</replaceable></literal> or
     <literal>$1.<replaceable>fieldname</replaceable></literal>, can be used to access attributes of the
     argument.  Again, you might need to qualify the argument's name with the
     function name to make the form with an argument name unambiguous.
    </para>
________________________________________________________-->
    <para>
     如果一个参数是一种组合类型，那么点号记法（如
     <literal><replaceable>argname</replaceable>.<replaceable>fieldname</replaceable></literal>
     或<literal>$1.<replaceable>fieldname</replaceable></literal>）也可以被用来
     访问该参数的属性。同样，你可能需要用函数的名称来限定参数的名称以避免歧义。
    </para>
<!-- pgdoc-cn_end sig_en=db4458fce2fde2c4f4a8beee8740222c -->

<!-- pgdoc-cn_start sig_en=972384cd8cbc82a6aea90bf90ffd4263 sig_cn_org=None source=14.1 
    <para>
     SQL function arguments can only be used as data values,
     not as identifiers.  Thus for example this is reasonable:
<programlisting>
INSERT INTO mytable VALUES ($1);
</programlisting>
but this will not work:
<programlisting>
INSERT INTO $1 VALUES (42);
</programlisting>
    </para>
________________________________________________________-->
    <para>
     SQL 函数参数只能被用做数据值而不能作为标识符。例如这是合理的：
<programlisting>
INSERT INTO mytable VALUES ($1);
</programlisting>
但这样就不行：
<programlisting>
INSERT INTO $1 VALUES (42);
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=972384cd8cbc82a6aea90bf90ffd4263 -->

    <note>
<!-- pgdoc-cn_start sig_en=7b8eef539fc7e39fd3ec01e2dcf009c1 sig_cn_org=None source=14.1 
     <para>
      The ability to use names to reference SQL function arguments was added
      in <productname>PostgreSQL</productname> 9.2.  Functions to be used in
      older servers must use the <literal>$<replaceable>n</replaceable></literal> notation.
     </para>
________________________________________________________-->
     <para>
      使用名称来引用 SQL 函数参数的能力是在<productname>PostgreSQL</productname> 9.2 中加入的。要在老的服务器中使用的函数必须使用<literal>$<replaceable>n</replaceable></literal>记法。
     </para>
<!-- pgdoc-cn_end sig_en=7b8eef539fc7e39fd3ec01e2dcf009c1 -->
    </note>
   </sect2>

   <sect2 id="xfunc-sql-base-functions">
<!-- pgdoc-cn_start sig_en=1899c0b31b01f63b807149198d23a505 sig_cn_org=None source=14.1 
    <title><acronym>SQL</acronym> Functions on Base Types</title>
________________________________________________________-->
    <title>基本类型上的<acronym>SQL</acronym></title>
<!-- pgdoc-cn_end sig_en=1899c0b31b01f63b807149198d23a505 -->

<!-- pgdoc-cn_start sig_en=124037049b4767187aea8f93dbb93b6b sig_cn_org=None source=14.1 
    <para>
     The simplest possible <acronym>SQL</acronym> function has no arguments and
     simply returns a base type, such as <type>integer</type>:

<screen>
CREATE FUNCTION one() RETURNS integer AS $$
    SELECT 1 AS result;
$$ LANGUAGE SQL;

-&minus; Alternative syntax for string literal:
CREATE FUNCTION one() RETURNS integer AS '
    SELECT 1 AS result;
' LANGUAGE SQL;

SELECT one();

 one
-&minus;-&minus;-
   1
</screen>
    </para>
________________________________________________________-->
    <para>
     最简单的<acronym>SQL</acronym>函数没有参数并且简单地返回一个基本类型，例如<type>integer</type>：

<screen>
CREATE FUNCTION one() RETURNS integer AS $$
    SELECT 1 AS result;
$$ LANGUAGE SQL;

-- Alternative syntax for string literal:
CREATE FUNCTION one() RETURNS integer AS '
    SELECT 1 AS result;
' LANGUAGE SQL;

SELECT one();

 one
-----
   1
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=124037049b4767187aea8f93dbb93b6b -->

<!-- pgdoc-cn_start sig_en=8c43cb14245bd19876b6a313e019bb4e sig_cn_org=None source=14.1 
    <para>
     Notice that we defined a column alias within the function body for the result of the function
     (with  the  name <literal>result</literal>),  but this column alias is not visible
     outside the function.  Hence,  the  result  is labeled <literal>one</literal>
     instead of <literal>result</literal>.
    </para>
________________________________________________________-->
    <para>
     注意我们为该函数的结果在函数体内定义了一个列别名（名为<literal>result</literal>），但是这个列别名在函数以外是不可见的。因此，结果被标记为<literal>one</literal>而不是<literal>result</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=8c43cb14245bd19876b6a313e019bb4e -->

<!-- pgdoc-cn_start sig_en=4d6e32df59bd919d34b2cc03add7ee96 sig_cn_org=None source=14.1 
    <para>
     It is almost as easy to define <acronym>SQL</acronym> functions
     that take base types as arguments:

<screen>
CREATE FUNCTION add_em(x integer, y integer) RETURNS integer AS $$
    SELECT x + y;
$$ LANGUAGE SQL;

SELECT add_em(1, 2) AS answer;

 answer
-&minus;-&minus;-&minus;-&minus;
      3
</screen>
    </para>
________________________________________________________-->
    <para>
     定义用基本类型作为参数的<acronym>SQL</acronym>函数也很容易：

<screen>
CREATE FUNCTION add_em(x integer, y integer) RETURNS integer AS $$
    SELECT x + y;
$$ LANGUAGE SQL;

SELECT add_em(1, 2) AS answer;

 answer
--------
      3
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=4d6e32df59bd919d34b2cc03add7ee96 -->

<!-- pgdoc-cn_start sig_en=a727939929b84e512ba7776feefe890d sig_cn_org=None source=14.1 
    <para>
     Alternatively, we could dispense with names for the arguments and
     use numbers:

<screen>
CREATE FUNCTION add_em(integer, integer) RETURNS integer AS $$
    SELECT $1 + $2;
$$ LANGUAGE SQL;

SELECT add_em(1, 2) AS answer;

 answer
-&minus;-&minus;-&minus;-&minus;
      3
</screen>
    </para>
________________________________________________________-->
    <para>
     我们也能省掉参数的名称而使用数字：

<screen>
CREATE FUNCTION add_em(integer, integer) RETURNS integer AS $$
    SELECT $1 + $2;
$$ LANGUAGE SQL;

SELECT add_em(1, 2) AS answer;

 answer
--------
      3
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=a727939929b84e512ba7776feefe890d -->

<!-- pgdoc-cn_start sig_en=abf8cadffd483198d0f70920a8131604 sig_cn_org=None source=14.1 
    <para>
     Here is a more useful function, which might be used to debit a
     bank account:

<programlisting>
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno;
    SELECT 1;
$$ LANGUAGE SQL;
</programlisting>

     A user could execute this function to debit account 17 by $100.00 as
     follows:

<programlisting>
SELECT tf1(17, 100.0);
</programlisting>
    </para>
________________________________________________________-->
    <para>
     这里是一个更有用的函数，它可以被用来借记一个银行账号：

<programlisting>
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno;
    SELECT 1;
$$ LANGUAGE SQL;
</programlisting>

     一个用户可以这样执行这个函数来从账户 17 中借记 $100.00：

<programlisting>
SELECT tf1(17, 100.0);
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=abf8cadffd483198d0f70920a8131604 -->

<!-- pgdoc-cn_start sig_en=c2480214ef49c9745fe2526efffdae4c sig_cn_org=None source=14.1 
    <para>
     In this example, we chose the name <literal>accountno</literal> for the first
     argument, but this is the same as the name of a column in the
     <literal>bank</literal> table.  Within the <command>UPDATE</command> command,
     <literal>accountno</literal> refers to the column <literal>bank.accountno</literal>,
     so <literal>tf1.accountno</literal> must be used to refer to the argument.
     We could of course avoid this by using a different name for the argument.
    </para>
________________________________________________________-->
    <para>
     在这个例子中，我们为第一个参数选择了名称<literal>accountno</literal>，但是这和表<literal>bank</literal>中的一个列名相同。
     在<command>UPDATE</command>命令中，
     <literal>accountno</literal>引用列<literal>bank.accountno</literal>，因此
     <literal>tf1.accountno</literal>必须被用来引用该参数。
     我们当然可以通过为该参数使用一个不同的名称来避免这样的问题。
    </para>
<!-- pgdoc-cn_end sig_en=c2480214ef49c9745fe2526efffdae4c -->

<!-- pgdoc-cn_start sig_en=1971b9e04c626c1a87eeaf0da6ae68f3 sig_cn_org=None source=14.1 
    <para>
     In practice one would probably like a more useful result from the
     function than a constant 1, so a more likely definition
     is:

<programlisting>
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno;
    SELECT balance FROM bank WHERE accountno = tf1.accountno;
$$ LANGUAGE SQL;
</programlisting>

     which adjusts the balance and returns the new balance.
     The same thing could be done in one command using <literal>RETURNING</literal>:

<programlisting>
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno
    RETURNING balance;
$$ LANGUAGE SQL;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     实际上我们可能喜欢从该函数得到一个更有用的结果而不是一个常数 1，因此一个更可能的定义是：

<programlisting>
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno;
    SELECT balance FROM bank WHERE accountno = tf1.accountno;
$$ LANGUAGE SQL;
</programlisting>

     它会调整余额并且返回新的余额。
     同样的事情也可以用一个使用<literal>RETURNING</literal>的命令实现：

<programlisting>
CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno
    RETURNING balance;
$$ LANGUAGE SQL;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=1971b9e04c626c1a87eeaf0da6ae68f3 -->

<!-- pgdoc-cn_start sig_en=6e9f53d3fc0852e7bca2a2e0cbec92de sig_cn_org=9be2ea89cd3b56b18196a55f41649bc3 source=15.7 
    <para>
     If the final <literal>SELECT</literal> or <literal>RETURNING</literal>
     clause in an <acronym>SQL</acronym> function does not return exactly
     the function's declared result
     type, <productname>PostgreSQL</productname> will automatically cast
     the value to the required type, if that is possible with an implicit
     or assignment cast.  Otherwise, you must write an explicit cast.
     For example, suppose we wanted the
     previous <function>add_em</function> function to return
     type <type>float8</type> instead.  It's sufficient to write

<programlisting>
CREATE FUNCTION add_em(integer, integer) RETURNS float8 AS $$
    SELECT $1 + $2;
$$ LANGUAGE SQL;
</programlisting>

     since the <type>integer</type> sum can be implicitly cast
     to <type>float8</type>.
     (See <xref linkend="typeconv"/> or <xref linkend="sql-createcast"/>
     for more about casts.)
    </para>
________________________________________________________-->
    <para>
     如果在<literal>SELECT</literal>或<literal>RETURNING</literal>子句中，
     <acronym>SQL</acronym>函数的最终返回值类型与函数声明的结果类型不完全匹配，
     如果可以使用隐式或赋值转换，
     <productname>PostgreSQL</productname>将自动将该值转换为所需类型。
     否则，您必须编写显式转换。
     例如，假设我们希望前面的<function>add_em</function>函数返回<type>float8</type>类型。
     只需编写

<programlisting>
CREATE FUNCTION add_em(integer, integer) RETURNS float8 AS $$
    SELECT $1 + $2;
$$ LANGUAGE SQL;
</programlisting>

     因为<type>integer</type>的和可以隐式转换为<type>float8</type>。
     （有关转换的更多信息，请参见<xref linkend="typeconv"/>或<xref linkend="sql-createcast"/>。）
    </para>
<!-- pgdoc-cn_end sig_en=6e9f53d3fc0852e7bca2a2e0cbec92de -->
   </sect2>

   <sect2 id="xfunc-sql-composite-functions">
<!-- pgdoc-cn_start sig_en=efde8e1173a8006b5116c04b9eab0b41 sig_cn_org=None source=14.1 
    <title><acronym>SQL</acronym> Functions on Composite Types</title>
________________________________________________________-->
    <title>组合类型上的<acronym>SQL</acronym>函数</title>
<!-- pgdoc-cn_end sig_en=efde8e1173a8006b5116c04b9eab0b41 -->

<!-- pgdoc-cn_start sig_en=954b1d69c5f8459a7fe3435d849b62a9 sig_cn_org=None source=14.1 
    <para>
     When writing functions with arguments of composite types, we must not
     only specify which argument we want but also the desired attribute
     (field) of that argument.  For example, suppose that
     <type>emp</type> is a table containing employee data, and therefore
     also the name of the composite type of each row of the table.  Here
     is a function <function>double_salary</function> that computes what someone's
     salary would be if it were doubled:

<screen>
CREATE TABLE emp (
    name        text,
    salary      numeric,
    age         integer,
    cubicle     point
);

INSERT INTO emp VALUES ('Bill', 4200, 45, '(2,1)');

CREATE FUNCTION double_salary(emp) RETURNS numeric AS $$
    SELECT $1.salary * 2 AS salary;
$$ LANGUAGE SQL;

SELECT name, double_salary(emp.*) AS dream
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';

 name | dream
-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
 Bill |  8400
</screen>
    </para>
________________________________________________________-->
    <para>
     在编写使用组合类型参数的函数时，我们必须不仅指定我们想要哪些参数，还要指定参数的期望属性（域）。例如，假定
     <type>emp</type>是一个包含雇员数据的表，并且因此它也是该表每一行的组合类型的名称。
     这里是一个函数<function>double_salary</function>，它计算某个人的双倍薪水：

<screen>
CREATE TABLE emp (
    name        text,
    salary      numeric,
    age         integer,
    cubicle     point
);

INSERT INTO emp VALUES ('Bill', 4200, 45, '(2,1)');

CREATE FUNCTION double_salary(emp) RETURNS numeric AS $$
    SELECT $1.salary * 2 AS salary;
$$ LANGUAGE SQL;

SELECT name, double_salary(emp.*) AS dream
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';

 name | dream
------+-------
 Bill |  8400
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=954b1d69c5f8459a7fe3435d849b62a9 -->

<!-- pgdoc-cn_start sig_en=05641e5ee86259000ddcd4a860aa722c sig_cn_org=None source=14.1 
    <para>
     Notice the use of the syntax <literal>$1.salary</literal>
     to select one field of the argument row value.  Also notice
     how the calling <command>SELECT</command> command
     uses <replaceable>table_name</replaceable><literal>.*</literal> to select
     the entire current row of a table as a composite value.  The table
     row can alternatively be referenced using just the table name,
     like this:
<screen>
SELECT name, double_salary(emp) AS dream
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';
</screen>
     but this usage is deprecated since it's easy to get confused.
     (See <xref linkend="rowtypes-usage"/> for details about these
     two notations for the composite value of a table row.)
    </para>
________________________________________________________-->
    <para>
     注意语法<literal>$1.salary</literal>的使用是要选择参数行值的一个域。
     还要注意调用的<command>SELECT</command>命令是如何使用<replaceable>table_name</replaceable><literal>.*</literal>来选择一个表的整个当前行作为一个组合值的。该表行也可以只用表名来引用：
<screen>
SELECT name, double_salary(emp) AS dream
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';
</screen>
     但这种用法已被废弃因为它很容易让人搞混（关于表行的组合值的这两种记法的详细情况请见<xref linkend="rowtypes-usage"/>）。
    </para>
<!-- pgdoc-cn_end sig_en=05641e5ee86259000ddcd4a860aa722c -->

<!-- pgdoc-cn_start sig_en=6e146ddb8b91f888740fb20d0ba03e7f sig_cn_org=None source=14.1 
    <para>
     Sometimes it is handy to construct a composite argument value
     on-the-fly.  This can be done with the <literal>ROW</literal> construct.
     For example, we could adjust the data being passed to the function:
<screen>
SELECT name, double_salary(ROW(name, salary*1.1, age, cubicle)) AS dream
    FROM emp;
</screen>
    </para>
________________________________________________________-->
    <para>
     有时候实时构建一个组合参数很方便。这可以用<literal>ROW</literal>结构完成。
     例如，我们可以调整被传递给函数的数据：
<screen>
SELECT name, double_salary(ROW(name, salary*1.1, age, cubicle)) AS dream
    FROM emp;
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=6e146ddb8b91f888740fb20d0ba03e7f -->

<!-- pgdoc-cn_start sig_en=87f5b0dae6a6903406da9f13fd9ba3f2 sig_cn_org=None source=14.1 
    <para>
     It is also possible to build a function that returns a composite type.
     This is an example of a function
     that returns a single <type>emp</type> row:

<programlisting>
CREATE FUNCTION new_emp() RETURNS emp AS $$
    SELECT text 'None' AS name,
        1000.0 AS salary,
        25 AS age,
        point '(2,2)' AS cubicle;
$$ LANGUAGE SQL;
</programlisting>

     In this example we have specified each of  the  attributes
     with  a  constant value, but any computation
     could have been substituted for these constants.
    </para>
________________________________________________________-->
    <para>
     也可以构建一个返回组合类型的函数。这是一个返回单一<type>emp</type>行的函数例子：

<programlisting>
CREATE FUNCTION new_emp() RETURNS emp AS $$
    SELECT text 'None' AS name,
        1000.0 AS salary,
        25 AS age,
        point '(2,2)' AS cubicle;
$$ LANGUAGE SQL;
</programlisting>

     在这个例子中，我们为每一个属性指定了一个常量值，但是可以用任何计算来替换这些常量。
    </para>
<!-- pgdoc-cn_end sig_en=87f5b0dae6a6903406da9f13fd9ba3f2 -->

<!-- pgdoc-cn_start sig_en=a625f9f0d2d61f7c150cbd39f2bfa7e8 sig_cn_org=None source=14.1 
    <para>
     Note two important things about defining the function:

     <itemizedlist>
      <listitem>
       <para>
        The select list order in the query must be exactly the same as
        that in which the columns appear in the composite type.
        (Naming the columns, as we did above,
        is irrelevant to the system.)
       </para>
      </listitem>
      <listitem>
       <para>
        We must ensure each expression's type can be cast to that of
        the corresponding column of the composite type.
        Otherwise we'll get errors like this:
<screen>
<computeroutput>
ERROR:  return type mismatch in function declared to return emp
DETAIL:  Final statement returns text instead of point at column 4.
</computeroutput>
</screen>
        As with the base-type case, the system will not insert explicit
        casts automatically, only implicit or assignment casts.
       </para>
      </listitem>
     </itemizedlist>
    </para>
________________________________________________________-->
    <para>
     有关定义函数有两件重要的事情：

     <itemizedlist>
      <listitem>
       <para>
        查询中的选择列表顺序必须与列在复合类型中出现的顺序完全相同。（正如我们上面所做的那样，命名列与系统无关。）
       </para>
      </listitem>
      <listitem>
       <para>
        我们必须确保每个表达式的类型都可以转换为复合类型的相应列的类型。 否则我们会得到这样的错误：
<screen>
<computeroutput>
ERROR:  return type mismatch in function declared to return emp
DETAIL:  Final statement returns text instead of point at column 4.
</computeroutput>
</screen>
        与基本类型的情况一样，系统不会自动插入显式转换，只会插入隐式或赋值转换。
       </para>
      </listitem>
     </itemizedlist>
    </para>
<!-- pgdoc-cn_end sig_en=a625f9f0d2d61f7c150cbd39f2bfa7e8 -->

<!-- pgdoc-cn_start sig_en=51b925dbcf172bdac15622120299c34b sig_cn_org=None source=14.1 
    <para>
     A different way to define the same function is:

<programlisting>
CREATE FUNCTION new_emp() RETURNS emp AS $$
    SELECT ROW('None', 1000.0, 25, '(2,2)')::emp;
$$ LANGUAGE SQL;
</programlisting>

     Here we wrote a <command>SELECT</command> that returns just a single
     column of the correct composite type.  This isn't really better
     in this situation, but it is a handy alternative in some cases
     &mdash; for example, if we need to compute the result by calling
     another function that returns the desired composite value.
     Another example is that if we are trying to write a function that
     returns a domain over composite, rather than a plain composite type,
     it is always necessary to write it as returning a single column,
     since there is no way to cause a coercion of the whole row result.
    </para>
________________________________________________________-->
    <para>
     定义同样的函数的一种不同的方法是：

<programlisting>
CREATE FUNCTION new_emp() RETURNS emp AS $$
    SELECT ROW('None', 1000.0, 25, '(2,2)')::emp;
$$ LANGUAGE SQL;
</programlisting>

     这里我们写了一个只返回正确组合类型的单一列的<command>SELECT</command>。
     在这种情况下这种写法实际并非更好，但是它在一些情况下比较方便
     &mdash; 例如，我们需要通过调用另一个返回所期望的组合值的函数来计算结果。
     另一个例子是，如果我们试图编写一个函数，它返回一个复合类型的域，而不是一个普通的复合类型，
     总是有必要把它写成返回单个列，因为没有办法导致整行结果。
    </para>
<!-- pgdoc-cn_end sig_en=51b925dbcf172bdac15622120299c34b -->

<!-- pgdoc-cn_start sig_en=1776ce0bc0daedca4b275243bf6beb76 sig_cn_org=None source=14.1 
    <para>
     We could call this function directly either by using it in
     a value expression:

<screen>
SELECT new_emp();

         new_emp
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 (None,1000.0,25,"(2,2)")
</screen>

     or by calling it as a table function:

<screen>
SELECT * FROM new_emp();

 name | salary | age | cubicle
-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-
 None | 1000.0 |  25 | (2,2)
</screen>

     The second way is described more fully in <xref
     linkend="xfunc-sql-table-functions"/>.
    </para>
________________________________________________________-->
    <para>
     我们可以直接调用这个函数或者在一个值表达式中使用它：

<screen>
SELECT new_emp();

         new_emp
--------------------------
 (None,1000.0,25,"(2,2)")
</screen>

     或者把它当做一个表函数调用：

<screen>
SELECT * FROM new_emp();

 name | salary | age | cubicle
------+--------+-----+---------
 None | 1000.0 |  25 | (2,2)
</screen>

     第二种方式在<xref linkend="xfunc-sql-table-functions"/>中有更完全的描述。
    </para>
<!-- pgdoc-cn_end sig_en=1776ce0bc0daedca4b275243bf6beb76 -->

<!-- pgdoc-cn_start sig_en=9996fd5488f43af5cfe657c4b822c2f5 sig_cn_org=None source=14.1 
    <para>
     When you use a function that returns a composite type,
     you might want only one field (attribute) from its result.
     You can do that with syntax like this:

<screen>
SELECT (new_emp()).name;

 name
-&minus;-&minus;-&minus;
 None
</screen>

     The extra parentheses are needed to keep the parser from getting
     confused.  If you try to do it without them, you get something like this:

<screen>
SELECT new_emp().name;
ERROR:  syntax error at or near "."
LINE 1: SELECT new_emp().name;
                        ^
</screen>
    </para>
________________________________________________________-->
    <para>
     当你使用一个返回组合类型的函数时，你可能只想要其结果中的一个域（属性）。
     你可以这样做：

<screen>
SELECT (new_emp()).name;

 name
------
 None
</screen>

     额外的圆括号是必须的，它用于避免解析器被搞混。如果你不写这些括号，会这样：

<screen>
SELECT new_emp().name;
ERROR:  syntax error at or near "."
LINE 1: SELECT new_emp().name;
                        ^
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=9996fd5488f43af5cfe657c4b822c2f5 -->

<!-- pgdoc-cn_start sig_en=b657ab81b306932b4e437ec55b02a2d6 sig_cn_org=None source=14.1 
    <para>
     Another option is to use functional notation for extracting an attribute:

<screen>
SELECT name(new_emp());

 name
-&minus;-&minus;-&minus;
 None
</screen>

     As explained in <xref linkend="rowtypes-usage"/>, the field notation and
     functional notation are equivalent.
    </para>
________________________________________________________-->
    <para>
     另一个选项是使用函数记号来抽取一个属性：

<screen>
SELECT name(new_emp());

 name
------
 None
</screen>

     如<xref linkend="rowtypes-usage"/>中所说，字段记法和函数记法是等效的。
    </para>
<!-- pgdoc-cn_end sig_en=b657ab81b306932b4e437ec55b02a2d6 -->

<!-- pgdoc-cn_start sig_en=59462b7826ba19b437de21f8cfd2cde1 sig_cn_org=None source=14.1 
    <para>
     Another way to use a function returning a composite type is to pass the
     result to another function that accepts the correct row type as input:

<screen>
CREATE FUNCTION getname(emp) RETURNS text AS $$
    SELECT $1.name;
$$ LANGUAGE SQL;

SELECT getname(new_emp());
 getname
-&minus;-&minus;-&minus;-&minus;-
 None
(1 row)
</screen>
    </para>
________________________________________________________-->
    <para>
     另一种使用返回组合类型的函数的方法是把结果传递给另一个接收正确行类型作为输入的函数：

<screen>
CREATE FUNCTION getname(emp) RETURNS text AS $$
    SELECT $1.name;
$$ LANGUAGE SQL;

SELECT getname(new_emp());
 getname
---------
 None
(1 row)
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=59462b7826ba19b437de21f8cfd2cde1 -->
   </sect2>

   <sect2 id="xfunc-output-parameters">
<!-- pgdoc-cn_start sig_en=474b9b9ec6131facef8a71547584b287 sig_cn_org=None source=14.1 
    <title><acronym>SQL</acronym> Functions with Output Parameters</title>
________________________________________________________-->
    <title>带有输出参数的<acronym>SQL</acronym>函数</title>
<!-- pgdoc-cn_end sig_en=474b9b9ec6131facef8a71547584b287 -->

<!-- pgdoc-cn_start sig_en=e67766ab4e008be50ba4034e95a56ed3 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>function</primary>
    <secondary>output parameter</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>函数</primary>
    <secondary>输出参数</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=e67766ab4e008be50ba4034e95a56ed3 -->

<!-- pgdoc-cn_start sig_en=af3c94f6c7f9dfb994e5886cf77932af sig_cn_org=None source=14.1 
    <para>
     An alternative way of describing a function's results is to define it
     with <firstterm>output parameters</firstterm>, as in this example:

<screen>
CREATE FUNCTION add_em (IN x int, IN y int, OUT sum int)
AS 'SELECT x + y'
LANGUAGE SQL;

SELECT add_em(3,7);
 add_em
-&minus;-&minus;-&minus;-&minus;
     10
(1 row)
</screen>

     This is not essentially different from the version of <literal>add_em</literal>
     shown in <xref linkend="xfunc-sql-base-functions"/>.  The real value of
     output parameters is that they provide a convenient way of defining
     functions that return several columns.  For example,

<screen>
CREATE FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int)
AS 'SELECT x + y, x * y'
LANGUAGE SQL;

 SELECT * FROM sum_n_product(11,42);
 sum | product
-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-
  53 |     462
(1 row)
</screen>

     What has essentially happened here is that we have created an anonymous
     composite type for the result of the function.  The above example has
     the same end result as

<screen>
CREATE TYPE sum_prod AS (sum int, product int);

CREATE FUNCTION sum_n_product (int, int) RETURNS sum_prod
AS 'SELECT $1 + $2, $1 * $2'
LANGUAGE SQL;
</screen>

     but not having to bother with the separate composite type definition
     is often handy.  Notice that the names attached to the output parameters
     are not just decoration, but determine the column names of the anonymous
     composite type.  (If you omit a name for an output parameter, the
     system will choose a name on its own.)
    </para>
________________________________________________________-->
    <para>
     一种描述一个函数的结果的替代方法是定义它的<firstterm>输出参数</firstterm>，例如：

<screen>
CREATE FUNCTION add_em (IN x int, IN y int, OUT sum int)
AS 'SELECT x + y'
LANGUAGE SQL;

SELECT add_em(3,7);
 add_em
--------
     10
(1 row)
</screen>

     这和<xref linkend="xfunc-sql-base-functions"/>中展示的<literal>add_em</literal>版本没有本质上的不同。输出参数的真正价值是它们提供了一种方便的方法来定义返回多个列的函数。例如，

<screen>
CREATE FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int)
AS 'SELECT x + y, x * y'
LANGUAGE SQL;

 SELECT * FROM sum_n_product(11,42);
 sum | product
-----+---------
  53 |     462
(1 row)
</screen>

     这里实际发生的是我们为该函数的结果创建了一个匿名的组合类型。上述例子具有与下面相同的最终结果

<screen>
CREATE TYPE sum_prod AS (sum int, product int);

CREATE FUNCTION sum_n_product (int, int) RETURNS sum_prod
AS 'SELECT $1 + $2, $1 * $2'
LANGUAGE SQL;
</screen>

     但是不必单独定义组合类型常常很方便。注意输出参数的名称并非只是装饰，而且决定了匿名组合类型的列名（如果你为一个输出参数忽略了名称，系统将自行选择一个名称）。
    </para>
<!-- pgdoc-cn_end sig_en=af3c94f6c7f9dfb994e5886cf77932af -->

<!-- pgdoc-cn_start sig_en=75de5040a14a5b1b5311472fe2d692f9 sig_cn_org=None source=14.1 
    <para>
     Notice that output parameters are not included in the calling argument
     list when invoking such a function from SQL.  This is because
     <productname>PostgreSQL</productname> considers only the input
     parameters to define the function's calling signature.  That means
     also that only the input parameters matter when referencing the function
     for purposes such as dropping it.  We could drop the above function
     with either of

<screen>
DROP FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int);
DROP FUNCTION sum_n_product (int, int);
</screen>
    </para>
________________________________________________________-->
    <para>
     在从 SQL 调用这样一个函数时，输出参数不会被包括在调用参数列表中。这是因为<productname>PostgreSQL</productname>只考虑输入参数来定义函数的调用签名。这也意味着在为诸如删除函数等目的引用该函数时只有输入参数有关系。我们可以用下面的命令之一删除上述函数

<screen>
DROP FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int);
DROP FUNCTION sum_n_product (int, int);
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=75de5040a14a5b1b5311472fe2d692f9 -->

<!-- pgdoc-cn_start sig_en=3ef498e0bdc76d993a14dfe801f35bae sig_cn_org=None source=14.1 
    <para>
     Parameters can be marked as <literal>IN</literal> (the default),
     <literal>OUT</literal>, <literal>INOUT</literal>, or <literal>VARIADIC</literal>.
     An <literal>INOUT</literal>
     parameter serves as both an input parameter (part of the calling
     argument list) and an output parameter (part of the result record type).
     <literal>VARIADIC</literal> parameters are input parameters, but are treated
     specially as described below.
    </para>
________________________________________________________-->
    <para>
     参数可以被标记为<literal>IN</literal>（默认）、<literal>OUT</literal>、<literal>INOUT</literal>或者<literal>VARIADIC</literal>。
     一个<literal>INOUT</literal>参数既作为一个输入参数（调用参数列表的一部分）又作为一个输出参数（结果记录类型的一部分）。
     <literal>VARIADIC</literal>参数是输入参数，但被按照下文所述特殊对待。
    </para>
<!-- pgdoc-cn_end sig_en=3ef498e0bdc76d993a14dfe801f35bae -->
   </sect2>

   <sect2 id="xfunc-output-parameters-proc">
<!-- pgdoc-cn_start sig_en=fc9897c434b4c7db58aad089c3993e78 sig_cn_org=None source=14.1 
    <title><acronym>SQL</acronym> Procedures with Output Parameters</title>
________________________________________________________-->
    <title><acronym>SQL</acronym> 有输出参数的过程</title>
<!-- pgdoc-cn_end sig_en=fc9897c434b4c7db58aad089c3993e78 -->

<!-- pgdoc-cn_start sig_en=225ce8d55f3ad21f623ac08e46344b51 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>procedures</primary>
     <secondary>output parameter</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>procedures</primary>
     <secondary>输出参数</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=225ce8d55f3ad21f623ac08e46344b51 -->

<!-- pgdoc-cn_start sig_en=a83df68244068c6e9f6e0cdd25c373d1 sig_cn_org=None source=14.1 
    <para>
     Output parameters are also supported in procedures, but they work a bit
     differently from functions.  In <command>CALL</command> commands,
     output parameters must be included in the argument list.
     For example, the bank account debiting routine from earlier could be
     written like this:
<programlisting>
CREATE PROCEDURE tp1 (accountno integer, debit numeric, OUT new_balance numeric) AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tp1.accountno
    RETURNING balance;
$$ LANGUAGE SQL;
</programlisting>
     To call this procedure, an argument matching the <literal>OUT</literal>
     parameter must be included.  It's customary to write
     <literal>NULL</literal>:
<programlisting>
CALL tp1(17, 100.0, NULL);
</programlisting>
     If you write something else, it must be an expression that is implicitly
     coercible to the declared type of the parameter, just as for input
     parameters.  Note however that such an expression will not be evaluated.
    </para>
________________________________________________________-->
    <para>
     过程也支持输出参数，但是它们工作方式与函数略有不同。
     在<command>CALL</command>命令中，输出参数必须包括在参数列表中。
     例如，前面的银行账户借记例程可以像这样写：
<programlisting>
CREATE PROCEDURE tp1 (accountno integer, debit numeric, OUT new_balance numeric) AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tp1.accountno
    RETURNING balance;
$$ LANGUAGE SQL;
</programlisting>
     要调用这个例程，必须包括匹配<literal>OUT</literal>参数的参数。
     习惯性的写<literal>NULL</literal>：
<programlisting>
CALL tp1(17, 100.0, NULL);
</programlisting>
     如果你要写一些其他的，它必须是隐式强制到参数的声明类型中的一个表达式，就像输入参数一样。
     注意，无论如何这样的表达式不会被评估。
    </para>
<!-- pgdoc-cn_end sig_en=a83df68244068c6e9f6e0cdd25c373d1 -->

<!-- pgdoc-cn_start sig_en=e1b4486526a3ae108656b80b0f217183 sig_cn_org=None source=14.1 
    <para>
     When calling a procedure from <application>PL/pgSQL</application>,
     instead of writing <literal>NULL</literal> you must write a variable
     that will receive the procedure's output.  See <xref
     linkend="plpgsql-statements-calling-procedure"/> for details.
    </para>
________________________________________________________-->
    <para>
     当从<application>PL/pgSQL</application>调用一个过程，而不是写<literal>NULL</literal>，你必须写一个将接收过程的输出的变量。
     详请参见<xref linkend="plpgsql-statements-calling-procedure"/>。
    </para>
<!-- pgdoc-cn_end sig_en=e1b4486526a3ae108656b80b0f217183 -->
   </sect2>

   <sect2 id="xfunc-sql-variadic-functions">
<!-- pgdoc-cn_start sig_en=c0af85d0a61236724dc1448819223050 sig_cn_org=None source=14.1 
    <title><acronym>SQL</acronym> Functions with Variable Numbers of Arguments</title>
________________________________________________________-->
    <title>带有可变数量参数的<acronym>SQL</acronym>函数</title>
<!-- pgdoc-cn_end sig_en=c0af85d0a61236724dc1448819223050 -->

<!-- pgdoc-cn_start sig_en=7d6e2bc73f560cf54bcad7f5d77bfec8 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>function</primary>
     <secondary>variadic</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>function</primary>
     <secondary>variadic</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=7d6e2bc73f560cf54bcad7f5d77bfec8 -->

<!-- pgdoc-cn_start sig_en=8b42e9c4d7602be788807037c5730212 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>variadic function</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>variadic function</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=8b42e9c4d7602be788807037c5730212 -->

<!-- pgdoc-cn_start sig_en=fdc8065aa208a86582748f1fcca3c1d9 sig_cn_org=38ef49486c60d23c1d4a34022e96b112 source=15.7 
    <para>
     <acronym>SQL</acronym> functions can be declared to accept
     variable numbers of arguments, so long as all the <quote>optional</quote>
     arguments are of the same data type.  The optional arguments will be
     passed to the function as an array.  The function is declared by
     marking the last parameter as <literal>VARIADIC</literal>; this parameter
     must be declared as being of an array type.  For example:

<screen>
CREATE FUNCTION mleast(VARIADIC arr numeric[]) RETURNS numeric AS $$
    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;

SELECT mleast(10, -1, 5, 4.4);
 mleast
-&minus;-&minus;-&minus;-&minus;
     -1
(1 row)
</screen>

     Effectively, all the actual arguments at or beyond the
     <literal>VARIADIC</literal> position are gathered up into a one-dimensional
     array, as if you had written

<screen>
SELECT mleast(ARRAY[10, -1, 5, 4.4]);    -&minus; doesn't work
</screen>

     You can't actually write that, though &mdash; or at least, it will
     not match this function definition.  A parameter marked
     <literal>VARIADIC</literal> matches one or more occurrences of its element
     type, not of its own type.
    </para>
________________________________________________________-->
    <para>
     <acronym>SQL</acronym>函数可以声明接受可变数量的参数，只要所有<quote>可选</quote>参数都是相同的数据类型。
     可选参数将作为数组传递给函数。函数通过将最后一个参数标记为<literal>VARIADIC</literal>来声明；
     此参数必须声明为数组类型。例如：

<screen>
CREATE FUNCTION mleast(VARIADIC arr numeric[]) RETURNS numeric AS $$
    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;

SELECT mleast(10, -1, 5, 4.4);
 mleast
--------
     -1
(1 row)
</screen>

     实际上，所有实际参数在<literal>VARIADIC</literal>位置或之后都被收集到一个一维数组中，就好像你写了

<screen>
SELECT mleast(ARRAY[10, -1, 5, 4.4]);    -- 不起作用
</screen>

     但实际上你不能这样写 &mdash; 或者至少，它不会匹配这个函数定义。标记为
     <literal>VARIADIC</literal>的参数匹配其元素类型的一个或多个出现，而不是其自身类型的一个或多个出现。
    </para>
<!-- pgdoc-cn_end sig_en=fdc8065aa208a86582748f1fcca3c1d9 -->

<!-- pgdoc-cn_start sig_en=a842f63ac3493c3f77dcb937b1332cc9 sig_cn_org=None source=14.1 
    <para>
     Sometimes it is useful to be able to pass an already-constructed array
     to a variadic function; this is particularly handy when one variadic
     function wants to pass on its array parameter to another one.  Also,
     this is the only secure way to call a variadic function found in a schema
     that permits untrusted users to create objects; see
     <xref linkend="typeconv-func"/>.  You can do this by
     specifying <literal>VARIADIC</literal> in the call:

<screen>
SELECT mleast(VARIADIC ARRAY[10, -1, 5, 4.4]);
</screen>

     This prevents expansion of the function's variadic parameter into its
     element type, thereby allowing the array argument value to match
     normally.  <literal>VARIADIC</literal> can only be attached to the last
     actual argument of a function call.
    </para>
________________________________________________________-->
    <para>
     有时候能够传递一个已经构造好的数组给 variadic 函数是有用的，特别是当
     一个 variadic 函数想要把它的数组参数传递给另一个函数时这会特别方便。此外，这是在一个允许不可信用户创建对象的方案中调用一个variadic函数的唯一安全的方式，见<xref linkend="typeconv-func"/>。你可以通过在调用中指定<literal>VARIADIC</literal>来做到这一点：

<screen>
SELECT mleast(VARIADIC ARRAY[10, -1, 5, 4.4]);
</screen>

     这会阻止该函数的 variadic 参数扩展成它的元素结构，从而允许数组参
     数值正常匹配。<literal>VARIADIC</literal>只能被附着在函数调用的最后一
     个实参上。
    </para>
<!-- pgdoc-cn_end sig_en=a842f63ac3493c3f77dcb937b1332cc9 -->

<!-- pgdoc-cn_start sig_en=c077fd3c46f4d7c2041c9d693625fabe sig_cn_org=None source=14.1 
    <para>
     Specifying <literal>VARIADIC</literal> in the call is also the only way to
     pass an empty array to a variadic function, for example:

<screen>
SELECT mleast(VARIADIC ARRAY[]::numeric[]);
</screen>

     Simply writing <literal>SELECT mleast()</literal> does not work because a
     variadic parameter must match at least one actual argument.
     (You could define a second function also named <literal>mleast</literal>,
     with no parameters, if you wanted to allow such calls.)
    </para>
________________________________________________________-->
    <para>
     在调用中指定<literal>VARIADIC</literal>也是将空数组传递给 variadic 函数
     的唯一方式，例如：

<screen>
SELECT mleast(VARIADIC ARRAY[]::numeric[]);
</screen>

     简单地写成<literal>SELECT mleast()</literal>是没有作用的，因为一个 variadic
     参数必须匹配至少一个实参（如果想允许这类调用，你可以定义第二个没有
     参数且也叫<literal>mleast</literal>的函数）。
    </para>
<!-- pgdoc-cn_end sig_en=c077fd3c46f4d7c2041c9d693625fabe -->

<!-- pgdoc-cn_start sig_en=0b45da8315e964b1ef56586d914373be sig_cn_org=None source=14.1 
    <para>
     The array element parameters generated from a variadic parameter are
     treated as not having any names of their own.  This means it is not
     possible to call a variadic function using named arguments (<xref
     linkend="sql-syntax-calling-funcs"/>), except when you specify
     <literal>VARIADIC</literal>.  For example, this will work:

<screen>
SELECT mleast(VARIADIC arr =&gt; ARRAY[10, -1, 5, 4.4]);
</screen>

     but not these:

<screen>
SELECT mleast(arr =&gt; 10);
SELECT mleast(arr =&gt; ARRAY[10, -1, 5, 4.4]);
</screen>
    </para>
________________________________________________________-->
    <para>
     从一个 variadic 参数产生的数组元素参数会被当做自己不具有名称。这
     意味着不能使用命名参数调用 variadic 函数（<xref
     linkend="sql-syntax-calling-funcs"/>），除非你指定了
     <literal>VARIADIC</literal>。例如下面的调用是可以工作的：

<screen>
SELECT mleast(VARIADIC arr =&gt; ARRAY[10, -1, 5, 4.4]);
</screen>

     但这些就不行：

<screen>
SELECT mleast(arr =&gt; 10);
SELECT mleast(arr =&gt; ARRAY[10, -1, 5, 4.4]);
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=0b45da8315e964b1ef56586d914373be -->
   </sect2>

   <sect2 id="xfunc-sql-parameter-defaults">
<!-- pgdoc-cn_start sig_en=4d6b8a1386db3bea2ee4702aa46573fd sig_cn_org=None source=14.1 
    <title><acronym>SQL</acronym> Functions with Default Values for Arguments</title>
________________________________________________________-->
    <title>带有参数默认值的<acronym>SQL</acronym>函数</title>
<!-- pgdoc-cn_end sig_en=4d6b8a1386db3bea2ee4702aa46573fd -->

<!-- pgdoc-cn_start sig_en=f5c1c5e4f37c2c7acafc013475786f06 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>function</primary>
     <secondary>default values for arguments</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>function</primary>
     <secondary>default values for arguments</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=f5c1c5e4f37c2c7acafc013475786f06 -->

<!-- pgdoc-cn_start sig_en=d987792e6c998fbf70e1863c70fd5f4e sig_cn_org=None source=14.1 
    <para>
     Functions can be declared with default values for some or all input
     arguments.  The default values are inserted whenever the function is
     called with insufficiently many actual arguments.  Since arguments
     can only be omitted from the end of the actual argument list, all
     parameters after a parameter with a default value have to have
     default values as well.  (Although the use of named argument notation
     could allow this restriction to be relaxed, it's still enforced so that
     positional argument notation works sensibly.)  Whether or not you use it,
     this capability creates a need for precautions when calling functions in
     databases where some users mistrust other users; see
     <xref linkend="typeconv-func"/>.
    </para>
________________________________________________________-->
    <para>
     函数可以被声明为对一些或者所有输入参数具有默认值。只要调用函数时
     没有给出足够多的实参，就会插入默认值来弥补缺失的实参。由于参数只
     能从实参列表的尾部开始被省略，在一个有默认值的参数之后的所有参数
     都不得不也具有默认值（尽管使用命名参数记法可以允许放松这种限制，
     这种限制仍然会被强制以便位置参数记法能工作）。不管你是否使用它，这种能力都要求在某些用户不信任其他用户的数据中调用函数时做一些预防措施，见<xref linkend="typeconv-func"/>。
    </para>
<!-- pgdoc-cn_end sig_en=d987792e6c998fbf70e1863c70fd5f4e -->

<!-- pgdoc-cn_start sig_en=417d56bdc34585d9f697aa93fae65339 sig_cn_org=e6f22ab4660f2af3e9986132fc020d39 source=15.7 
    <para>
     For example:
<screen>
CREATE FUNCTION foo(a int, b int DEFAULT 2, c int DEFAULT 3)
RETURNS int
LANGUAGE SQL
AS $$
    SELECT $1 + $2 + $3;
$$;

SELECT foo(10, 20, 30);
 foo
-&minus;-&minus;-
  60
(1 row)

SELECT foo(10, 20);
 foo
-&minus;-&minus;-
  33
(1 row)

SELECT foo(10);
 foo
-&minus;-&minus;-
  15
(1 row)

SELECT foo();  -&minus; fails since there is no default for the first argument
ERROR:  function foo() does not exist
</screen>
     The <literal>=</literal> sign can also be used in place of the
     key word <literal>DEFAULT</literal>.
    </para>
________________________________________________________-->
    <para>
     例如:
<screen>
CREATE FUNCTION foo(a int, b int DEFAULT 2, c int DEFAULT 3)
RETURNS int
LANGUAGE SQL
AS $$
    SELECT $1 + $2 + $3;
$$;

SELECT foo(10, 20, 30);
 foo
-----
  60
(1 row)

SELECT foo(10, 20);
 foo
-----
  33
(1 row)

SELECT foo(10);
 foo
-----
  15
(1 row)

SELECT foo();  -- 因为第一个参数没有默认值，所以失败
ERROR:  function foo() does not exist
</screen>
     <literal>=</literal>符号也可以用来代替关键字<literal>DEFAULT</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=417d56bdc34585d9f697aa93fae65339 -->
   </sect2>

   <sect2 id="xfunc-sql-table-functions">
<!-- pgdoc-cn_start sig_en=9e52d689b20e85b8526bbf8bf43698f2 sig_cn_org=None source=14.1 
    <title><acronym>SQL</acronym> Functions as Table Sources</title>
________________________________________________________-->
    <title><acronym>SQL</acronym> 函数作为表来源</title>
<!-- pgdoc-cn_end sig_en=9e52d689b20e85b8526bbf8bf43698f2 -->

<!-- pgdoc-cn_start sig_en=83dacb9a3dd7f29da37679df959a8c84 sig_cn_org=None source=14.1 
    <para>
     All SQL functions can be used in the <literal>FROM</literal> clause of a query,
     but it is particularly useful for functions returning composite types.
     If the function is defined to return a base type, the table function
     produces a one-column table.  If the function is defined to return
     a composite type, the table function produces a column for each attribute
     of the composite type.
    </para>
________________________________________________________-->
    <para>
     所有的 SQL 函数都可以被用在查询的<literal>FROM</literal>子句中，但是
     对于返回组合类型的函数特别有用。如果函数被定义为返回一种基本类型，
     该表函数会产生一个单列表。如果该函数被定义为返回一种组合类型，该
     表函数会为该组合类型的每一个属性产生一列。
    </para>
<!-- pgdoc-cn_end sig_en=83dacb9a3dd7f29da37679df959a8c84 -->

<!-- pgdoc-cn_start sig_en=d9fd829927faa80e2ecd66eee7eb9ba2 sig_cn_org=None source=14.1 
    <para>
     Here is an example:

<screen>
CREATE TABLE foo (fooid int, foosubid int, fooname text);
INSERT INTO foo VALUES (1, 1, 'Joe');
INSERT INTO foo VALUES (1, 2, 'Ed');
INSERT INTO foo VALUES (2, 1, 'Mary');

CREATE FUNCTION getfoo(int) RETURNS foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT *, upper(fooname) FROM getfoo(1) AS t1;

 fooid | foosubid | fooname | upper
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-
     1 |        1 | Joe     | JOE
(1 row)
</screen>

     As the example shows, we can work with the columns of the function's
     result just the same as if they were columns of a regular table.
    </para>
________________________________________________________-->
    <para>
     这里是一个例子：

<screen>
CREATE TABLE foo (fooid int, foosubid int, fooname text);
INSERT INTO foo VALUES (1, 1, 'Joe');
INSERT INTO foo VALUES (1, 2, 'Ed');
INSERT INTO foo VALUES (2, 1, 'Mary');

CREATE FUNCTION getfoo(int) RETURNS foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT *, upper(fooname) FROM getfoo(1) AS t1;

 fooid | foosubid | fooname | upper
-------+----------+---------+-------
     1 |        1 | Joe     | JOE
(1 row)
</screen>

     正如例子所示，我们可以把函数结果的列当作常规表的列来使用。
    </para>
<!-- pgdoc-cn_end sig_en=d9fd829927faa80e2ecd66eee7eb9ba2 -->

<!-- pgdoc-cn_start sig_en=0de6f5bc3e3556d3eddbd0134a9442d0 sig_cn_org=None source=14.1 
    <para>
     Note that we only got one row out of the function.  This is because
     we did not use <literal>SETOF</literal>.  That is described in the next section.
    </para>
________________________________________________________-->
    <para>
     注意我们只从函数得到了一行。这是因为我们没有使用<literal>SETOF</literal>。
     这会在下一节中介绍。
    </para>
<!-- pgdoc-cn_end sig_en=0de6f5bc3e3556d3eddbd0134a9442d0 -->
   </sect2>

   <sect2 id="xfunc-sql-functions-returning-set">
<!-- pgdoc-cn_start sig_en=5d44c3d69c74b51e86666903b3698950 sig_cn_org=None source=14.1 
    <title><acronym>SQL</acronym> Functions Returning Sets</title>
________________________________________________________-->
    <title>返回集合的<acronym>SQL</acronym>函数</title>
<!-- pgdoc-cn_end sig_en=5d44c3d69c74b51e86666903b3698950 -->

<!-- pgdoc-cn_start sig_en=fa9c0ae6adc23b522dd4dcc8fe1d67b1 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>function</primary>
     <secondary>with SETOF</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>function</primary>
     <secondary>with SETOF</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=fa9c0ae6adc23b522dd4dcc8fe1d67b1 -->

<!-- pgdoc-cn_start sig_en=ba92aa0493416af7262906605df430c1 sig_cn_org=None source=14.1 
    <para>
     When an SQL function is declared as returning <literal>SETOF
     <replaceable>sometype</replaceable></literal>, the function's final
     query is executed to completion, and each row it
     outputs is returned as an element of the result set.
    </para>
________________________________________________________-->
    <para>
     当一个 SQL 函数被声明为返回<literal>SETOF
     <replaceable>sometype</replaceable></literal>时，该函数的
     最后一个查询会被执行完，并且它输出的每一行都会被
     作为结果集的一个元素返回。
    </para>
<!-- pgdoc-cn_end sig_en=ba92aa0493416af7262906605df430c1 -->

<!-- pgdoc-cn_start sig_en=ec9a60d5d50b2e69d35671e77ca2d5a2 sig_cn_org=None source=14.1 
    <para>
     This feature is normally used when calling the function in the <literal>FROM</literal>
     clause.  In this case each row returned by the function becomes
     a row of the table seen by the query.  For example, assume that
     table <literal>foo</literal> has the same contents as above, and we say:

<programlisting>
CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM getfoo(1) AS t1;
</programlisting>

     Then we would get:
<screen>
 fooid | foosubid | fooname
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-
     1 |        1 | Joe
     1 |        2 | Ed
(2 rows)
</screen>
    </para>
________________________________________________________-->
    <para>
     在<literal>FROM</literal>子句中调用函数时通常会使用这种特性。在这种
     情况下，该函数返回的每一行都变成查询所见的表的一行。例如，假设
     表<literal>foo</literal>具有和上文一样的内容，并且我们做了以下动作：

<programlisting>
CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM getfoo(1) AS t1;
</programlisting>

     那么我们会得到：
<screen>
 fooid | foosubid | fooname
-------+----------+---------
     1 |        1 | Joe
     1 |        2 | Ed
(2 rows)
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=ec9a60d5d50b2e69d35671e77ca2d5a2 -->

<!-- pgdoc-cn_start sig_en=9b1e45f56f978bce3a49d408a52bd49d sig_cn_org=None source=14.1 
    <para>
     It is also possible to return multiple rows with the columns defined by
     output parameters, like this:

<programlisting>
CREATE TABLE tab (y int, z int);
INSERT INTO tab VALUES (1, 2), (3, 4), (5, 6), (7, 8);

CREATE FUNCTION sum_n_product_with_tab (x int, OUT sum int, OUT product int)
RETURNS SETOF record
AS $$
    SELECT $1 + tab.y, $1 * tab.y FROM tab;
$$ LANGUAGE SQL;

SELECT * FROM sum_n_product_with_tab(10);
 sum | product
-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-
  11 |      10
  13 |      30
  15 |      50
  17 |      70
(4 rows)
</programlisting>

     The key point here is that you must write <literal>RETURNS SETOF record</literal>
     to indicate that the function returns multiple rows instead of just one.
     If there is only one output parameter, write that parameter's type
     instead of <type>record</type>.
    </para>
________________________________________________________-->
    <para>
     也可以返回多个带有由输出参数定义的列的行，像这样：

<programlisting>
CREATE TABLE tab (y int, z int);
INSERT INTO tab VALUES (1, 2), (3, 4), (5, 6), (7, 8);

CREATE FUNCTION sum_n_product_with_tab (x int, OUT sum int, OUT product int)
RETURNS SETOF record
AS $$
    SELECT $1 + tab.y, $1 * tab.y FROM tab;
$$ LANGUAGE SQL;

SELECT * FROM sum_n_product_with_tab(10);
 sum | product
-----+---------
  11 |      10
  13 |      30
  15 |      50
  17 |      70
(4 rows)
</programlisting>

     这里的关键点是必须写上<literal>RETURNS SETOF record</literal>来指示
     该函数返回多行而不是一行。如果只有一个输出参数，则写上该参数的
     类型而不是<type>record</type>。
    </para>
<!-- pgdoc-cn_end sig_en=9b1e45f56f978bce3a49d408a52bd49d -->

<!-- pgdoc-cn_start sig_en=491c176c51823da64af8db9127ab586e sig_cn_org=None source=14.1 
    <para>
     It is frequently useful to construct a query's result by invoking a
     set-returning function multiple times, with the parameters for each
     invocation coming from successive rows of a table or subquery.  The
     preferred way to do this is to use the <literal>LATERAL</literal> key word,
     which is described in <xref linkend="queries-lateral"/>.
     Here is an example using a set-returning function to enumerate
     elements of a tree structure:

<screen>
SELECT * FROM nodes;
   name    | parent
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;
 Top       |
 Child1    | Top
 Child2    | Top
 Child3    | Top
 SubChild1 | Child1
 SubChild2 | Child1
(6 rows)

CREATE FUNCTION listchildren(text) RETURNS SETOF text AS $$
    SELECT name FROM nodes WHERE parent = $1
$$ LANGUAGE SQL STABLE;

SELECT * FROM listchildren('Top');
 listchildren
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Child1
 Child2
 Child3
(3 rows)

SELECT name, child FROM nodes, LATERAL listchildren(name) AS child;
  name  |   child
-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-
 Top    | Child1
 Top    | Child2
 Top    | Child3
 Child1 | SubChild1
 Child1 | SubChild2
(5 rows)
</screen>

     This example does not do anything that we couldn't have done with a
     simple join, but in more complex calculations the option to put
     some of the work into a function can be quite convenient.
    </para>
________________________________________________________-->
    <para>
     通过多次调用集合返回函数来构建查询的结果非常有用，每次调用的参数
     来自于一个表或者子查询的连续行。做这种事情最好的方法是使用
     <xref linkend="queries-lateral"/>中描述的<literal>LATERAL</literal>关键
     词。这里是一个使用集合返回函数枚举树结构中元素的例子：

<screen>
SELECT * FROM nodes;
   name    | parent
-----------+--------
 Top       |
 Child1    | Top
 Child2    | Top
 Child3    | Top
 SubChild1 | Child1
 SubChild2 | Child1
(6 rows)

CREATE FUNCTION listchildren(text) RETURNS SETOF text AS $$
    SELECT name FROM nodes WHERE parent = $1
$$ LANGUAGE SQL STABLE;

SELECT * FROM listchildren('Top');
 listchildren
--------------
 Child1
 Child2
 Child3
(3 rows)

SELECT name, child FROM nodes, LATERAL listchildren(name) AS child;
  name  |   child
--------+-----------
 Top    | Child1
 Top    | Child2
 Top    | Child3
 Child1 | SubChild1
 Child1 | SubChild2
(5 rows)
</screen>

     这个例子和我们使用的简单连接的效果没什么不同，但是在更复杂的
     计算中，把一些工作放在函数中会是一种很方便的选项。
    </para>
<!-- pgdoc-cn_end sig_en=491c176c51823da64af8db9127ab586e -->

<!-- pgdoc-cn_start sig_en=72df19e4cc282cb94e87ac2f1c170ee2 sig_cn_org=None source=14.1 
    <para>
     Functions returning sets can also be called in the select list
     of a query.  For each row that the query
     generates by itself, the set-returning function is invoked, and an output
     row is generated for each element of the function's result set.
     The previous example could also be done with queries like
     these:

<screen>
SELECT listchildren('Top');
 listchildren
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Child1
 Child2
 Child3
(3 rows)

SELECT name, listchildren(name) FROM nodes;
  name  | listchildren
-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Top    | Child1
 Top    | Child2
 Top    | Child3
 Child1 | SubChild1
 Child1 | SubChild2
(5 rows)
</screen>

     In the last <command>SELECT</command>,
     notice that no output row appears for <literal>Child2</literal>, <literal>Child3</literal>, etc.
     This happens because <function>listchildren</function> returns an empty set
     for those arguments, so no result rows are generated.  This is the same
     behavior as we got from an inner join to the function result when using
     the <literal>LATERAL</literal> syntax.
    </para>
________________________________________________________-->
    <para>
     返回集合的函数也能在查询的选择列表中调用。对于该查询本身产生的每一行都会调用集合返回函数，并且会从该函数的结果集中的每一个元素生成一个输出行。之前的例子也可以用这样的查询实现：

<screen>
SELECT listchildren('Top');
 listchildren
--------------
 Child1
 Child2
 Child3
(3 rows)

SELECT name, listchildren(name) FROM nodes;
  name  | listchildren
--------+--------------
 Top    | Child1
 Top    | Child2
 Top    | Child3
 Child1 | SubChild1
 Child1 | SubChild2
(5 rows)
</screen>

     在最后一个<command>SELECT</command>中，注意对于<literal>Child2</literal>、
     <literal>Child3</literal>等没有出现输出行。这是因为<function>listchildren</function>
     对这些参数返回空集，因此没有产生结果行。这和使用<literal>LATERAL</literal>
     语法时，我们从与该函数结果的内连接得到的行为是一样的。
    </para>
<!-- pgdoc-cn_end sig_en=72df19e4cc282cb94e87ac2f1c170ee2 -->

<!-- pgdoc-cn_start sig_en=8ebe18d063150aed9a65738c2e462433 sig_cn_org=None source=14.1 
    <para>
     <productname>PostgreSQL</productname>'s behavior for a set-returning function in a
     query's select list is almost exactly the same as if the set-returning
     function had been written in a <literal>LATERAL FROM</literal>-clause item
     instead.  For example,
<programlisting>
SELECT x, generate_series(1,5) AS g FROM tab;
</programlisting>
     is almost equivalent to
<programlisting>
SELECT x, g FROM tab, LATERAL generate_series(1,5) AS g;
</programlisting>
     It would be exactly the same, except that in this specific example,
     the planner could choose to put <structname>g</structname> on the outside of the
     nested-loop join, since <structname>g</structname> has no actual lateral dependency
     on <structname>tab</structname>.  That would result in a different output row
     order.  Set-returning functions in the select list are always evaluated
     as though they are on the inside of a nested-loop join with the rest of
     the <literal>FROM</literal> clause, so that the function(s) are run to
     completion before the next row from the <literal>FROM</literal> clause is
     considered.
    </para>
________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>中，写在查询的选择列表中的集合返回函数的行为几乎和写在<literal>LATERAL FROM</literal>子句项中的集合返回函数完全一样。例如：
<programlisting>
SELECT x, generate_series(1,5) AS g FROM tab;
</programlisting>
     几乎等效于
<programlisting>
SELECT x, g FROM tab, LATERAL generate_series(1,5) AS g;
</programlisting>
     这会是完全一样的，除了在这个特别的例子中，规划器会选择把<structname>g</structname>放在嵌套循环连接的外侧，因为<structname>g</structname>对<structname>tab</structname>没有实际的横向依赖。那会导致一种不同的输出行顺序。选择列表中的集合返回函数总是会被计算，就好像它们在<literal>FROM</literal>子句剩余部分的嵌套循环连接的内侧一样，因此在考虑来自<literal>FROM</literal>子句的下一行之前，这些函数会运行到完成。
    </para>
<!-- pgdoc-cn_end sig_en=8ebe18d063150aed9a65738c2e462433 -->

<!-- pgdoc-cn_start sig_en=d389af1dedd03173b14ffba4004a944b sig_cn_org=None source=14.1 
    <para>
     If there is more than one set-returning function in the query's select
     list, the behavior is similar to what you get from putting the functions
     into a single <literal>LATERAL ROWS FROM( ... )</literal> <literal>FROM</literal>-clause
     item.  For each row from the underlying query, there is an output row
     using the first result from each function, then an output row using the
     second result, and so on.  If some of the set-returning functions
     produce fewer outputs than others, null values are substituted for the
     missing data, so that the total number of rows emitted for one
     underlying row is the same as for the set-returning function that
     produced the most outputs.  Thus the set-returning functions
     run <quote>in lockstep</quote> until they are all exhausted, and then
     execution continues with the next underlying row.
    </para>
________________________________________________________-->
    <para>
     如果在查询的选择列表中有不止一个集合返回函数，则行为类似于把那些函数放到一个单一的<literal>LATERAL ROWS FROM( ... )</literal> <literal>FROM</literal>子句项中的行为。对于来自底层查询的每一行，都有一个用到每个函数首个结果的输出行，然后是一个使用每个函数第二个结果的输出行，以此类推。如果某些集合返回函数产生的输出比其他函数少，会用空值代替缺失的数据，因此为一个底层行形成的总行数等于产生最多输出的集合返回函数的输出行数。因此集合返回函数会<quote>步调一致</quote>地运行直到它们的输出被耗尽，然后用下一个底层行继续执行。
    </para>
<!-- pgdoc-cn_end sig_en=d389af1dedd03173b14ffba4004a944b -->

<!-- pgdoc-cn_start sig_en=0c489f4b1947f8ee4f9b0e3fcb987075 sig_cn_org=None source=14.1 
    <para>
     Set-returning functions can be nested in a select list, although that is
     not allowed in <literal>FROM</literal>-clause items.  In such cases, each level
     of nesting is treated separately, as though it were
     a separate <literal>LATERAL ROWS FROM( ... )</literal> item.  For example, in
<programlisting>
SELECT srf1(srf2(x), srf3(y)), srf4(srf5(z)) FROM tab;
</programlisting>
     the set-returning functions <function>srf2</function>, <function>srf3</function>,
     and <function>srf5</function> would be run in lockstep for each row
     of <structname>tab</structname>, and then <function>srf1</function> and <function>srf4</function>
     would be applied in lockstep to each row produced by the lower
     functions.
    </para>
________________________________________________________-->
    <para>
     集合返回函数可以被嵌套在一个选择列表中，不过在<literal>FROM</literal>子句项中不允许这样做。在这种情况下，嵌套的每一层会被单独对待，就像它是一个单独的<literal>LATERAL ROWS FROM( ... )</literal>项一样。例如，在
<programlisting>
SELECT srf1(srf2(x), srf3(y)), srf4(srf5(z)) FROM tab;
</programlisting>
     中，集合返回函数<function>srf2</function>、<function>srf3</function>和<function>srf5</function>将为<structname>tab</structname>的每一行步调一致地运行，然后会对较低层的函数产生的每一行以步调一致的形式应用<function>srf1</function>和<function>srf4</function>。
    </para>
<!-- pgdoc-cn_end sig_en=0c489f4b1947f8ee4f9b0e3fcb987075 -->

<!-- pgdoc-cn_start sig_en=4a36bb5131fffa9498cb51d7e1205f64 sig_cn_org=None source=14.1 
    <para>
     Set-returning functions cannot be used within conditional-evaluation
     constructs, such as <literal>CASE</literal> or <literal>COALESCE</literal>.  For
     example, consider
<programlisting>
SELECT x, CASE WHEN x &gt; 0 THEN generate_series(1, 5) ELSE 0 END FROM tab;
</programlisting>
     It might seem that this should produce five repetitions of input rows
     that have <literal>x &gt; 0</literal>, and a single repetition of those that do
     not; but actually, because <function>generate_series(1, 5)</function> would be
     run in an implicit <literal>LATERAL FROM</literal> item before
     the <literal>CASE</literal> expression is ever evaluated, it would produce five
     repetitions of every input row.  To reduce confusion, such cases produce
     a parse-time error instead.
    </para>
________________________________________________________-->
    <para>
     在<literal>CASE</literal>或<literal>COALESCE</literal>这样的条件计算结构中，不能使用集合返回函数。例如，考虑
<programlisting>
SELECT x, CASE WHEN x &gt; 0 THEN generate_series(1, 5) ELSE 0 END FROM tab;
</programlisting>
     看起来这个语句应该产生满足<literal>x &gt; 0</literal>的输入行的五次重复，以及不满足的行的一次重复。但实际上，由于在<literal>CASE</literal>表达时被计算前，<function>generate_series(1, 5)</function>会被运行在一个隐式的<literal>LATERAL FROM</literal>项中，它会为每个输入行产生五次重复。为了减少混乱，这类情况会产生一个解析时错误。
    </para>
<!-- pgdoc-cn_end sig_en=4a36bb5131fffa9498cb51d7e1205f64 -->

    <note>
<!-- pgdoc-cn_start sig_en=5d76c9beca2bb6981d85d94eaa747029 sig_cn_org=None source=14.1 
     <para>
      If a function's last command is <command>INSERT</command>, <command>UPDATE</command>,
      or <command>DELETE</command> with <literal>RETURNING</literal>, that command will
      always be executed to completion, even if the function is not declared
      with <literal>SETOF</literal> or the calling query does not fetch all the
      result rows.  Any extra rows produced by the <literal>RETURNING</literal>
      clause are silently dropped, but the commanded table modifications
      still happen (and are all completed before returning from the function).
     </para>
________________________________________________________-->
     <para>
      如果函数的最后一个命令是带有<literal>RETURNING</literal>的
      <command>INSERT</command>、<command>UPDATE</command>或者
      <command>DELETE</command>，该命令将总是会被执行完，即使函数没有用
      <literal>SETOF</literal>定义或者调用查询不要求取出所有结果行也是如此。
      <literal>RETURNING</literal>子句产生的多余的行会被悄无声息地丢掉，但是
      在命令的目标表上的修改仍然会发生（而且在从该函数返回前就会全部完成）。
     </para>
<!-- pgdoc-cn_end sig_en=5d76c9beca2bb6981d85d94eaa747029 -->
    </note>

    <note>
<!-- pgdoc-cn_start sig_en=7e658612fafc06229d1a7c56e837057a sig_cn_org=e65209e249e45e06caa19b00a30c14d5 source=15.7 
     <para>
      Before <productname>PostgreSQL</productname> 10, putting more than one
      set-returning function in the same select list did not behave very
      sensibly unless they always produced equal numbers of rows.  Otherwise,
      what you got was a number of output rows equal to the least common
      multiple of the numbers of rows produced by the set-returning
      functions.  Also, nested set-returning functions did not work as
      described above; instead, a set-returning function could have at most
      one set-returning argument, and each nest of set-returning functions
      was run independently.  Also, conditional execution (set-returning
      functions inside <literal>CASE</literal> etc.) was previously allowed,
      complicating things even more.
      Use of the <literal>LATERAL</literal> syntax is recommended when writing
      queries that need to work in older <productname>PostgreSQL</productname> versions,
      because that will give consistent results across different versions.
      If you have a query that is relying on conditional execution of a
      set-returning function, you may be able to fix it by moving the
      conditional test into a custom set-returning function.  For example,
<programlisting>
SELECT x, CASE WHEN y &gt; 0 THEN generate_series(1, z) ELSE 5 END FROM tab;
</programlisting>
      could become
<programlisting>
CREATE FUNCTION case_generate_series(cond bool, start int, fin int, els int)
  RETURNS SETOF int AS $$
BEGIN
  IF cond THEN
    RETURN QUERY SELECT generate_series(start, fin);
  ELSE
    RETURN QUERY SELECT els;
  END IF;
END$$ LANGUAGE plpgsql;

SELECT x, case_generate_series(y &gt; 0, 1, z, 5) FROM tab;
</programlisting>
      This formulation will work the same in all versions
      of <productname>PostgreSQL</productname>.
     </para>
________________________________________________________-->
     <para>
      在<productname>PostgreSQL</productname> 10之前，在同一选择列表中放置多个返回集函数
      的行为不太合理，除非它们始终产生相等数量的行。否则，您得到的将是由返回集函数产生的行数的最小公倍数。
      此外，嵌套的返回集函数不像上面描述的那样工作；相反，一个返回集函数最多可以有一个返回集参数，
      并且每个返回集函数的嵌套都是独立运行的。此外，以前允许条件执行（在<literal>CASE</literal>等内部的返回集函数），
      进一步复杂化了事情。
      在编写需要在旧版<productname>PostgreSQL</productname>版本中工作的查询时，建议使用<literal>LATERAL</literal>语法，
      因为这将在不同版本中提供一致的结果。
      如果您的查询依赖于返回集函数的条件执行，您可以通过将条件测试移入自定义返回集函数来修复它。例如，
<programlisting>
SELECT x, CASE WHEN y &gt; 0 THEN generate_series(1, z) ELSE 5 END FROM tab;
</programlisting>
      可以变成
<programlisting>
CREATE FUNCTION case_generate_series(cond bool, start int, fin int, els int)
  RETURNS SETOF int AS $$
BEGIN
  IF cond THEN
    RETURN QUERY SELECT generate_series(start, fin);
  ELSE
    RETURN QUERY SELECT els;
  END IF;
END$$ LANGUAGE plpgsql;

SELECT x, case_generate_series(y &gt; 0, 1, z, 5) FROM tab;
</programlisting>
      这种表述在所有版本的<productname>PostgreSQL</productname>中都能正常工作。
     </para>
<!-- pgdoc-cn_end sig_en=7e658612fafc06229d1a7c56e837057a -->
    </note>
   </sect2>

   <sect2 id="xfunc-sql-functions-returning-table">
<!-- pgdoc-cn_start sig_en=4fb74d9eac6b6756093a86f6ac9820f4 sig_cn_org=None source=14.1 
    <title><acronym>SQL</acronym> Functions Returning <literal>TABLE</literal></title>
________________________________________________________-->
    <title>返回<literal>TABLE</literal>的<acronym>SQL</acronym>函数</title>
<!-- pgdoc-cn_end sig_en=4fb74d9eac6b6756093a86f6ac9820f4 -->

<!-- pgdoc-cn_start sig_en=d6090ee14110cceaf1ca27ee44839feb sig_cn_org=None source=14.1 
    <indexterm>
     <primary>function</primary>
     <secondary>RETURNS TABLE</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>function</primary>
     <secondary>RETURNS TABLE</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=d6090ee14110cceaf1ca27ee44839feb -->

<!-- pgdoc-cn_start sig_en=843e8f98bb8e5219b5b984b255a2f555 sig_cn_org=None source=14.1 
    <para>
     There is another way to declare a function as returning a set,
     which is to use the syntax
     <literal>RETURNS TABLE(<replaceable>columns</replaceable>)</literal>.
     This is equivalent to using one or more <literal>OUT</literal> parameters plus
     marking the function as returning <literal>SETOF record</literal> (or
     <literal>SETOF</literal> a single output parameter's type, as appropriate).
     This notation is specified in recent versions of the SQL standard, and
     thus may be more portable than using <literal>SETOF</literal>.
    </para>
________________________________________________________-->
    <para>
     还有另一种方法可以把函数声明为返回一个集合，即使用
     <literal>RETURNS TABLE(<replaceable>columns</replaceable>)</literal>语法。
     这等效于使用一个或者多个<literal>OUT</literal>参数外加把函数标记为返回
     <literal>SETOF record</literal>（或者是<literal>SETOF</literal>单个输出参数的
     类型）。这种写法是在最近的 SQL 标准中指定的，因此可能比使用
     <literal>SETOF</literal>的移植性更好。
    </para>
<!-- pgdoc-cn_end sig_en=843e8f98bb8e5219b5b984b255a2f555 -->

<!-- pgdoc-cn_start sig_en=99f49a4985c47c60f3353bfb6f66131b sig_cn_org=None source=14.1 
    <para>
     For example, the preceding sum-and-product example could also be
     done this way:

<programlisting>
CREATE FUNCTION sum_n_product_with_tab (x int)
RETURNS TABLE(sum int, product int) AS $$
    SELECT $1 + tab.y, $1 * tab.y FROM tab;
$$ LANGUAGE SQL;
</programlisting>

     It is not allowed to use explicit <literal>OUT</literal> or <literal>INOUT</literal>
     parameters with the <literal>RETURNS TABLE</literal> notation &mdash; you must
     put all the output columns in the <literal>TABLE</literal> list.
    </para>
________________________________________________________-->
    <para>
     例如，前面的求和并且相乘的例子也可以这样来做：

<programlisting>
CREATE FUNCTION sum_n_product_with_tab (x int)
RETURNS TABLE(sum int, product int) AS $$
    SELECT $1 + tab.y, $1 * tab.y FROM tab;
$$ LANGUAGE SQL;
</programlisting>

     不允许把显式的<literal>OUT</literal>或者<literal>INOUT</literal>参数用于
     <literal>RETURNS TABLE</literal>记法 &mdash; 必须把所有输出列放在
     <literal>TABLE</literal>列表中。
    </para>
<!-- pgdoc-cn_end sig_en=99f49a4985c47c60f3353bfb6f66131b -->
   </sect2>

   <sect2 id="xfunc-sql-polymorphic-functions">
<!-- pgdoc-cn_start sig_en=65109f92945383899022e995f8ed9a6c sig_cn_org=None source=14.1 
    <title>Polymorphic <acronym>SQL</acronym> Functions</title>
________________________________________________________-->
    <title>多态<acronym>SQL</acronym>函数</title>
<!-- pgdoc-cn_end sig_en=65109f92945383899022e995f8ed9a6c -->

<!-- pgdoc-cn_start sig_en=b54e9440f62572070e669f48fe07331d sig_cn_org=None source=14.1 
    <para>
     <acronym>SQL</acronym> functions can be declared to accept and
     return the polymorphic types described in <xref
     linkend="extend-types-polymorphic"/>.  Here is a polymorphic
     function <function>make_array</function> that builds up an array
     from two arbitrary data type elements:
<screen>
CREATE FUNCTION make_array(anyelement, anyelement) RETURNS anyarray AS $$
    SELECT ARRAY[$1, $2];
$$ LANGUAGE SQL;

SELECT make_array(1, 2) AS intarray, make_array('a'::text, 'b') AS textarray;
 intarray | textarray
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-
 {1,2}    | {a,b}
(1 row)
</screen>
    </para>
________________________________________________________-->
    <para>
     <acronym>SQL</acronym>函数可以声明为接受和返回<xref linkend="extend-types-polymorphic"/>中描述的多态类型。
     这是一个多态函数<function>make_array</function>，它从两个任意数据类型元素构建一个数组：
<screen>
CREATE FUNCTION make_array(anyelement, anyelement) RETURNS anyarray AS $$
    SELECT ARRAY[$1, $2];
$$ LANGUAGE SQL;

SELECT make_array(1, 2) AS intarray, make_array('a'::text, 'b') AS textarray;
 intarray | textarray
----------+-----------
 {1,2}    | {a,b}
(1 row)
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=b54e9440f62572070e669f48fe07331d -->

<!-- pgdoc-cn_start sig_en=3b7e8ec5ea9595ea5b482219c479c7c2 sig_cn_org=None source=14.1 
    <para>
     Notice the use of the typecast <literal>'a'::text</literal>
     to specify that the argument is of type <type>text</type>. This is
     required if the argument is just a string literal, since otherwise
     it would be treated as type
     <type>unknown</type>, and array of <type>unknown</type> is not a valid
     type.
     Without the typecast, you will get errors like this:
<screen>
ERROR:  could not determine polymorphic type because input has type unknown
</screen>
    </para>
________________________________________________________-->
    <para>
     注意类型造型<literal>'a'::text</literal>的使用是为了指定该参数的类型
     是<type>text</type>。如果该参数只是一个字符串这就是必须的，因为
     否则它会被当作<type>unknown</type>类型，并且
     <type>unknown</type>的数组也不是一种合法的类型。如果没有改类型
     造型，将得到这样的错误：
<screen>
ERROR:  could not determine polymorphic type because input has type unknown
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=3b7e8ec5ea9595ea5b482219c479c7c2 -->

<!-- pgdoc-cn_start sig_en=eff0644662b6a8f5886b444b370ac77b sig_cn_org=889bc07506efd7d8ecf2d846c8f2b9e5 source=15.7 
    <para>
     With <function>make_array</function> declared as above, you must
     provide two arguments that are of exactly the same data type; the
     system will not attempt to resolve any type differences.  Thus for
     example this does not work:
<screen>
SELECT make_array(1, 2.5) AS numericarray;
ERROR:  function make_array(integer, numeric) does not exist
</screen>
     An alternative approach is to use the <quote>common</quote> family of
     polymorphic types, which allows the system to try to identify a
     suitable common type:
<screen>
CREATE FUNCTION make_array2(anycompatible, anycompatible)
RETURNS anycompatiblearray AS $$
    SELECT ARRAY[$1, $2];
$$ LANGUAGE SQL;

SELECT make_array2(1, 2.5) AS numericarray;
 numericarray
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {1,2.5}
(1 row)
</screen>
     Because the rules for common type resolution default to choosing
     type <type>text</type> when all inputs are of unknown types, this
     also works:
<screen>
SELECT make_array2('a', 'b') AS textarray;
 textarray
-&minus;-&minus;-&minus;-&minus;-&minus;-
 {a,b}
(1 row)
</screen>
    </para>
________________________________________________________-->
    <para>
     使用上述方式声明<function>make_array</function>函数时，必须提供两个完全相同数据类型的参数；
     系统不会尝试解决任何类型差异。因此，例如以下操作不起作用：
<screen>
SELECT make_array(1, 2.5) AS numericarray;
ERROR:  function make_array(integer, numeric) does not exist
</screen>
     另一种方法是使用<quote>common</quote>系列多态类型，允许系统尝试识别一个合适的公共类型：
<screen>
CREATE FUNCTION make_array2(anycompatible, anycompatible)
RETURNS anycompatiblearray AS $$
    SELECT ARRAY[$1, $2];
$$ LANGUAGE SQL;

SELECT make_array2(1, 2.5) AS numericarray;
 numericarray
--------------
 {1,2.5}
(1 row)
</screen>
     因为当所有输入类型未知时，公共类型解析规则默认选择<type>text</type>类型，所以以下操作也有效：
<screen>
SELECT make_array2('a', 'b') AS textarray;
 textarray
-----------
 {a,b}
(1 row)
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=eff0644662b6a8f5886b444b370ac77b -->

<!-- pgdoc-cn_start sig_en=73884636c25d178c2ab407b488b2a61a sig_cn_org=None source=14.1 
    <para>
     It is permitted to have polymorphic arguments with a fixed
     return type, but the converse is not. For example:
<screen>
CREATE FUNCTION is_greater(anyelement, anyelement) RETURNS boolean AS $$
    SELECT $1 &gt; $2;
$$ LANGUAGE SQL;

SELECT is_greater(1, 2);
 is_greater
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 f
(1 row)

CREATE FUNCTION invalid_func() RETURNS anyelement AS $$
    SELECT 1;
$$ LANGUAGE SQL;
ERROR:  cannot determine result data type
DETAIL:  A result of type anyelement requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
</screen>
    </para>
________________________________________________________-->
    <para>
     允许具有多态参数和固定的返回类型，但是反过来不行。例如：
<screen>
CREATE FUNCTION is_greater(anyelement, anyelement) RETURNS boolean AS $$
    SELECT $1 &gt; $2;
$$ LANGUAGE SQL;

SELECT is_greater(1, 2);
 is_greater
------------
 f
(1 row)

CREATE FUNCTION invalid_func() RETURNS anyelement AS $$
    SELECT 1;
$$ LANGUAGE SQL;
ERROR:  cannot determine result data type
DETAIL:  A result of type anyelement requires at least one input of type anyelement, anyarray, anynonarray, anyenum, or anyrange.
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=73884636c25d178c2ab407b488b2a61a -->

<!-- pgdoc-cn_start sig_en=e35aad66a90da81ba1f59833778d5108 sig_cn_org=None source=14.1 
    <para>
     Polymorphism can be used with functions that have output arguments.
     For example:
<screen>
CREATE FUNCTION dup (f1 anyelement, OUT f2 anyelement, OUT f3 anyarray)
AS 'select $1, array[$1,$1]' LANGUAGE SQL;

SELECT * FROM dup(22);
 f2 |   f3
-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-
 22 | {22,22}
(1 row)
</screen>
    </para>
________________________________________________________-->
    <para>
     多态化可以用在具有输出参数的函数上。例如：
<screen>
CREATE FUNCTION dup (f1 anyelement, OUT f2 anyelement, OUT f3 anyarray)
AS 'select $1, array[$1,$1]' LANGUAGE SQL;

SELECT * FROM dup(22);
 f2 |   f3
----+---------
 22 | {22,22}
(1 row)
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=e35aad66a90da81ba1f59833778d5108 -->

<!-- pgdoc-cn_start sig_en=be5c4caa8b339bfafe304d28279e671a sig_cn_org=e88d99c162d06d43b7dc61afb60741c1 source=15.7 
    <para>
     Polymorphism can also be used with variadic functions.
     For example:
<screen>
CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$
    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;

SELECT anyleast(10, -1, 5, 4);
 anyleast
-&minus;-&minus;-&minus;-&minus;-&minus;
       -1
(1 row)

SELECT anyleast('abc'::text, 'def');
 anyleast
-&minus;-&minus;-&minus;-&minus;-&minus;
 abc
(1 row)

CREATE FUNCTION concat_values(text, VARIADIC anyarray) RETURNS text AS $$
    SELECT array_to_string($2, $1);
$$ LANGUAGE SQL;

SELECT concat_values('|', 1, 4, 2);
 concat_values
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 1|4|2
(1 row)
</screen>
    </para>
________________________________________________________-->
    <para>
     多态性也可以与可变函数一起使用。
     例如：
<screen>
CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$
    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;

SELECT anyleast(10, -1, 5, 4);
 anyleast
----------
       -1
(1 row)

SELECT anyleast('abc'::text, 'def');
 anyleast
----------
 abc
(1 row)

CREATE FUNCTION concat_values(text, VARIADIC anyarray) RETURNS text AS $$
    SELECT array_to_string($2, $1);
$$ LANGUAGE SQL;

SELECT concat_values('|', 1, 4, 2);
 concat_values
---------------
 1|4|2
(1 row)
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=be5c4caa8b339bfafe304d28279e671a -->
   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=b84bc4aa1fe0dc182713e80ae71c982d sig_cn_org=None source=14.1 
    <title><acronym>SQL</acronym> Functions with Collations</title>
________________________________________________________-->
    <title>带有排序规则的<acronym>SQL</acronym>函数</title>
<!-- pgdoc-cn_end sig_en=b84bc4aa1fe0dc182713e80ae71c982d -->

<!-- pgdoc-cn_start sig_en=e4d600c4570c1582504907e7f1140e12 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>collation</primary>
     <secondary>in SQL functions</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>collation</primary>
     <secondary>in SQL functions</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=e4d600c4570c1582504907e7f1140e12 -->

<!-- pgdoc-cn_start sig_en=055e06fab3fc3683b3a790712e965935 sig_cn_org=None source=14.1 
    <para>
     When an SQL function has one or more parameters of collatable data types,
     a collation is identified for each function call depending on the
     collations assigned to the actual arguments, as described in <xref
     linkend="collation"/>.  If a collation is successfully identified
     (i.e., there are no conflicts of implicit collations among the arguments)
     then all the collatable parameters are treated as having that collation
     implicitly.  This will affect the behavior of collation-sensitive
     operations within the function.  For example, using the
     <function>anyleast</function> function described above, the result of
<programlisting>
SELECT anyleast('abc'::text, 'ABC');
</programlisting>
     will depend on the database's default collation.  In <literal>C</literal> locale
     the result will be <literal>ABC</literal>, but in many other locales it will
     be <literal>abc</literal>.  The collation to use can be forced by adding
     a <literal>COLLATE</literal> clause to any of the arguments, for example
<programlisting>
SELECT anyleast('abc'::text, 'ABC' COLLATE "C");
</programlisting>
     Alternatively, if you wish a function to operate with a particular
     collation regardless of what it is called with, insert
     <literal>COLLATE</literal> clauses as needed in the function definition.
     This version of <function>anyleast</function> would always use <literal>en_US</literal>
     locale to compare strings:
<programlisting>
CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$
    SELECT min($1[i] COLLATE "en_US") FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;
</programlisting>
     But note that this will throw an error if applied to a non-collatable
     data type.
    </para>
________________________________________________________-->
    <para>
     当一个 SQL 函数具有一个或者更多可排序数据类型的参数时，按照
     <xref linkend="collation"/>中所述，对每一次函数调用都会根据分
     配给实参的排序规则为其确定一个排序规则。如果成功地确定（即在
     参数之间没有隐式排序规则的冲突），那么所有的可排序参数都被认
     为隐式地具有该排序规则。这将会影响函数中对排序敏感的操作的行
     为。例如，使用上述的<function>anyleast</function>函数时，
<programlisting>
SELECT anyleast('abc'::text, 'ABC');
</programlisting>
     的结果将依赖于数据库的默认排序规则。在<literal>C</literal>区域中，
     结果将是<literal>ABC</literal>，但是在很多其他区域中它将是
     <literal>abc</literal>。可以在任意参数上增加一个<literal>COLLATE</literal>
     子句来强制要使用的排序规则，例如：
<programlisting>
SELECT anyleast('abc'::text, 'ABC' COLLATE "C");
</programlisting>
     此外，如果你希望一个函数用一个特定的排序规则工作而不管用什么排序规则
     调用它，可根据需要在函数定义中插入<literal>COLLATE</literal>子句。
     这种版本的<function>anyleast</function>将总是使用<literal>en_US</literal>区域来比
     较字符串：
<programlisting>
CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$
    SELECT min($1[i] COLLATE "en_US") FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;
</programlisting>
     但是注意如果应用到不可排序数据类型上，这将会抛出一个错误。
    </para>
<!-- pgdoc-cn_end sig_en=055e06fab3fc3683b3a790712e965935 -->

<!-- pgdoc-cn_start sig_en=61e43ef36ddec4171f065c57739ece7b sig_cn_org=None source=14.1 
    <para>
     If no common collation can be identified among the actual arguments,
     then an SQL function treats its parameters as having their data types'
     default collation (which is usually the database's default collation,
     but could be different for parameters of domain types).
    </para>
________________________________________________________-->
    <para>
     如果在实参之间无法确定共同的排序规则，那么 SQL 函数会把它的参数
     当作拥有其数据类型的默认排序规则（通常是数据库的默认排序规则，
     但是域类型的参数可能会不同）。
    </para>
<!-- pgdoc-cn_end sig_en=61e43ef36ddec4171f065c57739ece7b -->

<!-- pgdoc-cn_start sig_en=7ccfdf8d084f19e2fad3f41b724fdb1c sig_cn_org=None source=14.1 
    <para>
     The behavior of collatable parameters can be thought of as a limited
     form of polymorphism, applicable only to textual data types.
    </para>
________________________________________________________-->
    <para>
     可排序参数的行为可以被想成是多态的一种受限形式，只对于文本数据
     类型有效。
    </para>
<!-- pgdoc-cn_end sig_en=7ccfdf8d084f19e2fad3f41b724fdb1c -->
   </sect2>
  </sect1>

  <sect1 id="xfunc-overload">
<!-- pgdoc-cn_start sig_en=111501f30da31b3a35950b1ade62f871 sig_cn_org=None source=14.1 
   <title>Function Overloading</title>
________________________________________________________-->
   <title>函数重载</title>
<!-- pgdoc-cn_end sig_en=111501f30da31b3a35950b1ade62f871 -->

<!-- pgdoc-cn_start sig_en=9dc75ef48df00c0c2289d782f3f9fc3d sig_cn_org=None source=14.1 
   <indexterm zone="xfunc-overload">
    <primary>overloading</primary>
    <secondary>functions</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="xfunc-overload">
    <primary>overloading</primary>
    <secondary>functions</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=9dc75ef48df00c0c2289d782f3f9fc3d -->

<!-- pgdoc-cn_start sig_en=99588fc0abcb9a6b9b0179758306b934 sig_cn_org=None source=14.1 
   <para>
    More than one function can be defined with the same SQL name, so long
    as the arguments they take are different.  In other words,
    function names can be <firstterm>overloaded</firstterm>.  Whether or not
    you use it, this capability entails security precautions when calling
    functions in databases where some users mistrust other users; see
    <xref linkend="typeconv-func"/>.  When a query is executed, the server
    will determine which function to call from the data types and the number
    of the provided arguments.  Overloading can also be used to simulate
    functions with a variable number of arguments, up to a finite maximum
    number.
   </para>
________________________________________________________-->
   <para>
    可以用同样的 SQL 名称定义多于一个函数，只要它们的参数不同即可。
    换句话说，函数名可以被<firstterm>重载</firstterm>。不管你是否使用它，这种能力都要求在某些用户不信任其他用户的数据中调用函数时做一些预防措施，见<xref linkend="typeconv-func"/>。当一个查询
    被执行时，服务器将从数据类型和所提供的参数个数来决定要调用哪个
    函数。重载也可用来模拟具有可变参数个数（最大个数有限）的函数。
   </para>
<!-- pgdoc-cn_end sig_en=99588fc0abcb9a6b9b0179758306b934 -->

<!-- pgdoc-cn_start sig_en=f976f24fc1fdb8682afb86de622c82e1 sig_cn_org=None source=14.1 
   <para>
    When creating a family of overloaded functions, one should be
    careful not to create ambiguities.  For instance, given the
    functions:
<programlisting>
CREATE FUNCTION test(int, real) RETURNS ...
CREATE FUNCTION test(smallint, double precision) RETURNS ...
</programlisting>
    it is not immediately clear which function would be called with
    some trivial input like <literal>test(1, 1.5)</literal>.  The
    currently implemented resolution rules are described in
    <xref linkend="typeconv"/>, but it is unwise to design a system that subtly
    relies on this behavior.
   </para>
________________________________________________________-->
   <para>
    在创建一个重载函数家族时，应该小心不要创建歧义。例如，给定函数：
<programlisting>
CREATE FUNCTION test(int, real) RETURNS ...
CREATE FUNCTION test(smallint, double precision) RETURNS ...
</programlisting>
    对于<literal>test(1, 1.5)</literal>这样的输入就无法立刻清楚地知道
    应该调用哪个函数。当前实现的解决规则在<xref linkend="typeconv"/>
    中有描述，但是设计一个依赖于这种行为的系统是不明智的。
   </para>
<!-- pgdoc-cn_end sig_en=f976f24fc1fdb8682afb86de622c82e1 -->

<!-- pgdoc-cn_start sig_en=2cec9b31ba3c191ebfc5cefab00aff97 sig_cn_org=None source=14.1 
   <para>
    A function that takes a single argument of a composite type should
    generally not have the same name as any attribute (field) of that type.
    Recall that <literal><replaceable>attribute</replaceable>(<replaceable>table</replaceable>)</literal>
    is considered equivalent
    to <literal><replaceable>table</replaceable>.<replaceable>attribute</replaceable></literal>.
    In the case that there is an
    ambiguity between a function on a composite type and an attribute of
    the composite type, the attribute will always be used.  It is possible
    to override that choice by schema-qualifying the function name
    (that is, <literal><replaceable>schema</replaceable>.<replaceable>func</replaceable>(<replaceable>table</replaceable>)
    </literal>) but it's better to
    avoid the problem by not choosing conflicting names.
   </para>
________________________________________________________-->
   <para>
    一个具有单个组合类型参数的函数通常不应与该类型的任何属性（域）
    重名。回想一下，<literal><replaceable>attribute</replaceable>(<replaceable>table</replaceable>)</literal>被认为等效于
    <literal><replaceable>table</replaceable>.<replaceable>attribute</replaceable></literal>。在出现“一个组合类型
    上的函数”与“组合类型的一个属性”的情况下，将总是使用属性。
    可以通过用模式限定该函数名（即
    <literal><replaceable>schema</replaceable>.<replaceable>func</replaceable>(<replaceable>table</replaceable>)
    </literal>）来覆盖这种选择，但是最好
    不要选择有冲突的名称以避免此类问题。
   </para>
<!-- pgdoc-cn_end sig_en=2cec9b31ba3c191ebfc5cefab00aff97 -->

<!-- pgdoc-cn_start sig_en=04c89fc3493c43e7039ba85c6235077e sig_cn_org=None source=14.1 
   <para>
    Another possible conflict is between variadic and non-variadic functions.
    For instance, it is possible to create both <literal>foo(numeric)</literal> and
    <literal>foo(VARIADIC numeric[])</literal>.  In this case it is unclear which one
    should be matched to a call providing a single numeric argument, such as
    <literal>foo(10.1)</literal>.  The rule is that the function appearing
    earlier in the search path is used, or if the two functions are in the
    same schema, the non-variadic one is preferred.
   </para>
________________________________________________________-->
   <para>
    另一种可能的冲突在于 variadic 和非 variadic 函数之间。例如，可以创建
    <literal>foo(numeric)</literal>和<literal>foo(VARIADIC numeric[])</literal>。
    在这种情况下，对于提供了一个数字参数的调用（例如<literal>foo(10.1)</literal>）
    就不清楚应该匹配哪一个函数。规则是使用在搜索路径中出现得较早的
    函数，或者当两者都在同一个模式中时优先使用非 variadic 的那一个函数。
   </para>
<!-- pgdoc-cn_end sig_en=04c89fc3493c43e7039ba85c6235077e -->

<!-- pgdoc-cn_start sig_en=a0a7d756236a4125d25b891169ee3829 sig_cn_org=None source=14.1 
   <para>
    When overloading C-language functions, there is an additional
    constraint: The C name of each function in the family of
    overloaded functions must be different from the C names of all
    other functions, either internal or dynamically loaded.  If this
    rule is violated, the behavior is not portable.  You might get a
    run-time linker error, or one of the functions will get called
    (usually the internal one).  The alternative form of the
    <literal>AS</literal> clause for the SQL <command>CREATE
    FUNCTION</command> command decouples the SQL function name from
    the function name in the C source code.  For instance:
<programlisting>
CREATE FUNCTION test(int) RETURNS int
    AS '<replaceable>filename</replaceable>', 'test_1arg'
    LANGUAGE C;
CREATE FUNCTION test(int, int) RETURNS int
    AS '<replaceable>filename</replaceable>', 'test_2arg'
    LANGUAGE C;
</programlisting>
    The names of the C functions here reflect one of many possible conventions.
   </para>
________________________________________________________-->
   <para>
    在重载 C 语言函数时有一个额外的约束：重载函数家族中的每一个
    函数的 C 名称必须与其他所有函数的 C 名称不同，不管是内部的
    还是动态载入的。如果这条规则被违背，该行为将不可移植。你可能
    会得到一个运行时链接器错误，或者这些函数之一将被调用（通常
    是内部的那一个）。SQL <command>CREATE
    FUNCTION</command>命令的<literal>AS</literal>子句的另一种形式
    可以把 SQL 函数名和 C 源代码中的函数名分离。例如：
<programlisting>
CREATE FUNCTION test(int) RETURNS int
    AS '<replaceable>filename</replaceable>', 'test_1arg'
    LANGUAGE C;
CREATE FUNCTION test(int, int) RETURNS int
    AS '<replaceable>filename</replaceable>', 'test_2arg'
    LANGUAGE C;
</programlisting>
    这里的 C 函数名称反映了很多种可能的习惯之一。
   </para>
<!-- pgdoc-cn_end sig_en=a0a7d756236a4125d25b891169ee3829 -->
  </sect1>

  <sect1 id="xfunc-volatility">
<!-- pgdoc-cn_start sig_en=eba155e10ddff3731bc8b3521d58b678 sig_cn_org=None source=14.1 
   <title>Function Volatility Categories</title>
________________________________________________________-->
   <title>函数易变性分类</title>
<!-- pgdoc-cn_end sig_en=eba155e10ddff3731bc8b3521d58b678 -->

<!-- pgdoc-cn_start sig_en=07f40c82707b289cc244fecbd68a1dbf sig_cn_org=None source=14.1 
   <indexterm zone="xfunc-volatility">
    <primary>volatility</primary>
    <secondary>functions</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="xfunc-volatility">
    <primary>volatility</primary>
    <secondary>functions</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=07f40c82707b289cc244fecbd68a1dbf -->
<!-- pgdoc-cn_start sig_en=6a913c048e3dfa114979f3fbe3774c6c sig_cn_org=None source=14.1 
   <indexterm zone="xfunc-volatility">
    <primary>VOLATILE</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="xfunc-volatility">
    <primary>VOLATILE</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=6a913c048e3dfa114979f3fbe3774c6c -->
<!-- pgdoc-cn_start sig_en=f59b29f941c652f1942994b07e8c58e3 sig_cn_org=None source=14.1 
   <indexterm zone="xfunc-volatility">
    <primary>STABLE</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="xfunc-volatility">
    <primary>STABLE</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=f59b29f941c652f1942994b07e8c58e3 -->
<!-- pgdoc-cn_start sig_en=70be8a3d13f193236d8e773f13ba2a7f sig_cn_org=None source=14.1 
   <indexterm zone="xfunc-volatility">
    <primary>IMMUTABLE</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="xfunc-volatility">
    <primary>IMMUTABLE</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=70be8a3d13f193236d8e773f13ba2a7f -->

<!-- pgdoc-cn_start sig_en=acbee37a7eb633e58a2f200c43b2e7fb sig_cn_org=None source=14.1 
   <para>
    Every function has a <firstterm>volatility</firstterm> classification, with
    the possibilities being <literal>VOLATILE</literal>, <literal>STABLE</literal>, or
    <literal>IMMUTABLE</literal>.  <literal>VOLATILE</literal> is the default if the
    <link linkend="sql-createfunction"><command>CREATE FUNCTION</command></link>
    command does not specify a category.  The volatility category is a
    promise to the optimizer about the behavior of the function:

   <itemizedlist>
    <listitem>
     <para>
      A <literal>VOLATILE</literal> function can do anything, including modifying
      the database.  It can return different results on successive calls with
      the same arguments.  The optimizer makes no assumptions about the
      behavior of such functions.  A query using a volatile function will
      re-evaluate the function at every row where its value is needed.
     </para>
    </listitem>
    <listitem>
     <para>
      A <literal>STABLE</literal> function cannot modify the database and is
      guaranteed to return the same results given the same arguments
      for all rows within a single statement. This category allows the
      optimizer to optimize multiple calls of the function to a single
      call. In particular, it is safe to use an expression containing
      such a function in an index scan condition. (Since an index scan
      will evaluate the comparison value only once, not once at each
      row, it is not valid to use a <literal>VOLATILE</literal> function in an
      index scan condition.)
     </para>
    </listitem>
    <listitem>
     <para>
      An <literal>IMMUTABLE</literal> function cannot modify the database and is
      guaranteed to return the same results given the same arguments forever.
      This category allows the optimizer to pre-evaluate the function when
      a query calls it with constant arguments.  For example, a query like
      <literal>SELECT ... WHERE x = 2 + 2</literal> can be simplified on sight to
      <literal>SELECT ... WHERE x = 4</literal>, because the function underlying
      the integer addition operator is marked <literal>IMMUTABLE</literal>.
     </para>
    </listitem>
   </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    每一个函数都有一个<firstterm>易变性</firstterm>分类，可能是<literal>VOLATILE</literal>、<literal>STABLE</literal>或者<literal>IMMUTABLE</literal>。
    如果    <link linkend="sql-createfunction"><command>CREATE FUNCTION</command></link>命令没有指定一个分类，则默认是<literal>VOLATILE</literal>。
    易变性分类是给优化器的关于该函数行为的一种承诺：

   <itemizedlist>
    <listitem>
     <para>
      一个<literal>VOLATILE</literal>函数可以做任何事情，包括修改数据库。在
      使用相同的参数连续调用时，它能返回不同的结果。优化器不会对这类函
      数的行为做任何假定。在每一行需要 volatile 函数值时，一个使用 volatile
      函数的查询都会重新计算该函数。
     </para>
    </listitem>
    <listitem>
     <para>
      一个<literal>STABLE</literal>函数不能修改数据库并且被确保对一个语句中
      的所有行用给定的相同参数返回相同的结果。这种分类允许优化器把该函
      数的多个调用优化成一个调用。特别是，在一个索引扫描条件中使用包含
      这样一个函数的表达式是安全的（因为一次索引扫描只会计算一次比较值，
      而不是为每一行都计算一次，在一个索引扫描条件中不能使用
      <literal>VOLATILE</literal>函数）。
     </para>
    </listitem>
    <listitem>
     <para>
      一个<literal>IMMUTABLE</literal>函数不能修改数据库并且被确保用相同的参数
      永远返回相同的结果。这种分类允许优化器在一个查询用常量参数调用该函数
      时提前计算该函数。例如，一个
      <literal>SELECT ... WHERE x = 2 + 2</literal>这样的查询可以被简化为
      <literal>SELECT ... WHERE x = 4</literal>，因为整数加法操作符底层的函数被
      标记为<literal>IMMUTABLE</literal>。
     </para>
    </listitem>
   </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=acbee37a7eb633e58a2f200c43b2e7fb -->

<!-- pgdoc-cn_start sig_en=fb5c5c07153c2f7d0e434c11673686ce sig_cn_org=None source=14.1 
   <para>
    For best optimization results, you should label your functions with the
    strictest volatility category that is valid for them.
   </para>
________________________________________________________-->
   <para>
    为了最好的优化结果，你应该把函数标记为对它们合法的易变性分类中最严格
    的那种。
   </para>
<!-- pgdoc-cn_end sig_en=fb5c5c07153c2f7d0e434c11673686ce -->

<!-- pgdoc-cn_start sig_en=3b74c4c119a163a05b02cef219ed0b24 sig_cn_org=None source=14.1 
   <para>
    Any function with side-effects <emphasis>must</emphasis> be labeled
    <literal>VOLATILE</literal>, so that calls to it cannot be optimized away.
    Even a function with no side-effects needs to be labeled
    <literal>VOLATILE</literal> if its value can change within a single query;
    some examples are <literal>random()</literal>, <literal>currval()</literal>,
    <literal>timeofday()</literal>.
   </para>
________________________________________________________-->
   <para>
    任何带有副作用的函数<emphasis>必须</emphasis>被标记为<literal>VOLATILE</literal>，
    这样对它的调用就不能被优化掉。甚至如果一个函数的值在一个查询中会
    变化，即使它没有副作用也需要被标记为<literal>VOLATILE</literal>。这样的
    例子有<literal>random()</literal>、<literal>currval()</literal>、
    <literal>timeofday()</literal>等。
   </para>
<!-- pgdoc-cn_end sig_en=3b74c4c119a163a05b02cef219ed0b24 -->

<!-- pgdoc-cn_start sig_en=fcafb4f208fd1b841796a61d49226e66 sig_cn_org=None source=14.1 
   <para>
    Another important example is that the <function>current_timestamp</function>
    family of functions qualify as <literal>STABLE</literal>, since their values do
    not change within a transaction.
   </para>
________________________________________________________-->
   <para>
    另一种重要的例子是<function>current_timestamp</function>家族的函数有资格
    被标记为<literal>STABLE</literal>，因为它们的值在一个事务中不会改变。
   </para>
<!-- pgdoc-cn_end sig_en=fcafb4f208fd1b841796a61d49226e66 -->

<!-- pgdoc-cn_start sig_en=0e5b67c12061e2057b74636e0a17912c sig_cn_org=None source=14.1 
   <para>
    There is relatively little difference between <literal>STABLE</literal> and
    <literal>IMMUTABLE</literal> categories when considering simple interactive
    queries that are planned and immediately executed: it doesn't matter
    a lot whether a function is executed once during planning or once during
    query execution startup.  But there is a big difference if the plan is
    saved and reused later.  Labeling a function <literal>IMMUTABLE</literal> when
    it really isn't might allow it to be prematurely folded to a constant during
    planning, resulting in a stale value being re-used during subsequent uses
    of the plan.  This is a hazard when using prepared statements or when
    using function languages that cache plans (such as
    <application>PL/pgSQL</application>).
   </para>
________________________________________________________-->
   <para>
    在考虑先规划然后立即执行的简单交互式查询时，在<literal>STABLE</literal>和
    <literal>IMMUTABLE</literal>分类间的区别相对较小：一个函数是在规划时只
    执行一次还是在查询执行开始期间只执行一次没有太大关系。但是如果计划
    被保存下来然后在后面被重用，区别就大了。如果在不允许过早把一个函数
    变成规划期间的一个常数时把它标记为<literal>IMMUTABLE</literal>，会导致
    在后续重用该计划时用到一个陈旧的值。当使用预备语句或者使用会缓存计
    划的函数语言（<application>PL/pgSQL</application>）时，这就会是一种灾难。
   </para>
<!-- pgdoc-cn_end sig_en=0e5b67c12061e2057b74636e0a17912c -->

<!-- pgdoc-cn_start sig_en=3316f5397f747fcd7494a0572c20361a sig_cn_org=None source=14.1 
   <para>
    For functions written in SQL or in any of the standard procedural
    languages, there is a second important property determined by the
    volatility category, namely the visibility of any data changes that have
    been made by the SQL command that is calling the function.  A
    <literal>VOLATILE</literal> function will see such changes, a <literal>STABLE</literal>
    or <literal>IMMUTABLE</literal> function will not.  This behavior is implemented
    using the snapshotting behavior of MVCC (see <xref linkend="mvcc"/>):
    <literal>STABLE</literal> and <literal>IMMUTABLE</literal> functions use a snapshot
    established as of the start of the calling query, whereas
    <literal>VOLATILE</literal> functions obtain a fresh snapshot at the start of
    each query they execute.
   </para>
________________________________________________________-->
   <para>
    对于用 SQL 或者其他任何标准过程语言编写的函数，还有第二种由易变性分类
    决定的特性，即由调用该函数的 SQL 命令所作的数据修改的可见性。
    <literal>VOLATILE</literal>函数将看到这些更改，<literal>STABLE</literal>
    或者<literal>IMMUTABLE</literal>函数则看不到。这种行为使用 MVCC 的快照
    行为（见<xref linkend="mvcc"/>）实现：<literal>STABLE</literal>和
    <literal>IMMUTABLE</literal>函数使用一个在调用查询开始时建立的快照，而
    <literal>VOLATILE</literal>函数在它们执行的每一个查询的开始都获得一个新鲜
    的快照。
   </para>
<!-- pgdoc-cn_end sig_en=3316f5397f747fcd7494a0572c20361a -->

   <note>
<!-- pgdoc-cn_start sig_en=7741121aec9cd5a0a8aaa7060614779e sig_cn_org=None source=14.1 
    <para>
     Functions written in C can manage snapshots however they want, but it's
     usually a good idea to make C functions work this way too.
    </para>
________________________________________________________-->
    <para>
     用 C 编写的函数按照它们自己需要的方式管理快照，但是通常最好
     让 C 函数也按照上面的方式来。
    </para>
<!-- pgdoc-cn_end sig_en=7741121aec9cd5a0a8aaa7060614779e -->
   </note>

<!-- pgdoc-cn_start sig_en=73147a9ad9261a9bfa84afde42b104ec sig_cn_org=None source=14.1 
   <para>
    Because of this snapshotting behavior,
    a function containing only <command>SELECT</command> commands can safely be
    marked <literal>STABLE</literal>, even if it selects from tables that might be
    undergoing modifications by concurrent queries.
    <productname>PostgreSQL</productname> will execute all commands of a
    <literal>STABLE</literal> function using the snapshot established for the
    calling query, and so it will see a fixed view of the database throughout
    that query.
   </para>
________________________________________________________-->
   <para>
    由于这种快照行为，一个只包含<command>SELECT</command>命令的函数可以被
    安全地标记为<literal>STABLE</literal>，即便它选择的表可能正在被并发查询所
    修改。<productname>PostgreSQL</productname>将使用为调用查询所
    建立的快照来执行<literal>STABLE</literal>函数中的所有命令，因此它将在整个
    查询期间看到一种数据库的固定视图。
   </para>
<!-- pgdoc-cn_end sig_en=73147a9ad9261a9bfa84afde42b104ec -->

<!-- pgdoc-cn_start sig_en=1c46f6b8f660d05cf43d8c8f7fb10ba9 sig_cn_org=None source=14.1 
   <para>
    The same snapshotting behavior is used for <command>SELECT</command> commands
    within <literal>IMMUTABLE</literal> functions.  It is generally unwise to select
    from database tables within an <literal>IMMUTABLE</literal> function at all,
    since the immutability will be broken if the table contents ever change.
    However, <productname>PostgreSQL</productname> does not enforce that you
    do not do that.
   </para>
________________________________________________________-->
   <para>
    对<literal>IMMUTABLE</literal>函数中的<command>SELECT</command>使用了相同
    的快照行为。通常在一个<literal>IMMUTABLE</literal>函数中从数据库表选择是
    不明智的，因为如果表内容变化就会破坏不变性。不过，
    <productname>PostgreSQL</productname>不会强制不让你这样做。
   </para>
<!-- pgdoc-cn_end sig_en=1c46f6b8f660d05cf43d8c8f7fb10ba9 -->

<!-- pgdoc-cn_start sig_en=6527edb645a33efe0f4b1f792ada3ddc sig_cn_org=None source=14.1 
   <para>
    A common error is to label a function <literal>IMMUTABLE</literal> when its
    results depend on a configuration parameter.  For example, a function
    that manipulates timestamps might well have results that depend on the
    <xref linkend="guc-timezone"/> setting.  For safety, such functions should
    be labeled <literal>STABLE</literal> instead.
   </para>
________________________________________________________-->
   <para>
    一种常见的错误是当一个函数的结果依赖于一个配置参数时把它标记为
    <literal>IMMUTABLE</literal>。例如，一个操纵时间戳的函数有可能结果
    依赖于<xref linkend="guc-timezone"/>设置。为了安全起见，这类
    函数应该被标记为<literal>STABLE</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=6527edb645a33efe0f4b1f792ada3ddc -->

   <note>
<!-- pgdoc-cn_start sig_en=c2a95e07b553391eb3021721e8dc3375 sig_cn_org=None source=14.1 
    <para>
     <productname>PostgreSQL</productname> requires that <literal>STABLE</literal>
     and <literal>IMMUTABLE</literal> functions contain no SQL commands other
     than <command>SELECT</command> to prevent data modification.
     (This is not a completely bulletproof test, since such functions could
     still call <literal>VOLATILE</literal> functions that modify the database.
     If you do that, you will find that the <literal>STABLE</literal> or
     <literal>IMMUTABLE</literal> function does not notice the database changes
     applied by the called function, since they are hidden from its snapshot.)
    </para>
________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>要求<literal>STABLE</literal>
     和<literal>IMMUTABLE</literal>函数中不包含非<command>SELECT</command>
     的 SQL 命令以阻止数据修改（这也不是完全万无一失，因为这类函数还可以
     调用修改数据库的<literal>VOLATILE</literal>函数。如果那样做，你将发现
     该<literal>STABLE</literal>或<literal>IMMUTABLE</literal>函数不会发现由被调
     用函数所作的数据库改变，因为它们对它的快照不可见）。
    </para>
<!-- pgdoc-cn_end sig_en=c2a95e07b553391eb3021721e8dc3375 -->
   </note>
  </sect1>

  <sect1 id="xfunc-pl">
<!-- pgdoc-cn_start sig_en=a5bb5dceb91c7429328a84a9d75e26d1 sig_cn_org=None source=14.1 
   <title>Procedural Language Functions</title>
________________________________________________________-->
   <title>过程语言函数</title>
<!-- pgdoc-cn_end sig_en=a5bb5dceb91c7429328a84a9d75e26d1 -->

<!-- pgdoc-cn_start sig_en=d640fffee7f3e55cce0cec9f28d40f6f sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> allows user-defined functions
    to be written in other languages besides SQL and C.  These other
    languages are generically called <firstterm>procedural
    languages</firstterm> (<acronym>PL</acronym>s).
    Procedural languages aren't built into the
    <productname>PostgreSQL</productname> server; they are offered
    by loadable modules.
    See <xref linkend="xplang"/> and following chapters for more
    information.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>允许用除 SQL 和 C 之外
    的语言编写用户定义的函数。这些语言通常被称为<firstterm>过程语言</firstterm>（<acronym>PL</acronym>）。
    过程语言并不内建在<productname>PostgreSQL</productname>服务器中，
    它们通过可装载模块提供。更多信息请见<xref linkend="xplang"/>以及接下来的
    章节。
   </para>
<!-- pgdoc-cn_end sig_en=d640fffee7f3e55cce0cec9f28d40f6f -->
  </sect1>

  <sect1 id="xfunc-internal">
<!-- pgdoc-cn_start sig_en=6a74a942283b419abc2f45a4731f6ad2 sig_cn_org=None source=14.1 
   <title>Internal Functions</title>
________________________________________________________-->
   <title>内部函数</title>
<!-- pgdoc-cn_end sig_en=6a74a942283b419abc2f45a4731f6ad2 -->

<!-- pgdoc-cn_start sig_en=e778610e75479426d17c643fb8412eba sig_cn_org=None source=14.1 
   <indexterm zone="xfunc-internal"><primary>function</primary><secondary>internal</secondary></indexterm>
________________________________________________________-->
   <indexterm zone="xfunc-internal"><primary>function</primary><secondary>internal</secondary></indexterm>
<!-- pgdoc-cn_end sig_en=e778610e75479426d17c643fb8412eba -->

<!-- pgdoc-cn_start sig_en=bb75e86a69c6b9a3299dfa1c8390ee31 sig_cn_org=None source=14.1 
   <para>
    Internal functions are functions written in C that have been statically
    linked into the <productname>PostgreSQL</productname> server.
    The <quote>body</quote> of the function definition
    specifies the C-language name of the function, which need not be the
    same as the name being declared for SQL use.
    (For reasons of backward compatibility, an empty body
    is accepted as meaning that the C-language function name is the
    same as the SQL name.)
   </para>
________________________________________________________-->
   <para>
    内部函数由 C 编写并且已经被静态链接到<productname>PostgreSQL</productname>
    服务器中。该函数定义的<quote>主体</quote>指定该函数的 C 语言名称，
    它必须和声明 SQL 函数所用的名称一样（为了向后兼容性的原因，也接受空
    主体，那时会认为 C 语言函数名与 SQL 函数名相同）。
   </para>
<!-- pgdoc-cn_end sig_en=bb75e86a69c6b9a3299dfa1c8390ee31 -->

<!-- pgdoc-cn_start sig_en=4f43be6b46468ea11620bd88e12448a6 sig_cn_org=None source=14.1 
   <para>
    Normally, all internal functions present in the
    server are declared during the initialization of the database cluster
    (see <xref linkend="creating-cluster"/>),
    but a user could use <command>CREATE FUNCTION</command>
    to create additional alias names for an internal function.
    Internal functions are declared in <command>CREATE FUNCTION</command>
    with language name <literal>internal</literal>.  For instance, to
    create an alias for the <function>sqrt</function> function:
<programlisting>
CREATE FUNCTION square_root(double precision) RETURNS double precision
    AS 'dsqrt'
    LANGUAGE internal
    STRICT;
</programlisting>
    (Most internal functions expect to be declared <quote>strict</quote>.)
   </para>
________________________________________________________-->
   <para>
    通常，所有存在于服务器中的内部函数都在数据库集簇的初始化（见
    <xref linkend="creating-cluster"/>）期间被声明，但是用户可以使用
    <command>CREATE FUNCTION</command>为一个内部函数创建
    额外的别名。在<command>CREATE FUNCTION</command>中用
    语言名<literal>internal</literal>来声明内部函数。例如，要为
    <function>sqrt</function>函数创建一个别名：
<programlisting>
CREATE FUNCTION square_root(double precision) RETURNS double precision
    AS 'dsqrt'
    LANGUAGE internal
    STRICT;
</programlisting>
    （大部分内部函数应该被声明为<quote>严格</quote>）。
   </para>
<!-- pgdoc-cn_end sig_en=4f43be6b46468ea11620bd88e12448a6 -->

   <note>
<!-- pgdoc-cn_start sig_en=85fda003c578c7f691b202e3a585927a sig_cn_org=None source=14.1 
    <para>
     Not all <quote>predefined</quote> functions are
     <quote>internal</quote> in the above sense.  Some predefined
     functions are written in SQL.
    </para>
________________________________________________________-->
    <para>
     上述场景中并非所有<quote>预定义</quote>的函数都是
     <quote>内部</quote>函数。有些预定义的函数由 SQL
     编写。
    </para>
<!-- pgdoc-cn_end sig_en=85fda003c578c7f691b202e3a585927a -->
   </note>
  </sect1>

  <sect1 id="xfunc-c">
<!-- pgdoc-cn_start sig_en=1eb3b45f3c648553d80f7e2b303b76e7 sig_cn_org=None source=14.1 
   <title>C-Language Functions</title>
________________________________________________________-->
   <title>C 语言函数</title>
<!-- pgdoc-cn_end sig_en=1eb3b45f3c648553d80f7e2b303b76e7 -->

<!-- pgdoc-cn_start sig_en=48395a68466372f15e7e50427b0493e9 sig_cn_org=None source=14.1 
   <indexterm zone="xfunc-c">
    <primary>function</primary>
    <secondary>user-defined</secondary>
    <tertiary>in C</tertiary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="xfunc-c">
    <primary>function</primary>
    <secondary>user-defined</secondary>
    <tertiary>in C</tertiary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=48395a68466372f15e7e50427b0493e9 -->

<!-- pgdoc-cn_start sig_en=9c7e774e353f40679e975b87b2e5cae8 sig_cn_org=None source=14.1 
   <para>
    User-defined functions can be written in C (or a language that can
    be made compatible with C, such as C++).  Such functions are
    compiled into dynamically loadable objects (also called shared
    libraries) and are loaded by the server on demand.  The dynamic
    loading feature is what distinguishes <quote>C language</quote> functions
    from <quote>internal</quote> functions &mdash; the actual coding conventions
    are essentially the same for both.  (Hence, the standard internal
    function library is a rich source of coding examples for user-defined
    C functions.)
   </para>
________________________________________________________-->
   <para>
    用户定义的函数可以用 C 编写（或者可以与 C 兼容的语言，例如 C++）。
    这类函数被编译成动态载入对象（也被称为共享库）并且由服务器在
    需要时载入。动态载入是把<quote>C语言</quote>函数和
    <quote>内部</quote>函数区分开的特性 &mdash; 两者真正的编码习惯
    实际上是一样的（因此，标准的内部函数库是用户定义的 C 函数很好
    的源代码实例）。
   </para>
<!-- pgdoc-cn_end sig_en=9c7e774e353f40679e975b87b2e5cae8 -->

<!-- pgdoc-cn_start sig_en=a4ea3cee88a1ba91327a7ccb35f11723 sig_cn_org=None source=14.1 
   <para>
    Currently only one calling convention is used for C functions
    (<quote>version 1</quote>). Support for that calling convention is
    indicated by writing a <literal>PG_FUNCTION_INFO_V1()</literal> macro
    call for the function, as illustrated below.
   </para>
________________________________________________________-->
   <para>
    当前仅有一种调用约定被用于C函数（<quote>版本1</quote>）。如下文所示，为函数编写一个<literal>PG_FUNCTION_INFO_V1()</literal>宏就能指示对该调用约定的支持。
   </para>
<!-- pgdoc-cn_end sig_en=a4ea3cee88a1ba91327a7ccb35f11723 -->

  <sect2 id="xfunc-c-dynload">
<!-- pgdoc-cn_start sig_en=e1868f6d12361828a616fce88a608806 sig_cn_org=None source=14.1 
   <title>Dynamic Loading</title>
________________________________________________________-->
   <title>动态载入</title>
<!-- pgdoc-cn_end sig_en=e1868f6d12361828a616fce88a608806 -->

<!-- pgdoc-cn_start sig_en=0fc2539cdba6c61751fd9466f0931852 sig_cn_org=None source=14.1 
   <indexterm zone="xfunc-c-dynload">
    <primary>dynamic loading</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="xfunc-c-dynload">
    <primary>动态载入</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=0fc2539cdba6c61751fd9466f0931852 -->

<!-- pgdoc-cn_start sig_en=c2ecb0abf9897d19c384e0b51fb18313 sig_cn_org=None source=14.1 
   <para>
    The first time a user-defined function in a particular
    loadable object file is called in a session,
    the dynamic loader loads that object file into memory so that the
    function can be called.  The <command>CREATE FUNCTION</command>
    for a user-defined C function must therefore specify two pieces of
    information for the function: the name of the loadable
    object file, and the C name (link symbol) of the specific function to call
    within that object file.  If the C name is not explicitly specified then
    it is assumed to be the same as the SQL function name.
   </para>
________________________________________________________-->
   <para>
    在一个会话中第一次调用一个特定可载入对象文件中的用户定义函数时，
    动态载入器会把那个对象文件载入到内存以便该函数被调用。因此用户
    定义的 C 函数的<command>CREATE FUNCTION</command>必须
    为该函数指定两块信息：可载入对象文件的名称，以及要在该对象文件中
    调用的特定函数的 C 名称（链接符号）。如果没有显式指定 C 名称，则
    它被假定为和 SQL 函数名相同。
   </para>
<!-- pgdoc-cn_end sig_en=c2ecb0abf9897d19c384e0b51fb18313 -->

<!-- pgdoc-cn_start sig_en=34301dea99989db16ab0550e408ab7d5 sig_cn_org=None source=14.1 
   <para>
    The following algorithm is used to locate the shared object file
    based on the name given in the <command>CREATE FUNCTION</command>
    command:

    <orderedlist>
     <listitem>
      <para>
       If the name is an absolute path, the given file is loaded.
      </para>
     </listitem>

     <listitem>
      <para>
       If the name starts with the string <literal>$libdir</literal>,
       that part is replaced by the <productname>PostgreSQL</productname> package
        library directory
       name, which is determined at build time.<indexterm><primary>$libdir</primary></indexterm>
      </para>
     </listitem>

     <listitem>
      <para>
       If the name does not contain a directory part, the file is
       searched for in the path specified by the configuration variable
       <xref linkend="guc-dynamic-library-path"/>.<indexterm><primary>dynamic_library_path</primary></indexterm>
      </para>
     </listitem>

     <listitem>
      <para>
       Otherwise (the file was not found in the path, or it contains a
       non-absolute directory part), the dynamic loader will try to
       take the name as given, which will most likely fail.  (It is
       unreliable to depend on the current working directory.)
      </para>
     </listitem>
    </orderedlist>

    If this sequence does not work, the platform-specific shared
    library file name extension (often <filename>.so</filename>) is
    appended to the given name and this sequence is tried again.  If
    that fails as well, the load will fail.
   </para>
________________________________________________________-->
   <para>
    下面的算法被用来基于<command>CREATE FUNCTION</command>
    命令中给定的名称来定位共享对象文件：

    <orderedlist>
     <listitem>
      <para>
       如果名称是一个绝对路径，则载入给定的文件。
      </para>
     </listitem>

     <listitem>
      <para>
       如果该名称以字符串<literal>$libdir</literal>开始，那么这一部分会被
       <productname>PostgreSQL</productname>包的库目录名（在编译时确定）替换。
       <indexterm><primary>$libdir</primary></indexterm>
      </para>
     </listitem>

     <listitem>
      <para>
       如果该名称不包含目录部分，会在配置变量
       <xref linkend="guc-dynamic-library-path"/>指定的路径中搜索该
       文件。<indexterm><primary>dynamic_library_path</primary></indexterm>
      </para>
     </listitem>

     <listitem>
      <para>
       否则（在该路径中没找到该文件，或者它包含一个非绝对目录），
       动态载入器将尝试接受给定的名称，这大部分会导致失败（依赖
       当前工作目录是不可靠的）。
      </para>
     </listitem>
    </orderedlist>

    如果这个序列不起作用，会把平台相关的共享库文件名扩展（通常是
    <filename>.so</filename>）追加到给定的名称并且再次尝试上述
    的过程。如果还是失败，则载入失败。
   </para>
<!-- pgdoc-cn_end sig_en=34301dea99989db16ab0550e408ab7d5 -->

<!-- pgdoc-cn_start sig_en=80fc5f2adb59b35d88a3947749099dbf sig_cn_org=None source=14.1 
   <para>
    It is recommended to locate shared libraries either relative to
    <literal>$libdir</literal> or through the dynamic library path.
    This simplifies version upgrades if the new installation is at a
    different location.  The actual directory that
    <literal>$libdir</literal> stands for can be found out with the
    command <literal>pg_config -&minus;pkglibdir</literal>.
   </para>
________________________________________________________-->
   <para>
    我们推荐相对于<literal>$libdir</literal>或者通过动态库路径来
    定位共享库。如果升级版本时新的安装在一个不同的位置，则可以
    简化升级过程。<literal>$libdir</literal>实际表示的目录可以用
    命令<literal>pg_config --pkglibdir</literal>来找到。
   </para>
<!-- pgdoc-cn_end sig_en=80fc5f2adb59b35d88a3947749099dbf -->

<!-- pgdoc-cn_start sig_en=f5e102e8c8332254bf00d6b2b24c082d sig_cn_org=None source=14.1 
   <para>
    The user ID the <productname>PostgreSQL</productname> server runs
    as must be able to traverse the path to the file you intend to
    load.  Making the file or a higher-level directory not readable
    and/or not executable by the <systemitem>postgres</systemitem>
    user is a common mistake.
   </para>
________________________________________________________-->
   <para>
    用于运行<productname>PostgreSQL</productname>服务器的
    用户 ID 必须能够通过要载入文件的路径。常见的错误是把文件或
    更高层的目录变得对<systemitem>postgres</systemitem>用户
    不可读或者不可执行。
   </para>
<!-- pgdoc-cn_end sig_en=f5e102e8c8332254bf00d6b2b24c082d -->

<!-- pgdoc-cn_start sig_en=e2b20de787d7819b8d656c28875905ce sig_cn_org=None source=14.1 
   <para>
    In any case, the file name that is given in the
    <command>CREATE FUNCTION</command> command is recorded literally
    in the system catalogs, so if the file needs to be loaded again
    the same procedure is applied.
   </para>
________________________________________________________-->
   <para>
    在任何情况下，<command>CREATE FUNCTION</command>命令
    中给定的文件名会被原封不动地记录在系统目录中，这样如果需要再次
    载入该文件则会应用同样的过程。
   </para>
<!-- pgdoc-cn_end sig_en=e2b20de787d7819b8d656c28875905ce -->

   <note>
<!-- pgdoc-cn_start sig_en=04c55e8cbfdd9813262cc16a1d8345bf sig_cn_org=None source=14.1 
    <para>
     <productname>PostgreSQL</productname> will not compile a C function
     automatically.  The object file must be compiled before it is referenced
     in a <command>CREATE
     FUNCTION</command> command.  See <xref linkend="dfunc"/> for additional
     information.
    </para>
________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>不会自动编译 C 函数。在
     从<command>CREATE FUNCTION</command>命令中引用对象文件
     之前，它必须先被编译好。更多信息请见<xref linkend="dfunc"/>。
    </para>
<!-- pgdoc-cn_end sig_en=04c55e8cbfdd9813262cc16a1d8345bf -->
   </note>

<!-- pgdoc-cn_start sig_en=65ec7cd634c98c9e8efab6d157663ac8 sig_cn_org=None source=14.1 
   <indexterm zone="xfunc-c-dynload">
    <primary>magic block</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="xfunc-c-dynload">
    <primary>magic block</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=65ec7cd634c98c9e8efab6d157663ac8 -->

<!-- pgdoc-cn_start sig_en=f8f588a79d058531615f23b98e5d8b8b sig_cn_org=None source=14.1 
   <para>
    To ensure that a dynamically loaded object file is not loaded into an
    incompatible server, <productname>PostgreSQL</productname> checks that the
    file contains a <quote>magic block</quote> with the appropriate contents.
    This allows the server to detect obvious incompatibilities, such as code
    compiled for a different major version of
    <productname>PostgreSQL</productname>. To include a magic block,
    write this in one (and only one) of the module source files, after having
    included the header <filename>fmgr.h</filename>:

<programlisting>
PG_MODULE_MAGIC;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    为了确保动态载入对象文件不会被载入到一个不兼容的服务器，
    <productname>PostgreSQL</productname>会检查该文件是否包含一个
    带有合适内容的<quote>magic block</quote>。这允许服务器检测到明显的不兼
    容，例如为不同<productname>PostgreSQL</productname>主版本编译
    的代码。要包括一个 magic block，在写上包括
    头文件<filename>fmgr.h</filename>的语句之后，在该模块的源文件之一（并且只
    能在其中一个）中写上这些：

<programlisting>
PG_MODULE_MAGIC;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=f8f588a79d058531615f23b98e5d8b8b -->

<!-- pgdoc-cn_start sig_en=46c9363eea3c3f6914f5bcb73296e7d6 sig_cn_org=None source=14.1 
   <para>
    After it is used for the first time, a dynamically loaded object
    file is retained in memory.  Future calls in the same session to
    the function(s) in that file will only incur the small overhead of
    a symbol table lookup.  If you need to force a reload of an object
    file, for example after recompiling it, begin a fresh session.
   </para>
________________________________________________________-->
   <para>
    在被第一次使用后，动态载入对象文件会留在内存中。在同一个会话中
    对该函数未来的调用将只会消耗很小的负荷进行符号表查找。如果需要
    重新载入一个对象文件（例如重新编译以后），需要开始一个新的会话。
   </para>
<!-- pgdoc-cn_end sig_en=46c9363eea3c3f6914f5bcb73296e7d6 -->

<!-- pgdoc-cn_start sig_en=55dabf01ee02faf8050f001dbc1b0a6a sig_cn_org=None source=14.1 
   <indexterm zone="xfunc-c-dynload">
    <primary>_PG_init</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="xfunc-c-dynload">
    <primary>_PG_init</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=55dabf01ee02faf8050f001dbc1b0a6a -->
<!-- pgdoc-cn_start sig_en=796080e75fb120cecd59fd3e7bf8be45 sig_cn_org=None source=14.1 
   <indexterm zone="xfunc-c-dynload">
    <primary>library initialization function</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="xfunc-c-dynload">
    <primary>库初始化函数</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=796080e75fb120cecd59fd3e7bf8be45 -->

<!-- pgdoc-cn_start sig_en=e71975c317401edf809c9b0826519c84 sig_cn_org=fb269c83c47d3611e6e310f61c69a039 source=15.7 
   <para>
    Optionally, a dynamically loaded file can contain an initialization
    function.  If the file includes a function named
    <function>_PG_init</function>, that function will be called immediately after
    loading the file.  The function receives no parameters and should
    return void.  There is presently no way to unload a dynamically loaded file.
   </para>
________________________________________________________-->
   <para>
    可选地，一个动态加载的文件可以包含一个初始化函数。如果文件包含一个名为
    <function>_PG_init</function>的函数，那个函数将在加载文件后立即被调用。
    该函数不接收任何参数，应该返回void。目前没有办法卸载一个动态加载的文件。
   </para>
<!-- pgdoc-cn_end sig_en=e71975c317401edf809c9b0826519c84 -->

  </sect2>

   <sect2 id="xfunc-c-basetype">
<!-- pgdoc-cn_start sig_en=933c54f24c2c6b065b1e9bc9e29ab53a sig_cn_org=None source=14.1 
    <title>Base Types in C-Language Functions</title>
________________________________________________________-->
    <title>C 语言函数中的基本类型</title>
<!-- pgdoc-cn_end sig_en=933c54f24c2c6b065b1e9bc9e29ab53a -->

<!-- pgdoc-cn_start sig_en=edd7bcd56686b1a2381e4189750700d9 sig_cn_org=None source=14.1 
    <indexterm zone="xfunc-c-basetype">
     <primary>data type</primary>
     <secondary>internal organization</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="xfunc-c-basetype">
     <primary>数据类型</primary>
     <secondary>内部组织</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=edd7bcd56686b1a2381e4189750700d9 -->

<!-- pgdoc-cn_start sig_en=a1eda33e2ec261885f079ca0e5e371ae sig_cn_org=None source=14.1 
    <para>
     To know how to write C-language functions, you need to know how
     <productname>PostgreSQL</productname> internally represents base
     data types and how they can be passed to and from functions.
     Internally, <productname>PostgreSQL</productname> regards a base
     type as a <quote>blob of memory</quote>.  The user-defined
     functions that you define over a type in turn define the way that
     <productname>PostgreSQL</productname> can operate on it.  That
     is, <productname>PostgreSQL</productname> will only store and
     retrieve the data from disk and use your user-defined functions
     to input, process, and output the data.
    </para>
________________________________________________________-->
    <para>
     要了解如何编写 C 语言函数，你需要了解
     <productname>PostgreSQL</productname>如何在内部表达基本数据类型
     以及如何与函数传递它们。在内部，
     <productname>PostgreSQL</productname>把一个基本类型认为是
     <quote>一团内存</quote>。在类型上定义的用户定义函数说明了
     <productname>PostgreSQL</productname>在该类型上操作的方式。也就
     是说，<productname>PostgreSQL</productname>将只负责把数据存在磁盘以
     及从磁盘检索数据，而使用你的用户定义函数来输入、处理和输出该数据。
    </para>
<!-- pgdoc-cn_end sig_en=a1eda33e2ec261885f079ca0e5e371ae -->

<!-- pgdoc-cn_start sig_en=ddf45bf22b368aac5ab9dd43f801a1d9 sig_cn_org=None source=14.1 
    <para>
     Base types can have one of three internal formats:

     <itemizedlist>
      <listitem>
       <para>
        pass by value, fixed-length
       </para>
      </listitem>
      <listitem>
       <para>
        pass by reference, fixed-length
       </para>
      </listitem>
      <listitem>
       <para>
        pass by reference, variable-length
       </para>
      </listitem>
     </itemizedlist>
    </para>
________________________________________________________-->
    <para>
     基本类型可以有三种内部格式之一：

     <itemizedlist>
      <listitem>
       <para>
        传值，定长
       </para>
      </listitem>
      <listitem>
       <para>
        传引用，定长
       </para>
      </listitem>
      <listitem>
       <para>
        串引用，变长
       </para>
      </listitem>
     </itemizedlist>
    </para>
<!-- pgdoc-cn_end sig_en=ddf45bf22b368aac5ab9dd43f801a1d9 -->

<!-- pgdoc-cn_start sig_en=1eb64666ca98103ef9cd73bdecf176e5 sig_cn_org=None source=14.1 
    <para>
     By-value  types  can  only be 1, 2, or 4 bytes in length
     (also 8 bytes, if <literal>sizeof(Datum)</literal> is 8 on your machine).
     You should be careful to define your types such that they will be the
     same size (in bytes) on all architectures.  For example, the
     <literal>long</literal> type is dangerous because it is 4 bytes on some
     machines and 8 bytes on others, whereas <type>int</type> type is 4 bytes
     on most Unix machines.  A reasonable implementation of the
     <type>int4</type> type on Unix machines might be:

<programlisting>
/* 4-byte integer, passed by value */
typedef int int4;
</programlisting>

     (The actual PostgreSQL C code calls this type <type>int32</type>, because
     it is a convention in C that <type>int<replaceable>XX</replaceable></type>
     means <replaceable>XX</replaceable> <emphasis>bits</emphasis>.  Note
     therefore also that the C type <type>int8</type> is 1 byte in size.  The
     SQL type <type>int8</type> is called <type>int64</type> in C.  See also
     <xref linkend="xfunc-c-type-table"/>.)
    </para>
________________________________________________________-->
    <para>
     传值类型在长度上只能是 1、2 或 4 字节（如果你的机器上
     <literal>sizeof(Datum)</literal>是 8，则还有 8 字节）。你应当小心地
     定义你的类型以便它们在所有的架构上都是相同的尺寸（字节）。例如，
     <literal>long</literal>类型很危险，因为它在某些机器上是 4 字节但在
     另外一些机器上是 8 字节，而<type>int</type>类型在大部分 Unix 机器
     上都是 4 字节。在 Unix 机器上<type>int4</type>类型一种合理的实现
     可能是：

<programlisting>
/* 4 字节整数，传值 */
typedef int int4;
</programlisting>

     （实际的 PostgreSQL C 代码会把这种类型称为<type>int32</type>，因为
     C 中的习惯是<type>int<replaceable>XX</replaceable></type>
     表示<replaceable>XX</replaceable> <emphasis>位</emphasis>。注意
     因此还有尺寸为 1 字节的 C 类型<type>int8</type>。SQL 类型
     <type>int8</type>在 C 中被称为<type>int64</type>。另见
     <xref linkend="xfunc-c-type-table"/>）。
    </para>
<!-- pgdoc-cn_end sig_en=1eb64666ca98103ef9cd73bdecf176e5 -->

<!-- pgdoc-cn_start sig_en=7913a5053758f0ae9f782f6bc5bf3ed9 sig_cn_org=None source=14.1 
    <para>
     On  the  other hand, fixed-length types of any size can
     be passed by-reference.  For example, here is a  sample
     implementation of a <productname>PostgreSQL</productname> type:

<programlisting>
/* 16-byte structure, passed by reference */
typedef struct
{
    double  x, y;
} Point;
</programlisting>

     Only  pointers  to  such types can be used when passing
     them in and out of <productname>PostgreSQL</productname> functions.
     To return a value of such a type, allocate the right amount of
     memory with <literal>palloc</literal>, fill in the allocated memory,
     and return a pointer to it.  (Also, if you just want to return the
     same value as one of your input arguments that's of the same data type,
     you can skip the extra <literal>palloc</literal> and just return the
     pointer to the input value.)
    </para>
________________________________________________________-->
    <para>
     在另一方面，任何尺寸的定长类型可以用传引用的方法传递。例如，这里有一种
     <productname>PostgreSQL</productname>类型的实现示例：

<programlisting>
/* 16 字节结构，传引用 */
typedef struct
{
    double  x, y;
} Point;
</programlisting>

     在<productname>PostgreSQL</productname>函数中传进或传出这种
     类型时，只能使用指向这种类型的指针。要返回这样一种类型的值，用
     <literal>palloc</literal>分配正确的内存量，然后填充分配好的内存，
     并且返回一个指向该内存的指针（还有，如果只想返回与具有相同数据类型的
     一个输入参数相同的值，可以跳过额外的<literal>palloc</literal>并且返回
     指向该输入值的指针）。
    </para>
<!-- pgdoc-cn_end sig_en=7913a5053758f0ae9f782f6bc5bf3ed9 -->

<!-- pgdoc-cn_start sig_en=80f7904e29dcf1ab0a41fbcdf4c2e4fc sig_cn_org=None source=14.1 
    <para>
     Finally, all variable-length types must also be  passed
     by  reference.   All  variable-length  types must begin
     with an opaque length field of exactly 4 bytes, which will be set
     by <symbol>SET_VARSIZE</symbol>; never set this field directly! All data to
     be  stored within that type must be located in the memory
     immediately  following  that  length  field.   The
     length field contains the total length of the structure,
     that is,  it  includes  the  size  of  the  length  field
     itself.
    </para>
________________________________________________________-->
    <para>
     最后，所有变长类型必须也以引用的方式传递。所有变长类型必须用一个
     正好 4 字节的不透明长度域开始，该域会由<symbol>SET_VARSIZE</symbol>
     设置，绝不要直接设置该域！所有要被存储在该类型中的数据必须在内存
     中接着该长度域的后面存储。长度域包含该结构的总长度，也就是包括长
     度域本身的尺寸。
    </para>
<!-- pgdoc-cn_end sig_en=80f7904e29dcf1ab0a41fbcdf4c2e4fc -->

<!-- pgdoc-cn_start sig_en=47e555a970a660a45e96e8da15525fe4 sig_cn_org=None source=14.1 
    <para>
     Another important point is to avoid leaving any uninitialized bits
     within data type values; for example, take care to zero out any
     alignment padding bytes that might be present in structs.  Without
     this, logically-equivalent constants of your data type might be
     seen as unequal by the planner, leading to inefficient (though not
     incorrect) plans.
    </para>
________________________________________________________-->
    <para>
     另一个重点是要避免在数据类型值中留下未被初始化的位。例如，要注意
     把可能存在于结构中的任何对齐填充字节置零。如果不这样做，你的数据
     类型的逻辑等价常量可能会被规划器认为是不等的，进而导致低效的（不过
     还是正确的）计划。
    </para>
<!-- pgdoc-cn_end sig_en=47e555a970a660a45e96e8da15525fe4 -->

    <warning>
<!-- pgdoc-cn_start sig_en=ed5e17d42bcc891dbfbd1d14849254bf sig_cn_org=None source=14.1 
     <para>
      <emphasis>Never</emphasis> modify the contents of a pass-by-reference input
      value.  If you do so you are likely to corrupt on-disk data, since
      the pointer you are given might point directly into a disk buffer.
      The sole exception to this rule is explained in
      <xref linkend="xaggr"/>.
     </para>
________________________________________________________-->
     <para>
      <emphasis>绝不要</emphasis>修改通过引用传递的输入值的内容。如果这样做
      很可能会破坏磁盘上的数据，因为给出的指针可能直接指向一个磁盘缓冲
      区。这条规则唯一的例外在<xref linkend="xaggr"/>中有解释。
     </para>
<!-- pgdoc-cn_end sig_en=ed5e17d42bcc891dbfbd1d14849254bf -->
    </warning>

<!-- pgdoc-cn_start sig_en=109cd149dc781f176b5ce0051c686606 sig_cn_org=None source=14.1 
    <para>
     As an example, we can define the type <type>text</type> as
     follows:

<programlisting>
typedef struct {
    int32 length;
    char data[FLEXIBLE_ARRAY_MEMBER];
} text;
</programlisting>

     The <literal>[FLEXIBLE_ARRAY_MEMBER]</literal> notation means that the actual
     length of the data part is not specified by this declaration.
    </para>
________________________________________________________-->
    <para>
     例如，我们可以这样定义类型<type>text</type>：

<programlisting>
typedef struct {
    int32 length;
    char data[FLEXIBLE_ARRAY_MEMBER];
} text;
</programlisting>

     <literal>[FLEXIBLE_ARRAY_MEMBER]</literal>记号表示数据部分的实际
     长度不由该声明指定。
    </para>
<!-- pgdoc-cn_end sig_en=109cd149dc781f176b5ce0051c686606 -->

<!-- pgdoc-cn_start sig_en=36af58dd116eaa2c634de41b45f067bb sig_cn_org=None source=14.1 
    <para>
     When manipulating
     variable-length types, we must  be  careful  to  allocate
     the  correct amount  of memory and set the length field correctly.
     For example, if we wanted to  store  40  bytes  in  a <structname>text</structname>
     structure, we might use a code fragment like this:

<programlisting><![CDATA[
#include "postgres.h"
...
char buffer[40]; /* our source data */
...
text *destination = (text *) palloc(VARHDRSZ + 40);
SET_VARSIZE(destination, VARHDRSZ + 40);
memcpy(destination->data, buffer, 40);
...
]]>
</programlisting>

     <literal>VARHDRSZ</literal> is the same as <literal>sizeof(int32)</literal>, but
     it's considered good style to use the macro <literal>VARHDRSZ</literal>
     to refer to the size of the overhead for a variable-length type.
     Also, the length field <emphasis>must</emphasis> be set using the
     <literal>SET_VARSIZE</literal> macro, not by simple assignment.
    </para>
________________________________________________________-->
    <para>
     在操纵变长字节时，我们必须小心地分配正确数量的内存并且正确地
     设置长度域。例如，如果我们想在一个<structname>text</structname>结构
     中存储 40 字节，我们可以使用这样的代码片段：

<programlisting><![CDATA[
#include "postgres.h"
...
char buffer[40]; /* our source data */
...
text *destination = (text *) palloc(VARHDRSZ + 40);
SET_VARSIZE(destination, VARHDRSZ + 40);
memcpy(destination->data, buffer, 40);
...
]]>
</programlisting>

     <literal>VARHDRSZ</literal>和<literal>sizeof(int32)</literal>一样，
     但是用宏<literal>VARHDRSZ</literal>来引用变长类型的载荷的
     尺寸被认为是比较好的风格。还有，<emphasis>必须</emphasis>
     使用<literal>SET_VARSIZE</literal>宏来设置长度域，而不是用
     简单的赋值来设置。
    </para>
<!-- pgdoc-cn_end sig_en=36af58dd116eaa2c634de41b45f067bb -->

<!-- pgdoc-cn_start sig_en=544e875522c81c5cbbf897cad51d76a7 sig_cn_org=fb8366e5647642336198d5662b261962 source=15.7 
    <para>
     <xref linkend="xfunc-c-type-table"/> shows the C types
     corresponding to many of the built-in SQL data types
     of <productname>PostgreSQL</productname>.
     The <quote>Defined In</quote> column gives the header file that
     needs to be included to get the type definition.  (The actual
     definition might be in a different file that is included by the
     listed file.  It is recommended that users stick to the defined
     interface.)  Note that you should always include
     <filename>postgres.h</filename> first in any source file of server
     code, because it declares a number of things that you will need
     anyway, and because including other headers first can cause
     portability issues.
    </para>
________________________________________________________-->
    <para>
     <xref linkend="xfunc-c-type-table"/>显示了许多内置SQL数据类型对应的C类型，<productname>PostgreSQL</productname>的。
     <quote>Defined In</quote>列给出了需要包含的头文件，以获取类型定义。
     （实际的定义可能位于所列文件包含的其他文件中。建议用户坚持使用已定义的接口。）
     请注意，您应该始终首先在服务器代码的任何源文件中包含<filename>postgres.h</filename>，
     因为它声明了您将需要的许多内容，并且因为先包含其他头文件可能会导致可移植性问题。
    </para>
<!-- pgdoc-cn_end sig_en=544e875522c81c5cbbf897cad51d76a7 -->

     <table tocentry="1" id="xfunc-c-type-table">
<!-- pgdoc-cn_start sig_en=2a90c507af34cc80ea77882083c2c60d sig_cn_org=None source=14.1 
      <title>Equivalent C Types for Built-in SQL Types</title>
________________________________________________________-->
      <title>内建 SQL 类型等效的 C 类型</title>
<!-- pgdoc-cn_end sig_en=2a90c507af34cc80ea77882083c2c60d -->
      <tgroup cols="3">
       <colspec colname="col1" colwidth="1*"/>
       <colspec colname="col2" colwidth="1*"/>
       <colspec colname="col3" colwidth="2*"/>
       <thead>
<!-- pgdoc-cn_start sig_en=cf58ce5b3464724f5466780d84431797 sig_cn_org=None source=14.1 
        <row>
         <entry>
          SQL Type
         </entry>
         <entry>
          C Type
         </entry>
         <entry>
          Defined In
         </entry>
        </row>
________________________________________________________-->
        <row>
         <entry>
          SQL 类型
         </entry>
         <entry>
          C 类型
         </entry>
         <entry>
          定义文件
         </entry>
        </row>
<!-- pgdoc-cn_end sig_en=cf58ce5b3464724f5466780d84431797 -->
       </thead>
       <tbody>
<!-- pgdoc-cn_start sig_en=4550bf7c76382f4bf29964203020f2b2 sig_cn_org=None source=14.1 
        <row>
         <entry><type>boolean</type></entry>
         <entry><type>bool</type></entry>
         <entry><filename>postgres.h</filename> (maybe compiler built-in)</entry>
        </row>
________________________________________________________-->
        <row>
         <entry><type>boolean</type></entry>
         <entry><type>bool</type></entry>
         <entry><filename>postgres.h</filename>（可能是编译器内建）</entry>
        </row>
<!-- pgdoc-cn_end sig_en=4550bf7c76382f4bf29964203020f2b2 -->
        <row>
         <entry><type>box</type></entry>
         <entry><type>BOX*</type></entry>
         <entry><filename>utils/geo_decls.h</filename></entry>
        </row>
        <row>
         <entry><type>bytea</type></entry>
         <entry><type>bytea*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
<!-- pgdoc-cn_start sig_en=e056a395d56746e922f38109174fc6a3 sig_cn_org=None source=14.1 
        <row>
         <entry><type>"char"</type></entry>
         <entry><type>char</type></entry>
         <entry>(compiler built-in)</entry>
        </row>
________________________________________________________-->
        <row>
         <entry><type>"char"</type></entry>
         <entry><type>char</type></entry>
         <entry>（编译器内建）</entry>
        </row>
<!-- pgdoc-cn_end sig_en=e056a395d56746e922f38109174fc6a3 -->
        <row>
         <entry><type>character</type></entry>
         <entry><type>BpChar*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>cid</type></entry>
         <entry><type>CommandId</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>date</type></entry>
         <entry><type>DateADT</type></entry>
         <entry><filename>utils/date.h</filename></entry>
        </row>
<!-- pgdoc-cn_start sig_en=219c19e02b6223399651ed434d51ba57 sig_cn_org=ed92c685cdfe149e159238198d9d82c1 source=15.7 
        <row>
         <entry><type>float4</type> (<type>real</type>)</entry>
         <entry><type>float4</type></entry>
        <entry><filename>postgres.h</filename></entry>
        </row>
________________________________________________________-->
        <row>
         <entry><type>float4</type> (<type>real</type>)</entry>
         <entry><type>float4</type></entry>
        <entry><filename>postgres.h</filename></entry>
        </row>
<!-- pgdoc-cn_end sig_en=219c19e02b6223399651ed434d51ba57 -->
<!-- pgdoc-cn_start sig_en=5a24f2ee955bec35ddc2c9b6196f71f5 sig_cn_org=909b61c8bf5ad63cffec54728dabd60d source=15.7 
        <row>
         <entry><type>float8</type> (<type>double precision</type>)</entry>
         <entry><type>float8</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
________________________________________________________-->
        <row>
         <entry><type>float8</type> (<type>double precision</type>)</entry>
         <entry><type>float8</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
<!-- pgdoc-cn_end sig_en=5a24f2ee955bec35ddc2c9b6196f71f5 -->
<!-- pgdoc-cn_start sig_en=8d7af34493f290e0d63b5604a284bb6f sig_cn_org=8d7af34493f290e0d63b5604a284bb6f source=15.7 
        <row>
         <entry><type>int2</type> (<type>smallint</type>)</entry>
         <entry><type>int16</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
________________________________________________________-->
        <row>
         <entry><type>int2</type> (<type>smallint</type>)</entry>
         <entry><type>int16</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
<!-- pgdoc-cn_end sig_en=8d7af34493f290e0d63b5604a284bb6f -->
<!-- pgdoc-cn_start sig_en=f14f8f4cb7b1a3553499dd8758489e3c sig_cn_org=9dd03782207b8317e095a3ef49df9334 source=15.7 
        <row>
         <entry><type>int4</type> (<type>integer</type>)</entry>
         <entry><type>int32</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
________________________________________________________-->
        <row>
         <entry><type>int4</type>（<type>整数</type>）</entry>
         <entry><type>int32</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
<!-- pgdoc-cn_end sig_en=f14f8f4cb7b1a3553499dd8758489e3c -->
<!-- pgdoc-cn_start sig_en=e4c598b997b784f2b585159e280c4b7e sig_cn_org=e4c598b997b784f2b585159e280c4b7e source=15.7 
        <row>
         <entry><type>int8</type> (<type>bigint</type>)</entry>
         <entry><type>int64</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
________________________________________________________-->
        <row>
         <entry><type>int8</type> (<type>bigint</type>)</entry>
         <entry><type>int64</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
<!-- pgdoc-cn_end sig_en=e4c598b997b784f2b585159e280c4b7e -->
        <row>
         <entry><type>interval</type></entry>
         <entry><type>Interval*</type></entry>
         <entry><filename>datatype/timestamp.h</filename></entry>
        </row>
        <row>
         <entry><type>lseg</type></entry>
         <entry><type>LSEG*</type></entry>
         <entry><filename>utils/geo_decls.h</filename></entry>
        </row>
        <row>
         <entry><type>name</type></entry>
         <entry><type>Name</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>numeric</type></entry>
         <entry><type>Numeric</type></entry>
         <entry><filename>utils/numeric.h</filename></entry>
        </row>
        <row>
         <entry><type>oid</type></entry>
         <entry><type>Oid</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>oidvector</type></entry>
         <entry><type>oidvector*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>path</type></entry>
         <entry><type>PATH*</type></entry>
         <entry><filename>utils/geo_decls.h</filename></entry>
        </row>
        <row>
         <entry><type>point</type></entry>
         <entry><type>POINT*</type></entry>
         <entry><filename>utils/geo_decls.h</filename></entry>
        </row>
        <row>
         <entry><type>regproc</type></entry>
         <entry><type>RegProcedure</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>text</type></entry>
         <entry><type>text*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>tid</type></entry>
         <entry><type>ItemPointer</type></entry>
         <entry><filename>storage/itemptr.h</filename></entry>
        </row>
        <row>
         <entry><type>time</type></entry>
         <entry><type>TimeADT</type></entry>
         <entry><filename>utils/date.h</filename></entry>
        </row>
        <row>
         <entry><type>time with time zone</type></entry>
         <entry><type>TimeTzADT</type></entry>
         <entry><filename>utils/date.h</filename></entry>
        </row>
        <row>
         <entry><type>timestamp</type></entry>
         <entry><type>Timestamp</type></entry>
         <entry><filename>datatype/timestamp.h</filename></entry>
        </row>
        <row>
         <entry><type>timestamp with time zone</type></entry>
         <entry><type>TimestampTz</type></entry>
         <entry><filename>datatype/timestamp.h</filename></entry>
        </row>
        <row>
         <entry><type>varchar</type></entry>
         <entry><type>VarChar*</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
        <row>
         <entry><type>xid</type></entry>
         <entry><type>TransactionId</type></entry>
         <entry><filename>postgres.h</filename></entry>
        </row>
       </tbody>
      </tgroup>
     </table>

<!-- pgdoc-cn_start sig_en=0b0a187c5b6dc50284ac9e1ebcf68d87 sig_cn_org=None source=14.1 
    <para>
     Now that we've gone over all of the possible structures
     for base types, we can show some examples of real functions.
    </para>
________________________________________________________-->
    <para>
     现在我们已经复习了基本类型所有可能的结构，现在可以展示一些
     真实函数的例子了。
    </para>
<!-- pgdoc-cn_end sig_en=0b0a187c5b6dc50284ac9e1ebcf68d87 -->
   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=defc2a8168c6b2267adc909a3c9a6e86 sig_cn_org=None source=14.1 
    <title>Version 1 Calling Conventions</title>
________________________________________________________-->
    <title>版本 1 的调用约定</title>
<!-- pgdoc-cn_end sig_en=defc2a8168c6b2267adc909a3c9a6e86 -->

<!-- pgdoc-cn_start sig_en=81b7a8fa584d2f829fbf649d6d445d0e sig_cn_org=None source=14.1 
    <para>
     The version-1 calling convention relies on macros to suppress most
     of the complexity of passing arguments and results.  The C declaration
     of a version-1 function is always:
<programlisting>
Datum funcname(PG_FUNCTION_ARGS)
</programlisting>
     In addition, the macro call:
<programlisting>
PG_FUNCTION_INFO_V1(funcname);
</programlisting>
     must appear in the same source file.  (Conventionally, it's
     written just before the function itself.)  This macro call is not
     needed for <literal>internal</literal>-language functions, since
     <productname>PostgreSQL</productname> assumes that all internal functions
     use the version-1 convention.  It is, however, required for
     dynamically-loaded functions.
    </para>
________________________________________________________-->
    <para>
     版本-1 的调用规范依赖于宏来降低传参数和结果的复杂度。版本-1 函数的
     C 声明总是：
<programlisting>
Datum funcname(PG_FUNCTION_ARGS)
</programlisting>
     此外，宏调用：
<programlisting>
PG_FUNCTION_INFO_V1(funcname);
</programlisting>
     必须出现在同一个源文件中（按惯例会正好写在该函数本身之前）。
     这种宏调用不是<literal>internal</literal>语言函数所需要的，因为
     <productname>PostgreSQL</productname>会假定所有内部函数都使用
     版本-1 规范。不过，对于动态载入函数是必需的。
    </para>
<!-- pgdoc-cn_end sig_en=81b7a8fa584d2f829fbf649d6d445d0e -->

<!-- pgdoc-cn_start sig_en=e760d8c6594fc56ffb3494f69a99a65a sig_cn_org=None source=14.1 
    <para>
     In a version-1 function, each actual argument is fetched using a
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function>
     macro that corresponds to the argument's data type.  (In non-strict
     functions there needs to be a previous check about argument null-ness
     using <function>PG_ARGISNULL()</function>; see below.)
     The result is returned using a
     <function>PG_RETURN_<replaceable>xxx</replaceable>()</function>
     macro for the return type.
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function>
     takes as its argument the number of the function argument to
     fetch, where the count starts at 0.
     <function>PG_RETURN_<replaceable>xxx</replaceable>()</function>
     takes as its argument the actual value to return.
    </para>
________________________________________________________-->
    <para>
     在版本-1 函数中，每一个实参都使用对应于该参数数据类型的<function>PG_GETARG_<replaceable>xxx</replaceable>()</function>宏取得。（在非严格的函数中，需要使用<function>PG_ARGISNULL()</function>对参数是否为空提前做检查；见下文。）结果要用对应于返回类型的<function>PG_RETURN_<replaceable>xxx</replaceable>()</function>宏返回。<function>PG_GETARG_<replaceable>xxx</replaceable>()</function>的参数是要取得的函数参数的编号，从零开始计。<function>PG_RETURN_<replaceable>xxx</replaceable>()</function>的参数是实际要返回的值。
    </para>
<!-- pgdoc-cn_end sig_en=e760d8c6594fc56ffb3494f69a99a65a -->

<!-- pgdoc-cn_start sig_en=ab9d7951fc2114780d6b5fa38c34fd5b sig_cn_org=None source=14.1 
    <para>
     Here are some examples using the version-1 calling convention:
    </para>
________________________________________________________-->
    <para>
     这里是一些使用版本-1调用约定的例子：
    </para>
<!-- pgdoc-cn_end sig_en=ab9d7951fc2114780d6b5fa38c34fd5b -->

<programlisting><![CDATA[
#include "postgres.h"
#include <string.h>
#include "fmgr.h"
#include "utils/geo_decls.h"

PG_MODULE_MAGIC;

/* by value */

PG_FUNCTION_INFO_V1(add_one);

Datum
add_one(PG_FUNCTION_ARGS)
{
    int32   arg = PG_GETARG_INT32(0);

    PG_RETURN_INT32(arg + 1);
}

/* by reference, fixed length */

PG_FUNCTION_INFO_V1(add_one_float8);

Datum
add_one_float8(PG_FUNCTION_ARGS)
{
    /* The macros for FLOAT8 hide its pass-by-reference nature. */
    float8   arg = PG_GETARG_FLOAT8(0);

    PG_RETURN_FLOAT8(arg + 1.0);
}

PG_FUNCTION_INFO_V1(makepoint);

Datum
makepoint(PG_FUNCTION_ARGS)
{
    /* Here, the pass-by-reference nature of Point is not hidden. */
    Point     *pointx = PG_GETARG_POINT_P(0);
    Point     *pointy = PG_GETARG_POINT_P(1);
    Point     *new_point = (Point *) palloc(sizeof(Point));

    new_point->x = pointx->x;
    new_point->y = pointy->y;

    PG_RETURN_POINT_P(new_point);
}

/* by reference, variable length */

PG_FUNCTION_INFO_V1(copytext);

Datum
copytext(PG_FUNCTION_ARGS)
{
    text     *t = PG_GETARG_TEXT_PP(0);

    /*
     * VARSIZE_ANY_EXHDR is the size of the struct in bytes, minus the
     * VARHDRSZ or VARHDRSZ_SHORT of its header.  Construct the copy with a
     * full-length header.
     */
    text     *new_t = (text *) palloc(VARSIZE_ANY_EXHDR(t) + VARHDRSZ);
    SET_VARSIZE(new_t, VARSIZE_ANY_EXHDR(t) + VARHDRSZ);

    /*
     * VARDATA is a pointer to the data region of the new struct.  The source
     * could be a short datum, so retrieve its data through VARDATA_ANY.
     */
    memcpy((void *) VARDATA(new_t), /* destination */
           (void *) VARDATA_ANY(t), /* source */
           VARSIZE_ANY_EXHDR(t));   /* how many bytes */
    PG_RETURN_TEXT_P(new_t);
}

PG_FUNCTION_INFO_V1(concat_text);

Datum
concat_text(PG_FUNCTION_ARGS)
{
    text  *arg1 = PG_GETARG_TEXT_PP(0);
    text  *arg2 = PG_GETARG_TEXT_PP(1);
    int32 arg1_size = VARSIZE_ANY_EXHDR(arg1);
    int32 arg2_size = VARSIZE_ANY_EXHDR(arg2);
    int32 new_text_size = arg1_size + arg2_size + VARHDRSZ;
    text *new_text = (text *) palloc(new_text_size);

    SET_VARSIZE(new_text, new_text_size);
    memcpy(VARDATA(new_text), VARDATA_ANY(arg1), arg1_size);
    memcpy(VARDATA(new_text) + arg1_size, VARDATA_ANY(arg2), arg2_size);
    PG_RETURN_TEXT_P(new_text);
}
]]>
</programlisting>

<!-- pgdoc-cn_start sig_en=f1b72497c9fe9ace657e8addcd841f86 sig_cn_org=None source=14.1 
    <para>
     Supposing that the above code has been prepared in file
     <filename>funcs.c</filename> and compiled into a shared object,
     we could define the functions to <productname>PostgreSQL</productname>
     with commands like this:
    </para>
________________________________________________________-->
    <para>
     假定上述代码已经准备在文件<filename>funcs.c</filename>中并且被编译成一个共享对象，我们可以用这样的命令在<productname>PostgreSQL</productname>中定义函数：
    </para>
<!-- pgdoc-cn_end sig_en=f1b72497c9fe9ace657e8addcd841f86 -->

<!-- pgdoc-cn_start sig_en=89825f39822a5512098530a763d4c7d5 sig_cn_org=None source=14.1 
<programlisting>
CREATE FUNCTION add_one(integer) RETURNS integer
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'add_one'
     LANGUAGE C STRICT;

-&minus; note overloading of SQL function name "add_one"
CREATE FUNCTION add_one(double precision) RETURNS double precision
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'add_one_float8'
     LANGUAGE C STRICT;

CREATE FUNCTION makepoint(point, point) RETURNS point
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'makepoint'
     LANGUAGE C STRICT;

CREATE FUNCTION copytext(text) RETURNS text
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'copytext'
     LANGUAGE C STRICT;

CREATE FUNCTION concat_text(text, text) RETURNS text
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'concat_text'
     LANGUAGE C STRICT;
</programlisting>
________________________________________________________-->
<programlisting>
CREATE FUNCTION add_one(integer) RETURNS integer
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'add_one'
     LANGUAGE C STRICT;

-- 注意SQL函数名“add_one”的重载
CREATE FUNCTION add_one(double precision) RETURNS double precision
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'add_one_float8'
     LANGUAGE C STRICT;

CREATE FUNCTION makepoint(point, point) RETURNS point
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'makepoint'
     LANGUAGE C STRICT;

CREATE FUNCTION copytext(text) RETURNS text
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'copytext'
     LANGUAGE C STRICT;

CREATE FUNCTION concat_text(text, text) RETURNS text
     AS '<replaceable>DIRECTORY</replaceable>/funcs', 'concat_text'
     LANGUAGE C STRICT;
</programlisting>
<!-- pgdoc-cn_end sig_en=89825f39822a5512098530a763d4c7d5 -->

<!-- pgdoc-cn_start sig_en=019f8e9dbbe6e1e594f8d50ad23544f2 sig_cn_org=None source=14.1 
    <para>
     Here, <replaceable>DIRECTORY</replaceable> stands for the
     directory of the shared library file (for instance the
     <productname>PostgreSQL</productname> tutorial directory, which
     contains the code for the examples used in this section).
     (Better style would be to use just <literal>'funcs'</literal> in the
     <literal>AS</literal> clause, after having added
     <replaceable>DIRECTORY</replaceable> to the search path.  In any
     case, we can omit the system-specific extension for a shared
     library, commonly <literal>.so</literal>.)
    </para>
________________________________________________________-->
    <para>
     这里，<replaceable>DIRECTORY</replaceable>表示共享库文件的目录（例如<productname>PostgreSQL</productname>的教程目录，它包含这一节中用到的例子的代码）。（更好的风格是先把<replaceable>DIRECTORY</replaceable>放入搜索路径，在<literal>AS</literal>子句中只使用<literal>'funcs'</literal>。在任何情况下，我们可以为一个共享库省略系统相关的扩展名，通常是<literal>.so</literal>）。
    </para>
<!-- pgdoc-cn_end sig_en=019f8e9dbbe6e1e594f8d50ad23544f2 -->

<!-- pgdoc-cn_start sig_en=440b44a52ea32ad02cbee1c4c68c608a sig_cn_org=None source=14.1 
    <para>
     Notice that we have specified the functions as <quote>strict</quote>,
     meaning that
     the system should automatically assume a null result if any input
     value is null.  By doing this, we avoid having to check for null inputs
     in the function code.  Without this, we'd have to check for null values
     explicitly, using <function>PG_ARGISNULL()</function>.
    </para>
________________________________________________________-->
    <para>
     注意我们已经把函数指定为<quote>strict</quote>，这意味着如果有任何输入值为空，系统应该自动假定得到空结果。通过这种做法，我们避免在函数代码中检查空值输入。如果不这样做，我们必须使用<function>PG_ARGISNULL()</function>明确地检查空值输入。
    </para>
<!-- pgdoc-cn_end sig_en=440b44a52ea32ad02cbee1c4c68c608a -->

<!-- pgdoc-cn_start sig_en=45932ed513e71618e17eb59e1b1ca74b sig_cn_org=None source=14.1 
    <para>
     The macro <function>PG_ARGISNULL(<replaceable>n</replaceable>)</function>
     allows a function to test whether each input is null.  (Of course, doing
     this is only necessary in functions not declared <quote>strict</quote>.)
     As with the
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function> macros,
     the input arguments are counted beginning at zero.  Note that one
     should refrain from executing
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function> until
     one has verified that the argument isn't null.
     To return a null result, execute <function>PG_RETURN_NULL()</function>;
     this works in both strict and nonstrict functions.
    </para>
________________________________________________________-->
    <para>
     宏<function>PG_ARGISNULL(<replaceable>n</replaceable>)</function>允许一个函数测试是否每一个输入为空（当然，只需要在没有声明为<quote>strict</quote>的函数中这样做）。和<function>PG_GETARG_<replaceable>xxx</replaceable>()</function>宏一样，输入参数也是从零开始计数。注意应该在验证了一个参数不是空之后才执行<function>PG_GETARG_<replaceable>xxx</replaceable>()</function>。要返回一个空结果，应执行<function>PG_RETURN_NULL()</function>，它对严格的以及非严格的函数都有用。
    </para>
<!-- pgdoc-cn_end sig_en=45932ed513e71618e17eb59e1b1ca74b -->

<!-- pgdoc-cn_start sig_en=0ea5aece2fd053d9bda53d625aba02b6 sig_cn_org=None source=14.1 
    <para>
     At first glance, the version-1 coding conventions might appear
     to be just pointless obscurantism, compared to using
     plain <literal>C</literal> calling conventions.  They do however allow
     us to deal with <literal>NULL</literal>able arguments/return values,
     and <quote>toasted</quote> (compressed or out-of-line) values.
    </para>
________________________________________________________-->
    <para>
     乍一看，与使用普通的<literal>C</literal>调用约定相比，版本 1 编码约定似乎只是毫无意义的愚民政策。
     然而，它们确实允许我们处理<literal>NULL</literal>able 参数/返回值，以及<quote>toasted</quote>（压缩或离线）值。
    </para>
<!-- pgdoc-cn_end sig_en=0ea5aece2fd053d9bda53d625aba02b6 -->

<!-- pgdoc-cn_start sig_en=548aa927fc8df303db9a5fdccc264c94 sig_cn_org=None source=14.1 
    <para>
     Other options provided by the version-1 interface are two
     variants of the
     <function>PG_GETARG_<replaceable>xxx</replaceable>()</function>
     macros. The first of these,
     <function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</function>,
     guarantees to return a copy of the specified argument that is
     safe for writing into. (The normal macros will sometimes return a
     pointer to a value that is physically stored in a table, which
     must not be written to. Using the
     <function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</function>
     macros guarantees a writable result.)
    The second variant consists of the
    <function>PG_GETARG_<replaceable>xxx</replaceable>_SLICE()</function>
    macros which take three arguments. The first is the number of the
    function argument (as above). The second and third are the offset and
    length of the segment to be returned. Offsets are counted from
    zero, and a negative length requests that the remainder of the
    value be returned. These macros provide more efficient access to
    parts of large values in the case where they have storage type
    <quote>external</quote>. (The storage type of a column can be specified using
    <literal>ALTER TABLE <replaceable>tablename</replaceable> ALTER
    COLUMN <replaceable>colname</replaceable> SET STORAGE
    <replaceable>storagetype</replaceable></literal>. <replaceable>storagetype</replaceable> is one of
    <literal>plain</literal>, <literal>external</literal>, <literal>extended</literal>,
     or <literal>main</literal>.)
    </para>
________________________________________________________-->
    <para>
     在版本-1接口中提供的其他选项是<function>PG_GETARG_<replaceable>xxx</replaceable>()</function>宏的两个变种。其中的第一种是<function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</function>，它确保返回的指定参数的拷贝可以被安全地写入（通常的宏有时会返回一个指向表中物理存储的值，它不能被写入。使用<function>PG_GETARG_<replaceable>xxx</replaceable>_COPY()</function>宏可以保证得到一个可写的结果）。第二种变种<function>PG_GETARG_<replaceable>xxx</replaceable>_SLICE()</function>宏有三个参数。第一个是函数参数的编号（如上文）。第二个和第三个是要被返回的段的偏移量和长度。偏移量从零开始计算，而负值的长度则表示要求返回该值的剩余部分。当大型值的存储类型为<quote>external</quote>时，这些宏提供了访问这些大型值的更有效的方法（列的存储类型可以使用<literal>ALTER TABLE <replaceable>tablename</replaceable> ALTER COLUMN <replaceable>colname</replaceable> SET STORAGE <replaceable>storagetype</replaceable></literal>来指定。<replaceable>storagetype</replaceable>取<literal>plain</literal>、<literal>external</literal>、<literal>extended</literal>或者<literal>main</literal>）。
    </para>
<!-- pgdoc-cn_end sig_en=548aa927fc8df303db9a5fdccc264c94 -->

<!-- pgdoc-cn_start sig_en=f0ba9e3d984d68fa092a6a46fb0b4579 sig_cn_org=None source=14.1 
    <para>
     Finally, the version-1 function call conventions make it possible
     to return set results (<xref linkend="xfunc-c-return-set"/>) and
     implement trigger functions (<xref linkend="triggers"/>) and
     procedural-language call handlers (<xref
     linkend="plhandler"/>).  For more details
     see <filename>src/backend/utils/fmgr/README</filename> in the
     source distribution.
    </para>
________________________________________________________-->
    <para>
     最后，版本-1 的函数调用规范可以返回集合结果（<xref linkend="xfunc-c-return-set"/>）、实现触发器函数（<xref linkend="triggers"/>）和过程语言调用处理器（<xref linkend="plhandler"/>）。更多细节
     可见源代码发布中的<filename>src/backend/utils/fmgr/README</filename>。
    </para>
<!-- pgdoc-cn_end sig_en=f0ba9e3d984d68fa092a6a46fb0b4579 -->
   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=5cc481eafe1d8ba20f0055439f476cbe sig_cn_org=None source=14.1 
    <title>Writing Code</title>
________________________________________________________-->
    <title>编写代码</title>
<!-- pgdoc-cn_end sig_en=5cc481eafe1d8ba20f0055439f476cbe -->

<!-- pgdoc-cn_start sig_en=a7abac24efdbe88f2c440a730af92815 sig_cn_org=None source=14.1 
    <para>
     Before we turn to the more advanced topics, we should discuss
     some coding rules for <productname>PostgreSQL</productname>
     C-language functions.  While it might be possible to load functions
     written in languages other than C into
     <productname>PostgreSQL</productname>, this is usually difficult
     (when it is possible at all) because other languages, such as
     C++, FORTRAN, or Pascal often do not follow the same calling
     convention as C.  That is, other languages do not pass argument
     and return values between functions in the same way.  For this
     reason, we will assume that your C-language functions are
     actually written in C.
    </para>
________________________________________________________-->
    <para>
     在开始更高级的话题之前，我们应该讨论一下用于
     <productname>PostgreSQL</productname> C 语言函数的编码规则。
     虽然可以把不是 C 编写的函数载入到
     <productname>PostgreSQL</productname>中，这通常是很困难的，
     因为其他语言（例如 C++、FORTRAN 或者 Pascal）通常不会遵循和 C
     相同的调用规范。也就是说，其他语言不会以同样的方式在函数之间传递
     参数以及返回值。由于这个原因，我们会假定你的 C 语言函数确实是用 C
     编写的。
    </para>
<!-- pgdoc-cn_end sig_en=a7abac24efdbe88f2c440a730af92815 -->

<!-- pgdoc-cn_start sig_en=2bb88ea656a4203fa1c1d148cf17ac93 sig_cn_org=None source=14.1 
    <para>
     The basic rules for writing and building C functions are as follows:

     <itemizedlist>
      <listitem>
       <para>
        Use <literal>pg_config
        -&minus;includedir-server</literal><indexterm><primary>pg_config</primary><secondary>with user-defined C functions</secondary></indexterm>
        to find out where the <productname>PostgreSQL</productname> server header
        files are installed on your system (or the system that your
        users will be running on).
       </para>
      </listitem>

      <listitem>
       <para>
        Compiling and linking your code so that it can be dynamically
        loaded into <productname>PostgreSQL</productname> always
        requires special flags.  See <xref linkend="dfunc"/> for a
        detailed explanation of how to do it for your particular
        operating system.
       </para>
      </listitem>

      <listitem>
       <para>
        Remember to define a <quote>magic block</quote> for your shared library,
        as described in <xref linkend="xfunc-c-dynload"/>.
       </para>
      </listitem>

      <listitem>
       <para>
        When allocating memory, use the
        <productname>PostgreSQL</productname> functions
        <function>palloc</function><indexterm><primary>palloc</primary></indexterm> and <function>pfree</function><indexterm><primary>pfree</primary></indexterm>
        instead of the corresponding C library functions
        <function>malloc</function> and <function>free</function>.
        The memory allocated by <function>palloc</function> will be
        freed automatically at the end of each transaction, preventing
        memory leaks.
       </para>
      </listitem>

      <listitem>
       <para>
        Always zero the bytes of your structures using <function>memset</function>
        (or allocate them with <function>palloc0</function> in the first place).
        Even if you assign to each field of your structure, there might be
        alignment padding (holes in the structure) that contain
        garbage values.  Without this, it's difficult to
        support hash indexes or hash joins, as you must pick out only
        the significant bits of your data structure to compute a hash.
        The planner also sometimes relies on comparing constants via
        bitwise equality, so you can get undesirable planning results if
        logically-equivalent values aren't bitwise equal.
       </para>
      </listitem>

      <listitem>
       <para>
        Most of the internal <productname>PostgreSQL</productname>
        types are declared in <filename>postgres.h</filename>, while
        the function manager interfaces
        (<symbol>PG_FUNCTION_ARGS</symbol>, etc.)  are in
        <filename>fmgr.h</filename>, so you will need to include at
        least these two files.  For portability reasons it's best to
        include <filename>postgres.h</filename> <emphasis>first</emphasis>,
        before any other system or user header files.  Including
        <filename>postgres.h</filename> will also include
        <filename>elog.h</filename> and <filename>palloc.h</filename>
        for you.
       </para>
      </listitem>

      <listitem>
       <para>
        Symbol names defined within object files must not conflict
        with each other or with symbols defined in the
        <productname>PostgreSQL</productname> server executable.  You
        will have to rename your functions or variables if you get
        error messages to this effect.
       </para>
      </listitem>
     </itemizedlist>
    </para>
________________________________________________________-->
    <para>
     编写和编译 C 函数的基本规则如下：

     <itemizedlist>
      <listitem>
       <para>
        使用<literal>pg_config
        --includedir-server</literal><indexterm><primary>pg_config</primary><secondary>with user-defined C functions</secondary></indexterm>
        找出<productname>PostgreSQL</productname>服务器头文件安装在
        系统的哪个位置。
       </para>
      </listitem>

      <listitem>
       <para>
        编译并且链接你的代码（这样它就能被动态载入到
        <productname>PostgreSQL</productname>中）总是
        要求特殊的标志。对特定的操作系统的做法详见
        <xref linkend="dfunc"/>。
       </para>
      </listitem>

      <listitem>
       <para>
        记住为你的共享库按<xref linkend="xfunc-c-dynload"/>中所述
        定义一个<quote>magic block</quote>。
       </para>
      </listitem>

      <listitem>
       <para>
        在分配内存时，使用
        <productname>PostgreSQL</productname>函数
        <function>palloc</function><indexterm><primary>palloc</primary></indexterm>和 <function>pfree</function><indexterm><primary>pfree</primary></indexterm>，
        而不是使用对应的 C 库函数
        <function>malloc</function>和<function>free</function>。
        在每个事务结束时会自动释放通过<function>palloc</function>
        分配的内存，以免内存泄露。
       </para>
      </listitem>

      <listitem>
       <para>
        总是要使用<function>memset</function>把你的结构中的字节置零（或者
        最开始就用<function>palloc0</function>分配它们）。即使你对结构中的
        每个域都赋值，也可能有对齐填充（结构中的空洞）包含着垃圾值。
        如果不这样做，很难支持哈希索引或哈希连接，因为你必须选出数据
        结构中有意义的位进行哈希计算。规划器有时也依赖于用按位相等来
        比较常量，因此如果逻辑等价的值不是按位相等的会导致出现不想要
        的规划结果。
       </para>
      </listitem>

      <listitem>
       <para>
        大部分的内部<productname>PostgreSQL</productname>类型
        都声明在<filename>postgres.h</filename>中，不过函数管理器
        接口（<symbol>PG_FUNCTION_ARGS</symbol>等）在
        <filename>fmgr.h</filename>中，因此你将需要包括至少这两个
        文件。为了移植性，最好在包括任何其他系统或者用户头文件之前，
        <emphasis>先</emphasis>包括<filename>postgres.h</filename>。包
        括<filename>postgres.h</filename>也将会为你包括
        <filename>elog.h</filename>和<filename>palloc.h</filename>。
       </para>
      </listitem>

      <listitem>
       <para>
        对象文件中定义的符号名不能相互冲突或者与
        <productname>PostgreSQL</productname>服务器可执行程序中
        定义的符号冲突。如果出现有关于此的错误消息，你将必须重命名你的
        函数或者变量。
       </para>
      </listitem>
     </itemizedlist>
    </para>
<!-- pgdoc-cn_end sig_en=2bb88ea656a4203fa1c1d148cf17ac93 -->
   </sect2>

&dfunc;

   <sect2>
<!-- pgdoc-cn_start sig_en=a82ae9611e53da5651cdb8d5173c31df sig_cn_org=None source=14.1 
    <title>Composite-Type Arguments</title>
________________________________________________________-->
    <title>组合类型参数</title>
<!-- pgdoc-cn_end sig_en=a82ae9611e53da5651cdb8d5173c31df -->

<!-- pgdoc-cn_start sig_en=6cea360a0dc7a5654abfba0f77d25bdf sig_cn_org=None source=14.1 
    <para>
     Composite types do not have a fixed layout like C structures.
     Instances of a composite type can contain null fields.  In
     addition, composite types that are part of an inheritance
     hierarchy can have different fields than other members of the
     same inheritance hierarchy.  Therefore,
     <productname>PostgreSQL</productname> provides a function
     interface for accessing fields of composite types from C.
    </para>
________________________________________________________-->
    <para>
     组合类型没有像 C 结构那样的固定布局。组合类型的实例可能包含
     空值域。此外，继承层次中的组合类型可能具有和同一继承层次中
     其他成员不同的域。因此，
     <productname>PostgreSQL</productname>提供了函数接口
     来访问 C 的组合类型的域。
    </para>
<!-- pgdoc-cn_end sig_en=6cea360a0dc7a5654abfba0f77d25bdf -->

<!-- pgdoc-cn_start sig_en=7196f3695e6f4ccdcbe8063676f6bee9 sig_cn_org=None source=14.1 
    <para>
     Suppose we want to write a function to answer the query:

<programlisting>
SELECT name, c_overpaid(emp, 1500) AS overpaid
    FROM emp
    WHERE name = 'Bill' OR name = 'Sam';
</programlisting>

     Using the version-1 calling conventions, we can define
     <function>c_overpaid</function> as:

<programlisting><![CDATA[
#include "postgres.h"
#include "executor/executor.h"  /* for GetAttributeByName() */

PG_MODULE_MAGIC;

PG_FUNCTION_INFO_V1(c_overpaid);

Datum
c_overpaid(PG_FUNCTION_ARGS)
{
    HeapTupleHeader  t = PG_GETARG_HEAPTUPLEHEADER(0);
    int32            limit = PG_GETARG_INT32(1);
    bool isnull;
    Datum salary;

    salary = GetAttributeByName(t, "salary", &isnull);
    if (isnull)
        PG_RETURN_BOOL(false);
    /* Alternatively, we might prefer to do PG_RETURN_NULL() for null salary. */

    PG_RETURN_BOOL(DatumGetInt32(salary) > limit);
}
]]>
</programlisting>
    </para>
________________________________________________________-->
    <para>
     假设我们想要写一个函数来回答查询：

<programlisting>
SELECT name, c_overpaid(emp, 1500) AS overpaid
    FROM emp
    WHERE name = 'Bill' OR name = 'Sam';
</programlisting>

     如果使用版本-1的调用规范，我们可以定义
     <function>c_overpaid</function>为：

<programlisting><![CDATA[
#include "postgres.h"
#include "executor/executor.h"  /* 用于 GetAttributeByName() */

PG_MODULE_MAGIC;

PG_FUNCTION_INFO_V1(c_overpaid);

Datum
c_overpaid(PG_FUNCTION_ARGS)
{
    HeapTupleHeader  t = PG_GETARG_HEAPTUPLEHEADER(0);
    int32            limit = PG_GETARG_INT32(1);
    bool isnull;
    Datum salary;

    salary = GetAttributeByName(t, "salary", &isnull);
    if (isnull)
        PG_RETURN_BOOL(false);
    /* 另外，我们可能更想对空 salary 用 PG_RETURN_NULL() 。*/

    PG_RETURN_BOOL(DatumGetInt32(salary) > limit);
}
]]>
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=7196f3695e6f4ccdcbe8063676f6bee9 -->

<!-- pgdoc-cn_start sig_en=96316c71d63cbca5ab360756020f439f sig_cn_org=None source=14.1 
    <para>
     <function>GetAttributeByName</function> is the
     <productname>PostgreSQL</productname> system function that
     returns attributes out of the specified row.  It has
     three arguments: the argument of type <type>HeapTupleHeader</type> passed
     into
     the  function, the name of the desired attribute, and a
     return parameter that tells whether  the  attribute
     is  null.   <function>GetAttributeByName</function> returns a <type>Datum</type>
     value that you can convert to the proper data type by using the
     appropriate <function>DatumGet<replaceable>XXX</replaceable>()</function>
     macro.  Note that the return value is meaningless if the null flag is
     set; always check the null flag before trying to do anything with the
     result.
    </para>
________________________________________________________-->
    <para>
     <function>GetAttributeByName</function>是返回指定行的属性的
     <productname>PostgreSQL</productname>系统函数。它有三个参数：
     类型为<type>HeapTupleHeader</type>的传入参数、想要访问的函数名
     以及一个说明该属性是否为空的返回参数。
     <function>GetAttributeByName</function>返回一个<type>Datum</type>
     值，可以把它用合适的<function>DatumGet<replaceable>XXX</replaceable>()</function>
     宏转换成正确的数据类型。注意如果空值标志被设置，那么返回值是没有
     意义的，所以在对结果做任何事情之前应该先检查空值标志。
    </para>
<!-- pgdoc-cn_end sig_en=96316c71d63cbca5ab360756020f439f -->

<!-- pgdoc-cn_start sig_en=5bcc0464d458631ee6f090ca8f5da7a7 sig_cn_org=None source=14.1 
    <para>
     There is also <function>GetAttributeByNum</function>, which selects
     the target attribute by column number instead of name.
    </para>
________________________________________________________-->
    <para>
     也有<function>GetAttributeByNum</function>函数，它可以用目标属性
     的属性号而不是属性名来选择目标属性。
    </para>
<!-- pgdoc-cn_end sig_en=5bcc0464d458631ee6f090ca8f5da7a7 -->

<!-- pgdoc-cn_start sig_en=48498e9f435179344a87d9cc655bd927 sig_cn_org=None source=14.1 
    <para>
     The following command declares the function
     <function>c_overpaid</function> in SQL:

<programlisting>
CREATE FUNCTION c_overpaid(emp, integer) RETURNS boolean
    AS '<replaceable>DIRECTORY</replaceable>/funcs', 'c_overpaid'
    LANGUAGE C STRICT;
</programlisting>

     Notice we have used <literal>STRICT</literal> so that we did not have to
     check whether the input arguments were NULL.
    </para>
________________________________________________________-->
    <para>
     下面的命令声明 SQL 中的<function>c_overpaid</function>：

<programlisting>
CREATE FUNCTION c_overpaid(emp, integer) RETURNS boolean
    AS '<replaceable>DIRECTORY</replaceable>/funcs', 'c_overpaid'
    LANGUAGE C STRICT;
</programlisting>

     注意我们用了<literal>STRICT</literal>，这样我们不需要检查输入参数是否
     为 NULL。
    </para>
<!-- pgdoc-cn_end sig_en=48498e9f435179344a87d9cc655bd927 -->
   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=dbfcb9778e00388b37311587d7609e3e sig_cn_org=None source=14.1 
    <title>Returning Rows (Composite Types)</title>
________________________________________________________-->
    <title>返回行（组合类型）</title>
<!-- pgdoc-cn_end sig_en=dbfcb9778e00388b37311587d7609e3e -->

<!-- pgdoc-cn_start sig_en=8398d9e73765edca585f76ccb804da42 sig_cn_org=None source=14.1 
    <para>
     To return a row or composite-type value from a C-language
     function, you can use a special API that provides macros and
     functions to hide most of the complexity of building composite
     data types.  To use this API, the source file must include:
<programlisting>
#include "funcapi.h"
</programlisting>
    </para>
________________________________________________________-->
    <para>
     要从一个 C 语言函数中返回一个行或者组合类型值，你可以使用一种
     特殊的 API，它提供的宏和函数隐藏了大部分的构建组合数据类型的
     复杂性。要使用这种 API，源文件中必须包括：
<programlisting>
#include "funcapi.h"
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=8398d9e73765edca585f76ccb804da42 -->

<!-- pgdoc-cn_start sig_en=7169b3c2f12a668068511abb6543cb0e sig_cn_org=None source=14.1 
    <para>
     There are two ways you can build a composite data value (henceforth
     a <quote>tuple</quote>): you can build it from an array of Datum values,
     or from an array of C strings that can be passed to the input
     conversion functions of the tuple's column data types.  In either
     case, you first need to obtain or construct a <structname>TupleDesc</structname>
     descriptor for the tuple structure.  When working with Datums, you
     pass the <structname>TupleDesc</structname> to <function>BlessTupleDesc</function>,
     and then call <function>heap_form_tuple</function> for each row.  When working
     with C strings, you pass the <structname>TupleDesc</structname> to
     <function>TupleDescGetAttInMetadata</function>, and then call
     <function>BuildTupleFromCStrings</function> for each row.  In the case of a
     function returning a set of tuples, the setup steps can all be done
     once during the first call of the function.
    </para>
________________________________________________________-->
    <para>
     有两种方式可以构建一个组合数据值（以后就叫一个<quote>元组</quote>）：
     可以从一个 Datum 值的数组构造，或者从一个 C 字符串（可被传递给该元组
     各列的数据类型的输入转换函数）的数组构造。在两种情况下，都首先需要为
     该元组的结构获得或者构造一个<structname>TupleDesc</structname>描述符。在处
     理 Datum 时，需要把该<structname>TupleDesc</structname>传递给
     <function>BlessTupleDesc</function>，接着为每一行调用
     <function>heap_form_tuple</function>。在处理 C 字符串时，需要把该
     <structname>TupleDesc</structname>传递给
     <function>TupleDescGetAttInMetadata</function>，接着为每一行调用
     <function>BuildTupleFromCStrings</function>。对于返回一个元组集合的函数，
     这些设置步骤可以在第一次调用该函数时一次性完成。
    </para>
<!-- pgdoc-cn_end sig_en=7169b3c2f12a668068511abb6543cb0e -->

<!-- pgdoc-cn_start sig_en=ea06e47cecde378b7270f3df5d0fd2e8 sig_cn_org=None source=14.1 
    <para>
     Several helper functions are available for setting up the needed
     <structname>TupleDesc</structname>.  The recommended way to do this in most
     functions returning composite values is to call:
<programlisting>
TypeFuncClass get_call_result_type(FunctionCallInfo fcinfo,
                                   Oid *resultTypeId,
                                   TupleDesc *resultTupleDesc)
</programlisting>
     passing the same <literal>fcinfo</literal> struct passed to the calling function
     itself.  (This of course requires that you use the version-1
     calling conventions.)  <varname>resultTypeId</varname> can be specified
     as <literal>NULL</literal> or as the address of a local variable to receive the
     function's result type OID.  <varname>resultTupleDesc</varname> should be the
     address of a local <structname>TupleDesc</structname> variable.  Check that the
     result is <literal>TYPEFUNC_COMPOSITE</literal>; if so,
     <varname>resultTupleDesc</varname> has been filled with the needed
     <structname>TupleDesc</structname>.  (If it is not, you can report an error along
     the lines of <quote>function returning record called in context that
     cannot accept type record</quote>.)
    </para>
________________________________________________________-->
    <para>
     有一些助手函数可以用来设置所需的<structname>TupleDesc</structname>。在大部分
     返回组合值的函数中推荐的方式是调用：
<programlisting>
TypeFuncClass get_call_result_type(FunctionCallInfo fcinfo,
                                   Oid *resultTypeId,
                                   TupleDesc *resultTupleDesc)
</programlisting>
     传递传给调用函数本身的同一个<literal>fcinfo</literal>结构（这当然要求使用的
     是版本-1 的调用规范）。<varname>resultTypeId</varname>可以被指定为
     <literal>NULL</literal>或者一个本地变量的地址以接收该函数的结果类型 OID。
     <varname>resultTupleDesc</varname>应该是一个本地
     <structname>TupleDesc</structname>变量的地址。检查结果是不是
     <literal>TYPEFUNC_COMPOSITE</literal>，如果是则
     <varname>resultTupleDesc</varname>已经被用所需的
     <structname>TupleDesc</structname>填充（如果不是，你可以报告一个错误，并且
     返回<quote>function returning record called in context that
     cannot accept type record</quote>字样的消息）。
    </para>
<!-- pgdoc-cn_end sig_en=ea06e47cecde378b7270f3df5d0fd2e8 -->

    <tip>
<!-- pgdoc-cn_start sig_en=d8479cec8444b31959e046ae3a391db3 sig_cn_org=None source=14.1 
     <para>
      <function>get_call_result_type</function> can resolve the actual type of a
      polymorphic function result; so it is useful in functions that return
      scalar polymorphic results, not only functions that return composites.
      The <varname>resultTypeId</varname> output is primarily useful for functions
      returning polymorphic scalars.
     </para>
________________________________________________________-->
     <para>
      <function>get_call_result_type</function>能够解析一个多态函数结果的实际类型，
      因此不仅在返回组合类型的函数中，在返回标量多态结果的函数中它也是非常
      有用的。<varname>resultTypeId</varname>输出主要用于返回多态标量的函数。
     </para>
<!-- pgdoc-cn_end sig_en=d8479cec8444b31959e046ae3a391db3 -->
    </tip>

    <note>
<!-- pgdoc-cn_start sig_en=723ff85551422308796532b6fb6e678f sig_cn_org=None source=14.1 
     <para>
      <function>get_call_result_type</function> has a sibling
      <function>get_expr_result_type</function>, which can be used to resolve the
      expected output type for a function call represented by an expression
      tree.  This can be used when trying to determine the result type from
      outside the function itself.  There is also
      <function>get_func_result_type</function>, which can be used when only the
      function's OID is available.  However these functions are not able
      to deal with functions declared to return <structname>record</structname>, and
      <function>get_func_result_type</function> cannot resolve polymorphic types,
      so you should preferentially use <function>get_call_result_type</function>.
     </para>
________________________________________________________-->
     <para>
      <function>get_call_result_type</function>有一个兄弟
      <function>get_expr_result_type</function>，它被用来解析被表示为一棵表达式
      树的函数调用的输出类型。在尝试确定来自函数外部的结果类型时可以用它。
      也有一个<function>get_func_result_type</function>，当只有函数的 OID 可用时
      可以用它。不过这些函数无法处理被声明为返回<structname>record</structname>的
      函数，并且<function>get_func_result_type</function>无法解析多态类型，因此你
      应该优先使用<function>get_call_result_type</function>。
     </para>
<!-- pgdoc-cn_end sig_en=723ff85551422308796532b6fb6e678f -->
    </note>

<!-- pgdoc-cn_start sig_en=cfed270950e7263033a5531dfb6b7867 sig_cn_org=None source=14.1 
    <para>
     Older, now-deprecated functions for obtaining
     <structname>TupleDesc</structname>s are:
<programlisting>
TupleDesc RelationNameGetTupleDesc(const char *relname)
</programlisting>
     to get a <structname>TupleDesc</structname> for the row type of a named relation,
     and:
<programlisting>
TupleDesc TypeGetTupleDesc(Oid typeoid, List *colaliases)
</programlisting>
     to get a <structname>TupleDesc</structname> based on a type OID. This can
     be used to get a <structname>TupleDesc</structname> for a base or
     composite type.  It will not work for a function that returns
     <structname>record</structname>, however, and it cannot resolve polymorphic
     types.
    </para>
________________________________________________________-->
    <para>
     比较老的，现在已经被废弃的获得<structname>TupleDesc</structname>的函数是：
<programlisting>
TupleDesc RelationNameGetTupleDesc(const char *relname)
</programlisting>
     它可以为一个提到的关系的行类型得到<structname>TupleDesc</structname>，
     还有：
<programlisting>
TupleDesc TypeGetTupleDesc(Oid typeoid, List *colaliases)
</programlisting>
     可以基于一个类型 OID 得到<structname>TupleDesc</structname>。这可以被用来
     为一种基础或者组合类型获得<structname>TupleDesc</structname>。不过，对于
     返回<structname>record</structname>的函数它不起作用，并且它无法解析多态类型。
    </para>
<!-- pgdoc-cn_end sig_en=cfed270950e7263033a5531dfb6b7867 -->

<!-- pgdoc-cn_start sig_en=771b05ce8be6faa5cd09bbb74914c622 sig_cn_org=None source=14.1 
    <para>
     Once you have a <structname>TupleDesc</structname>, call:
<programlisting>
TupleDesc BlessTupleDesc(TupleDesc tupdesc)
</programlisting>
     if you plan to work with Datums, or:
<programlisting>
AttInMetadata *TupleDescGetAttInMetadata(TupleDesc tupdesc)
</programlisting>
     if you plan to work with C strings.  If you are writing a function
     returning set, you can save the results of these functions in the
     <structname>FuncCallContext</structname> structure &mdash; use the
     <structfield>tuple_desc</structfield> or <structfield>attinmeta</structfield> field
     respectively.
    </para>
________________________________________________________-->
    <para>
     一旦有了一个<structname>TupleDesc</structname>，如果计划处理 Datum可以调用：
<programlisting>
TupleDesc BlessTupleDesc(TupleDesc tupdesc)
</programlisting>
     如果计划处理 C 字符串，可调用：
<programlisting>
AttInMetadata *TupleDescGetAttInMetadata(TupleDesc tupdesc)
</programlisting>
     如果正在编写一个返回集合的函数，你可以把这些函数的结果保存在
     <structname>FuncCallContext</structname>结构中 &mdash; 分别使用
     <structfield>tuple_desc</structfield>或者<structfield>attinmeta</structfield>域。
    </para>
<!-- pgdoc-cn_end sig_en=771b05ce8be6faa5cd09bbb74914c622 -->

<!-- pgdoc-cn_start sig_en=f01f6046e40bf5e66b90206c98800046 sig_cn_org=None source=14.1 
    <para>
     When working with Datums, use:
<programlisting>
HeapTuple heap_form_tuple(TupleDesc tupdesc, Datum *values, bool *isnull)
</programlisting>
     to build a <structname>HeapTuple</structname> given user data in Datum form.
    </para>
________________________________________________________-->
    <para>
     在处理 Datum 时，使用
<programlisting>
HeapTuple heap_form_tuple(TupleDesc tupdesc, Datum *values, bool *isnull)
</programlisting>
     来用 Datum 形式的用户数据构建一个<structname>HeapTuple</structname>。
    </para>
<!-- pgdoc-cn_end sig_en=f01f6046e40bf5e66b90206c98800046 -->

<!-- pgdoc-cn_start sig_en=0ee2c127109e34bb2dccb40a9e818911 sig_cn_org=None source=14.1 
    <para>
     When working with C strings, use:
<programlisting>
HeapTuple BuildTupleFromCStrings(AttInMetadata *attinmeta, char **values)
</programlisting>
     to build a <structname>HeapTuple</structname> given user data
     in C string form.  <parameter>values</parameter> is an array of C strings,
     one for each attribute of the return row. Each C string should be in
     the form expected by the input function of the attribute data
     type. In order to return a null value for one of the attributes,
     the corresponding pointer in the <parameter>values</parameter> array
     should be set to <symbol>NULL</symbol>.  This function will need to
     be called again for each row you return.
    </para>
________________________________________________________-->
    <para>
     在处理 C 字符串时，使用
<programlisting>
HeapTuple BuildTupleFromCStrings(AttInMetadata *attinmeta, char **values)
</programlisting>
     来用 C 字符串形式的用户数据构建一个<structname>HeapTuple</structname>。
     <parameter>values</parameter>是一个 C 字符串数组，每一个元素是返回行
     的一个属性。每一个 C 字符串应该是该属性数据类型的输入函数所期望
     的格式。为了对一个属性返回空值，<parameter>values</parameter>数组中对
     应的指针应该被设置为<symbol>NULL</symbol>。对于你返回的每一行都将
     再次调用这个函数。
    </para>
<!-- pgdoc-cn_end sig_en=0ee2c127109e34bb2dccb40a9e818911 -->

<!-- pgdoc-cn_start sig_en=0a084d2c523d3422de52a1bc8af33002 sig_cn_org=None source=14.1 
    <para>
     Once you have built a tuple to return from your function, it
     must be converted into a <type>Datum</type>. Use:
<programlisting>
HeapTupleGetDatum(HeapTuple tuple)
</programlisting>
     to convert a <structname>HeapTuple</structname> into a valid Datum.  This
     <type>Datum</type> can be returned directly if you intend to return
     just a single row, or it can be used as the current return value
     in a set-returning function.
    </para>
________________________________________________________-->
    <para>
     一旦已经构建了一个要从函数中返回的元组，它必须被转换成一个
     <type>Datum</type>。使用
<programlisting>
HeapTupleGetDatum(HeapTuple tuple)
</programlisting>
     可把一个<structname>HeapTuple</structname>转换成合法的 Datum。如果你
     只想返回一行，那么这个<type>Datum</type>可以被直接返回，在一个
     集合返回函数中它也可以被当做当前的返回值。
    </para>
<!-- pgdoc-cn_end sig_en=0a084d2c523d3422de52a1bc8af33002 -->

<!-- pgdoc-cn_start sig_en=70a78f7124e785580d2c1930d1f9717c sig_cn_org=None source=14.1 
    <para>
     An example appears in the next section.
    </para>
________________________________________________________-->
    <para>
     下一节中会有一个例子。
    </para>
<!-- pgdoc-cn_end sig_en=70a78f7124e785580d2c1930d1f9717c -->

   </sect2>

   <sect2 id="xfunc-c-return-set">
<!-- pgdoc-cn_start sig_en=3e26a8c40651103e5695f1c7deee08fe sig_cn_org=None source=14.1 
    <title>Returning Sets</title>
________________________________________________________-->
    <title>返回集合</title>
<!-- pgdoc-cn_end sig_en=3e26a8c40651103e5695f1c7deee08fe -->

<!-- pgdoc-cn_start sig_en=9df76ebc62ebe6bb98d80ad69526a3ab sig_cn_org=None source=14.1 
    <para>
     C-language functions have two options for returning sets (multiple
     rows).  In one method, called <firstterm>ValuePerCall</firstterm>
     mode, a set-returning function is called repeatedly (passing the same
     arguments each time) and it returns one new row on each call, until
     it has no more rows to return and signals that by returning NULL.
     The set-returning function (<acronym>SRF</acronym>) must therefore
     save enough state across calls to remember what it was doing and
     return the correct next item on each call.
     In the other method, called <firstterm>Materialize</firstterm> mode,
     an SRF fills and returns a tuplestore object containing its
     entire result; then only one call occurs for the whole result, and
     no inter-call state is needed.
    </para>
________________________________________________________-->
    <para>
     C 语言函数有两个返回集合（多行）的选项。在一种称为<firstterm>ValuePerCall</firstterm>
     模式的方法中，一个集合返回函数被重复调用（每次传递相同的参数），并在每次调用时返回一个新行，
     直到没有更多行要返回并且 通过返回 NULL 来表示这一点。因此，集合返回函数 (<acronym>SRF</acronym>) 
     必须在调用之间保存足够的状态以记住它在做什么并在每次调用时返回正确的下一项。
     在另一种称为<firstterm>Materialize</firstterm>模式的方法中，SRF 填充并返回一个包含其整个结果的 tuplestore 对象； 
     那么整个结果只发生一次调用，不需要调用间状态。
    </para>
<!-- pgdoc-cn_end sig_en=9df76ebc62ebe6bb98d80ad69526a3ab -->

<!-- pgdoc-cn_start sig_en=9e9d8202fa2ced0e607708d9f580f973 sig_cn_org=None source=14.1 
    <para>
     When using ValuePerCall mode, it is important to remember that the
     query is not guaranteed to be run to completion; that is, due to
     options such as <literal>LIMIT</literal>, the executor might stop
     making calls to the set-returning function before all rows have been
     fetched.  This means it is not safe to perform cleanup activities in
     the last call, because that might not ever happen.  It's recommended
     to use Materialize mode for functions that need access to external
     resources, such as file descriptors.
    </para>
________________________________________________________-->
    <para>
     使用 ValuePerCall 模式时，重要的是要记住查询不能保证运行完成； 
     也就是说，由于诸如<literal>LIMIT</literal>之类的选项，
     执行程序可能会在获取所有行之前停止调用 set-returning 函数。
     这意味着在最后一次调用中执行清理活动是不安全的，因为这可能永远不会发生。
     对于需要访问外部资源（例如文件描述符）的函数，建议使用 Materialize 模式。
    </para>
<!-- pgdoc-cn_end sig_en=9e9d8202fa2ced0e607708d9f580f973 -->

<!-- pgdoc-cn_start sig_en=1957e8be7c8fe501316c1eed16f74a4c sig_cn_org=None source=14.1 
    <para>
     The remainder of this section documents a set of helper macros that
     are commonly used (though not required to be used) for SRFs using
     ValuePerCall mode.  Additional details about Materialize mode can be
     found in <filename>src/backend/utils/fmgr/README</filename>.  Also,
     the <filename>contrib</filename> modules in
     the <productname>PostgreSQL</productname> source distribution contain
     many examples of SRFs using both ValuePerCall and Materialize mode.
    </para>
________________________________________________________-->
    <para>
     本节的其余部分记录了一组使用 ValuePerCall 模式的 SRF 常用（尽管不是必须使用）的帮助程序宏。
     有关 Materialize 模式的其他详细信息可以在<filename>src/backend/utils/fmgr/README</filename>中找到。
     此外，<productname>PostgreSQL</productname>源代码分发中的<filename>contrib</filename> 
     模块包含许多使用 ValuePerCall 和 Materialize 模式的 SRF 示例。
    </para>
<!-- pgdoc-cn_end sig_en=1957e8be7c8fe501316c1eed16f74a4c -->

<!-- pgdoc-cn_start sig_en=5cbaf05ee655c964e1a3bdfe6165ebd7 sig_cn_org=None source=14.1 
    <para>
     To use the ValuePerCall support macros described here,
     include <filename>funcapi.h</filename>.  These macros work with a
     structure <structname>FuncCallContext</structname> that contains the
     state that needs to be saved across calls.  Within the calling
     SRF, <literal>fcinfo-&gt;flinfo-&gt;fn_extra</literal> is used to
     hold a pointer to <structname>FuncCallContext</structname> across
     calls.  The macros automatically fill that field on first use,
     and expect to find the same pointer there on subsequent uses.
<programlisting>
typedef struct FuncCallContext
{
    /*
     * Number of times we've been called before
     *
     * call_cntr is initialized to 0 for you by SRF_FIRSTCALL_INIT(), and
     * incremented for you every time SRF_RETURN_NEXT() is called.
     */
    uint64 call_cntr;

    /*
     * OPTIONAL maximum number of calls
     *
     * max_calls is here for convenience only and setting it is optional.
     * If not set, you must provide alternative means to know when the
     * function is done.
     */
    uint64 max_calls;

    /*
     * OPTIONAL pointer to miscellaneous user-provided context information
     *
     * user_fctx is for use as a pointer to your own data to retain
     * arbitrary context information between calls of your function.
     */
    void *user_fctx;

    /*
     * OPTIONAL pointer to struct containing attribute type input metadata
     *
     * attinmeta is for use when returning tuples (i.e., composite data types)
     * and is not used when returning base data types. It is only needed
     * if you intend to use BuildTupleFromCStrings() to create the return
     * tuple.
     */
    AttInMetadata *attinmeta;

    /*
     * memory context used for structures that must live for multiple calls
     *
     * multi_call_memory_ctx is set by SRF_FIRSTCALL_INIT() for you, and used
     * by SRF_RETURN_DONE() for cleanup. It is the most appropriate memory
     * context for any memory that is to be reused across multiple calls
     * of the SRF.
     */
    MemoryContext multi_call_memory_ctx;

    /*
     * OPTIONAL pointer to struct containing tuple description
     *
     * tuple_desc is for use when returning tuples (i.e., composite data types)
     * and is only needed if you are going to build the tuples with
     * heap_form_tuple() rather than with BuildTupleFromCStrings().  Note that
     * the TupleDesc pointer stored here should usually have been run through
     * BlessTupleDesc() first.
     */
    TupleDesc tuple_desc;

} FuncCallContext;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     要使用此处描述的 ValuePerCall 支持宏，请包含<filename>funcapi.h</filename>。
     这些宏与结构<structname>FuncCallContext</structname>一起使用，该结构包含需要跨调用保存的状态。
     在调用 SRF 中，<literal>fcinfo-&gt;flinfo-&gt;fn_extra</literal>用于在调用之间保存
     指向<structname>FuncCallContext</structname>的指针。
     宏在第一次使用时自动填充该字段，并期望在后续使用中找到相同的指针。
<programlisting>
typedef struct FuncCallContext
{
    /*
     * 本次调用以前已经被调用过多少次
     *
     * SRF_FIRSTCALL_INIT() 会为你把 call_cntr 初始化为 0，
     * 并且在每次调用 SRF_RETURN_NEXT() 时增加。
     */
    uint64 call_cntr;

    /*
     * 可选：最大调用次数
     *
     * 这里的 max_calls 只是为了方便，设置它是可选的。
     * 如果没有设置，你必须提供替代的方法来了解函数什么时候做完。
     */
    uint64 max_calls;

    /*
     * 可选：指向用户提供的上下文信息的指针
     *
     * user_fctx 是一个指向你自己的数据的指针，它可用来在函数的多次
     * 调用之间保存任意的上下文信息。
     */
    void *user_fctx;

    /*
     * 可选：指向包含属性类型输入元数据的结构的指针
     *
     * attinmeta 被用在返回元组（即组合数据类型）时，在返回基本数据类型
     * 时不会使用。只有想用BuildTupleFromCStrings()创建返回元组时才需要它。
     */
    AttInMetadata *attinmeta;

    /*
     * 用于保存必须在多次调用间都存在的结构的内存上下文
     *
     * SRF_FIRSTCALL_INIT() 会为你设置 multi_call_memory_ctx，并且由
     * SRF_RETURN_DONE() 来清理。对于任何需要在 SRF 的多次调用间都
     * 存在的内存来说，它是最合适的内存上下文。
     */
    MemoryContext multi_call_memory_ctx;

    /*
     * 可选：指向包含元组描述的结构的指针
     *
     * tuple_desc 被用在返回元组（即组合数据类型）时，并且只有在用
     * heap_form_tuple() 而不是 BuildTupleFromCStrings() 构建元组时才需要它。
     * 注意这里存储的 TupleDesc 指针通常已经被先运行过 BlessTupleDesc()。
     */
    TupleDesc tuple_desc;

} FuncCallContext;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=5cbaf05ee655c964e1a3bdfe6165ebd7 -->

<!-- pgdoc-cn_start sig_en=65e2493089fe2e11eaabf1647d1310b4 sig_cn_org=None source=14.1 
    <para>
     The macros to be used by an <acronym>SRF</acronym> using this
     infrastructure are:
<programlisting>
SRF_IS_FIRSTCALL()
</programlisting>
     Use this to determine if your function is being called for the first or a
     subsequent time. On the first call (only), call:
<programlisting>
SRF_FIRSTCALL_INIT()
</programlisting>
     to initialize the <structname>FuncCallContext</structname>. On every function call,
     including the first, call:
<programlisting>
SRF_PERCALL_SETUP()
</programlisting>
     to set up for using the <structname>FuncCallContext</structname>.
    </para>
________________________________________________________-->
    <para>
     使用此基础结构的<acronym>SRF</acronym>将使用的宏是：
<programlisting>
SRF_IS_FIRSTCALL()
</programlisting>
     来判断你的函数是否是第一次被调用。在第一次调用时（只能在第一次调用时）使用：
<programlisting>
SRF_FIRSTCALL_INIT()
</programlisting>
	 初始化<structname>FuncCallContext</structname>。在每次函数调用时，包含第一次，调用：
<programlisting>
SRF_PERCALL_SETUP()
</programlisting>
     设置使用<structname>FuncCallContext</structname>。
    </para>
<!-- pgdoc-cn_end sig_en=65e2493089fe2e11eaabf1647d1310b4 -->

<!-- pgdoc-cn_start sig_en=8245b4fdb6e3aa6a3b89777eb3a02041 sig_cn_org=None source=14.1 
    <para>
     If your function has data to return in the current call, use:
<programlisting>
SRF_RETURN_NEXT(funcctx, result)
</programlisting>
     to return it to the caller.  (<literal>result</literal> must be of type
     <type>Datum</type>, either a single value or a tuple prepared as
     described above.)  Finally, when your function is finished
     returning data, use:
<programlisting>
SRF_RETURN_DONE(funcctx)
</programlisting>
     to clean up and end the <acronym>SRF</acronym>.
    </para>
________________________________________________________-->
    <para>
     如果您的函数有数据要在当前调用中返回，请使用：
<programlisting>
SRF_RETURN_NEXT(funcctx, result)
</programlisting>
     把它返回给调用者（<literal>result</literal>必须是类型<type>Datum</type>，
     可以是一个单一值或者按上文所述准备好的元组）。最后，当函数完成了
     数据返回后，可使用：
<programlisting>
SRF_RETURN_DONE(funcctx)
</programlisting>
     来清理并且结束<acronym>SRF</acronym>。
    </para>
<!-- pgdoc-cn_end sig_en=8245b4fdb6e3aa6a3b89777eb3a02041 -->

<!-- pgdoc-cn_start sig_en=5d45df48d7cf96e856c885e69295fa24 sig_cn_org=None source=14.1 
    <para>
     The memory context that is current when the <acronym>SRF</acronym> is called is
     a transient context that will be cleared between calls.  This means
     that you do not need to call <function>pfree</function> on everything
     you allocated using <function>palloc</function>; it will go away anyway.  However, if you want to allocate
     any data structures to live across calls, you need to put them somewhere
     else.  The memory context referenced by
     <structfield>multi_call_memory_ctx</structfield> is a suitable location for any
     data that needs to survive until the <acronym>SRF</acronym> is finished running.  In most
     cases, this means that you should switch into
     <structfield>multi_call_memory_ctx</structfield> while doing the
     first-call setup.
     Use <literal>funcctx-&gt;user_fctx</literal> to hold a pointer to
     any such cross-call data structures.
     (Data you allocate
     in <structfield>multi_call_memory_ctx</structfield> will go away
     automatically when the query ends, so it is not necessary to free
     that data manually, either.)
    </para>
________________________________________________________-->
    <para>
     <acronym>SRF</acronym>被调用时的当前内存上下文被称作一个瞬时上下文，
     在两次调用之间会清除它。这意味着你不必对用<function>palloc</function>
     分配的所有东西调用<function>pfree</function>，它们将自动被释放。不过，
     如果你想要分配任何需要在多次调用间都存在的数据结构，需要把它们
     放在其他地方。对于任何需要在<acronym>SRF</acronym>结束运行之前都存
     在的数据来说，<structfield>multi_call_memory_ctx</structfield>引用的内存
     上下文是一个合适的位置。在大多数情况下，这意味着您应该在进行首次调用设置时切换到
     <structfield>multi_call_memory_ctx</structfield>。 
     使用<literal>funcctx-&gt;user_fctx</literal>来保存指向任何此类交叉调用数据结构的指针。
     （您在<structfield>multi_call_memory_ctx</structfield>中分配的数据将在查询结束时自动消失，
     因此也无需手动释放该数据。）
    </para>
<!-- pgdoc-cn_end sig_en=5d45df48d7cf96e856c885e69295fa24 -->

    <warning>
<!-- pgdoc-cn_start sig_en=432bb9cd498462430c29cf6f8130505c sig_cn_org=None source=14.1 
     <para>
      While the actual arguments to the function remain unchanged between
      calls, if you detoast the argument values (which is normally done
      transparently by the
      <function>PG_GETARG_<replaceable>xxx</replaceable></function> macro)
      in the transient context then the detoasted copies will be freed on
      each cycle. Accordingly, if you keep references to such values in
      your <structfield>user_fctx</structfield>, you must either copy them into the
      <structfield>multi_call_memory_ctx</structfield> after detoasting, or ensure
      that you detoast the values only in that context.
     </para>
________________________________________________________-->
     <para>
      虽然函数的实参在多次调用之间保持不变，但如果在瞬时上下文中
      反 TOAST 了参数（通常由
      <function>PG_GETARG_<replaceable>xxx</replaceable></function>
      宏完成），那么被反 TOAST 的拷贝将在每次循环中被释放。相应地，
      如果你把这些值的引用保存在<structfield>user_fctx</structfield>中，你也必
      须在反 TOAST 之后把它们拷贝到
      <structfield>multi_call_memory_ctx</structfield>中，或者确保你只在那个
      上下文中反 TOAST 这些值。
     </para>
<!-- pgdoc-cn_end sig_en=432bb9cd498462430c29cf6f8130505c -->
    </warning>

<!-- pgdoc-cn_start sig_en=c3d0214744568857d769543ec7208371 sig_cn_org=None source=14.1 
    <para>
     A complete pseudo-code example looks like the following:
<programlisting>
Datum
my_set_returning_function(PG_FUNCTION_ARGS)
{
    FuncCallContext  *funcctx;
    Datum             result;
    <replaceable>further declarations as needed</replaceable>

    if (SRF_IS_FIRSTCALL())
    {
        MemoryContext oldcontext;

        funcctx = SRF_FIRSTCALL_INIT();
        oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);
        /* One-time setup code appears here: */
        <replaceable>user code</replaceable>
        <replaceable>if returning composite</replaceable>
            <replaceable>build TupleDesc, and perhaps AttInMetadata</replaceable>
        <replaceable>endif returning composite</replaceable>
        <replaceable>user code</replaceable>
        MemoryContextSwitchTo(oldcontext);
    }

    /* Each-time setup code appears here: */
    <replaceable>user code</replaceable>
    funcctx = SRF_PERCALL_SETUP();
    <replaceable>user code</replaceable>

    /* this is just one way we might test whether we are done: */
    if (funcctx-&gt;call_cntr &lt; funcctx-&gt;max_calls)
    {
        /* Here we want to return another item: */
        <replaceable>user code</replaceable>
        <replaceable>obtain result Datum</replaceable>
        SRF_RETURN_NEXT(funcctx, result);
    }
    else
    {
        /* Here we are done returning items, so just report that fact. */
        /* (Resist the temptation to put cleanup code here.) */
        SRF_RETURN_DONE(funcctx);
    }
}
</programlisting>
    </para>
________________________________________________________-->
    <para>
     一个完整的伪代码例子：
<programlisting>
Datum
my_set_returning_function(PG_FUNCTION_ARGS)
{
    FuncCallContext  *funcctx;
    Datum             result;
    <replaceable>further declarations as needed</replaceable>

    if (SRF_IS_FIRSTCALL())
    {
        MemoryContext oldcontext;

        funcctx = SRF_FIRSTCALL_INIT();
        oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);
        /* 这里是一次性设置代码： */
        <replaceable>user code</replaceable>
        <replaceable>if returning composite</replaceable>
            <replaceable>build TupleDesc, and perhaps AttInMetadata</replaceable>
        <replaceable>endif returning composite</replaceable>
        <replaceable>user code</replaceable>
        MemoryContextSwitchTo(oldcontext);
    }

    /* 这里是每一次都要做的设置代码： */
    <replaceable>user code</replaceable>
    funcctx = SRF_PERCALL_SETUP();
    <replaceable>user code</replaceable>

    /* 这里只是一种测试是否执行完的方法： */
    if (funcctx-&gt;call_cntr &lt; funcctx-&gt;max_calls)
    {
        /* 这里返回另一个项： */
        <replaceable>user code</replaceable>
        <replaceable>obtain result Datum</replaceable>
        SRF_RETURN_NEXT(funcctx, result);
    }
    else
    {
        /* 这里已经完成了项的返回，所以只报告事实。 */
        /* （不要将清理代码放在这里的。） */
        SRF_RETURN_DONE(funcctx);
    }
}
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=c3d0214744568857d769543ec7208371 -->

<!-- pgdoc-cn_start sig_en=e4bad1cfedee81a9d409adc5af9fff17 sig_cn_org=dcb22b6bffcbdd03462c7a33341d5112 source=15.7 
    <para>
     A complete example of a simple <acronym>SRF</acronym> returning a composite type
     looks like:
<programlisting><![CDATA[
PG_FUNCTION_INFO_V1(retcomposite);

Datum
retcomposite(PG_FUNCTION_ARGS)
{
    FuncCallContext     *funcctx;
    int                  call_cntr;
    int                  max_calls;
    TupleDesc            tupdesc;
    AttInMetadata       *attinmeta;

    /* stuff done only on the first call of the function */
    if (SRF_IS_FIRSTCALL())
    {
        MemoryContext   oldcontext;

        /* create a function context for cross-call persistence */
        funcctx = SRF_FIRSTCALL_INIT();

        /* switch to memory context appropriate for multiple function calls */
        oldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);

        /* total number of tuples to be returned */
        funcctx->max_calls = PG_GETARG_INT32(0);

        /* Build a tuple descriptor for our result type */
        if (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)
            ereport(ERROR,
                    (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                     errmsg("function returning record called in context "
                            "that cannot accept type record")));

        /*
         * generate attribute metadata needed later to produce tuples from raw
         * C strings
         */
        attinmeta = TupleDescGetAttInMetadata(tupdesc);
        funcctx->attinmeta = attinmeta;

        MemoryContextSwitchTo(oldcontext);
    }

    /* stuff done on every call of the function */
    funcctx = SRF_PERCALL_SETUP();

    call_cntr = funcctx->call_cntr;
    max_calls = funcctx->max_calls;
    attinmeta = funcctx->attinmeta;

    if (call_cntr < max_calls)    /* do when there is more left to send */
    {
        char       **values;
        HeapTuple    tuple;
        Datum        result;

        /*
         * Prepare a values array for building the returned tuple.
         * This should be an array of C strings which will
         * be processed later by the type input functions.
         */
        values = (char **) palloc(3 * sizeof(char *));
        values[0] = (char *) palloc(16 * sizeof(char));
        values[1] = (char *) palloc(16 * sizeof(char));
        values[2] = (char *) palloc(16 * sizeof(char));

        snprintf(values[0], 16, "%d", 1 * PG_GETARG_INT32(1));
        snprintf(values[1], 16, "%d", 2 * PG_GETARG_INT32(1));
        snprintf(values[2], 16, "%d", 3 * PG_GETARG_INT32(1));

        /* build a tuple */
        tuple = BuildTupleFromCStrings(attinmeta, values);

        /* make the tuple into a datum */
        result = HeapTupleGetDatum(tuple);

        /* clean up (this is not really necessary) */
        pfree(values[0]);
        pfree(values[1]);
        pfree(values[2]);
        pfree(values);

        SRF_RETURN_NEXT(funcctx, result);
    }
    else    /* do when there is no more left */
    {
        SRF_RETURN_DONE(funcctx);
    }
}
]]>
</programlisting>

     One way to declare this function in SQL is:
<programlisting>
CREATE TYPE __retcomposite AS (f1 integer, f2 integer, f3 integer);

CREATE OR REPLACE FUNCTION retcomposite(integer, integer)
    RETURNS SETOF __retcomposite
    AS '<replaceable>filename</replaceable>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;
</programlisting>
     A different way is to use OUT parameters:
<programlisting>
CREATE OR REPLACE FUNCTION retcomposite(IN integer, IN integer,
    OUT f1 integer, OUT f2 integer, OUT f3 integer)
    RETURNS SETOF record
    AS '<replaceable>filename</replaceable>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;
</programlisting>
     Notice that in this method the output type of the function is formally
     an anonymous <structname>record</structname> type.
    </para>
________________________________________________________-->
    <para>
     一个返回复合类型的简单<acronym>SRF</acronym>的完整示例如下：
<programlisting><![CDATA[
PG_FUNCTION_INFO_V1(retcomposite);

Datum
retcomposite(PG_FUNCTION_ARGS)
{
    FuncCallContext     *funcctx;
    int                  call_cntr;
    int                  max_calls;
    TupleDesc            tupdesc;
    AttInMetadata       *attinmeta;

    /* 仅在函数的第一次调用时执行的操作 */
    if (SRF_IS_FIRSTCALL())
    {
        MemoryContext   oldcontext;

        /* 为跨调用持久性创建函数上下文 */
        funcctx = SRF_FIRSTCALL_INIT();

        /* 切换到适合多次函数调用的内存上下文 */
        oldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);

        /* 要返回的元组总数 */
        funcctx->max_calls = PG_GETARG_INT32(0);

        /* 为我们的结果类型构建一个元组描述符 */
        if (get_call_result_type(fcinfo, NULL, &tupdesc) != TYPEFUNC_COMPOSITE)
            ereport(ERROR,
                    (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                     errmsg("function returning record called in context "
                            "that cannot accept type record")));

        /*
         * 生成后续从原始C字符串生成元组所需的属性元数据
         */
        attinmeta = TupleDescGetAttInMetadata(tupdesc);
        funcctx->attinmeta = attinmeta;

        MemoryContextSwitchTo(oldcontext);
    }

    /* 每次函数调用时执行的操作 */
    funcctx = SRF_PERCALL_SETUP();

    call_cntr = funcctx->call_cntr;
    max_calls = funcctx->max_calls;
    attinmeta = funcctx->attinmeta;

    if (call_cntr < max_calls)    /* 当还有更多要发送时执行 */
    {
        char       **values;
        HeapTuple    tuple;
        Datum        result;

        /*
         * 为构建返回的元组准备一个值数组。
         * 这应该是一个由后续类型输入函数处理的C字符串数组。
         */
        values = (char **) palloc(3 * sizeof(char *));
        values[0] = (char *) palloc(16 * sizeof(char));
        values[1] = (char *) palloc(16 * sizeof(char));
        values[2] = (char *) palloc(16 * sizeof(char));

        snprintf(values[0], 16, "%d", 1 * PG_GETARG_INT32(1));
        snprintf(values[1], 16, "%d", 2 * PG_GETARG_INT32(1));
        snprintf(values[2], 16, "%d", 3 * PG_GETARG_INT32(1));

        /* 构建一个元组 */
        tuple = BuildTupleFromCStrings(attinmeta, values);

        /* 将元组转换为数据 */
        result = HeapTupleGetDatum(tuple);

        /* 清理（这实际上并不是必要的） */
        pfree(values[0]);
        pfree(values[1]);
        pfree(values[2]);
        pfree(values);

        SRF_RETURN_NEXT(funcctx, result);
    }
    else    /* 当没有更多要发送时执行 */
    {
        SRF_RETURN_DONE(funcctx);
    }
}
]]>
</programlisting>

     在SQL中声明此函数的一种方法是：
<programlisting>
CREATE TYPE __retcomposite AS (f1 integer, f2 integer, f3 integer);

CREATE OR REPLACE FUNCTION retcomposite(integer, integer)
    RETURNS SETOF __retcomposite
    AS '<replaceable>filename</replaceable>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;
</programlisting>
     另一种方法是使用OUT参数：
<programlisting>
CREATE OR REPLACE FUNCTION retcomposite(IN integer, IN integer,
    OUT f1 integer, OUT f2 integer, OUT f3 integer)
    RETURNS SETOF record
    AS '<replaceable>filename</replaceable>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;
</programlisting>
     请注意，在这种方法中，函数的输出类型形式上是一个匿名<structname>record</structname>类型。
    </para>
<!-- pgdoc-cn_end sig_en=e4bad1cfedee81a9d409adc5af9fff17 -->
   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=386233f603132ba593cd9a41f5ff1b7e sig_cn_org=None source=14.1 
    <title>Polymorphic Arguments and Return Types</title>
________________________________________________________-->
    <title>多态参数和返回类型</title>
<!-- pgdoc-cn_end sig_en=386233f603132ba593cd9a41f5ff1b7e -->

<!-- pgdoc-cn_start sig_en=c7d1a19129cefdcb9fc877d035e40800 sig_cn_org=None source=14.1 
    <para>
     C-language functions can be declared to accept and
     return the polymorphic types described in <xref
     linkend="extend-types-polymorphic"/>.
     When a function's arguments or return types
     are defined as polymorphic types, the function author cannot know
     in advance what data type it will be called with, or
     need to return. There are two routines provided in <filename>fmgr.h</filename>
     to allow a version-1 C function to discover the actual data types
     of its arguments and the type it is expected to return. The routines are
     called <literal>get_fn_expr_rettype(FmgrInfo *flinfo)</literal> and
     <literal>get_fn_expr_argtype(FmgrInfo *flinfo, int argnum)</literal>.
     They return the result or argument type OID, or <symbol>InvalidOid</symbol> if the
     information is not available.
     The structure <literal>flinfo</literal> is normally accessed as
     <literal>fcinfo-&gt;flinfo</literal>. The parameter <literal>argnum</literal>
     is zero based.  <function>get_call_result_type</function> can also be used
     as an alternative to <function>get_fn_expr_rettype</function>.
     There is also <function>get_fn_expr_variadic</function>, which can be used to
     find out whether variadic arguments have been merged into an array.
     This is primarily useful for <literal>VARIADIC "any"</literal> functions,
     since such merging will always have occurred for variadic functions
     taking ordinary array types.
    </para>
________________________________________________________-->
    <para>
     可以声明 C 语言函数来接受和返回<xref linkend="extend-types-polymorphic"/>中描述的多态类型。当函数参数或者返回
     类型被定义为多态类型时，函数的编写者无法提前知道会用什么数据类型
     调用该函数或者该函数需要返回什么数据类型。在<filename>fmgr.h</filename>
     中提供了两种例程来允许版本-1 的 C 函数发现其参数的实际数据类型以及
     它要返回的类型。这些例程被称为
     <literal>get_fn_expr_rettype(FmgrInfo *flinfo)</literal>和
     <literal>get_fn_expr_argtype(FmgrInfo *flinfo, int argnum)</literal>。它们
     返回结果或者参数的类型的 OID，或者当该信息不可用时返回
     <symbol>InvalidOid</symbol>。结构<literal>flinfo</literal>通常被当做
     <literal>fcinfo-&gt;flinfo</literal>访问。参数<literal>argnum</literal>则是从零
     开始计。<function>get_call_result_type</function>也可被用作
     <function>get_fn_expr_rettype</function>的一种替代品。还有
     <function>get_fn_expr_variadic</function>，它可以被用来找出 variadic 参数
     是否已经被合并到了一个数组中。这主要用于
     <literal>VARIADIC "any"</literal>函数，因为对于接收普通数组类型的
     variadic 函数来说总是会发生这类合并。
    </para>
<!-- pgdoc-cn_end sig_en=c7d1a19129cefdcb9fc877d035e40800 -->

<!-- pgdoc-cn_start sig_en=2a2bf38a7808fcf5670a78e4729cd222 sig_cn_org=None source=14.1 
    <para>
     For example, suppose we want to write a function to accept a single
     element of any type, and return a one-dimensional array of that type:

<programlisting>
PG_FUNCTION_INFO_V1(make_array);
Datum
make_array(PG_FUNCTION_ARGS)
{
    ArrayType  *result;
    Oid         element_type = get_fn_expr_argtype(fcinfo-&gt;flinfo, 0);
    Datum       element;
    bool        isnull;
    int16       typlen;
    bool        typbyval;
    char        typalign;
    int         ndims;
    int         dims[MAXDIM];
    int         lbs[MAXDIM];

    if (!OidIsValid(element_type))
        elog(ERROR, "could not determine data type of input");

    /* get the provided element, being careful in case it's NULL */
    isnull = PG_ARGISNULL(0);
    if (isnull)
        element = (Datum) 0;
    else
        element = PG_GETARG_DATUM(0);

    /* we have one dimension */
    ndims = 1;
    /* and one element */
    dims[0] = 1;
    /* and lower bound is 1 */
    lbs[0] = 1;

    /* get required info about the element type */
    get_typlenbyvalalign(element_type, &amp;typlen, &amp;typbyval, &amp;typalign);

    /* now build the array */
    result = construct_md_array(&amp;element, &amp;isnull, ndims, dims, lbs,
                                element_type, typlen, typbyval, typalign);

    PG_RETURN_ARRAYTYPE_P(result);
}
</programlisting>
    </para>
________________________________________________________-->
    <para>
     例如，假设我们想要写一个接收一个任意类型元素并且返回一个该类型的一维
     数组的函数：

<programlisting>
PG_FUNCTION_INFO_V1(make_array);
Datum
make_array(PG_FUNCTION_ARGS)
{
    ArrayType  *result;
    Oid         element_type = get_fn_expr_argtype(fcinfo-&gt;flinfo, 0);
    Datum       element;
    bool        isnull;
    int16       typlen;
    bool        typbyval;
    char        typalign;
    int         ndims;
    int         dims[MAXDIM];
    int         lbs[MAXDIM];

    if (!OidIsValid(element_type))
        elog(ERROR, "could not determine data type of input");

    /* 得到提供的元素，小心它为 NULL 的情况 */
    isnull = PG_ARGISNULL(0);
    if (isnull)
        element = (Datum) 0;
    else
        element = PG_GETARG_DATUM(0);

    /* 只有一个维度 */
    ndims = 1;
    /* 和一个元素 */
    dims[0] = 1;
    /* 且下界是 1 */
    lbs[0] = 1;

    /* 得到该元素类型所需的信息 */
    get_typlenbyvalalign(element_type, &amp;typlen, &amp;typbyval, &amp;typalign);

    /* 现在构建数组 */
    result = construct_md_array(&amp;element, &amp;isnull, ndims, dims, lbs,
                                element_type, typlen, typbyval, typalign);

    PG_RETURN_ARRAYTYPE_P(result);
}
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=2a2bf38a7808fcf5670a78e4729cd222 -->

<!-- pgdoc-cn_start sig_en=2b04b65fa3461745c28594d17b2b1ae0 sig_cn_org=None source=14.1 
    <para>
     The following command declares the function
     <function>make_array</function> in SQL:

<programlisting>
CREATE FUNCTION make_array(anyelement) RETURNS anyarray
    AS '<replaceable>DIRECTORY</replaceable>/funcs', 'make_array'
    LANGUAGE C IMMUTABLE;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     下面的命令在 SQL 中声明函数<function>make_array</function>：

<programlisting>
CREATE FUNCTION make_array(anyelement) RETURNS anyarray
    AS '<replaceable>DIRECTORY</replaceable>/funcs', 'make_array'
    LANGUAGE C IMMUTABLE;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=2b04b65fa3461745c28594d17b2b1ae0 -->

<!-- pgdoc-cn_start sig_en=ceb66359703d7509133a518c14ef4249 sig_cn_org=None source=14.1 
    <para>
     There is a variant of polymorphism that is only available to C-language
     functions: they can be declared to take parameters of type
     <literal>"any"</literal>.  (Note that this type name must be double-quoted,
     since it's also an SQL reserved word.)  This works like
     <type>anyelement</type> except that it does not constrain different
     <literal>"any"</literal> arguments to be the same type, nor do they help
     determine the function's result type.  A C-language function can also
     declare its final parameter to be <literal>VARIADIC "any"</literal>.  This will
     match one or more actual arguments of any type (not necessarily the same
     type).  These arguments will <emphasis>not</emphasis> be gathered into an array
     as happens with normal variadic functions; they will just be passed to
     the function separately.  The <function>PG_NARGS()</function> macro and the
     methods described above must be used to determine the number of actual
     arguments and their types when using this feature.  Also, users of such
     a function might wish to use the <literal>VARIADIC</literal> keyword in their
     function call, with the expectation that the function would treat the
     array elements as separate arguments.  The function itself must implement
     that behavior if wanted, after using <function>get_fn_expr_variadic</function> to
     detect that the actual argument was marked with <literal>VARIADIC</literal>.
    </para>
________________________________________________________-->
    <para>
     有一种只对 C 语言函数可用的多态变体：它们可以被声明为接受类型为
     <literal>"any"</literal>的参数（注意这种类型名必须用双引号引用，因为它也
     是一个 SQL 保留字）。这和<type>anyelement</type>相似，不过它不约束
     不同的<literal>"any"</literal>参数为同一种类型，它们也不会帮助确定函数的
     结果类型。C 语言函数也能声明它的第一个参数为
     <literal>VARIADIC "any"</literal>。这可以匹配一个或者多个任意类型的实参（
     不需要是同一种类型）。这些参数<emphasis>不会</emphasis>像普通 variadic 函
     数那样被收集到一个数组中，它们将被单独传递给该函数。使用这种特性时，
     必须用<function>PG_NARGS()</function>宏以及上述方法来判断实参的个数和类
     型。还有，这种函数的用户可能希望在他们的函数调用中使用
     <literal>VARIADIC</literal>关键词，以期让该函数将数组元素作为单独的参数
     对待。如果想要这样，在使用<function>get_fn_expr_variadic</function>检测被
     标记为<literal>VARIADIC</literal>的实参之后，函数本身必须实现这种行为。
    </para>
<!-- pgdoc-cn_end sig_en=ceb66359703d7509133a518c14ef4249 -->
   </sect2>

   <sect2 id="xfunc-shared-addin">
<!-- pgdoc-cn_start sig_en=2d343a9e69946bb0ff2ab97eb2cb147a sig_cn_org=None source=14.1 
    <title>Shared Memory and LWLocks</title>
________________________________________________________-->
    <title>共享内存和 LWLock</title>
<!-- pgdoc-cn_end sig_en=2d343a9e69946bb0ff2ab97eb2cb147a -->

<!-- pgdoc-cn_start sig_en=c2c5bb1fceb88b01ae744ba1fb46f31b sig_cn_org=b5301551ade2992f5737940a8ac11ab4 source=15.7 
    <para>
     Add-ins can reserve LWLocks and an allocation of shared memory on server
     startup.  The add-in's shared library must be preloaded by specifying
     it in
     <xref linkend="guc-shared-preload-libraries"/><indexterm><primary>shared_preload_libraries</primary></indexterm>.
     The shared library should register a <literal>shmem_request_hook</literal>
     in its <function>_PG_init</function> function.  This
     <literal>shmem_request_hook</literal> can reserve LWLocks or shared memory.
     Shared memory is reserved by calling:
<programlisting>
void RequestAddinShmemSpace(int size)
</programlisting>
     from your <literal>shmem_request_hook</literal>.
    </para>
________________________________________________________-->
    <para>
     Add-ins可以在服务器启动时保留LWLocks和共享内存的分配。添加的共享库必须通过在
     <xref linkend="guc-shared-preload-libraries"/><indexterm><primary>shared_preload_libraries</primary></indexterm>
     中指定进行预加载。共享库应在其<function>_PG_init</function>函数中注册一个<literal>shmem_request_hook</literal>。
     这个<literal>shmem_request_hook</literal>可以保留LWLocks或共享内存。
     通过调用以下方式来保留共享内存：
<programlisting>
void RequestAddinShmemSpace(int size)
</programlisting>
     从你的<literal>shmem_request_hook</literal>中调用。
    </para>
<!-- pgdoc-cn_end sig_en=c2c5bb1fceb88b01ae744ba1fb46f31b -->
<!-- pgdoc-cn_start sig_en=1321cffb435dbe90be97f36153ef0e68 sig_cn_org=67fcb0f1c288029053e5dab7f6875459 source=15.7 
    <para>
     LWLocks are reserved by calling:
<programlisting>
void RequestNamedLWLockTranche(const char *tranche_name, int num_lwlocks)
</programlisting>
     from your <literal>shmem_request_hook</literal>.  This will ensure that an array of
     <literal>num_lwlocks</literal> LWLocks is available under the name
     <literal>tranche_name</literal>.  Use <function>GetNamedLWLockTranche</function>
     to get a pointer to this array.
    </para>
________________________________________________________-->
    <para>
     LWLocks是通过调用:
<programlisting>
void RequestNamedLWLockTranche(const char *tranche_name, int num_lwlocks)
</programlisting>
     从您的<literal>shmem_request_hook</literal>中保留的。这将确保一个名为
     <literal>tranche_name</literal>的<literal>num_lwlocks</literal>数组LWLocks可用。使用<function>GetNamedLWLockTranche</function>
     来获取指向该数组的指针。
    </para>
<!-- pgdoc-cn_end sig_en=1321cffb435dbe90be97f36153ef0e68 -->
<!-- pgdoc-cn_start sig_en=122803fe724022c150ba382e56b7d327 sig_cn_org=727984950bfb4730d9afc78967d0ce7f source=15.7 
    <para>
     An example of a <literal>shmem_request_hook</literal> can be found in
     <filename>contrib/pg_stat_statements/pg_stat_statements.c</filename> in the
     <productname>PostgreSQL</productname> source tree.
    </para>
________________________________________________________-->
    <para>
     一个<literal>shmem_request_hook</literal>的示例可以在<filename>contrib/pg_stat_statements/pg_stat_statements.c</filename>中找到，
     位于<productname>PostgreSQL</productname>源代码树中。
    </para>
<!-- pgdoc-cn_end sig_en=122803fe724022c150ba382e56b7d327 -->
<!-- pgdoc-cn_start sig_en=126728c0bb489e66c9c905f84ff3b855 sig_cn_org=None source=14.1 
    <para>
     To avoid possible race-conditions, each backend should use the LWLock
     <function>AddinShmemInitLock</function> when connecting to and initializing
     its allocation of shared memory, as shown here:
<programlisting>
static mystruct *ptr = NULL;

if (!ptr)
{
        bool    found;

        LWLockAcquire(AddinShmemInitLock, LW_EXCLUSIVE);
        ptr = ShmemInitStruct("my struct name", size, &amp;found);
        if (!found)
        {
                initialize contents of shmem area;
                acquire any requested LWLocks using:
                ptr->locks = GetNamedLWLockTranche("my tranche name");
        }
        LWLockRelease(AddinShmemInitLock);
}
</programlisting>
    </para>
________________________________________________________-->
    <para>
     为了避免可能的竞争情况，在连接并且初始化共享内存时，每一个
     后端应该使用 LWLock
     <function>AddinShmemInitLock</function>，如下所示：
<programlisting>
static mystruct *ptr = NULL;

if (!ptr)
{
        bool    found;

        LWLockAcquire(AddinShmemInitLock, LW_EXCLUSIVE);
        ptr = ShmemInitStruct("my struct name", size, &amp;found);
        if (!found)
        {
                initialize contents of shmem area;
                acquire any requested LWLocks using:
                ptr->locks = GetNamedLWLockTranche("my tranche name");
        }
        LWLockRelease(AddinShmemInitLock);
}
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=126728c0bb489e66c9c905f84ff3b855 -->
   </sect2>

   <sect2 id="extend-cpp">
<!-- pgdoc-cn_start sig_en=60632b470b4b072d050173a2a0421900 sig_cn_org=None source=14.1 
    <title>Using C++ for Extensibility</title>
________________________________________________________-->
    <title>把 C++ 用于可扩展性</title>
<!-- pgdoc-cn_end sig_en=60632b470b4b072d050173a2a0421900 -->

<!-- pgdoc-cn_start sig_en=486b437d89f9e3bb8b2e4f02e6e3d1d3 sig_cn_org=None source=14.1 
    <indexterm zone="extend-cpp">
     <primary>C++</primary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="extend-cpp">
     <primary>C++</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=486b437d89f9e3bb8b2e4f02e6e3d1d3 -->

<!-- pgdoc-cn_start sig_en=096b8f60a6afa92df78113c69a7bce88 sig_cn_org=None source=14.1 
    <para>
     Although the <productname>PostgreSQL</productname> backend is written in
     C, it is possible to write extensions in C++ if these guidelines are
     followed:

     <itemizedlist>
      <listitem>
       <para>
         All functions accessed by the backend must present a C interface
         to the backend;  these C functions can then call C++ functions.
         For example, <literal>extern C</literal> linkage is required for
         backend-accessed functions.  This is also necessary for any
         functions that are passed as pointers between the backend and
         C++ code.
       </para>
      </listitem>
      <listitem>
       <para>
        Free memory using the appropriate deallocation method.  For example,
        most backend memory is allocated using <function>palloc()</function>, so use
        <function>pfree()</function> to free it.  Using C++
        <function>delete</function> in such cases will fail.
       </para>
      </listitem>
      <listitem>
       <para>
        Prevent exceptions from propagating into the C code (use a catch-all
        block at the top level of all <literal>extern C</literal> functions).  This
        is necessary even if the C++ code does not explicitly throw any
        exceptions, because events like out-of-memory can still throw
        exceptions.  Any exceptions must be caught and appropriate errors
        passed back to the C interface.  If possible, compile C++ with
        <option>-fno-exceptions</option> to eliminate exceptions entirely; in such
        cases, you must check for failures in your C++ code, e.g.,  check for
        NULL returned by <function>new()</function>.
       </para>
      </listitem>
      <listitem>
       <para>
        If calling backend functions from C++ code, be sure that the
        C++ call stack contains only plain old data structures
        (<acronym>POD</acronym>).  This is necessary because backend errors
        generate a distant <function>longjmp()</function> that does not properly
        unroll a C++ call stack with non-POD objects.
       </para>
      </listitem>
     </itemizedlist>
    </para>
________________________________________________________-->
    <para>
     尽管<productname>PostgreSQL</productname>后端是用 C 编写的，
     只要遵循下面的指导方针也可以用 C++ 编写扩展：

     <itemizedlist>
      <listitem>
       <para>
         所有被后端访问的函数必须对后端呈现一种 C 接口，然后这些 C 函数
         调用 C++ 函数。例如，对后端访问的函数要求<literal>extern C</literal>
         链接。对需要在后端和 C++ 代码之间作为指针传递的任何函数也要
         这样做。
       </para>
      </listitem>
      <listitem>
       <para>
        使用合适的释放方法释放内存。例如，大部分后端内存是通过
        <function>palloc()</function>分配的，所以应使用<function>pfree()</function>
        来释放。在这种情况中使用 C++ 的<function>delete</function>会失败。
       </para>
      </listitem>
      <listitem>
       <para>
        防止异常传播到 C 代码中（在所有<literal>extern C</literal>函数的顶层
        使用一个捕捉全部异常的块）。即使 C++ 代码不会显式地抛出任何
        异常也需要这样做，因为类似内存不足等事件仍会抛出异常。任何异常
        都必须被捕捉并且用适当的错误传回给 C 接口。如果可能，用
        <option>-fno-exceptions</option> 来编译 C++ 以完全消灭异常。在这种
        情况下，你必须在 C++ 代码中检查失败，例如检查<function>new()</function>
        返回的 NULL。
       </para>
      </listitem>
      <listitem>
       <para>
        如果从 C++ 代码调用后端函数，确定 C++ 调用栈值包含传统 C 风格
        的数据结构（<acronym>POD</acronym>）。这是必要的，因为后端错误会
        产生远距离的<function>longjmp()</function>，它无法正确的退回具有非
        POD 对象的 C++ 调用栈。
       </para>
      </listitem>
     </itemizedlist>
    </para>
<!-- pgdoc-cn_end sig_en=096b8f60a6afa92df78113c69a7bce88 -->

<!-- pgdoc-cn_start sig_en=851d25c5569df7dd3dc482c8d4bdbb3b sig_cn_org=None source=14.1 
    <para>
     In summary, it is best to place C++ code behind a wall of
     <literal>extern C</literal> functions that interface to the backend,
     and avoid exception, memory, and call stack leakage.
    </para>
________________________________________________________-->
    <para>
     总之，最好把 C++ 代码放在与后端交互的<literal>extern C</literal>函数之后，
     并且避免异常、内存和调用栈泄露。
    </para>
<!-- pgdoc-cn_end sig_en=851d25c5569df7dd3dc482c8d4bdbb3b -->
   </sect2>

  </sect1>

  <sect1 id="xfunc-optimization">
<!-- pgdoc-cn_start sig_en=dd068c47b44f0cea2de487f551ed4287 sig_cn_org=None source=14.1 
   <title>Function Optimization Information</title>
________________________________________________________-->
   <title>函数优化信息</title>
<!-- pgdoc-cn_end sig_en=dd068c47b44f0cea2de487f551ed4287 -->

<!-- pgdoc-cn_start sig_en=ba9438899d56fc3c231ed03ae77d449f sig_cn_org=None source=14.1 
  <indexterm zone="xfunc-optimization">
   <primary>optimization information</primary>
   <secondary>for functions</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="xfunc-optimization">
   <primary>optimization information</primary>
   <secondary>for functions</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=ba9438899d56fc3c231ed03ae77d449f -->

<!-- pgdoc-cn_start sig_en=175e00f54ca967fc45bae4a07f825129 sig_cn_org=None source=14.1 
   <para>
    By default, a function is just a <quote>black box</quote> that the
    database system knows very little about the behavior of.  However,
    that means that queries using the function may be executed much less
    efficiently than they could be.  It is possible to supply additional
    knowledge that helps the planner optimize function calls.
   </para>
________________________________________________________-->
   <para>
    默认情况下，函数只是一个<quote>black box</quote>，数据库系统对它的行为了解得很少。 
    不过，这意味着使用函数的查询执行效率可能会低于它们的能力。可以提供额外的知识帮助计划器优化函数调用。
   </para>
<!-- pgdoc-cn_end sig_en=175e00f54ca967fc45bae4a07f825129 -->

<!-- pgdoc-cn_start sig_en=ff8b855f9ff2017bd1c14821b7186c9b sig_cn_org=None source=14.1 
   <para>
    Some basic facts can be supplied by declarative annotations provided in
    the <link linkend="sql-createfunction"><command>CREATE FUNCTION</command></link> command.  Most important of
    these is the function's <link linkend="xfunc-volatility">volatility
    category</link> (<literal>IMMUTABLE</literal>, <literal>STABLE</literal>,
    or <literal>VOLATILE</literal>); one should always be careful to
    specify this correctly when defining a function.
    The parallel safety property (<literal>PARALLEL
    UNSAFE</literal>, <literal>PARALLEL RESTRICTED</literal>, or
    <literal>PARALLEL SAFE</literal>) must also be specified if you hope
    to use the function in parallelized queries.
    It can also be useful to specify the function's estimated execution
    cost, and/or the number of rows a set-returning function is estimated
    to return.  However, the declarative way of specifying those two
    facts only allows specifying a constant value, which is often
    inadequate.
   </para>
________________________________________________________-->
   <para>
    一些基本事实可以通过<link linkend="sql-createfunction"><command>CREATE FUNCTION</command></link>命令中提供的声明性注释来提供。
    这里面最重要的是函数的<link linkend="xfunc-volatility">volatility category</link> (<literal>IMMUTABLE</literal>、 <literal>STABLE</literal>或 <literal>VOLATILE</literal>)；在定义函数时，要始终小心地正确指定这个。
    并行安全属性(<literal>PARALLEL UNSAFE</literal>、<literal>PARALLEL RESTRICTED</literal>或<literal>PARALLEL SAFE</literal>)也必须被指定，如果你希望在并行查询中使用该函数。
    指定函数的估算执行开销也会有作用，和/或集返回函数估计返回的行数。不过，指定这两个事实的声明方式只允许指定常数值，而这通常是不够的。
   </para>
<!-- pgdoc-cn_end sig_en=ff8b855f9ff2017bd1c14821b7186c9b -->

<!-- pgdoc-cn_start sig_en=a0b288da82f505817f17e0ecb9a8645c sig_cn_org=None source=14.1 
   <para>
    It is also possible to attach a <firstterm>planner support
    function</firstterm> to an SQL-callable function (called
    its <firstterm>target function</firstterm>), and thereby provide
    knowledge about the target function that is too complex to be
    represented declaratively.  Planner support functions have to be
    written in C (although their target functions might not be), so this is
    an advanced feature that relatively few people will use.
   </para>
________________________________________________________-->
   <para>
    也可以将一个<firstterm>planner support function</firstterm> 附加到SQL-可调用函数（称为<firstterm>target function</firstterm>），
    从而提供关于目标函数的知识，该函数过于复杂而无法以声明方式表示。
    计划器支持函数必须写在 C 中（尽管它们的目标函数可以不是），所以这是一个高级功能，相对很少有人会使用。
   </para>
<!-- pgdoc-cn_end sig_en=a0b288da82f505817f17e0ecb9a8645c -->

<!-- pgdoc-cn_start sig_en=f9bf49a31e7c63ffe59335efc0a1f809 sig_cn_org=None source=14.1 
   <para>
    A planner support function must have the SQL signature
<programlisting>
supportfn(internal) returns internal
</programlisting>
    It is attached to its target function by specifying
    the <literal>SUPPORT</literal> clause when creating the target function.
   </para>
________________________________________________________-->
   <para>
    计划器支持函数必须具有SQL签名
<programlisting>
supportfn(internal) returns internal
</programlisting>
    当建立目标函数时，它通过指定<literal>SUPPORT</literal>子句附加到它的目标函数。
   </para>
<!-- pgdoc-cn_end sig_en=f9bf49a31e7c63ffe59335efc0a1f809 -->

<!-- pgdoc-cn_start sig_en=79acf2676d74825a669a6fe71b803089 sig_cn_org=None source=14.1 
   <para>
    The details of the API for planner support functions can be found in
    file <filename>src/include/nodes/supportnodes.h</filename> in the
    <productname>PostgreSQL</productname> source code.  Here we provide
    just an overview of what planner support functions can do.
    The set of possible requests to a support function is extensible,
    so more things might be possible in future versions.
   </para>
________________________________________________________-->
   <para>
    计划器支持函数的 API 的详细信息可以在 <productname>PostgreSQL</productname>源代码中的<filename>src/include/nodes/supportnodes.h</filename>文件中找到。 
    这里我们提供了计划器支持函数的概述。支持函数的可能请求集合是可扩展的，所以在将来的版本中可能会有更多(功能)。
   </para>
<!-- pgdoc-cn_end sig_en=79acf2676d74825a669a6fe71b803089 -->

<!-- pgdoc-cn_start sig_en=f98c870789dbac8a23bb5a7bf1569285 sig_cn_org=None source=14.1 
   <para>
    Some function calls can be simplified during planning based on
    properties specific to the function.  For example,
    <literal>int4mul(n, 1)</literal> could be simplified to
    just <literal>n</literal>.  This type of transformation can be
    performed by a planner support function, by having it implement
    the <literal>SupportRequestSimplify</literal> request type.
    The support function will be called for each instance of its target
    function found in a query parse tree.  If it finds that the particular
    call can be simplified into some other form, it can build and return a
    parse tree representing that expression.  This will automatically work
    for operators based on the function, too &mdash; in the example just
    given, <literal>n * 1</literal> would also be simplified to
    <literal>n</literal>.
    (But note that this is just an example; this particular
    optimization is not actually performed by
    standard <productname>PostgreSQL</productname>.)
    We make no guarantee that <productname>PostgreSQL</productname> will
    never call the target function in cases that the support function could
    simplify.  Ensure rigorous equivalence between the simplified
    expression and an actual execution of the target function.
   </para>
________________________________________________________-->
   <para>
    在规划期间，根据指定函数的特性，一些函数调用可以进行简化。
    例如，<literal>int4mul(n, 1)</literal>可以被简化为<literal>n</literal>。 
    这种类型的转换可以通过计划器支持函数执行，通过它实现<literal>SupportRequestSimplify</literal>请求类型。
    对于在查询解析树中找到其目标函数的每个实例，将调用支持函数。如果它发现特定的调用可以简化成某种其他窗体，它可以构建并返回表示该表达式的解析树。 
    这将为基于函数的操作符自动工作，非常&mdash;在刚才的示例中，<literal>n * 1</literal>也将简化为<literal>n</literal>。
    （但注意这只是一个例子；这个特殊的优化实际上不是标准的<productname>PostgreSQL</productname>执行）。
    我们不保证<productname>PostgreSQL</productname>在支持函数能够简化的情况下，永远不会调用目标函数。 确保简化表达式与目标函数的实际执行之间严格等效。
   </para>
<!-- pgdoc-cn_end sig_en=f98c870789dbac8a23bb5a7bf1569285 -->

<!-- pgdoc-cn_start sig_en=2fba2d0f472671b23b9d10410af58280 sig_cn_org=None source=14.1 
   <para>
    For target functions that return <type>boolean</type>, it is often useful to estimate
    the fraction of rows that will be selected by a <literal>WHERE</literal> clause using that
    function.  This can be done by a support function that implements
    the <literal>SupportRequestSelectivity</literal> request type.
   </para>
________________________________________________________-->
   <para>
    对于返回 <type>boolean</type> 的目标函数，估计使用该函数的 <literal>WHERE</literal> 子句将选择的行的比重通常会有用。
    这可以通过实现<literal>SupportRequestSelectivity</literal>请求类型的支持函数来完成。
   </para>
<!-- pgdoc-cn_end sig_en=2fba2d0f472671b23b9d10410af58280 -->

<!-- pgdoc-cn_start sig_en=cf085a89e5c96f0fb69c22200710e2d3 sig_cn_org=None source=14.1 
   <para>
    If the target function's run time is highly dependent on its inputs,
    it may be useful to provide a non-constant cost estimate for it.
    This can be done by a support function that implements
    the <literal>SupportRequestCost</literal> request type.
   </para>
________________________________________________________-->
   <para>
    如果目标函数的运行时间高度依赖于其输入，提供非固定开销估算可能很有用。这可以通过实现<literal>SupportRequestCost</literal>请求类型的支持函数来完成。
   </para>
<!-- pgdoc-cn_end sig_en=cf085a89e5c96f0fb69c22200710e2d3 -->

<!-- pgdoc-cn_start sig_en=f7af0f1f1584d0ae9100a8563dc666ea sig_cn_org=None source=14.1 
   <para>
    For target functions that return sets, it is often useful to provide
    a non-constant estimate for the number of rows that will be returned.
    This can be done by a support function that implements
    the <literal>SupportRequestRows</literal> request type.
   </para>
________________________________________________________-->
   <para>
    对于返回集的目标函数，为提供要返回的行数的非常量估计通常很有用。这可以通过实现<literal>SupportRequestRows</literal>请求类型的支持函数来完成。
   </para>
<!-- pgdoc-cn_end sig_en=f7af0f1f1584d0ae9100a8563dc666ea -->

<!-- pgdoc-cn_start sig_en=208ca6608b052e8abc6ef5196509141d sig_cn_org=None source=14.1 
   <para>
    For target functions that return <type>boolean</type>, it may be possible to
    convert a function call appearing in <literal>WHERE</literal> into an indexable operator
    clause or clauses.  The converted clauses might be exactly equivalent
    to the function's condition, or they could be somewhat weaker (that is,
    they might accept some values that the function condition does not).
    In the latter case the index condition is said to
    be <firstterm>lossy</firstterm>; it can still be used to scan an index,
    but the function call will have to be executed for each row returned by
    the index to see if it really passes the <literal>WHERE</literal> condition or not.
    To create such conditions, the support function must implement
    the <literal>SupportRequestIndexCondition</literal> request type.
   </para>
________________________________________________________-->
   <para>
    对于返回 <type>boolean</type>的目标函数，可以将<literal>WHERE</literal>中出现的函数调用转换为一个可索引操作符子句或多个子句。
    转换的子句可能与函数的条件完全相同，或者它们可能比较弱态一些(也就是说，它们可能接受函数条件所不接受的一些值)。
    在后一种情况下，索引条件被称作<firstterm>lossy</firstterm>；它仍然可用于扫描索引，但必须为索引返回的每一行执行函数调用，以看它是否真的通过 <literal>WHERE</literal>条件或没有。
    要建立这样的条件，支持函数必须实现<literal>SupportRequestIndexCondition</literal>需求类型。
   </para>
<!-- pgdoc-cn_end sig_en=208ca6608b052e8abc6ef5196509141d -->
  </sect1>
