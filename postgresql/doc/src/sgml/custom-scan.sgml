<!-- doc/src/sgml/custom-scan.sgml -->

<chapter id="custom-scan">
<!-- pgdoc-cn_start sig_en=5d7b35a112a1295af19c930edbde345c sig_cn_org=None source=14.1 
 <title>Writing a Custom Scan Provider</title>
________________________________________________________-->
 <title>编写一个自定义扫描提供者</title>
<!-- pgdoc-cn_end sig_en=5d7b35a112a1295af19c930edbde345c -->

<!-- pgdoc-cn_start sig_en=9564714e660fdeaa2753055900700b8e sig_cn_org=None source=14.1 
 <indexterm zone="custom-scan">
  <primary>custom scan provider</primary>
  <secondary>handler for</secondary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="custom-scan">
  <primary>custom scan provider</primary>
  <secondary>handler for</secondary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=9564714e660fdeaa2753055900700b8e -->

<!-- pgdoc-cn_start sig_en=fc1d5deae1d1cd00291c0fae1926d49f sig_cn_org=None source=14.1 
 <para>
  <productname>PostgreSQL</productname> supports a set of experimental facilities which
  are intended to allow extension modules to add new scan types to the system.
  Unlike a <link linkend="fdwhandler">foreign data wrapper</link>, which is only
  responsible for knowing how to scan its own foreign tables, a custom scan
  provider can provide an alternative method of scanning any relation in the
  system.  Typically, the motivation for writing a custom scan provider will
  be to allow the use of some optimization not supported by the core
  system, such as caching or some form of hardware acceleration.  This chapter
  outlines how to write a new custom scan provider.
 </para>
________________________________________________________-->
 <para>
  <productname>PostgreSQL</productname>支持一组实验性的功能，它们的目的是允许扩展模块向系统中增加新的扫描类型。与<link linkend="fdwhandler">外部数据包装器</link>不同（只负责给出如何扫描其自身的外部表的知识），自定义扫描提供者可以提供另一种扫描系统中任一关系的方法。通常，编写一个自定义扫描提供者的动机是允许使用某种核心系统不支持的优化，例如缓冲或者某种形式的硬件加速。这一章简要介绍了如何编写一个新的自定义扫描提供者。
 </para>
<!-- pgdoc-cn_end sig_en=fc1d5deae1d1cd00291c0fae1926d49f -->

<!-- pgdoc-cn_start sig_en=4659336ce4b130dc1727335f65a2dddd sig_cn_org=None source=14.1 
 <para>
  Implementing a new type of custom scan is a three-step process.  First,
  during planning, it is necessary to generate access paths representing a
  scan using the proposed strategy.  Second, if one of those access paths
  is selected by the planner as the optimal strategy for scanning a
  particular relation, the access path must be converted to a plan.
  Finally, it must be possible to execute the plan and generate the same
  results that would have been generated for any other access path targeting
  the same relation.
 </para>
________________________________________________________-->
 <para>
  实现一个新类别的自定义扫描分成三步。首先，在规划期间需要生成表达使用所提出策略的扫描的访问路径。然后，如果规划器选择这些访问路径之一作为最优策略来扫描一个特定关系，该访问路径必须被转换成计划。最后，必须能执行该计划并且产生和其他以同一关系为目标的访问路径相同的结果。
 </para>
<!-- pgdoc-cn_end sig_en=4659336ce4b130dc1727335f65a2dddd -->

 <sect1 id="custom-scan-path">
<!-- pgdoc-cn_start sig_en=5c27a7fd2d423860eeaf8b6e80d92412 sig_cn_org=None source=14.1 
  <title>Creating Custom Scan Paths</title>
________________________________________________________-->
  <title>创建自定义扫描路径</title>
<!-- pgdoc-cn_end sig_en=5c27a7fd2d423860eeaf8b6e80d92412 -->

<!-- pgdoc-cn_start sig_en=0cbbe211dde3a0a29c5305d8b268b7c6 sig_cn_org=None source=14.1 
  <para>
    A custom scan provider will typically add paths for a base relation by
    setting the following hook, which is called after the core code has
    generated all the access paths it can for the relation (except for
    Gather paths, which are made after this call so that they can use
    partial paths added by the hook):
<programlisting>
typedef void (*set_rel_pathlist_hook_type) (PlannerInfo *root,
                                            RelOptInfo *rel,
                                            Index rti,
                                            RangeTblEntry *rte);
extern PGDLLIMPORT set_rel_pathlist_hook_type set_rel_pathlist_hook;
</programlisting>
  </para>
________________________________________________________-->
  <para>
    一个自定义扫描提供者将通过设置下面的钩子函数来为基本关系增加路径，
    在核心代码已经为该关系产生了所有访问路径集后（除了在此调用之后生成的Gather路径，以便它们可以使用被钩子添加的部分路径），这个钩子函数将被调用。
<programlisting>
typedef void (*set_rel_pathlist_hook_type) (PlannerInfo *root,
                                            RelOptInfo *rel,
                                            Index rti,
                                            RangeTblEntry *rte);
extern PGDLLIMPORT set_rel_pathlist_hook_type set_rel_pathlist_hook;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=0cbbe211dde3a0a29c5305d8b268b7c6 -->

<!-- pgdoc-cn_start sig_en=c396d6c695d19bf67f0df30514a247ab sig_cn_org=None source=14.1 
  <para>
    Although this hook function can be used to examine, modify, or remove
    paths generated by the core system, a custom scan provider will typically
    confine itself to generating <structname>CustomPath</structname> objects and adding
    them to <literal>rel</literal> using <function>add_path</function>.  The custom scan
    provider is responsible for initializing the <structname>CustomPath</structname>
    object, which is declared like this:
<programlisting>
typedef struct CustomPath
{
    Path      path;
    uint32    flags;
    List     *custom_paths;
    List     *custom_private;
    const CustomPathMethods *methods;
} CustomPath;
</programlisting>
  </para>
________________________________________________________-->
  <para>
    尽管这个钩子函数可被用来检查、修改或者移除核心系统产生的路径，自定义扫描提供程序通常还是局限于产生<structname>CustomPath</structname>对象并且使用<function>add_path</function>把它们加入到<literal>rel</literal>中。自定义扫描提供者负责初始化<structname>CustomPath</structname>对象，它被声明为这样：
<programlisting>
typedef struct CustomPath
{
    Path      path;
    uint32    flags;
    List     *custom_paths;
    List     *custom_private;
    const CustomPathMethods *methods;
} CustomPath;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=c396d6c695d19bf67f0df30514a247ab -->

<!-- pgdoc-cn_start sig_en=3b87aef607b376161c468a475cec0f77 sig_cn_org=1728a1bf11550c8721217c32a8d3bea7 source=15.7 
  <para>
    <structfield>path</structfield> must be initialized as for any other path, including
    the row-count estimate, start and total cost, and sort ordering provided
    by this path.  <structfield>flags</structfield> is a bit mask, which
    specifies whether the scan provider can support certain optional
    capabilities.  <structfield>flags</structfield> should include
    <literal>CUSTOMPATH_SUPPORT_BACKWARD_SCAN</literal> if the custom path can support
    a backward scan, <literal>CUSTOMPATH_SUPPORT_MARK_RESTORE</literal> if it
    can support mark and restore,
    and <literal>CUSTOMPATH_SUPPORT_PROJECTION</literal> if it can perform
    projections.  (If <literal>CUSTOMPATH_SUPPORT_PROJECTION</literal> is not
    set, the scan node will only be asked to produce Vars of the scanned
    relation; while if that flag is set, the scan node must be able to
    evaluate scalar expressions over these Vars.)
    An optional <structfield>custom_paths</structfield> is a list of <structname>Path</structname>
    nodes used by this custom-path node; these will be transformed into
    <structname>Plan</structname> nodes by planner.
    <structfield>custom_private</structfield> can be used to store the custom path's
    private data.  Private data should be stored in a form that can be handled
    by <literal>nodeToString</literal>, so that debugging routines that attempt to
    print the custom path will work as designed.  <structfield>methods</structfield> must
    point to a (usually statically allocated) object implementing the required
    custom path methods, which are further detailed below.
  </para>
________________________________________________________-->
  <para>
    <structfield>path</structfield>必须像任何其他路径一样进行初始化，包括行数估计、起始和总成本，以及此路径提供的排序顺序。
    <structfield>flags</structfield>是一个位掩码，指定扫描提供程序是否支持某些可选功能。
    <structfield>flags</structfield>应包括<literal>CUSTOMPATH_SUPPORT_BACKWARD_SCAN</literal>，如果自定义路径可以支持向后扫描，
    <literal>CUSTOMPATH_SUPPORT_MARK_RESTORE</literal>，如果它可以支持标记和恢复，
    以及<literal>CUSTOMPATH_SUPPORT_PROJECTION</literal>，如果它可以执行投影。
    （如果未设置<literal>CUSTOMPATH_SUPPORT_PROJECTION</literal>，则扫描节点将仅被要求生成扫描关系的Vars；
    而如果设置了该标志，则扫描节点必须能够评估这些Vars上的标量表达式。）
    可选的<structfield>custom_paths</structfield>是此自定义路径节点使用的<structname>Path</structname>节点列表；
    这些将由规划器转换为<structname>Plan</structname>节点。
    <structfield>custom_private</structfield>可用于存储自定义路径的私有数据。私有数据应以<literal>nodeToString</literal>可以处理的形式存储，
    以便尝试打印自定义路径的调试例程能够按预期工作。
    <structfield>methods</structfield>必须指向实现所需自定义路径方法的（通常是静态分配的）对象，这些方法将在下面进一步详细说明。
</para>
<!-- pgdoc-cn_end sig_en=3b87aef607b376161c468a475cec0f77 -->

<!-- pgdoc-cn_start sig_en=2896f68331746eae56b1c8efe1d73768 sig_cn_org=None source=14.1 
  <para>
   A custom scan provider can also provide join paths.  Just as for base
   relations, such a path must produce the same output as would normally be
   produced by the join it replaces.  To do this, the join provider should
   set the following hook, and then within the hook function,
   create <structname>CustomPath</structname> path(s) for the join relation.
<programlisting>
typedef void (*set_join_pathlist_hook_type) (PlannerInfo *root,
                                             RelOptInfo *joinrel,
                                             RelOptInfo *outerrel,
                                             RelOptInfo *innerrel,
                                             JoinType jointype,
                                             JoinPathExtraData *extra);
extern PGDLLIMPORT set_join_pathlist_hook_type set_join_pathlist_hook;
</programlisting>

   This hook will be invoked repeatedly for the same join relation, with
   different combinations of inner and outer relations; it is the
   responsibility of the hook to minimize duplicated work.
  </para>
________________________________________________________-->
  <para>
   一个自定义扫描提供者还能提供连接路径。就和基本关系一样，这样一条路径也应该产生和它将要替换的连接所产生的相同的输出。要做到这一点，连接提供程序应该设置下面的钩子函数，并且在该钩子函数里为连接关系创建<structname>CustomPath</structname>路径。
<programlisting>
typedef void (*set_join_pathlist_hook_type) (PlannerInfo *root,
                                             RelOptInfo *joinrel,
                                             RelOptInfo *outerrel,
                                             RelOptInfo *innerrel,
                                             JoinType jointype,
                                             JoinPathExtraData *extra);
extern PGDLLIMPORT set_join_pathlist_hook_type set_join_pathlist_hook;
</programlisting>

   对于同一个连接关系，这个钩子将被反复调用，因为要对不同的内外关系组合生成路径，所以如何最小化可能的重复工作是钩子函数的责任。
  </para>
<!-- pgdoc-cn_end sig_en=2896f68331746eae56b1c8efe1d73768 -->

  <sect2 id="custom-scan-path-callbacks">
<!-- pgdoc-cn_start sig_en=72d12d2d98672e4bc794d5e2125ece94 sig_cn_org=None source=14.1 
  <title>Custom Scan Path Callbacks</title>
________________________________________________________-->
  <title>自定义扫描路径回调</title>
<!-- pgdoc-cn_end sig_en=72d12d2d98672e4bc794d5e2125ece94 -->

<!-- pgdoc-cn_start sig_en=87471ac14ec35d03102d1e3c1ae6c441 sig_cn_org=None source=14.1 
  <para>
<programlisting>
Plan *(*PlanCustomPath) (PlannerInfo *root,
                         RelOptInfo *rel,
                         CustomPath *best_path,
                         List *tlist,
                         List *clauses,
                         List *custom_plans);
</programlisting>
    Convert a custom path to a finished plan.  The return value will generally
    be a <literal>CustomScan</literal> object, which the callback must allocate and
    initialize.  See <xref linkend="custom-scan-plan"/> for more details.
   </para>
________________________________________________________-->
  <para>
<programlisting>
Plan *(*PlanCustomPath) (PlannerInfo *root,
                         RelOptInfo *rel,
                         CustomPath *best_path,
                         List *tlist,
                         List *clauses,
                         List *custom_plans);
</programlisting>
    将一条自定义路径转换为一个完成的计划。返回值通常将是一个<literal>CustomScan</literal>对象，回调函数必须负责分配并且初始化这个对象。详见<xref linkend="custom-scan-plan"/>。
   </para>
<!-- pgdoc-cn_end sig_en=87471ac14ec35d03102d1e3c1ae6c441 -->

<!-- pgdoc-cn_start sig_en=04d177e7655febccb8dca6b6e37befc2 sig_cn_org=b69877d65dab565460fe548261ba2f7f source=15.7 
   <para>
<programlisting>
List *(*ReparameterizeCustomPathByChild) (PlannerInfo *root,
                                          List *custom_private,
                                          RelOptInfo *child_rel);
</programlisting>
    This callback is called while converting a path parameterized by the
    top-most parent of the given child relation <literal>child_rel</literal>
    to be parameterized by the child relation.  The callback is used to
    reparameterize any paths or translate any expression nodes saved in the
    given <literal>custom_private</literal> member of a
    <structname>CustomPath</structname>.  The callback may use
    <literal>reparameterize_path_by_child</literal>,
    <literal>adjust_appendrel_attrs</literal> or
    <literal>adjust_appendrel_attrs_multilevel</literal> as required.
   </para>
________________________________________________________-->
   <para>
<programlisting>
List *(*ReparameterizeCustomPathByChild) (PlannerInfo *root,
                                          List *custom_private,
                                          RelOptInfo *child_rel);
</programlisting>
    当将由给定子关系<literal>child_rel</literal>的最顶层父关系参数化的路径转换为由子关系参数化时，将调用此回调函数。
    此回调函数用于重新参数化任何路径或转换保存在给定<literal>custom_private</literal>成员中的表达式节点，
    该成员属于<structname>CustomPath</structname>。回调函数可以根据需要使用
    <literal>reparameterize_path_by_child</literal>、
    <literal>adjust_appendrel_attrs</literal>或
    <literal>adjust_appendrel_attrs_multilevel</literal>。
</para>
<!-- pgdoc-cn_end sig_en=04d177e7655febccb8dca6b6e37befc2 -->
  </sect2>
 </sect1>

 <sect1 id="custom-scan-plan">
<!-- pgdoc-cn_start sig_en=0007f29dd5d18db82c2856234ff65cff sig_cn_org=None source=14.1 
  <title>Creating Custom Scan Plans</title>
________________________________________________________-->
  <title>创建自定义扫描计划</title>
<!-- pgdoc-cn_end sig_en=0007f29dd5d18db82c2856234ff65cff -->

<!-- pgdoc-cn_start sig_en=a1a4e08c57b976105b043acf9b05f564 sig_cn_org=None source=14.1 
  <para>
    A custom scan is represented in a finished plan tree using the following
    structure:
<programlisting>
typedef struct CustomScan
{
    Scan      scan;
    uint32    flags;
    List     *custom_plans;
    List     *custom_exprs;
    List     *custom_private;
    List     *custom_scan_tlist;
    Bitmapset *custom_relids;
    const CustomScanMethods *methods;
} CustomScan;
</programlisting>
  </para>
________________________________________________________-->
  <para>
    以一棵已完成的计划树表示的自定义扫描使用下面的结构：
<programlisting>
typedef struct CustomScan
{
    Scan      scan;
    uint32    flags;
    List     *custom_plans;
    List     *custom_exprs;
    List     *custom_private;
    List     *custom_scan_tlist;
    Bitmapset *custom_relids;
    const CustomScanMethods *methods;
} CustomScan;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=a1a4e08c57b976105b043acf9b05f564 -->

<!-- pgdoc-cn_start sig_en=de818f58acc3c137c41baf5e657b098a sig_cn_org=None source=14.1 
  <para>
    <structfield>scan</structfield> must be initialized as for any other scan, including
    estimated costs, target lists, qualifications, and so on.
    <structfield>flags</structfield> is a bit mask with the same meaning as in
    <structname>CustomPath</structname>.
    <structfield>custom_plans</structfield> can be used to store child
    <structname>Plan</structname> nodes.
    <structfield>custom_exprs</structfield> should be used to
    store expression trees that will need to be fixed up by
    <filename>setrefs.c</filename> and <filename>subselect.c</filename>, while
    <structfield>custom_private</structfield> should be used to store other private data
    that is only used by the custom scan provider itself.
    <structfield>custom_scan_tlist</structfield> can be NIL when scanning a base
    relation, indicating that the custom scan returns scan tuples that match
    the base relation's row type.  Otherwise it is a target list describing
    the actual scan tuples.  <structfield>custom_scan_tlist</structfield> must be
    provided for joins, and could be provided for scans if the custom scan
    provider can compute some non-Var expressions.
    <structfield>custom_relids</structfield> is set by the core code to the set of
    relations (range table indexes) that this scan node handles; except when
    this scan is replacing a join, it will have only one member.
    <structfield>methods</structfield> must point to a (usually statically allocated)
    object implementing the required custom scan methods, which are further
    detailed below.
  </para>
________________________________________________________-->
  <para>
    <structfield>scan</structfield>必须和任何其他扫描一样被初始化，包括估计代价、目标列表、条件等等。<structfield>flags</structfield>是一个位掩码，它的含义和<structname>CustomPath</structname>中的一样。<structfield>custom_plans</structfield>可以用来存储子<structname>Plan</structname>节点。<structfield>custom_exprs</structfield>应该被用来存储需要由<filename>setrefs.c</filename>和<filename>subselect.c</filename>修整的表达式树，而<structfield>custom_private</structfield>应该被用来存储其他只由自定义扫描提供者本身使用的私有数据。在扫描一个基本关系时，<structfield>custom_scan_tlist</structfield>可以为 NIL，表示该自定义扫描返回符合该基本关系行类型的扫描元组。否则，它是一个描述实际扫描元组的目标列表。对于连接必须提供<structfield>custom_scan_tlist</structfield>。如果自定义扫描提供者能够计算某些非-Var 表达式，也应该提供这个域的值。<structfield>custom_relids</structfield>会被核心代码设置成这个扫描节点要处理的关系的集合（范围表索引）。当这个扫描被放在一个链接上时是一种例外，那时其中只有一个成员。<structfield>methods</structfield>必须指向一个实现了所需自定义扫描方法的对象（通常是静态分配的），将进一步在下文详细介绍。
  </para>
<!-- pgdoc-cn_end sig_en=de818f58acc3c137c41baf5e657b098a -->

<!-- pgdoc-cn_start sig_en=5716103572756c44cd4d90633d7038c1 sig_cn_org=None source=14.1 
  <para>
   When a <structname>CustomScan</structname> scans a single relation,
   <structfield>scan.scanrelid</structfield> must be the range table index of the table
   to be scanned.  When it replaces a join, <structfield>scan.scanrelid</structfield>
   should be zero.
  </para>
________________________________________________________-->
  <para>
   当一个<structname>CustomScan</structname>扫描单个关系时，<structfield>scan.scanrelid</structfield>必须是被扫描的表的范围表索引。当它替代的是一个连接时，<structfield>scan.scanrelid</structfield>应该为零。
  </para>
<!-- pgdoc-cn_end sig_en=5716103572756c44cd4d90633d7038c1 -->

<!-- pgdoc-cn_start sig_en=5e68ef3e030e260cbc462c873feb4711 sig_cn_org=None source=14.1 
  <para>
   Plan trees must be able to be duplicated using <function>copyObject</function>,
   so all the data stored within the <quote>custom</quote> fields must consist of
   nodes that that function can handle.  Furthermore, custom scan providers
   cannot substitute a larger structure that embeds
   a <structname>CustomScan</structname> for the structure itself, as would be possible
   for a <structname>CustomPath</structname> or <structname>CustomScanState</structname>.
  </para>
________________________________________________________-->
  <para>
   计划树必须能够被使用<function>copyObject</function>复制，因此所有存储在<quote>custom</quote>域中的数据必须由该函数能处理的节点构成。更进一步，自定义扫描提供者不能把<structname>CustomScan</structname>结构本身替换成包含<structname>CustomScan</structname>的更大的结构（就好像<structname>CustomPath</structname>或者<structname>CustomScanState</structname>）。
  </para>
<!-- pgdoc-cn_end sig_en=5e68ef3e030e260cbc462c873feb4711 -->

  <sect2 id="custom-scan-plan-callbacks">
<!-- pgdoc-cn_start sig_en=49a8acb25c27a654eb89fa0d3239fc82 sig_cn_org=None source=14.1 
   <title>Custom Scan Plan Callbacks</title>
________________________________________________________-->
   <title>自定义扫描计划回调</title>
<!-- pgdoc-cn_end sig_en=49a8acb25c27a654eb89fa0d3239fc82 -->
<!-- pgdoc-cn_start sig_en=7edb6204360586d90dfb72215523a05e sig_cn_org=None source=14.1 
   <para>
<programlisting>
Node *(*CreateCustomScanState) (CustomScan *cscan);
</programlisting>
    Allocate a <structname>CustomScanState</structname> for this
    <structname>CustomScan</structname>.  The actual allocation will often be larger than
    required for an ordinary <structname>CustomScanState</structname>, because many
    providers will wish to embed that as the first field of a larger structure.
    The value returned must have the node tag and <structfield>methods</structfield>
    set appropriately, but other fields should be left as zeroes at this
    stage; after <function>ExecInitCustomScan</function> performs basic initialization,
    the <function>BeginCustomScan</function> callback will be invoked to give the
    custom scan provider a chance to do whatever else is needed.
   </para>
________________________________________________________-->
   <para>
<programlisting>
Node *(*CreateCustomScanState) (CustomScan *cscan);
</programlisting>
    为这个<structname>CustomScan</structname>分配一个<structname>CustomScanState</structname>。实际的分配常常会比一个普通<structname>CustomScanState</structname>所要求的空间要大，因为很多提供者希望把它嵌入在一个更大的结构中作为第一个域。返回的值必须有节点标签并且设置好了合适的<structfield>methods</structfield>，不过在这个阶段其他域应该被设置为零。在<function>ExecInitCustomScan</function>执行基本的初始化之后，将调用<function>BeginCustomScan</function>回调函数来让自定义扫描提供者有机会做其他需要干的事情。
   </para>
<!-- pgdoc-cn_end sig_en=7edb6204360586d90dfb72215523a05e -->
  </sect2>
 </sect1>

 <sect1 id="custom-scan-execution">
<!-- pgdoc-cn_start sig_en=130f6d5e06b94b440caa231fb17d1688 sig_cn_org=None source=14.1 
  <title>Executing Custom Scans</title>
________________________________________________________-->
  <title>执行自定义扫描</title>
<!-- pgdoc-cn_end sig_en=130f6d5e06b94b440caa231fb17d1688 -->

<!-- pgdoc-cn_start sig_en=b37a0004b5a7b279e6b230e871f01801 sig_cn_org=None source=14.1 
  <para>
   When a <structfield>CustomScan</structfield> is executed, its execution state is
   represented by a <structfield>CustomScanState</structfield>, which is declared as
   follows:
<programlisting>
typedef struct CustomScanState
{
    ScanState ss;
    uint32    flags;
    const CustomExecMethods *methods;
} CustomScanState;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   在执行一个<structfield>CustomScan</structfield>时，它的执行状态由一个<structfield>CustomScanState</structfield>表示，其定义如下：
<programlisting>
typedef struct CustomScanState
{
    ScanState ss;
    uint32    flags;
    const CustomExecMethods *methods;
} CustomScanState;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=b37a0004b5a7b279e6b230e871f01801 -->

<!-- pgdoc-cn_start sig_en=774a488381c197bd25b5ecc5938158e8 sig_cn_org=None source=14.1 
  <para>
   <structfield>ss</structfield> is initialized as for any other scan state,
   except that if the scan is for a join rather than a base relation,
   <literal>ss.ss_currentRelation</literal> is left NULL.
   <structfield>flags</structfield> is a bit mask with the same meaning as in
   <structname>CustomPath</structname> and <structname>CustomScan</structname>.
   <structfield>methods</structfield> must point to a (usually statically allocated)
   object implementing the required custom scan state methods, which are
   further detailed below.  Typically, a <structname>CustomScanState</structname>, which
   need not support <function>copyObject</function>, will actually be a larger
   structure embedding the above as its first member.
  </para>
________________________________________________________-->
  <para>
   <structfield>ss</structfield>和任何其他扫描状态一样被初始化，不过如果该扫描是用于连接而不是基本关系，则<literal>ss.ss_currentRelation</literal>会被留成 NULL。<structfield>flags</structfield>是一个位掩码，它的含义与<structname>CustomPath</structname>和<structname>CustomScan</structname>中的一样。<structfield>methods</structfield>必须指向一个实现了所需自定义扫描状态方法的对象（通常是静态分配的），将进一步在下文详细介绍。通常一个<structname>CustomScanState</structname>（不需要支持<function>copyObject</function>）实际将是一个较大的结构，上面的结构将嵌入在其中作为第一个成员。
  </para>
<!-- pgdoc-cn_end sig_en=774a488381c197bd25b5ecc5938158e8 -->

  <sect2 id="custom-scan-execution-callbacks">
<!-- pgdoc-cn_start sig_en=b5f3f590b459ad813894407781bc2026 sig_cn_org=None source=14.1 
   <title>Custom Scan Execution Callbacks</title>
________________________________________________________-->
   <title>自定义扫描执行回调</title>
<!-- pgdoc-cn_end sig_en=b5f3f590b459ad813894407781bc2026 -->

<!-- pgdoc-cn_start sig_en=2e501a32b3db889687cbba7cb7fe4777 sig_cn_org=None source=14.1 
   <para>
<programlisting>
void (*BeginCustomScan) (CustomScanState *node,
                         EState *estate,
                         int eflags);
</programlisting>
    Complete initialization of the supplied <structname>CustomScanState</structname>.
    Standard fields have been initialized by <function>ExecInitCustomScan</function>,
    but any private fields should be initialized here.
   </para>
________________________________________________________-->
   <para>
<programlisting>
void (*BeginCustomScan) (CustomScanState *node,
                         EState *estate,
                         int eflags);
</programlisting>
    完成所提供的<structname>CustomScanState</structname>的初始化。标准的域已经被<function>ExecInitCustomScan</function>初始化，但是任何私有的域应该在这里被初始化。
   </para>
<!-- pgdoc-cn_end sig_en=2e501a32b3db889687cbba7cb7fe4777 -->

<!-- pgdoc-cn_start sig_en=1ef2c6b0677a97339d07ef7c7fb33d2c sig_cn_org=None source=14.1 
   <para>
<programlisting>
TupleTableSlot *(*ExecCustomScan) (CustomScanState *node);
</programlisting>
    Fetch the next scan tuple.  If any tuples remain, it should fill
    <literal>ps_ResultTupleSlot</literal> with the next tuple in the current scan
    direction, and then return the tuple slot.  If not,
    <literal>NULL</literal> or an empty slot should be returned.
   </para>
________________________________________________________-->
   <para>
<programlisting>
TupleTableSlot *(*ExecCustomScan) (CustomScanState *node);
</programlisting>
    取下一个扫描元组。如果还有任何元组剩余，它应该用当前扫描方向的下一个元组填充<literal>ps_ResultTupleSlot</literal>，并且接着返回该元组槽。如果没有，则用<literal>NULL</literal>填充或者返回一个空槽。
   </para>
<!-- pgdoc-cn_end sig_en=1ef2c6b0677a97339d07ef7c7fb33d2c -->

<!-- pgdoc-cn_start sig_en=111e080d4ab2c2df78a4d3c5b430e392 sig_cn_org=None source=14.1 
   <para>
<programlisting>
void (*EndCustomScan) (CustomScanState *node);
</programlisting>
    Clean up any private data associated with the <literal>CustomScanState</literal>.
    This method is required, but it does not need to do anything if there is
    no associated data or it will be cleaned up automatically.
   </para>
________________________________________________________-->
   <para>
<programlisting>
void (*EndCustomScan) (CustomScanState *node);
</programlisting>
    清除任何与<literal>CustomScanState</literal>相关的私有数据。这个方法是必需的，但是如果没有相关的数据或者相关数据将被自动清除，则它不需要做任何事情。
   </para>
<!-- pgdoc-cn_end sig_en=111e080d4ab2c2df78a4d3c5b430e392 -->

<!-- pgdoc-cn_start sig_en=4d599b01848c75987ced8feb26c2005e sig_cn_org=None source=14.1 
   <para>
<programlisting>
void (*ReScanCustomScan) (CustomScanState *node);
</programlisting>
    Rewind the current scan to the beginning and prepare to rescan the
    relation.
   </para>
________________________________________________________-->
   <para>
<programlisting>
void (*ReScanCustomScan) (CustomScanState *node);
</programlisting>
    把当前扫描倒回到开始处，并且准备重新扫描该关系。
   </para>
<!-- pgdoc-cn_end sig_en=4d599b01848c75987ced8feb26c2005e -->

<!-- pgdoc-cn_start sig_en=8a60303223fea5cf5adbbe5019fc9425 sig_cn_org=None source=14.1 
   <para>
<programlisting>
void (*MarkPosCustomScan) (CustomScanState *node);
</programlisting>
    Save the current scan position so that it can subsequently be restored
    by the <function>RestrPosCustomScan</function> callback.  This callback is
    optional, and need only be supplied if the
    <literal>CUSTOMPATH_SUPPORT_MARK_RESTORE</literal> flag is set.
   </para>
________________________________________________________-->
   <para>
<programlisting>
void (*MarkPosCustomScan) (CustomScanState *node);
</programlisting>
    保存当前的扫描位置，这样可以在以后由<function>RestrPosCustomScan</function>回调函数恢复。这个回调函数是可选的，只有在<literal>CUSTOMPATH_SUPPORT_MARK_RESTORE</literal>标志被设置时才需要提供。
   </para>
<!-- pgdoc-cn_end sig_en=8a60303223fea5cf5adbbe5019fc9425 -->

<!-- pgdoc-cn_start sig_en=b3c453ace0f0d6ed0e15c31eb990d679 sig_cn_org=None source=14.1 
   <para>
<programlisting>
void (*RestrPosCustomScan) (CustomScanState *node);
</programlisting>
    Restore the previous scan position as saved by the
    <function>MarkPosCustomScan</function> callback.  This callback is optional,
    and need only be supplied if the
    <literal>CUSTOMPATH_SUPPORT_MARK_RESTORE</literal> flag is set.
   </para>
________________________________________________________-->
   <para>
<programlisting>
void (*RestrPosCustomScan) (CustomScanState *node);
</programlisting>
    恢复由<function>MarkPosCustomScan</function>回调函数保存的扫描位置。这个回调函数是可选的，只有在<literal>CUSTOMPATH_SUPPORT_MARK_RESTORE</literal>标志被设置时才需要提供。
   </para>
<!-- pgdoc-cn_end sig_en=b3c453ace0f0d6ed0e15c31eb990d679 -->

<!-- pgdoc-cn_start sig_en=20fc325f7d243cb5b67dbf24722b9786 sig_cn_org=None source=14.1 
   <para>
<programlisting>
Size (*EstimateDSMCustomScan) (CustomScanState *node,
                               ParallelContext *pcxt);
</programlisting>
    Estimate the amount of dynamic shared memory that will be required
    for parallel operation.  This may be higher than the amount that will
    actually be used, but it must not be lower.  The return value is in bytes.
    This callback is optional, and need only be supplied if this custom
    scan provider supports parallel execution.
   </para>
________________________________________________________-->
   <para>
<programlisting>
Size (*EstimateDSMCustomScan) (CustomScanState *node,
                               ParallelContext *pcxt);
</programlisting>
    估计并行操作所需要的动态共享内存的数量。这可能会比实际使用的量更大，但是绝不能更低。返回值的单位是字节。这个回调是可选的，只有在这个自定义扫描提供者支持并行执行时才必须提供这个回调。
   </para>
<!-- pgdoc-cn_end sig_en=20fc325f7d243cb5b67dbf24722b9786 -->

<!-- pgdoc-cn_start sig_en=017657306adc80bd814e3aa00c6d037e sig_cn_org=None source=14.1 
   <para>
<programlisting>
void (*InitializeDSMCustomScan) (CustomScanState *node,
                                 ParallelContext *pcxt,
                                 void *coordinate);
</programlisting>
    Initialize the dynamic shared memory that will be required for parallel
    operation.  <literal>coordinate</literal> points to a shared memory area of
    size equal to the return value of <function>EstimateDSMCustomScan</function>.
    This callback is optional, and need only be supplied if this custom
    scan provider supports parallel execution.
   </para>
________________________________________________________-->
   <para>
<programlisting>
void (*InitializeDSMCustomScan) (CustomScanState *node,
                                 ParallelContext *pcxt,
                                 void *coordinate);
</programlisting>
    初始化并行操作所需的动态共享内存。<literal>coordinate</literal>
	指向一块大小等于<function>EstimateDSMCustomScan</function>
	返回值的共享内存区域。这个回调是可选的，
	只有在这个自定义扫描提供者支持并行执行时才必须提供这个回调。
   </para>
<!-- pgdoc-cn_end sig_en=017657306adc80bd814e3aa00c6d037e -->

<!-- pgdoc-cn_start sig_en=7dc577de02cf32a461b33c4ba5039d40 sig_cn_org=None source=14.1 
   <para>
<programlisting>
void (*ReInitializeDSMCustomScan) (CustomScanState *node,
                                   ParallelContext *pcxt,
                                   void *coordinate);
</programlisting>
    Re-initialize the dynamic shared memory required for parallel operation
    when the custom-scan plan node is about to be re-scanned.
    This callback is optional, and need only be supplied if this custom
    scan provider supports parallel execution.
    Recommended practice is that this callback reset only shared state,
    while the <function>ReScanCustomScan</function> callback resets only local
    state.  Currently, this callback will be called
    before <function>ReScanCustomScan</function>, but it's best not to rely on
    that ordering.
   </para>
________________________________________________________-->
   <para>
<programlisting>
void (*ReInitializeDSMCustomScan) (CustomScanState *node,
                                   ParallelContext *pcxt,
                                   void *coordinate);
</programlisting>
    当自定义扫描计划节点即将被重新扫描时，
	重新初始化并行操作所需的动态共享内存。这个回调是可选的，
	只有在这个自定义扫描提供者支持并行执行时才必须提供这个回调。
	推荐的做法是，此回调仅重置共享状态，而<function>ReScanCustomScan</function>
	回调仅重置本地状态。目前，该回调将在<function>ReScanCustomScan</function>
	之前调用，但最好不要依赖该顺序。
   </para>
<!-- pgdoc-cn_end sig_en=7dc577de02cf32a461b33c4ba5039d40 -->

<!-- pgdoc-cn_start sig_en=11f2d2a7e2c89b7d6f64ec34d9fbdaca sig_cn_org=None source=14.1 
   <para>
<programlisting>
void (*InitializeWorkerCustomScan) (CustomScanState *node,
                                    shm_toc *toc,
                                    void *coordinate);
</programlisting>
    Initialize a parallel worker's local state based on the shared state
    set up by the leader during <function>InitializeDSMCustomScan</function>.
    This callback is optional, and need only be supplied if this custom
    scan provider supports parallel execution.
   </para>
________________________________________________________-->
   <para>
<programlisting>
void (*InitializeWorkerCustomScan) (CustomScanState *node,
                                    shm_toc *toc,
                                    void *coordinate);
</programlisting>
    基于<function>InitializeDSMCustomScan</function>期间通过领导者
	设置的共享状态初始化并行工作者的本地状态。这个回调是可选的，
	只有在这个自定义扫描提供者支持并行执行时才必须提供这个回调。
   </para>
<!-- pgdoc-cn_end sig_en=11f2d2a7e2c89b7d6f64ec34d9fbdaca -->

<!-- pgdoc-cn_start sig_en=a92d6e266a3f0f396a13b326e5f3505a sig_cn_org=None source=14.1 
   <para>
<programlisting>
void (*ShutdownCustomScan) (CustomScanState *node);
</programlisting>
    Release resources when it is anticipated the node will not be executed
    to completion.  This is not called in all cases; sometimes,
    <literal>EndCustomScan</literal> may be called without this function having
    been called first.  Since the DSM segment used by parallel query is
    destroyed just after this callback is invoked, custom scan providers that
    wish to take some action before the DSM segment goes away should implement
    this method.
   </para>
________________________________________________________-->
   <para>
<programlisting>
void (*ShutdownCustomScan) (CustomScanState *node);
</programlisting>
    预计节点将不会执行完成时释放资源。并不是在所有情况下都调用；
	有时，<literal>EndCustomScan</literal>可能会在调用此函数之前调用。
	由于并行查询使用的DSM段在调用此回调后即被销毁，
	因此希望在DSM段消失之前采取某些操作的自定义扫描提供程序应实现此方法。
   </para>
<!-- pgdoc-cn_end sig_en=a92d6e266a3f0f396a13b326e5f3505a -->

<!-- pgdoc-cn_start sig_en=f477e1e8beafca274c644d49f75fd89b sig_cn_org=None source=14.1 
   <para>
<programlisting>
void (*ExplainCustomScan) (CustomScanState *node,
                           List *ancestors,
                           ExplainState *es);
</programlisting>
    Output additional information for <command>EXPLAIN</command> of a custom-scan
    plan node.  This callback is optional.  Common data stored in the
    <structname>ScanState</structname>, such as the target list and scan relation, will
    be shown even without this callback, but the callback allows the display
    of additional, private state.
   </para>
________________________________________________________-->
   <para>
<programlisting>
void (*ExplainCustomScan) (CustomScanState *node,
                           List *ancestors,
                           ExplainState *es);
</programlisting>
    为一个自定义扫描计划节点的<command>EXPLAIN</command>输出额外的信息。这个回调函数是可选的。即使没有这个回调函数，被存储在<structname>ScanState</structname>中的公共的数据（例如目标列表和扫描关系）也将被显示，但是该回调函数允许显示额外的信息（例如私有状态）。
   </para>
<!-- pgdoc-cn_end sig_en=f477e1e8beafca274c644d49f75fd89b -->
  </sect2>
 </sect1>
</chapter>
