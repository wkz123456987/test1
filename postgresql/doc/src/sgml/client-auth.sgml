<!-- doc/src/sgml/client-auth.sgml -->

<chapter id="client-authentication">
<!-- pgdoc-cn_start sig_en=9005c7125761f6806dacf22d17ab9b32 sig_cn_org=None source=14.1 
 <title>Client Authentication</title>
________________________________________________________-->
 <title>客户端认证</title>
<!-- pgdoc-cn_end sig_en=9005c7125761f6806dacf22d17ab9b32 -->

<!-- pgdoc-cn_start sig_en=fe4df66ea13c714b13bdd1a8ef5dcf3f sig_cn_org=None source=14.1 
 <indexterm zone="client-authentication">
  <primary>client authentication</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="client-authentication">
  <primary>客户端认证</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=fe4df66ea13c714b13bdd1a8ef5dcf3f -->

<!-- pgdoc-cn_start sig_en=7f838d1fea5283b0c038e5f0256795ed sig_cn_org=None source=14.1 
 <para>
  When a client application connects to the database server, it
  specifies which <productname>PostgreSQL</productname> database user name it
  wants to connect as, much the same way one logs into a Unix computer
  as a particular user. Within the SQL environment the active database
  user name determines access privileges to database objects &mdash; see
  <xref linkend="user-manag"/> for more information. Therefore, it is
  essential to restrict which database users can connect.
 </para>
________________________________________________________-->
 <para>
  当一个客户端应用连接一个数据库服务器时，它将指定以哪个<productname>PostgreSQL</productname> 数据库用户名连接，就像我们以一个特定用户登录一台 Unix 计算机一样。在 SQL 环境中，活动的数据库用户名决定对数据库对象的访问权限 &mdash; 详见<xref linkend="user-manag"/>。因此，它本质上是哪些数据库用户可以连接。
 </para>
<!-- pgdoc-cn_end sig_en=7f838d1fea5283b0c038e5f0256795ed -->

 <note>
<!-- pgdoc-cn_start sig_en=8defbd1e5363a6aafc4dd0d78e1b8afa sig_cn_org=None source=14.1 
  <para>
   As explained in <xref linkend="user-manag"/>,
   <productname>PostgreSQL</productname> actually does privilege
   management in terms of <quote>roles</quote>.  In this chapter, we
   consistently use <firstterm>database user</firstterm> to mean <quote>role with the
   <literal>LOGIN</literal> privilege</quote>.
  </para>
________________________________________________________-->
  <para>
   如<xref linkend="user-manag"/>中所释，<productname>PostgreSQL</productname>实际上以<quote>角色</quote>来进行权限管理。在本章中，我们用<firstterm>数据库用户</firstterm>表示<quote>拥有<literal>LOGIN</literal>权限的角色</quote>。
  </para>
<!-- pgdoc-cn_end sig_en=8defbd1e5363a6aafc4dd0d78e1b8afa -->
 </note>

<!-- pgdoc-cn_start sig_en=fdc49b304919962d903fd2b302db7f10 sig_cn_org=None source=14.1 
 <para>
  <firstterm>Authentication</firstterm> is the process by which the
  database server establishes the identity of the client, and by
  extension determines whether the client application (or the user
  who runs the client application) is permitted to connect with the
  database user name that was requested.
 </para>
________________________________________________________-->
 <para>
  <firstterm>认证</firstterm>是数据库服务器建立客户端身份的过程，并且服务器决定客户端应用（或者运行客户端应用的用户）是否被允许以请求的数据库用户名来连接。
 </para>
<!-- pgdoc-cn_end sig_en=fdc49b304919962d903fd2b302db7f10 -->

<!-- pgdoc-cn_start sig_en=3fe86bda788077fbaa4e796290df6dad sig_cn_org=None source=14.1 
 <para>
  <productname>PostgreSQL</productname> offers a number of different
  client authentication methods. The method used to authenticate a
  particular client connection can be selected on the basis of
  (client) host address, database, and user.
 </para>
________________________________________________________-->
 <para>
  <productname>PostgreSQL</productname>提供多种不同的客户端认证方式。被用来认证一个特定客户端连接的方法可以基于（客户端）主机地址、数据库和用户来选择。
 </para>
<!-- pgdoc-cn_end sig_en=3fe86bda788077fbaa4e796290df6dad -->

<!-- pgdoc-cn_start sig_en=6472956fb1207fb827e2c8618cca35fd sig_cn_org=None source=14.1 
 <para>
  <productname>PostgreSQL</productname> database user names are logically
  separate from user names of the operating system in which the server
  runs. If all the users of a particular server also have accounts on
  the server's machine, it makes sense to assign database user names
  that match their operating system user names. However, a server that
  accepts remote connections might have many database users who have no local
  operating system
  account, and in such cases there need be no connection between
  database user names and OS user names.
 </para>
________________________________________________________-->
 <para>
  <productname>PostgreSQL</productname>数据库用户名在逻辑上是和服务器运行的操作系统中的用户名相互独立的。如果一个特定服务器的所有用户在那台服务器的机器上也有帐号，那么分配与操作系统用户名匹配的数据库用户名是有意义的。不过，一个接受远程连接的服务器可能有许多没有本地操作系统帐号的用户，并且在这种情况下数据库用户和操作系统用户名之间不必有任何联系。
 </para>
<!-- pgdoc-cn_end sig_en=6472956fb1207fb827e2c8618cca35fd -->

 <sect1 id="auth-pg-hba-conf">
<!-- pgdoc-cn_start sig_en=2e08661319b839a2d4a190eab7158fdf sig_cn_org=None source=14.1 
  <title>The <filename>pg_hba.conf</filename> File</title>
________________________________________________________-->
  <title><filename>pg_hba.conf</filename>文件</title>
<!-- pgdoc-cn_end sig_en=2e08661319b839a2d4a190eab7158fdf -->

<!-- pgdoc-cn_start sig_en=399858d044314f898fb00f357f6afddf sig_cn_org=None source=14.1 
  <indexterm zone="auth-pg-hba-conf">
   <primary>pg_hba.conf</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="auth-pg-hba-conf">
   <primary>pg_hba.conf</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=399858d044314f898fb00f357f6afddf -->

<!-- pgdoc-cn_start sig_en=91e242124edf88f507b79b88a2680af7 sig_cn_org=e37a99cd625dc51eecbe8fe3cb960b14 source=15.7 
  <para>
   Client authentication is controlled by a configuration file,
   which traditionally is named
   <filename>pg_hba.conf</filename> and is stored in the database
   cluster's data directory.
   (<acronym>HBA</acronym> stands for host-based authentication.) A default
   <filename>pg_hba.conf</filename> file is installed when the data
   directory is initialized by <xref linkend="app-initdb"/>.  It is
   possible to place the authentication configuration file elsewhere,
   however; see the <xref linkend="guc-hba-file"/> configuration parameter.
  </para>
________________________________________________________-->
  <para>
   客户端身份验证由一个配置文件控制，传统上被命名为
   <filename>pg_hba.conf</filename>，并存储在集簇的数据目录中。
   （<acronym>HBA</acronym>代表基于主机的身份验证。）当数据
   目录被 <xref linkend="app-initdb"/> 初始化时，会安装一个默认的
   <filename>pg_hba.conf</filename> 文件。
   但是也可以将身份验证配置文件放在其他地方；
   请参见 <xref linkend="guc-hba-file"/> 配置参数。
</para>
<!-- pgdoc-cn_end sig_en=91e242124edf88f507b79b88a2680af7 -->

<!-- pgdoc-cn_start sig_en=5aa5708abf92d70c1c242ad79f559f9b sig_cn_org=None source=14.1 
  <para>
   The general format of the <filename>pg_hba.conf</filename> file is
   a set of records, one per line. Blank lines are ignored, as is any
   text after the <literal>#</literal> comment character.
   A record can be continued onto the next line by ending the line with
   a backslash. (Backslashes are not special except at the end of a line.)
   A record is made
   up of a number of fields which are separated by spaces and/or tabs.
   Fields can contain white space if the field value is double-quoted.
   Quoting one of the keywords in a database, user, or address field (e.g.,
   <literal>all</literal> or <literal>replication</literal>) makes the word lose its special
   meaning, and just match a database, user, or host with that name.
   Backslash line continuation applies even within quoted text or comments.
  </para>
________________________________________________________-->
  <para>
   <filename>pg_hba.conf</filename>文件的常用格式是一组记录，每行一条。
   空白行将被忽略， <literal>#</literal>注释字符后面的任何文本也被忽略。
   记录可以延续到下一行并以反斜线结束该行。(反斜线不是特定的的，除了在行尾。)
   一条记录由若干用空格和/或制表符分隔的域组成。
   如果域值用双引号包围，那么它可以包含空白。
   在数据库、用户或地址域中引用一个关键字（例如，<literal>all</literal>或<literal>replication</literal>）将使该词失去其特殊含义，并且只是匹配一个有该名字的数据库、用户或主机。
   反斜线行的延续在引用文本或注释中也可以使用。
  </para>
<!-- pgdoc-cn_end sig_en=5aa5708abf92d70c1c242ad79f559f9b -->

<!-- pgdoc-cn_start sig_en=b7431889d3c7613207c31c54e0f07ab5 sig_cn_org=None source=14.1 
  <para>
   Each record specifies a connection type, a client IP address range
   (if relevant for the connection type), a database name, a user name,
   and the authentication method to be used for connections matching
   these parameters. The first record with a matching connection type,
   client address, requested database, and user name is used to perform
   authentication. There is no <quote>fall-through</quote> or
   <quote>backup</quote>: if one record is chosen and the authentication
   fails, subsequent records are not considered. If no record matches,
   access is denied.
  </para>
________________________________________________________-->
  <para>
   每条记录指定一种连接类型、一个客户端 IP 地址范围（如果和连接类型相关）、一个数据库名、一个用户名以及对匹配这些参数的连接使用的认证方法。第一条匹配连接类型、客户端地址、连接请求的数据库和用户名的记录将被用于执行认证。这个过程没有<quote>落空</quote>或者<quote>后备</quote>的说法：如果选择了一条记录而且认证失败，那么将不再考虑后面的记录。如果没有匹配的记录，那么访问将被拒绝。
  </para>
<!-- pgdoc-cn_end sig_en=b7431889d3c7613207c31c54e0f07ab5 -->

<!-- pgdoc-cn_start sig_en=20394574ee8d3e6deb4b442460208433 sig_cn_org=a79d105d5a412d584119ca1dea327242 source=15.7 
  <para>
   A record can have several formats:
________________________________________________________-->
  <para>
   一条记录可以有多种格式:
<!-- pgdoc-cn_end sig_en=20394574ee8d3e6deb4b442460208433 -->
<!-- pgdoc-cn_start sig_en=4031b23bee077b0ad1dad17dfd9964eb sig_cn_org=4031b23bee077b0ad1dad17dfd9964eb source=15.7 
<synopsis>
local         <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>auth-method</replaceable> <optional><replaceable>auth-options</replaceable></optional>
host          <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>     <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostssl       <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>     <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostnossl     <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>     <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostgssenc    <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>     <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostnogssenc  <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>     <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
host          <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>      <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostssl       <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>      <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostnossl     <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>      <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostgssenc    <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>      <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostnogssenc  <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>      <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
</synopsis>
________________________________________________________-->
<synopsis>
local         <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>auth-method</replaceable> <optional><replaceable>auth-options</replaceable></optional>
host          <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>     <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostssl       <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>     <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostnossl     <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>     <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostgssenc    <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>     <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostnogssenc  <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>address</replaceable>     <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
host          <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>      <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostssl       <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>      <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostnossl     <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>      <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostgssenc    <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>      <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
hostnogssenc  <replaceable>database</replaceable>  <replaceable>user</replaceable>  <replaceable>IP-address</replaceable>  <replaceable>IP-mask</replaceable>      <replaceable>auth-method</replaceable>  <optional><replaceable>auth-options</replaceable></optional>
</synopsis>
<!-- pgdoc-cn_end sig_en=4031b23bee077b0ad1dad17dfd9964eb -->
<!-- pgdoc-cn_start sig_en=26e56fd711b0d5ee891451976dcff9df sig_cn_org=95c3c3b6983a22935f159cedb362b208 source=15.7 
   The meaning of the fields is as follows:

   <variablelist>
    <varlistentry>
________________________________________________________-->
   字段的含义如下：

   <variablelist>
    <varlistentry>
<!-- pgdoc-cn_end sig_en=26e56fd711b0d5ee891451976dcff9df -->
     <term><literal>local</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=b8348c64c9d18f58b92027018913f934 sig_cn_org=9e679d6c27e2d309a26337ded7488ce1 source=15.7 
      <para>
       This record matches connection attempts using Unix-domain
       sockets.  Without a record of this type, Unix-domain socket
       connections are disallowed.
      </para>
________________________________________________________-->
      <para>
       这个记录匹配使用Unix域套接字的连接尝试。没有这种类型的记录，Unix域套接字连接是不允许的。
      </para>
<!-- pgdoc-cn_end sig_en=b8348c64c9d18f58b92027018913f934 -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>host</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=cf7c3d5279f00c85e3bd5d5bb65bf463 sig_cn_org=9261e2029702ae14f9aae58aaa8f88c3 source=15.7 
      <para>
       This record matches connection attempts made using TCP/IP.
       <literal>host</literal> records match
       <acronym>SSL</acronym> or non-<acronym>SSL</acronym> connection
       attempts as well as <acronym>GSSAPI</acronym> encrypted or
       non-<acronym>GSSAPI</acronym> encrypted connection attempts.
      </para>
________________________________________________________-->
      <para>
       这个记录匹配使用TCP/IP进行的连接尝试。
       <literal>host</literal>记录匹配
       <acronym>SSL</acronym>或非<acronym>SSL</acronym>连接
       尝试，以及<acronym>GSSAPI</acronym>加密或
       非<acronym>GSSAPI</acronym>加密连接尝试。
      </para>
<!-- pgdoc-cn_end sig_en=cf7c3d5279f00c85e3bd5d5bb65bf463 -->
     <note>
<!-- pgdoc-cn_start sig_en=1113f83fe34f54cb363863b9877a8c77 sig_cn_org=3c31334379c28767184be4f99a434ec5 source=15.7 
      <para>
       Remote TCP/IP connections will not be possible unless
       the server is started with an appropriate value for the
       <xref linkend="guc-listen-addresses"/> configuration parameter,
       since the default behavior is to listen for TCP/IP connections
       only on the local loopback address <literal>localhost</literal>.
      </para>
________________________________________________________-->
      <para>
       远程TCP/IP连接将无法实现，除非服务器以适当的值启动
       <xref linkend="guc-listen-addresses"/>配置参数，
       因为默认行为是仅在本地回环地址<literal>localhost</literal>上监听TCP/IP连接。
      </para>
<!-- pgdoc-cn_end sig_en=1113f83fe34f54cb363863b9877a8c77 -->
     </note>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hostssl</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=6b2c86dad2e95375a82194607bacf197 sig_cn_org=013a1e6c224287e4b85325ff053f281c source=15.7 
      <para>
       This record matches connection attempts made using TCP/IP,
       but only when the connection is made with <acronym>SSL</acronym>
       encryption.
      </para>
________________________________________________________-->
      <para>
       这条记录匹配使用TCP/IP进行的连接尝试，但仅当连接使用<acronym>SSL</acronym>加密时。
      </para>
<!-- pgdoc-cn_end sig_en=6b2c86dad2e95375a82194607bacf197 -->

<!-- pgdoc-cn_start sig_en=9b2519d99beffe11e0aec9cc473253ea sig_cn_org=4b9c4ed1319793135a0560d6ed9e5434 source=15.7 
      <para>
       To make use of this option the server must be built with
       <acronym>SSL</acronym> support. Furthermore,
       <acronym>SSL</acronym> must be enabled
       by setting the <xref linkend="guc-ssl"/> configuration parameter (see
       <xref linkend="ssl-tcp"/> for more information).
       Otherwise, the <literal>hostssl</literal> record is ignored except for
       logging a warning that it cannot match any connections.
      </para>
________________________________________________________-->
      <para>
       要使用此选项，服务器必须构建支持<acronym>SSL</acronym>。
       此外，必须通过设置<xref linkend="guc-ssl"/>配置参数来启用<acronym>SSL</acronym>
       （有关更多信息，请参见<xref linkend="ssl-tcp"/>）。
       否则，<literal>hostssl</literal>记录将被忽略，除了记录一个警告，说明它无法匹配任何连接。
      </para>
<!-- pgdoc-cn_end sig_en=9b2519d99beffe11e0aec9cc473253ea -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hostnossl</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=28a646f1cddcc1c800af50d013b0c431 sig_cn_org=1286ee2cc90fd0e2c580e2f231e2b1fc source=15.7 
      <para>
       This record type has the opposite behavior of <literal>hostssl</literal>;
       it only matches connection attempts made over
       TCP/IP that do not use <acronym>SSL</acronym>.
      </para>
________________________________________________________-->
      <para>
       这个记录类型与<literal>hostssl</literal>的行为相反；它只匹配通过TCP/IP进行的不使用<acronym>SSL</acronym>的连接尝试。
      </para>
<!-- pgdoc-cn_end sig_en=28a646f1cddcc1c800af50d013b0c431 -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hostgssenc</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=4fef26a9b28569c6cbd6ebafca683136 sig_cn_org=782f280d17aa327b89afa054e5d3c84e source=15.7 
      <para>
       This record matches connection attempts made using TCP/IP,
       but only when the connection is made with <acronym>GSSAPI</acronym>
       encryption.
      </para>
________________________________________________________-->
      <para>
       这条记录匹配使用TCP/IP进行的连接尝试，但仅当连接使用<acronym>GSSAPI</acronym>加密时。
      </para>
<!-- pgdoc-cn_end sig_en=4fef26a9b28569c6cbd6ebafca683136 -->

<!-- pgdoc-cn_start sig_en=69d62973518f4c84eb98f1e002b3651e sig_cn_org=60cba5f80ced5568a1f467a14c898c68 source=15.7 
      <para>
       To make use of this option the server must be built with
       <acronym>GSSAPI</acronym> support.  Otherwise,
       the <literal>hostgssenc</literal> record is ignored except for logging
       a warning that it cannot match any connections.
      </para>
________________________________________________________-->
      <para>
       要使用此选项，服务器必须构建具有<acronym>GSSAPI</acronym>支持。
       否则，<literal>hostgssenc</literal>记录将被忽略，除了记录一个警告，说明它无法匹配任何连接。
      </para>
<!-- pgdoc-cn_end sig_en=69d62973518f4c84eb98f1e002b3651e -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>hostnogssenc</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=779ba469f449e7d8c8708544fc175d64 sig_cn_org=ac136f049059604eeb578daa6118f6f6 source=15.7 
      <para>
       This record type has the opposite behavior of <literal>hostgssenc</literal>;
       it only matches connection attempts made over
       TCP/IP that do not use <acronym>GSSAPI</acronym> encryption.
      </para>
________________________________________________________-->
      <para>
       这个记录类型与<literal>hostgssenc</literal>的行为相反；
       它只匹配通过TCP/IP进行的不使用<acronym>GSSAPI</acronym>加密的连接尝试。
      </para>
<!-- pgdoc-cn_end sig_en=779ba469f449e7d8c8708544fc175d64 -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>database</replaceable></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=39dd910e2053585804f1bf7b7305fb77 sig_cn_org=de9ad6911290fdf024864c78c36f61e4 source=15.7 
      <para>
       Specifies which database name(s) this record matches.  The value
       <literal>all</literal> specifies that it matches all databases.
       The value <literal>sameuser</literal> specifies that the record
       matches if the requested database has the same name as the
       requested user.  The value <literal>samerole</literal> specifies that
       the requested user must be a member of the role with the same
       name as the requested database.  (<literal>samegroup</literal> is an
       obsolete but still accepted spelling of <literal>samerole</literal>.)
       Superusers are not considered to be members of a role for the
       purposes of <literal>samerole</literal> unless they are explicitly
       members of the role, directly or indirectly, and not just by
       virtue of being a superuser.
       The value <literal>replication</literal> specifies that the record
       matches if a physical replication connection is requested, however, it
       doesn't match with logical replication connections. Note that physical
       replication connections do not specify any particular database whereas
       logical replication connections do specify it.
       Otherwise, this is the name of
       a specific <productname>PostgreSQL</productname> database.
       Multiple database names can be supplied by separating them with
       commas.  A separate file containing database names can be specified by
       preceding the file name with <literal>@</literal>.
      </para>
________________________________________________________-->
      <para>
       指定此记录匹配的数据库名称。值<literal>all</literal>指定匹配所有数据库。
       值<literal>sameuser</literal>指定如果请求的数据库与请求的用户具有相同的名称，则记录匹配。
       值<literal>samerole</literal>指定请求的用户必须是与请求的数据库具有相同名称的角色的成员。
       (<literal>samegroup</literal>是<literal>samerole</literal>的一个过时但仍然被接受的拼写。)
       超级用户不被视为<literal>samerole</literal>的角色成员，除非他们明确是该角色的成员，直接或间接地，而不仅仅是因为是超级用户。
       值<literal>replication</literal>指定如果请求了物理复制连接，则记录匹配，但不匹配逻辑复制连接。请注意，物理复制连接不指定任何特定的数据库，而逻辑复制连接则指定。
       否则，这是一个特定的<productname>PostgreSQL</productname>数据库的名称。
       可以通过用逗号分隔它们来提供多个数据库名称。可以通过在文件名前加上<literal>@</literal>来指定包含数据库名称的单独文件。
      </para>
<!-- pgdoc-cn_end sig_en=39dd910e2053585804f1bf7b7305fb77 -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>user</replaceable></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=8f861420462bf0bcf26aa9dd6840ba94 sig_cn_org=1275445188f6e7aa2e90295a98b3e858 source=15.7 
      <para>
       Specifies which database user name(s) this record
       matches. The value <literal>all</literal> specifies that it
       matches all users.  Otherwise, this is either the name of a specific
       database user, or a group name preceded by <literal>+</literal>.
       (Recall that there is no real distinction between users and groups
       in <productname>PostgreSQL</productname>; a <literal>+</literal> mark really means
       <quote>match any of the roles that are directly or indirectly members
       of this role</quote>, while a name without a <literal>+</literal> mark matches
       only that specific role.) For this purpose, a superuser is only
       considered to be a member of a role if they are explicitly a member
       of the role, directly or indirectly, and not just by virtue of
       being a superuser.
       Multiple user names can be supplied by separating them with commas.
       A separate file containing user names can be specified by preceding the
       file name with <literal>@</literal>.
      </para>
________________________________________________________-->
      <para>
       指定此记录匹配哪些数据库用户名。值<literal>all</literal>指定匹配所有用户。
       否则，这可以是特定数据库用户的名称，或者是以<literal>+</literal>开头的组名。
       （请记住，在<productname>PostgreSQL</productname>中，用户和组之间没有真正的区别；
       <literal>+</literal>标记实际上意味着<quote>匹配直接或间接是此角色成员的任何角色</quote>，
       而没有<literal>+</literal>标记的名称仅匹配该特定角色。）对于此目的，只有超级用户
       被认为是角色的成员，如果他们明确是该角色的成员，直接或间接地，而不仅仅是因为
       是超级用户。
       可以通过用逗号分隔它们来提供多个用户名。可以通过在文件名前加上<literal>@</literal>
       来指定包含用户名的单独文件。
      </para>
<!-- pgdoc-cn_end sig_en=8f861420462bf0bcf26aa9dd6840ba94 -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>address</replaceable></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=a60711fa8c5768098b2bc92b825831c9 sig_cn_org=33372e47c77a87414ee341d3bfb2cd15 source=15.7 
      <para>
       Specifies the client machine address(es) that this record
       matches.  This field can contain either a host name, an IP
       address range, or one of the special key words mentioned below.
      </para>
________________________________________________________-->
      <para>
       指定此记录匹配的客户端机器地址。此字段可以包含主机名、IP地址范围或下面提到的特殊关键字之一。
      </para>
<!-- pgdoc-cn_end sig_en=a60711fa8c5768098b2bc92b825831c9 -->

<!-- pgdoc-cn_start sig_en=ba3c004e578ddcccb824d390eaf8a7f7 sig_cn_org=e1f6b7e6a510cda65b58b73b124edc83 source=15.7 
      <para>
       An IP address range is specified using standard numeric notation
       for the range's starting address, then a slash (<literal>/</literal>)
       and a <acronym>CIDR</acronym> mask length.  The mask
       length indicates the number of high-order bits of the client
       IP address that must match.  Bits to the right of this should
       be zero in the given IP address.
       There must not be any white space between the IP address, the
       <literal>/</literal>, and the CIDR mask length.
      </para>
________________________________________________________-->
      <para>
       IP地址范围使用标准的数字表示法来指定起始地址，然后是斜杠（<literal>/</literal>）和一个<acronym>CIDR</acronym>掩码长度。
       掩码长度表示客户端IP地址必须匹配的高位比特数。给定IP地址中右侧的比特应为零。
       IP地址、<literal>/</literal>和CIDR掩码长度之间不得有任何空格。
      </para>
<!-- pgdoc-cn_end sig_en=ba3c004e578ddcccb824d390eaf8a7f7 -->

<!-- pgdoc-cn_start sig_en=b4f38595538aceb130b964cecef13356 sig_cn_org=498950713b04421d2c8fc1dd6557f55a source=15.7 
      <para>
       Typical examples of an IPv4 address range specified this way are
       <literal>172.20.143.89/32</literal> for a single host, or
       <literal>172.20.143.0/24</literal> for a small network, or
       <literal>10.6.0.0/16</literal> for a larger one.
       An IPv6 address range might look like <literal>::1/128</literal>
       for a single host (in this case the IPv6 loopback address) or
       <literal>fe80::7a31:c1ff:0000:0000/96</literal> for a small
       network.
       <literal>0.0.0.0/0</literal> represents all
       IPv4 addresses, and <literal>::0/0</literal> represents
       all IPv6 addresses.
       To specify a single host, use a mask length of 32 for IPv4 or
       128 for IPv6.  In a network address, do not omit trailing zeroes.
      </para>
________________________________________________________-->
      <para>
       以这种方式指定的IPv4地址范围的典型示例包括<literal>172.20.143.89/32</literal>用于单个主机，
       或<literal>172.20.143.0/24</literal>用于小型网络，或<literal>10.6.0.0/16</literal>用于较大的网络。
       IPv6地址范围可能看起来像<literal>::1/128</literal>用于单个主机（在这种情况下是IPv6环回地址）或
       <literal>fe80::7a31:c1ff:0000:0000/96</literal>用于小型网络。
       <literal>0.0.0.0/0</literal>代表所有IPv4地址，<literal>::0/0</literal>代表所有IPv6地址。
       要指定单个主机，请对IPv4使用32的掩码长度，对IPv6使用128。在网络地址中，不要省略尾部的零。
      </para>
<!-- pgdoc-cn_end sig_en=b4f38595538aceb130b964cecef13356 -->

<!-- pgdoc-cn_start sig_en=0e6b62a48bccfd58fa35cfc38b0dbf16 sig_cn_org=85fa7ac1e06a3b51956dfc444f515054 source=15.7 
      <para>
       An entry given in IPv4 format will match only IPv4 connections,
       and an entry given in IPv6 format will match only IPv6 connections,
       even if the represented address is in the IPv4-in-IPv6 range.
       Note that entries in IPv6 format will be rejected if the system's
       C library does not have support for IPv6 addresses.
      </para>
________________________________________________________-->
      <para>
       以IPv4格式给出的条目将仅匹配IPv4连接，以IPv6格式给出的条目将仅匹配IPv6连接，
       即使所代表的地址在IPv4-in-IPv6范围内。请注意，如果系统的C库不支持IPv6地址，
       以IPv6格式给出的条目将被拒绝。
      </para>
<!-- pgdoc-cn_end sig_en=0e6b62a48bccfd58fa35cfc38b0dbf16 -->

<!-- pgdoc-cn_start sig_en=ae49dc8f76520894243d9dec08738f2a sig_cn_org=83a97cdf99c5a7dfef7587375736fa35 source=15.7 
      <para>
       You can also write <literal>all</literal> to match any IP address,
       <literal>samehost</literal> to match any of the server's own IP
       addresses, or <literal>samenet</literal> to match any address in any
       subnet that the server is directly connected to.
      </para>
________________________________________________________-->
      <para>
       你也可以写<literal>all</literal>来匹配任何IP地址，
       <literal>samehost</literal>来匹配服务器自己的任何IP地址，
       或<literal>samenet</literal>来匹配服务器直接连接到的任何子网中的任何地址。
      </para>
<!-- pgdoc-cn_end sig_en=ae49dc8f76520894243d9dec08738f2a -->

<!-- pgdoc-cn_start sig_en=4e9434af818a1c50d2570729a48512e3 sig_cn_org=8f4eb0a9be80d9a0ee550f2ea00e9c5f source=15.7 
      <para>
       If a host name is specified (anything that is not an IP address
       range or a special key word is treated as a host name),
       that name is compared with the result of a reverse name
       resolution of the client's IP address (e.g., reverse DNS
       lookup, if DNS is used).  Host name comparisons are case
       insensitive.  If there is a match, then a forward name
       resolution (e.g., forward DNS lookup) is performed on the host
       name to check whether any of the addresses it resolves to are
       equal to the client's IP address.  If both directions match,
       then the entry is considered to match.  (The host name that is
       used in <filename>pg_hba.conf</filename> should be the one that
       address-to-name resolution of the client's IP address returns,
       otherwise the line won't be matched.  Some host name databases
       allow associating an IP address with multiple host names, but
       the operating system will only return one host name when asked
       to resolve an IP address.)
      </para>
________________________________________________________-->
      <para>
       如果指定了主机名（任何不是IP地址范围或特殊关键字的内容都被视为主机名），
       则将该名称与客户端IP地址的反向名称解析结果进行比较（例如，如果使用DNS，则进行反向DNS查找）。
       主机名比较不区分大小写。如果匹配成功，则对主机名执行正向名称解析（例如，进行正向DNS查找），
       以检查其解析为的任何地址是否等于客户端IP地址。如果两个方向都匹配，则将条目视为匹配。
       （在<filename>pg_hba.conf</filename>中使用的主机名应该是客户端IP地址的地址到名称解析返回的名称，
       否则该行将不会匹配。一些主机名数据库允许将IP地址与多个主机名关联，
       但操作系统在要求解析IP地址时只会返回一个主机名。）
      </para>
<!-- pgdoc-cn_end sig_en=4e9434af818a1c50d2570729a48512e3 -->

<!-- pgdoc-cn_start sig_en=0db3c273b9e96e6ed0d661814fd15382 sig_cn_org=2baa204decbb7b45eeea00cfd55f7fe6 source=15.7 
      <para>
       A host name specification that starts with a dot
       (<literal>.</literal>) matches a suffix of the actual host
       name.  So <literal>.example.com</literal> would match
       <literal>foo.example.com</literal> (but not just
       <literal>example.com</literal>).
      </para>
________________________________________________________-->
      <para>
       以点（<literal>.</literal>）开头的主机名规范匹配实际主机名的后缀。
       因此，<literal>.example.com</literal>将匹配<literal>foo.example.com</literal>
       （但不仅仅是<literal>example.com</literal>）。
      </para>
<!-- pgdoc-cn_end sig_en=0db3c273b9e96e6ed0d661814fd15382 -->

<!-- pgdoc-cn_start sig_en=029b19b6999063fb02a21ce20c91fe6c sig_cn_org=196aca488b664b0c83152698b2f401e0 source=15.7 
      <para>
       When host names are specified
       in <filename>pg_hba.conf</filename>, you should make sure that
       name resolution is reasonably fast.  It can be of advantage to
       set up a local name resolution cache such
       as <command>nscd</command>.  Also, you may wish to enable the
       configuration parameter <varname>log_hostname</varname> to see
       the client's host name instead of the IP address in the log.
      </para>
________________________________________________________-->
      <para>
       当在<filename>pg_hba.conf</filename>中指定主机名时，您应确保名称解析相对快速。
       最好设置一个本地名称解析缓存，如<command>nscd</command>。
       此外，您可能希望启用配置参数<varname>log_hostname</varname>，以在日志中看到客户端的主机名而不是IP地址。
      </para>
<!-- pgdoc-cn_end sig_en=029b19b6999063fb02a21ce20c91fe6c -->

<!-- pgdoc-cn_start sig_en=3f17b0cda2373258ebc4d5c3af1b8440 sig_cn_org=06967d425f1c87a991c026a7052fc664 source=15.7 
      <para>
       These fields do not apply to <literal>local</literal> records.
      </para>
________________________________________________________-->
      <para>
       这些字段不适用于<literal>local</literal>记录。
      </para>
<!-- pgdoc-cn_end sig_en=3f17b0cda2373258ebc4d5c3af1b8440 -->

      <note>
<!-- pgdoc-cn_start sig_en=cefc3586c091c8d30604e9816c90162f sig_cn_org=57fa03efa32d8ff5c0d886c68ec199f1 source=15.7 
       <para>
        Users sometimes wonder why host names are handled
        in this seemingly complicated way, with two name resolutions
        including a reverse lookup of the client's IP address.  This
        complicates use of the feature in case the client's reverse DNS
        entry is not set up or yields some undesirable host name.
        It is done primarily for efficiency: this way, a connection attempt
        requires at most two resolver lookups, one reverse and one forward.
        If there is a resolver problem with some address, it becomes only
        that client's problem.  A hypothetical alternative
        implementation that only did forward lookups would have to
        resolve every host name mentioned in
        <filename>pg_hba.conf</filename> during every connection attempt.
        That could be quite slow if many names are listed.
        And if there is a resolver problem with one of the host names,
        it becomes everyone's problem.
       </para>
________________________________________________________-->
       <para>
        用户有时会想知道为什么主机名以这种看似复杂的方式处理，包括两次名称解析，其中包括对客户端IP地址的反向查找。
        如果客户端的反向DNS条目未设置或生成了一些不良的主机名，则使用该功能会变得复杂。
        这主要是为了效率：这样，连接尝试最多需要两次解析器查找，一次反向查找和一次正向查找。
        如果某个地址存在解析器问题，那就只会成为该客户端的问题。
        一个假设的替代实现只进行正向查找的情况下，在每次连接尝试期间都必须解析<filename>pg_hba.conf</filename>中提到的每个主机名。
        如果列出了许多名称，这可能会非常慢。
        如果其中一个主机名存在解析器问题，那么这将成为所有人的问题。
       </para>
<!-- pgdoc-cn_end sig_en=cefc3586c091c8d30604e9816c90162f -->

<!-- pgdoc-cn_start sig_en=2ddd2e7871c73c87aa0336d2db67a997 sig_cn_org=a89064c7f63709030a1d9ae1ff0d34c8 source=15.7 
       <para>
        Also, a reverse lookup is necessary to implement the suffix
        matching feature, because the actual client host name needs to
        be known in order to match it against the pattern.
       </para>
________________________________________________________-->
       <para>
        此外，实现后缀匹配功能需要进行反向查找，因为需要知道实际客户端主机名
        以便将其与模式进行匹配。
       </para>
<!-- pgdoc-cn_end sig_en=2ddd2e7871c73c87aa0336d2db67a997 -->

<!-- pgdoc-cn_start sig_en=6048120c403b49832e6e2d410c21c9cc sig_cn_org=752e78f99288f1f28ea6148aca560672 source=15.7 
       <para>
        Note that this behavior is consistent with other popular
        implementations of host name-based access control, such as the
        Apache HTTP Server and TCP Wrappers.
       </para>
________________________________________________________-->
       <para>
        请注意，这种行为与其他流行的基于主机名的访问控制实现一致，例如
        Apache HTTP服务器和TCP包装器。
       </para>
<!-- pgdoc-cn_end sig_en=6048120c403b49832e6e2d410c21c9cc -->
      </note>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>IP-address</replaceable></term>
     <term><replaceable>IP-mask</replaceable></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=ac62899b09c251b496a85089640180b4 sig_cn_org=4f8a2ca65c3d2fb18de9323291391a97 source=15.7 
      <para>
       These two fields can be used as an alternative to the
       <replaceable>IP-address</replaceable><literal>/</literal><replaceable>mask-length</replaceable>
       notation.  Instead of
       specifying the mask length, the actual mask is specified in a
       separate column. For example, <literal>255.0.0.0</literal> represents an IPv4
       CIDR mask length of 8, and <literal>255.255.255.255</literal> represents a
       CIDR mask length of 32.
      </para>
________________________________________________________-->
      <para>
       这两个字段可以用作<replaceable>IP地址</replaceable><literal>/</literal><replaceable>掩码长度</replaceable>
       表示法的替代方案。而不是指定掩码长度，实际掩码在一个单独的列中指定。
       例如，<literal>255.0.0.0</literal>表示IPv4的CIDR掩码长度为8，
       而<literal>255.255.255.255</literal>表示CIDR掩码长度为32。
      </para>
<!-- pgdoc-cn_end sig_en=ac62899b09c251b496a85089640180b4 -->

<!-- pgdoc-cn_start sig_en=3f17b0cda2373258ebc4d5c3af1b8440 sig_cn_org=06967d425f1c87a991c026a7052fc664 source=15.7 
      <para>
       These fields do not apply to <literal>local</literal> records.
      </para>
________________________________________________________-->
      <para>
       这些字段不适用于<literal>local</literal>记录。
      </para>
<!-- pgdoc-cn_end sig_en=3f17b0cda2373258ebc4d5c3af1b8440 -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>auth-method</replaceable></term>
<!-- pgdoc-cn_start sig_en=dc2d47d81762c5a02998133d66911384 sig_cn_org=f7fbdcec27ddb3ae3fc6b82fc065afe5 source=15.7 
     <listitem>
      <para>
       Specifies the authentication method to use when a connection matches
       this record. The possible choices are summarized here; details
       are in <xref linkend="auth-methods"/>.  All the options
       are lower case and treated case sensitively, so even acronyms like
       <literal>ldap</literal> must be specified as lower case.

       <variablelist>
        <varlistentry>
________________________________________________________-->
     <listitem>
      <para>
       指定连接匹配此记录时要使用的身份验证方法。可能的选择在这里总结; 详细信息在<xref linkend="auth-methods"/>中。所有选项都是小写的，并且区分大小写，因此即使是像<literal>ldap</literal>这样的首字母缩写也必须指定为小写。

       <variablelist>
        <varlistentry>
<!-- pgdoc-cn_end sig_en=dc2d47d81762c5a02998133d66911384 -->
         <term><literal>trust</literal></term>
         <listitem>
<!-- pgdoc-cn_start sig_en=fb1a8c3be0f7d96302c14ec6e2274404 sig_cn_org=0c4768e4a29fc1171fc1f3022c422d62 source=15.7 
         <para>
          Allow the connection unconditionally. This method
          allows anyone that can connect to the
          <productname>PostgreSQL</productname> database server to login as
          any <productname>PostgreSQL</productname> user they wish,
          without the need for a password or any other authentication.  See <xref
          linkend="auth-trust"/> for details.
         </para>
________________________________________________________-->
         <para>
          允许无条件连接。这种方法允许任何可以连接到<productname>PostgreSQL</productname>数据库服务器的人以任何他们希望的<productname>PostgreSQL</productname>用户登录，无需密码或任何其他身份验证。有关详细信息，请参见<xref linkend="auth-trust"/>。
         </para>
<!-- pgdoc-cn_end sig_en=fb1a8c3be0f7d96302c14ec6e2274404 -->
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>reject</literal></term>
        <listitem>
<!-- pgdoc-cn_start sig_en=489b456d2008333a1bbf16b6e97043df sig_cn_org=ef59517d70bfc7c25fdc6d1bb5d9932e source=15.7 
         <para>
          Reject the connection unconditionally. This is useful for
          <quote>filtering out</quote> certain hosts from a group, for example a
          <literal>reject</literal> line could block a specific host from connecting,
          while a later line allows the remaining hosts in a specific
          network to connect.
         </para>
________________________________________________________-->
         <para>
          无条件拒绝连接。这对于<quote>过滤掉</quote>某些主机很有用，例如一个<literal>reject</literal>行可以阻止特定主机连接，
          而后面的行允许特定网络中的其余主机连接。
         </para>
<!-- pgdoc-cn_end sig_en=489b456d2008333a1bbf16b6e97043df -->
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>scram-sha-256</literal></term>
        <listitem>
<!-- pgdoc-cn_start sig_en=ac1aa2b4b696d164cb91660500e0ccb7 sig_cn_org=60fb300bbaeefe40bf865b81049b4bef source=15.7 
         <para>
          Perform SCRAM-SHA-256 authentication to verify the user's
          password. See <xref linkend="auth-password"/> for details.
         </para>
________________________________________________________-->
         <para>
          执行SCRAM-SHA-256身份验证以验证用户的密码。详细信息请参见<xref linkend="auth-password"/>。
         </para>
<!-- pgdoc-cn_end sig_en=ac1aa2b4b696d164cb91660500e0ccb7 -->
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>md5</literal></term>
        <listitem>
<!-- pgdoc-cn_start sig_en=572dc13351b4692d1f72c66e4194d774 sig_cn_org=6e931e2328fc2878bef1eb84a291c21b source=15.7 
         <para>
          Perform SCRAM-SHA-256 or MD5 authentication to verify the
          user's password. See <xref linkend="auth-password"/>
          for details.
         </para>
________________________________________________________-->
         <para>
          执行SCRAM-SHA-256或MD5身份验证以验证用户的密码。详细信息请参见<xref linkend="auth-password"/>。
         </para>
<!-- pgdoc-cn_end sig_en=572dc13351b4692d1f72c66e4194d774 -->
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>password</literal></term>
        <listitem>
<!-- pgdoc-cn_start sig_en=a19a7115d91dd76805eeab1db987f1e8 sig_cn_org=f507891c6bba6d28788c2f5101700533 source=15.7 
         <para>
          Require the client to supply an unencrypted password for
          authentication.
          Since the password is sent in clear text over the
          network, this should not be used on untrusted networks.
          See <xref linkend="auth-password"/> for details.
         </para>
________________________________________________________-->
         <para>
          要求客户端提供未加密的密码进行身份验证。
          由于密码以明文形式通过网络发送，因此不应在不受信任的网络上使用。
          详细信息请参见<xref linkend="auth-password"/>。
         </para>
<!-- pgdoc-cn_end sig_en=a19a7115d91dd76805eeab1db987f1e8 -->
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>gss</literal></term>
        <listitem>
<!-- pgdoc-cn_start sig_en=3b4df58ea4a31aff16a8adfcda4b0c39 sig_cn_org=2019e776dfa03ff16e65806060d717ad source=15.7 
         <para>
          Use GSSAPI to authenticate the user. This is only
          available for TCP/IP connections. See <xref
          linkend="gssapi-auth"/> for details.  It can be used in conjunction
          with GSSAPI encryption.
         </para>
________________________________________________________-->
         <para>
          使用GSSAPI对用户进行身份验证。这仅适用于TCP/IP连接。有关详细信息，请参见<xref
          linkend="gssapi-auth"/>。它可以与GSSAPI加密一起使用。
         </para>
<!-- pgdoc-cn_end sig_en=3b4df58ea4a31aff16a8adfcda4b0c39 -->
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>sspi</literal></term>
        <listitem>
<!-- pgdoc-cn_start sig_en=23ed4f24e91f5f6bbfc41e0d119ddfc6 sig_cn_org=8d58d567e99d271e37e3c69141e285fe source=15.7 
         <para>
          Use SSPI to authenticate the user. This is only
          available on Windows. See <xref
          linkend="sspi-auth"/> for details.
         </para>
________________________________________________________-->
         <para>
          使用SSPI对用户进行身份验证。这仅适用于Windows。有关详细信息，请参见<xref
          linkend="sspi-auth"/>。
         </para>
<!-- pgdoc-cn_end sig_en=23ed4f24e91f5f6bbfc41e0d119ddfc6 -->
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>ident</literal></term>
        <listitem>
<!-- pgdoc-cn_start sig_en=ba4eee3672397090df68bb8dc026e60f sig_cn_org=8a9a5a798ac14089022c541e95f731c1 source=15.7 
         <para>
          Obtain the operating system user name of the client
          by contacting the ident server on the client
          and check if it matches the requested database user name.
          Ident authentication can only be used on TCP/IP
          connections. When specified for local connections, peer
          authentication will be used instead.
          See <xref linkend="auth-ident"/> for details.
         </para>
________________________________________________________-->
         <para>
          通过联系客户端上的ident服务器获取操作系统用户名称，
          并检查是否与请求的数据库用户名称匹配。
          Ident身份验证只能用于TCP/IP连接。
          当为本地连接指定时，将改为使用对等身份验证。
          详细信息请参见<xref linkend="auth-ident"/>。
         </para>
<!-- pgdoc-cn_end sig_en=ba4eee3672397090df68bb8dc026e60f -->
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>peer</literal></term>
        <listitem>
<!-- pgdoc-cn_start sig_en=b3e66854815f9aeb85f612942ee05f62 sig_cn_org=2d79a6676909c9e66fb2070965c5c553 source=15.7 
         <para>
          Obtain the client's operating system user name from the operating
          system and check if it matches the requested database user name.
          This is only available for local connections.
          See <xref linkend="auth-peer"/> for details.
         </para>
________________________________________________________-->
         <para>
          从操作系统获取客户端的操作系统用户名，并检查是否与请求的数据库用户名匹配。
          这仅适用于本地连接。
          有关详细信息，请参见<xref linkend="auth-peer"/>。
         </para>
<!-- pgdoc-cn_end sig_en=b3e66854815f9aeb85f612942ee05f62 -->
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>ldap</literal></term>
        <listitem>
<!-- pgdoc-cn_start sig_en=4067c11cb0ae293f52658550df6920c9 sig_cn_org=4f26e2f422539c6a2604d7d3f7794e08 source=15.7 
         <para>
          Authenticate using an <acronym>LDAP</acronym> server. See <xref
          linkend="auth-ldap"/> for details.
         </para>
________________________________________________________-->
         <para>
          使用<acronym>LDAP</acronym>服务器进行身份验证。有关详细信息，请参见<xref
          linkend="auth-ldap"/>。
         </para>
<!-- pgdoc-cn_end sig_en=4067c11cb0ae293f52658550df6920c9 -->
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>radius</literal></term>
        <listitem>
<!-- pgdoc-cn_start sig_en=6db4405ea3416034f065f7d3ed2d5964 sig_cn_org=791f2917190376c87856379f945bb9ba source=15.7 
         <para>
          Authenticate using a RADIUS server. See <xref
          linkend="auth-radius"/> for details.
         </para>
________________________________________________________-->
         <para>
          使用RADIUS服务器进行身份验证。详细信息请参见<xref
          linkend="auth-radius"/>。
         </para>
<!-- pgdoc-cn_end sig_en=6db4405ea3416034f065f7d3ed2d5964 -->
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>cert</literal></term>
        <listitem>
<!-- pgdoc-cn_start sig_en=a14eab6bbded683971b348038b60c185 sig_cn_org=b005bc7be3a33b28fe0679242183899b source=15.7 
         <para>
          Authenticate using SSL client certificates. See
          <xref linkend="auth-cert"/> for details.
         </para>
________________________________________________________-->
         <para>
          使用SSL客户端证书进行身份验证。详情请参见<xref linkend="auth-cert"/>。
         </para>
<!-- pgdoc-cn_end sig_en=a14eab6bbded683971b348038b60c185 -->
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>pam</literal></term>
        <listitem>
<!-- pgdoc-cn_start sig_en=bfd136dff5ade08da21832f810a82b21 sig_cn_org=6752813b7b7645de2289ae60c205e9f9 source=15.7 
         <para>
          Authenticate using the Pluggable Authentication Modules
          (PAM) service provided by the operating system.  See <xref
          linkend="auth-pam"/> for details.
         </para>
________________________________________________________-->
         <para>
          使用操作系统提供的可插拔认证模块（PAM）服务进行身份验证。详细信息请参见<xref
          linkend="auth-pam"/>。
         </para>
<!-- pgdoc-cn_end sig_en=bfd136dff5ade08da21832f810a82b21 -->
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>bsd</literal></term>
        <listitem>
<!-- pgdoc-cn_start sig_en=5024253c8289675d3247255128d3a476 sig_cn_org=dd3f8b5aa6c59ee74486fe6cfb92efd4 source=15.7 
         <para>
          Authenticate using the BSD Authentication service provided by the
          operating system. See <xref linkend="auth-bsd"/> for details.
         </para>
________________________________________________________-->
         <para>
          使用操作系统提供的BSD认证服务进行身份验证。有关详细信息，请参见<xref linkend="auth-bsd"/>。
         </para>
<!-- pgdoc-cn_end sig_en=5024253c8289675d3247255128d3a476 -->
        </listitem>
       </varlistentry>
      </variablelist>

      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>auth-options</replaceable></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=6376d038f20d112b63935c01026e221f sig_cn_org=4420259577b40250ec058466bdc95307 source=15.7 
      <para>
       After the <replaceable>auth-method</replaceable> field, there can be field(s) of
       the form <replaceable>name</replaceable><literal>=</literal><replaceable>value</replaceable> that
       specify options for the authentication method. Details about which
       options are available for which authentication methods appear below.
      </para>
________________________________________________________-->
      <para>
       在<replaceable>auth-method</replaceable>字段之后，可以是形如<replaceable>name</replaceable><literal>=</literal><replaceable>value</replaceable>的字段，
       用于指定认证方法的选项。关于哪些选项适用于哪些认证方法的详细信息见下文。
      </para>
<!-- pgdoc-cn_end sig_en=6376d038f20d112b63935c01026e221f -->

<!-- pgdoc-cn_start sig_en=08edb4e4ea48537c93605e4da3baafc8 sig_cn_org=4328eab1d297ba00fab4d7deb6de1eba source=15.7 
      <para>
       In addition to the method-specific options listed below, there is a
       method-independent authentication option <literal>clientcert</literal>, which
       can be specified in any <literal>hostssl</literal> record.
       This option can be set to <literal>verify-ca</literal> or
       <literal>verify-full</literal>. Both options require the client
       to present a valid (trusted) SSL certificate, while
       <literal>verify-full</literal> additionally enforces that the
       <literal>cn</literal> (Common Name) in the certificate matches
       the username or an applicable mapping.
       This behavior is similar to the <literal>cert</literal> authentication
       method (see <xref linkend="auth-cert"/>) but enables pairing
       the verification of client certificates with any authentication
       method that supports <literal>hostssl</literal> entries.
      </para>
________________________________________________________-->
      <para>
       除了下面列出的特定于方法的选项外，还有一个方法无关的身份验证选项<literal>clientcert</literal>，
       可以在任何<literal>hostssl</literal>记录中指定。
       此选项可以设置为<literal>verify-ca</literal>或<literal>verify-full</literal>。
       这两个选项都要求客户端提供有效（受信任的）SSL证书，
       而<literal>verify-full</literal>还要求证书中的<literal>cn</literal>（通用名称）与用户名或适用映射匹配。
       这种行为类似于<literal>cert</literal>身份验证方法（请参阅<xref linkend="auth-cert"/>），
       但允许将客户端证书的验证与支持<literal>hostssl</literal>条目的任何身份验证方法配对。
      </para>
<!-- pgdoc-cn_end sig_en=08edb4e4ea48537c93605e4da3baafc8 -->
<!-- pgdoc-cn_start sig_en=0521e989d5c7e8f7bbda4e1a8d1f73bb sig_cn_org=b691b1116718dfcdbf63d3ea84d304ed source=15.7 
      <para>
       On any record using client certificate authentication (i.e. one
       using the <literal>cert</literal> authentication method or one
       using the <literal>clientcert</literal> option), you can specify
       which part of the client certificate credentials to match using
       the <literal>clientname</literal> option. This option can have one
       of two values. If you specify <literal>clientname=CN</literal>, which
       is the default, the username is matched against the certificate's
       <literal>Common Name (CN)</literal>. If instead you specify
       <literal>clientname=DN</literal> the username is matched against the
       entire <literal>Distinguished Name (DN)</literal> of the certificate.
       This option is probably best used in conjunction with a username map.
       The comparison is done with the <literal>DN</literal> in
       <ulink url="https://datatracker.ietf.org/doc/html/rfc2253">RFC 2253</ulink>
       format. To see the <literal>DN</literal> of a client certificate
       in this format, do
<programlisting>
openssl x509 -in myclient.crt -noout -subject -nameopt RFC2253 | sed "s/^subject=//"
</programlisting>
        Care needs to be taken when using this option, especially when using
        regular expression matching against the <literal>DN</literal>.
      </para>
________________________________________________________-->
      <para>
       在使用客户端证书认证的任何记录上（即使用<literal>cert</literal>认证方法或使用<literal>clientcert</literal>选项的记录），您可以使用<literal>clientname</literal>选项指定要匹配的客户端证书凭据的哪个部分。此选项可以有两个值之一。如果您指定<literal>clientname=CN</literal>，这是默认值，则用户名将与证书的<literal>Common Name (CN)</literal>进行匹配。如果您改为指定<literal>clientname=DN</literal>，则用户名将与证书的整个<literal>Distinguished Name (DN)</literal>进行匹配。此选项最好与用户名映射一起使用。比较是使用<literal>DN</literal>以<ulink url="https://datatracker.ietf.org/doc/html/rfc2253">RFC 2253</ulink>格式进行的。要查看以此格式显示的客户端证书的<literal>DN</literal>，请执行
<programlisting>
openssl x509 -in myclient.crt -noout -subject -nameopt RFC2253 | sed "s/^subject=//"
</programlisting>
        在使用此选项时需要小心，特别是在使用正则表达式匹配<literal>DN</literal>时。
      </para>
<!-- pgdoc-cn_end sig_en=0521e989d5c7e8f7bbda4e1a8d1f73bb -->
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<!-- pgdoc-cn_start sig_en=fa1194d7a24bcf53ee63a125341bc80c sig_cn_org=None source=14.1 
  <para>
   Files included by <literal>@</literal> constructs are read as lists of names,
   which can be separated by either whitespace or commas.  Comments are
   introduced by <literal>#</literal>, just as in
   <filename>pg_hba.conf</filename>, and nested <literal>@</literal> constructs are
   allowed.  Unless the file name following <literal>@</literal> is an absolute
   path, it is taken to be relative to the directory containing the
   referencing file.
  </para>
________________________________________________________-->
  <para>
   用<literal>@</literal>结构包括的文件被读作一个名字列表，它们可以用空白或者逗号分隔。注释用<literal>#</literal>引入，就像在<filename>pg_hba.conf</filename>中那样，并且允许嵌套<literal>@</literal>结构。除非跟在<literal>@</literal>后面的文件名是一个绝对路径， 文件名都被认为是相对于包含引用文件的目录。
  </para>
<!-- pgdoc-cn_end sig_en=fa1194d7a24bcf53ee63a125341bc80c -->

<!-- pgdoc-cn_start sig_en=b361797a7236e0ba23de0643a110e8c2 sig_cn_org=None source=14.1 
  <para>
   Since the <filename>pg_hba.conf</filename> records are examined
   sequentially for each connection attempt, the order of the records is
   significant. Typically, earlier records will have tight connection
   match parameters and weaker authentication methods, while later
   records will have looser match parameters and stronger authentication
   methods. For example, one might wish to use <literal>trust</literal>
   authentication for local TCP/IP connections but require a password for
   remote TCP/IP connections. In this case a record specifying
   <literal>trust</literal> authentication for connections from 127.0.0.1 would
   appear before a record specifying password authentication for a wider
   range of allowed client IP addresses.
  </para>
________________________________________________________-->
  <para>
   因为每一次连接尝试都会顺序地检查<filename>pg_hba.conf</filename>记录，所以这些记录的顺序是非常关键的。通常，靠前的记录有比较严的连接匹配参数和比较弱的认证方法，而靠后的记录有比较松的匹配参数和比较强的认证方法。 例如，我们希望对本地 TCP/IP 连接使用<literal>trust</literal>认证，而对远程 TCP/IP 连接要求口令。在这种情况下为来自于 127.0.0.1 的连接指定<literal>trust</literal>认证的记录将出现在为一个更宽范围的客户端 IP 地址指定口令认证的记录前面。
  </para>
<!-- pgdoc-cn_end sig_en=b361797a7236e0ba23de0643a110e8c2 -->

<!-- pgdoc-cn_start sig_en=b51e3a2c564477e0c099ca759d159fc1 sig_cn_org=None source=14.1 
  <para>
   The <filename>pg_hba.conf</filename> file is read on start-up and when
   the main server process receives a
   <systemitem>SIGHUP</systemitem><indexterm><primary>SIGHUP</primary></indexterm>
   signal. If you edit the file on an
   active system, you will need to signal the postmaster
   (using <literal>pg_ctl reload</literal>, calling the SQL function
   <function>pg_reload_conf()</function>, or using <literal>kill
   -HUP</literal>) to make it re-read the file.
  </para>
________________________________________________________-->
  <para>
   在启动以及主服务器进程收到<systemitem>SIGHUP</systemitem><indexterm><primary>SIGHUP</primary></indexterm>信号时，<filename>pg_hba.conf</filename>文件会被读取。 
   如果你在活动的系统上编辑了该文件，你将需要通知 postmaster（使用<literal>pg_ctl reload</literal>，调用SQL函数<function>pg_reload_conf()</function>,或使用<literal>kill -HUP</literal>）使其重新读取该文件。
  </para>
<!-- pgdoc-cn_end sig_en=b51e3a2c564477e0c099ca759d159fc1 -->

  <note>
<!-- pgdoc-cn_start sig_en=5570acaee367a5770ec62e5c5bf25d4b sig_cn_org=None source=14.1 
   <para>
    The preceding statement is not true on Microsoft Windows: there, any
    changes in the <filename>pg_hba.conf</filename> file are immediately
    applied by subsequent new connections.
   </para>
________________________________________________________-->
   <para>
    前面的说明在Microsoft Windows上不为真：在Windows上，<filename>pg_hba.conf</filename>文件中的任何更改会立即被应用到后续的新连接上。
   </para>
<!-- pgdoc-cn_end sig_en=5570acaee367a5770ec62e5c5bf25d4b -->
  </note>

<!-- pgdoc-cn_start sig_en=47a48158eaa15299606b198522bb06e4 sig_cn_org=None source=14.1 
  <para>
   The system view
   <link linkend="view-pg-hba-file-rules"><structname>pg_hba_file_rules</structname></link>
   can be helpful for pre-testing changes to the <filename>pg_hba.conf</filename>
   file, or for diagnosing problems if loading of the file did not have the
   desired effects.  Rows in the view with
   non-null <structfield>error</structfield> fields indicate problems in the
   corresponding lines of the file.
  </para>
________________________________________________________-->
  <para>
   系统视图<link linkend="view-pg-hba-file-rules"><structname>pg_hba_file_rules</structname></link>有助于预先测试对<filename>pg_hba.conf</filename>文件的更改，该视图也可以在该文件的装载没有产生预期效果时用于诊断问题。该视图中带有非空<structfield>error</structfield>域的行就表示该文件对应行中存在问题。
  </para>
<!-- pgdoc-cn_end sig_en=47a48158eaa15299606b198522bb06e4 -->

  <tip>
<!-- pgdoc-cn_start sig_en=a7947d154690a672a9eb82a2a6ba2967 sig_cn_org=None source=14.1 
   <para>
    To connect to a particular database, a user must not only pass the
    <filename>pg_hba.conf</filename> checks, but must have the
    <literal>CONNECT</literal> privilege for the database.  If you wish to
    restrict which users can connect to which databases, it's usually
    easier to control this by granting/revoking <literal>CONNECT</literal> privilege
    than to put the rules in <filename>pg_hba.conf</filename> entries.
   </para>
________________________________________________________-->
   <para>
    要连接到一个特定数据库，一个用户必须不仅要通过<filename>pg_hba.conf</filename>检查，还必须要有该数据库上的<literal>CONNECT</literal>权限。如果你希望限制哪些用户能够连接到哪些数据库，授予/撤销<literal>CONNECT</literal>权限通常比在<filename>pg_hba.conf</filename>项中设置规则简单。
   </para>
<!-- pgdoc-cn_end sig_en=a7947d154690a672a9eb82a2a6ba2967 -->
  </tip>

<!-- pgdoc-cn_start sig_en=413d139107130c4f7b497352f8ccd2ca sig_cn_org=None source=14.1 
  <para>
   Some examples of <filename>pg_hba.conf</filename> entries are shown in
   <xref linkend="example-pg-hba.conf"/>. See the next section for details on the
   different authentication methods.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="example-pg-hba.conf"/>中展示了<filename>pg_hba.conf</filename>项的一些例子。不同认证方法的详情请见下一节。
  </para>
<!-- pgdoc-cn_end sig_en=413d139107130c4f7b497352f8ccd2ca -->

   <example id="example-pg-hba.conf">
<!-- pgdoc-cn_start sig_en=ce8cae43b96047001b10332d309b959b sig_cn_org=None source=14.1 
    <title>Example <filename>pg_hba.conf</filename> Entries</title>
________________________________________________________-->
    <title>示例 <filename>pg_hba.conf</filename> 项</title>
<!-- pgdoc-cn_end sig_en=ce8cae43b96047001b10332d309b959b -->
<!-- pgdoc-cn_start sig_en=2e2079d1e61fc3a673af7acd844f5ebb sig_cn_org=None source=14.1 
<programlisting>
# Allow any user on the local system to connect to any database with
# any database user name using Unix-domain sockets (the default for local
# connections).
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   all             all                                     trust

# The same using local loopback TCP/IP connections.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             127.0.0.1/32            trust

# The same as the previous line, but using a separate netmask column
#
# TYPE  DATABASE        USER            IP-ADDRESS      IP-MASK             METHOD
host    all             all             127.0.0.1       255.255.255.255     trust

# The same over IPv6.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             ::1/128                 trust

# The same using a host name (would typically cover both IPv4 and IPv6).
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             localhost               trust

# Allow any user from any host with IP address 192.168.93.x to connect
# to database "postgres" as the same user name that ident reports for
# the connection (typically the operating system user name).
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    postgres        all             192.168.93.0/24         ident

# Allow any user from host 192.168.12.10 to connect to database
# "postgres" if the user's password is correctly supplied.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    postgres        all             192.168.12.10/32        scram-sha-256

# Allow any user from hosts in the example.com domain to connect to
# any database if the user's password is correctly supplied.
#
# Require SCRAM authentication for most users, but make an exception
# for user 'mike', who uses an older client that doesn't support SCRAM
# authentication.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             mike            .example.com            md5
host    all             all             .example.com            scram-sha-256

# In the absence of preceding "host" lines, these three lines will
# reject all connections from 192.168.54.1 (since that entry will be
# matched first), but allow GSSAPI-encrypted connections from anywhere else
# on the Internet.  The zero mask causes no bits of the host IP address to
# be considered, so it matches any host.  Unencrypted GSSAPI connections
# (which "fall through" to the third line since "hostgssenc" only matches
# encrypted GSSAPI connections) are allowed, but only from 192.168.12.10.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             192.168.54.1/32         reject
hostgssenc all          all             0.0.0.0/0               gss
host    all             all             192.168.12.10/32        gss

# Allow users from 192.168.x.x hosts to connect to any database, if
# they pass the ident check.  If, for example, ident says the user is
# "bryanh" and he requests to connect as PostgreSQL user "guest1", the
# connection is allowed if there is an entry in pg_ident.conf for map
# "omicron" that says "bryanh" is allowed to connect as "guest1".
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             192.168.0.0/16          ident map=omicron

# If these are the only three lines for local connections, they will
# allow local users to connect only to their own databases (databases
# with the same name as their database user name) except for administrators
# and members of role "support", who can connect to all databases.  The file
# $PGDATA/admins contains a list of names of administrators.  Passwords
# are required in all cases.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   sameuser        all                                     md5
local   all             @admins                                 md5
local   all             +support                                md5

# The last two lines above can be combined into a single line:
local   all             @admins,+support                        md5

# The database column can also use lists and file names:
local   db1,db2,@demodbs  all                                   md5
</programlisting>
________________________________________________________-->
<programlisting>
# 允许本地系统上的任何用户
# 通过 Unix 域套接字以任意
# 数据库用户名连接到任意数据库（本地连接的默认值）。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   all             all                                     trust

# 相同的规则，但是使用本地环回 TCP/IP 连接。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             127.0.0.1/32            trust

# 和前一行相同，但是使用了一个独立的掩码列
#
# TYPE  DATABASE        USER            IP-ADDRESS      IP-MASK             METHOD
host    all             all             127.0.0.1       255.255.255.255     trust

# IPv6 上相同的规则
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             ::1/128                 trust

# 使用主机名的相同规则（通常同时覆盖 IPv4 和 IPv6）。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             localhost               trust

# 允许来自任意具有 IP 地址192.168.93.x 的主机上任意
# 用户以 ident 为该连接所报告的相同用户名连接到
# 数据库 "postgres"（通常是操作系统用户名）。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    postgres        all             192.168.93.0/24         ident

# 如果用户的口令被正确提供，允许来自主机 192.168.12.10
# 的任意用户连接到数据库 "postgres"。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    postgres        all             192.168.12.10/32        scram-sha-256

# 如果用户的口令被正确提供，允许 example.com 中主机上
# 的任意用户连接到任意数据库。
#
# 为大部分用户要求SCRAM认证，但是用户'mike'是个例外，
# 他使用的是不支持SCRAM认证的旧客户端。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             mike            .example.com            md5
host    all             all             .example.com            scram-sha-256

# 如果没有前面的 "host" 行，这三行
# 将拒绝所有来自 192.168.54.1的连接（因为那些项将首先被匹配），
# 但是允许来自互联网其他任何地方的
# GSSAPI-encrypted连接。零掩码导致主机IP 地址中的所有位都不会被考虑，
# 因此它匹配任意主机。未加密GSSAPI连接
# (which "跳转"到第三行是因为"hostgssenc" 仅匹配加密的 GSSAPI 连接) 是被允许的,但只能来自192.168.12.10.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             192.168.54.1/32         reject
hostgssenc all          all             0.0.0.0/0               gss
host    all             all             192.168.12.10/32        gss

# 允许来自 192.168.x.x 主机的用户连接到任意数据库，如果它们能够
# 通过 ident 检查。例如，假设 ident说用户是 "bryanh" 并且他要求以
# PostgreSQL 用户 "guest1" 连接，如果在 pg_ident.conf 有一个映射
# "omicron" 的选项说 "bryanh" 被允许以 "guest1" 连接，则该连接将被允许。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             192.168.0.0/16          ident map=omicron

# 如果这些是本地连接的唯一三行，它们将允许本地用户只连接到它们
# 自己的数据库（与其数据库用户名同名的数据库），不过管理员和角
# 色 "support" 的成员除外（它们可以连接到所有数据库）。文件
# $PGDATA/admins 包含一个管理员名字的列表。在所有情况下都要求口令。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   sameuser        all                                     md5
local   all             @admins                                 md5
local   all             +support                                md5

# 上面的最后两行可以被整合为一行：
local   all             @admins,+support                        md5

# 数据库列也可以用列表和文件名：
local   db1,db2,@demodbs  all                                   md5
</programlisting>
<!-- pgdoc-cn_end sig_en=2e2079d1e61fc3a673af7acd844f5ebb -->
   </example>
 </sect1>

 <sect1 id="auth-username-maps">
<!-- pgdoc-cn_start sig_en=854da2517cda5c3b4baf989e814a7957 sig_cn_org=None source=14.1 
  <title>User Name Maps</title>
________________________________________________________-->
  <title>用户名映射</title>
<!-- pgdoc-cn_end sig_en=854da2517cda5c3b4baf989e814a7957 -->

<!-- pgdoc-cn_start sig_en=41fa9a414b2b96551101d2baf93d1774 sig_cn_org=None source=14.1 
  <indexterm zone="auth-username-maps">
   <primary>User name maps</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="auth-username-maps">
   <primary>用户名映射</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=41fa9a414b2b96551101d2baf93d1774 -->

<!-- pgdoc-cn_start sig_en=48c951e1615715ce56ce03e80dbda028 sig_cn_org=None source=14.1 
  <para>
   When using an external authentication system such as Ident or GSSAPI,
   the name of the operating system user that initiated the connection
   might not be the same as the database user (role) that is to be used.
   In this case, a user name map can be applied to map the operating system
   user name to a database user.  To use user name mapping, specify
   <literal>map</literal>=<replaceable>map-name</replaceable>
   in the options field in <filename>pg_hba.conf</filename>. This option is
   supported for all authentication methods that receive external user names.
   Since different mappings might be needed for different connections,
   the name of the map to be used is specified in the
   <replaceable>map-name</replaceable> parameter in <filename>pg_hba.conf</filename>
   to indicate which map to use for each individual connection.
  </para>
________________________________________________________-->
  <para>
   当使用像 Ident 或者 GSSAPI 之类的外部认证系统时，发起连接的操作系统用户名可能不同于要被使用的数据库用户（角色）。在这种情况下，一个用户名映射可被用来把操作系统用户名映射到数据库用户。要使用用户名映射，在<filename>pg_hba.conf</filename>的选项域指定<literal>map</literal>=<replaceable>map-name</replaceable>。此选项支持所有接收外部用户名的认证方法。由于不同的连接可能需要不同的映射，在<filename>pg_hba.conf</filename>中的<replaceable>map-name</replaceable>参数中指定要被使用的映射名，用以指示哪个映射用于每个个体连接。
  </para>
<!-- pgdoc-cn_end sig_en=48c951e1615715ce56ce03e80dbda028 -->

<!-- pgdoc-cn_start sig_en=b2590a2fb109825c1092d5a923d068d9 sig_cn_org=None source=14.1 
  <para>
   User name maps are defined in the ident map file, which by default is named
   <filename>pg_ident.conf</filename><indexterm><primary>pg_ident.conf</primary></indexterm>
   and is stored in the
   cluster's data directory.  (It is possible to place the map file
   elsewhere, however; see the <xref linkend="guc-ident-file"/>
   configuration parameter.)
   The ident map file contains lines of the general form:
<synopsis>
<replaceable>map-name</replaceable> <replaceable>system-username</replaceable> <replaceable>database-username</replaceable>
</synopsis>
   Comments, whitespace and line continuations are handled in the same way as in
   <filename>pg_hba.conf</filename>.  The
   <replaceable>map-name</replaceable> is an arbitrary name that will be used to
   refer to this mapping in <filename>pg_hba.conf</filename>. The other
   two fields specify an operating system user name and a matching
   database user name. The same <replaceable>map-name</replaceable> can be
   used repeatedly to specify multiple user-mappings within a single map.
  </para>
________________________________________________________-->
  <para>
   用户名映射定义在 ident 映射文件中，默认情况下它被命名为<filename>pg_ident.conf</filename><indexterm><primary>pg_ident.conf</primary></indexterm>并被存储在集簇的数据目录中（不过，可以把该映射文件放在其他地方，见<xref linkend="guc-ident-file"/>配置参数）。ident 映射文件包含的行的一般格式：
<synopsis>
<replaceable>map-name</replaceable> <replaceable>system-username</replaceable> <replaceable>database-username</replaceable>
</synopsis>
   以在<filename>pg_hba.conf</filename>中同样的方式处理注释，空白和行延续。
   <replaceable>map-name</replaceable>是一个任意名称，它将被用于在<filename>pg_hba.conf</filename>中引用该映射。
   其他两个域指定一个操作系统用户名和一个匹配的数据库用户名。
   相同的<replaceable>map-name</replaceable>可以被反复地用在同一个映射中指定多个用户映射。
  </para>
<!-- pgdoc-cn_end sig_en=b2590a2fb109825c1092d5a923d068d9 -->
<!-- pgdoc-cn_start sig_en=049f09cea6205451c3ea1c278a8c1f83 sig_cn_org=None source=14.1 
  <para>
   There is no restriction regarding how many database users a given
   operating system user can correspond to, nor vice versa.  Thus, entries
   in a map should be thought of as meaning <quote>this operating system
   user is allowed to connect as this database user</quote>, rather than
   implying that they are equivalent.  The connection will be allowed if
   there is any map entry that pairs the user name obtained from the
   external authentication system with the database user name that the
   user has requested to connect as.
  </para>
________________________________________________________-->
  <para>
   对于一个给定操作系统用户可以对应多少个数据库用户没有限制，反之亦然。因此，一个映射中的项应该被看成意味着<quote>这个操作系统用户被允许作为这个数据库用户连接</quote>，而不是按时它们等价。如果有任何映射项把从外部认证系统获得的用户名和用户要求的数据库用户名配对，该连接将被允许。
  </para>
<!-- pgdoc-cn_end sig_en=049f09cea6205451c3ea1c278a8c1f83 -->
<!-- pgdoc-cn_start sig_en=d6f56525bade5823c509eace83e83c0f sig_cn_org=None source=14.1 
  <para>
   If the <replaceable>system-username</replaceable> field starts with a slash (<literal>/</literal>),
   the remainder of the field is treated as a regular expression.
   (See <xref linkend="posix-syntax-details"/> for details of
   <productname>PostgreSQL</productname>'s regular expression syntax.)  The regular
   expression can include a single capture, or parenthesized subexpression,
   which can then be referenced in the <replaceable>database-username</replaceable>
   field as <literal>\1</literal> (backslash-one).  This allows the mapping of
   multiple user names in a single line, which is particularly useful for
   simple syntax substitutions.  For example, these entries
<programlisting>
mymap   /^(.*)@mydomain\.com$      \1
mymap   /^(.*)@otherdomain\.com$   guest
</programlisting>
   will remove the domain part for users with system user names that end with
   <literal>@mydomain.com</literal>, and allow any user whose system name ends with
   <literal>@otherdomain.com</literal> to log in as <literal>guest</literal>.
  </para>
________________________________________________________-->
  <para>
   如果<replaceable>system-username</replaceable>域以一个斜线（<literal>/</literal>）开始，域的剩余部分被当做一个正则表达式（<productname>PostgreSQL</productname>的正则表达式语法详见<xref linkend="posix-syntax-details"/>）。正则表达式可以包括一个单一的捕获，或圆括号子表达式，然后它可以在<replaceable>database-username</replaceable>域中以<literal>\1</literal>（反斜线一）被引用。这允许在单个行中多个用户名的映射，这特别有助于简单的语法替换。例如，这些项
<programlisting>
mymap   /^(.*)@mydomain\.com$      \1
mymap   /^(.*)@otherdomain\.com$   guest
</programlisting>
   将为用户移除以<literal>@mydomain.com</literal>结束的系统用户名的域部分，以及允许系统名以<literal>@otherdomain.com</literal>结束的任意用户作为<literal>guest</literal>登入。
  </para>
<!-- pgdoc-cn_end sig_en=d6f56525bade5823c509eace83e83c0f -->

  <tip>
<!-- pgdoc-cn_start sig_en=1d5f5cb1330a4aec7f7b18a01c9e8a3c sig_cn_org=None source=14.1 
   <para>
    Keep in mind that by default, a regular expression can match just part of
    a string.  It's usually wise to use <literal>^</literal> and <literal>$</literal>, as
    shown in the above example, to force the match to be to the entire
    system user name.
   </para>
________________________________________________________-->
   <para>
    记住在默认情况下，一个正则表达式可以只匹配字符串的一部分。如上例所示，使用<literal>^</literal>和<literal>$</literal>来强制匹配整个系统用户名通常是明智的。
   </para>
<!-- pgdoc-cn_end sig_en=1d5f5cb1330a4aec7f7b18a01c9e8a3c -->
  </tip>

<!-- pgdoc-cn_start sig_en=b854953caa2878a642e045b073609ff9 sig_cn_org=None source=14.1 
  <para>
   The <filename>pg_ident.conf</filename> file is read on start-up and
   when the main server process receives a
   <systemitem>SIGHUP</systemitem><indexterm><primary>SIGHUP</primary></indexterm>
   signal. If you edit the file on an
   active system, you will need to signal the postmaster
   (using <literal>pg_ctl reload</literal>, calling the SQL function
   <function>pg_reload_conf()</function>, or using <literal>kill
   -HUP</literal>) to make it re-read the file.
  </para>
________________________________________________________-->
  <para>
   在启动以及主服务器进程收到<systemitem>SIGHUP</systemitem><indexterm><primary>SIGHUP</primary></indexterm>信号时，<filename>pg_ident.conf</filename>文件会被读取。 
   如果你在活动的系统上编辑了该文件，你将需要通知 postmaster（使用<literal>pg_ctl reload</literal>,调用SQL函数<function>pg_reload_conf()</function>, 或用<literal>kill -HUP</literal>）重新读取文件。
  </para>
<!-- pgdoc-cn_end sig_en=b854953caa2878a642e045b073609ff9 -->

<!-- pgdoc-cn_start sig_en=1d7732035137fa0babad5e6ffc2b70de sig_cn_org=384b468070c773f4f8cf18e8f83e53b6 source=15.7 
  <para>
   The system view
   <link linkend="view-pg-ident-file-mappings"><structname>pg_ident_file_mappings</structname></link>
   can be helpful for pre-testing changes to the
   <filename>pg_ident.conf</filename> file, or for diagnosing problems if
   loading of the file did not have the desired effects.  Rows in the view with
   non-null <structfield>error</structfield> fields indicate problems in the
   corresponding lines of the file.
  </para>
________________________________________________________-->
  <para>
   系统视图
   <link linkend="view-pg-ident-file-mappings"><structname>pg_ident_file_mappings</structname></link>
   可以帮助预先测试对<filename>pg_ident.conf</filename>文件的更改，或者在加载文件后未产生预期效果时诊断问题。
   视图中具有非空<structfield>error</structfield>字段的行表示文件相应行中存在问题。
</para>
<!-- pgdoc-cn_end sig_en=1d7732035137fa0babad5e6ffc2b70de -->

<!-- pgdoc-cn_start sig_en=12704ec1f52e3c5720ab0a16024ba2a2 sig_cn_org=None source=14.1 
  <para>
   A <filename>pg_ident.conf</filename> file that could be used in
   conjunction with the <filename>pg_hba.conf</filename> file in <xref
   linkend="example-pg-hba.conf"/> is shown in <xref
   linkend="example-pg-ident.conf"/>. In this example, anyone
   logged in to a machine on the 192.168 network that does not have the
   operating system user name <literal>bryanh</literal>, <literal>ann</literal>, or
   <literal>robert</literal> would not be granted access. Unix user
   <literal>robert</literal> would only be allowed access when he tries to
   connect as <productname>PostgreSQL</productname> user <literal>bob</literal>, not
   as <literal>robert</literal> or anyone else. <literal>ann</literal> would
   only be allowed to connect as <literal>ann</literal>. User
   <literal>bryanh</literal> would be allowed to connect as either
   <literal>bryanh</literal> or as <literal>guest1</literal>.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="example-pg-ident.conf"/>中展示了一个可以联合<filename>pg_hba.conf</filename>文件（<xref linkend="example-pg-hba.conf"/>）使用的<filename>pg_ident.conf</filename>文件。在这个例子中，对于任何登入到 192.168 网络上的一台机器的用户， 如果该用户没有操作系统用户名<literal>bryanh</literal>、<literal>ann</literal>或<literal>robert</literal>，则他不会被授予访问权限。只有当 Unix 用户<literal>robert</literal>尝试作为<productname>PostgreSQL</productname>用户<literal>bob</literal>（而不是作为<literal>robert</literal>或其他人）连接时，他才被允许访问。<literal>ann</literal>只被允许作为<literal>ann</literal>连接。用户<literal>bryanh</literal>被允许以<literal>bryanh</literal>或者<literal>guest1</literal>连接。
  </para>
<!-- pgdoc-cn_end sig_en=12704ec1f52e3c5720ab0a16024ba2a2 -->

  <example id="example-pg-ident.conf">
<!-- pgdoc-cn_start sig_en=79980671cf6e7a38a613636764894f97 sig_cn_org=None source=14.1 
   <title>An Example <filename>pg_ident.conf</filename> File</title>
________________________________________________________-->
   <title>一个示例 <filename>pg_ident.conf</filename> 文件</title>
<!-- pgdoc-cn_end sig_en=79980671cf6e7a38a613636764894f97 -->
<!-- pgdoc-cn_start sig_en=dabe02b3f99c37ef340053dc11fbedbd sig_cn_org=None source=14.1 
<programlisting>
# MAPNAME       SYSTEM-USERNAME         PG-USERNAME

omicron         bryanh                  bryanh
omicron         ann                     ann
# bob has user name robert on these machines
omicron         robert                  bob
# bryanh can also connect as guest1
omicron         bryanh                  guest1
</programlisting>
________________________________________________________-->
<programlisting>
# MAPNAME       SYSTEM-USERNAME         PG-USERNAME

omicron         bryanh                  bryanh
omicron         ann                     ann
# bob 在这些机器上有用户名 robert
omicron         robert                  bob
# bryanh 也可以作为 guest1 连接
omicron         bryanh                  guest1
</programlisting>
<!-- pgdoc-cn_end sig_en=dabe02b3f99c37ef340053dc11fbedbd -->
  </example>
 </sect1>

 <sect1 id="auth-methods">
<!-- pgdoc-cn_start sig_en=9e99e536bbe04fe92bf78faadf51757c sig_cn_org=None source=14.1 
  <title>Authentication Methods</title>
________________________________________________________-->
  <title>认证方法</title>
<!-- pgdoc-cn_end sig_en=9e99e536bbe04fe92bf78faadf51757c -->

<!-- pgdoc-cn_start sig_en=7eb14945c604bbf446f5022388c5d79a sig_cn_org=d859ac8c77d6b8cefc7f39f1bcfa0b72 source=15.7 
  <para>
   <productname>PostgreSQL</productname> provides various methods for
   authenticating users:

   <itemizedlist>
    <listitem>
     <para>
      <link linkend="auth-trust">Trust authentication</link>, which
      simply trusts that users are who they say they are.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-password">Password authentication</link>, which
      requires that users send a password.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="gssapi-auth">GSSAPI authentication</link>, which
      relies on a GSSAPI-compatible security library.  Typically this is
      used to access an authentication server such as a Kerberos or
      Microsoft Active Directory server.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="sspi-auth">SSPI authentication</link>, which
      uses a Windows-specific protocol similar to GSSAPI.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-ident">Ident authentication</link>, which
      relies on an <quote>Identification Protocol</quote>
      (<ulink url="https://datatracker.ietf.org/doc/html/rfc1413">RFC 1413</ulink>)
      service on the client's machine.  (On local Unix-socket connections,
      this is treated as peer authentication.)
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-peer">Peer authentication</link>, which
      relies on operating system facilities to identify the process at the
      other end of a local connection.  This is not supported for remote
      connections.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-ldap">LDAP authentication</link>, which
      relies on an LDAP authentication server.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-radius">RADIUS authentication</link>, which
      relies on a RADIUS authentication server.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-cert">Certificate authentication</link>, which
      requires an SSL connection and authenticates users by checking the
      SSL certificate they send.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-pam">PAM authentication</link>, which
      relies on a PAM (Pluggable Authentication Modules) library.
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-bsd">BSD authentication</link>, which
      relies on the BSD Authentication framework (currently available
      only on OpenBSD).
     </para>
    </listitem>
   </itemizedlist>
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>提供了各种认证用户的方法：

   <itemizedlist>
    <listitem>
     <para>
      <link linkend="auth-trust">信任认证</link>，简单地相信用户是他们声称的那样。
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-password">密码认证</link>，需要用户发送密码。
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="gssapi-auth">GSSAPI认证</link>，依赖于一个兼容GSSAPI的安全库。
      通常用于访问认证服务器，如Kerberos或Microsoft Active Directory服务器。
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="sspi-auth">SSPI认证</link>，使用类似于GSSAPI的Windows特定协议。
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-ident">Ident认证</link>，依赖于客户端机器上的一个
      <quote>Identification Protocol</quote>
      (<ulink url="https://datatracker.ietf.org/doc/html/rfc1413">RFC 1413</ulink>)
      服务。（在本地Unix套接字连接中，这被视为对等认证。）
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-peer">对等认证</link>，依赖于操作系统设施来识别本地连接另一端的进程。
      不支持远程连接。
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-ldap">LDAP认证</link>，依赖于LDAP认证服务器。
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-radius">RADIUS认证</link>，依赖于RADIUS认证服务器。
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-cert">证书认证</link>，需要SSL连接，并通过检查用户发送的SSL证书来认证用户。
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-pam">PAM认证</link>，依赖于PAM（可插拔认证模块）库。
     </para>
    </listitem>
    <listitem>
     <para>
      <link linkend="auth-bsd">BSD认证</link>，依赖于BSD认证框架（目前仅在OpenBSD上可用）。
     </para>
    </listitem>
   </itemizedlist>
  </para>
<!-- pgdoc-cn_end sig_en=7eb14945c604bbf446f5022388c5d79a -->

<!-- pgdoc-cn_start sig_en=85bd7ea59c385e0dc2d15727ace280a9 sig_cn_org=None source=14.1 
  <para>
   Peer authentication is usually recommendable for local connections,
   though trust authentication might be sufficient in some circumstances.
   Password authentication is the easiest choice for remote connections.
   All the other options require some kind of external security
   infrastructure (usually an authentication server or a certificate
   authority for issuing SSL certificates), or are platform-specific.
  </para>
________________________________________________________-->
  <para>
   对等身份验证通常适用于本地连接,信任认证在某些情况下也许是比较适合的。
   密码认证是远程连接的常见选择。
   所有其它的选项都需要某种外部安全基础架构(通常是认证服务器或颁发 SSL 证书的证书颁发机构。)，或用于某些特定平台。
  </para>
<!-- pgdoc-cn_end sig_en=85bd7ea59c385e0dc2d15727ace280a9 -->

<!-- pgdoc-cn_start sig_en=d54b9901be768ee3ef2a22d65dfc9042 sig_cn_org=None source=14.1 
  <para>
   The following sections describe each of these authentication methods
   in more detail.
  </para>
________________________________________________________-->
  <para>
   以下各节将更详细地介绍这些身份认证方法。
  </para>
<!-- pgdoc-cn_end sig_en=d54b9901be768ee3ef2a22d65dfc9042 -->
 </sect1>

  <sect1 id="auth-trust">
<!-- pgdoc-cn_start sig_en=e763893f68ddc00c09ddc530469e9761 sig_cn_org=None source=14.1 
   <title>Trust Authentication</title>
________________________________________________________-->
   <title>信任认证</title>
<!-- pgdoc-cn_end sig_en=e763893f68ddc00c09ddc530469e9761 -->

<!-- pgdoc-cn_start sig_en=b915a3a5e943b379250374af3a31f1e6 sig_cn_org=None source=14.1 
   <para>
    When <literal>trust</literal> authentication is specified,
    <productname>PostgreSQL</productname> assumes that anyone who can
    connect to the server is authorized to access the database with
    whatever database user name they specify (even superuser names).
    Of course, restrictions made in the <literal>database</literal> and
    <literal>user</literal> columns still apply.
    This method should only be used when there is adequate
    operating-system-level protection on connections to the server.
   </para>
________________________________________________________-->
   <para>
    当<literal>trust</literal>认证被指定时，<productname>PostgreSQL</productname>假设任何可以连接到服务器的人都被授权使用他们指定的任何数据库用户名（即使是超级用户）访问数据库。当然，在<literal>database</literal>和 <literal>user</literal>列中设置的限制仍然适用。只有当在操作系统层对进入服务器的连接有足够保护时，才应该使用这种方法。
   </para>
<!-- pgdoc-cn_end sig_en=b915a3a5e943b379250374af3a31f1e6 -->

<!-- pgdoc-cn_start sig_en=6920863781d274b9e57d30e9f159a763 sig_cn_org=None source=14.1 
   <para>
    <literal>trust</literal> authentication is appropriate and very
    convenient for local connections on a single-user workstation.  It
    is usually <emphasis>not</emphasis> appropriate by itself on a multiuser
    machine.  However, you might be able to use <literal>trust</literal> even
    on a multiuser machine, if you restrict access to the server's
    Unix-domain socket file using file-system permissions.  To do this, set the
    <varname>unix_socket_permissions</varname> (and possibly
    <varname>unix_socket_group</varname>) configuration parameters as
    described in <xref linkend="runtime-config-connection"/>.  Or you
    could set the <varname>unix_socket_directories</varname>
    configuration parameter to place the socket file in a suitably
    restricted directory.
   </para>
________________________________________________________-->
   <para>
    <literal>trust</literal>认证对于单用户工作站的本地连接是非常合适和方便的。通常它本身<emphasis>不</emphasis>适用于一台多用户机器。不过，只要你利用文件系统权限限制了对服务器的 Unix 域套接字文件的访问，即使在多用户机器上，你也可以使用<literal>trust</literal>。 要做这些限制，你可以设置<xref linkend="runtime-config-connection"/>中描述的<varname>unix_socket_permissions</varname>配置参数（可能还有<varname>unix_socket_group</varname>）。 或者你可以设置<varname>unix_socket_directories</varname>配置参数来把 Unix 域套接字文件放在一个经过恰当限制的目录中。
   </para>
<!-- pgdoc-cn_end sig_en=6920863781d274b9e57d30e9f159a763 -->

<!-- pgdoc-cn_start sig_en=4bb79668a48ce603b5eccee72f768a2a sig_cn_org=None source=14.1 
   <para>
    Setting file-system permissions only helps for Unix-socket connections.
    Local TCP/IP connections are not restricted by file-system permissions.
    Therefore, if you want to use file-system permissions for local security,
    remove the <literal>host ... 127.0.0.1 ...</literal> line from
    <filename>pg_hba.conf</filename>, or change it to a
    non-<literal>trust</literal> authentication method.
   </para>
________________________________________________________-->
   <para>
    设置文件系统权限只能有助于 Unix 套接字连接。本地 TCP/IP 连接不会被文件系统权限限制。因此，如果你想利用文件系统权限来控制本地安全，那么从<filename>pg_hba.conf</filename>中移除<literal>host ... 127.0.0.1 ...</literal>行，或者把它改为一个非<literal>trust</literal>认证方法。
   </para>
<!-- pgdoc-cn_end sig_en=4bb79668a48ce603b5eccee72f768a2a -->

<!-- pgdoc-cn_start sig_en=75c7ab0688bf44d6388b67548b5da950 sig_cn_org=None source=14.1 
   <para>
    <literal>trust</literal> authentication is only suitable for TCP/IP connections
    if you trust every user on every machine that is allowed to connect
    to the server by the <filename>pg_hba.conf</filename> lines that specify
    <literal>trust</literal>.  It is seldom reasonable to use <literal>trust</literal>
    for any TCP/IP connections other than those from <systemitem>localhost</systemitem> (127.0.0.1).
   </para>
________________________________________________________-->
   <para>
    如果通过指定<literal>trust</literal>的<filename>pg_hba.conf</filename>行让你信任每一个被允许连接到服务器的机器上的用户，<literal>trust</literal>认证只适合 TCP/IP 连接。为任何不是来自<systemitem>localhost</systemitem>（127.0.0.1）的 TCP/IP 连接使用<literal>trust</literal>很少是合理的。
   </para>
<!-- pgdoc-cn_end sig_en=75c7ab0688bf44d6388b67548b5da950 -->

  </sect1>

  <sect1 id="auth-password">
<!-- pgdoc-cn_start sig_en=49d7c08f33a98f41fffb30c68fbc3af7 sig_cn_org=None source=14.1 
   <title>Password Authentication</title>
________________________________________________________-->
   <title>口令认证</title>
<!-- pgdoc-cn_end sig_en=49d7c08f33a98f41fffb30c68fbc3af7 -->

<!-- pgdoc-cn_start sig_en=884565b0e995dc75fca0c9e6c63707f9 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>MD5</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>MD5</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=884565b0e995dc75fca0c9e6c63707f9 -->
<!-- pgdoc-cn_start sig_en=ba2e5b306139da742046ae6099efac0f sig_cn_org=None source=14.1 
   <indexterm>
    <primary>SCRAM</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>SCRAM</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=ba2e5b306139da742046ae6099efac0f -->
<!-- pgdoc-cn_start sig_en=6339afade8d290e1939c83e5659d493e sig_cn_org=None source=14.1 
   <indexterm>
    <primary>password</primary>
    <secondary>authentication</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>口令</primary>
    <secondary>认证</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=6339afade8d290e1939c83e5659d493e -->

<!-- pgdoc-cn_start sig_en=7d5e7cde6e034e7fa2b457022d07c066 sig_cn_org=None source=14.1 
   <para>
    There are several password-based authentication methods.  These methods
    operate similarly but differ in how the users' passwords are stored on the
    server and how the password provided by a client is sent across the
    connection.
   </para>
________________________________________________________-->
   <para>
    有几种基于口令的认证方法。这些方法的过程类似，但是区别在于用户口令如何被存放在服务器上以及客户端提供的口令如何被通过连接发送。
   </para>
<!-- pgdoc-cn_end sig_en=7d5e7cde6e034e7fa2b457022d07c066 -->

   <variablelist>
    <varlistentry>
     <term><literal>scram-sha-256</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=4c1256abb1917d9eca4963483658e9c2 sig_cn_org=ef6ea470a639a0b58b67c2a471ad5510 source=15.7 
      <para>
       The method <literal>scram-sha-256</literal> performs SCRAM-SHA-256
       authentication, as described in
       <ulink url="https://datatracker.ietf.org/doc/html/rfc7677">RFC 7677</ulink>.  It
       is a challenge-response scheme that prevents password sniffing on
       untrusted connections and supports storing passwords on the server in a
       cryptographically hashed form that is thought to be secure.
      </para>
________________________________________________________-->
      <para>
       方法<literal>scram-sha-256</literal>执行SCRAM-SHA-256身份验证，如
       在<ulink url="https://datatracker.ietf.org/doc/html/rfc7677">RFC 7677</ulink>中描述的那样。它
       是一种挑战-响应方案，可防止在不受信任的连接上嗅探密码，并支持在服务器上以
       密码学哈希形式存储密码，被认为是安全的。
      </para>
<!-- pgdoc-cn_end sig_en=4c1256abb1917d9eca4963483658e9c2 -->

<!-- pgdoc-cn_start sig_en=a607a51b2aede63c85d7d5632534524e sig_cn_org=None source=14.1 
      <para>
       This is the most secure of the currently provided methods, but it is
       not supported by older client libraries.
      </para>
________________________________________________________-->
      <para>
       这是当前提供的方法中最安全的一种，但是旧的客户端库不支持这种方法。
      </para>
<!-- pgdoc-cn_end sig_en=a607a51b2aede63c85d7d5632534524e -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>md5</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=db6d39b50111eee3dbc40166210c1031 sig_cn_org=None source=14.1 
      <para>
       The method <literal>md5</literal> uses a custom less secure challenge-response
       mechanism.  It prevents password sniffing and avoids storing passwords
       on the server in plain text but provides no protection if an attacker
       manages to steal the password hash from the server.  Also, the MD5 hash
       algorithm is nowadays no longer considered secure against determined
       attacks.
      </para>
________________________________________________________-->
      <para>
       方法<literal>md5</literal>使用一种自定义的安全性较低的挑战-响应机制。它能防止口令嗅探并且防止口令在服务器上以明文存储，但是无法保护攻击者想办法从服务器上窃取了口令哈希的情况。此外，现在认为MD5哈希算法对于确定攻击已经不再安全。
      </para>
<!-- pgdoc-cn_end sig_en=db6d39b50111eee3dbc40166210c1031 -->

<!-- pgdoc-cn_start sig_en=e713ada97781c417ded8a6003a860117 sig_cn_org=None source=14.1 
      <para>
       The <literal>md5</literal> method cannot be used with
       the <xref linkend="guc-db-user-namespace"/> feature.
      </para>
________________________________________________________-->
      <para>
       <literal>md5</literal>方法不能与<xref linkend="guc-db-user-namespace"/>特性一起使用。
      </para>
<!-- pgdoc-cn_end sig_en=e713ada97781c417ded8a6003a860117 -->

<!-- pgdoc-cn_start sig_en=f22bcc1803373552ce17f127cf4d44ef sig_cn_org=None source=14.1 
      <para>
       To ease transition from the <literal>md5</literal> method to the newer
       SCRAM method, if <literal>md5</literal> is specified as a method
       in <filename>pg_hba.conf</filename> but the user's password on the
       server is encrypted for SCRAM (see below), then SCRAM-based
       authentication will automatically be chosen instead.
      </para>
________________________________________________________-->
      <para>
       为了简化从<literal>md5</literal>方法到较新的SCRAM方法的转变，如果在<filename>pg_hba.conf</filename>中指定了<literal>md5</literal>但是用户在服务器上的口令是为SCRAM（见下文）加密的，则将自动选择基于SCRAM的认证。
      </para>
<!-- pgdoc-cn_end sig_en=f22bcc1803373552ce17f127cf4d44ef -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>password</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=c28f1fd9dffd6f5a76bf9f63e2c3a4ea sig_cn_org=None source=14.1 
      <para>
       The method <literal>password</literal> sends the password in clear-text and is
       therefore vulnerable to password <quote>sniffing</quote> attacks. It should
       always be avoided if possible. If the connection is protected by SSL
       encryption then <literal>password</literal> can be used safely, though.
       (Though SSL certificate authentication might be a better choice if one
       is depending on using SSL).
      </para>
________________________________________________________-->
      <para>
       方法<literal>password</literal>以明文形式发送口令，因此它对于口令<quote>嗅探</quote>攻击很脆弱。如果可能应该尽量避免使用它。不过，如果连接被SSL加密保护着，那么可以安全地使用<literal>password</literal>（不过如果依靠SSL，SSL证书认证可能是更好的选择）。
      </para>
<!-- pgdoc-cn_end sig_en=c28f1fd9dffd6f5a76bf9f63e2c3a4ea -->
     </listitem>
    </varlistentry>
   </variablelist>

<!-- pgdoc-cn_start sig_en=c9cd95264bb9cb145a44c427058a1c13 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> database passwords are
    separate from operating system user passwords. The password for
    each database user is stored in the <literal>pg_authid</literal> system
    catalog. Passwords can be managed with the SQL commands
    <xref linkend="sql-createrole"/> and
    <xref linkend="sql-alterrole"/>,
    e.g., <userinput>CREATE ROLE foo WITH LOGIN PASSWORD 'secret'</userinput>,
    or the <application>psql</application>
    command <literal>\password</literal>.
    If no password has been set up for a user, the stored password
    is null and password authentication will always fail for that user.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>数据库口令独立于操作系统用户口令。每个数据库用户的口令被存储在<literal>pg_authid</literal>系统目录中。口令可以用 SQL 命令<xref linkend="sql-createuser"/>和<xref linkend="sql-alterrole"/>管理，例如<userinput>CREATE ROLE foo WITH LOGIN PASSWORD 'secret'</userinput>或者<application>psql</application>的<literal>\password</literal>命令。如果没有为一个用户设置口令，那么存储的口令为空并且对该用户的口令认证总会失败。
   </para>
<!-- pgdoc-cn_end sig_en=c9cd95264bb9cb145a44c427058a1c13 -->

<!-- pgdoc-cn_start sig_en=f44c9f2dda7882dc5c58ecd29d039056 sig_cn_org=None source=14.1 
   <para>
    The availability of the different password-based authentication methods
    depends on how a user's password on the server is encrypted (or hashed,
    more accurately).  This is controlled by the configuration
    parameter <xref linkend="guc-password-encryption"/> at the time the
    password is set.  If a password was encrypted using
    the <literal>scram-sha-256</literal> setting, then it can be used for the
    authentication methods <literal>scram-sha-256</literal>
    and <literal>password</literal> (but password transmission will be in
    plain text in the latter case).  The authentication method
    specification <literal>md5</literal> will automatically switch to using
    the <literal>scram-sha-256</literal> method in this case, as explained
    above, so it will also work.  If a password was encrypted using
    the <literal>md5</literal> setting, then it can be used only for
    the <literal>md5</literal> and <literal>password</literal> authentication
    method specifications (again, with the password transmitted in plain text
    in the latter case).  (Previous PostgreSQL releases supported storing the
    password on the server in plain text.  This is no longer possible.)  To
    check the currently stored password hashes, see the system
    catalog <literal>pg_authid</literal>.
   </para>
________________________________________________________-->
   <para>
    不同的基于口令的认证方法的可用性取决于用户的口令在服务器上是如何被加密（或者更准确地说是哈希）的。这由设置口令时的配置参数<xref linkend="guc-password-encryption"/>控制。如果口令使用<literal>scram-sha-256</literal>设置加密，那么它可以被用于认证方法<literal>scram-sha-256</literal>和<literal>password</literal>（但后一种情况中口令将以明文传输）。如上所释，在这种情况下，指定的认证方法<literal>md5</literal>将自动切换到使用<literal>scram-sha-256</literal>方法。如果口令使用<literal>md5</literal>设置加密，那么它仅能用于<literal>md5</literal>和<literal>password</literal>认证方法说明（同样，后一种情况中口令以明文传输）。（之前的PostgreSQL发行版支持在服务器上存储明文口令。现在已经不可能了）。要检查当前存储的口令哈希，可以参考系统目录<literal>pg_authid</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=f44c9f2dda7882dc5c58ecd29d039056 -->

<!-- pgdoc-cn_start sig_en=fcb1d61aec7a6503a3e4f2059769953d sig_cn_org=None source=14.1 
   <para>
    To upgrade an existing installation from <literal>md5</literal>
    to <literal>scram-sha-256</literal>, after having ensured that all client
    libraries in use are new enough to support SCRAM,
    set <literal>password_encryption = 'scram-sha-256'</literal>
    in <filename>postgresql.conf</filename>, make all users set new passwords,
    and change the authentication method specifications
    in <filename>pg_hba.conf</filename> to <literal>scram-sha-256</literal>.
   </para>
________________________________________________________-->
   <para>
    要把现有的安装从<literal>md5</literal>升级到<literal>scram-sha-256</literal>，可以在确保所有在用的客户端已经足以支持SCRAM之后，在<filename>postgresql.conf</filename>中设置<literal>password_encryption = 'scram-sha-256'</literal>，然后让所有用户设置新口令并且在<filename>pg_hba.conf</filename>中将认证方法说明改为<literal>scram-sha-256</literal>.
   </para>
<!-- pgdoc-cn_end sig_en=fcb1d61aec7a6503a3e4f2059769953d -->
  </sect1>

  <sect1 id="gssapi-auth">
<!-- pgdoc-cn_start sig_en=19e0b9799f164877a563e7a6fcb42308 sig_cn_org=None source=14.1 
   <title>GSSAPI Authentication</title>
________________________________________________________-->
   <title>GSSAPI 认证</title>
<!-- pgdoc-cn_end sig_en=19e0b9799f164877a563e7a6fcb42308 -->

<!-- pgdoc-cn_start sig_en=10e0ac416b90d929d45ad61dfeb6b05b sig_cn_org=None source=14.1 
   <indexterm zone="gssapi-auth">
    <primary>GSSAPI</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="gssapi-auth">
    <primary>GSSAPI</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=10e0ac416b90d929d45ad61dfeb6b05b -->

<!-- pgdoc-cn_start sig_en=1f81b0ee2866230ac24857157f966a9f sig_cn_org=0acd9dd76cc5a3f8ddf3db0c07bd0635 source=15.7 
   <para>
    <productname>GSSAPI</productname> is an industry-standard protocol
    for secure authentication defined in
    <ulink url="https://datatracker.ietf.org/doc/html/rfc2743">RFC 2743</ulink>.
    <productname>PostgreSQL</productname>
    supports <productname>GSSAPI</productname> for authentication,
    communications encryption, or both.
    <productname>GSSAPI</productname> provides automatic authentication
    (single sign-on) for systems that support it. The authentication itself is
    secure.  If <productname>GSSAPI</productname> encryption
    or <acronym>SSL</acronym> encryption is
    used, the data sent along the database connection will be encrypted;
    otherwise, it will not.
   </para>
________________________________________________________-->
   <para>
    <productname>GSSAPI</productname>是一种在
    <ulink url="https://datatracker.ietf.org/doc/html/rfc2743">RFC 2743</ulink>
    中定义的安全认证行业标准协议。
    <productname>PostgreSQL</productname>支持<productname>GSSAPI</productname>用于认证、
    通信加密，或两者兼而有之。
    <productname>GSSAPI</productname>为支持它的系统提供自动认证（单点登录）。
    认证本身是安全的。如果使用<productname>GSSAPI</productname>加密
    或<acronym>SSL</acronym>加密，沿数据库连接发送的数据将被加密；
    否则，将不会被加密。
</para>
<!-- pgdoc-cn_end sig_en=1f81b0ee2866230ac24857157f966a9f -->

<!-- pgdoc-cn_start sig_en=e90551d4bff6fee80196d2b82194cbba sig_cn_org=None source=14.1 
   <para>
    GSSAPI support has to be enabled when <productname>PostgreSQL</productname> is built;
    see <xref linkend="installation"/> for more information.
   </para>
________________________________________________________-->
   <para>
    当编译<productname>PostgreSQL</productname>时，GSSAPI 支持必须被启用，详见<xref linkend="installation"/>。
   </para>
<!-- pgdoc-cn_end sig_en=e90551d4bff6fee80196d2b82194cbba -->

<!-- pgdoc-cn_start sig_en=5f757489c8002c4ece68a14fd7cf06f7 sig_cn_org=None source=14.1 
   <para>
    When <productname>GSSAPI</productname> uses
    <productname>Kerberos</productname>, it uses a standard service
    principal (authentication identity) name in the format
    <literal><replaceable>servicename</replaceable>/<replaceable>hostname</replaceable>@<replaceable>realm</replaceable></literal>.
    The principal name used by a particular installation is not encoded in
    the <productname>PostgreSQL</productname> server in any way; rather it
    is specified in the <firstterm>keytab</firstterm> file that the server
    reads to determine its identity.  If multiple principals are listed in
    the keytab file, the server will accept any one of them.
    The server's realm name is the preferred realm specified in the Kerberos
    configuration file(s) accessible to the server.
   </para>
________________________________________________________-->
   <para>
    当<productname>GSSAPI</productname> 使用<productname>Kerberos</productname>的时候， 它使用一个标准服务主体(身份验证)名称，以<literal><replaceable>servicename</replaceable>/<replaceable>hostname</replaceable>@<replaceable>realm</replaceable></literal>的格式。
    特定安装使用的主体名称(principal name)没有被以任何方式编码在<productname>PostgreSQL</productname>服务器中；而是被指定在<firstterm>keytab</firstterm>文件中，服务器读取该文件以决定它的身份。
    如果在keytab文件中罗列着多个主体，服务器将接受其中任何一个。
    服务器的领域名称(realm name)是在服务器可访问的Kerberos配置文件中指定的优先领域。
   </para>
<!-- pgdoc-cn_end sig_en=5f757489c8002c4ece68a14fd7cf06f7 -->

<!-- pgdoc-cn_start sig_en=ba4e99ad2eab4b2548d22ed86017af8a sig_cn_org=None source=14.1 
   <para>
    When connecting, the client must know the principal name of the server
    it intends to connect to.  The <replaceable>servicename</replaceable>
    part of the principal is ordinarily <literal>postgres</literal>,
    but another value can be selected via <application>libpq</application>'s
    <xref linkend="libpq-connect-krbsrvname"/> connection parameter.
    The <replaceable>hostname</replaceable> part is the fully qualified
    host name that <application>libpq</application> is told to connect to.
    The realm name is the preferred realm specified in the Kerberos
    configuration file(s) accessible to the client.
   </para>
________________________________________________________-->
   <para>
    当连接时，客户端必须知道它打算连接的服务器的主体名称。
    主体名称的<replaceable>servicename</replaceable>部分通常是<literal>postgres</literal>，但是其他值可以通过<application>libpq</application>的<xref linkend="libpq-connect-krbsrvname"/>连接参数来选择。
    <replaceable>hostname</replaceable>部分是<application>libpq</application>告知要连接的全限制的主机名称。
    领域名称是在客户端可访问的Kerberos配置文件中指定的优先领域。
   </para>
<!-- pgdoc-cn_end sig_en=ba4e99ad2eab4b2548d22ed86017af8a -->

<!-- pgdoc-cn_start sig_en=ab6d59d9f6a422a2056e33f99c4054f6 sig_cn_org=None source=14.1 
   <para>
    The client will also have a principal name for its own identity
    (and it must have a valid ticket for this principal).  To
    use <productname>GSSAPI</productname> for authentication, the client
    principal must be associated with
    a <productname>PostgreSQL</productname> database user name.
    The <filename>pg_ident.conf</filename> configuration file can be used
    to map principals to user names; for example,
    <literal>pgusername@realm</literal> could be mapped to just <literal>pgusername</literal>.
    Alternatively, you can use the full <literal>username@realm</literal> principal as
    the role name in <productname>PostgreSQL</productname> without any mapping.
   </para>
________________________________________________________-->
   <para>
    客户端也可以有主体名称作为它自己的身份(并且它必须拥有针对这个主体的有效的标签[ticket])。
    要使用<productname>GSSAPI</productname>做身份验证，客户端的主体必须与<productname>PostgreSQL</productname>数据库用户名关联。
    <filename>pg_ident.conf</filename>配置文件可以用于映射主体到用户名；例如，<literal>pgusername@realm</literal>可能会被映射到<literal>pgusername</literal>。
    或者，你可以使用完整的<literal>username@realm</literal>当事人作为<productname>PostgreSQL</productname>中的角色而无需任何映射。
   </para>
<!-- pgdoc-cn_end sig_en=ab6d59d9f6a422a2056e33f99c4054f6 -->

<!-- pgdoc-cn_start sig_en=16f1928349edf7d76ccdb728f47826be sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> also supports mapping
    client principals to user names by just stripping the realm from
    the principal.  This method is supported for backwards compatibility and is
    strongly discouraged as it is then impossible to distinguish different users
    with the same user name but coming from different realms.  To enable this,
    set <literal>include_realm</literal> to 0.  For simple single-realm
    installations, doing that combined with setting the
    <literal>krb_realm</literal> parameter (which checks that the principal's realm
    matches exactly what is in the <literal>krb_realm</literal> parameter)
    is still secure; but this is a
    less capable approach compared to specifying an explicit mapping in
    <filename>pg_ident.conf</filename>.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>也支持映射客户端主体到用户名，通过从主体中剥离领域(realm)的方式。
    这种方法是为了向后兼容性，并且我们强烈反对使用它，因为这样就无法区分具有相同用户名却来自不同 realm 的不同用户了。
    要启用这种方法，可将<literal>include_realm</literal>设置为 0。
    对于简单的单 realm 安装，这样做并且设置<literal>krb_realm</literal>参数（这会检查 principal 的 realm 是否正好匹配<literal>krb_realm</literal>中的参数）仍然是安全的。
    但比起在<filename>pg_ident.conf</filename>中指定一个显式映射来说，这种方法的能力较低。
   </para>
<!-- pgdoc-cn_end sig_en=16f1928349edf7d76ccdb728f47826be -->

<!-- pgdoc-cn_start sig_en=d99a6fc954cd3304adc0eae8048fa264 sig_cn_org=None source=14.1 
   <para>
    The location of the server's keytab file is specified by the <xref
    linkend="guc-krb-server-keyfile"/> configuration parameter.
    For security reasons, it is recommended to use a separate keytab
    just for the <productname>PostgreSQL</productname> server rather
    than allowing the server to read the system keytab file.
    Make sure that your server keytab file is readable (and preferably
    only readable, not writable) by the <productname>PostgreSQL</productname>
    server account.  (See also <xref linkend="postgres-user"/>.)
   </para>
________________________________________________________-->
   <para>
    服务器的keytab文件的位置是由<xref linkend="guc-krb-server-keyfile"/>配置参数指定的。
    出于安全原因，它建议针对<productname>PostgreSQL</productname>使用独立的keytab而不是允许服务器读取系统的keytab文件。
    确保你的服务器的keytab文件是对<productname>PostgreSQL</productname>服务器账号可读的(并且最好是只读的，不可写)
    (参见<xref linkend="postgres-user"/>。)
   </para>
<!-- pgdoc-cn_end sig_en=d99a6fc954cd3304adc0eae8048fa264 -->

<!-- pgdoc-cn_start sig_en=c61319bb172270d77cc7484dd9903da8 sig_cn_org=None source=14.1 
   <para>
    The keytab file is generated using the Kerberos software; see the
    Kerberos documentation for details. The following example shows
    doing this using the <application>kadmin</application> tool of
    MIT-compatible Kerberos 5 implementations:
<screen>
<prompt>kadmin% </prompt><userinput>addprinc -randkey postgres/server.my.domain.org</userinput>
<prompt>kadmin% </prompt><userinput>ktadd -k krb5.keytab postgres/server.my.domain.org</userinput>
</screen>
   </para>
________________________________________________________-->
   <para>
    keytab 文件用 Kerberos 软件生成；详见 Kerberos 文档。
    下面展示了用 MIT 兼容的 Kerberos 5 实现的<application>kadmin</application>来做这个的例子：
<screen>
<prompt>kadmin% </prompt><userinput>addprinc -randkey postgres/server.my.domain.org</userinput>
<prompt>kadmin% </prompt><userinput>ktadd -k krb5.keytab postgres/server.my.domain.org</userinput>
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=c61319bb172270d77cc7484dd9903da8 -->

<!-- pgdoc-cn_start sig_en=eafcae9ca9b08fc80011a449e67fa900 sig_cn_org=None source=14.1 
   <para>
    The following authentication options are supported for
    the <productname>GSSAPI</productname> authentication method:
    <variablelist>
     <varlistentry>
      <term><literal>include_realm</literal></term>
      <listitem>
       <para>
        If set to 0, the realm name from the authenticated user principal is
        stripped off before being passed through the user name mapping
        (<xref linkend="auth-username-maps"/>). This is discouraged and is
        primarily available for backwards compatibility, as it is not secure
        in multi-realm environments unless <literal>krb_realm</literal> is
        also used.  It is recommended to
        leave <literal>include_realm</literal> set to the default (1) and to
        provide an explicit mapping in <filename>pg_ident.conf</filename> to convert
        principal names to <productname>PostgreSQL</productname> user names.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        Allows mapping from client principals to database user names. See
        <xref linkend="auth-username-maps"/> for details.  For a GSSAPI/Kerberos
        principal, such as <literal>username@EXAMPLE.COM</literal> (or, less
        commonly, <literal>username/hostbased@EXAMPLE.COM</literal>), the
        user name used for mapping is
        <literal>username@EXAMPLE.COM</literal> (or
        <literal>username/hostbased@EXAMPLE.COM</literal>, respectively),
        unless <literal>include_realm</literal> has been set to 0, in which case
        <literal>username</literal> (or <literal>username/hostbased</literal>)
        is what is seen as the system user name when mapping.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>krb_realm</literal></term>
      <listitem>
       <para>
        Sets the realm to match user principal names against. If this parameter
        is set, only users of that realm will be accepted.  If it is not set,
        users of any realm can connect, subject to whatever user name mapping
        is done.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    <productname>GSSAPI</productname>验证方法支持下列身份验证选项:
    <variablelist>
     <varlistentry>
      <term><literal>include_realm</literal></term>
      <listitem>
       <para>
        如果设置为 0，在通过用户名映射之前（<xref linkend="auth-username-maps"/>），来自已认证用户 principal 的 realm 名称会被剥离掉。
        我们不鼓励这样做，这种方法主要是为了向后兼容性而存在的，因为它在多 realm 环境中是不安全的（除非也使用 <literal>krb_realm</literal>）。
        推荐用户让<literal>include_realm</literal>设置为默认值（1）并且在<filename>pg_ident.conf</filename>中提供一条显式的映射来把 principal 名称转换成<productname>PostgreSQL</productname>用户名。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        允许从客户端主体到数据库用户名之间的映射。
        详见<xref linkend="auth-username-maps"/>。
        对于一个 GSSAPI/Kerberos 原则，例如<literal>username@EXAMPLE.COM</literal>（或者更不常见的<literal>username/hostbased@EXAMPLE.COM</literal>），用于映射的用户名会是<literal>username@EXAMPLE.COM</literal>（或者 <literal>username/hostbased@EXAMPLE.COM</literal>，相应地），除非 <literal>include_realm</literal>已经被设置为 0，在那种情况下 <literal>username</literal>（或者<literal>username/hostbased</literal>）是映射时被视作系统用户名的东西。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>krb_realm</literal></term>
      <listitem>
       <para>
        Sets the realm to match user principal names against. If this parameter
        is set, only users of that realm will be accepted.  If it is not set,
        users of any realm can connect, subject to whatever user name mapping
        is done.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=eafcae9ca9b08fc80011a449e67fa900 -->

<!-- pgdoc-cn_start sig_en=1b20437f9fae2f0dc7f72e8c470081d5 sig_cn_org=None source=14.1 
   <para>
    In addition to these settings, which can be different for
    different <filename>pg_hba.conf</filename> entries, there is the
    server-wide <xref linkend="guc-krb-caseins-users"/> configuration
    parameter.  If that is set to true, client principals are matched to
    user map entries case-insensitively.  <literal>krb_realm</literal>, if
    set, is also matched case-insensitively.
   </para>
________________________________________________________-->
   <para>
    在这些设置之外，对于不同的<filename>pg_hba.conf</filename>项可能有所不同，还有服务器范围的<xref linkend="guc-krb-caseins-users"/> 配置参数。
    如果设置为真，客户端主体匹配用户映射条目是大小写不敏感的。
    如果设置了<literal>krb_realm</literal>，也不区分大小写。
   </para>
<!-- pgdoc-cn_end sig_en=1b20437f9fae2f0dc7f72e8c470081d5 -->
  </sect1>

  <sect1 id="sspi-auth">
<!-- pgdoc-cn_start sig_en=467697a7757cf848062d32d9a97552be sig_cn_org=None source=14.1 
   <title>SSPI Authentication</title>
________________________________________________________-->
   <title>SSPI 认证</title>
<!-- pgdoc-cn_end sig_en=467697a7757cf848062d32d9a97552be -->

<!-- pgdoc-cn_start sig_en=a644e5a98902fd788e44245862ca9c72 sig_cn_org=None source=14.1 
   <indexterm zone="sspi-auth">
    <primary>SSPI</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="sspi-auth">
    <primary>SSPI</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=a644e5a98902fd788e44245862ca9c72 -->

<!-- pgdoc-cn_start sig_en=b0742f202255752d9083d3e8a256d3d7 sig_cn_org=1f0e53b58bb24fca18bff9a8243d77b6 source=15.7 
   <para>
    <productname>SSPI</productname> is a <productname>Windows</productname>
    technology for secure authentication with single sign-on.
    <productname>PostgreSQL</productname> will use SSPI in
    <literal>negotiate</literal> mode, which will use
    <productname>Kerberos</productname> when possible and automatically
    fall back to <productname>NTLM</productname> in other cases.
    <productname>SSPI</productname> and <productname>GSSAPI</productname>
    interoperate as clients and servers, e.g., an
    <productname>SSPI</productname> client can authenticate to an
    <productname>GSSAPI</productname> server.  It is recommended to use
    <productname>SSPI</productname> on Windows clients and servers and
    <productname>GSSAPI</productname> on non-Windows platforms.
   </para>
________________________________________________________-->
   <para>
    <productname>SSPI</productname>是一种用于安全身份验证和单点登录的<productname>Windows</productname>技术。
    <productname>PostgreSQL</productname>将在<literal>negotiate</literal>模式下使用SSPI，
    该模式将在可能时使用<productname>Kerberos</productname>，并在其他情况下自动回退到<productname>NTLM</productname>。
    <productname>SSPI</productname>和<productname>GSSAPI</productname>可以作为客户端和服务器进行互操作，
    例如，<productname>SSPI</productname>客户端可以向<productname>GSSAPI</productname>服务器进行身份验证。
    建议在Windows客户端和服务器上使用<productname>SSPI</productname>，在非Windows平台上使用<productname>GSSAPI</productname>。
</para>
<!-- pgdoc-cn_end sig_en=b0742f202255752d9083d3e8a256d3d7 -->

<!-- pgdoc-cn_start sig_en=175b4576310364d274f2370f082f7798 sig_cn_org=None source=14.1 
   <para>
    When using <productname>Kerberos</productname> authentication,
    <productname>SSPI</productname> works the same way
    <productname>GSSAPI</productname> does; see <xref linkend="gssapi-auth"/>
    for details.
   </para>
________________________________________________________-->
   <para>
    当使用<productname>Kerberos</productname>认证时，<productname>SSPI</productname>和<productname>GSSAPI</productname>的工作方式相同，详见<xref linkend="gssapi-auth"/>。
   </para>
<!-- pgdoc-cn_end sig_en=175b4576310364d274f2370f082f7798 -->

<!-- pgdoc-cn_start sig_en=f8b6112c9892491bf7befbe0e829284f sig_cn_org=None source=14.1 
   <para>
    The following configuration options are supported for <productname>SSPI</productname>:
    <variablelist>

     <varlistentry>
      <term><literal>include_realm</literal></term>
      <listitem>
       <para>
        If set to 0, the realm name from the authenticated user principal is
        stripped off before being passed through the user name mapping
        (<xref linkend="auth-username-maps"/>). This is discouraged and is
        primarily available for backwards compatibility, as it is not secure
        in multi-realm environments unless <literal>krb_realm</literal> is
        also used.  It is recommended to
        leave <literal>include_realm</literal> set to the default (1) and to
        provide an explicit mapping in <filename>pg_ident.conf</filename> to convert
        principal names to <productname>PostgreSQL</productname> user names.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>compat_realm</literal></term>
      <listitem>
       <para>
        If set to 1, the domain's SAM-compatible name (also known as the
        NetBIOS name) is used for the <literal>include_realm</literal>
        option. This is the default. If set to 0, the true realm name from
        the Kerberos user principal name is used.
       </para>
       <para>
        Do not disable this option unless your server runs under a domain
        account (this includes virtual service accounts on a domain member
        system) and all clients authenticating through SSPI are also using
        domain accounts, or authentication will fail.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>upn_username</literal></term>
      <listitem>
       <para>
        If this option is enabled along with <literal>compat_realm</literal>,
        the user name from the Kerberos UPN is used for authentication. If
        it is disabled (the default), the SAM-compatible user name is used.
        By default, these two names are identical for new user accounts.
       </para>
       <para>
        Note that <application>libpq</application> uses the SAM-compatible name if no
        explicit user name is specified. If you use
        <application>libpq</application> or a driver based on it, you should
        leave this option disabled or explicitly specify user name in the
        connection string.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        Allows for mapping between system and database user names. See
        <xref linkend="auth-username-maps"/> for details.  For an SSPI/Kerberos
        principal, such as <literal>username@EXAMPLE.COM</literal> (or, less
        commonly, <literal>username/hostbased@EXAMPLE.COM</literal>), the
        user name used for mapping is
        <literal>username@EXAMPLE.COM</literal> (or
        <literal>username/hostbased@EXAMPLE.COM</literal>, respectively),
        unless <literal>include_realm</literal> has been set to 0, in which case
        <literal>username</literal> (or <literal>username/hostbased</literal>)
        is what is seen as the system user name when mapping.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>krb_realm</literal></term>
      <listitem>
       <para>
        Sets the realm to match user principal names against. If this parameter
        is set, only users of that realm will be accepted.  If it is not set,
        users of any realm can connect, subject to whatever user name mapping
        is done.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    下列被支持的配置选项用于<productname>SSPI</productname>：
    <variablelist>

     <varlistentry>
      <term><literal>include_realm</literal></term>
      <listitem>
       <para>
        如果设置为 0，在通过用户名映射之前（<xref linkend="auth-username-maps"/>），来自已认证用户 principal 的 realm 名称会被剥离掉。我们不鼓励这样做，这种方法主要是为了向后兼容性而存在的，因为它在多 realm 环境中是不安全的（除非也使用<literal>krb_realm</literal>）。推荐用户让 include_realm 设置为默认值（1）并且在<filename>pg_ident.conf</filename>中提供一条显式的映射来把 principal 名称转换成<productname>PostgreSQL</productname>用户名。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>compat_realm</literal></term>
      <listitem>
       <para>
        如果被设置为 1，该域的 SAM 兼容名称（也被称为 NetBIOS 名称）被用于<literal>include_realm</literal>选项。这是默认值。如果被设置为 0，会使用来自 Kerberos 用户主名的真实 realm 名称。
       </para>
       <para>
        不要禁用这个选项，除非你的服务器运行在一个域账号（这包括一个域成员系统上的虚拟服务账号）下并且所有通过 SSPI 认证的所有客户端也在使用域账号，否则认证将会失败。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>upn_username</literal></term>
      <listitem>
       <para>
        如果这个选项和<literal>compat_realm</literal>一起被启用，来自 Kerberos UPN 的用户名会被用于认证。如果它被禁用（默认），会使用 SAM 兼容的用户名。默认情况下，对于新用户账号这两种名称是一样的。
       </para>
       <para>
        注意如果没有显式指定用户名，<application>libpq</application>会使用 SAM 兼容的名称。如果你使用的是<application>libpq</application>或者基于它的驱动，你应该让这个选项保持禁用或者在连接字符串中显式指定用户名。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        允许在系统和数据库用户名之间的映射。详见<xref linkend="auth-username-maps"/>。
        对于一个 GSSAPI/Kerberos 原则，例如<literal>username@EXAMPLE.COM</literal>
        （或者更不常见的<literal>username/hostbased@EXAMPLE.COM</literal>），
        用于映射的用户名会是<literal>username@EXAMPLE.COM</literal>（或者
        <literal>username/hostbased@EXAMPLE.COM</literal>，相应地），除非
        <literal>include_realm</literal>已经被设置为 0，在那种情况下
        <literal>username</literal>（或者<literal>username/hostbased</literal>）是
        映射时被视作系统用户名的东西。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>krb_realm</literal></term>
      <listitem>
       <para>
        设置领域为对用户 principal 名进行匹配的范围。如果这个参数被设置，只有那个领域的用户将被接受。如果它没有被设置，任何领域的用户都能连接，服从任何已完成的用户名映射。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=f8b6112c9892491bf7befbe0e829284f -->
  </sect1>

  <sect1 id="auth-ident">
<!-- pgdoc-cn_start sig_en=caf5009fa420b793107b0eaf8f467559 sig_cn_org=None source=14.1 
   <title>Ident Authentication</title>
________________________________________________________-->
   <title>Ident 认证</title>
<!-- pgdoc-cn_end sig_en=caf5009fa420b793107b0eaf8f467559 -->

<!-- pgdoc-cn_start sig_en=25560b96de7fc545ce2c4d121529c4f2 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>ident</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>ident</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=25560b96de7fc545ce2c4d121529c4f2 -->

<!-- pgdoc-cn_start sig_en=1410369441b5f87ff4fb2e4649b22733 sig_cn_org=None source=14.1 
   <para>
    The ident authentication method works by obtaining the client's
    operating system user name from an ident server and using it as
    the allowed database user name (with an optional user name mapping).
    This is only supported on TCP/IP connections.
   </para>
________________________________________________________-->
   <para>
    ident 认证方法通过从一个 ident 服务器获得客户端的操作系统用户名并且用它作为被允许的数据库用户名（和可选的用户名映射）来工作。它只在 TCP/IP 连接上支持。
   </para>
<!-- pgdoc-cn_end sig_en=1410369441b5f87ff4fb2e4649b22733 -->

   <note>
<!-- pgdoc-cn_start sig_en=3166f52e6e4e2852e20c818e49accf43 sig_cn_org=None source=14.1 
    <para>
     When ident is specified for a local (non-TCP/IP) connection,
     peer authentication (see <xref linkend="auth-peer"/>) will be
     used instead.
    </para>
________________________________________________________-->
    <para>
     当为一个本地（非 TCP/IP）连接指定 ident 时，将实际使用 peer 认证（见<xref linkend="auth-peer"/>）。
    </para>
<!-- pgdoc-cn_end sig_en=3166f52e6e4e2852e20c818e49accf43 -->
   </note>

<!-- pgdoc-cn_start sig_en=d04490f911e1b77dbaaae6dfb756fd17 sig_cn_org=5f414e6b55efec0889769a576c950f1d source=15.7 
   <para>
    The following configuration options are supported for <literal>ident</literal>:
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        Allows for mapping between system and database user names. See
        <xref linkend="auth-username-maps"/> for details.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    支持以下配置选项<literal>ident</literal>：
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        允许在系统用户和数据库用户名称之间进行映射。详细信息请参见<xref linkend="auth-username-maps"/>。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=d04490f911e1b77dbaaae6dfb756fd17 -->

<!-- pgdoc-cn_start sig_en=2a3618de11c919ff1421f7bf7a285e41 sig_cn_org=989b4b67ebfae5a3d4084ba608e89829 source=15.7 
   <para>
    The <quote>Identification Protocol</quote> is described in
    <ulink url="https://datatracker.ietf.org/doc/html/rfc1413">RFC 1413</ulink>.
    Virtually every Unix-like
    operating system ships with an ident server that listens on TCP
    port 113 by default. The basic functionality of an ident server
    is to answer questions like <quote>What user initiated the
    connection that goes out of your port <replaceable>X</replaceable>
    and connects to my port <replaceable>Y</replaceable>?</quote>.
    Since <productname>PostgreSQL</productname> knows both <replaceable>X</replaceable> and
    <replaceable>Y</replaceable> when a physical connection is established, it
    can interrogate the ident server on the host of the connecting
    client and can theoretically determine the operating system user
    for any given connection.
   </para>
________________________________________________________-->
   <para>
    <quote>Identification Protocol</quote>被描述在
    <ulink url="https://datatracker.ietf.org/doc/html/rfc1413">RFC 1413</ulink>中。
    几乎每个类Unix的操作系统都默认安装了一个ident服务器，监听TCP
    端口113。ident服务器的基本功能是回答类似于<quote>哪个用户发起了
    从你的端口<replaceable>X</replaceable>到我的端口<replaceable>Y</replaceable>的连接？</quote>这样的问题。
    由于<productname>PostgreSQL</productname>在建立物理连接时知道<replaceable>X</replaceable>和
    <replaceable>Y</replaceable>，它可以查询连接客户端主机上的ident服务器，
    理论上可以确定任何给定连接的操作系统用户。
</para>
<!-- pgdoc-cn_end sig_en=2a3618de11c919ff1421f7bf7a285e41 -->

<!-- pgdoc-cn_start sig_en=86d3040d85ac7f309e00583b794148a3 sig_cn_org=None source=14.1 
   <para>
    The drawback of this procedure is that it depends on the integrity
    of the client: if the client machine is untrusted or compromised,
    an attacker could run just about any program on port 113 and
    return any user name they choose. This authentication method is
    therefore only appropriate for closed networks where each client
    machine is under tight control and where the database and system
    administrators operate in close contact. In other words, you must
    trust the machine running the ident server.
    Heed the warning:
    <blockquote>
     <attribution>RFC 1413</attribution>
     <para>
      The Identification Protocol is not intended as an authorization
      or access control protocol.
     </para>
    </blockquote>
   </para>
________________________________________________________-->
   <para>
    这个过程的缺点是它依赖于客户端的完整性：如果客户端机器不可信或者被攻破，攻击者可能在 113 端口上运行任何程序并且返回他们选择的任何用户。因此这种认证方法只适用于封闭的网络， 这样的网络中的每台客户端机器都处于严密的控制下并且数据库和操作系统管理员操作时可以方便地联系。换句话说，你必须信任运行 ident 服务器的机器。注意这样的警告：
    <blockquote>
     <attribution>RFC 1413</attribution>
     <para>
      标识协议的本意不是作为一种认证或访问控制协议。
     </para>
    </blockquote>
   </para>
<!-- pgdoc-cn_end sig_en=86d3040d85ac7f309e00583b794148a3 -->

<!-- pgdoc-cn_start sig_en=46dd2def50e8ba1c4bdcb7d66f425044 sig_cn_org=None source=14.1 
   <para>
    Some ident servers have a nonstandard option that causes the returned
    user name to be encrypted, using a key that only the originating
    machine's administrator knows.  This option <emphasis>must not</emphasis> be
    used when using the ident server with <productname>PostgreSQL</productname>,
    since <productname>PostgreSQL</productname> does not have any way to decrypt the
    returned string to determine the actual user name.
   </para>
________________________________________________________-->
   <para>
    有些 ident 服务器有一个非标准的选项，它导致返回的用户名是被加密的，使用的是只有原机器管理员知道的一个密钥。当与<productname>PostgreSQL</productname>配合使用 ident 服务器时，<emphasis>一定不要</emphasis>使用这个选项，因为<productname>PostgreSQL</productname>没有任何方法对返回的字符串进行解密以获取实际的用户名。
   </para>
<!-- pgdoc-cn_end sig_en=46dd2def50e8ba1c4bdcb7d66f425044 -->
  </sect1>

  <sect1 id="auth-peer">
<!-- pgdoc-cn_start sig_en=c357ba2f3c0cd6fb056132ebdd4fb763 sig_cn_org=None source=14.1 
   <title>Peer Authentication</title>
________________________________________________________-->
   <title>Peer 认证</title>
<!-- pgdoc-cn_end sig_en=c357ba2f3c0cd6fb056132ebdd4fb763 -->

<!-- pgdoc-cn_start sig_en=1ec67c104b9a83999f59e8ddc3e70788 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>peer</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>peer</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=1ec67c104b9a83999f59e8ddc3e70788 -->

<!-- pgdoc-cn_start sig_en=0f7718caf25baeffa3741cf9456778ac sig_cn_org=None source=14.1 
   <para>
    The peer authentication method works by obtaining the client's
    operating system user name from the kernel and using it as the
    allowed database user name (with optional user name mapping). This
    method is only supported on local connections.
   </para>
________________________________________________________-->
   <para>
    Peer 认证方法通过从内核获得客户端的操作系统用户名并把它用作被允许的数据库用户名（和可选的用户名映射）来工作。这种方法只在本地连接上支持。
   </para>
<!-- pgdoc-cn_end sig_en=0f7718caf25baeffa3741cf9456778ac -->

<!-- pgdoc-cn_start sig_en=c837625109f0646d477d45124d9a09a0 sig_cn_org=80e1376adbe9c52396b422e6c60b02fb source=15.7 
   <para>
    The following configuration options are supported for <literal>peer</literal>:
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        Allows for mapping between system and database user names. See
        <xref linkend="auth-username-maps"/> for details.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    下面是<literal>peer</literal>支持的配置选项：
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        允许在系统用户和数据库用户名称之间进行映射。详细信息请参见<xref linkend="auth-username-maps"/>。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=c837625109f0646d477d45124d9a09a0 -->

<!-- pgdoc-cn_start sig_en=161cdada140186a0f2b48aaf3a7858a1 sig_cn_org=None source=14.1 
   <para>
    Peer authentication is only available on operating systems providing
    the <function>getpeereid()</function> function, the <symbol>SO_PEERCRED</symbol>
    socket parameter, or similar mechanisms.  Currently that includes
    <systemitem class="osname">Linux</systemitem>,
    most flavors of <systemitem class="osname">BSD</systemitem> including
    <systemitem class="osname">macOS</systemitem>,
    and <systemitem class="osname">Solaris</systemitem>.
   </para>
________________________________________________________-->
   <para>
    Peer 认证只在提供<function>getpeereid()</function>函数、<symbol>SO_PEERCRED</symbol>套接字参数或相似机制的操作系统上可用。这些 OS 当前包括<systemitem class="osname">Linux</systemitem>、大部分的<systemitem class="osname">BSD</systemitem>包括<systemitem class="osname">OS X</systemitem>以及<systemitem class="osname">Solaris</systemitem>。
   </para>
<!-- pgdoc-cn_end sig_en=161cdada140186a0f2b48aaf3a7858a1 -->

  </sect1>

  <sect1 id="auth-ldap">
<!-- pgdoc-cn_start sig_en=83673494bcd34ccbb5d3dcd1e17c20ae sig_cn_org=None source=14.1 
   <title>LDAP Authentication</title>
________________________________________________________-->
   <title>LDAP 认证</title>
<!-- pgdoc-cn_end sig_en=83673494bcd34ccbb5d3dcd1e17c20ae -->

<!-- pgdoc-cn_start sig_en=9606270231718080d6c9d44e726afa20 sig_cn_org=None source=14.1 
   <indexterm zone="auth-ldap">
    <primary>LDAP</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="auth-ldap">
    <primary>LDAP</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=9606270231718080d6c9d44e726afa20 -->

<!-- pgdoc-cn_start sig_en=12783ff858c03373656b468487c1777d sig_cn_org=None source=14.1 
   <para>
    This authentication method operates similarly to
    <literal>password</literal> except that it uses LDAP
    as the password verification method. LDAP is used only to validate
    the user name/password pairs. Therefore the user must already
    exist in the database before LDAP can be used for
    authentication.
   </para>
________________________________________________________-->
   <para>
    这种认证方法操作起来类似于<literal>password</literal>，只不过它使用 LDAP 作为密码验证方法。LDAP 只被用于验证用户名/口令对。因此，在使用 LDAP 进行认证之前，用户必须已经存在于数据库中。
   </para>
<!-- pgdoc-cn_end sig_en=12783ff858c03373656b468487c1777d -->

<!-- pgdoc-cn_start sig_en=fb9f9f18384c0be3f6d9b63119ed0c4f sig_cn_org=None source=14.1 
   <para>
    LDAP authentication can operate in two modes. In the first mode,
    which we will call the simple bind mode,
    the server will bind to the distinguished name constructed as
    <replaceable>prefix</replaceable> <replaceable>username</replaceable> <replaceable>suffix</replaceable>.
    Typically, the <replaceable>prefix</replaceable> parameter is used to specify
    <literal>cn=</literal>, or <replaceable>DOMAIN</replaceable><literal>\</literal> in an Active
    Directory environment.  <replaceable>suffix</replaceable> is used to specify the
    remaining part of the DN in a non-Active Directory environment.
   </para>
________________________________________________________-->
   <para>
    LDAP 认证可以在两种模式下操作。在第一种模式中（我们将称之为简单绑定模式），服务器将绑定到构造成<replaceable>prefix</replaceable> <replaceable>username</replaceable> <replaceable>suffix</replaceable>的可区分名称。通常，<replaceable>prefix</replaceable>参数被用于指定 <literal>cn=</literal>或者一个活动目录环境中的<replaceable>DOMAIN</replaceable><literal>\</literal>。<replaceable>suffix</replaceable>被用来指定非活动目录环境中的DN的剩余部分。
   </para>
<!-- pgdoc-cn_end sig_en=fb9f9f18384c0be3f6d9b63119ed0c4f -->

<!-- pgdoc-cn_start sig_en=85a7fd85561ce0efacc133b6542be8fe sig_cn_org=None source=14.1 
   <para>
    In the second mode, which we will call the search+bind mode,
    the server first binds to the LDAP directory with
    a fixed user name and password, specified with <replaceable>ldapbinddn</replaceable>
    and <replaceable>ldapbindpasswd</replaceable>, and performs a search for the user trying
    to log in to the database. If no user and password is configured, an
    anonymous bind will be attempted to the directory. The search will be
    performed over the subtree at <replaceable>ldapbasedn</replaceable>, and will try to
    do an exact match of the attribute specified in
    <replaceable>ldapsearchattribute</replaceable>.
    Once the user has been found in
    this search, the server disconnects and re-binds to the directory as
    this user, using the password specified by the client, to verify that the
    login is correct. This mode is the same as that used by LDAP authentication
    schemes in other software, such as Apache <literal>mod_authnz_ldap</literal> and <literal>pam_ldap</literal>.
    This method allows for significantly more flexibility
    in where the user objects are located in the directory, but will cause
    two separate connections to the LDAP server to be made.
   </para>
________________________________________________________-->
   <para>
    在第二种模式中（我们将称之为搜索与绑定模式），服务器首先用一个固定的用户名和密码（用<replaceable>ldapbinddn</replaceable>和<replaceable>ldapbindpasswd</replaceable>指定）绑定到 LDAP 目录 ，并为试图登入该数据库的用户执行一次搜索。如果没有配置用户名和密码， 将尝试一次匿名绑定到目录。搜索将在位于<replaceable>ldapbasedn</replaceable>的子树上被执行，并将尝试做一次<replaceable>ldapsearchattribute</replaceable>中指定属性的精确匹配。一旦在这次搜索中找到用户，服务器断开并且作为这个用户重新绑定到目录，使用由客户端指定的口令来验证登录是正确的。这种模式与在其他软件中的 LDAP 认证所使用的相同，例如 Apache <literal>mod_authnz_ldap</literal> 和 <literal>pam_ldap</literal>。这种方法允许位于目录中用户对象的更大灵活性，但是会导致建立两个到 LDAP 服务器的独立连接。
   </para>
<!-- pgdoc-cn_end sig_en=85a7fd85561ce0efacc133b6542be8fe -->

<!-- pgdoc-cn_start sig_en=58c621c247ff18f17e535428cde59bd2 sig_cn_org=2509e72a518b29ec06583c32af0d1b0a source=15.7 
   <para>
    The following configuration options are used in both modes:
    <variablelist>
     <varlistentry>
      <term><literal>ldapserver</literal></term>
      <listitem>
       <para>
        Names or IP addresses of LDAP servers to connect to. Multiple
        servers may be specified, separated by spaces.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapport</literal></term>
      <listitem>
       <para>
        Port number on LDAP server to connect to. If no port is specified,
        the LDAP library's default port setting will be used.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapscheme</literal></term>
      <listitem>
       <para>
        Set to <literal>ldaps</literal> to use LDAPS.  This is a non-standard
        way of using LDAP over SSL, supported by some LDAP server
        implementations.  See also the <literal>ldaptls</literal> option for
        an alternative.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldaptls</literal></term>
      <listitem>
       <para>
        Set to 1 to make the connection between PostgreSQL and the LDAP server
        use TLS encryption.  This uses the <literal>StartTLS</literal>
        operation per <ulink url="https://datatracker.ietf.org/doc/html/rfc4513">RFC 4513</ulink>.
        See also the <literal>ldapscheme</literal> option for an alternative.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    以下配置选项在两种模式下都使用：
    <variablelist>
     <varlistentry>
      <term><literal>ldapserver</literal></term>
      <listitem>
       <para>
        要连接的LDAP服务器的名称或IP地址。可以指定多个服务器，用空格分隔。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapport</literal></term>
      <listitem>
       <para>
        要连接的LDAP服务器的端口号。如果未指定端口，则将使用LDAP库的默认端口设置。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapscheme</literal></term>
      <listitem>
       <para>
        设置为<literal>ldaps</literal>以使用LDAPS。这是一种非标准的使用LDAP
        进行SSL加密的方式，受一些LDAP服务器实现支持。另请参阅<literal>ldaptls</literal>
        选项作为替代。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldaptls</literal></term>
      <listitem>
       <para>
        设置为1以使PostgreSQL和LDAP服务器之间的连接使用TLS加密。这使用
        <literal>StartTLS</literal>操作，参见<ulink url="https://datatracker.ietf.org/doc/html/rfc4513">RFC 4513</ulink>。
        另请参阅<literal>ldapscheme</literal>选项作为替代。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=58c621c247ff18f17e535428cde59bd2 -->

<!-- pgdoc-cn_start sig_en=27299dd35fb2f733912255c8cc14ef08 sig_cn_org=None source=14.1 
   <para>
    Note that using <literal>ldapscheme</literal> or
    <literal>ldaptls</literal> only encrypts the traffic between the
    PostgreSQL server and the LDAP server.  The connection between the
    PostgreSQL server and the PostgreSQL client will still be unencrypted
    unless SSL is used there as well.
   </para>
________________________________________________________-->
   <para>
    注意使用<literal>ldapscheme</literal>或<literal>ldaptls</literal>仅会加密PostgreSQL服务器和LDAP服务器之间的通信。PostgreSQL服务器和PostgreSQL客户端之间的连接仍是未加密的，除非也在其上使用SSL。
   </para>
<!-- pgdoc-cn_end sig_en=27299dd35fb2f733912255c8cc14ef08 -->

<!-- pgdoc-cn_start sig_en=2a24f580f77df5a1f374501fa2b0c82a sig_cn_org=None source=14.1 
   <para>
    The following options are used in simple bind mode only:
    <variablelist>
     <varlistentry>
      <term><literal>ldapprefix</literal></term>
      <listitem>
       <para>
        String to prepend to the user name when forming the DN to bind as,
        when doing simple bind authentication.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapsuffix</literal></term>
      <listitem>
       <para>
        String to append to the user name when forming the DN to bind as,
        when doing simple bind authentication.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    下列选项只被用于简单绑定模式：
    <variablelist>
     <varlistentry>
      <term><literal>ldapprefix</literal></term>
      <listitem>
       <para>
        当做简单绑定认证时，前置到用户名形成要用于绑定的DN的字符串。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapsuffix</literal></term>
      <listitem>
       <para>
        当做简单绑定认证时，前置到用户名形成要用于绑定的DN的字符串。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=2a24f580f77df5a1f374501fa2b0c82a -->

<!-- pgdoc-cn_start sig_en=e50d3d4301bfa84cdce4be890656f81b sig_cn_org=44107764301bb39d765308746ddfc2df source=15.7 
   <para>
    The following options are used in search+bind mode only:
    <variablelist>
     <varlistentry>
      <term><literal>ldapbasedn</literal></term>
      <listitem>
       <para>
        Root DN to begin the search for the user in, when doing search+bind
        authentication.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapbinddn</literal></term>
      <listitem>
       <para>
        DN of user to bind to the directory with to perform the search when
        doing search+bind authentication.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapbindpasswd</literal></term>
      <listitem>
       <para>
        Password for user to bind to the directory with to perform the search
        when doing search+bind authentication.
       </para>
      </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>ldapsearchattribute</literal></term>
       <listitem>
        <para>
         Attribute to match against the user name in the search when doing
         search+bind authentication.  If no attribute is specified, the
         <literal>uid</literal> attribute will be used.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>ldapsearchfilter</literal></term>
       <listitem>
        <para>
         The search filter to use when doing search+bind authentication.
         Occurrences of <literal>$username</literal> will be replaced with the
         user name.  This allows for more flexible search filters than
         <literal>ldapsearchattribute</literal>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>ldapurl</literal></term>
       <listitem>
        <para>
         An <ulink url="https://datatracker.ietf.org/doc/html/rfc4516">RFC 4516</ulink>
         LDAP URL.  This is an alternative way to write some of the
         other LDAP options in a more compact and standard form.  The format is
<synopsis>
ldap[s]://<replaceable>host</replaceable>[:<replaceable>port</replaceable>]/<replaceable>basedn</replaceable>[?[<replaceable>attribute</replaceable>][?[<replaceable>scope</replaceable>][?[<replaceable>filter</replaceable>]]]]
</synopsis>
         <replaceable>scope</replaceable> must be one
         of <literal>base</literal>, <literal>one</literal>, <literal>sub</literal>,
         typically the last.  (The default is <literal>base</literal>, which
         is normally not useful in this application.)  <replaceable>attribute</replaceable> can
         nominate a single attribute, in which case it is used as a value for
         <literal>ldapsearchattribute</literal>.  If
         <replaceable>attribute</replaceable> is empty then
         <replaceable>filter</replaceable> can be used as a value for
         <literal>ldapsearchfilter</literal>.
        </para>

        <para>
         The URL scheme <literal>ldaps</literal> chooses the LDAPS method for
         making LDAP connections over SSL, equivalent to using
         <literal>ldapscheme=ldaps</literal>.  To use encrypted LDAP
         connections using the <literal>StartTLS</literal> operation, use the
         normal URL scheme <literal>ldap</literal> and specify the
         <literal>ldaptls</literal> option in addition to
         <literal>ldapurl</literal>.
        </para>

        <para>
         For non-anonymous binds, <literal>ldapbinddn</literal>
         and <literal>ldapbindpasswd</literal> must be specified as separate
         options.
        </para>

        <para>
         LDAP URLs are currently only supported with
         <productname>OpenLDAP</productname>, not on Windows.
        </para>
       </listitem>
      </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    以下选项仅在搜索+绑定模式中使用：
    <variablelist>
     <varlistentry>
      <term><literal>ldapbasedn</literal></term>
      <listitem>
       <para>
        在进行搜索+绑定身份验证时，用于开始搜索用户的根DN。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapbinddn</literal></term>
      <listitem>
       <para>
        用于绑定到目录以执行搜索的用户的DN，当进行搜索+绑定身份验证时。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>ldapbindpasswd</literal></term>
      <listitem>
       <para>
        用于绑定到目录以执行搜索的用户的密码，当进行搜索+绑定身份验证时。
       </para>
      </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>ldapsearchattribute</literal></term>
       <listitem>
        <para>
         在进行搜索+绑定身份验证时，用于匹配用户名的属性。如果未指定属性，则将使用<literal>uid</literal>属性。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>ldapsearchfilter</literal></term>
       <listitem>
        <para>
         在进行搜索+绑定身份验证时使用的搜索过滤器。
         <literal>$username</literal>的出现将被替换为用户名。这允许比<literal>ldapsearchattribute</literal>更灵活的搜索过滤器。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>ldapurl</literal></term>
       <listitem>
        <para>
         一个<ulink url="https://datatracker.ietf.org/doc/html/rfc4516">RFC 4516</ulink>
         LDAP URL。这是以更紧凑和标准形式编写其他LDAP选项的替代方式。格式为
<synopsis>
ldap[s]://<replaceable>host</replaceable>[:<replaceable>port</replaceable>]/<replaceable>basedn</replaceable>[?[<replaceable>attribute</replaceable>][?[<replaceable>scope</replaceable>][?[<replaceable>filter</replaceable>]]]]
</synopsis>
         <replaceable>scope</replaceable>必须是<literal>base</literal>、<literal>one</literal>、<literal>sub</literal>中的一个，通常是最后一个。（默认为<literal>base</literal>，在此应用中通常无用。）<replaceable>attribute</replaceable>可以指定单个属性，此时将用作<literal>ldapsearchattribute</literal>的值。如果<replaceable>attribute</replaceable>为空，则<replaceable>filter</replaceable>可用作<literal>ldapsearchfilter</literal>的值。
        </para>

        <para>
         URL方案<literal>ldaps</literal>选择了通过SSL进行LDAP连接的LDAPS方法，相当于使用<literal>ldapscheme=ldaps</literal>。要使用<literal>StartTLS</literal>操作进行加密LDAP连接，请使用正常的URL方案<literal>ldap</literal>并另外指定<literal>ldaptls</literal>选项。
        </para>

        <para>
         对于非匿名绑定，必须将<literal>ldapbinddn</literal>和<literal>ldapbindpasswd</literal>指定为单独的选项。
        </para>

        <para>
         LDAP URL目前仅受<productname>OpenLDAP</productname>支持，不支持Windows。
        </para>
       </listitem>
      </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=e50d3d4301bfa84cdce4be890656f81b -->

<!-- pgdoc-cn_start sig_en=7a23b3bafc19277d1db127eee7282fda sig_cn_org=None source=14.1 
   <para>
    It is an error to mix configuration options for simple bind with options
    for search+bind.
   </para>
________________________________________________________-->
   <para>
    将简单绑定的选项中混合用于搜索与绑定的选项是一种错误。
   </para>
<!-- pgdoc-cn_end sig_en=7a23b3bafc19277d1db127eee7282fda -->

<!-- pgdoc-cn_start sig_en=904d4eebab1c685b79cf3b02784eae70 sig_cn_org=None source=14.1 
   <para>
    When using search+bind mode, the search can be performed using a single
    attribute specified with <literal>ldapsearchattribute</literal>, or using
    a custom search filter specified with
    <literal>ldapsearchfilter</literal>.
    Specifying <literal>ldapsearchattribute=foo</literal> is equivalent to
    specifying <literal>ldapsearchfilter="(foo=$username)"</literal>.  If neither
    option is specified the default is
    <literal>ldapsearchattribute=uid</literal>.
   </para>
________________________________________________________-->
   <para>
    在使用search+bind模式时，可以用<literal>ldapsearchattribute</literal>指定的单个属性执行搜索，或者使用<literal>ldapsearchfilter</literal>指定的自定义搜索过滤器执行搜索。指定<literal>ldapsearchattribute=foo</literal>等效于指定<literal>ldapsearchfilter="(foo=$username)"</literal>。如果两个选项都没有被指定，则默认为<literal>ldapsearchattribute=uid</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=904d4eebab1c685b79cf3b02784eae70 -->

<!-- pgdoc-cn_start sig_en=7c8bbfb74f12db3da41ac013c0d902c3 sig_cn_org=f77c38656b0e2753242d58a22325b382 source=15.7 
   <para>
     If <productname>PostgreSQL</productname> was compiled with
     <productname>OpenLDAP</productname> as the LDAP client library, the
     <literal>ldapserver</literal> setting may be omitted.  In that case, a
     list of host names and ports is looked up via
     <ulink url="https://datatracker.ietf.org/doc/html/rfc2782">RFC 2782</ulink> DNS SRV records.
     The name <literal>_ldap._tcp.DOMAIN</literal> is looked up, where
     <literal>DOMAIN</literal> is extracted from <literal>ldapbasedn</literal>.
   </para>
________________________________________________________-->
   <para>
     如果<productname>PostgreSQL</productname>是使用<productname>OpenLDAP</productname>作为LDAP客户端库编译的，
     则<literal>ldapserver</literal>设置可以省略。在这种情况下，将通过<ulink url="https://datatracker.ietf.org/doc/html/rfc2782">RFC 2782</ulink> DNS SRV记录查找主机名和端口列表。
     查找名称为<literal>_ldap._tcp.DOMAIN</literal>，其中<literal>DOMAIN</literal>是从<literal>ldapbasedn</literal>中提取的。
   </para>
<!-- pgdoc-cn_end sig_en=7c8bbfb74f12db3da41ac013c0d902c3 -->

<!-- pgdoc-cn_start sig_en=d6e226fb39ed5128cc1917dd8a391c2b sig_cn_org=None source=14.1 
   <para>
    Here is an example for a simple-bind LDAP configuration:
<programlisting>
host ... ldap ldapserver=ldap.example.net ldapprefix="cn=" ldapsuffix=", dc=example, dc=net"
</programlisting>
    When a connection to the database server as database
    user <literal>someuser</literal> is requested, PostgreSQL will attempt to
    bind to the LDAP server using the DN <literal>cn=someuser, dc=example,
    dc=net</literal> and the password provided by the client.  If that connection
    succeeds, the database access is granted.
   </para>
________________________________________________________-->
   <para>
    这里是一个简单绑定 LDAP 配置的例子：
<programlisting>
host ... ldap ldapserver=ldap.example.net ldapprefix="cn=" ldapsuffix=", dc=example, dc=net"
</programlisting>
    当请求一个作为数据库用户<literal>someuser</literal>到数据库服务器的连接时，PostgreSQL 将尝试使用<literal>cn=someuser, dc=example, dc=net</literal>和客户端提供的口令来绑定到 LDAP 服务器。如果那个连接成功，将被授予数据库访问。
   </para>
<!-- pgdoc-cn_end sig_en=d6e226fb39ed5128cc1917dd8a391c2b -->

<!-- pgdoc-cn_start sig_en=e602bcbbe6457b63f1ca331d2eee1dee sig_cn_org=None source=14.1 
   <para>
    Here is an example for a search+bind configuration:
<programlisting>
host ... ldap ldapserver=ldap.example.net ldapbasedn="dc=example, dc=net" ldapsearchattribute=uid
</programlisting>
    When a connection to the database server as database
    user <literal>someuser</literal> is requested, PostgreSQL will attempt to
    bind anonymously (since <literal>ldapbinddn</literal> was not specified) to
    the LDAP server, perform a search for <literal>(uid=someuser)</literal>
    under the specified base DN.  If an entry is found, it will then attempt to
    bind using that found information and the password supplied by the client.
    If that second connection succeeds, the database access is granted.
   </para>
________________________________________________________-->
   <para>
    这里是一个搜索与绑定配置的例子：
<programlisting>
host ... ldap ldapserver=ldap.example.net ldapbasedn="dc=example, dc=net" ldapsearchattribute=uid
</programlisting>
    当请求一个作为数据库用户<literal>someuser</literal>到数据库服务器的连接时，PostgreSQL 将尝试匿名绑定（因为没有指定<literal>ldapbinddn</literal>）到 LDAP 服务器，在指定的基础 DN 下执行一次对于<literal>(uid=someuser)</literal>的搜索。如果找到一个项，则它将尝试使用找到的信息和客户端提供的口令进行绑定。如果第二个连接成功，将被授予数据库访问。
   </para>
<!-- pgdoc-cn_end sig_en=e602bcbbe6457b63f1ca331d2eee1dee -->

<!-- pgdoc-cn_start sig_en=0ec4e05e9921eedf8c003fa95b736f48 sig_cn_org=None source=14.1 
   <para>
    Here is the same search+bind configuration written as a URL:
<programlisting>
host ... ldap ldapurl="ldap://ldap.example.net/dc=example,dc=net?uid?sub"
</programlisting>
    Some other software that supports authentication against LDAP uses the
    same URL format, so it will be easier to share the configuration.
   </para>
________________________________________________________-->
   <para>
    这里是被写成一个 URL 的相同搜索与绑定配置：
<programlisting>
host ... ldap ldapurl="ldap://ldap.example.net/dc=example,dc=net?uid?sub"
</programlisting>
    一些支持根据 LDAP 认证的其他软件使用相同的 URL 格式，因此很容易共享该配置。
   </para>
<!-- pgdoc-cn_end sig_en=0ec4e05e9921eedf8c003fa95b736f48 -->

<!-- pgdoc-cn_start sig_en=dd0d85ad29075990b407d0a7402858ae sig_cn_org=None source=14.1 
   <para>
    Here is an example for a search+bind configuration that uses
    <literal>ldapsearchfilter</literal> instead of
    <literal>ldapsearchattribute</literal> to allow authentication by
    user ID or email address:
<programlisting>
host ... ldap ldapserver=ldap.example.net ldapbasedn="dc=example, dc=net" ldapsearchfilter="(|(uid=$username)(mail=$username))"
</programlisting>
   </para>
________________________________________________________-->
   <para>
    这里是一个search+bind配置的例子，它使用<literal>ldapsearchfilter</literal>而不是<literal>ldapsearchattribute</literal>来允许用用户ID或电子邮件地址进行认证：
<programlisting>
host ... ldap ldapserver=ldap.example.net ldapbasedn="dc=example, dc=net" ldapsearchfilter="(|(uid=$username)(mail=$username))"
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=dd0d85ad29075990b407d0a7402858ae -->

<!-- pgdoc-cn_start sig_en=0429c7afbde546cff49aefc86ca9cc90 sig_cn_org=None source=14.1 
   <para>
    Here is an example for a search+bind configuration that uses DNS SRV
    discovery to find the host name(s) and port(s) for the LDAP service for the
    domain name <literal>example.net</literal>:
<programlisting>
host ... ldap ldapbasedn="dc=example,dc=net"
</programlisting>
   </para>
________________________________________________________-->
   <para>
    这是一个search+bind配置的例子，它使用DNS SRV discovery来查找域名<literal>example.net</literal>的LDAP服务的主机名和端口。
<programlisting>
host ... ldap ldapbasedn="dc=example,dc=net"
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=0429c7afbde546cff49aefc86ca9cc90 -->

   <tip>
<!-- pgdoc-cn_start sig_en=90ae2296f8b276ee4fa84a71df9d1b67 sig_cn_org=None source=14.1 
    <para>
     Since LDAP often uses commas and spaces to separate the different
     parts of a DN, it is often necessary to use double-quoted parameter
     values when configuring LDAP options, as shown in the examples.
    </para>
________________________________________________________-->
    <para>
     如例子中所示，由于 LDAP 通常使用逗号和空格来分割一个 DN 的不同部分，在配置 LDAP 选项时通常有必要使用双引号包围的参数值。
    </para>
<!-- pgdoc-cn_end sig_en=90ae2296f8b276ee4fa84a71df9d1b67 -->
   </tip>

  </sect1>

  <sect1 id="auth-radius">
<!-- pgdoc-cn_start sig_en=255a7c75883ca1994db1926cb6c79632 sig_cn_org=None source=14.1 
   <title>RADIUS Authentication</title>
________________________________________________________-->
   <title>RADIUS 认证</title>
<!-- pgdoc-cn_end sig_en=255a7c75883ca1994db1926cb6c79632 -->

<!-- pgdoc-cn_start sig_en=bcf8ae6231c34c6d0c10c110a672d8f4 sig_cn_org=None source=14.1 
   <indexterm zone="auth-radius">
    <primary>RADIUS</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="auth-radius">
    <primary>RADIUS</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=bcf8ae6231c34c6d0c10c110a672d8f4 -->

<!-- pgdoc-cn_start sig_en=f717969cd4e358ca968da59d4918f24f sig_cn_org=None source=14.1 
   <para>
    This authentication method operates similarly to
    <literal>password</literal> except that it uses RADIUS
    as the password verification method. RADIUS is used only to validate
    the user name/password pairs. Therefore the user must already
    exist in the database before RADIUS can be used for
    authentication.
   </para>
________________________________________________________-->
   <para>
    这种认证方法的操作类似于<literal>password</literal>，不过它使用 RADIUS 作为密码验证方式。RADIUS 只被用于验证 用户名/密码对。因此，在 RADIUS 能被用于认证之前，用户必须已经存在于数据库中。
   </para>
<!-- pgdoc-cn_end sig_en=f717969cd4e358ca968da59d4918f24f -->

<!-- pgdoc-cn_start sig_en=de552a5404ddc14ccf772efba01df45c sig_cn_org=None source=14.1 
   <para>
    When using RADIUS authentication, an Access Request message will be sent
    to the configured RADIUS server. This request will be of type
    <literal>Authenticate Only</literal>, and include parameters for
    <literal>user name</literal>, <literal>password</literal> (encrypted) and
    <literal>NAS Identifier</literal>. The request will be encrypted using
    a secret shared with the server. The RADIUS server will respond to
    this request with either <literal>Access Accept</literal> or
    <literal>Access Reject</literal>. There is no support for RADIUS accounting.
   </para>
________________________________________________________-->
   <para>
    当使用 RADIUS 认证时，一个访问请求消息将被发送到配置好的 RADIUS 服务器。
	这一请求将是<literal>Authenticate Only</literal>类型，并且包含参数<literal>user name</literal>、<literal>password</literal>（加密的）和<literal>NAS Identifier</literal>。
	该请求将使用一个与服务器共享的密钥加密。
	RADIUS 服务器将对这个请求响应<literal>Access Accept</literal>或者<literal>Access Reject</literal>。不支持RADIUS accounting。
   </para>
<!-- pgdoc-cn_end sig_en=de552a5404ddc14ccf772efba01df45c -->

<!-- pgdoc-cn_start sig_en=a37edceb5efdda7ea9b5103a69eb807a sig_cn_org=None source=14.1 
   <para>
    Multiple RADIUS servers can be specified, in which case they will
    be tried sequentially. If a negative response is received from
    a server, the authentication will fail. If no response is received,
    the next server in the list will be tried. To specify multiple
    servers, separate the server names with commas and surround the list
    with double quotes. If multiple servers are specified, the other
    RADIUS options can also be given as comma-separated lists, to provide
    individual values for each server. They can also be specified as
    a single value, in which case that value will apply to all servers.
   </para>
________________________________________________________-->
   <para>
    可以指定多个RADIUS服务器，这种情况下将会依次尝试它们。如果从一台服务器接收到否定响应，则认证失败。
	如果没有接收到响应，则将会尝试列表中的下一台服务器。要指定多台服务器，可用双引号括住列表并用逗号将服务器名称分开。
	如果指定了多台服务器，其他RADIUS选项也可以用逗号分隔的列表给出，用来为每台服务器应用个别的值。
	它们也可以指定为单个值，这种情况下该值将被应用到所有的服务器。
   </para>
<!-- pgdoc-cn_end sig_en=a37edceb5efdda7ea9b5103a69eb807a -->

<!-- pgdoc-cn_start sig_en=bb60f4c489a64280ef3808cfcf2dcc6e sig_cn_org=None source=14.1 
   <para>
    The following configuration options are supported for RADIUS:
     <variablelist>
      <varlistentry>
       <term><literal>radiusservers</literal></term>
       <listitem>
        <para>
         The DNS names or IP addresses of the RADIUS servers to connect to.
         This parameter is required.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiussecrets</literal></term>
       <listitem>
        <para>
         The shared secrets used when talking securely to the RADIUS
         servers. This must have exactly the same value on the PostgreSQL
         and RADIUS servers. It is recommended that this be a string of
         at least 16 characters. This parameter is required.
         <note>
         <para>
          The encryption vector used will only be cryptographically
          strong if <productname>PostgreSQL</productname> is built with support for
          <productname>OpenSSL</productname>. In other cases, the transmission to the
          RADIUS server should only be considered obfuscated, not secured, and
          external security measures should be applied if necessary.
         </para>
         </note>
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiusports</literal></term>
       <listitem>
        <para>
         The port numbers to connect to on the RADIUS servers. If no port
         is specified, the default RADIUS port (<literal>1812</literal>)
         will be used.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiusidentifiers</literal></term>
       <listitem>
        <para>
         The strings to be used as <literal>NAS Identifier</literal> in the
         RADIUS requests. This parameter can be used, for example, to
         identify which database cluster the user is attempting to connect
         to, which can be useful for policy matching on
         the RADIUS server. If no identifier is specified, the default
         <literal>postgresql</literal> will be used.
        </para>
       </listitem>
      </varlistentry>

     </variablelist>
   </para>
________________________________________________________-->
   <para>
    下列被支持的配置选项用于 RADIUS：
     <variablelist>
      <varlistentry>
       <term><literal>radiusservers</literal></term>
       <listitem>
        <para>
         连接到 RADIUS 服务器的DNS名称或IP地址。此参数是必需的。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiussecrets</literal></term>
       <listitem>
        <para>
         和 RADIUS 服务器秘密交谈时会用到共享密钥。这在 PostgreSQL 和 RADIUS 服务器之间必须有完全相同的值。我们推荐用一个至少 16 个字符的字符串。这个参数是必需的。
         <note>
         <para>
          如果<productname>PostgreSQL</productname>编译为支持<productname>OpenSSL</productname>，所用的加密向量将只是强密码。在其他情况下，到 RADIUS 服务器的传输应该被视为应该被视为被混淆的、不安全的。如有必要，应采用外部安全措施。
         </para>
         </note>
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiusports</literal></term>
       <listitem>
        <para>
         连接 RADIUS 服务器的端口号。如果没有指定端口，则使用默认RADIUS端口<literal>1812</literal>。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>radiusidentifiers</literal></term>
       <listitem>
        <para>
         在 RADIUS 请求中字符串被用作<literal>NAS Identifier</literal>。
         这个参数可以被用于识别用户尝试连接哪些数据库集群，可以被用于 RADIUS 服务器上的策略匹配。
         如果没有指定标识符，默认使用<literal>postgresql</literal>。		 
        </para>
       </listitem>
      </varlistentry>

     </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=bb60f4c489a64280ef3808cfcf2dcc6e -->

<!-- pgdoc-cn_start sig_en=65fa06bf93fdb190b4957637456861c7 sig_cn_org=None source=14.1 
   <para>
    If it is necessary to have a comma or whitespace in a RADIUS parameter
    value, that can be done by putting double quotes around the value, but
    it is tedious because two layers of double-quoting are now required.
    An example of putting whitespace into RADIUS secret strings is:
<programlisting>
host ... radius radiusservers="server1,server2" radiussecrets="""secret one"",""secret two"""
</programlisting>
   </para>
________________________________________________________-->
   <para>
    如果RADIUS参数值中需要有逗号或者空格，可以通过双引号括住该值来完成，但这样做是比较繁琐的因为需要两层双引号。
    将空格放到RADIUS秘密字符串的一个示例为：
<programlisting>
host ... radius radiusservers="server1,server2" radiussecrets="""secret one"",""secret two"""
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=65fa06bf93fdb190b4957637456861c7 -->
  </sect1>

  <sect1 id="auth-cert">
<!-- pgdoc-cn_start sig_en=2eaf7af73350a80864c7e344ae33d270 sig_cn_org=None source=14.1 
   <title>Certificate Authentication</title>
________________________________________________________-->
   <title>证书认证</title>
<!-- pgdoc-cn_end sig_en=2eaf7af73350a80864c7e344ae33d270 -->

<!-- pgdoc-cn_start sig_en=be2757fcfcc3919499c04fd25c49e73f sig_cn_org=None source=14.1 
   <indexterm zone="auth-cert">
    <primary>Certificate</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="auth-cert">
    <primary>证书</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=be2757fcfcc3919499c04fd25c49e73f -->

<!-- pgdoc-cn_start sig_en=9aa73a7c87bc4d83b1d5dff42f446a52 sig_cn_org=48b2308e303805e2ea5ad31bfdcbd459 source=15.7 
   <para>
    This authentication method uses SSL client certificates to perform
    authentication. It is therefore only available for SSL connections;
    see <xref linkend="ssl-openssl-config"/> for SSL configuration instructions.
    When using this authentication method, the server will require that
    the client provide a valid, trusted certificate.  No password prompt
    will be sent to the client.  The <literal>cn</literal> (Common Name)
    attribute of the certificate
    will be compared to the requested database user name, and if they match
    the login will be allowed.  User name mapping can be used to allow
    <literal>cn</literal> to be different from the database user name.
   </para>
________________________________________________________-->
   <para>
    这种身份验证方法使用SSL客户端证书进行身份验证。因此，它仅适用于SSL连接；
    请参阅<xref linkend="ssl-openssl-config"/>获取SSL配置说明。
    使用此身份验证方法时，服务器将要求客户端提供有效的受信任证书。
    不会向客户端发送密码提示。证书的<literal>cn</literal>（通用名称）属性
    将与请求的数据库用户名进行比较，如果它们匹配，则允许登录。
    用户名称映射可用于允许<literal>cn</literal>与数据库用户名不同。
</para>
<!-- pgdoc-cn_end sig_en=9aa73a7c87bc4d83b1d5dff42f446a52 -->

<!-- pgdoc-cn_start sig_en=f29238b37fe70aa95a472ea7d0d1c876 sig_cn_org=None source=14.1 
   <para>
    The following configuration options are supported for SSL certificate
    authentication:
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        Allows for mapping between system and database user names. See
        <xref linkend="auth-username-maps"/> for details.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    下列被支持的配置选项用于 SSL 证书认证：
    <variablelist>
     <varlistentry>
      <term><literal>map</literal></term>
      <listitem>
       <para>
        允许在系统和数据库用户名之间的映射。详见<xref linkend="auth-username-maps"/>。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=f29238b37fe70aa95a472ea7d0d1c876 -->

<!-- pgdoc-cn_start sig_en=6d308988238c969fcff96a56825de496 sig_cn_org=None source=14.1 
   <para>
    It is redundant to use the <literal>clientcert</literal> option with
    <literal>cert</literal> authentication because <literal>cert</literal>
    authentication is effectively <literal>trust</literal> authentication
    with <literal>clientcert=verify-full</literal>.
   </para>
________________________________________________________-->
   <para>
    将 <literal>clientcert</literal> 选项与 <literal>cert</literal>验证一起使用是多余的，
    因为 <literal>cert</literal>身份验证是经过<literal>clientcert=verify-full</literal>的有效的 <literal>trust</literal> 验证。
   </para>
<!-- pgdoc-cn_end sig_en=6d308988238c969fcff96a56825de496 -->
  </sect1>

  <sect1 id="auth-pam">
<!-- pgdoc-cn_start sig_en=d9e3135202eaa97a1d7ca022f6f21456 sig_cn_org=None source=14.1 
   <title>PAM Authentication</title>
________________________________________________________-->
   <title>PAM 认证</title>
<!-- pgdoc-cn_end sig_en=d9e3135202eaa97a1d7ca022f6f21456 -->

<!-- pgdoc-cn_start sig_en=7d037b0bf9d23145bf94d6343072811c sig_cn_org=None source=14.1 
   <indexterm zone="auth-pam">
    <primary>PAM</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="auth-pam">
    <primary>PAM</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=7d037b0bf9d23145bf94d6343072811c -->

<!-- pgdoc-cn_start sig_en=ff9f62f9699e0a4f0a7adc696d133f94 sig_cn_org=None source=14.1 
   <para>
    This authentication method operates similarly to
    <literal>password</literal> except that it uses PAM (Pluggable
    Authentication Modules) as the authentication mechanism. The
    default PAM service name is <literal>postgresql</literal>.
    PAM is used only to validate user name/password pairs and optionally the
    connected remote host name or IP address. Therefore the user must already
    exist in the database before PAM can be used for authentication.  For more
    information about PAM, please read the
    <ulink url="https://www.kernel.org/pub/linux/libs/pam/">
    <productname>Linux-PAM</productname> Page</ulink>.
   </para>
________________________________________________________-->
   <para>
    这种认证方法操作起来类似<literal>password</literal>， 只不过它使用 PAM （插入式验证模块）作为认证机制。默认的 PAM 服务名是<literal>postgresql</literal>。PAM 只被用于验证用户名/口令对并且可以有选择地验证已连接的远程主机名或 IP 地址。因此，在使用 PAM 进行认证之前，用户必须已经存在于数据库中。有关 PAM 的更多信息，请阅读<ulink url="https://www.kernel.org/pub/linux/libs/pam/">
    <productname>Linux-PAM</productname> 页面</ulink>.
   </para>
<!-- pgdoc-cn_end sig_en=ff9f62f9699e0a4f0a7adc696d133f94 -->

<!-- pgdoc-cn_start sig_en=c0a3b8c08782269098c821e7dcbd3ab8 sig_cn_org=None source=14.1 
   <para>
    The following configuration options are supported for PAM:
    <variablelist>
     <varlistentry>
      <term><literal>pamservice</literal></term>
      <listitem>
       <para>
        PAM service name.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>pam_use_hostname</literal></term>
      <listitem>
       <para>
        Determines whether the remote IP address or the host name is provided
        to PAM modules through the <symbol>PAM_RHOST</symbol> item.  By
        default, the IP address is used.  Set this option to 1 to use the
        resolved host name instead.  Host name resolution can lead to login
        delays.  (Most PAM configurations don't use this information, so it is
        only necessary to consider this setting if a PAM configuration was
        specifically created to make use of it.)
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    下列被支持的配置选项用于 PAM：
    <variablelist>
     <varlistentry>
      <term><literal>pamservice</literal></term>
      <listitem>
       <para>
        PAM服务名称。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>pam_use_hostname</literal></term>
      <listitem>
       <para>
        判断是否通过<symbol>PAM_RHOST</symbol>项把远程 IP 地址或者主机名提供给 PAM 模块。默认情况下会使用 IP 地址。把这个选项设置为 1 可以使用解析过的主机名。主机名解析可能导致登录延迟（大部分的 PAM 配置不使用这些信息，因此只有使用为利用这种信息而特别创建的 PAM 配置时才需要考虑这个设置）。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=c0a3b8c08782269098c821e7dcbd3ab8 -->

   <note>
<!-- pgdoc-cn_start sig_en=f4ae8cc3a3ba4107d8732b76570db306 sig_cn_org=None source=14.1 
    <para>
     If PAM is set up to read <filename>/etc/shadow</filename>, authentication
     will fail because the PostgreSQL server is started by a non-root
     user.  However, this is not an issue when PAM is configured to use
     LDAP or other authentication methods.
    </para>
________________________________________________________-->
    <para>
     如果 PAM 被设置为读取<filename>/etc/shadow</filename>，认证将会失败，因为 PostgreSQL 服务器是由一个非 root 用户启动 。然而，当 PAM 被配置为使用 LDAP 或其他认证验证方法时这就不是一个问题。
    </para>
<!-- pgdoc-cn_end sig_en=f4ae8cc3a3ba4107d8732b76570db306 -->
   </note>
  </sect1>

  <sect1 id="auth-bsd">
<!-- pgdoc-cn_start sig_en=dd20ed4bb81e14b9ef28768a97857c09 sig_cn_org=None source=14.1 
   <title>BSD Authentication</title>
________________________________________________________-->
   <title>BSD 认证</title>
<!-- pgdoc-cn_end sig_en=dd20ed4bb81e14b9ef28768a97857c09 -->

<!-- pgdoc-cn_start sig_en=761e7ab0547c5d080f6df50dfe7f598e sig_cn_org=None source=14.1 
   <indexterm zone="auth-bsd">
    <primary>BSD Authentication</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="auth-bsd">
    <primary>BSD 认证</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=761e7ab0547c5d080f6df50dfe7f598e -->

<!-- pgdoc-cn_start sig_en=68e2403b4eefa347311d1006a59708a7 sig_cn_org=None source=14.1 
   <para>
    This authentication method operates similarly to
    <literal>password</literal> except that it uses BSD Authentication
    to verify the password. BSD Authentication is used only
    to validate user name/password pairs. Therefore the user's role must
    already exist in the database before BSD Authentication can be used
    for authentication. The BSD Authentication framework is currently
    only available on OpenBSD.
   </para>
________________________________________________________-->
   <para>
    这种认证方法操作起来类似于<literal>password</literal>，不过它使用 BSD 认证来验证口令。BSD 认证只被用来验证用户名/口令对。因此，在 BSD 认证可以被用于认证之前，用户的角色必须已经存在于数据库中。BSD 认证框架当前只在 OpenBSD 上可用。
   </para>
<!-- pgdoc-cn_end sig_en=68e2403b4eefa347311d1006a59708a7 -->

<!-- pgdoc-cn_start sig_en=8511522c624f1be7cbb6d56c1c0d2db4 sig_cn_org=None source=14.1 
   <para>
    BSD Authentication in <productname>PostgreSQL</productname> uses
    the <literal>auth-postgresql</literal> login type and authenticates with
    the <literal>postgresql</literal> login class if that's defined
    in <filename>login.conf</filename>. By default that login class does not
    exist, and <productname>PostgreSQL</productname> will use the default login class.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>中的 BSD 认证使用<literal>auth-postgresql</literal>登录类型，如果<filename>login.conf</filename>中定义了<literal>postgresql</literal>登录分类，就会用它来认证。默认情况下这种登录分类不存在，<productname>PostgreSQL</productname>将使用默认的登录分类。
   </para>
<!-- pgdoc-cn_end sig_en=8511522c624f1be7cbb6d56c1c0d2db4 -->

   <note>
<!-- pgdoc-cn_start sig_en=d015065aeabe7c46830b8145ebafc401 sig_cn_org=None source=14.1 
    <para>
     To use BSD Authentication, the PostgreSQL user account (that is, the
     operating system user running the server) must first be added to
     the <literal>auth</literal> group.  The <literal>auth</literal> group
     exists by default on OpenBSD systems.
    </para>
________________________________________________________-->
    <para>
     要使用 BSD 认证，PostgreSQL 用户账号（也就是运行服务器的操作系统用户）必须首先被加入到<literal>auth</literal>组中。在 OpenBSD 系统上默认存在<literal>auth</literal>组。
    </para>
<!-- pgdoc-cn_end sig_en=d015065aeabe7c46830b8145ebafc401 -->
   </note>
  </sect1>

  <sect1 id="client-authentication-problems">
<!-- pgdoc-cn_start sig_en=f574a0fe39842c7434baea9824ab4a12 sig_cn_org=None source=14.1 
   <title>Authentication Problems</title>
________________________________________________________-->
   <title>认证问题</title>
<!-- pgdoc-cn_end sig_en=f574a0fe39842c7434baea9824ab4a12 -->

<!-- pgdoc-cn_start sig_en=c3906adf5bb5bf79c63ab999ad2c0310 sig_cn_org=None source=14.1 
   <para>
    Authentication failures and related problems generally
    manifest themselves through error messages like the following:
   </para>
________________________________________________________-->
   <para>
    认证失败以及相关的问题通常由类似下面的错误消息显示：
   </para>
<!-- pgdoc-cn_end sig_en=c3906adf5bb5bf79c63ab999ad2c0310 -->

<!-- pgdoc-cn_start sig_en=28ee2c024c533fc34a6b2014f6f90b98 sig_cn_org=None source=14.1 
   <para>
<programlisting>
FATAL:  no pg_hba.conf entry for host "123.123.123.123", user "andym", database "testdb"
</programlisting>
    This is what you are most likely to get if you succeed in contacting
    the server, but it does not want to talk to you. As the message
    suggests, the server refused the connection request because it found
    no matching entry in its <filename>pg_hba.conf</filename>
    configuration file.
   </para>
________________________________________________________-->
   <para>
<programlisting>
FATAL:  no pg_hba.conf entry for host "123.123.123.123", user "andym", database "testdb"
</programlisting>
    这条消息最可能出现的情况是你成功地联系了服务器，但它不愿意和你说话。就像消息本身所建议的，服务器拒绝了连接请求，因为它没有在其<filename>pg_hba.conf</filename>配置文件里找到匹配项。
   </para>
<!-- pgdoc-cn_end sig_en=28ee2c024c533fc34a6b2014f6f90b98 -->

<!-- pgdoc-cn_start sig_en=8de73d34221dd29ad40091776a92651b sig_cn_org=None source=14.1 
   <para>
<programlisting>
FATAL:  password authentication failed for user "andym"
</programlisting>
    Messages like this indicate that you contacted the server, and it is
    willing to talk to you, but not until you pass the authorization
    method specified in the <filename>pg_hba.conf</filename> file. Check
    the password you are providing, or check your Kerberos or ident
    software if the complaint mentions one of those authentication
    types.
   </para>
________________________________________________________-->
   <para>
<programlisting>
FATAL:  password authentication failed for user "andym"
</programlisting>
    这样的消息表示你联系了服务器，并且它也愿意和你交谈，但是你必须通过<filename>pg_hba.conf</filename>文件中指定的认证方法。检查你提供的口令，或者如果错误消息提到了 Kerberos 或 ident 认证类型，检查那些软件。
   </para>
<!-- pgdoc-cn_end sig_en=8de73d34221dd29ad40091776a92651b -->

<!-- pgdoc-cn_start sig_en=0a17fd98f29eda097fe6f24832fc552c sig_cn_org=None source=14.1 
   <para>
<programlisting>
FATAL:  user "andym" does not exist
</programlisting>
    The indicated database user name was not found.
   </para>
________________________________________________________-->
   <para>
<programlisting>
FATAL:  user "andym" does not exist
</programlisting>
    指示的数据库用户没有被找到。
   </para>
<!-- pgdoc-cn_end sig_en=0a17fd98f29eda097fe6f24832fc552c -->

<!-- pgdoc-cn_start sig_en=f4e22a73deafb2bd9c6a4acbbe470442 sig_cn_org=None source=14.1 
   <para>
<programlisting>
FATAL:  database "testdb" does not exist
</programlisting>
    The database you are trying to connect to does not exist. Note that
    if you do not specify a database name, it defaults to the database
    user name, which might or might not be the right thing.
   </para>
________________________________________________________-->
   <para>
<programlisting>
FATAL:  database "testdb" does not exist
</programlisting>
    你试图连接的数据库不存在。请注意如果你没有声明数据库名，默认会用数据库用户名作为数据库名，这可能正确也可能不正确。
   </para>
<!-- pgdoc-cn_end sig_en=f4e22a73deafb2bd9c6a4acbbe470442 -->

   <tip>
<!-- pgdoc-cn_start sig_en=e4f9d470aee8a085eb8bb3c6b80eeed0 sig_cn_org=None source=14.1 
   <para>
    The server log might contain more information about an
    authentication failure than is reported to the client. If you are
    confused about the reason for a failure, check the server log.
   </para>
________________________________________________________-->
   <para>
    服务器日志可能包含比报告给客户端的更多的有关认证失败的信息。如果你为失败的原因而困惑，那么请检查服务器日志。
   </para>
<!-- pgdoc-cn_end sig_en=e4f9d470aee8a085eb8bb3c6b80eeed0 -->
   </tip>
  </sect1>

 </chapter>
