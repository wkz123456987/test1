<!-- doc/src/sgml/bki.sgml -->

<chapter id="bki">
<!-- pgdoc-cn_start sig_en=05a1fc1b40a789f42a41d85f7ff7aca5 sig_cn_org=None source=14.1 
 <title>System Catalog Declarations and Initial Contents</title>
________________________________________________________-->
 <title>系统目录声明和初始内容</title>
<!-- pgdoc-cn_end sig_en=05a1fc1b40a789f42a41d85f7ff7aca5 -->

<!-- pgdoc-cn_start sig_en=90d2321610213c05009337ee960a1fc7 sig_cn_org=None source=14.1 
 <para>
  <productname>PostgreSQL</productname> uses many different system catalogs
  to keep track of the existence and properties of database objects, such as
  tables and functions.  Physically there is no difference between a system
  catalog and a plain user table, but the backend C code knows the structure
  and properties of each catalog, and can manipulate it directly at a low
  level.  Thus, for example, it is inadvisable to attempt to alter the
  structure of a catalog on-the-fly; that would break assumptions built into
  the C code about how rows of the catalog are laid out.  But the structure
  of the catalogs can change between major versions.
 </para>
________________________________________________________-->
 <para>
  <productname>PostgreSQL</productname>使用很多不同的系统目录来跟踪数据库对象（例如表和函数）的存在以及属性。系统目录和普通用户表之间在物理上没有什么不同，但是后端的C代码知道每一个目录的结构和属性，并且能够在较低的层次上直接操纵它们。因此，不建议尝试在运行中修改目录的结构，那样做会破坏内建在C代码中对目录行如何放置的设想。但是目录的结构可能会在主版本之间发生变化。
 </para>
<!-- pgdoc-cn_end sig_en=90d2321610213c05009337ee960a1fc7 -->

<!-- pgdoc-cn_start sig_en=1ec6fbcd122225c4f333736ee0b45162 sig_cn_org=None source=14.1 
 <para>
  The structures of the catalogs are declared in specially formatted C
  header files in the <filename>src/include/catalog/</filename> directory of
  the source tree.  For each catalog there is a header file
  named after the catalog (e.g., <filename>pg_class.h</filename>
  for <structname>pg_class</structname>), which defines the set of columns
  the catalog has, as well as some other basic properties such as its OID.
 </para>
________________________________________________________-->
 <para>
  目录的结构声明在特殊格式的C头文件中，它们位于源码树的<filename>src/include/catalog/</filename>目录中。
  对每一个目录都有一个以其名称命名的头文件（例如，<structname>pg_class</structname>的头文件是<filename>pg_class.h</filename>），头文件定义了目录具有的列集合，以及一些其他的基本属性（例如OID）。
 </para>
<!-- pgdoc-cn_end sig_en=1ec6fbcd122225c4f333736ee0b45162 -->

<!-- pgdoc-cn_start sig_en=2ee174b168ec715e0d2957cf0c884770 sig_cn_org=None source=14.1 
 <para>
  Many of the catalogs have initial data that must be loaded into them
  during the <quote>bootstrap</quote> phase
  of <application>initdb</application>, to bring the system up to a point
  where it is capable of executing SQL commands.  (For
  example, <filename>pg_class.h</filename> must contain an entry for itself,
  as well as one for each other system catalog and index.)  This
  initial data is kept in editable form in data files that are also stored
  in the <filename>src/include/catalog/</filename> directory.  For example,
  <filename>pg_proc.dat</filename> describes all the initial rows that must
  be inserted into the <structname>pg_proc</structname> catalog.
 </para>
________________________________________________________-->
 <para>
  很多目录都有初始数据，这些数据必须在<application>initdb</application>的<quote>bootstrap</quote>阶段装载到对应的目录中，这样才能让系统达到能够执行SQL命令的状态点（例如，<filename>pg_class.h</filename>必须包含表示其自身的一个项，还要为每个系统目录和索引都分别包含一项）。这些初始数据以可编辑的形式保存在<filename>src/include/catalog/</filename>目录下的数据文件中。例如，<filename>pg_proc.dat</filename>描述了所有必须被插入到<structname>pg_proc</structname>目录的初始行。
 </para>
<!-- pgdoc-cn_end sig_en=2ee174b168ec715e0d2957cf0c884770 -->

<!-- pgdoc-cn_start sig_en=c90e9c71e9fa7fcd947a2b499d6f3180 sig_cn_org=None source=14.1 
 <para>
  To create the catalog files and load this initial data into them, a
  backend running in bootstrap mode reads a <acronym>BKI</acronym>
  (Backend Interface) file containing commands and initial data.
  The <filename>postgres.bki</filename> file used in this mode is prepared
  from the aforementioned header and data files, while building
  a <productname>PostgreSQL</productname> distribution, by a Perl script
  named <filename>genbki.pl</filename>.
  Although it's specific to a particular <productname>PostgreSQL</productname>
  release, <filename>postgres.bki</filename> is platform-independent and is
  installed in the <filename>share</filename> subdirectory of the
  installation tree.
 </para>
________________________________________________________-->
 <para>
  为了创建目录文件并且将这些初始数据载入其中，一个以bootstrap模式运行的后端会读取包含着命令和初始数据的<acronym>BKI</acronym>（后端接口）文件。这种模式中用到的<filename>postgres.bki</filename>文件正是在编译<productname>PostgreSQL</productname>时从前述的头文件和数据文件准备而来，这一过程由名为<filename>genbki.pl</filename>的Perl脚本负责。尽管<filename>postgres.bki</filename>与特定<productname>PostgreSQL</productname>发行版相关，但它是平台无关的并且被安装在安装树的<filename>share</filename>子目录中。
 </para>
<!-- pgdoc-cn_end sig_en=c90e9c71e9fa7fcd947a2b499d6f3180 -->

<!-- pgdoc-cn_start sig_en=5106757d02bbff26ae9cf9208aca509f sig_cn_org=None source=14.1 
 <para>
  <filename>genbki.pl</filename> also produces a derived header file for
  each catalog, for example <filename>pg_class_d.h</filename> for
  the <structname>pg_class</structname> catalog.  This file contains
  automatically-generated macro definitions, and may contain other macros,
  enum declarations, and so on that can be useful for client C code that
  reads a particular catalog.
 </para>
________________________________________________________-->
 <para>
  <filename>genbki.pl</filename>还会为每个目录产生一个头文件，例如为<structname>pg_class</structname>生成的头文件是<filename>pg_class_d.h</filename>。这个文件含有自动生成的宏定义，并且可能包含其他的宏、枚举声明，因此对于读取特定目录的客户端C代码很有用。
 </para>
<!-- pgdoc-cn_end sig_en=5106757d02bbff26ae9cf9208aca509f -->

<!-- pgdoc-cn_start sig_en=bead76e45f448f739cb3da74086b749d sig_cn_org=None source=14.1 
 <para>
  Most PostgreSQL developers don't need to be directly concerned with
  the <acronym>BKI</acronym> file, but almost any nontrivial feature
  addition in the backend will require modifying the catalog header files
  and/or initial data files.  The rest of this chapter gives some
  information about that, and for completeness describes
  the <acronym>BKI</acronym> file format.
 </para>
________________________________________________________-->
 <para>
  大部分PostgreSQL的开发者不需要直接与<acronym>BKI</acronym>文件打交道，但是几乎在后端中增加任何非平凡的特性都需要修改目录头文件或者初始数据文件。本章的剩余部分会给出一些相关的信息，并且将会完整地描述<acronym>BKI</acronym>文件格式。
 </para>
<!-- pgdoc-cn_end sig_en=bead76e45f448f739cb3da74086b749d -->

 <sect1 id="system-catalog-declarations">
<!-- pgdoc-cn_start sig_en=ea15d9eb6a132588013fc7e1c67d2270 sig_cn_org=None source=14.1 
  <title>System Catalog Declaration Rules</title>
________________________________________________________-->
  <title>系统目录声明规则</title>
<!-- pgdoc-cn_end sig_en=ea15d9eb6a132588013fc7e1c67d2270 -->

<!-- pgdoc-cn_start sig_en=2b39c2677354eae73ee0ea586062e77f sig_cn_org=None source=14.1 
  <para>
   The key part of a catalog header file is a C structure definition
   describing the layout of each row of the catalog.  This begins with
   a <literal>CATALOG</literal> macro, which so far as the C compiler is
   concerned is just shorthand for <literal>typedef struct
   FormData_<replaceable>catalogname</replaceable></literal>.
   Each field in the struct gives rise to a catalog column.
   Fields can be annotated using the BKI property macros described
   in <filename>genbki.h</filename>, for example to define a default value
   for a field or mark it as nullable or not nullable.
   The <literal>CATALOG</literal> line can also be annotated, with some
   other BKI property macros described in <filename>genbki.h</filename>, to
   define other properties of the catalog as a whole, such as whether
   it is a shared relation.
  </para>
________________________________________________________-->
  <para>
   一个目录头文件的关键部分是一个C的结构定义，它描述该目录中每一行的布局。这个结构开始于一个<literal>CATALOG</literal>宏，它对于C编译器而言只不过是<literal>typedef struct FormData_<replaceable>catalogname</replaceable></literal>的一个简写。该结构中的每一个域会导致出现一个目录列。域可以用<filename>genbki.h</filename>中描述的BKI属性宏进行标注，例如可以为域定义默认值或者把域标记为可以为空或者不能为空。<literal>CATALOG</literal>行也可以用<filename>genbki.h</filename>中描述的一些其他BKI属性宏标注，用于定义该目录整体的其他属性，例如是否为共享的关系。
  </para>
<!-- pgdoc-cn_end sig_en=2b39c2677354eae73ee0ea586062e77f -->

<!-- pgdoc-cn_start sig_en=61b2aec3e56e2464f62ea905ab104ee4 sig_cn_org=None source=14.1 
  <para>
   The system catalog cache code (and most catalog-munging code in general)
   assumes that the fixed-length portions of all system catalog tuples are
   in fact present, because it maps this C struct declaration onto them.
   Thus, all variable-length fields and nullable fields must be placed at
   the end, and they cannot be accessed as struct fields.
   For example, if you tried to
   set <structname>pg_type</structname>.<structfield>typrelid</structfield>
   to be NULL, it would fail when some piece of code tried to reference
   <literal>typetup-&gt;typrelid</literal> (or worse,
   <literal>typetup-&gt;typelem</literal>, because that follows
   <structfield>typrelid</structfield>).  This would result in
   random errors or even segmentation violations.
  </para>
________________________________________________________-->
  <para>
   系统目录缓冲代码（以及大部分目录功能代码）假定所有的系统目录元组的定长部分是实际的存在形式，因为它会把这个C结构声明映射到定长部分之上。因此，所有变长域和可以为空的域必须被放置在最后，并且不能够以结构的域的方式访问。例如，如果尝试设置<structname>pg_type</structname>.<structfield>typrelid</structfield>为NULL，当某段代码尝试引用<literal>typetup-&gt;typrelid</literal>（或者更糟糕的是引用<literal>typetup-&gt;typelem</literal>，因为它跟随在<structfield>typrelid</structfield>之后）时将会出现失败。这会导致随机错误乃至段错误。
  </para>
<!-- pgdoc-cn_end sig_en=61b2aec3e56e2464f62ea905ab104ee4 -->

<!-- pgdoc-cn_start sig_en=d4a0744d573fc840110515063eed91fe sig_cn_org=None source=14.1 
  <para>
   As a partial guard against this type of error, variable-length or
   nullable fields should not be made directly visible to the C compiler.
   This is accomplished by wrapping them in <literal>#ifdef
   CATALOG_VARLEN</literal> ... <literal>#endif</literal> (where
   <literal>CATALOG_VARLEN</literal> is a symbol that is never defined).
   This prevents C code from carelessly trying to access fields that might
   not be there or might be at some other offset.
   As an independent guard against creating incorrect rows, we
   require all columns that should be non-nullable to be marked so
   in <structname>pg_attribute</structname>.  The bootstrap code will
   automatically mark catalog columns as <literal>NOT NULL</literal>
   if they are fixed-width and are not preceded by any nullable or
   variable-width column.
   Where this rule is inadequate, you can force correct marking by using
   <literal>BKI_FORCE_NOT_NULL</literal>
   and <literal>BKI_FORCE_NULL</literal> annotations as needed.
  </para>
________________________________________________________-->
  <para>
   作为对这类错误的一种部分保护，变长或可以为空的域不应该对C编译器可见。
   通过将它们包裹在<literal>#ifdef CATALOG_VARLEN</literal> ... <literal>#endif</literal>（其中<literal>CATALOG_VARLEN</literal>是一个永不被定义的符号）中可以实现这一点。
   这能防止C代码不小心尝试访问可能不在那里或者可能在其他某个偏移位置的域。
   作为一种防止创建不正确行的措施，我们要求所有应该为非空的列在<structname>pg_attribute</structname>中也被标记为非空。
   如果目录列是定长的并且前面没有任何可以为空或可变宽度的列，bootstrap代码将自动把它标记为<literal>NOT NULL</literal>。
   在这一规则不适用的地方，可以根据需要使用<literal>BKI_FORCE_NOT_NULL</literal>和<literal>BKI_FORCE_NULL</literal>标注强制正确的标记。
  </para>
<!-- pgdoc-cn_end sig_en=d4a0744d573fc840110515063eed91fe -->

<!-- pgdoc-cn_start sig_en=e5f95226c6f94cbb477f65f037b65ae6 sig_cn_org=None source=14.1 
  <para>
   Frontend code should not include any <filename>pg_xxx.h</filename>
   catalog header file, as these files may contain C code that won't compile
   outside the backend.  (Typically, that happens because these files also
   contain declarations for functions
   in <filename>src/backend/catalog/</filename> files.)
   Instead, frontend code may include the corresponding
   generated <filename>pg_xxx_d.h</filename> header, which will contain
   OID <literal>#define</literal>s and any other data that might be of use
   on the client side.  If you want macros or other code in a catalog header
   to be visible to frontend code, write <literal>#ifdef
   EXPOSE_TO_CLIENT_CODE</literal> ... <literal>#endif</literal> around that
   section to instruct <filename>genbki.pl</filename> to copy that section
   to the <filename>pg_xxx_d.h</filename> header.
  </para>
________________________________________________________-->
  <para>
   前端代码不应该包括任何<filename>pg_xxx.h</filename>目录头文件，因为这些文件可能包含在后端之外无法编译的C代码（通常，这是因为这些文件还包含<filename>src/backend/catalog/</filename>文件中函数的声明）。不过，前端代码可以包括相应的<filename>pg_xxx_d.h</filename>头文件，它将包含OID <literal>#define</literal>以及任何其他可能要在客户端使用的数据。如果希望前端代码能看到目录头文件中的宏或者其他代码，可以在相应部分的周围写上<literal>#ifdef EXPOSE_TO_CLIENT_CODE</literal> ... <literal>#endif</literal>，这样会指示<filename>genbki.pl</filename>把相应的部分拷贝到<filename>pg_xxx_d.h</filename>头文件中。
  </para>
<!-- pgdoc-cn_end sig_en=e5f95226c6f94cbb477f65f037b65ae6 -->

<!-- pgdoc-cn_start sig_en=846d12303207722a8728ee56087a976b sig_cn_org=None source=14.1 
  <para>
   A few of the catalogs are so fundamental that they can't even be created
   by the <acronym>BKI</acronym> <literal>create</literal> command that's
   used for most catalogs, because that command needs to write information
   into these catalogs to describe the new catalog.  These are
   called <firstterm>bootstrap</firstterm> catalogs, and defining one takes
   a lot of extra work: you have to manually prepare appropriate entries for
   them in the pre-loaded contents of <structname>pg_class</structname>
   and <structname>pg_type</structname>, and those entries will need to be
   updated for subsequent changes to the catalog's structure.
   (Bootstrap catalogs also need pre-loaded entries
   in <structname>pg_attribute</structname>, but
   fortunately <filename>genbki.pl</filename> handles that chore nowadays.)
   Avoid making new catalogs be bootstrap catalogs if at all possible.
  </para>
________________________________________________________-->
  <para>
   少数目录是非常基础的，以至于它们无法用大部分目录采用的<acronym>BKI</acronym> <literal>create</literal>命令来创建，因为那个命令需要在这些目录中写入信息来描述新的目录。这些目录被称为<firstterm>bootstrap</firstterm>目录，定义一个这样的目录需要一些额外的工作：开发者必须为它在<structname>pg_class</structname>和<structname>pg_type</structname>的预装载内容中手工准备合适的项，并且后续对该目录结构的更改将会更新那些项（bootstrap目录还需要<structname>pg_attribute</structname>中的预装载项，但是幸运地是现如今的<filename>genbki.pl</filename>会处理这些杂务）。如果可能，一定避免将新目录创建为bootstrap目录。
  </para>
<!-- pgdoc-cn_end sig_en=846d12303207722a8728ee56087a976b -->
 </sect1>

 <sect1 id="system-catalog-initial-data">
<!-- pgdoc-cn_start sig_en=289eb2485220fa8a5035715aacdc30ed sig_cn_org=None source=14.1 
  <title>System Catalog Initial Data</title>
________________________________________________________-->
  <title>系统目录初始数据</title>
<!-- pgdoc-cn_end sig_en=289eb2485220fa8a5035715aacdc30ed -->

<!-- pgdoc-cn_start sig_en=3ae6573a3f957aebd353362c6cd3cba2 sig_cn_org=None source=14.1 
  <para>
   Each catalog that has any manually-created initial data (some do not)
   has a corresponding <literal>.dat</literal> file that contains its
   initial data in an editable format.
  </para>
________________________________________________________-->
  <para>
   每个有手工创建的初始数据（有些没有）的目录都有一个相应的<literal>.dat</literal>文件，其中以可编辑的格式包含着该目录的初始数据。
  </para>
<!-- pgdoc-cn_end sig_en=3ae6573a3f957aebd353362c6cd3cba2 -->

  <sect2 id="system-catalog-initial-data-format">
<!-- pgdoc-cn_start sig_en=6de337cbbddc050273c5405084822c23 sig_cn_org=None source=14.1 
   <title>Data File Format</title>
________________________________________________________-->
   <title>数据文件格式</title>
<!-- pgdoc-cn_end sig_en=6de337cbbddc050273c5405084822c23 -->

<!-- pgdoc-cn_start sig_en=fae6e341aae62f6594736f20db16f2fd sig_cn_org=None source=14.1 
   <para>
    Each <literal>.dat</literal> file contains Perl data structure literals
    that are simply eval'd to produce an in-memory data structure consisting
    of an array of hash references, one per catalog row.
    A slightly modified excerpt from <filename>pg_database.dat</filename>
    will demonstrate the key features:
   </para>
________________________________________________________-->
   <para>
    每个<literal>.dat</literal>文件含有Perl数据结构文本，它可以简单地通过eval产生由一个哈希引用数组构成的内存数据结构，每个目录行一个。从<filename>pg_database.dat</filename>摘出的经过略微修改的一小部分可以展示关键特性：
   </para>
<!-- pgdoc-cn_end sig_en=fae6e341aae62f6594736f20db16f2fd -->

<!-- The "slight modification" is the apostrophe in the description. -->
<programlisting><![CDATA[
[

# A comment could appear here.
{ oid => '1', oid_symbol => 'Template1DbOid',
  descr => 'database\'s default template',
  datname => 'template1', encoding => 'ENCODING',
  datlocprovider => 'LOCALE_PROVIDER', datistemplate => 't',
  datallowconn => 't', datconnlimit => '-1', datfrozenxid => '0',
  datminmxid => '1', dattablespace => 'pg_default', datcollate => 'LC_COLLATE',
  datctype => 'LC_CTYPE', daticulocale => 'ICU_LOCALE', datacl => '_null_' },

]
]]></programlisting>

<!-- pgdoc-cn_start sig_en=0fba2a06d0e9dabc48b912d399028cb7 sig_cn_org=None source=14.1 
   <para>
    Points to note:
   </para>
________________________________________________________-->
   <para>
    需要注意的点：
   </para>
<!-- pgdoc-cn_end sig_en=0fba2a06d0e9dabc48b912d399028cb7 -->

   <itemizedlist>

    <listitem>
<!-- pgdoc-cn_start sig_en=61aa7f591f96f962c33365c1362a7f1b sig_cn_org=None source=14.1 
     <para>
      The overall file layout is: open square bracket, one or more sets of
      curly braces each of which represents a catalog row, close square
      bracket.  Write a comma after each closing curly brace.
     </para>
________________________________________________________-->
     <para>
      总体的文件布局是：开方括号，一个或者多个花括号集合（每一个表示一个目录行），闭方括号。在每一个闭花括号之后写一个逗号。
     </para>
<!-- pgdoc-cn_end sig_en=61aa7f591f96f962c33365c1362a7f1b -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=a6243c30399f0f7ba642cda08095bae7 sig_cn_org=None source=14.1 
     <para>
      Within each catalog row, write comma-separated
      <replaceable>key</replaceable> <literal>=&gt;</literal>
      <replaceable>value</replaceable> pairs.  The
      allowed <replaceable>key</replaceable>s are the names of the catalog's
      columns, plus the metadata keys <literal>oid</literal>,
      <literal>oid_symbol</literal>,
      <literal>array_type_oid</literal>, and <literal>descr</literal>.
      (The use of <literal>oid</literal> and <literal>oid_symbol</literal>
      is described in <xref linkend="system-catalog-oid-assignment"/> below,
      while <literal>array_type_oid</literal> is described in
      <xref linkend="system-catalog-auto-array-types"/>.
      <literal>descr</literal> supplies a description string for the object,
      which will be inserted into <structname>pg_description</structname>
      or <structname>pg_shdescription</structname> as appropriate.)
      While the metadata keys are optional, the catalog's defined columns
      must all be provided, except when the catalog's <literal>.h</literal>
      file specifies a default value for the column.
      (In the example above, the <structfield>datdba</structfield> field has
      been omitted because <filename>pg_database.h</filename> supplies a
      suitable default value for it.)
     </para>
________________________________________________________-->
     <para>
      在每个目录行内，写成逗号分隔的<replaceable>key</replaceable> <literal>=&gt;</literal> <replaceable>value</replaceable>对。允许的<replaceable>key</replaceable>是该目录的列名，外加上元数据键<literal>oid</literal>、<literal>oid_symbol</literal>、<literal>array_type_oid</literal>以及<literal>descr</literal>（<literal>oid</literal>和<literal>oid_symbol</literal>的使用在下文的<xref linkend="system-catalog-oid-assignment"/>中描述，而<literal>array_type_oid</literal>在<xref linkend="system-catalog-auto-array-types"/>中描述。<literal>descr</literal>为该对象提供一个描述字符串，它将被插入到<structname>pg_description</structname>或<structname>pg_shdescription</structname>中）。虽然元数据键是可选的，但是目录中定义的列必须全部提供，除非目录的<literal>.h</literal>文件为该列指定了默认值。以上的例子里，忽略了<structfield>datdba</structfield>字段是因为<filename>pg_database.h</filename>为其提供了适当的默认值。
     </para>
<!-- pgdoc-cn_end sig_en=a6243c30399f0f7ba642cda08095bae7 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=94ce2ed34bf965c4d3cf4349f48348f0 sig_cn_org=None source=14.1 
     <para>
      All values must be single-quoted.  Escape single quotes used within a
      value with a backslash.  Backslashes meant as data can, but need not,
      be doubled; this follows Perl's rules for simple quoted literals.
      Note that backslashes appearing as data will be treated as escapes by
      the bootstrap scanner, according to the same rules as for escape string
      constants (see <xref linkend="sql-syntax-strings-escape"/>); for
      example <literal>\t</literal> converts to a tab character.  If you
      actually want a backslash in the final value, you will need to write
      four of them: Perl strips two, leaving <literal>\\</literal> for the
      bootstrap scanner to see.
     </para>
________________________________________________________-->
     <para>
      所有的值都必须被放在单引号中。用反斜线可以转义值中用到的单引号。作为数据的反斜线可以（但是不必）被双写，这遵循的是Perl对简单引用文本的规则。注意，作为数据出现的反斜线将被bootstrap扫描器根据转义字符串常量的相同规则（见<xref linkend="sql-syntax-strings-escape"/>）当作转义处理。例如<literal>\t</literal>转换为一个制表符。如果在最终值中确实想要一个反斜线，则需要写成四个：Perl会剥离掉两个，留下<literal>\\</literal>给bootstrap扫描器。
     </para>
<!-- pgdoc-cn_end sig_en=94ce2ed34bf965c4d3cf4349f48348f0 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=35cf2fdb8e714163edebcef9cb6eebd4 sig_cn_org=None source=14.1 
     <para>
      Null values are represented by <literal>_null_</literal>.
      (Note that there is no way to create a value that is just that
      string.)
     </para>
________________________________________________________-->
     <para>
      空值被表示为<literal>_null_</literal>（注意没有办法创建就是该字符串的值）。
     </para>
<!-- pgdoc-cn_end sig_en=35cf2fdb8e714163edebcef9cb6eebd4 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=7a875eb66599365285d780fd17e104ec sig_cn_org=None source=14.1 
     <para>
      Comments are preceded by <literal>#</literal>, and must be on their
      own lines.
     </para>
________________________________________________________-->
     <para>
      注释以<literal>#</literal>开头，并且必须位于它们自己的行上。
     </para>
<!-- pgdoc-cn_end sig_en=7a875eb66599365285d780fd17e104ec -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=df18c2e2118316751fef8acdf39f6d0f sig_cn_org=None source=14.1 
     <para>
      Field values that are OIDs of other catalog entries should be
      represented by symbolic names rather than actual numeric OIDs.
      (In the example above, <structfield>dattablespace</structfield>
      contains such a reference.)
      This is described in <xref linkend="system-catalog-oid-references"/>
      below.
     </para>
________________________________________________________-->
     <para>
      那些是其他目录条目的OID的字段值应该用符号名而不是实际的数字OID来表示（在上述例子中，<structfield>dattablespace</structfield>包含此类的引用。）这会在下文的<xref linkend="system-catalog-oid-references"/>中描述。
     </para>
<!-- pgdoc-cn_end sig_en=df18c2e2118316751fef8acdf39f6d0f -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=e74e8569c188facc878018e5e160e20d sig_cn_org=None source=14.1 
     <para>
      Since hashes are unordered data structures, field order and line
      layout aren't semantically significant.  However, to maintain a
      consistent appearance, we set a few rules that are applied by the
      formatting script <filename>reformat_dat_file.pl</filename>:

      <itemizedlist>

       <listitem>
        <para>
         Within each pair of curly braces, the metadata
         fields <literal>oid</literal>, <literal>oid_symbol</literal>,
         <literal>array_type_oid</literal>, and <literal>descr</literal>
         (if present) come first, in that order, then the catalog's own
         fields appear in their defined order.
        </para>
       </listitem>

       <listitem>
        <para>
         Newlines are inserted between fields as needed to limit line length
         to 80 characters, if possible.  A newline is also inserted between
         the metadata fields and the regular fields.
        </para>
       </listitem>

       <listitem>
        <para>
         If the catalog's <literal>.h</literal> file specifies a default
         value for a column, and a data entry has that same
         value, <filename>reformat_dat_file.pl</filename> will omit it from
         the data file.  This keeps the data representation compact.
        </para>
       </listitem>

       <listitem>
        <para>
         <filename>reformat_dat_file.pl</filename> preserves blank lines
         and comment lines as-is.
        </para>
       </listitem>

      </itemizedlist>

      It's recommended to run <filename>reformat_dat_file.pl</filename>
      before submitting catalog data patches.  For convenience, you can
      simply change to <filename>src/include/catalog/</filename> and
      run <literal>make reformat-dat-files</literal>.
     </para>
________________________________________________________-->
     <para>
      因为哈希是无序的数据结构，域顺序和行布局并不重要。不过，为了维持一种一致的外貌，我们设定了一些规则，它们由格式化脚本<filename>reformat_dat_file.pl</filename>实施：

      <itemizedlist>

       <listitem>
        <para>
         在每一对花括号内，元数据域<literal>oid</literal>、<literal>oid_symbol</literal>、<literal>array_type_oid</literal>和<literal>descr</literal>（如果存在）按照这个顺序放在最前面，然后以定义时的顺序放上该目录自己的域。
        </para>
       </listitem>

       <listitem>
        <para>
         如果可能，根据需要在域之间插入新行以限制行的长度低于80字符。在元数据域和普通域之间也插入一个新行。
        </para>
       </listitem>

       <listitem>
        <para>
         如果目录的<literal>.h</literal>文件为一个列指定了默认值并且一个数据项具有相同的值，<filename>reformat_dat_file.pl</filename>将从数据文件中省去它。这能使得数据表达紧凑。
        </para>
       </listitem>

       <listitem>
        <para>
         <filename>reformat_dat_file.pl</filename>原样保留空行和注释行。
        </para>
       </listitem>

      </itemizedlist>

      推荐在提交目录数据补丁前运行<filename>reformat_dat_file.pl</filename>。为了方便起见，可以简单地更改<filename>src/include/catalog/</filename>并且运行<literal>make reformat-dat-files</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=e74e8569c188facc878018e5e160e20d -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=1de5f076a4f9b95465a68e1c2e61d00c sig_cn_org=None source=14.1 
     <para>
      If you want to add a new method of making the data representation
      smaller, you must implement it
      in <filename>reformat_dat_file.pl</filename> and also
      teach <function>Catalog::ParseData()</function> how to expand the
      data back into the full representation.
     </para>
________________________________________________________-->
     <para>
      如果想要增加一种新方法让数据表达更小，必须在<filename>reformat_dat_file.pl</filename>中实现该方法并且还要教会<function>Catalog::ParseData()</function>如何将数据展开回完整的表达。
     </para>
<!-- pgdoc-cn_end sig_en=1de5f076a4f9b95465a68e1c2e61d00c -->
    </listitem>

   </itemizedlist>
  </sect2>

  <sect2 id="system-catalog-oid-assignment">
<!-- pgdoc-cn_start sig_en=9a60f7acf99d32d06a3a40f1bf603b13 sig_cn_org=None source=14.1 
   <title>OID Assignment</title>
________________________________________________________-->
   <title>OID分配</title>
<!-- pgdoc-cn_end sig_en=9a60f7acf99d32d06a3a40f1bf603b13 -->

<!-- pgdoc-cn_start sig_en=2d8933cf046d28a01872440962989105 sig_cn_org=None source=14.1 
   <para>
    A catalog row appearing in the initial data can be given a
    manually-assigned OID by writing an <literal>oid
    =&gt; <replaceable>nnnn</replaceable></literal> metadata field.
    Furthermore, if an OID is assigned, a C macro for that OID can be
    created by writing an <literal>oid_symbol
    =&gt; <replaceable>name</replaceable></literal> metadata field.
   </para>
________________________________________________________-->
   <para>
    通过写一个<literal>oid =&gt; <replaceable>nnnn</replaceable></literal>元数据域，出现在初始数据中的目录行可以被给予一个手工分配的OID。此外，如果分配一个OID，可以通过书写一个<literal>oid_symbol =&gt; <replaceable>name</replaceable></literal>元数据域为该OID创建一个C宏。
   </para>
<!-- pgdoc-cn_end sig_en=2d8933cf046d28a01872440962989105 -->

<!-- pgdoc-cn_start sig_en=81ab5ea9fafa38091ada7eb64ce42166 sig_cn_org=None source=14.1 
   <para>
    Pre-loaded catalog rows must have preassigned OIDs if there are OID
    references to them in other pre-loaded rows.  A preassigned OID is
    also needed if the row's OID must be referenced from C code.
    If neither case applies, the <literal>oid</literal> metadata field can
    be omitted, in which case the bootstrap code assigns an OID
    automatically.
    In practice we usually preassign OIDs for all or none of the pre-loaded
    rows in a given catalog, even if only some of them are actually
    cross-referenced.
   </para>
________________________________________________________-->
   <para>
    如果预装载的目录行被其他预装载行用OID引用，则必须给它们预先分配OID。如果行的OID必须被C代码引用，也需要预分配的OID。如果两种情况都不符合，则<literal>oid</literal>元数据域可以被省略，在这种情况下bootstrap代码会自动分配OID。实际上对于一个给定的目录，即便其中某些行实际并没有被交叉引用，我们也通常会为其中预装载的行全部预分配OID或者全部不分配OID。
   </para>
<!-- pgdoc-cn_end sig_en=81ab5ea9fafa38091ada7eb64ce42166 -->

<!-- pgdoc-cn_start sig_en=a7bbe92f3a3a39663cb39b840f7e7043 sig_cn_org=None source=14.1 
   <para>
    Writing the actual numeric value of any OID in C code is considered
    very bad form; always use a macro, instead.  Direct references
    to <structname>pg_proc</structname> OIDs are common enough that there's
    a special mechanism to create the necessary macros automatically;
    see <filename>src/backend/utils/Gen_fmgrtab.pl</filename>.  Similarly
    &mdash; but, for historical reasons, not done the same way &mdash;
    there's an automatic method for creating macros
    for <structname>pg_type</structname>
    OIDs.  <literal>oid_symbol</literal> entries are therefore not
    necessary in those two catalogs.  Likewise, macros for
    the <structname>pg_class</structname> OIDs of system catalogs and
    indexes are set up automatically.  For all other system catalogs, you
    have to manually specify any macros you need
    via <literal>oid_symbol</literal> entries.
   </para>
________________________________________________________-->
   <para>
    在C代码中写出任何OID的实际数字值是一种非常糟糕的形式，通常应该使用宏。对<structname>pg_proc</structname> OID的直接引用太常见了，因此有一种特别的机制自动创建必需的宏，见<filename>src/backend/utils/Gen_fmgrtab.pl</filename>。类似地 &mdash; 但是由于历史原因，实现的方式不同 &mdash; 也有一种自动的为<structname>pg_type</structname> OID创建宏的方法。因此在这两个目录中，<literal>oid_symbol</literal>项不是必需的。同样，系统目录和索引的<structname>pg_class</structname> OID的宏是自动设置的。对于所有其他系统目录，开发者必需通过<literal>oid_symbol</literal>项手动指定所需的宏。
   </para>
<!-- pgdoc-cn_end sig_en=a7bbe92f3a3a39663cb39b840f7e7043 -->

<!-- pgdoc-cn_start sig_en=cce82b392bd1ac35eb9016dc00b58fdf sig_cn_org=None source=14.1 
   <para>
    To find an available OID for a new pre-loaded row, run the
    script <filename>src/include/catalog/unused_oids</filename>.
    It prints inclusive ranges of unused OIDs (e.g., the output
    line <literal>45-900</literal> means OIDs 45 through 900 have not been
    allocated yet).  Currently, OIDs 1&ndash;9999 are reserved for manual
    assignment; the <filename>unused_oids</filename> script simply looks
    through the catalog headers and <filename>.dat</filename> files
    to see which ones do not appear.  You can also use
    the <filename>duplicate_oids</filename> script to check for mistakes.
    (<filename>genbki.pl</filename> will assign OIDs for any rows that
    didn't get one hand-assigned to them, and it will also detect duplicate
    OIDs at compile time.)
   </para>
________________________________________________________-->
   <para>
    要为一个新的预装载行找到一个可用的OID，可以运行脚本<filename>src/include/catalog/unused_oids</filename>。
    它能打印出未被使用的OID的闭区间范围（例如，输出行<literal>45-900</literal>表示OID 45到900都还没有被分配出去）。
    当前，OID 1&ndash;9999被保留给手工分配，<filename>unused_oids</filename>脚本会简单地查看目录头部以及<filename>.dat</filename>文件来看看哪些OID没有出现。
    也可以使用<filename>duplicate_oids</filename>脚本来检查错误（<filename>genbki.pl</filename>将为没有手工分配给他们的任何行分配OID，还会在编译时检测重复的OID）。
   </para>
<!-- pgdoc-cn_end sig_en=cce82b392bd1ac35eb9016dc00b58fdf -->

<!-- pgdoc-cn_start sig_en=1c7f8aa446194bb2b5ef41333b40d01a sig_cn_org=None source=14.1 
   <para>
    When choosing OIDs for a patch that is not expected to be committed
    immediately, best practice is to use a group of more-or-less
    consecutive OIDs starting with some random choice in the range
    8000&mdash;9999.  This minimizes the risk of OID collisions with other
    patches being developed concurrently.  To keep the 8000&mdash;9999
    range free for development purposes, after a patch has been committed
    to the master git repository its OIDs should be renumbered into
    available space below that range.  Typically, this will be done
    near the end of each development cycle, moving all OIDs consumed by
    patches committed in that cycle at the same time.  The script
    <filename>renumber_oids.pl</filename> can be used for this purpose.
    If an uncommitted patch is found to have OID conflicts with some
    recently-committed patch, <filename>renumber_oids.pl</filename> may
    also be useful for recovering from that situation.
   </para>
________________________________________________________-->
   <para>
    在为一个不会立即提交的补丁选择OID时，最佳实践是使用一组接近连续的OID，以8000&mdash;9999范围中随机选择的值作为开始。这样就将其与其他同时开发的补丁的冲突的风险降至最低。为了保持8000&mdash;9999范围对于开发来讲可自由使用，在补丁提交到git库之后，应使用低于该范围的可用空间重新编号。通常这项工作会在接近每次开发周期的尾声时做，与此同时移动由该周期提交的补丁所消费掉的所有OID。<filename>renumber_oids.pl</filename>脚本可用来完成该项工作。如果发现一个未提交的补丁与一些近来提交的补丁有OID冲突，<filename>renumber_oids.pl</filename>也可用于从此状况下的恢复。
   </para>
<!-- pgdoc-cn_end sig_en=1c7f8aa446194bb2b5ef41333b40d01a -->

<!-- pgdoc-cn_start sig_en=0d5218b37799e1b8b168775517a01fb7 sig_cn_org=None source=14.1 
   <para>
    Because of this convention of possibly renumbering OIDs assigned by
    patches, the OIDs assigned by a patch should not be considered stable
    until the patch has been included in an official release.  We do not
    change manually-assigned object OIDs once released, however, as that
    would create assorted compatibility problems.
   </para>
________________________________________________________-->
   <para>
    因为此约定可能会对补丁程序分配的OID重新编号，在补丁纳入到官方发布版本之前，补丁所分配的OID不应该认为是稳定的。一旦发布，我们并不修改手工分配的对象OID，但是那样会产生各种各样的兼容性问题。
   </para>
<!-- pgdoc-cn_end sig_en=0d5218b37799e1b8b168775517a01fb7 -->

<!-- pgdoc-cn_start sig_en=5b4e9a87cbfc87a4306db7e9760dbfe2 sig_cn_org=4138d35080e12541d67f50e202eb4830 source=15.7 
   <para>
    If <filename>genbki.pl</filename> needs to assign an OID to a catalog
    entry that does not have a manually-assigned OID, it will use a value in
    the range 10000&mdash;11999.  The server's OID counter is set to 10000
    at the start of a bootstrap run, so that any objects created on-the-fly
    during bootstrap processing also receive OIDs in this range.  (The
    usual OID assignment mechanism takes care of preventing any conflicts.)
   </para>
________________________________________________________-->
   <para>
    如果<filename>genbki.pl</filename>需要为一个没有手动分配OID的目录条目分配一个OID，它将使用范围在10000&mdash;11999之间的值。服务器的OID计数器在引导运行开始时设置为10000，因此在引导处理期间动态创建的任何对象也会收到此范围内的OID。（通常的OID分配机制会确保不会发生任何冲突。）
</para>
<!-- pgdoc-cn_end sig_en=5b4e9a87cbfc87a4306db7e9760dbfe2 -->

<!-- pgdoc-cn_start sig_en=8c45e7c3dcdcb327789166f2d0bba8d5 sig_cn_org=d721bcf25f9fd84f80b6318b08a92b42 source=15.7 
   <para>
    Objects with OIDs below <symbol>FirstUnpinnedObjectId</symbol> (12000)
    are considered <quote>pinned</quote>, preventing them from being
    deleted.  (There are a small number of exceptions, which are
    hard-wired into <function>IsPinnedObject()</function>.)
    <application>initdb</application> forces the OID counter up
    to <symbol>FirstUnpinnedObjectId</symbol> as soon as it's ready to
    create unpinned objects.  Thus objects created during the later phases
    of <application>initdb</application>, such as objects created while
    running the <filename>information_schema.sql</filename> script, will
    not be pinned, while all objects known
    to <filename>genbki.pl</filename> will be.
   </para>
________________________________________________________-->
   <para>
    对象的OID低于<symbol>FirstUnpinnedObjectId</symbol>（12000）被视为<quote>pinned</quote>，防止它们被删除。
    （有一小部分例外情况，这些例外情况被硬编码到<function>IsPinnedObject()</function>中。）
    <application>initdb</application>在准备好创建未固定对象时，会将OID计数器提升到<symbol>FirstUnpinnedObjectId</symbol>。
    因此，在<application>initdb</application>的后期阶段创建的对象，比如在运行<filename>information_schema.sql</filename>脚本时创建的对象，将不会被固定，而所有被<filename>genbki.pl</filename>知道的对象将被固定。
</para>
<!-- pgdoc-cn_end sig_en=8c45e7c3dcdcb327789166f2d0bba8d5 -->

<!-- pgdoc-cn_start sig_en=831ea4b714b812b79686d9140cc52534 sig_cn_org=3a5e3b28e13abe7bc0101175b3e85cf6 source=15.7 
   <para>
    OIDs assigned during normal database operation are constrained to be
    16384 or higher.  This ensures that the range 10000&mdash;16383 is free
    for OIDs assigned automatically by <filename>genbki.pl</filename> or
    during <application>initdb</application>.  These
    automatically-assigned OIDs are not considered stable, and may change
    from one installation to another.
   </para>
________________________________________________________-->
   <para>
    在正常数据库操作期间分配的OID受到限制，必须为16384或更高。这确保了范围10000&mdash;16383
    为<filename>genbki.pl</filename>或在<application>initdb</application>期间自动分配的OID保留。
    这些自动分配的OID不被视为稳定，并且可能在不同的安装中发生变化。
</para>
<!-- pgdoc-cn_end sig_en=831ea4b714b812b79686d9140cc52534 -->
  </sect2>

  <sect2 id="system-catalog-oid-references">
<!-- pgdoc-cn_start sig_en=801ce86419a436a9f3cdba3ca11698b4 sig_cn_org=None source=14.1 
   <title>OID Reference Lookup</title>
________________________________________________________-->
   <title>OID引用查找</title>
<!-- pgdoc-cn_end sig_en=801ce86419a436a9f3cdba3ca11698b4 -->

<!-- pgdoc-cn_start sig_en=3b73f9852750851e17bdc5fd71c39299 sig_cn_org=None source=14.1 
   <para>
    In principle, cross-references from one initial catalog row to another
    could be written just by writing the preassigned OID of the referenced
    row in the referencing field.  However, that is against project
    policy, because it is error-prone, hard to read, and subject to
    breakage if a newly-assigned OID is renumbered.  Therefore
    <filename>genbki.pl</filename> provides mechanisms to write
    symbolic references instead.
    The rules are as follows:
   </para>
________________________________________________________-->
   <para>
    原则上，从一个初始目录行到另一个初始目录行的交叉引用只需要在引用字段中写上被引用行的预分配OID就可以实现。但是这违反了项目策略，因为它容易出错，难理解，并且如果新分配的OID重新编号的话容易损坏。因此<filename>genbki.pl</filename>提供了替代的方式来编写符号引用。规则如下：
   </para>
<!-- pgdoc-cn_end sig_en=3b73f9852750851e17bdc5fd71c39299 -->

   <itemizedlist>

    <listitem>
<!-- pgdoc-cn_start sig_en=c523c7442361cacbf5be2bb3566d87e6 sig_cn_org=None source=14.1 
     <para>
      Use of symbolic references is enabled in a particular catalog column
      by attaching <literal>BKI_LOOKUP(<replaceable>lookuprule</replaceable>)</literal>
      to the column's definition, where <replaceable>lookuprule</replaceable>
      is the name of the referenced catalog, e.g., <literal>pg_proc</literal>.
      <literal>BKI_LOOKUP</literal> can be attached to columns of
      type <type>Oid</type>, <type>regproc</type>, <type>oidvector</type>,
      or <type>Oid[]</type>; in the latter two cases it implies performing a
      lookup on each element of the array.
     </para>
________________________________________________________-->
     <para>
      通过对特定的目录列定义附加<literal>BKI_LOOKUP(<replaceable>lookuprule</replaceable>)</literal>来开启对符号化引用的使用，其中<replaceable>lookuprule</replaceable>是被引用目录的名称，例如<literal>pg_proc</literal>。<literal>BKI_LOOKUP</literal>可以被附加到类型为<type>oid</type>、<type>regproc</type>、<type>oidvector</type>或者<type>Oid[]</type>的列上，在后两种情况中它意味着在数组的每个元素上执行查找。
     </para>
<!-- pgdoc-cn_end sig_en=c523c7442361cacbf5be2bb3566d87e6 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=2d618e13b448c0a972992f1dadb7d219 sig_cn_org=None source=14.1 
     <para>
      It's also permissible to attach <literal>BKI_LOOKUP(encoding)</literal>
      to integer columns to reference character set encodings, which are
      not currently represented as catalog OIDs, but have a set of values
      known to <filename>genbki.pl</filename>.
     </para>
________________________________________________________-->
     <para>
      也允许将<literal>BKI_LOOKUP(encoding)</literal>附加到整数列以引用字符集编码，字符集编码目前还没有表示为目录OID，但有对于<filename>genbki.pl</filename>已知的一组值。
     </para>
<!-- pgdoc-cn_end sig_en=2d618e13b448c0a972992f1dadb7d219 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=95da23b2f62389577c553edd82d36a4b sig_cn_org=None source=14.1 
     <para>
      In some catalog columns, it's allowed for entries to be zero instead
      of a valid reference.  If this is allowed, write
      <literal>BKI_LOOKUP_OPT</literal> instead
      of <literal>BKI_LOOKUP</literal>.  Then you can
      write <literal>0</literal> for an entry.  (If the column is
      declared <type>regproc</type>, you can optionally
      write <literal>-</literal> instead of <literal>0</literal>.)
      Except for this special case, all entries in
      a <literal>BKI_LOOKUP</literal> column must be symbolic references.
      <filename>genbki.pl</filename> will warn about unrecognized names.
     </para>
________________________________________________________-->
     <para>
      在一些目录列，允许条目为零而不是有效的引用。如果这是允许的，写<literal>BKI_LOOKUP_OPT</literal>而不是<literal>BKI_LOOKUP</literal>。
      然后你能对一个条目写<literal>0</literal> 。(如果列为<type>regproc</type>声明，你可以有选择的写<literal>-</literal>而不是<literal>0</literal>。)
      除了这种特殊情况外，<literal>BKI_LOOKUP</literal>列中的所有条目都必须是符号引用。<filename>genbki.pl</filename>将会警告无法识别的名称。	  
     </para>
<!-- pgdoc-cn_end sig_en=95da23b2f62389577c553edd82d36a4b -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=28c9f884ca679cb7041d4571b2e644ed sig_cn_org=None source=14.1 
     <para>
      Most kinds of catalog objects are simply referenced by their names.
      Note that type names must exactly match the
      referenced <structname>pg_type</structname>
      entry's <structfield>typname</structfield>; you do not get to use
      any aliases such as <literal>integer</literal>
      for <literal>int4</literal>.
     </para>
________________________________________________________-->
     <para>
      大多数种类的目录对象仅通过其名称引用。注意类型的名称必须完全匹配被引用的<structname>pg_type</structname>项的<structfield>typname</structfield>，不能使用任何别名，例如用<literal>integer</literal>来替代<literal>int4</literal>。。
     </para>
<!-- pgdoc-cn_end sig_en=28c9f884ca679cb7041d4571b2e644ed -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=ac2efd2929a739b632b438c3a13993ad sig_cn_org=None source=14.1 
     <para>
      A function can be represented by
      its <structfield>proname</structfield>, if that is unique among
      the <filename>pg_proc.dat</filename> entries (this works like regproc
      input).  Otherwise, write it
      as <replaceable>proname(argtypename,argtypename,...)</replaceable>,
      like regprocedure.  The argument type names must be spelled exactly as
      they are in the <filename>pg_proc.dat</filename> entry's
      <structfield>proargtypes</structfield> field.  Do not insert any
      spaces.
     </para>
________________________________________________________-->
     <para>
      函数可以用其<structfield>proname</structfield>来表示，前提是它在<filename>pg_proc.dat</filename>项中是唯一的（这和regproc输入类似）。否则，要将函数写成<replaceable>proname(argtypename,argtypename,...)</replaceable>，就像regprocedure那样。参数的类型名称必须被拼写准确，和它们在<filename>pg_proc.dat</filename>项的<structfield>proargtypes</structfield>域中的值一致。不要插入任何空白。
     </para>
<!-- pgdoc-cn_end sig_en=ac2efd2929a739b632b438c3a13993ad -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=1463455f16a8f879e837b99f27bb2174 sig_cn_org=None source=14.1 
     <para>
      Operators are represented
      by <replaceable>oprname(lefttype,righttype)</replaceable>,
      writing the type names exactly as they appear in
      the <filename>pg_operator.dat</filename>
      entry's <structfield>oprleft</structfield>
      and <structfield>oprright</structfield> fields.
      (Write <literal>0</literal> for the omitted operand of a unary
      operator.)
     </para>
________________________________________________________-->
     <para>
      操作符的名称由<replaceable>oprname(lefttype,righttype)</replaceable>表示，类型的名称要写得准确，与它们出现在<filename>pg_operator.dat</filename>项的<structfield>oprleft</structfield>和<structfield>oprright</structfield>域中的值一样（对于一元操作符省略的操作数，可以写成<literal>0</literal>）。
     </para>
<!-- pgdoc-cn_end sig_en=1463455f16a8f879e837b99f27bb2174 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=9d0a87a25270ddeb527fe27a531d4ef5 sig_cn_org=None source=14.1 
     <para>
      The names of opclasses and opfamilies are only unique within an
      access method, so they are represented
      by <replaceable>access_method_name</replaceable><literal>/</literal><replaceable>object_name</replaceable>.
     </para>
________________________________________________________-->
     <para>
      操作符类和操作符族的名称仅在一个访问方法中唯一，因此它们用<replaceable>access_method_name</replaceable><literal>/</literal><replaceable>object_name</replaceable>表示。
     </para>
<!-- pgdoc-cn_end sig_en=9d0a87a25270ddeb527fe27a531d4ef5 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=d05725f8e9508e73bfae7be5fc466f90 sig_cn_org=None source=14.1 
     <para>
      In none of these cases is there any provision for
      schema-qualification; all objects created during bootstrap are
      expected to be in the <literal>pg_catalog</literal> schema.
     </para>
________________________________________________________-->
     <para>
      在这些情况中都不能有模式限定，所有在bootstrap期间创建的对象都应该出现在<literal>pg_catalog</literal>模式中。
     </para>
<!-- pgdoc-cn_end sig_en=d05725f8e9508e73bfae7be5fc466f90 -->
    </listitem>
   </itemizedlist>

<!-- pgdoc-cn_start sig_en=23719e9b8477382950900a080b4cc8ad sig_cn_org=None source=14.1 
   <para>
    <filename>genbki.pl</filename> resolves all symbolic references while it
    runs, and puts simple numeric OIDs into the emitted BKI file.  There is
    therefore no need for the bootstrap backend to deal with symbolic
    references.
   </para>
________________________________________________________-->
   <para>
    <filename>genbki.pl</filename>在运行时会解决所有符号化引用并且把简单的数字OID放到输出的BKI文件中。因此不需要bootstrap后端处理符号化引用。
   </para>
<!-- pgdoc-cn_end sig_en=23719e9b8477382950900a080b4cc8ad -->

<!-- pgdoc-cn_start sig_en=7b36042f64394fa47ea3341051e5f2cb sig_cn_org=None source=14.1 
   <para>
    It's desirable to mark OID reference columns
    with <literal>BKI_LOOKUP</literal> or <literal>BKI_LOOKUP_OPT</literal>
    even if the catalog has no initial data that requires lookup.  This
    allows <filename>genbki.pl</filename> to record the foreign key
    relationships that exist in the system catalogs.  That information is
    used in the regression tests to check for incorrect entries.  See also
    the macros <literal>DECLARE_FOREIGN_KEY</literal>,
    <literal>DECLARE_FOREIGN_KEY_OPT</literal>,
    <literal>DECLARE_ARRAY_FOREIGN_KEY</literal>,
    and <literal>DECLARE_ARRAY_FOREIGN_KEY_OPT</literal>, which are
    used to declare foreign key relationships that are too complex
    for <literal>BKI_LOOKUP</literal> (typically, multi-column foreign
    keys).
   </para>
________________________________________________________-->
   <para>
    将OID引用列标记为<literal>BKI_LOOKUP</literal>或<literal>BKI_LOOKUP_OPT</literal>是较为可取的，即使目录没有需要查找的初始数据。
    这允许<filename>genbki.pl</filename>记录已经存在系统目录中的外键的关系。这些信息在回归测试中用于检查不正确的条目。
    也可参见宏 <literal>DECLARE_FOREIGN_KEY</literal>,<literal>DECLARE_FOREIGN_KEY_OPT</literal>,<literal>DECLARE_ARRAY_FOREIGN_KEY</literal>,
    和 <literal>DECLARE_ARRAY_FOREIGN_KEY_OPT</literal>，用于声明<literal>BKI_LOOKUP</literal>过于复杂的外键关系（通常是，多列外键）。
   </para>
<!-- pgdoc-cn_end sig_en=7b36042f64394fa47ea3341051e5f2cb -->
  </sect2>

  <sect2 id="system-catalog-auto-array-types">
<!-- pgdoc-cn_start sig_en=e8f0772d959bc155e85f25e416d6c5b9 sig_cn_org=None source=14.1 
   <title>Automatic Creation of Array Types</title>
________________________________________________________-->
   <title>数组类型的自动创建</title>
<!-- pgdoc-cn_end sig_en=e8f0772d959bc155e85f25e416d6c5b9 -->

<!-- pgdoc-cn_start sig_en=a7e804c5b6447844799f61db8faf5e28 sig_cn_org=None source=14.1 
   <para>
    Most scalar data types should have a corresponding array type (that is,
    a standard varlena array type whose element type is the scalar type, and
    which is referenced by the <structfield>typarray</structfield> field of
    the scalar type's <structname>pg_type</structname>
    entry).  <filename>genbki.pl</filename> is able to generate
    the <structname>pg_type</structname> entry for the array type
    automatically in most cases.
   </para>
________________________________________________________-->
   <para>
    大多数标量数据类型应该有一相应的数组类型（即元素类型为标量类型的标准变长数组类型，该类型由标量类型的<structname>pg_type</structname>条目的<structfield>typarray</structfield>字段引用）。<filename>genbki.pl</filename>在大多数情况下能够自动为数组类型生成<structname>pg_type</structname>条目。
   </para>
<!-- pgdoc-cn_end sig_en=a7e804c5b6447844799f61db8faf5e28 -->

<!-- pgdoc-cn_start sig_en=7129e9bb1e72aa37f44921ae1712041f sig_cn_org=None source=14.1 
   <para>
    To use this facility, just write an <literal>array_type_oid
    =&gt; <replaceable>nnnn</replaceable></literal> metadata field in the
    scalar type's <structname>pg_type</structname> entry, specifying the OID
    to use for the array type.  You may then omit
    the <structfield>typarray</structfield> field, since it will be filled
    automatically with that OID.
   </para>
________________________________________________________-->
   <para>
    要使用此工具，只需在标量类型的<structname>pg_type</structname>条目中写入<literal>array_type_oid =&gt; <replaceable>nnnn</replaceable></literal>元数据字段，指定要用于数组类型的OID。然后可以省略<structfield>typarray</structfield>字段，因为它会使用该OID自动填充。
   </para>
<!-- pgdoc-cn_end sig_en=7129e9bb1e72aa37f44921ae1712041f -->

<!-- pgdoc-cn_start sig_en=9bd6f8c646f20559bda263b44f6035a4 sig_cn_org=None source=14.1 
   <para>
    The generated array type's name is the scalar type's name with an
    underscore prepended.  The array entry's other fields are filled from
    <literal>BKI_ARRAY_DEFAULT(<replaceable>value</replaceable>)</literal>
    annotations in <filename>pg_type.h</filename>, or if there isn't one,
    copied from the scalar type.  (There's also a special case
    for <structfield>typalign</structfield>.)  Then
    the <structfield>typelem</structfield>
    and <structfield>typarray</structfield> fields of the two entries are
    set to cross-reference each other.
   </para>
________________________________________________________-->
   <para>
    生成的数组类型名是标量类型名称，前面加下划线。数组条目的其他字段由pg_type.h中的<literal>BKI_ARRAY_DEFAULT(<replaceable>value</replaceable>)</literal>注释填充，如果没有则从标量类型复制。（对于<structfield>typalign</structfield>也有一种特殊情况）然后，将两个条目的<structfield>typelem</structfield>和<structfield>typarray</structfield>字段设置为相互交叉引用。
   </para>
<!-- pgdoc-cn_end sig_en=9bd6f8c646f20559bda263b44f6035a4 -->
  </sect2>

  <sect2 id="system-catalog-recipes">
<!-- pgdoc-cn_start sig_en=c75353bdbbebd55d5b678c152b069031 sig_cn_org=None source=14.1 
   <title>Recipes for Editing Data Files</title>
________________________________________________________-->
   <title>编辑数据文件的方法</title>
<!-- pgdoc-cn_end sig_en=c75353bdbbebd55d5b678c152b069031 -->

<!-- pgdoc-cn_start sig_en=92283314958e4de5a8481a387e4956c8 sig_cn_org=None source=14.1 
   <para>
    Here are some suggestions about the easiest ways to perform common tasks
    when updating catalog data files.
   </para>
________________________________________________________-->
   <para>
    在更新目录数据文件时，对于执行常用任务的简便方法，这里有一些建议。
   </para>
<!-- pgdoc-cn_end sig_en=92283314958e4de5a8481a387e4956c8 -->

   <formalpara>
<!-- pgdoc-cn_start sig_en=f1c3909231faab26c6d37a6e2b3ba6fd sig_cn_org=None source=14.1 
    <title>Add a new column with a default to a catalog:</title>
________________________________________________________-->
    <title>向一个目录增加一个带有默认值的新列：</title>
<!-- pgdoc-cn_end sig_en=f1c3909231faab26c6d37a6e2b3ba6fd -->
<!-- pgdoc-cn_start sig_en=295d6c535bf5cf8de8742d3f97c8ba0a sig_cn_org=None source=14.1 
    <para>
     Add the column to the header file with
     a <literal>BKI_DEFAULT(<replaceable>value</replaceable>)</literal>
     annotation.  The data file need only be adjusted by adding the field
     in existing rows where a non-default value is needed.
    </para>
________________________________________________________-->
    <para>
     用<literal>BKI_DEFAULT(<replaceable>value</replaceable>)</literal>标注将列增加到头文件中。数据文件的调整仅需要在要求非默认值的现有行中增加该域即可。
    </para>
<!-- pgdoc-cn_end sig_en=295d6c535bf5cf8de8742d3f97c8ba0a -->
   </formalpara>

   <formalpara>
<!-- pgdoc-cn_start sig_en=5392ddb68bd0804d416f0e61201e8d96 sig_cn_org=None source=14.1 
    <title>Add a default value to an existing column that doesn't have
     one:</title>
________________________________________________________-->
    <title>为没有默认值的现有列增加默认值：</title>
<!-- pgdoc-cn_end sig_en=5392ddb68bd0804d416f0e61201e8d96 -->
<!-- pgdoc-cn_start sig_en=32218f7846423c80cab13de7043828d8 sig_cn_org=None source=14.1 
    <para>
     Add a <literal>BKI_DEFAULT</literal> annotation to the header file,
     then run <literal>make reformat-dat-files</literal> to remove
     now-redundant field entries.
    </para>
________________________________________________________-->
    <para>
     在头文件中增加一个<literal>BKI_DEFAULT</literal>标注，然后运行<literal>make reformat-dat-files</literal>以移除现在变得冗余的域项。
    </para>
<!-- pgdoc-cn_end sig_en=32218f7846423c80cab13de7043828d8 -->
   </formalpara>

   <formalpara>
<!-- pgdoc-cn_start sig_en=253bf61fab83bd17424267027371f073 sig_cn_org=None source=14.1 
    <title>Remove a column, whether it has a default or not:</title>
________________________________________________________-->
    <title>移除一列（不管有默认值还是没有）：</title>
<!-- pgdoc-cn_end sig_en=253bf61fab83bd17424267027371f073 -->
<!-- pgdoc-cn_start sig_en=b5b6ee8a47417d807888cae45c167a94 sig_cn_org=None source=14.1 
    <para>
     Remove the column from the header, then run <literal>make
     reformat-dat-files</literal> to remove now-useless field entries.
    </para>
________________________________________________________-->
    <para>
     从头文件中移除该列，然后运行<literal>make reformat-dat-files</literal>以移除现在无用的域项。
    </para>
<!-- pgdoc-cn_end sig_en=b5b6ee8a47417d807888cae45c167a94 -->
   </formalpara>

   <formalpara>
<!-- pgdoc-cn_start sig_en=b9324dbb5b01b1e360c11ba06fe0f9cb sig_cn_org=None source=14.1 
    <title>Change or remove an existing default value:</title>
________________________________________________________-->
    <title>更改或者移除现有的默认值：</title>
<!-- pgdoc-cn_end sig_en=b9324dbb5b01b1e360c11ba06fe0f9cb -->
<!-- pgdoc-cn_start sig_en=77dfcfdbb4e6628e811964c425c43306 sig_cn_org=None source=14.1 
    <para>
     You cannot simply change the header file, since that will cause the
     current data to be interpreted incorrectly.  First run <literal>make
     expand-dat-files</literal> to rewrite the data files with all
     default values inserted explicitly, then change or remove
     the <literal>BKI_DEFAULT</literal> annotation, then run <literal>make
     reformat-dat-files</literal> to remove superfluous fields again.
    </para>
________________________________________________________-->
    <para>
     不能简单地更改头文件，因为这将会导致当前的数据被不正确地解读。首先运行<literal>make
     expand-dat-files</literal>用显式插入所有默认值的形式重写数据文件，然后更改或者移除<literal>BKI_DEFAULT</literal>标注，然后运行<literal>make reformat-dat-files</literal>移除多余的域。
    </para>
<!-- pgdoc-cn_end sig_en=77dfcfdbb4e6628e811964c425c43306 -->
   </formalpara>

   <formalpara>
<!-- pgdoc-cn_start sig_en=a76e5aaa57ba0aa1ebce17dbfeac6d24 sig_cn_org=None source=14.1 
    <title>Ad-hoc bulk editing:</title>
________________________________________________________-->
    <title>临时批量编辑：</title>
<!-- pgdoc-cn_end sig_en=a76e5aaa57ba0aa1ebce17dbfeac6d24 -->
<!-- pgdoc-cn_start sig_en=759527364f142d73fe83409fdca878ae sig_cn_org=None source=14.1 
    <para>
     <filename>reformat_dat_file.pl</filename> can be adapted to perform
     many kinds of bulk changes.  Look for its block comments showing where
     one-off code can be inserted.  In the following example, we are going
     to consolidate two Boolean fields in <structname>pg_proc</structname>
     into a char field:

     <orderedlist>
      <listitem>
       <para>
        Add the new column, with a default,
        to <filename>pg_proc.h</filename>:
<programlisting>
+    /* see PROKIND_ categories below */
+    char        prokind BKI_DEFAULT(f);
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        Create a new script based on <filename>reformat_dat_file.pl</filename>
        to insert appropriate values on-the-fly:
<programlisting>
-           # At this point we have the full row in memory as a hash
-           # and can do any operations we want. As written, it only
-           # removes default values, but this script can be adapted to
-           # do one-off bulk-editing.
+           # One-off change to migrate to prokind
+           # Default has already been filled in by now, so change to other
+           # values as appropriate
+           if ($values{proisagg} eq 't')
+           {
+               $values{prokind} = 'a';
+           }
+           elsif ($values{proiswindow} eq 't')
+           {
+               $values{prokind} = 'w';
+           }
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        Run the new script:
<programlisting>
$ cd src/include/catalog
$ perl  rewrite_dat_with_prokind.pl  pg_proc.dat
</programlisting>
        At this point <filename>pg_proc.dat</filename> has all three
        columns, <structfield>prokind</structfield>,
        <structfield>proisagg</structfield>,
        and <structfield>proiswindow</structfield>, though they will appear
        only in rows where they have non-default values.
       </para>
      </listitem>

      <listitem>
       <para>
        Remove the old columns from <filename>pg_proc.h</filename>:
<programlisting>
-    /* is it an aggregate? */
-    bool        proisagg BKI_DEFAULT(f);
-
-    /* is it a window function? */
-    bool        proiswindow BKI_DEFAULT(f);
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        Finally, run <literal>make reformat-dat-files</literal> to remove
        the useless old entries from <filename>pg_proc.dat</filename>.
       </para>
      </listitem>
     </orderedlist>

     For further examples of scripts used for bulk editing, see
     <filename>convert_oid2name.pl</filename>
     and <filename>remove_pg_type_oid_symbols.pl</filename> attached to this
     message:
     <ulink url="https://www.postgresql.org/message-id/CAJVSVGVX8gXnPm+Xa=DxR7kFYprcQ1tNcCT5D0O3ShfnM6jehA@mail.gmail.com"></ulink>
    </para>
________________________________________________________-->
    <para>
     可以修改<filename>reformat_dat_file.pl</filename>执行很多种批量更改。寻找其中展示可以插入一次性代码的注释块。在下面的例子中，我们将把<structname>pg_proc</structname>中的两个Boolean域联合成一个char域：

     <orderedlist>
      <listitem>
       <para>
        在<filename>pg_proc.h</filename>中增加一个带有默认值的新列：
<programlisting>
+    /* see PROKIND_ categories below */
+    char        prokind BKI_DEFAULT(f);
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        基于<filename>reformat_dat_file.pl</filename>创建一个新脚本以插入合适的值：
<programlisting>
-           # At this point we have the full row in memory as a hash
-           # and can do any operations we want. As written, it only
-           # removes default values, but this script can be adapted to
-           # do one-off bulk-editing.
+           # One-off change to migrate to prokind
+           # Default has already been filled in by now, so change to other
+           # values as appropriate
+           if ($values{proisagg} eq 't')
+           {
+               $values{prokind} = 'a';
+           }
+           elsif ($values{proiswindow} eq 't')
+           {
+               $values{prokind} = 'w';
+           }
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        运行新的脚本：
<programlisting>
$ cd src/include/catalog
$ perl  rewrite_dat_with_prokind.pl  pg_proc.dat
</programlisting>
        到这里<filename>pg_proc.dat</filename>拥有所有三个列<structfield>prokind</structfield>、<structfield>proisagg</structfield>以及<structfield>proiswindow</structfield>，不过它们将只出现在它们有非默认值的行中。
       </para>
      </listitem>

      <listitem>
       <para>
        从<filename>pg_proc.h</filename>移除旧的列：
<programlisting>
-    /* is it an aggregate? */
-    bool        proisagg BKI_DEFAULT(f);
-
-    /* is it a window function? */
-    bool        proiswindow BKI_DEFAULT(f);
</programlisting>
       </para>
      </listitem>

      <listitem>
       <para>
        最后，运行<literal>make reformat-dat-files</literal>从<filename>pg_proc.dat</filename>中移除无用的旧项。
       </para>
      </listitem>
     </orderedlist>

     用于批量编辑的脚本的更多例子，请参考这个消息<ulink url="https://www.postgresql.org/message-id/CAJVSVGVX8gXnPm+Xa=DxR7kFYprcQ1tNcCT5D0O3ShfnM6jehA@mail.gmail.com"></ulink>的附件<filename>convert_oid2name.pl</filename>和<filename>remove_pg_type_oid_symbols.pl</filename>。
    </para>
<!-- pgdoc-cn_end sig_en=759527364f142d73fe83409fdca878ae -->
   </formalpara>
  </sect2>
 </sect1>

 <sect1 id="bki-format">
<!-- pgdoc-cn_start sig_en=095075770fef1b7667c76ffde782d0e4 sig_cn_org=None source=14.1 
  <title><acronym>BKI</acronym> File Format</title>
________________________________________________________-->
  <title><acronym>BKI</acronym>文件格式</title>
<!-- pgdoc-cn_end sig_en=095075770fef1b7667c76ffde782d0e4 -->

<!-- pgdoc-cn_start sig_en=37a2a207d89b463d776f9874ed3e0d94 sig_cn_org=None source=14.1 
  <para>
   This section describes how the <productname>PostgreSQL</productname>
   backend interprets <acronym>BKI</acronym> files.  This description
   will be easier to understand if the <filename>postgres.bki</filename>
   file is at hand as an example.
  </para>
________________________________________________________-->
  <para>
   本节描述<productname>PostgreSQL</productname>后端如何解释<acronym>BKI</acronym>文件。结合一份实际的<filename>postgres.bki</filename>文件，本节的内容将会更容易理解。
  </para>
<!-- pgdoc-cn_end sig_en=37a2a207d89b463d776f9874ed3e0d94 -->

<!-- pgdoc-cn_start sig_en=fe4ac77ac6438b7c1369a56a2469bbbe sig_cn_org=None source=14.1 
  <para>
   <acronym>BKI</acronym> input consists of a sequence of commands.  Commands are made up
   of a number of tokens, depending on the syntax of the command.
   Tokens are usually separated by whitespace, but need not be if
   there is no ambiguity.  There is no special command separator; the
   next token that syntactically cannot belong to the preceding
   command starts a new one.  (Usually you would put a new command on
   a new line, for clarity.)  Tokens can be certain key words, special
   characters (parentheses, commas, etc.), identifiers, numbers, or
   single-quoted strings.  Everything is case sensitive.
  </para>
________________________________________________________-->
  <para>
   <acronym>BKI</acronym>输入由一个命令序列组成。根据命令的语法，命令由一系列记号构成。记号之间通常由空白分隔，但是在没有歧义时也可不用。
   没有什么特殊的命令分隔符；语法上无法属于前一命令的记号将开始新的一条命令（通常你会把一个新命令放在一个新行上以保持清晰）。 
   记号可以是某些关键字、特殊字符（圆括弧，逗号等）、标识符、数字或者单引号字串。 所有东西都是大小写敏感的。
  </para>
<!-- pgdoc-cn_end sig_en=fe4ac77ac6438b7c1369a56a2469bbbe -->

<!-- pgdoc-cn_start sig_en=858f05dae8fa7da7a3c8b7cbea6e00fb sig_cn_org=None source=14.1 
  <para>
   Lines starting with <literal>#</literal> are ignored.
  </para>
________________________________________________________-->
  <para>
   以<literal>#</literal>开头的行会被忽略。
  </para>
<!-- pgdoc-cn_end sig_en=858f05dae8fa7da7a3c8b7cbea6e00fb -->

 </sect1>

 <sect1 id="bki-commands">
<!-- pgdoc-cn_start sig_en=1f99b6144dea6460e6f401af033a8e48 sig_cn_org=None source=14.1 
  <title><acronym>BKI</acronym> Commands</title>
________________________________________________________-->
  <title><acronym>BKI</acronym>命令</title>
<!-- pgdoc-cn_end sig_en=1f99b6144dea6460e6f401af033a8e48 -->

  <variablelist>
   <varlistentry>
<!-- pgdoc-cn_start sig_en=80e3b1d35c0a8f437b2d769057855324 sig_cn_org=None source=14.1 
    <term>
     <literal>create</literal>
     <replaceable class="parameter">tablename</replaceable>
     <replaceable class="parameter">tableoid</replaceable>
     <optional><literal>bootstrap</literal></optional>
     <optional><literal>shared_relation</literal></optional>
     <optional><literal>rowtype_oid</literal> <replaceable>oid</replaceable></optional>
     (<replaceable class="parameter">name1</replaceable> =
     <replaceable class="parameter">type1</replaceable>
     <optional><literal>FORCE NOT NULL</literal> | <literal>FORCE NULL</literal> </optional> <optional>,
     <replaceable class="parameter">name2</replaceable> =
     <replaceable class="parameter">type2</replaceable>
     <optional><literal>FORCE NOT NULL</literal> | <literal>FORCE NULL</literal> </optional>,
     ...</optional>)
    </term>
________________________________________________________-->
    <term>
     <literal>create</literal>
     <replaceable class="parameter">tablename</replaceable>
     <replaceable class="parameter">tableoid</replaceable>
     <optional><literal>bootstrap</literal></optional>
     <optional><literal>shared_relation</literal></optional>
     <optional><literal>rowtype_oid</literal> <replaceable>oid</replaceable></optional>
     (<replaceable class="parameter">name1</replaceable> =
     <replaceable class="parameter">type1</replaceable>
     <optional><literal>FORCE NOT NULL</literal> | <literal>FORCE NULL</literal> </optional> <optional>,
     <replaceable class="parameter">name2</replaceable> =
     <replaceable class="parameter">type2</replaceable>
     <optional><literal>FORCE NOT NULL</literal> | <literal>FORCE NULL</literal> </optional>,
     ...</optional>)
    </term>
<!-- pgdoc-cn_end sig_en=80e3b1d35c0a8f437b2d769057855324 -->

    <listitem>
<!-- pgdoc-cn_start sig_en=87d5e66780bb2e4d2baffba8dca73f56 sig_cn_org=None source=14.1 
     <para>
      Create a table named <replaceable
      class="parameter">tablename</replaceable>, and having the OID
      <replaceable class="parameter">tableoid</replaceable>,
      with the columns given in parentheses.
     </para>
________________________________________________________-->
     <para>
      创建一个叫做<replaceable class="parameter">tablename</replaceable>，OID为<replaceable class="parameter">tableoid</replaceable>的表，它的列在圆括弧中给出。
     </para>
<!-- pgdoc-cn_end sig_en=87d5e66780bb2e4d2baffba8dca73f56 -->

<!-- pgdoc-cn_start sig_en=fd56cee4a1655b5feadeb768a8313d62 sig_cn_org=None source=14.1 
     <para>
      The following column types are supported directly by
      <filename>bootstrap.c</filename>: <type>bool</type>,
      <type>bytea</type>, <type>char</type> (1 byte),
      <type>name</type>, <type>int2</type>,
      <type>int4</type>, <type>regproc</type>, <type>regclass</type>,
      <type>regtype</type>, <type>text</type>,
      <type>oid</type>, <type>tid</type>, <type>xid</type>,
      <type>cid</type>, <type>int2vector</type>, <type>oidvector</type>,
      <type>_int4</type> (array), <type>_text</type> (array),
      <type>_oid</type> (array), <type>_char</type> (array),
      <type>_aclitem</type> (array).  Although it is possible to create
      tables containing columns of other types, this cannot be done until
      after <structname>pg_type</structname> has been created and filled with
      appropriate entries.  (That effectively means that only these
      column types can be used in bootstrap catalogs, but non-bootstrap
      catalogs can contain any built-in type.)
     </para>
________________________________________________________-->
     <para>
      <filename>bootstrap.c</filename>直接支持下列列类型：<type>bool</type>、<type>bytea</type>、<type>char</type>（1 字节）、<type>name</type>、<type>int2</type>、<type>int4</type>、<type>regproc</type>、<type>regclass</type>、<type>regtype</type>、<type>text</type>、<type>oid</type>、<type>tid</type>、<type>xid</type>、<type>cid</type>、<type>int2vector</type>、<type>oidvector</type>、<type>_int4</type>（数组）、<type>_text</type>（数组）、<type>_oid</type>（数组）、<type>_char</type>（数组）、<type>_aclitem</type>（数组）。尽管我们可以创建包含其它类型列的表， 但是我们只有在创建完<structname>pg_type</structname>并且填充了合适的记录之后才行（这实际上就意味着在自举目录中，只能使用这些列类型，而非自举目录可以使用任意内置类型）。
     </para>
<!-- pgdoc-cn_end sig_en=fd56cee4a1655b5feadeb768a8313d62 -->

<!-- pgdoc-cn_start sig_en=3f7bb1cb2582fb7bb35b43e94c4ed5a2 sig_cn_org=53566d2cb68c529ec8a0e6abe0724a25 source=15.7 
     <para>
      When <literal>bootstrap</literal> is specified,
      the table will only be created on disk; nothing is entered into
      <structname>pg_class</structname>,
      <structname>pg_attribute</structname>, etc., for it.  Thus the
      table will not be accessible by ordinary SQL operations until
      such entries are made the hard way (with <literal>insert</literal>
      commands).  This option is used for creating
      <structname>pg_class</structname> etc. themselves.
     </para>
________________________________________________________-->
     <para>
      当指定<literal>bootstrap</literal>时，表只会在磁盘上创建；不会在<structname>pg_class</structname>、<structname>pg_attribute</structname>等中输入任何内容。因此，在通过<literal>insert</literal>命令以硬编码的方式进行这些条目之前，该表将无法通过普通的SQL操作访问。此选项用于创建<structname>pg_class</structname>等本身。
     </para>
<!-- pgdoc-cn_end sig_en=3f7bb1cb2582fb7bb35b43e94c4ed5a2 -->

<!-- pgdoc-cn_start sig_en=3be75a3ac3436c3d11a1b63b85e4e93d sig_cn_org=None source=14.1 
     <para>
      The table is created as shared if <literal>shared_relation</literal> is
      specified.
      The table's row type OID (<structname>pg_type</structname> OID) can optionally
      be specified via the <literal>rowtype_oid</literal> clause; if not specified,
      an OID is automatically generated for it.  (The <literal>rowtype_oid</literal>
      clause is useless if <literal>bootstrap</literal> is specified, but it can be
      provided anyway for documentation.)
     </para>
________________________________________________________-->
     <para>
      如果声明了<literal>shared_relation</literal>，那么表就作为共享表创建。除非声明了<literal>without_oids</literal>，否则表将会有OID。表的行类型OID（<structname>pg_type</structname>的OID）可以有选择性地通过<literal>rowtype_oid</literal>子句指定。如果没有指定，会为之自产生一个OID（如果<literal>bootstrap</literal>被指定，则<literal>rowtype_oid</literal>是无效的，但不管怎样它还是被写在了文档中）。
     </para>
<!-- pgdoc-cn_end sig_en=3be75a3ac3436c3d11a1b63b85e4e93d -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>open</literal> <replaceable class="parameter">tablename</replaceable>
    </term>

    <listitem>
<!-- pgdoc-cn_start sig_en=9fb387f922dd231ddd50e9bb8fcfa23a sig_cn_org=None source=14.1 
     <para>
      Open the table named
      <replaceable class="parameter">tablename</replaceable>
      for insertion of data.  Any currently open table is closed.
     </para>
________________________________________________________-->
     <para>
      打开名为<replaceable class="parameter">tablename</replaceable>的表进行数据插入。任何当前打开的表将被关闭。
     </para>
<!-- pgdoc-cn_end sig_en=9fb387f922dd231ddd50e9bb8fcfa23a -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>close</literal> <replaceable class="parameter">tablename</replaceable>
    </term>

    <listitem>
<!-- pgdoc-cn_start sig_en=2d4a697c23289a22dd43dff30ff57e74 sig_cn_org=None source=14.1 
     <para>
      Close the open table.  The name of the table must be given as a
      cross-check.
     </para>
________________________________________________________-->
     <para>
      关闭打开着的表。给出的表名用于交叉检查，但并不是必须的。
     </para>
<!-- pgdoc-cn_end sig_en=2d4a697c23289a22dd43dff30ff57e74 -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=70c2978f41d7d1d673fdc2271d99ad59 sig_cn_org=None source=14.1 
    <term>
     <literal>insert</literal> <literal>(</literal> <optional><replaceable class="parameter">oid_value</replaceable></optional> <replaceable class="parameter">value1</replaceable> <replaceable class="parameter">value2</replaceable> ... <literal>)</literal>
    </term>
________________________________________________________-->
    <term>
     <literal>insert</literal> <literal>(</literal> <optional><replaceable class="parameter">oid_value</replaceable></optional> <replaceable class="parameter">value1</replaceable> <replaceable class="parameter">value2</replaceable> ... <literal>)</literal>
    </term>
<!-- pgdoc-cn_end sig_en=70c2978f41d7d1d673fdc2271d99ad59 -->

    <listitem>
<!-- pgdoc-cn_start sig_en=9cf0dec0af7ae45691c84b29cc90e9f6 sig_cn_org=None source=14.1 
     <para>
      Insert a new row into the open table using <replaceable
      class="parameter">value1</replaceable>, <replaceable
      class="parameter">value2</replaceable>, etc., for its column
      values.
     </para>
________________________________________________________-->
     <para>
      用<replaceable class="parameter">value1</replaceable>、<replaceable class="parameter">value2</replaceable> 等作为列值向打开的表插入一条新记录。
     </para>
<!-- pgdoc-cn_end sig_en=9cf0dec0af7ae45691c84b29cc90e9f6 -->

<!-- pgdoc-cn_start sig_en=ec12ed80813d9824cf010d8a134161b3 sig_cn_org=None source=14.1 
     <para>
      NULL values can be specified using the special key word
      <literal>_null_</literal>.  Values that do not look like
      identifiers or digit strings must be single-quoted.
      (To include a single quote in a value, write it twice.
      Escape-string-style backslash escapes are allowed in the string, too.)
     </para>
________________________________________________________-->
     <para>
      NULL 可以用特殊的关键字<literal>_null_</literal>指定。看起来不像标识符或者数字字符串的值必须被加上单引号。
      (要在一个值中包含单引号，将其写两次。转义字符串风格的反斜杠转义在字符串中也是允许的。)
     </para>
<!-- pgdoc-cn_end sig_en=ec12ed80813d9824cf010d8a134161b3 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>declare</literal> <optional><literal>unique</literal></optional>
     <literal>index</literal> <replaceable class="parameter">indexname</replaceable>
     <replaceable class="parameter">indexoid</replaceable>
     <literal>on</literal> <replaceable class="parameter">tablename</replaceable>
     <literal>using</literal> <replaceable class="parameter">amname</replaceable>
     <literal>(</literal> <replaceable class="parameter">opclass1</replaceable>
     <replaceable class="parameter">name1</replaceable>
     <optional>, ...</optional> <literal>)</literal>
    </term>

    <listitem>
<!-- pgdoc-cn_start sig_en=d15c5325d631e7658f43f1ab4c401676 sig_cn_org=None source=14.1 
     <para>
      Create an index named <replaceable
      class="parameter">indexname</replaceable>, having OID
      <replaceable class="parameter">indexoid</replaceable>,
      on the table named
      <replaceable class="parameter">tablename</replaceable>, using the
      <replaceable class="parameter">amname</replaceable> access
      method.  The fields to index are called <replaceable
      class="parameter">name1</replaceable>, <replaceable
      class="parameter">name2</replaceable> etc., and the operator
      classes to use are <replaceable
      class="parameter">opclass1</replaceable>, <replaceable
      class="parameter">opclass2</replaceable> etc., respectively.
      The index file is created and appropriate catalog entries are
      made for it, but the index contents are not initialized by this command.
     </para>
________________________________________________________-->
     <para>
      在名为<replaceable class="parameter">tablename</replaceable>的表上用<replaceable class="parameter">amname</replaceable>访问方法创建一个OID为<replaceable class="parameter">indexoid</replaceable>的名为<replaceable class="parameter">indexname</replaceable>的索引。 索引的域被称为<replaceable class="parameter">name1</replaceable>、<replaceable class="parameter">name2</replaceable>等，而使用的操作符类分别是<replaceable class="parameter">opclass1</replaceable>, <replaceable class="parameter">opclass2</replaceable>等。 该命令将会创建索引文件和适当的系统目录项，但是索引内容不会被此命令初始化。
     </para>
<!-- pgdoc-cn_end sig_en=d15c5325d631e7658f43f1ab4c401676 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>declare toast</literal>
     <replaceable class="parameter">toasttableoid</replaceable>
     <replaceable class="parameter">toastindexoid</replaceable>
     <literal>on</literal> <replaceable class="parameter">tablename</replaceable>
    </term>

    <listitem>
<!-- pgdoc-cn_start sig_en=e75895c59525a1ceedb14b42a5acd031 sig_cn_org=None source=14.1 
     <para>
      Create a TOAST table for the table named
      <replaceable class="parameter">tablename</replaceable>.
      The TOAST table is assigned OID
      <replaceable class="parameter">toasttableoid</replaceable>
      and its index is assigned OID
      <replaceable class="parameter">toastindexoid</replaceable>.
      As with <literal>declare index</literal>, filling of the index
      is postponed.
     </para>
________________________________________________________-->
     <para>
      为名为<replaceable class="parameter">tablename</replaceable>的表创建一个TOAST表。该TOAST表将被赋予由<replaceable class="parameter">toasttableoid</replaceable>表示的OID，且它的索引将被赋予由<replaceable class="parameter">toastindexoid</replaceable>表示的OID。和<literal>declare index</literal>一样，索引的填充将被推迟。
     </para>
<!-- pgdoc-cn_end sig_en=e75895c59525a1ceedb14b42a5acd031 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>build indices</literal></term>

    <listitem>
<!-- pgdoc-cn_start sig_en=1b8bdb1c727ef4b9991a1dc4b2e0a04e sig_cn_org=None source=14.1 
     <para>
      Fill in the indices that have previously been declared.
     </para>
________________________________________________________-->
     <para>
      填充之前声明的索引。
     </para>
<!-- pgdoc-cn_end sig_en=1b8bdb1c727ef4b9991a1dc4b2e0a04e -->
    </listitem>
   </varlistentry>
  </variablelist>

 </sect1>

 <sect1 id="bki-structure">
<!-- pgdoc-cn_start sig_en=8c7e244dbd5992bec86dcf043d96b50d sig_cn_org=None source=14.1 
  <title>Structure of the Bootstrap <acronym>BKI</acronym> File</title>
________________________________________________________-->
  <title>自举<acronym>BKI</acronym>文件的结构</title>
<!-- pgdoc-cn_end sig_en=8c7e244dbd5992bec86dcf043d96b50d -->

<!-- pgdoc-cn_start sig_en=f8da342733b2ef38f263ac8263601e0c sig_cn_org=None source=14.1 
  <para>
   The <literal>open</literal> command cannot be used until the tables it uses
   exist and have entries for the table that is to be opened.
   (These minimum tables are <structname>pg_class</structname>,
   <structname>pg_attribute</structname>, <structname>pg_proc</structname>, and
   <structname>pg_type</structname>.)   To allow those tables themselves to be filled,
   <literal>create</literal> with the <literal>bootstrap</literal> option implicitly opens
   the created table for data insertion.
  </para>
________________________________________________________-->
  <para>
   在<literal>open</literal>命令打开某个表时，它需要系统中已经存在一些表并且其中要具有与被打开表相关的项，在这些先决条件满足之前，<literal>open</literal>命令不能被使用（这些至少应该存在的表是<structname>pg_class</structname>、<structname>pg_attribute</structname>、<structname>pg_proc</structname>和<structname>pg_type</structname>）。 为了允许这些表本身被填充，带着<literal>bootstrap</literal>选项的<literal>create</literal>将会隐式打开所创建的表用于插入数据。
  </para>
<!-- pgdoc-cn_end sig_en=f8da342733b2ef38f263ac8263601e0c -->

<!-- pgdoc-cn_start sig_en=0429eb655545db1d395a24f5b9923dfc sig_cn_org=None source=14.1 
  <para>
   Also, the <literal>declare index</literal> and <literal>declare toast</literal>
   commands cannot be used until the system catalogs they need have been
   created and filled in.
  </para>
________________________________________________________-->
  <para>
   同样，<literal>declare index</literal>和<literal>declare toast</literal>命令也必须在相关系统目录被创建和填充之后才能被使用。
  </para>
<!-- pgdoc-cn_end sig_en=0429eb655545db1d395a24f5b9923dfc -->

<!-- pgdoc-cn_start sig_en=2c93f861af79c6d1eb382932d00c7c45 sig_cn_org=None source=14.1 
  <para>
   Thus, the structure of the <filename>postgres.bki</filename> file has to
   be:
   <orderedlist>
    <listitem>
     <para>
      <literal>create bootstrap</literal> one of the critical tables
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>insert</literal> data describing at least the critical tables
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>close</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      Repeat for the other critical tables.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>create</literal> (without <literal>bootstrap</literal>) a noncritical table
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>open</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>insert</literal> desired data
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>close</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      Repeat for the other noncritical tables.
     </para>
    </listitem>
    <listitem>
     <para>
      Define indexes and toast tables.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>build indices</literal>
     </para>
    </listitem>
   </orderedlist>
  </para>
________________________________________________________-->
  <para>
   因此，<filename>postgres.bki</filename>文件的结构必须是：
   <orderedlist>
    <listitem>
     <para>
      <literal>create bootstrap</literal>其中一个关键表
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>insert</literal>数据，这些数据至少要能描述这些关键表
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>close</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      重复创建其他关键表。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>create</literal>（不带<literal>bootstrap</literal>）一个非关键表
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>open</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>insert</literal>需要的数据
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>close</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      重复创建其他非关键表。
     </para>
    </listitem>
    <listitem>
     <para>
      定义索引和TOAST表。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>build indices</literal>
     </para>
    </listitem>
   </orderedlist>
  </para>
<!-- pgdoc-cn_end sig_en=2c93f861af79c6d1eb382932d00c7c45 -->

<!-- pgdoc-cn_start sig_en=d6738f774f49d5735338aa723f013197 sig_cn_org=None source=14.1 
  <para>
   There are doubtless other, undocumented ordering dependencies.
  </para>
________________________________________________________-->
  <para>
   无疑还有其它未被文档记录的顺序依赖关系。
  </para>
<!-- pgdoc-cn_end sig_en=d6738f774f49d5735338aa723f013197 -->
 </sect1>

 <sect1 id="bki-example">
<!-- pgdoc-cn_start sig_en=4e7ba0e742ef22fb06995747c8e5bf0b sig_cn_org=None source=14.1 
  <title>BKI Example</title>
________________________________________________________-->
  <title>BKI例子</title>
<!-- pgdoc-cn_end sig_en=4e7ba0e742ef22fb06995747c8e5bf0b -->

<!-- pgdoc-cn_start sig_en=4e5e9db4f48d455886c621d35322e8e0 sig_cn_org=None source=14.1 
  <para>
   The following sequence of commands will create the table
   <literal>test_table</literal> with OID 420, having three columns
   <literal>oid</literal>, <literal>cola</literal> and <literal>colb</literal>
   of type <type>oid</type>, <type>int4</type> and <type>text</type>,
   respectively, and insert two rows into the table:
<programlisting>
create test_table 420 (oid = oid, cola = int4, colb = text)
open test_table
insert ( 421 1 'value 1' )
insert ( 422 2 _null_ )
close test_table
</programlisting>
  </para>
________________________________________________________-->
  <para>
   下面的命令序列将创建<literal>test_table</literal>表，表的OID为420，它有三列<literal>oid</literal>、 <literal>cola</literal>和<literal>colb</literal>，类型分别为<type>oid</type>、<type>int4</type>和<type>text</type>，然后向该表插入两行：
<programlisting>
create test_table 420 (oid = oid, cola = int4, colb = text)
open test_table
insert ( 421 1 'value 1' )
insert ( 422 2 _null_ )
close test_table
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=4e5e9db4f48d455886c621d35322e8e0 -->
 </sect1>
</chapter>
