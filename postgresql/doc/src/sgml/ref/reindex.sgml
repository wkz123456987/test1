<!--
doc/src/sgml/ref/reindex.sgml
PostgreSQL documentation
-->

<refentry id="sql-reindex">
<!-- pgdoc-cn_start sig_en=76050c6bf7439e0e13bd7ad3c09a4877 sig_cn_org=None source=14.1 
 <indexterm zone="sql-reindex">
  <primary>REINDEX</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="sql-reindex">
  <primary>REINDEX</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=76050c6bf7439e0e13bd7ad3c09a4877 -->

 <refmeta>
  <refentrytitle>REINDEX</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

<!-- pgdoc-cn_start sig_en=3cac2d01a78d9fb1f3ddf32a1cc4d2b6 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>REINDEX</refname>
  <refpurpose>rebuild indexes</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>REINDEX</refname>
  <refpurpose>重建索引</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=3cac2d01a78d9fb1f3ddf32a1cc4d2b6 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=5cb48eaa2b008d0246fafab70fbe6a4c sig_cn_org=None source=14.1 
<synopsis>
REINDEX [ ( <replaceable class="parameter">option</replaceable> [, ...] ) ] { INDEX | TABLE | SCHEMA | DATABASE | SYSTEM } [ CONCURRENTLY ] <replaceable class="parameter">name</replaceable>

<phrase>where <replaceable class="parameter">option</replaceable> can be one of:</phrase>

    CONCURRENTLY [ <replaceable class="parameter">boolean</replaceable> ]
    TABLESPACE <replaceable class="parameter">new_tablespace</replaceable>
    VERBOSE [ <replaceable class="parameter">boolean</replaceable> ]
</synopsis>
________________________________________________________-->
<synopsis>
REINDEX [ ( <replaceable class="parameter">option</replaceable> [, ...] ) ] { INDEX | TABLE | SCHEMA | DATABASE | SYSTEM } [ CONCURRENTLY ] <replaceable class="parameter">name</replaceable>

<phrase>其中 <replaceable class="parameter">选项</replaceable> 可以是以下之一：</phrase>

    CONCURRENTLY [ <replaceable class="parameter">boolean</replaceable> ]
    TABLESPACE <replaceable class="parameter">new_tablespace</replaceable>
    VERBOSE [ <replaceable class="parameter">boolean</replaceable> ]
</synopsis>
<!-- pgdoc-cn_end sig_en=5cb48eaa2b008d0246fafab70fbe6a4c -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=ac4fa35c0c90085f9d348ad92bf36826 sig_cn_org=None source=14.1 
  <para>
   <command>REINDEX</command> rebuilds an index using the data
   stored in the index's table, replacing the old copy of the index. There are
   several scenarios in which to use <command>REINDEX</command>:

   <itemizedlist>
    <listitem>
     <para>
      An index has become corrupted, and no longer contains valid
      data. Although in theory this should never happen, in
      practice indexes can become corrupted due to software bugs or
      hardware failures.  <command>REINDEX</command> provides a
      recovery method.
     </para>
    </listitem>

    <listitem>
     <para>
      An index has become <quote>bloated</quote>, that is it contains many
      empty or nearly-empty pages.  This can occur with B-tree indexes in
      <productname>PostgreSQL</productname> under certain uncommon access
      patterns. <command>REINDEX</command> provides a way to reduce
      the space consumption of the index by writing a new version of
      the index without the dead pages. See <xref
      linkend="routine-reindex"/> for more information.
     </para>
    </listitem>

    <listitem>
     <para>
      You have altered a storage parameter (such as fillfactor)
      for an index, and wish to ensure that the change has taken full effect.
     </para>
    </listitem>

    <listitem>
     <para>
      If an index build fails with the <literal>CONCURRENTLY</literal> option,
      this index is left as <quote>invalid</quote>. Such indexes are useless
      but it can be convenient to use <command>REINDEX</command> to rebuild
      them. Note that only <command>REINDEX INDEX</command> is able
      to perform a concurrent build on an invalid index.
     </para>
    </listitem>

   </itemizedlist></para>
________________________________________________________-->
  <para>
   <command>REINDEX</command>使用索引的表里存储的数据重建一个索引，
   并且替换该索引的旧拷贝。有一些场景需要使用<command>REINDEX</command>：

   <itemizedlist>
    <listitem>
     <para>
      一个索引已经损坏，并且不再包含合法数据。尽管理论上这不会发生，
      实际上索引会因为软件缺陷或硬件失效损坏。
      <command>REINDEX</command>提供了一种恢复方法。
     </para>
    </listitem>

    <listitem>
     <para>
      一个索引变得<quote>臃肿</quote>，其中包含很多空的或者近乎为空的页面。
      <productname>PostgreSQL</productname>中的 B-树索引在特定的非
      常规访问模式下可能会发生这种情况。<command>REINDEX</command>
      提供了一种方法来减少索引的空间消耗，即制造一个新版本的索引，其中没有
      死亡页面。详见<xref linkend="routine-reindex"/>。
     </para>
    </listitem>

    <listitem>
     <para>
      修改了一个索引的存储参数（例如填充因子），并且希望确保这种修改完全
      生效。
     </para>
    </listitem>

    <listitem>
     <para>
      如果索引在用<literal>CONCURRENTLY</literal>选项创建失败，该索引保留为一个<quote>invalid</quote>。
      这类索引是无用的，但是可以方便的用<command>REINDEX</command>来重建它们。注意，只有<command>REINDEX INDEX</command>可以在无效的索引上执行并发创建。
     </para>
    </listitem>

   </itemizedlist></para>
<!-- pgdoc-cn_end sig_en=ac4fa35c0c90085f9d348ad92bf36826 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
  <title>Parameters</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

  <variablelist>
   <varlistentry>
    <term><literal>INDEX</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=3e5392a24ef5f184269176c654f50413 sig_cn_org=None source=14.1 
     <para>
      Recreate the specified index. This form of <command>REINDEX</command>
      cannot be executed inside a transaction block when used with a
      partitioned index.
     </para>
________________________________________________________-->
     <para>
      重新创建指定的索引。
      当与分区索引一起使用时，<command>REINDEX</command>的这种形式不能在事务块内部执行。
     </para>
<!-- pgdoc-cn_end sig_en=3e5392a24ef5f184269176c654f50413 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TABLE</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=4d54d1aa240ced994b932b11f0267823 sig_cn_org=None source=14.1 
     <para>
      Recreate all indexes of the specified table.  If the table has a
      secondary <quote>TOAST</quote> table, that is reindexed as well.
      This form of <command>REINDEX</command> cannot be executed inside a
      transaction block when used with a partitioned table.
     </para>
________________________________________________________-->
     <para>
      重新创建指定表的所有索引。
      如果该表有一个二级<quote>TOAST</quote>表，它也会被重新索引。
      当与分区表一起使用时，<command>REINDEX</command>的这种形式不能再事务块内部执行。
     </para>
<!-- pgdoc-cn_end sig_en=4d54d1aa240ced994b932b11f0267823 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SCHEMA</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=b9732aa2dfbe4cd02d545babfabae385 sig_cn_org=None source=14.1 
     <para>
      Recreate all indexes of the specified schema.  If a table of this
      schema has a secondary <quote>TOAST</quote> table, that is reindexed as
      well. Indexes on shared system catalogs are also processed.
      This form of <command>REINDEX</command> cannot be executed inside a
      transaction block.
     </para>
________________________________________________________-->
     <para>
      重建指定方案的所有索引。如果这个方案中的一个表有次级的<quote>TOAST</quote>表，它也会被重建索引。共享系统目录上的索引也会被处理。这种形式的<command>REINDEX</command>不能在事务块内执行。
     </para>
<!-- pgdoc-cn_end sig_en=b9732aa2dfbe4cd02d545babfabae385 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DATABASE</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=abb826c32ee2b6f61d18611f67bbeb2a sig_cn_org=None source=14.1 
     <para>
      Recreate all indexes within the current database.
      Indexes on shared system catalogs are also processed.
      This form of <command>REINDEX</command> cannot be executed inside a
      transaction block.
     </para>
________________________________________________________-->
     <para>
      重新创建当前数据库内的所有索引。共享的系统目录上的索引也会被
      处理。这种形式的<command>REINDEX</command>不能在一个
      事务块内执行。
     </para>
<!-- pgdoc-cn_end sig_en=abb826c32ee2b6f61d18611f67bbeb2a -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SYSTEM</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=ff2b359b548820f6f75d8e073e10f3b7 sig_cn_org=None source=14.1 
     <para>
      Recreate all indexes on system catalogs within the current database.
      Indexes on shared system catalogs are included.
      Indexes on user tables are not processed.
      This form of <command>REINDEX</command> cannot be executed inside a
      transaction block.
     </para>
________________________________________________________-->
     <para>
      重新创建当前数据库中在系统目录上的所有索引。共享系统目录上的
      索引也被包括在内。用户表上的索引则不会被处理。这种形式的
      <command>REINDEX</command>不能在一个事务块内执行。
     </para>
<!-- pgdoc-cn_end sig_en=ff2b359b548820f6f75d8e073e10f3b7 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">name</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=30d2c083be2814157aa191a8b92f08e0 sig_cn_org=None source=14.1 
     <para>
      The name of the specific index, table, or database to be
      reindexed.  Index and table names can be schema-qualified.
      Presently, <command>REINDEX DATABASE</command> and <command>REINDEX SYSTEM</command>
      can only reindex the current database, so their parameter must match
      the current database's name.
     </para>
________________________________________________________-->
     <para>
      要被重新索引的特定索引、表或者数据库的名字。索引和表名可以被
      模式限定。当前，<command>REINDEX DATABASE</command>和
      <command>REINDEX SYSTEM</command>只能重新索引当前数据库，因此
      它们的参数必须匹配当前数据库的名称。
     </para>
<!-- pgdoc-cn_end sig_en=30d2c083be2814157aa191a8b92f08e0 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CONCURRENTLY</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=3ae29fb9d1d2eab731d90ebc8a719d71 sig_cn_org=None source=14.1 
     <para>
      When this option is used, <productname>PostgreSQL</productname> will rebuild the
      index without taking any locks that prevent concurrent inserts,
      updates, or deletes on the table; whereas a standard index rebuild
      locks out writes (but not reads) on the table until it's done.
      There are several caveats to be aware of when using this option
      &mdash; see <xref linkend="sql-reindex-concurrently"/> below.
     </para>
________________________________________________________-->
     <para>
      使用此选项时，<productname>PostgreSQL</productname> 将重建索引，而不在表上采取任何阻止并发插入、更新或删除的锁;
      标准的索引重建将会锁定表上的写操作(而不是读操作)，直到它完成。
      使用此选项&mdash;时，有几个事项需要注意；请参阅下面的<xref linkend="sql-reindex-concurrently"/>。
     </para>
<!-- pgdoc-cn_end sig_en=3ae29fb9d1d2eab731d90ebc8a719d71 -->
<!-- pgdoc-cn_start sig_en=6187b3f5581eb2e230d152fca8a168ca sig_cn_org=None source=14.1 
     <para>
      For temporary tables, <command>REINDEX</command> is always
      non-concurrent, as no other session can access them, and
      non-concurrent reindex is cheaper.
     </para>
________________________________________________________-->
     <para>
      对于临时表，<command>REINDEX</command>始终是非并发的，因为没有其他会话可以访问它们，并且非并发重新索引更便宜。
     </para>
<!-- pgdoc-cn_end sig_en=6187b3f5581eb2e230d152fca8a168ca -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TABLESPACE</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=e218df470a6c789346df58872fef666e sig_cn_org=None source=14.1 
     <para>
      Specifies that indexes will be rebuilt on a new tablespace.
     </para>
________________________________________________________-->
     <para>
      指定将在新表空间上重建的索引。
     </para>
<!-- pgdoc-cn_end sig_en=e218df470a6c789346df58872fef666e -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>VERBOSE</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=1cb545801c7edc0bf7903729719c77d1 sig_cn_org=None source=14.1 
     <para>
      Prints a progress report as each index is reindexed.
     </para>
________________________________________________________-->
     <para>
      在每个索引被重建时打印进度报告。
     </para>
<!-- pgdoc-cn_end sig_en=1cb545801c7edc0bf7903729719c77d1 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">boolean</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=8bf72cd4d6f8014b82e3bee2e1efc117 sig_cn_org=None source=14.1 
     <para>
      Specifies whether the selected option should be turned on or off.
      You can write <literal>TRUE</literal>, <literal>ON</literal>, or
      <literal>1</literal> to enable the option, and <literal>FALSE</literal>,
      <literal>OFF</literal>, or <literal>0</literal> to disable it.  The
      <replaceable class="parameter">boolean</replaceable> value can also
      be omitted, in which case <literal>TRUE</literal> is assumed.
     </para>
________________________________________________________-->
     <para>
      指定选择的选项是否打开或关闭。
      你可以写<literal>TRUE</literal>、<literal>ON</literal>、或者<literal>1</literal> 以激活该选项，以及<literal>FALSE</literal>、<literal>OFF</literal>、或<literal>0</literal>以禁用它。
      <replaceable class="parameter">boolean</replaceable>值也可以被省略，在假设为<literal>TRUE</literal>的情况下。
     </para>
<!-- pgdoc-cn_end sig_en=8bf72cd4d6f8014b82e3bee2e1efc117 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">new_tablespace</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=0d62f630998f6e15a14411d82ab8f556 sig_cn_org=None source=14.1 
     <para>
      The tablespace where indexes will be rebuilt.
     </para>
________________________________________________________-->
     <para>
      将被重建索引的表空间。
     </para>
<!-- pgdoc-cn_end sig_en=0d62f630998f6e15a14411d82ab8f556 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
  <title>Notes</title>
________________________________________________________-->
  <title>注解</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->

<!-- pgdoc-cn_start sig_en=4a32771f1683a6f4b630138e8cf5bd44 sig_cn_org=None source=14.1 
  <para>
   If you suspect corruption of an index on a user table, you can
   simply rebuild that index, or all indexes on the table, using
   <command>REINDEX INDEX</command> or <command>REINDEX TABLE</command>.
  </para>
________________________________________________________-->
  <para>
   如果怀疑一个用户表上的索引损坏，可以使用
   <command>REINDEX INDEX</command>或者
   <command>REINDEX TABLE</command>简单地重建该索引
   或者表上的所有索引。
  </para>
<!-- pgdoc-cn_end sig_en=4a32771f1683a6f4b630138e8cf5bd44 -->

<!-- pgdoc-cn_start sig_en=3c8da003e7e480ec60af82921acfb58b sig_cn_org=None source=14.1 
  <para>
   Things are more difficult if you need to recover from corruption of
   an index on a system table.  In this case it's important for the
   system to not have used any of the suspect indexes itself.
   (Indeed, in this sort of scenario you might find that server
   processes are crashing immediately at start-up, due to reliance on
   the corrupted indexes.)  To recover safely, the server must be started
   with the <option>-P</option> option, which prevents it from using
   indexes for system catalog lookups.
  </para>
________________________________________________________-->
  <para>
   如果你需要从一个系统表上的索引损坏中恢复，就更困难一些。在
   这种情况下，对系统来说重要的是没有使用过任何可疑的索引本身（
   实际上，这种场景中，你可能会发现服务器进程会在启动时立刻崩溃，
   这是因为对于损坏的索引的依赖）。要安全地恢复，服务器必须用
   <option>-P</option>选项启动，这将阻止它使用索引来进行系统
   目录查找。
  </para>
<!-- pgdoc-cn_end sig_en=3c8da003e7e480ec60af82921acfb58b -->

<!-- pgdoc-cn_start sig_en=e4b947a0ea5789c5ac0604c2bdf7387d sig_cn_org=None source=14.1 
  <para>
   One way to do this is to shut down the server and start a single-user
   <productname>PostgreSQL</productname> server
   with the <option>-P</option> option included on its command line.
   Then, <command>REINDEX DATABASE</command>, <command>REINDEX SYSTEM</command>,
   <command>REINDEX TABLE</command>, or <command>REINDEX INDEX</command> can be
   issued, depending on how much you want to reconstruct.  If in
   doubt, use <command>REINDEX SYSTEM</command> to select
   reconstruction of all system indexes in the database.  Then quit
   the single-user server session and restart the regular server.
   See the <xref linkend="app-postgres"/> reference page for more
   information about how to interact with the single-user server
   interface.
  </para>
________________________________________________________-->
  <para>
   这样做的一种方法是关闭服务器，并且启动一个单用户的
   <productname>PostgreSQL</productname>服务器，在其命令行
   中包括<option>-P</option>选项。然后，可以发出
   <command>REINDEX DATABASE</command>、<command>REINDEX SYSTEM</command>、
   <command>REINDEX TABLE</command>或者<command>REINDEX INDEX</command>，
   具体使用哪个命令取决于你想要重构多少东西。如果有疑问，可以使用
   <command>REINDEX SYSTEM</command>来选择重建数据库中的所有系统索引。
   然后退出单用户服务器会话并且重启常规的服务器。更多关于如何与
   单用户服务器接口交互的内容请见<xref linkend="app-postgres"/>参考页。
  </para>
<!-- pgdoc-cn_end sig_en=e4b947a0ea5789c5ac0604c2bdf7387d -->

<!-- pgdoc-cn_start sig_en=c35ff0eda6bf274dfc6a20517dc87265 sig_cn_org=None source=14.1 
  <para>
   Alternatively, a regular server session can be started with
   <option>-P</option> included in its command line options.
   The method for doing this varies across clients, but in all
   <application>libpq</application>-based clients, it is possible to set
   the <envar>PGOPTIONS</envar> environment variable to <literal>-P</literal>
   before starting the client.  Note that while this method does not
   require locking out other clients, it might still be wise to prevent
   other users from connecting to the damaged database until repairs
   have been completed.
  </para>
________________________________________________________-->
  <para>
   在另一种方法中，可以开始一个常规的服务器会话，在其命令行选项
   中包括<option>-P</option>。这样做的方法与客户端有关，但是在
   所有基于<application>libpq</application>的客户端中都可以在开始客户端
   之前设置<envar>PGOPTIONS</envar>环境变量为<literal>-P</literal>。
   注意虽然这种方法不要求用锁排斥其他客户端，在修复完成之前避免
   其他用户连接到受损的数据库才是更加明智的。
  </para>
<!-- pgdoc-cn_end sig_en=c35ff0eda6bf274dfc6a20517dc87265 -->

<!-- pgdoc-cn_start sig_en=4f2f5947979c003f3a0bec605b76ff91 sig_cn_org=82d4514106b5a3ff24d7c903a5b9e05d source=15.7 
  <para>
   <command>REINDEX</command> is similar to a drop and recreate of the index
   in that the index contents are rebuilt from scratch.  However, the locking
   considerations are rather different.  <command>REINDEX</command> locks out writes
   but not reads of the index's parent table.  It also takes an
   <literal>ACCESS EXCLUSIVE</literal> lock on the specific index being processed,
   which will block reads that attempt to use that index. In particular,
   the query planner tries to take an <literal>ACCESS SHARE</literal>
   lock on every index of the table, regardless of the query, and so
   <command>REINDEX</command> blocks virtually any queries except for some
   prepared queries whose plan has been cached and which don't use this very
   index. In contrast,
   <command>DROP INDEX</command> momentarily takes an
   <literal>ACCESS EXCLUSIVE</literal> lock on the parent table, blocking both
   writes and reads.  The subsequent <command>CREATE INDEX</command> locks out
   writes but not reads; since the index is not there, no read will attempt to
   use it, meaning that there will be no blocking but reads might be forced
   into expensive sequential scans.
  </para>
________________________________________________________-->
  <para>
   <command>REINDEX</command>类似于索引的删除和重建，因为索引内容是从头开始重建的。
   但是，锁定考虑是非常不同的。<command>REINDEX</command>锁定了索引的父表的写入，但不锁定读取。
   它还对正在处理的特定索引采取了<literal>ACCESS EXCLUSIVE</literal>锁定，这将阻止尝试使用该索引的读取。
   特别是，查询规划器尝试对表的每个索引采取<literal>ACCESS SHARE</literal>锁定，而不考虑查询，
   因此<command>REINDEX</command>几乎阻止除了一些已缓存计划且不使用这个索引的准备查询之外的任何查询。
   相比之下，<command>DROP INDEX</command>瞬间对父表采取<literal>ACCESS EXCLUSIVE</literal>锁定，
   阻止写入和读取。随后的<command>CREATE INDEX</command>锁定了写入但不锁定读取；
   因为索引不存在，没有读取会尝试使用它，这意味着不会有阻塞，但读取可能被迫进入昂贵的顺序扫描。
</para>
<!-- pgdoc-cn_end sig_en=4f2f5947979c003f3a0bec605b76ff91 -->

<!-- pgdoc-cn_start sig_en=926f137883c266bb7e8b9da02a5760ec sig_cn_org=None source=14.1 
  <para>
   Reindexing a single index or table requires being the owner of that
   index or table.  Reindexing a schema or database requires being the
   owner of that schema or database.  Note specifically that it's thus
   possible for non-superusers to rebuild indexes of tables owned by
   other users.  However, as a special exception, when
   <command>REINDEX DATABASE</command>, <command>REINDEX SCHEMA</command>
   or <command>REINDEX SYSTEM</command> is issued by a non-superuser,
   indexes on shared catalogs will be skipped unless the user owns the
   catalog (which typically won't be the case).  Of course, superusers
   can always reindex anything.
  </para>
________________________________________________________-->
  <para>
   重新索引单独一个索引或者表要求用户是该索引或表的拥有者。对方案或数据库重建索引要求是该方案或者数据库的拥有者。请特别注意，因此非超级用户有时无法重建其他用户拥有的表上的索引。不过，作为一种特例，当一个非超级用户发出<command>REINDEX DATABASE</command>、<command>REINDEX SCHEMA</command>或者<command>REINDEX SYSTEM</command>时，共享目录上的索引将被跳过，除非该用户拥有该目录（通常不会是这样）。当然，超级用户总是可以重建所有的索引。
  </para>
<!-- pgdoc-cn_end sig_en=926f137883c266bb7e8b9da02a5760ec -->

<!-- pgdoc-cn_start sig_en=7f4478b3c3814670b0c7fa6e66f1fbf9 sig_cn_org=None source=14.1 
  <para>
   Reindexing partitioned indexes or partitioned tables is supported
   with <command>REINDEX INDEX</command> or <command>REINDEX TABLE</command>,
   respectively. Each partition of the specified partitioned relation is
   reindexed in a separate transaction. Those commands cannot be used inside
   a transaction block when working on a partitioned table or index.
  </para>
________________________________________________________-->
  <para>
   可以支持对分区索引或分区表重建索引，分别通过<command>REINDEX INDEX</command> 或 <command>REINDEX TABLE</command>。
   指定分区关系的每个分区在一个单独的事务中重建索引。
   当工作在分区表或索引上面时，那些命令不能在事务块内部使用。
  </para>
<!-- pgdoc-cn_end sig_en=7f4478b3c3814670b0c7fa6e66f1fbf9 -->

<!-- pgdoc-cn_start sig_en=c9964ee12a0bcdd4e4f34bb38aafaca7 sig_cn_org=None source=14.1 
  <para>
   When using the <literal>TABLESPACE</literal> clause with
   <command>REINDEX</command> on a partitioned index or table, only the
   tablespace references of the leaf partitions are updated. As partitioned
   indexes are not updated, it is recommended to separately use
   <command>ALTER TABLE ONLY</command> on them so as any new partitions
   attached inherit the new tablespace. On failure, it may not have moved
   all the indexes to the new tablespace. Re-running the command will rebuild
   all the leaf partitions and move previously-unprocessed indexes to the new
   tablespace.
  </para>
________________________________________________________-->
  <para>
   当在已分区的索引或表上使用<literal>TABLESPACE</literal>子句和<command>REINDEX</command>时，只有叶子分区的表空间引用被更新。
   由于分区索引不会被更新，因此建议单独对它们使用<command>ALTER TABLE ONLY</command>，以便任何附加的新分区继承新的表空间。
   失败的话，它可能没有将所有的索引转移到新的表空间。
   重新运行该命令将重新构建所有叶子分区，并将以前未处理的索引转移到新的表空间。
  </para>
<!-- pgdoc-cn_end sig_en=c9964ee12a0bcdd4e4f34bb38aafaca7 -->

<!-- pgdoc-cn_start sig_en=701dda3735cc9ecc31112a825981cd1d sig_cn_org=None source=14.1 
  <para>
   If <literal>SCHEMA</literal>, <literal>DATABASE</literal> or
   <literal>SYSTEM</literal> is used with <literal>TABLESPACE</literal>,
   system relations are skipped and a single <literal>WARNING</literal>
   will be generated. Indexes on TOAST tables are rebuilt, but not moved
   to the new tablespace.
  </para>
________________________________________________________-->
  <para>
   如果<literal>SCHEMA</literal>、<literal>DATABASE</literal>或<literal>SYSTEM</literal>一起使用，系统关系会被跳过，并且将会生成单个<literal>WARNING</literal>。
   TOAST表上的索引会重建，但不会移动到新的表空间。
  </para>
<!-- pgdoc-cn_end sig_en=701dda3735cc9ecc31112a825981cd1d -->

  <refsect2 id="sql-reindex-concurrently" xreflabel="Rebuilding Indexes Concurrently">
<!-- pgdoc-cn_start sig_en=763de19bbd2dc0ff16ae4c283223d113 sig_cn_org=None source=14.1 
   <title>Rebuilding Indexes Concurrently</title>
________________________________________________________-->
   <title>Rebuilding Indexes Concurrently</title>
<!-- pgdoc-cn_end sig_en=763de19bbd2dc0ff16ae4c283223d113 -->

<!-- pgdoc-cn_start sig_en=14649938a836943af95b8fcb43818edf sig_cn_org=None source=14.1 
   <indexterm zone="sql-reindex-concurrently">
    <primary>index</primary>
    <secondary>rebuilding concurrently</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="sql-reindex-concurrently">
    <primary>index</primary>
    <secondary>rebuilding concurrently</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=14649938a836943af95b8fcb43818edf -->

<!-- pgdoc-cn_start sig_en=2e4c3f6e84aab1ab2dd8ea598074eb0c sig_cn_org=None source=14.1 
   <para>
    Rebuilding an index can interfere with regular operation of a database.
    Normally <productname>PostgreSQL</productname> locks the table whose index is rebuilt
    against writes and performs the entire index build with a single scan of the
    table. Other transactions can still read the table, but if they try to
    insert, update, or delete rows in the table they will block until the
    index rebuild is finished. This could have a severe effect if the system is
    a live production database. Very large tables can take many hours to be
    indexed, and even for smaller tables, an index rebuild can lock out writers
    for periods that are unacceptably long for a production system.
   </para>
________________________________________________________-->
   <para>
    重建索引可能会影响数据库的常规操作。通常<productname>PostgreSQL</productname>会锁定重建的表以防止写操作，并通过单次扫描表来执行整个索引构建。
    其他事务仍可以读取表，但如果它们尝试在表中插入、更新或删除行，它们将被阻止，直到索引重建完成。
    如果系统是实时生产数据库，这可能会产生严重影响。非常大的表可能需要几个小时才能编制索引，即使对于较小的表，索引重建也会锁定编写器，这些时间段对于生产系统来说是不可接受的。
   </para>
<!-- pgdoc-cn_end sig_en=2e4c3f6e84aab1ab2dd8ea598074eb0c -->

<!-- pgdoc-cn_start sig_en=6bdb9372700f2dbcf601f6dc33c71a3a sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> supports rebuilding indexes with minimum locking
    of writes.  This method is invoked by specifying the
    <literal>CONCURRENTLY</literal> option of <command>REINDEX</command>. When this option
    is used, <productname>PostgreSQL</productname> must perform two scans of the table
    for each index that needs to be rebuilt and wait for termination of
    all existing transactions that could potentially use the index.
    This method requires more total work than a standard index
    rebuild and takes significantly longer to complete as it needs to wait
    for unfinished transactions that might modify the index. However, since
    it allows normal operations to continue while the index is being rebuilt, this
    method is useful for rebuilding indexes in a production environment. Of
    course, the extra CPU, memory and I/O load imposed by the index rebuild
    may slow down other operations.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>支持以最少的写入锁定来重建索引。此方法通过指定<command>REINDEX</command>的<literal>CONCURRENTLY</literal>选项来调用。
    使用此选项时，<productname>PostgreSQL</productname>必须对需要重新生成的每个索引执行两次表扫描，并等待可能使用索引的所有现有事务的终止。
    此方法需要比标准索引重建更大的工作量，并且需要相当长的时间才能完成，因为它需要等待可能修改索引的未完成的事务。
    但是，由于它允许在重建索引时继续正常操作，此方法可用于在生产环境中重建索引。当然，重建索引所需的额外 CPU、内存和 I/O 负载可能会减慢其他操作的速度。
   </para>
<!-- pgdoc-cn_end sig_en=6bdb9372700f2dbcf601f6dc33c71a3a -->

<!-- pgdoc-cn_start sig_en=5164d9940ed7be4703fbd4221b93403d sig_cn_org=None source=14.1 
   <para>
    The following steps occur in a concurrent reindex.  Each step is run in a
    separate transaction.  If there are multiple indexes to be rebuilt, then
    each step loops through all the indexes before moving to the next step.

    <orderedlist>
     <listitem>
      <para>
       A new transient index definition is added to the catalog
       <literal>pg_index</literal>.  This definition will be used to replace
       the old index.  A <literal>SHARE UPDATE EXCLUSIVE</literal> lock at
       session level is taken on the indexes being reindexed as well as their
       associated tables to prevent any schema modification while processing.
      </para>
     </listitem>

     <listitem>
      <para>
       A first pass to build the index is done for each new index.  Once the
       index is built, its flag <literal>pg_index.indisready</literal> is
       switched to <quote>true</quote> to make it ready for inserts, making it
       visible to other sessions once the transaction that performed the build
       is finished.  This step is done in a separate transaction for each
       index.
      </para>
     </listitem>

     <listitem>
      <para>
       Then a second pass is performed to add tuples that were added while the
       first pass was running.  This step is also done in a separate
       transaction for each index.
      </para>
     </listitem>

     <listitem>
      <para>
       All the constraints that refer to the index are changed to refer to the
       new index definition, and the names of the indexes are changed.  At
       this point, <literal>pg_index.indisvalid</literal> is switched to
       <quote>true</quote> for the new index and to <quote>false</quote> for
       the old, and a cache invalidation is done causing all sessions that
       referenced the old index to be invalidated.
      </para>
     </listitem>

     <listitem>
      <para>
       The old indexes have <literal>pg_index.indisready</literal> switched to
       <quote>false</quote> to prevent any new tuple insertions, after waiting
       for running queries that might reference the old index to complete.
      </para>
     </listitem>

     <listitem>
      <para>
       The old indexes are dropped.  The <literal>SHARE UPDATE
       EXCLUSIVE</literal> session locks for the indexes and the table are
       released.
      </para>
     </listitem>
    </orderedlist>
   </para>
________________________________________________________-->
   <para>
    以下步骤发生在并发重建索引中。 每个步骤在单独的事务中运行。
	如果要重建多个索引，则每个步骤在进入到下一步之前都要循环遍历所有索引。

    <orderedlist>
     <listitem>
      <para>
       新的临时索引定义将添加到目录<literal>pg_index</literal>中。 此定义将用于替换旧索引。 
       一个<literal>SHARE UPDATE EXCLUSIVE</literal>会话级别的锁将放在要重建的索引以及其关联的表上，以防止处理时的任何模式修改。
      </para>
     </listitem>

     <listitem>
      <para>
       为每个新索引完成生成索引的首个操作。
       生成索引后，其标志<literal>pg_index.indisready</literal>切换到<quote>true</quote>使其准备好插入，使其在执行生成的事务完成后对其他会话可见。 
       此步骤在每个索引的单独事务中完成。
      </para>
     </listitem>

     <listitem>
      <para>
       然后执行第二个操作以添加在第一个操作运行时添加的元组。此步骤也在每个索引的单独事务中完成。
      </para>
     </listitem>

     <listitem>
      <para>
       引用索引的所有约束都已更改以引用新的索引定义，并且索引名称也已经更改。
       此时，<literal>pg_index.indisvalid</literal>会为新索引切换到<quote>true</quote>，以及为旧索引切换到<quote>false</quote>，并且缓存无效会导致引用旧索引的所有会话失效。
      </para>
     </listitem>

     <listitem>
      <para>
       旧索引有<literal>pg_index.indisready</literal>切换到<quote>false</quote>以防止任何新的元组插入，在等待可能引用旧索引的查询之后完成。
      </para>
     </listitem>

     <listitem>
      <para>
       旧索引被丢弃。索引和表的<literal>SHARE UPDATE EXCLUSIVE</literal>会话锁被释放。
      </para>
     </listitem>
    </orderedlist>
   </para>
<!-- pgdoc-cn_end sig_en=5164d9940ed7be4703fbd4221b93403d -->

<!-- pgdoc-cn_start sig_en=1142a42dc5c39aa037bf0012370522e5 sig_cn_org=None source=14.1 
   <para>
    If a problem arises while rebuilding the indexes, such as a
    uniqueness violation in a unique index, the <command>REINDEX</command>
    command will fail but leave behind an <quote>invalid</quote> new index in addition to
    the pre-existing one. This index will be ignored for querying purposes
    because it might be incomplete; however it will still consume update
    overhead. The <application>psql</application> <command>\d</command> command will report
    such an index as <literal>INVALID</literal>:

<programlisting>
postgres=# \d tab
       Table "public.tab"
 Column |  Type   | Modifiers
-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-
 col    | integer |
Indexes:
    "idx" btree (col)
    "idx_ccnew" btree (col) INVALID
</programlisting>

    If the index marked <literal>INVALID</literal> is suffixed
    <literal>ccnew</literal>, then it corresponds to the transient
    index created during the concurrent operation, and the recommended
    recovery method is to drop it using <literal>DROP INDEX</literal>,
    then attempt <command>REINDEX CONCURRENTLY</command> again.
    If the invalid index is instead suffixed <literal>ccold</literal>,
    it corresponds to the original index which could not be dropped;
    the recommended recovery method is to just drop said index, since the
    rebuild proper has been successful.
   </para>
________________________________________________________-->
   <para>
    如果在重建索引时出现问题，例如唯一索引中的唯一性冲突， <command>REINDEX</command>命令将失败，但会留下一个 <quote>invalid</quote>新索引，在已经存在的索引之外。
    出于查询目的此索引将被忽略，因为它可能不完整;但是它仍将消耗更新开销。<application>psql</application> <command>\d</command>命令将此类索引报告为 <literal>INVALID</literal>:

<programlisting>
postgres=# \d tab
       Table "public.tab"
 Column |  Type   | Modifiers
--------+---------+-----------
 col    | integer |
Indexes:
    "idx" btree (col)
    "idx_ccnew" btree (col) INVALID
</programlisting>

    如果标记为<literal>INVALID</literal>的索引后缀为<literal>ccnew</literal>，那么它对应的是并发操作时创建的临时索引，推荐的恢复方法是使用<literal>DROP INDEX</literal>删除，然后再次尝试 <command>REINDEX CONCURRENTLY</command>。 如果无效索引改为后缀<literal>ccold</literal>，则对应于无法删除的原始索引； 推荐的恢复方法是删除所述索引，因为正确的重建已经成功。
   </para>
<!-- pgdoc-cn_end sig_en=1142a42dc5c39aa037bf0012370522e5 -->

<!-- pgdoc-cn_start sig_en=6e56c8e1c57a14c27b8529be8c4a126a sig_cn_org=None source=14.1 
   <para>
    Regular index builds permit other regular index builds on the same table
    to occur simultaneously, but only one concurrent index build can occur on a
    table at a time. In both cases, no other types of schema modification on
    the table are allowed meanwhile.  Another difference is that a regular
    <command>REINDEX TABLE</command> or <command>REINDEX INDEX</command>
    command can be performed within a transaction block, but <command>REINDEX
    CONCURRENTLY</command> cannot.
   </para>
________________________________________________________-->
   <para>
    常规索引创建允许在同一表上的其他常规索引创建同时发生，但在一个表上一次只能发生一个并发索引创建。在这两种情况下，不允许同时对表上其他类型的模式进行修改。
    另一个区别是，常规<command>REINDEX TABLE</command>或<command>REINDEX INDEX</command>命令可以在事务块中执行，但<command>REINDEX CONCURRENTLY</command>不能执行。
   </para>
<!-- pgdoc-cn_end sig_en=6e56c8e1c57a14c27b8529be8c4a126a -->

<!-- pgdoc-cn_start sig_en=5c7c5fcc1e868a95856376b240a473c2 sig_cn_org=35711974db4de6a3e50681b0f0e910a6 source=15.7 
   <para>
    Like any long-running transaction, <command>REINDEX</command> on a table
    can affect which tuples can be removed by concurrent
    <command>VACUUM</command> on any other table.
   </para>
________________________________________________________-->
   <para>
    与任何长时间运行的事务一样，<command>REINDEX</command>在表上的操作
    可能会影响哪些元组可以被并发的<command>VACUUM</command>在其他表上移除。
   </para>
<!-- pgdoc-cn_end sig_en=5c7c5fcc1e868a95856376b240a473c2 -->

<!-- pgdoc-cn_start sig_en=17ec93f0da0cdb679ba90bbbb51658c9 sig_cn_org=None source=14.1 
   <para>
    <command>REINDEX SYSTEM</command> does not support
    <command>CONCURRENTLY</command> since system catalogs cannot be reindexed
    concurrently.
   </para>
________________________________________________________-->
   <para>
    <command>REINDEX SYSTEM</command> 不支持 <command>CONCURRENTLY</command> 因为系统目录不能并发重新索引。
   </para>
<!-- pgdoc-cn_end sig_en=17ec93f0da0cdb679ba90bbbb51658c9 -->

<!-- pgdoc-cn_start sig_en=84e305f1d3a86cd313f7bc0e0e59447f sig_cn_org=None source=14.1 
   <para>
    Furthermore, indexes for exclusion constraints cannot be reindexed
    concurrently.  If such an index is named directly in this command, an
    error is raised.  If a table or database with exclusion constraint indexes
    is reindexed concurrently, those indexes will be skipped.  (It is possible
    to reindex such indexes without the <command>CONCURRENTLY</command> option.)
   </para>
________________________________________________________-->
   <para>
    此外，排除约束的索引不能并发重新编制索引。 如果此命令中直接命名了这样的索引，则会引发错误。 
    如果并发重新编制具有排除约束索引的表或数据库，将跳过这些索引。 （它可以不使用<command>CONCURRENTLY</command>选项来重新编制这样的索引）。
   </para>
<!-- pgdoc-cn_end sig_en=84e305f1d3a86cd313f7bc0e0e59447f -->

<!-- pgdoc-cn_start sig_en=96827cdfb4d2ad6b7eac6a685ceef7fb sig_cn_org=None source=14.1 
  <para>
    Each backend running <command>REINDEX</command> will report its progress
    in the <structname>pg_stat_progress_create_index</structname> view. See
    <xref linkend="create-index-progress-reporting"/> for details.
  </para>
________________________________________________________-->
  <para>
    每个后端运行<command>REINDEX</command>将在<structname>pg_stat_progress_create_index</structname>视图中报告它的进度。
    详见<xref linkend="create-index-progress-reporting"/>。
  </para>
<!-- pgdoc-cn_end sig_en=96827cdfb4d2ad6b7eac6a685ceef7fb -->
  </refsect2>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
  <title>Examples</title>
________________________________________________________-->
  <title>示例</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=12a69fa1398ba3b6602aef8fc557520a sig_cn_org=None source=14.1 
  <para>
   Rebuild a single index:

<programlisting>
REINDEX INDEX my_index;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   重建单个索引：

<programlisting>
REINDEX INDEX my_index;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=12a69fa1398ba3b6602aef8fc557520a -->

<!-- pgdoc-cn_start sig_en=8be2cdd9091be1264cac4df57a43b22e sig_cn_org=None source=14.1 
  <para>
   Rebuild all the indexes on the table <literal>my_table</literal>:

<programlisting>
REINDEX TABLE my_table;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   重建表<literal>my_table</literal>上的所有索引：

<programlisting>
REINDEX TABLE my_table;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=8be2cdd9091be1264cac4df57a43b22e -->

<!-- pgdoc-cn_start sig_en=f381399723b895dd317b709c92effdf6 sig_cn_org=None source=14.1 
  <para>
   Rebuild all indexes in a particular database, without trusting the
   system indexes to be valid already:

<programlisting>
$ <userinput>export PGOPTIONS="-P"</userinput>
$ <userinput>psql broken_db</userinput>
...
broken_db=&gt; REINDEX DATABASE broken_db;
broken_db=&gt; \q
</programlisting></para>
________________________________________________________-->
  <para>
   重建一个特定数据库中的所有索引，且不假设系统索引已经可用：

<programlisting>
$ <userinput>export PGOPTIONS="-P"</userinput>
$ <userinput>psql broken_db</userinput>
...
broken_db=&gt; REINDEX DATABASE broken_db;
broken_db=&gt; \q
</programlisting></para>
<!-- pgdoc-cn_end sig_en=f381399723b895dd317b709c92effdf6 -->

<!-- pgdoc-cn_start sig_en=695b6152fd43ae952078273d9a8e3137 sig_cn_org=None source=14.1 
  <para>
   Rebuild indexes for a table, without blocking read and write operations
   on involved relations while reindexing is in progress:

<programlisting>
REINDEX TABLE CONCURRENTLY my_broken_table;
</programlisting></para>
________________________________________________________-->
  <para>
   重建表的索引，在重建索引过程中不阻止对相关关系进行读写操作：

<programlisting>
REINDEX TABLE CONCURRENTLY my_broken_table;
</programlisting></para>
<!-- pgdoc-cn_end sig_en=695b6152fd43ae952078273d9a8e3137 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
  <title>Compatibility</title>
________________________________________________________-->
  <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=5e92dbb612216b584304a9960ef45d72 sig_cn_org=None source=14.1 
  <para>
   There is no <command>REINDEX</command> command in the SQL standard.
  </para>
________________________________________________________-->
  <para>
   在 SQL 标准中没有<command>REINDEX</command>命令。
  </para>
<!-- pgdoc-cn_end sig_en=5e92dbb612216b584304a9960ef45d72 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=8b7cc214676b443e6527e3d6bf054420 sig_cn_org=None source=14.1 
  <title>See Also</title>
________________________________________________________-->
  <title>See Also</title>
<!-- pgdoc-cn_end sig_en=8b7cc214676b443e6527e3d6bf054420 -->

  <simplelist type="inline">
   <member><xref linkend="sql-createindex"/></member>
   <member><xref linkend="sql-dropindex"/></member>
   <member><xref linkend="app-reindexdb"/></member>
   <member><xref linkend="create-index-progress-reporting"/></member>
  </simplelist>
 </refsect1>
</refentry>
