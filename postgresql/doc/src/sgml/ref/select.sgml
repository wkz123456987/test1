<!--
doc/src/sgml/ref/select.sgml
PostgreSQL documentation
-->

<refentry id="sql-select">
<!-- pgdoc-cn_start sig_en=28beadc0ca1ef48823f39fb83bdb1f16 sig_cn_org=None source=14.1 
 <indexterm zone="sql-select">
  <primary>SELECT</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="sql-select">
  <primary>SELECT</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=28beadc0ca1ef48823f39fb83bdb1f16 -->

<!-- pgdoc-cn_start sig_en=4187048a956ab7d3346b584b783d6e4f sig_cn_org=None source=14.1 
 <indexterm zone="sql-select">
  <primary>TABLE command</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="sql-select">
  <primary>TABLE command</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=4187048a956ab7d3346b584b783d6e4f -->

<!-- pgdoc-cn_start sig_en=40d0155c05ac8c0f6c7c1a4820b499f6 sig_cn_org=None source=14.1 
 <indexterm zone="sql-select">
  <primary>WITH</primary>
  <secondary>in SELECT</secondary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="sql-select">
  <primary>WITH</primary>
  <secondary>in SELECT</secondary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=40d0155c05ac8c0f6c7c1a4820b499f6 -->

 <refmeta>
  <refentrytitle>SELECT</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

<!-- pgdoc-cn_start sig_en=e58381c063f5a097758c32f4ca655bd6 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SELECT</refname>
  <refname>TABLE</refname>
  <refname>WITH</refname>
  <refpurpose>retrieve rows from a table or view</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SELECT</refname>
  <refname>TABLE</refname>
  <refname>WITH</refname>
  <refpurpose>从一个表或视图检索行</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=e58381c063f5a097758c32f4ca655bd6 -->

<!-- pgdoc-cn_start sig_en=9de2b5699bbbd3365f8f70ebd52612c2 sig_cn_org=8f199f52bd0080032b7ac8a6fa8c8e89 source=15.7 
 <refsynopsisdiv>
<synopsis>
[ WITH [ RECURSIVE ] <replaceable class="parameter">with_query</replaceable> [, ...] ]
SELECT [ ALL | DISTINCT [ ON ( <replaceable class="parameter">expression</replaceable> [, ...] ) ] ]
    [ * | <replaceable class="parameter">expression</replaceable> [ [ AS ] <replaceable class="parameter">output_name</replaceable> ] [, ...] ]
    [ FROM <replaceable class="parameter">from_item</replaceable> [, ...] ]
    [ WHERE <replaceable class="parameter">condition</replaceable> ]
    [ GROUP BY [ ALL | DISTINCT ] <replaceable class="parameter">grouping_element</replaceable> [, ...] ]
    [ HAVING <replaceable class="parameter">condition</replaceable> ]
    [ WINDOW <replaceable class="parameter">window_name</replaceable> AS ( <replaceable class="parameter">window_definition</replaceable> ) [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] <replaceable class="parameter">select</replaceable> ]
    [ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operator</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
    [ LIMIT { <replaceable class="parameter">count</replaceable> | ALL } ]
    [ OFFSET <replaceable class="parameter">start</replaceable> [ ROW | ROWS ] ]
    [ FETCH { FIRST | NEXT } [ <replaceable class="parameter">count</replaceable> ] { ROW | ROWS } { ONLY | WITH TIES } ]
    [ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF <replaceable class="parameter">table_name</replaceable> [, ...] ] [ NOWAIT | SKIP LOCKED ] [...] ]

<phrase>where <replaceable class="parameter">from_item</replaceable> can be one of:</phrase>

    [ ONLY ] <replaceable class="parameter">table_name</replaceable> [ * ] [ [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">column_alias</replaceable> [, ...] ) ] ]
                [ TABLESAMPLE <replaceable class="parameter">sampling_method</replaceable> ( <replaceable class="parameter">argument</replaceable> [, ...] ) [ REPEATABLE ( <replaceable class="parameter">seed</replaceable> ) ] ]
    [ LATERAL ] ( <replaceable class="parameter">select</replaceable> ) [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">column_alias</replaceable> [, ...] ) ]
    <replaceable class="parameter">with_query_name</replaceable> [ [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">column_alias</replaceable> [, ...] ) ] ]
    [ LATERAL ] <replaceable class="parameter">function_name</replaceable> ( [ <replaceable class="parameter">argument</replaceable> [, ...] ] )
                [ WITH ORDINALITY ] [ [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">column_alias</replaceable> [, ...] ) ] ]
    [ LATERAL ] <replaceable class="parameter">function_name</replaceable> ( [ <replaceable class="parameter">argument</replaceable> [, ...] ] ) [ AS ] <replaceable class="parameter">alias</replaceable> ( <replaceable class="parameter">column_definition</replaceable> [, ...] )
    [ LATERAL ] <replaceable class="parameter">function_name</replaceable> ( [ <replaceable class="parameter">argument</replaceable> [, ...] ] ) AS ( <replaceable class="parameter">column_definition</replaceable> [, ...] )
    [ LATERAL ] ROWS FROM( <replaceable class="parameter">function_name</replaceable> ( [ <replaceable class="parameter">argument</replaceable> [, ...] ] ) [ AS ( <replaceable class="parameter">column_definition</replaceable> [, ...] ) ] [, ...] )
                [ WITH ORDINALITY ] [ [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">column_alias</replaceable> [, ...] ) ] ]
    <replaceable class="parameter">from_item</replaceable> <replaceable class="parameter">join_type</replaceable> <replaceable class="parameter">from_item</replaceable> { ON <replaceable class="parameter">join_condition</replaceable> | USING ( <replaceable class="parameter">join_column</replaceable> [, ...] ) [ AS <replaceable class="parameter">join_using_alias</replaceable> ] }
    <replaceable class="parameter">from_item</replaceable> NATURAL <replaceable class="parameter">join_type</replaceable> <replaceable class="parameter">from_item</replaceable>
    <replaceable class="parameter">from_item</replaceable> CROSS JOIN <replaceable class="parameter">from_item</replaceable>

<phrase>and <replaceable class="parameter">grouping_element</replaceable> can be one of:</phrase>

    ( )
    <replaceable class="parameter">expression</replaceable>
    ( <replaceable class="parameter">expression</replaceable> [, ...] )
    ROLLUP ( { <replaceable class="parameter">expression</replaceable> | ( <replaceable class="parameter">expression</replaceable> [, ...] ) } [, ...] )
    CUBE ( { <replaceable class="parameter">expression</replaceable> | ( <replaceable class="parameter">expression</replaceable> [, ...] ) } [, ...] )
    GROUPING SETS ( <replaceable class="parameter">grouping_element</replaceable> [, ...] )

<phrase>and <replaceable class="parameter">with_query</replaceable> is:</phrase>

    <replaceable class="parameter">with_query_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ] AS [ [ NOT ] MATERIALIZED ] ( <replaceable class="parameter">select</replaceable> | <replaceable class="parameter">values</replaceable> | <replaceable class="parameter">insert</replaceable> | <replaceable class="parameter">update</replaceable> | <replaceable class="parameter">delete</replaceable> )
        [ SEARCH { BREADTH | DEPTH } FIRST BY <replaceable>column_name</replaceable> [, ...] SET <replaceable>search_seq_col_name</replaceable> ]
        [ CYCLE <replaceable>column_name</replaceable> [, ...] SET <replaceable>cycle_mark_col_name</replaceable> [ TO <replaceable>cycle_mark_value</replaceable> DEFAULT <replaceable>cycle_mark_default</replaceable> ] USING <replaceable>cycle_path_col_name</replaceable> ]

TABLE [ ONLY ] <replaceable class="parameter">table_name</replaceable> [ * ]
</synopsis>
________________________________________________________-->
 <refsynopsisdiv>
<synopsis>
[ WITH [ RECURSIVE ] <replaceable class="parameter">with_query</replaceable> [, ...] ]
SELECT [ ALL | DISTINCT [ ON ( <replaceable class="parameter">expression</replaceable> [, ...] ) ] ]
    [ * | <replaceable class="parameter">expression</replaceable> [ [ AS ] <replaceable class="parameter">output_name</replaceable> ] [, ...] ]
    [ FROM <replaceable class="parameter">from_item</replaceable> [, ...] ]
    [ WHERE <replaceable class="parameter">condition</replaceable> ]
    [ GROUP BY [ ALL | DISTINCT ] <replaceable class="parameter">grouping_element</replaceable> [, ...] ]
    [ HAVING <replaceable class="parameter">condition</replaceable> ]
    [ WINDOW <replaceable class="parameter">window_name</replaceable> AS ( <replaceable class="parameter">window_definition</replaceable> ) [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] <replaceable class="parameter">select</replaceable> ]
    [ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operator</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
    [ LIMIT { <replaceable class="parameter">count</replaceable> | ALL } ]
    [ OFFSET <replaceable class="parameter">start</replaceable> [ ROW | ROWS ] ]
    [ FETCH { FIRST | NEXT } [ <replaceable class="parameter">count</replaceable> ] { ROW | ROWS } { ONLY | WITH TIES } ]
    [ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF <replaceable class="parameter">table_name</replaceable> [, ...] ] [ NOWAIT | SKIP LOCKED ] [...] ]

<phrase><replaceable class="parameter">from_item</replaceable>可以是以下之一：</phrase>

    [ ONLY ] <replaceable class="parameter">table_name</replaceable> [ * ] [ [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">column_alias</replaceable> [, ...] ) ] ]
                [ TABLESAMPLE <replaceable class="parameter">sampling_method</replaceable> ( <replaceable class="parameter">argument</replaceable> [, ...] ) [ REPEATABLE ( <replaceable class="parameter">seed</replaceable> ) ] ]
    [ LATERAL ] ( <replaceable class="parameter">select</replaceable> ) [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">column_alias</replaceable> [, ...] ) ]
    <replaceable class="parameter">with_query_name</replaceable> [ [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">column_alias</replaceable> [, ...] ) ] ]
    [ LATERAL ] <replaceable class="parameter">function_name</replaceable> ( [ <replaceable class="parameter">argument</replaceable> [, ...] ] )
                [ WITH ORDINALITY ] [ [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">column_alias</replaceable> [, ...] ) ] ]
    [ LATERAL ] <replaceable class="parameter">function_name</replaceable> ( [ <replaceable class="parameter">argument</replaceable> [, ...] ] ) [ AS ] <replaceable class="parameter">alias</replaceable> ( <replaceable class="parameter">column_definition</replaceable> [, ...] )
    [ LATERAL ] <replaceable class="parameter">function_name</replaceable> ( [ <replaceable class="parameter">argument</replaceable> [, ...] ] ) AS ( <replaceable class="parameter">column_definition</replaceable> [, ...] )
    [ LATERAL ] ROWS FROM( <replaceable class="parameter">function_name</replaceable> ( [ <replaceable class="parameter">argument</replaceable> [, ...] ] ) [ AS ( <replaceable class="parameter">column_definition</replaceable> [, ...] ) ] [, ...] )
                [ WITH ORDINALITY ] [ [ AS ] <replaceable class="parameter">alias</replaceable> [ ( <replaceable class="parameter">column_alias</replaceable> [, ...] ) ] ]
    <replaceable class="parameter">from_item</replaceable> <replaceable class="parameter">join_type</replaceable> <replaceable class="parameter">from_item</replaceable> { ON <replaceable class="parameter">join_condition</replaceable> | USING ( <replaceable class="parameter">join_column</replaceable> [, ...] ) [ AS <replaceable class="parameter">join_using_alias</replaceable> ] }
    <replaceable class="parameter">from_item</replaceable> NATURAL <replaceable class="parameter">join_type</replaceable> <replaceable class="parameter">from_item</replaceable>
    <replaceable class="parameter">from_item</replaceable> CROSS JOIN <replaceable class="parameter">from_item</replaceable>

<phrase>和<replaceable class="parameter">grouping_element</replaceable>可以是以下之一：</phrase>

    ( )
    <replaceable class="parameter">expression</replaceable>
    ( <replaceable class="parameter">expression</replaceable> [, ...] )
    ROLLUP ( { <replaceable class="parameter">expression</replaceable> | ( <replaceable class="parameter">expression</replaceable> [, ...] ) } [, ...] )
    CUBE ( { <replaceable class="parameter">expression</replaceable> | ( <replaceable class="parameter">expression</replaceable> [, ...] ) } [, ...] )
    GROUPING SETS ( <replaceable class="parameter">grouping_element</replaceable> [, ...] )

<phrase>和<replaceable class="parameter">with_query</replaceable>是：</phrase>

    <replaceable class="parameter">with_query_name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ] AS [ [ NOT ] MATERIALIZED ] ( <replaceable class="parameter">select</replaceable> | <replaceable class="parameter">values</replaceable> | <replaceable class="parameter">insert</replaceable> | <replaceable class="parameter">update</replaceable> | <replaceable class="parameter">delete</replaceable> ]
        [ SEARCH { BREADTH | DEPTH } FIRST BY <replaceable>column_name</replaceable> [, ...] SET <replaceable>search_seq_col_name</replaceable> ]
        [ CYCLE <replaceable>column_name</replaceable> [, ...] SET <replaceable>cycle_mark_col_name</replaceable> [ TO <replaceable>cycle_mark_value</replaceable> DEFAULT <replaceable>cycle_mark_default</replaceable> ] USING <replaceable>cycle_path_col_name</replaceable> ]

TABLE [ ONLY ] <replaceable class="parameter">table_name</replaceable> [ * ]
</synopsis>
<!-- pgdoc-cn_end sig_en=9de2b5699bbbd3365f8f70ebd52612c2 -->

 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=b4c34d2b3f39a69a9d3ed57a37ee21fc sig_cn_org=6bc98a8e34aa61d8b0d99b9402e72444 source=15.7 
  <para>
   <command>SELECT</command> retrieves rows from zero or more tables.
   The general processing of <command>SELECT</command> is as follows:

   <orderedlist>
    <listitem>
________________________________________________________-->
  <para>
   <command>SELECT</command>检索零个或多个表中的行。
   <command>SELECT</command>的一般处理如下：

   <orderedlist>
    <listitem>
<!-- pgdoc-cn_end sig_en=b4c34d2b3f39a69a9d3ed57a37ee21fc -->
<!-- pgdoc-cn_start sig_en=d3024e2c09379727100ad6b5ace38305 sig_cn_org=1b2af48c5deef11752419d1c9b1a2d8d source=15.7 
     <para>
      All queries in the <literal>WITH</literal> list are computed.
      These effectively serve as temporary tables that can be referenced
      in the <literal>FROM</literal> list.  A <literal>WITH</literal> query
      that is referenced more than once in <literal>FROM</literal> is
      computed only once,
      unless specified otherwise with <literal>NOT MATERIALIZED</literal>.
      (See <xref linkend="sql-with"/> below.)
     </para>
________________________________________________________-->
     <para>
      <literal>WITH</literal>列表中的所有查询都会被计算。
      这些实际上充当临时表，可以在<literal>FROM</literal>列表中引用。
      在<literal>FROM</literal>列表中多次引用的<literal>WITH</literal>查询只会计算一次，
      除非使用<literal>NOT MATERIALIZED</literal>进行其他指定。
      （参见下面的<xref linkend="sql-with"/>。）
</para>
<!-- pgdoc-cn_end sig_en=d3024e2c09379727100ad6b5ace38305 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=71369f2458a73394fb737e47650e04a3 sig_cn_org=e557936ac89921dd2c73acb628a2b205 source=15.7 
     <para>
      All elements in the <literal>FROM</literal> list are computed.
      (Each element in the <literal>FROM</literal> list is a real or
      virtual table.)  If more than one element is specified in the
      <literal>FROM</literal> list, they are cross-joined together.
      (See <xref linkend="sql-from"/> below.)
     </para>
________________________________________________________-->
     <para>
      所有<literal>FROM</literal>列表中的元素都会被计算。
      （<literal>FROM</literal>列表中的每个元素都是一个真实或虚拟表。）
      如果在<literal>FROM</literal>列表中指定了多个元素，则它们会被交叉连接在一起。
      （参见下面的<xref linkend="sql-from"/>。）
</para>
<!-- pgdoc-cn_end sig_en=71369f2458a73394fb737e47650e04a3 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=dfab9a0e99573b9f4a78569bfd555856 sig_cn_org=b91244002a2c20b5f4a5d4762e835b26 source=15.7 
     <para>
      If the <literal>WHERE</literal> clause is specified, all rows
      that do not satisfy the condition are eliminated from the
      output.  (See <xref linkend="sql-where"/> below.)
     </para>
________________________________________________________-->
     <para>
      如果指定了<literal>WHERE</literal>子句，则不满足条件的所有行将从输出中删除。
      （请参见下面的<xref linkend="sql-where"/>。）
</para>
<!-- pgdoc-cn_end sig_en=dfab9a0e99573b9f4a78569bfd555856 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=0303cfd5de76d7d4ac9e561d78443425 sig_cn_org=22df466f8d7cb2edc36b2f401135bc5f source=15.7 
     <para>
      If the <literal>GROUP BY</literal> clause is specified,
      or if there are aggregate function calls, the
      output is combined into groups of rows that match on one or more
      values, and the results of aggregate functions are computed.
      If the <literal>HAVING</literal> clause is present, it
      eliminates groups that do not satisfy the given condition.  (See
      <xref linkend="sql-groupby"/> and
      <xref linkend="sql-having"/> below.)
      Although query output columns are nominally computed in the next
      step, they can also be referenced (by name or ordinal number)
      in the <literal>GROUP BY</literal> clause.
     </para>
________________________________________________________-->
     <para>
      如果指定了<literal>GROUP BY</literal>子句，
      或者存在聚合函数调用，
      输出将合并为匹配一个或多个值的行组，
      并计算聚合函数的结果。
      如果存在<literal>HAVING</literal>子句，
      它将消除不满足给定条件的组。（参见
      <xref linkend="sql-groupby"/>和
      <xref linkend="sql-having"/>。）
      虽然查询输出列名义上是在下一步计算的，
      但它们也可以在<literal>GROUP BY</literal>子句中被引用（按名称或序号）。
     </para>
<!-- pgdoc-cn_end sig_en=0303cfd5de76d7d4ac9e561d78443425 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=4734c5fb125680ee973396a5dbe4ec48 sig_cn_org=d41ffef41a59555813e51ed584083c05 source=15.7 
     <para>
      The actual output rows are computed using the
      <command>SELECT</command> output expressions for each selected
      row or row group.  (See <xref linkend="sql-select-list"/> below.)
     </para>
________________________________________________________-->
     <para>
      实际输出行是使用每个选定行或行组的<command>SELECT</command>输出表达式计算的。
      （参见下面的<xref linkend="sql-select-list"/>。）
</para>
<!-- pgdoc-cn_end sig_en=4734c5fb125680ee973396a5dbe4ec48 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=8b76b5d26e8448084038c59fb6bce1f2 sig_cn_org=6004aee6e95fc19924a73c656eaa934c source=15.7 
     <para><literal>SELECT DISTINCT</literal> eliminates duplicate rows from the
      result.  <literal>SELECT DISTINCT ON</literal> eliminates rows that
      match on all the specified expressions.  <literal>SELECT ALL</literal>
      (the default) will return all candidate rows, including
      duplicates.  (See <xref linkend="sql-distinct"/> below.)
     </para>
________________________________________________________-->
     <para><literal>SELECT DISTINCT</literal>消除结果中的重复行。
      <literal>SELECT DISTINCT ON</literal>消除所有指定表达式匹配的行。
      <literal>SELECT ALL</literal>（默认）将返回所有候选行，包括重复行。
      （参见下面的<xref linkend="sql-distinct"/>。）
     </para>
<!-- pgdoc-cn_end sig_en=8b76b5d26e8448084038c59fb6bce1f2 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=417770760d51b9c557fae950dcfe6c3e sig_cn_org=108b1a7e0aaf3d124fc1ca0418160eb4 source=15.7 
     <para>
      Using the operators <literal>UNION</literal>,
      <literal>INTERSECT</literal>, and <literal>EXCEPT</literal>, the
      output of more than one <command>SELECT</command> statement can
      be combined to form a single result set.  The
      <literal>UNION</literal> operator returns all rows that are in
      one or both of the result sets.  The
      <literal>INTERSECT</literal> operator returns all rows that are
      strictly in both result sets.  The <literal>EXCEPT</literal>
      operator returns the rows that are in the first result set but
      not in the second.  In all three cases, duplicate rows are
      eliminated unless <literal>ALL</literal> is specified.  The noise
      word <literal>DISTINCT</literal> can be added to explicitly specify
      eliminating duplicate rows.  Notice that <literal>DISTINCT</literal> is
      the default behavior here, even though <literal>ALL</literal> is
      the default for <command>SELECT</command> itself.  (See
      <xref linkend="sql-union"/>, <xref linkend="sql-intersect"/>, and
      <xref linkend="sql-except"/> below.)
     </para>
________________________________________________________-->
     <para>
      使用运算符<literal>UNION</literal>、<literal>INTERSECT</literal>和<literal>EXCEPT</literal>，
      可以将多个<command>SELECT</command>语句的输出合并成一个结果集。 
      <literal>UNION</literal>运算符返回在一个或两个结果集中的所有行。 
      <literal>INTERSECT</literal>运算符返回严格在两个结果集中的所有行。 
      <literal>EXCEPT</literal>运算符返回在第一个结果集中但不在第二个结果集中的行。 
      在这三种情况下，除非指定<literal>ALL</literal>，否则将消除重复行。 
      噪声词<literal>DISTINCT</literal>可以添加以明确指定消除重复行。 
      请注意，这里的默认行为是<literal>DISTINCT</literal>，即使<command>SELECT</command>本身的默认行为是<literal>ALL</literal>。
      （请参见下面的<xref linkend="sql-union"/>、<xref linkend="sql-intersect"/>和<xref linkend="sql-except"/>。）
     </para>
<!-- pgdoc-cn_end sig_en=417770760d51b9c557fae950dcfe6c3e -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=a541aa05443950ba5f806b391da8c8c2 sig_cn_org=5780f05dcab694f43b32235a6e839671 source=15.7 
     <para>
      If the <literal>ORDER BY</literal> clause is specified, the
      returned rows are sorted in the specified order.  If
      <literal>ORDER BY</literal> is not given, the rows are returned
      in whatever order the system finds fastest to produce.  (See
      <xref linkend="sql-orderby"/> below.)
     </para>
________________________________________________________-->
     <para>
      如果指定了<literal>ORDER BY</literal>子句，则返回的行按指定顺序排序。
      如果没有给出<literal>ORDER BY</literal>，系统将以最快速度返回行。
      （参见下面的<xref linkend="sql-orderby"/>。）
</para>
<!-- pgdoc-cn_end sig_en=a541aa05443950ba5f806b391da8c8c2 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=26dc0d5dfb2babcf27494987ebcb68b6 sig_cn_org=fe90644d402607d11b61cf9a3c0853b5 source=15.7 
     <para>
      If the <literal>LIMIT</literal> (or <literal>FETCH FIRST</literal>) or <literal>OFFSET</literal>
      clause is specified, the <command>SELECT</command> statement
      only returns a subset of the result rows. (See <xref
      linkend="sql-limit"/> below.)
     </para>
________________________________________________________-->
     <para>
      如果指定了<literal>LIMIT</literal>（或<literal>FETCH FIRST</literal>）或<literal>OFFSET</literal>子句，
      <command>SELECT</command>语句只返回结果行的子集。（参见下面的<xref
      linkend="sql-limit"/>。）
     </para>
<!-- pgdoc-cn_end sig_en=26dc0d5dfb2babcf27494987ebcb68b6 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=75b7fb24c8f3c900e1f32c03921c04d4 sig_cn_org=137ab9341b4c47e5e7bc02b25cae4981 source=15.7 
     <para>
      If <literal>FOR UPDATE</literal>, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR SHARE</literal>
      or <literal>FOR KEY SHARE</literal>
      is specified, the
      <command>SELECT</command> statement locks the selected rows
      against concurrent updates.  (See <xref linkend="sql-for-update-share"/>
      below.)
     </para>
________________________________________________________-->
     <para>
      如果指定了<literal>FOR UPDATE</literal>、<literal>FOR NO KEY UPDATE</literal>、<literal>FOR SHARE</literal>
      或<literal>FOR KEY SHARE</literal>，
      <command>SELECT</command>语句将选定的行锁定，防止并发更新。（参见下面的<xref linkend="sql-for-update-share"/>。）
     </para>
<!-- pgdoc-cn_end sig_en=75b7fb24c8f3c900e1f32c03921c04d4 -->
    </listitem>
   </orderedlist>
  </para>

<!-- pgdoc-cn_start sig_en=6f297fbbc776284ea27f882ab65629fb sig_cn_org=None source=14.1 
  <para>
   You must have <literal>SELECT</literal> privilege on each column used
   in a <command>SELECT</command> command.  The use of <literal>FOR NO KEY UPDATE</literal>,
   <literal>FOR UPDATE</literal>,
   <literal>FOR SHARE</literal> or <literal>FOR KEY SHARE</literal> requires
   <literal>UPDATE</literal> privilege as well (for at least one column
   of each table so selected).
  </para>
________________________________________________________-->
  <para>
   你必须拥有在一个<command>SELECT</command>命令中使用的每一列上的
   <literal>SELECT</literal>特权。<literal>FOR NO KEY UPDATE</literal>、
   <literal>FOR UPDATE</literal>、
   <literal>FOR SHARE</literal>或者<literal>FOR KEY SHARE</literal>
   还要求（对这样选中的每一个表至少一列的）<literal>UPDATE</literal>
   特权。
  </para>
<!-- pgdoc-cn_end sig_en=6f297fbbc776284ea27f882ab65629fb -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
  <title>Parameters</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

  <refsect2 id="sql-with" xreflabel="WITH Clause">
<!-- pgdoc-cn_start sig_en=ce0b5c87d02b944e51865a12f85bea11 sig_cn_org=None source=14.1 
   <title><literal>WITH</literal> Clause</title>
________________________________________________________-->
   <title><literal>WITH</literal> 子句</title>
<!-- pgdoc-cn_end sig_en=ce0b5c87d02b944e51865a12f85bea11 -->

<!-- pgdoc-cn_start sig_en=f76c748c9a319d533661b0e9f738038d sig_cn_org=None source=14.1 
   <para>
    The <literal>WITH</literal> clause allows you to specify one or more
    subqueries that can be referenced by name in the primary query.
    The subqueries effectively act as temporary tables or views
    for the duration of the primary query.
    Each subquery can be a <command>SELECT</command>, <command>TABLE</command>, <command>VALUES</command>,
    <command>INSERT</command>, <command>UPDATE</command> or
    <command>DELETE</command> statement.
    When writing a data-modifying statement (<command>INSERT</command>,
    <command>UPDATE</command> or <command>DELETE</command>) in
    <literal>WITH</literal>, it is usual to include a <literal>RETURNING</literal> clause.
    It is the output of <literal>RETURNING</literal>, <emphasis>not</emphasis> the underlying
    table that the statement modifies, that forms the temporary table that is
    read by the primary query.  If <literal>RETURNING</literal> is omitted, the
    statement is still executed, but it produces no output so it cannot be
    referenced as a table by the primary query.
   </para>
________________________________________________________-->
   <para>
    <literal>WITH</literal>子句允许你指定一个或者多个在主查询中可以
    其名称引用的子查询。在主查询期间子查询实际扮演了临时表或者视图
    的角色。每一个子查询都可以是一个<command>SELECT</command>、
    <command>TABLE</command>、<command>VALUES</command>、
    <command>INSERT</command>、
    <command>UPDATE</command>或者
    <command>DELETE</command>语句。在<literal>WITH</literal>中书写
    一个数据修改语句（<command>INSERT</command>、
    <command>UPDATE</command>或者
    <command>DELETE</command>）时，通常要包括一个
    <literal>RETURNING</literal>子句。构成被主查询读取的临时表的是
    <literal>RETURNING</literal>的输出，而<emphasis>不是</emphasis>该语句修改的
    底层表。如果省略<literal>RETURNING</literal>，该语句仍会被执行，但是它
    不会产生输出，因此它不能作为一个表从主查询引用。
   </para>
<!-- pgdoc-cn_end sig_en=f76c748c9a319d533661b0e9f738038d -->

<!-- pgdoc-cn_start sig_en=9c23741ca5985cb19fec5e893a858421 sig_cn_org=None source=14.1 
   <para>
    A name (without schema qualification) must be specified for each
    <literal>WITH</literal> query.  Optionally, a list of column names
    can be specified; if this is omitted,
    the column names are inferred from the subquery.
   </para>
________________________________________________________-->
   <para>
    对于每一个<literal>WITH</literal>查询，都必须指定一个名称（无需模
    式限定）。可选地，可以指定一个列名列表。如果省略该列表，会从该子查
    询中推导列名。
   </para>
<!-- pgdoc-cn_end sig_en=9c23741ca5985cb19fec5e893a858421 -->

<!-- pgdoc-cn_start sig_en=100c4de425772dc245fe1e0c1e5ee0fe sig_cn_org=None source=14.1 
   <para>
    If <literal>RECURSIVE</literal> is specified, it allows a
    <command>SELECT</command> subquery to reference itself by name.  Such a
    subquery must have the form
<synopsis>
<replaceable class="parameter">non_recursive_term</replaceable> UNION [ ALL | DISTINCT ] <replaceable class="parameter">recursive_term</replaceable>
</synopsis>
    where the recursive self-reference must appear on the right-hand
    side of the <literal>UNION</literal>.  Only one recursive self-reference
    is permitted per query.  Recursive data-modifying statements are not
    supported, but you can use the results of a recursive
    <command>SELECT</command> query in
    a data-modifying statement.  See <xref linkend="queries-with"/> for
    an example.
   </para>
________________________________________________________-->
   <para>
    如果指定了<literal>RECURSIVE</literal>，则允许一个
    <command>SELECT</command>子查询使用名称引用自身。
    这样一个子查询的形式必须是
<synopsis>
<replaceable class="parameter">non_recursive_term</replaceable> UNION [ ALL | DISTINCT ] <replaceable class="parameter">recursive_term</replaceable>
</synopsis>
    其中递归自引用必须出现在<literal>UNION</literal>的右手边。每个
    查询中只允许一个递归自引用。不支持递归数据修改语句，但是
    可以在一个数据查询语句中使用一个递归
    <command>SELECT</command>查询的结果。例子可见
    <xref linkend="queries-with"/>。
   </para>
<!-- pgdoc-cn_end sig_en=100c4de425772dc245fe1e0c1e5ee0fe -->

<!-- pgdoc-cn_start sig_en=83107fb756b1d2f80aeed58a1399adc0 sig_cn_org=None source=14.1 
   <para>
    Another effect of <literal>RECURSIVE</literal> is that
    <literal>WITH</literal> queries need not be ordered: a query
    can reference another one that is later in the list.  (However,
    circular references, or mutual recursion, are not implemented.)
    Without <literal>RECURSIVE</literal>, <literal>WITH</literal> queries
    can only reference sibling <literal>WITH</literal> queries
    that are earlier in the <literal>WITH</literal> list.
   </para>
________________________________________________________-->
   <para>
    <literal>RECURSIVE</literal>的另一个效果是
    <literal>WITH</literal>查询不需要被排序：一个查询可以引用另一个
    在列表中比它靠后的查询（不过，循环引用或者互递归没有实现）。
    如果没有<literal>RECURSIVE</literal>，<literal>WITH</literal>
    查询只能引用在<literal>WITH</literal>列表中位置更前面的兄弟
    <literal>WITH</literal>查询。
   </para>
<!-- pgdoc-cn_end sig_en=83107fb756b1d2f80aeed58a1399adc0 -->

<!-- pgdoc-cn_start sig_en=cdd361df83931f780307b98d43218f64 sig_cn_org=None source=14.1 
   <para>
    When there are multiple queries in the <literal>WITH</literal>
    clause, <literal>RECURSIVE</literal> should be written only once,
    immediately after <literal>WITH</literal>.  It applies to all queries
    in the <literal>WITH</literal> clause, though it has no effect on
    queries that do not use recursion or forward references.
   </para>
________________________________________________________-->
   <para>
    当<literal>WITH</literal>子句中有多个查询时，<literal>RECURSIVE</literal>应只编写一次，紧跟在<literal>WITH</literal>之后。
    它适用于<literal>WITH</literal>子句中的所有查询，尽管它对不使用递归或前向引用的查询没有影响。
   </para>
<!-- pgdoc-cn_end sig_en=cdd361df83931f780307b98d43218f64 -->

<!-- pgdoc-cn_start sig_en=3eb3513ea5803df1025ca70078ada7ea sig_cn_org=None source=14.1 
   <para>
    The optional <literal>SEARCH</literal> clause computes a <firstterm>search
    sequence column</firstterm> that can be used for ordering the results of a
    recursive query in either breadth-first or depth-first order.  The
    supplied column name list specifies the row key that is to be used for
    keeping track of visited rows.  A column named
    <replaceable>search_seq_col_name</replaceable> will be added to the result
    column list of the <literal>WITH</literal> query.  This column can be
    ordered by in the outer query to achieve the respective ordering.  See
    <xref linkend="queries-with-search"/> for examples.
   </para>
________________________________________________________-->
   <para>
    可选的<literal>SEARCH</literal>子句计算一个<firstterm>search sequence column</firstterm>，可用于按宽度优先或深度优先的顺序对递归查询的结果排序。
    提供的列名列表指定用于保持跟踪已访问行的行键。
    名为<replaceable>search_seq_col_name</replaceable>的列将被添加到<literal>WITH</literal>查询的结果列列表中。
    这个列可以通过外部查询进行排序，以实现单独的排序。
    示例请见<xref linkend="queries-with-search"/> 。
   </para>
<!-- pgdoc-cn_end sig_en=3eb3513ea5803df1025ca70078ada7ea -->

<!-- pgdoc-cn_start sig_en=ad7ab851af7df6e8ff1ab09b3bcfa942 sig_cn_org=None source=14.1 
   <para>
    The optional <literal>CYCLE</literal> clause is used to detect cycles in
    recursive queries.  The supplied column name list specifies the row key
    that is to be used for keeping track of visited rows.  A column named
    <replaceable>cycle_mark_col_name</replaceable> will be added to the result
    column list of the <literal>WITH</literal> query.  This column will be set
    to <replaceable>cycle_mark_value</replaceable> when a cycle has been
    detected, else to <replaceable>cycle_mark_default</replaceable>.
    Furthermore, processing of the recursive union will stop when a cycle has
    been detected.  <replaceable>cycle_mark_value</replaceable> and
    <replaceable>cycle_mark_default</replaceable> must be constants and they
    must be coercible to a common data type, and the data type must have an
    inequality operator.  (The SQL standard requires that they be Boolean
    constants or character strings, but PostgreSQL does not require that.)  By
    default, <literal>TRUE</literal> and <literal>FALSE</literal> (of type
    <type>boolean</type>) are used.  Furthermore, a column
    named <replaceable>cycle_path_col_name</replaceable> will be added to the
    result column list of the <literal>WITH</literal> query.  This column is
    used internally for tracking visited rows.  See <xref
    linkend="queries-with-cycle"/> for examples.
   </para>
________________________________________________________-->
   <para>
    可选的<literal>CYCLE</literal>子句用于检测递归查询中的周期。
    提供的列名列表指定将用于保持跟踪访问的行的行键。
    名为<replaceable>cycle_mark_col_name</replaceable>的列，将被添加到<literal>WITH</literal>查询的结果列的列表中。
    当检测到循环时，此列将设置为<replaceable>cycle_mark_value</replaceable>，否则为<replaceable>cycle_mark_default</replaceable>。
    此外，当检测到循环时，递归联合的处理将停止。
    <replaceable>cycle_mark_value</replaceable>和<replaceable>cycle_mark_default</replaceable>必须是常量，并且它们必须被强制为公共数据类型，并且数据类型必须有一个不等运算符。
    (SQL标准要求它们是Boolean常量或字符串，但PostgreSQL不要求那样。)
    默认为使用<literal>TRUE</literal> 和 <literal>FALSE</literal> (<type>boolean</type>类型)。
    此外，名为<replaceable>cycle_path_col_name</replaceable>的列将被添加到<literal>WITH</literal>查询的结果列的列表中。
    此列将用于跟踪访问的行的内部。
    示例请参见<xref linkend="queries-with-cycle"/> 
   </para>
<!-- pgdoc-cn_end sig_en=ad7ab851af7df6e8ff1ab09b3bcfa942 -->

<!-- pgdoc-cn_start sig_en=28da67fcc72da5361bc478d15cbd0dc7 sig_cn_org=None source=14.1 
   <para>
    Both the <literal>SEARCH</literal> and the <literal>CYCLE</literal> clause
    are only valid for recursive <literal>WITH</literal> queries.  The
    <replaceable>with_query</replaceable> must be a <literal>UNION</literal>
    (or <literal>UNION ALL</literal>) of two <literal>SELECT</literal> (or
    equivalent) commands (no nested <literal>UNION</literal>s).  If both
    clauses are used, the column added by the <literal>SEARCH</literal> clause
    appears before the columns added by the <literal>CYCLE</literal> clause.
   </para>
________________________________________________________-->
   <para>
    <literal>SEARCH</literal>和<literal>CYCLE</literal>子句仅对递归<literal>WITH</literal>查询有效。
    <replaceable>with_query</replaceable>必须是两个<literal>SELECT</literal>(或等效)命令(非嵌套<literal>UNION</literal>)的<literal>UNION</literal>(或<literal>UNION ALL</literal>) 
    如果同时使用两个子句，<literal>SEARCH</literal>子句添加的列出现在<literal>CYCLE</literal> 子句添加的列之前。
   </para>
<!-- pgdoc-cn_end sig_en=28da67fcc72da5361bc478d15cbd0dc7 -->

<!-- pgdoc-cn_start sig_en=84f272ab08758caaef603e7c7a19ead5 sig_cn_org=None source=14.1 
   <para>
    The primary query and the <literal>WITH</literal> queries are all
    (notionally) executed at the same time.  This implies that the effects of
    a data-modifying statement in <literal>WITH</literal> cannot be seen from
    other parts of the query, other than by reading its <literal>RETURNING</literal>
    output.  If two such data-modifying statements attempt to modify the same
    row, the results are unspecified.
   </para>
________________________________________________________-->
   <para>
    主查询以及<literal>WITH</literal>查询全部（理论上）在同一时间
    被执行。这意味着从该查询的任何部分都无法看到
    <literal>WITH</literal>中的一个数据修改语句的效果，不过可以读
    取其<literal>RETURNING</literal>输出。如果两个这样的数据修改语句
    尝试修改相同的行，结果将无法确定。
   </para>
<!-- pgdoc-cn_end sig_en=84f272ab08758caaef603e7c7a19ead5 -->

<!-- pgdoc-cn_start sig_en=4524f9e7a7fcd53700bd7a5a2b102e66 sig_cn_org=None source=14.1 
   <para>
    A key property of <literal>WITH</literal> queries is that they
    are normally evaluated only once per execution of the primary query,
    even if the primary query refers to them more than once.
    In particular, data-modifying statements are guaranteed to be
    executed once and only once, regardless of whether the primary query
    reads all or any of their output.
   </para>
________________________________________________________-->
   <para>
    <literal>WITH</literal>查询的一个关键属性是，即使主查询多次引用它们，它们通常每次执行主查询只计算一次。
	特别是，数据修改语句确保执行一次而且只执行一次，而与主查询是否读取它们的全部或任何输出无关。
   </para>
<!-- pgdoc-cn_end sig_en=4524f9e7a7fcd53700bd7a5a2b102e66 -->

<!-- pgdoc-cn_start sig_en=bad413472489c049888833eec36fcd67 sig_cn_org=None source=14.1 
   <para>
    However, a <literal>WITH</literal> query can be marked
    <literal>NOT MATERIALIZED</literal> to remove this guarantee.  In that
    case, the <literal>WITH</literal> query can be folded into the primary
    query much as though it were a simple sub-<literal>SELECT</literal> in
    the primary query's <literal>FROM</literal> clause.  This results in
    duplicate computations if the primary query refers to
    that <literal>WITH</literal> query more than once; but if each such use
    requires only a few rows of the <literal>WITH</literal> query's total
    output, <literal>NOT MATERIALIZED</literal> can provide a net savings by
    allowing the queries to be optimized jointly.
    <literal>NOT MATERIALIZED</literal> is ignored if it is attached to
    a <literal>WITH</literal> query that is recursive or is not
    side-effect-free (i.e., is not a plain <literal>SELECT</literal>
    containing no volatile functions).
   </para>
________________________________________________________-->
   <para>
    但是，<literal>WITH</literal>查询可以标记为<literal>NOT MATERIALIZED</literal>以移除此保证。
	在这种情况下，<literal>WITH</literal>查询可以折叠到主查询中，就好像它是主查询的<literal>FROM</literal>子句中的简单的sub-<literal>SELECT</literal>。 
	如果主查询多次引用<literal>WITH</literal>查询，则会导致重复计算;但是，如果每次此类使用只需要<literal>WITH</literal>查询的总输出中的几行，<literal>NOT MATERIALIZED</literal>可以通过允许查询联合优化来节省开销。
	<literal>NOT MATERIALIZED</literal>被忽略，如果它被附加到一个递归的<literal>WITH</literal>查询，或者不是边际效应无关的（也就是说，不是包含非易失性函数的普通的<literal>SELECT</literal>）。
   </para>
<!-- pgdoc-cn_end sig_en=bad413472489c049888833eec36fcd67 -->

<!-- pgdoc-cn_start sig_en=78d254479d1d0519df741c1902a72b39 sig_cn_org=None source=14.1 
   <para>
    By default, a side-effect-free <literal>WITH</literal> query is folded
    into the primary query if it is used exactly once in the primary
    query's <literal>FROM</literal> clause.  This allows joint optimization
    of the two query levels in situations where that should be semantically
    invisible.  However, such folding can be prevented by marking the
    <literal>WITH</literal> query as <literal>MATERIALIZED</literal>.
    That might be useful, for example, if the <literal>WITH</literal> query
    is being used as an optimization fence to prevent the planner from
    choosing a bad plan.
    <productname>PostgreSQL</productname> versions before v12 never did
    such folding, so queries written for older versions might rely on
    <literal>WITH</literal> to act as an optimization fence.
   </para>
________________________________________________________-->
   <para>
    默认情况下，如果查询在主查询的<literal>FROM</literal>子句中仅一次使用，则边际效应无关的<literal>WITH</literal>查询将折叠到主查询中。
    这允许在语义不可见的情况下两个查询级别的联合优化。 但是，通过将<literal>WITH</literal>查询标记为<literal>MATERIALIZED</literal>，可以防止此类折叠。
    这可能很有用，例如，如果<literal>WITH</literal>查询被用作优化围栏，以防止规划者选择错误计划。
    <productname>PostgreSQL</productname>v12版本之前没有做过这样的折叠，所以为旧版本编写的查询可能依赖于<literal>WITH</literal>作为优化围栏。
   </para>
<!-- pgdoc-cn_end sig_en=78d254479d1d0519df741c1902a72b39 -->

<!-- pgdoc-cn_start sig_en=9a26da24b63b2305e03e0764e275c548 sig_cn_org=None source=14.1 
   <para>
    See <xref linkend="queries-with"/> for additional information.
   </para>
________________________________________________________-->
   <para>
    更多信息请见<xref linkend="queries-with"/>。
   </para>
<!-- pgdoc-cn_end sig_en=9a26da24b63b2305e03e0764e275c548 -->
  </refsect2>

  <refsect2 id="sql-from" xreflabel="FROM Clause">
<!-- pgdoc-cn_start sig_en=ad8126135d93a6a782e6c69c4d205f68 sig_cn_org=None source=14.1 
   <title><literal>FROM</literal> Clause</title>
________________________________________________________-->
   <title><literal>FROM</literal> 子句</title>
<!-- pgdoc-cn_end sig_en=ad8126135d93a6a782e6c69c4d205f68 -->

<!-- pgdoc-cn_start sig_en=878bbc5522425cf87adf9883173c8324 sig_cn_org=None source=14.1 
   <para>
    The <literal>FROM</literal> clause specifies one or more source
    tables for the <command>SELECT</command>.  If multiple sources are
    specified, the result is the Cartesian product (cross join) of all
    the sources.  But usually qualification conditions are added (via
    <literal>WHERE</literal>) to restrict the returned rows to a small subset of the
    Cartesian product.
   </para>
________________________________________________________-->
   <para>
    <literal>FROM</literal>子句为<command>SELECT</command>
    指定一个或者更多源表。如果指定了多个源表，结果将是所有源表的
    笛卡尔积（交叉连接）。但是通常会增加限定条件（通过
    <literal>WHERE</literal>）来把返回的行限制为该笛卡尔积的一个小子集。
   </para>
<!-- pgdoc-cn_end sig_en=878bbc5522425cf87adf9883173c8324 -->

<!-- pgdoc-cn_start sig_en=ec9aa84fe7ce1d941bebc48e72c25c9a sig_cn_org=b5ab7ebdb897232c1e737523d48b8fec source=15.7 
   <para>
    The <literal>FROM</literal> clause can contain the following
    elements:

    <variablelist>
     <varlistentry>
________________________________________________________-->
   <para>
    <literal>FROM</literal>子句可以包含以下元素：

    <variablelist>
     <varlistentry>
<!-- pgdoc-cn_end sig_en=ec9aa84fe7ce1d941bebc48e72c25c9a -->
      <term><replaceable class="parameter">table_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=ed2b76bd952606fc9e76e618f1e515a8 sig_cn_org=bbaea8871ee4277220b7536247dde353 source=15.7 
       <para>
        The name (optionally schema-qualified) of an existing table or view.
        If <literal>ONLY</literal> is specified before the table name, only that
        table is scanned.  If <literal>ONLY</literal> is not specified, the table
        and all its descendant tables (if any) are scanned.  Optionally,
        <literal>*</literal> can be specified after the table name to explicitly
        indicate that descendant tables are included.
       </para>
________________________________________________________-->
       <para>
        要扫描的现有表或视图的名称（可选模式限定符）。如果在表名之前指定<literal>ONLY</literal>，
        则仅扫描该表。如果未指定<literal>ONLY</literal>，则扫描该表及其所有后代表（如果有）。
        可选地，可以在表名后指定<literal>*</literal>，以明确指示包括后代表。
       </para>
<!-- pgdoc-cn_end sig_en=ed2b76bd952606fc9e76e618f1e515a8 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">alias</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=823bdf73b39c89abd5812cbc8039e99d sig_cn_org=0d829737b1f2e8367b544b33ac6b2434 source=15.7 
       <para>
        A substitute name for the <literal>FROM</literal> item containing the
        alias.  An alias is used for brevity or to eliminate ambiguity
        for self-joins (where the same table is scanned multiple
        times).  When an alias is provided, it completely hides the
        actual name of the table or function; for example given
        <literal>FROM foo AS f</literal>, the remainder of the
        <command>SELECT</command> must refer to this <literal>FROM</literal>
        item as <literal>f</literal> not <literal>foo</literal>.  If an alias is
        written, a column alias list can also be written to provide
        substitute names for one or more columns of the table.
       </para>
________________________________________________________-->
       <para>
        一个替代名称，用于包含别名的<literal>FROM</literal>项。别名用于简洁或消除自连接（同一表被多次扫描）的歧义。
        当提供别名时，它完全隐藏了表或函数的实际名称；例如给定<literal>FROM foo AS f</literal>，<command>SELECT</command>的其余部分必须引用此<literal>FROM</literal>项为<literal>f</literal>而不是<literal>foo</literal>。
        如果写了一个别名，还可以写一个列别名列表，为表的一个或多个列提供替代名称。
       </para>
<!-- pgdoc-cn_end sig_en=823bdf73b39c89abd5812cbc8039e99d -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>TABLESAMPLE <replaceable class="parameter">sampling_method</replaceable> ( <replaceable class="parameter">argument</replaceable> [, ...] ) [ REPEATABLE ( <replaceable class="parameter">seed</replaceable> ) ]</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=afac6ed1a62ff91b85cd5996a32e1839 sig_cn_org=3a978ceb8cca05f9f4c16937786fbe79 source=15.7 
       <para>
        A <literal>TABLESAMPLE</literal> clause after
        a <replaceable class="parameter">table_name</replaceable> indicates that the
        specified <replaceable class="parameter">sampling_method</replaceable>
        should be used to retrieve a subset of the rows in that table.
        This sampling precedes the application of any other filters such
        as <literal>WHERE</literal> clauses.
        The standard <productname>PostgreSQL</productname> distribution
        includes two sampling methods, <literal>BERNOULLI</literal>
        and <literal>SYSTEM</literal>, and other sampling methods can be
        installed in the database via extensions.
       </para>
________________________________________________________-->
       <para>
        一个<literal>TABLESAMPLE</literal>子句在一个<replaceable class="parameter">table_name</replaceable>之后指示应该使用指定的<replaceable class="parameter">sampling_method</replaceable>来检索该表中的行的子集。这种抽样在应用任何其他过滤器之前进行，比如<literal>WHERE</literal>子句。标准的<productname>PostgreSQL</productname>发行版包括两种抽样方法，<literal>BERNOULLI</literal>和<literal>SYSTEM</literal>，其他抽样方法可以通过扩展安装在数据库中。
       </para>
<!-- pgdoc-cn_end sig_en=afac6ed1a62ff91b85cd5996a32e1839 -->

<!-- pgdoc-cn_start sig_en=7de66ef0b271d316f01063461a6a54b1 sig_cn_org=4de2ca0f12d402d9ace5595f01638efd source=15.7 
       <para>
        The <literal>BERNOULLI</literal> and <literal>SYSTEM</literal> sampling methods
        each accept a single <replaceable class="parameter">argument</replaceable>
        which is the fraction of the table to sample, expressed as a
        percentage between 0 and 100.  This argument can be
        any <type>real</type>-valued expression.  (Other sampling methods might
        accept more or different arguments.)  These two methods each return
        a randomly-chosen sample of the table that will contain
        approximately the specified percentage of the table's rows.
        The <literal>BERNOULLI</literal> method scans the whole table and
        selects or ignores individual rows independently with the specified
        probability.
        The <literal>SYSTEM</literal> method does block-level sampling with
        each block having the specified chance of being selected; all rows
        in each selected block are returned.
        The <literal>SYSTEM</literal> method is significantly faster than
        the <literal>BERNOULLI</literal> method when small sampling
        percentages are specified, but it may return a less-random sample of
        the table as a result of clustering effects.
       </para>
________________________________________________________-->
       <para>
        <literal>BERNOULLI</literal>和<literal>SYSTEM</literal>抽样方法
        各接受一个<replaceable class="parameter">argument</replaceable>
        ，即要抽样的表格比例，表示为0到100之间的百分比。
        此参数可以是任何<type>实数</type>表达式。
        （其他抽样方法可能接受更多或不同的参数。）
        这两种方法各自返回表格的一个随机选择样本，该样本将包含
        大约指定百分比的表格行。
        <literal>BERNOULLI</literal>方法扫描整个表格，并
        以指定概率独立选择或忽略单个行。
        <literal>SYSTEM</literal>方法进行块级抽样，
        每个块有指定的选择机会；返回每个选定块中的所有行。
        当指定小的抽样百分比时，<literal>SYSTEM</literal>方法比
        <literal>BERNOULLI</literal>方法快得多，但由于聚类效应，
        可能返回表格的不太随机的样本。
       </para>
<!-- pgdoc-cn_end sig_en=7de66ef0b271d316f01063461a6a54b1 -->

<!-- pgdoc-cn_start sig_en=43030f029dd8d1998dd1a59c575533c5 sig_cn_org=9033078111a0afe886164c5079276b00 source=15.7 
       <para>
        The optional <literal>REPEATABLE</literal> clause specifies
        a <replaceable class="parameter">seed</replaceable> number or expression to use
        for generating random numbers within the sampling method.  The seed
        value can be any non-null floating-point value.  Two queries that
        specify the same seed and <replaceable class="parameter">argument</replaceable>
        values will select the same sample of the table, if the table has
        not been changed meanwhile.  But different seed values will usually
        produce different samples.
        If <literal>REPEATABLE</literal> is not given then a new random
        sample is selected for each query, based upon a system-generated seed.
        Note that some add-on sampling methods do not
        accept <literal>REPEATABLE</literal>, and will always produce new
        samples on each use.
       </para>
________________________________________________________-->
       <para>
        可选的<literal>REPEATABLE</literal>子句指定用于在抽样方法中生成随机数的<replaceable class="parameter">seed</replaceable>数或表达式。
        种子值可以是任何非空浮点值。如果两个查询指定相同的种子和<replaceable class="parameter">argument</replaceable>值，
        则如果表在此期间未更改，则将选择相同的表样本。但是不同的种子值通常会产生不同的样本。
        如果未给出<literal>REPEATABLE</literal>，则每个查询都会选择一个新的随机样本，基于系统生成的种子。
        请注意，一些附加的抽样方法不接受<literal>REPEATABLE</literal>，并且在每次使用时总是生成新的样本。
       </para>
<!-- pgdoc-cn_end sig_en=43030f029dd8d1998dd1a59c575533c5 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">select</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=ddc9b6396678f2ddecdd2a81ab34a658 sig_cn_org=a720b3a0c1c2535fba0c08b68c9cc70a source=15.7 
       <para>
        A sub-<command>SELECT</command> can appear in the
        <literal>FROM</literal> clause.  This acts as though its
        output were created as a temporary table for the duration of
        this single <command>SELECT</command> command.  Note that the
        sub-<command>SELECT</command> must be surrounded by
        parentheses, and an alias <emphasis>must</emphasis> be
        provided for it.  A
        <link linkend="sql-values"><command>VALUES</command></link> command
        can also be used here.
       </para>
________________________________________________________-->
       <para>
        子<command>SELECT</command>可以出现在<literal>FROM</literal>子句中。这就好像它的输出被创建为临时表，仅在这个单个<command>SELECT</command>命令的持续时间内有效。
        注意，子<command>SELECT</command>必须用括号括起来，并且<emphasis>必须</emphasis>为其提供一个别名。在这里还可以使用<link linkend="sql-values"><command>VALUES</command></link>命令。
</para>
<!-- pgdoc-cn_end sig_en=ddc9b6396678f2ddecdd2a81ab34a658 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">with_query_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=6d7cfada5d542ffffc4374300d1f008d sig_cn_org=e7b087057ddec0f3d4f715cf5ed93a88 source=15.7 
       <para>
        A <literal>WITH</literal> query is referenced by writing its name,
        just as though the query's name were a table name.  (In fact,
        the <literal>WITH</literal> query hides any real table of the same name
        for the purposes of the primary query.  If necessary, you can
        refer to a real table of the same name by schema-qualifying
        the table's name.)
        An alias can be provided in the same way as for a table.
       </para>
________________________________________________________-->
       <para>
        一个<literal>WITH</literal>查询通过写入它的名称来引用，就像查询的名称是表名一样。
        （实际上，<literal>WITH</literal>查询为主查询隐藏了同名的任何真实表。
        如果必要，您可以通过模式限定表的名称来引用同名的真实表。）
        别名可以像表一样提供。
       </para>
<!-- pgdoc-cn_end sig_en=6d7cfada5d542ffffc4374300d1f008d -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">function_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=4939b736f39a503f8015f59bff2ca0da sig_cn_org=0884fffc94ab14d931bf60cd3d8251ea source=15.7 
       <para>
        Function calls can appear in the <literal>FROM</literal>
        clause.  (This is especially useful for functions that return
        result sets, but any function can be used.)  This acts as
        though the function's output were created as a temporary table for the
        duration of this single <command>SELECT</command> command.
        If the function's result type is composite (including the case of a
        function with multiple <literal>OUT</literal> parameters), each
        attribute becomes a separate column in the implicit table.
       </para>
________________________________________________________-->
       <para>
        函数调用可以出现在<literal>FROM</literal>子句中。
        （这对于返回结果集的函数特别有用，但任何函数都可以使用。）
        这就好像函数的输出被创建为一个临时表，在这个单个<command>SELECT</command>命令的持续时间内。
        如果函数的结果类型是复合的（包括具有多个<literal>OUT</literal>参数的情况），
        每个属性都成为隐式表中的一个单独列。
       </para>
<!-- pgdoc-cn_end sig_en=4939b736f39a503f8015f59bff2ca0da -->

<!-- pgdoc-cn_start sig_en=32c6edd6932bdc9913cd898f63e71c09 sig_cn_org=af147c0b7432228b41df9edc3400d2e6 source=15.7 
       <para>
        When the optional <command>WITH ORDINALITY</command> clause is added
        to the function call, an additional column of type <type>bigint</type>
        will be appended to the function's result column(s).  This column
        numbers the rows of the function's result set, starting from 1.
        By default, this column is named <literal>ordinality</literal>.
       </para>
________________________________________________________-->
       <para>
        当在函数调用中添加可选的<command>WITH ORDINALITY</command>子句时，
        将会在函数的结果列后附加一个<type>bigint</type>类型的额外列。
        该列对函数结果集的行进行编号，从1开始。
        默认情况下，该列名为<literal>ordinality</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=32c6edd6932bdc9913cd898f63e71c09 -->

<!-- pgdoc-cn_start sig_en=21be81c7834fbd1c186438d63be19ee1 sig_cn_org=65e64b175c7f2c6ad459ddf8de16b6c4 source=15.7 
       <para>
        An alias can be provided in the same way as for a table.
        If an alias is written, a column
        alias list can also be written to provide substitute names for
        one or more attributes of the function's composite return
        type, including the ordinality column if present.
       </para>
________________________________________________________-->
       <para>
        别名可以像表格一样提供。如果写了别名，还可以编写列别名列表，
        为函数的复合返回类型的一个或多个属性提供替代名称，包括存在的序号列。
       </para>
<!-- pgdoc-cn_end sig_en=21be81c7834fbd1c186438d63be19ee1 -->

<!-- pgdoc-cn_start sig_en=e59c175dc7d5f1feedc0ba8577a52826 sig_cn_org=f7fb34691e331fc6be488d35000e3edd source=15.7 
       <para>
        Multiple function calls can be combined into a
        single <literal>FROM</literal>-clause item by surrounding them
        with <literal>ROWS FROM( ... )</literal>.  The output of such an item is the
        concatenation of the first row from each function, then the second
        row from each function, etc.  If some of the functions produce fewer
        rows than others, null values are substituted for the missing data, so
        that the total number of rows returned is always the same as for the
        function that produced the most rows.
       </para>
________________________________________________________-->
       <para>
        多个函数调用可以通过用<literal>ROWS FROM( ... )</literal>括起来，
        合并成一个单一的<literal>FROM</literal>-子句项。这样一个项的输出是每个函数的第一行连接在一起，
        然后是每个函数的第二行，依此类推。如果某些函数产生的行数少于其他函数，
        则用空值替换缺失的数据，以确保返回的行数总是与产生最多行的函数相同。
       </para>
<!-- pgdoc-cn_end sig_en=e59c175dc7d5f1feedc0ba8577a52826 -->

<!-- pgdoc-cn_start sig_en=ce90ff69a3eb8a7ac4cabaf0bf628e3c sig_cn_org=ad40b164527f9677c8e79f41c455063b source=15.7 
      <para>
        If the function has been defined as returning the
        <type>record</type> data type, then an alias or the key word
        <literal>AS</literal> must be present, followed by a column
        definition list in the form <literal>( <replaceable
        class="parameter">column_name</replaceable> <replaceable
        class="parameter">data_type</replaceable> <optional>, ...
        </optional>)</literal>.  The column definition list must match the
        actual number and types of columns returned by the function.
       </para>
________________________________________________________-->
      <para>
        如果函数被定义为返回<type>record</type>数据类型，则必须存在一个别名或关键字<literal>AS</literal>，
		后面跟着一个列定义列表，形式为<literal>( <replaceable class="parameter">column_name</replaceable> 
		<replaceable class="parameter">data_type</replaceable> <optional>, ... </optional>)</literal>。
		列定义列表必须与函数返回的实际列数和类型匹配。
       </para>
<!-- pgdoc-cn_end sig_en=ce90ff69a3eb8a7ac4cabaf0bf628e3c -->

<!-- pgdoc-cn_start sig_en=d2bb1ba2a3de870de0a230d36cf3fe63 sig_cn_org=ebe675f599b0d2f51d4e0858f35a55ed source=15.7 
       <para>
        When using the <literal>ROWS FROM( ... )</literal> syntax, if one of the
        functions requires a column definition list, it's preferred to put
        the column definition list after the function call inside
        <literal>ROWS FROM( ... )</literal>.  A column definition list can be placed
        after the <literal>ROWS FROM( ... )</literal> construct only if there's just
        a single function and no <literal>WITH ORDINALITY</literal> clause.
       </para>
________________________________________________________-->
       <para>
        当使用<literal>ROWS FROM( ... )</literal>语法时，如果其中一个函数需要列定义列表，
        最好将列定义列表放在函数调用后面<literal>ROWS FROM( ... )</literal>内部。只有在只有一个函数且没有
        <literal>WITH ORDINALITY</literal>子句时，才能在<literal>ROWS FROM( ... )</literal>结构后放置列定义列表。
       </para>
<!-- pgdoc-cn_end sig_en=d2bb1ba2a3de870de0a230d36cf3fe63 -->

<!-- pgdoc-cn_start sig_en=4c266eb72de4ac23dfbb0b003d84c1c7 sig_cn_org=8f45f85fa18b91d05a950bec5626666b source=15.7 
       <para>
        To use <literal>ORDINALITY</literal> together with a column definition
        list, you must use the <literal>ROWS FROM( ... )</literal> syntax and put the
        column definition list inside <literal>ROWS FROM( ... )</literal>.
       </para>
________________________________________________________-->
       <para>
        要在列定义列表中使用<literal>ORDINALITY</literal>，必须使用<literal>ROWS FROM( ... )</literal>语法，
        并将列定义列表放在<literal>ROWS FROM( ... )</literal>内部。
</para>
<!-- pgdoc-cn_end sig_en=4c266eb72de4ac23dfbb0b003d84c1c7 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">join_type</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=22e336f1ab2ac70951256ac5d697ef66 sig_cn_org=c581f59145faff35a4067bca22f5bce4 source=15.7 
       <para>
        One of
        <itemizedlist>
         <listitem>
          <para><literal>[ INNER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>LEFT [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>RIGHT [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>FULL [ OUTER ] JOIN</literal></para>
         </listitem>
        </itemizedlist>

        For the <literal>INNER</literal> and <literal>OUTER</literal> join types, a
        join condition must be specified, namely exactly one of
        <literal>ON <replaceable
        class="parameter">join_condition</replaceable></literal>,
        <literal>USING (<replaceable
        class="parameter">join_column</replaceable> [, ...])</literal>,
        or <literal>NATURAL</literal>.  See below for the meaning.
       </para>
________________________________________________________-->
       <para>
        其中之一是
        <itemizedlist>
         <listitem>
          <para><literal>[ INNER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>LEFT [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>RIGHT [ OUTER ] JOIN</literal></para>
         </listitem>
         <listitem>
          <para><literal>FULL [ OUTER ] JOIN</literal></para>
         </listitem>
        </itemizedlist>

        对于<literal>INNER</literal>和<literal>OUTER</literal>连接类型，必须指定连接条件，即
        <literal>ON <replaceable
        class="parameter">join_condition</replaceable></literal>、
        <literal>USING (<replaceable
        class="parameter">join_column</replaceable> [, ...])</literal>，
        或者<literal>NATURAL</literal>。请参见下文的含义。
       </para>
<!-- pgdoc-cn_end sig_en=22e336f1ab2ac70951256ac5d697ef66 -->

<!-- pgdoc-cn_start sig_en=2eb6d54c772776454820d4cdd0a46d5c sig_cn_org=f0cb0a61117c04511c01c9e9b9fc028c source=15.7 
       <para>
        A <literal>JOIN</literal> clause combines two <literal>FROM</literal>
        items, which for convenience we will refer to as <quote>tables</quote>,
        though in reality they can be any type of <literal>FROM</literal> item.
        Use parentheses if necessary to determine the order of nesting.
        In the absence of parentheses, <literal>JOIN</literal>s nest
        left-to-right.  In any case <literal>JOIN</literal> binds more
        tightly than the commas separating <literal>FROM</literal>-list items.
        All the <literal>JOIN</literal> options are just a notational
        convenience, since they do nothing you couldn't do with plain
        <literal>FROM</literal> and <literal>WHERE</literal>.
       </para>
________________________________________________________-->
       <para>
        一个<literal>JOIN</literal>子句结合了两个<literal>FROM</literal>项，为了方便起见，我们将其称为<quote>表</quote>，
        虽然实际上它们可以是任何类型的<literal>FROM</literal>项。
        如有必要，使用括号确定嵌套的顺序。
        在没有括号的情况下，<literal>JOIN</literal>从左到右嵌套。
        无论如何，<literal>JOIN</literal>比分隔<literal>FROM</literal>列表项的逗号更紧密。
        所有<literal>JOIN</literal>选项只是一种表示上的便利，因为它们并没有做任何你不能用普通的<literal>FROM</literal>和<literal>WHERE</literal>做的事情。
       </para>
<!-- pgdoc-cn_end sig_en=2eb6d54c772776454820d4cdd0a46d5c -->

<!-- pgdoc-cn_start sig_en=85acdffcce84d47674a962339430e6da sig_cn_org=046fba4c08f8a8bae2ebb51701853dc1 source=15.7 
       <para><literal>LEFT OUTER JOIN</literal> returns all rows in the qualified
        Cartesian product (i.e., all combined rows that pass its join
        condition), plus one copy of each row in the left-hand table
        for which there was no right-hand row that passed the join
        condition.  This left-hand row is extended to the full width
        of the joined table by inserting null values for the
        right-hand columns.  Note that only the <literal>JOIN</literal>
        clause's own condition is considered while deciding which rows
        have matches.  Outer conditions are applied afterwards.
       </para>
________________________________________________________-->
       <para><literal>LEFT OUTER JOIN</literal>返回符合连接条件的所有行的笛卡尔积（即，通过连接条件的所有组合行），以及左表中每一行的一个副本，对于这些行，右表中没有通过连接条件的行。这个左表行通过在右表列中插入空值来扩展到连接表的完整宽度。请注意，只有<literal>JOIN</literal>子句的条件在决定哪些行有匹配时才会被考虑。外部条件在之后应用。</para>
<!-- pgdoc-cn_end sig_en=85acdffcce84d47674a962339430e6da -->

<!-- pgdoc-cn_start sig_en=ba17d729c1641cd0e659cd7f0d77d646 sig_cn_org=12e9e04ea526fb2d7b32713fc4c704f6 source=15.7 
       <para>
        Conversely, <literal>RIGHT OUTER JOIN</literal> returns all the
        joined rows, plus one row for each unmatched right-hand row
        (extended with nulls on the left).  This is just a notational
        convenience, since you could convert it to a <literal>LEFT
        OUTER JOIN</literal> by switching the left and right tables.
       </para>
________________________________________________________-->
       <para>
        相反，<literal>RIGHT OUTER JOIN</literal>返回所有连接的行，再加上每个未匹配的右侧行的一行
        （在左侧扩展为null）。这只是一种符号上的便利，因为你可以通过交换左右表格将其转换为<literal>LEFT
        OUTER JOIN</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=ba17d729c1641cd0e659cd7f0d77d646 -->

<!-- pgdoc-cn_start sig_en=0a151720dd86fd9da58a755f3fa8b229 sig_cn_org=d4bd2ab11895dd47af1236e6673129c4 source=15.7 
       <para><literal>FULL OUTER JOIN</literal> returns all the joined rows, plus
        one row for each unmatched left-hand row (extended with nulls
        on the right), plus one row for each unmatched right-hand row
        (extended with nulls on the left).
       </para>
________________________________________________________-->
       <para><literal>FULL OUTER JOIN</literal>返回所有连接的行，以及每个未匹配的左侧行（右侧扩展为null），以及每个未匹配的右侧行（左侧扩展为null）。</para>
<!-- pgdoc-cn_end sig_en=0a151720dd86fd9da58a755f3fa8b229 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ON <replaceable class="parameter">join_condition</replaceable></literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=ad154178fda81ea9895ca6b59b4f5b5f sig_cn_org=c20ce1dc48977ba0ded67dc92ef5566e source=15.7 
       <para><replaceable class="parameter">join_condition</replaceable> is
        an expression resulting in a value of type
        <type>boolean</type> (similar to a <literal>WHERE</literal>
        clause) that specifies which rows in a join are considered to
        match.
       </para>
________________________________________________________-->
       <para><replaceable class="parameter">join_condition</replaceable>是一个表达式，其结果为<type>boolean</type>类型的值（类似于<literal>WHERE</literal>子句），指定哪些连接中的行被认为是匹配的。</para>
<!-- pgdoc-cn_end sig_en=ad154178fda81ea9895ca6b59b4f5b5f -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>USING ( <replaceable class="parameter">join_column</replaceable> [, ...] ) [ AS <replaceable class="parameter">join_using_alias</replaceable> ]</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=c761f827e490bbf984a4a374ba541a70 sig_cn_org=860c129250af2d17d12caaed41d18633 source=15.7 
       <para>
        A clause of the form <literal>USING ( a, b, ... )</literal> is
        shorthand for <literal>ON left_table.a = right_table.a AND
        left_table.b = right_table.b ...</literal>.  Also,
        <literal>USING</literal> implies that only one of each pair of
        equivalent columns will be included in the join output, not
        both.
       </para>
________________________________________________________-->
       <para>
        一个形如<literal>USING ( a, b, ... )</literal>的子句是<literal>ON left_table.a = right_table.a AND
        left_table.b = right_table.b ...</literal>的简写。此外，
        <literal>USING</literal>意味着只有每对等价列中的一个会包含在连接输出中，而不是两者都包含。
       </para>
<!-- pgdoc-cn_end sig_en=c761f827e490bbf984a4a374ba541a70 -->

<!-- pgdoc-cn_start sig_en=e49ab6ce50764d5bcd67a024bb5aea64 sig_cn_org=ee6b0dd1f1af299442baac5972cfc2c7 source=15.7 
       <para>
        If a <replaceable class="parameter">join_using_alias</replaceable>
        name is specified, it provides a table alias for the join columns.
        Only the join columns listed in the <literal>USING</literal> clause
        are addressable by this name.  Unlike a regular <replaceable
        class="parameter">alias</replaceable>, this does not hide the names of
        the joined tables from the rest of the query.  Also unlike a regular
        <replaceable class="parameter">alias</replaceable>, you cannot write a
        column alias list &mdash; the output names of the join columns are the
        same as they appear in the <literal>USING</literal> list.
       </para>
________________________________________________________-->
       <para>
        如果指定了一个<replaceable class="parameter">join_using_alias</replaceable>名称，
        它为连接列提供了一个表别名。只有在<literal>USING</literal>子句中列出的连接列可以通过此名称访问。
        与常规<replaceable class="parameter">alias</replaceable>不同，这不会隐藏连接表的名称。
        与常规<replaceable class="parameter">alias</replaceable>也不同，您不能编写列别名列表 —— 连接列的输出名称与它们在<literal>USING</literal>列表中出现的名称相同。
       </para>
<!-- pgdoc-cn_end sig_en=e49ab6ce50764d5bcd67a024bb5aea64 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NATURAL</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=c105de79ca7fec9be7fd5da55952a884 sig_cn_org=70a324215d23b9149e6c4595c2fdf5de source=15.7 
       <para>
        <literal>NATURAL</literal> is shorthand for a
        <literal>USING</literal> list that mentions all columns in the two
        tables that have matching names.  If there are no common
        column names, <literal>NATURAL</literal> is equivalent
        to <literal>ON TRUE</literal>.
       </para>
________________________________________________________-->
       <para>
        <literal>NATURAL</literal>是一个简写，表示一个包含两个表中所有具有相同名称的列的<literal>USING</literal>列表。
        如果没有共同的列名，<literal>NATURAL</literal>等同于<literal>ON TRUE</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=c105de79ca7fec9be7fd5da55952a884 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CROSS JOIN</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=74c4cdd791cde333986c151029a41171 sig_cn_org=1de899d636a35012b2a56d58644e88a5 source=15.7 
       <para>
        <literal>CROSS JOIN</literal> is equivalent to <literal>INNER JOIN ON
        (TRUE)</literal>, that is, no rows are removed by qualification.
        They produce a simple Cartesian product, the same result as you get from
        listing the two tables at the top level of <literal>FROM</literal>,
        but restricted by the join condition (if any).
       </para>
________________________________________________________-->
       <para>
        <literal>CROSS JOIN</literal>等同于<literal>INNER JOIN ON (TRUE)</literal>，
        也就是说，没有任何行被条件限制删除。它们产生一个简单的笛卡尔积，
        与在<literal>FROM</literal>的顶层列出两个表时得到的结果相同，
        但受连接条件（如果有）的限制。
       </para>
<!-- pgdoc-cn_end sig_en=74c4cdd791cde333986c151029a41171 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>LATERAL</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=2f567c3116b8675eacc16b94d478381a sig_cn_org=779106899f5029df5d9bb03974f566ec source=15.7 
       <para>
        The <literal>LATERAL</literal> key word can precede a
        sub-<command>SELECT</command> <literal>FROM</literal> item.  This allows the
        sub-<command>SELECT</command> to refer to columns of <literal>FROM</literal>
        items that appear before it in the <literal>FROM</literal> list.  (Without
        <literal>LATERAL</literal>, each sub-<command>SELECT</command> is
        evaluated independently and so cannot cross-reference any other
        <literal>FROM</literal> item.)
       </para>
________________________________________________________-->
       <para>
        <literal>LATERAL</literal>关键字可以在子<command>SELECT</command> <literal>FROM</literal>项之前出现。
        这允许子<command>SELECT</command>引用在<literal>FROM</literal>列表中出现在其前面的<literal>FROM</literal>项的列。
        （没有<literal>LATERAL</literal>，每个子<command>SELECT</command>都是独立评估的，因此不能交叉引用任何其他<literal>FROM</literal>项。）
       </para>
<!-- pgdoc-cn_end sig_en=2f567c3116b8675eacc16b94d478381a -->

<!-- pgdoc-cn_start sig_en=2be3dc6b9aca3c0c3284386684cc0c95 sig_cn_org=a465eda91bbf4a6fc1eceadecf9e6540 source=15.7 
       <para><literal>LATERAL</literal> can also precede a function-call
        <literal>FROM</literal> item, but in this case it is a noise word, because
        the function expression can refer to earlier <literal>FROM</literal> items
        in any case.
       </para>
________________________________________________________-->
       <para><literal>LATERAL</literal>也可以在函数调用<literal>FROM</literal>项之前出现，但在这种情况下，它是一个噪音词，因为函数表达式可以在任何情况下引用先前的<literal>FROM</literal>项。</para>
<!-- pgdoc-cn_end sig_en=2be3dc6b9aca3c0c3284386684cc0c95 -->

<!-- pgdoc-cn_start sig_en=f2daf5d7b8be49c4726e3e0339de4d88 sig_cn_org=c33d4d3ab8fa557cb56cc3ab32460655 source=15.7 
       <para>
        A <literal>LATERAL</literal> item can appear at top level in the
        <literal>FROM</literal> list, or within a <literal>JOIN</literal> tree.  In the
        latter case it can also refer to any items that are on the left-hand
        side of a <literal>JOIN</literal> that it is on the right-hand side of.
       </para>
________________________________________________________-->
       <para>
        一个<literal>LATERAL</literal>项可以出现在<literal>FROM</literal>列表的顶层，或者在<literal>JOIN</literal>树中。
        在后一种情况下，它还可以引用任何在它右侧的<literal>JOIN</literal>左侧的项。
       </para>
<!-- pgdoc-cn_end sig_en=f2daf5d7b8be49c4726e3e0339de4d88 -->

<!-- pgdoc-cn_start sig_en=f680fdeed364f2c7cf085dafcf1405a6 sig_cn_org=ce0c214f5a108efe8f8642a1fabcb482 source=15.7 
       <para>
        When a <literal>FROM</literal> item contains <literal>LATERAL</literal>
        cross-references, evaluation proceeds as follows: for each row of the
        <literal>FROM</literal> item providing the cross-referenced column(s), or
        set of rows of multiple <literal>FROM</literal> items providing the
        columns, the <literal>LATERAL</literal> item is evaluated using that
        row or row set's values of the columns.  The resulting row(s) are
        joined as usual with the rows they were computed from.  This is
        repeated for each row or set of rows from the column source table(s).
       </para>
________________________________________________________-->
       <para>
        当<literal>FROM</literal>项包含<literal>LATERAL</literal>交叉引用时，评估过程如下：
        对于提供交叉引用列的<literal>FROM</literal>项的每一行，或者提供列的多个<literal>FROM</literal>项的一组行，
        使用该行或行集的列的值来评估<literal>LATERAL</literal>项。得到的行将像往常一样与计算出它们的行连接。
        对来自列源表的每一行或一组行重复此过程。
       </para>
<!-- pgdoc-cn_end sig_en=f680fdeed364f2c7cf085dafcf1405a6 -->

<!-- pgdoc-cn_start sig_en=7dd2779ed616a5592922fe5f40d6c028 sig_cn_org=07a8d783e020675a457f4fbe3a1550ba source=15.7 
       <para>
        The column source table(s) must be <literal>INNER</literal> or
        <literal>LEFT</literal> joined to the <literal>LATERAL</literal> item, else
        there would not be a well-defined set of rows from which to compute
        each set of rows for the <literal>LATERAL</literal> item.  Thus,
        although a construct such as <literal><replaceable>X</replaceable> RIGHT JOIN
        LATERAL <replaceable>Y</replaceable></literal> is syntactically valid, it is
        not actually allowed for <replaceable>Y</replaceable> to reference
        <replaceable>X</replaceable>.
       </para>
________________________________________________________-->
       <para>
        列源表必须与<literal>INNER</literal>或<literal>LEFT</literal>连接到<literal>LATERAL</literal>项，
        否则将无法从中计算每个<literal>LATERAL</literal>项的行集。因此，尽管像
        <literal><replaceable>X</replaceable> RIGHT JOIN LATERAL <replaceable>Y</replaceable></literal>
        这样的结构在语法上是有效的，但实际上不允许<replaceable>Y</replaceable>引用<replaceable>X</replaceable>。
</para>
<!-- pgdoc-cn_end sig_en=7dd2779ed616a5592922fe5f40d6c028 -->
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </refsect2>

  <refsect2 id="sql-where" xreflabel="WHERE Clause">
<!-- pgdoc-cn_start sig_en=fa069ec1396549516618b10180fb812d sig_cn_org=None source=14.1 
   <title><literal>WHERE</literal> Clause</title>
________________________________________________________-->
   <title><literal>WHERE</literal> 子句</title>
<!-- pgdoc-cn_end sig_en=fa069ec1396549516618b10180fb812d -->

<!-- pgdoc-cn_start sig_en=074cb2a3aef670520c15966d0e10ee4e sig_cn_org=None source=14.1 
   <para>
    The optional <literal>WHERE</literal> clause has the general form
<synopsis>
WHERE <replaceable class="parameter">condition</replaceable>
</synopsis>
    where <replaceable class="parameter">condition</replaceable> is
    any expression that evaluates to a result of type
    <type>boolean</type>.  Any row that does not satisfy this
    condition will be eliminated from the output.  A row satisfies the
    condition if it returns true when the actual row values are
    substituted for any variable references.
   </para>
________________________________________________________-->
   <para>
    可选的<literal>WHERE</literal>子句的形式
<synopsis>
WHERE <replaceable class="parameter">condition</replaceable>
</synopsis>
    其中<replaceable class="parameter">condition</replaceable>
    是任一计算得到<type>布尔</type>类型结果的表达式。任何不满足
    这个条件的行都会从输出中被消除。如果用一行的实际值替换其中的
    变量引用后，该表达式返回真，则该行符合条件。
   </para>
<!-- pgdoc-cn_end sig_en=074cb2a3aef670520c15966d0e10ee4e -->
  </refsect2>

  <refsect2 id="sql-groupby" xreflabel="GROUP BY Clause">
<!-- pgdoc-cn_start sig_en=23cc40477b94ba3dfdecf93e526e15da sig_cn_org=None source=14.1 
   <title><literal>GROUP BY</literal> Clause</title>
________________________________________________________-->
   <title><literal>GROUP BY</literal> 子句</title>
<!-- pgdoc-cn_end sig_en=23cc40477b94ba3dfdecf93e526e15da -->

<!-- pgdoc-cn_start sig_en=6f8108908a9671e83874ff220790a8fc sig_cn_org=None source=14.1 
   <para>
    The optional <literal>GROUP BY</literal> clause has the general form
<synopsis>
GROUP BY [ ALL | DISTINCT ] <replaceable class="parameter">grouping_element</replaceable> [, ...]
</synopsis>
   </para>
________________________________________________________-->
   <para>
    可选的<literal>GROUP BY</literal>子句的形式
<synopsis>
GROUP BY [ ALL | DISTINCT ] <replaceable class="parameter">grouping_element</replaceable> [, ...]
</synopsis>
   </para>
<!-- pgdoc-cn_end sig_en=6f8108908a9671e83874ff220790a8fc -->

<!-- pgdoc-cn_start sig_en=eab9037291f8082378166da932475575 sig_cn_org=None source=14.1 
   <para>
    <literal>GROUP BY</literal> will condense into a single row all
    selected rows that share the same values for the grouped
    expressions.  An <replaceable
    class="parameter">expression</replaceable> used inside a
    <replaceable class="parameter">grouping_element</replaceable>
    can be an input column name, or the name or ordinal number of an
    output column (<command>SELECT</command> list item), or an arbitrary
    expression formed from input-column values.  In case of ambiguity,
    a <literal>GROUP BY</literal> name will be interpreted as an
    input-column name rather than an output column name.
   </para>
________________________________________________________-->
   <para>
    <literal>GROUP BY</literal>将会把所有被选择的行中共享相同分组表达式
    值的那些行压缩成一个行。一个被用在
    <replaceable class="parameter">grouping_element</replaceable>中的
    <replaceable
    class="parameter">expression</replaceable>可以是输入列名、输出列
    （<command>SELECT</command>列表项）的名称或序号或者由输入列
    值构成的任意表达式。在出现歧义时，<literal>GROUP BY</literal>名称
    将被解释为输入列名而不是输出列名。
   </para>
<!-- pgdoc-cn_end sig_en=eab9037291f8082378166da932475575 -->

<!-- pgdoc-cn_start sig_en=da7de2f4fd8d03a891a1c12e56dfc844 sig_cn_org=None source=14.1 
   <para>
    If any of <literal>GROUPING SETS</literal>, <literal>ROLLUP</literal> or
    <literal>CUBE</literal> are present as grouping elements, then the
    <literal>GROUP BY</literal> clause as a whole defines some number of
    independent <replaceable>grouping sets</replaceable>.  The effect of this is
    equivalent to constructing a <literal>UNION ALL</literal> between
    subqueries with the individual grouping sets as their
    <literal>GROUP BY</literal> clauses.  The optional <literal>DISTINCT</literal>
    clause removes duplicate sets before processing; it does <emphasis>not</emphasis>
    transform the <literal>UNION ALL</literal> into a <literal>UNION DISTINCT</literal>.
    For further details on the handling
    of grouping sets see <xref linkend="queries-grouping-sets"/>.
   </para>
________________________________________________________-->
   <para>
    如果任何<literal>GROUPING SETS</literal>、<literal>ROLLUP</literal>或者<literal>CUBE</literal>作为分组元素存在，则<literal>GROUP BY</literal>子句整体上定义了数个独立的<replaceable>分组集</replaceable>。
    其效果等效于在子查询间构建一个<literal>UNION ALL</literal>，子查询带有分组集作为它们的<literal>GROUP BY</literal>子句。
    在处理前可选的<literal>DISTINCT</literal>子句移除副本集合；它<emphasis>不</emphasis>做<literal>UNION ALL</literal>到<literal>UNION DISTINCT</literal>的转换
    处理分组集的进一步细节请见<xref linkend="queries-grouping-sets"/>。
   </para>
<!-- pgdoc-cn_end sig_en=da7de2f4fd8d03a891a1c12e56dfc844 -->

<!-- pgdoc-cn_start sig_en=34c7359d803f2e586db90d5d8ee13b27 sig_cn_org=None source=14.1 
   <para>
    Aggregate functions, if any are used, are computed across all rows
    making up each group, producing a separate value for each group.
    (If there are aggregate functions but no <literal>GROUP BY</literal>
    clause, the query is treated as having a single group comprising all
    the selected rows.)
    The set of rows fed to each aggregate function can be further filtered by
    attaching a <literal>FILTER</literal> clause to the aggregate function
    call; see <xref linkend="syntax-aggregates"/> for more information.  When
    a <literal>FILTER</literal> clause is present, only those rows matching it
    are included in the input to that aggregate function.
   </para>
________________________________________________________-->
   <para>
    聚集函数（如果使用）会在组成每一个分组的所有行上进行计算，从而为每
    一个分组产生一个单独的值（如果有聚集函数但是没有
    <literal>GROUP BY</literal>子句，则查询会被当成是由所有选中行构成
    的一个单一分组）。传递给每一个聚集函数的行集合可以通过在聚集函数调
    用附加一个<literal>FILTER</literal>子句来进一步过滤，详见
    <xref linkend="syntax-aggregates"/>。当存在一个
    <literal>FILTER</literal>子句时，只有那些匹配它的行才会被包括在该聚
    集函数的输入中。
   </para>
<!-- pgdoc-cn_end sig_en=34c7359d803f2e586db90d5d8ee13b27 -->

<!-- pgdoc-cn_start sig_en=789b749044257530b0aa54d83a884b11 sig_cn_org=None source=14.1 
   <para>
    When <literal>GROUP BY</literal> is present,
    or any aggregate functions are present, it is not valid for
    the <command>SELECT</command> list expressions to refer to
    ungrouped columns except within aggregate functions or when the
    ungrouped column is functionally dependent on the grouped columns,
    since there would otherwise be more than one possible value to
    return for an ungrouped column.  A functional dependency exists if
    the grouped columns (or a subset thereof) are the primary key of
    the table containing the ungrouped column.
   </para>
________________________________________________________-->
   <para>
    当存在<literal>GROUP BY</literal>子句或者任何聚集函数时，
    <command>SELECT</command>列表表达式不能引用非分组列（除非它
    出现在聚集函数中或者它函数依赖于分组列），因为这样做会导致返回
    非分组列的值时会有多种可能的值。如果分组列是包含非分组列的表的主键（
    或者主键的子集），则存在函数依赖。
   </para>
<!-- pgdoc-cn_end sig_en=789b749044257530b0aa54d83a884b11 -->

<!-- pgdoc-cn_start sig_en=927ccc2e2854de7589525f2704bc0083 sig_cn_org=None source=14.1 
   <para>
    Keep in mind that all aggregate functions are evaluated before
    evaluating any <quote>scalar</quote> expressions in the <literal>HAVING</literal>
    clause or <literal>SELECT</literal> list.  This means that, for example,
    a <literal>CASE</literal> expression cannot be used to skip evaluation of
    an aggregate function; see <xref linkend="syntax-express-eval"/>.
   </para>
________________________________________________________-->
   <para>
    记住所有的聚集函数都是在<literal>HAVING</literal>子句或者
    <literal>SELECT</literal>列表中的任何<quote>标量</quote>表达式之前被计算。
    这意味着一个<literal>CASE</literal>表达式不能被用来跳过一个聚集表达式的
    计算，见<xref linkend="syntax-express-eval"/>。
   </para>
<!-- pgdoc-cn_end sig_en=927ccc2e2854de7589525f2704bc0083 -->

<!-- pgdoc-cn_start sig_en=1e0f2ea1fd21ec87f24e3d9d13c2848f sig_cn_org=None source=14.1 
   <para>
    Currently, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>,
    <literal>FOR SHARE</literal> and <literal>FOR KEY SHARE</literal> cannot be
    specified with <literal>GROUP BY</literal>.
   </para>
________________________________________________________-->
   <para>
    当前，<literal>FOR NO KEY UPDATE</literal>、<literal>FOR UPDATE</literal>、
    <literal>FOR SHARE</literal>和<literal>FOR KEY SHARE</literal>不能和
    <literal>GROUP BY</literal>一起指定。
   </para>
<!-- pgdoc-cn_end sig_en=1e0f2ea1fd21ec87f24e3d9d13c2848f -->
  </refsect2>

  <refsect2 id="sql-having" xreflabel="HAVING Clause">
<!-- pgdoc-cn_start sig_en=a04e0283bd7e40ea9586a30b247dd59e sig_cn_org=None source=14.1 
   <title><literal>HAVING</literal> Clause</title>
________________________________________________________-->
   <title><literal>HAVING</literal> 子句</title>
<!-- pgdoc-cn_end sig_en=a04e0283bd7e40ea9586a30b247dd59e -->

<!-- pgdoc-cn_start sig_en=61be901961688ece35cbf991e4a76564 sig_cn_org=None source=14.1 
   <para>
    The optional <literal>HAVING</literal> clause has the general form
<synopsis>
HAVING <replaceable class="parameter">condition</replaceable>
</synopsis>
    where <replaceable class="parameter">condition</replaceable> is
    the same as specified for the <literal>WHERE</literal> clause.
   </para>
________________________________________________________-->
   <para>
    可选的<literal>HAVING</literal>子句的形式
<synopsis>
HAVING <replaceable class="parameter">condition</replaceable>
</synopsis>
    其中<replaceable class="parameter">condition</replaceable>与
    <literal>WHERE</literal>子句中指定的条件相同。
   </para>
<!-- pgdoc-cn_end sig_en=61be901961688ece35cbf991e4a76564 -->

<!-- pgdoc-cn_start sig_en=2069844a3ae05070ed0c862688ee8e01 sig_cn_org=None source=14.1 
   <para>
    <literal>HAVING</literal> eliminates group rows that do not
    satisfy the condition.  <literal>HAVING</literal> is different
    from <literal>WHERE</literal>: <literal>WHERE</literal> filters
    individual rows before the application of <literal>GROUP
    BY</literal>, while <literal>HAVING</literal> filters group rows
    created by <literal>GROUP BY</literal>.  Each column referenced in
    <replaceable class="parameter">condition</replaceable> must
    unambiguously reference a grouping column, unless the reference
    appears within an aggregate function or the ungrouped column is
    functionally dependent on the grouping columns.
   </para>
________________________________________________________-->
   <para>
    <literal>HAVING</literal>消除不满足该条件的分组行。
    <literal>HAVING</literal>与<literal>WHERE</literal>不同：
    <literal>WHERE</literal>会在应用<literal>GROUP
    BY</literal>之前过滤个体行，而<literal>HAVING</literal>过滤由
    <literal>GROUP BY</literal>创建的分组行。
    <replaceable class="parameter">condition</replaceable>中引用
    的每一个列必须无歧义地引用一个分组列（除非该引用出现在一个聚集
    函数中或者该非分组列函数依赖于分组列。
   </para>
<!-- pgdoc-cn_end sig_en=2069844a3ae05070ed0c862688ee8e01 -->

<!-- pgdoc-cn_start sig_en=1a85fed674f67a8ef25adbba3e26ce03 sig_cn_org=None source=14.1 
   <para>
    The presence of <literal>HAVING</literal> turns a query into a grouped
    query even if there is no <literal>GROUP BY</literal> clause.  This is the
    same as what happens when the query contains aggregate functions but
    no <literal>GROUP BY</literal> clause.  All the selected rows are considered to
    form a single group, and the <command>SELECT</command> list and
    <literal>HAVING</literal> clause can only reference table columns from
    within aggregate functions.  Such a query will emit a single row if the
    <literal>HAVING</literal> condition is true, zero rows if it is not true.
   </para>
________________________________________________________-->
   <para>
    即使没有<literal>GROUP BY</literal>子句，<literal>HAVING</literal>
    的存在也会把一个查询转变成一个分组查询。这和查询中包含聚集函数但没有
    <literal>GROUP BY</literal>子句时的情况相同。所有被选择的行都被认为是一个
    单一分组，并且<command>SELECT</command>列表和
    <literal>HAVING</literal>子句只能引用聚集函数中的表列。如果该
    <literal>HAVING</literal>条件为真，这样一个查询将会发出一个单一行；
    否则不返回行。
   </para>
<!-- pgdoc-cn_end sig_en=1a85fed674f67a8ef25adbba3e26ce03 -->

<!-- pgdoc-cn_start sig_en=b6346a3a870053745d9d921bce14be8f sig_cn_org=None source=14.1 
   <para>
    Currently, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>,
    <literal>FOR SHARE</literal> and <literal>FOR KEY SHARE</literal> cannot be
    specified with <literal>HAVING</literal>.
   </para>
________________________________________________________-->
   <para>
    当前，<literal>FOR NO KEY UPDATE</literal>、<literal>FOR UPDATE</literal>、
    <literal>FOR SHARE</literal>和<literal>FOR KEY SHARE</literal>不能与
    <literal>HAVING</literal>一起指定。
   </para>
<!-- pgdoc-cn_end sig_en=b6346a3a870053745d9d921bce14be8f -->
  </refsect2>

  <refsect2 id="sql-window" xreflabel="WINDOW Clause">
<!-- pgdoc-cn_start sig_en=6c2fa49c5d0dafe9c276c17e911136fa sig_cn_org=None source=14.1 
   <title><literal>WINDOW</literal> Clause</title>
________________________________________________________-->
   <title><literal>WINDOW</literal> 子句</title>
<!-- pgdoc-cn_end sig_en=6c2fa49c5d0dafe9c276c17e911136fa -->

<!-- pgdoc-cn_start sig_en=901282843bbd737e4945e7983c5d3beb sig_cn_org=None source=14.1 
   <para>
    The optional <literal>WINDOW</literal> clause has the general form
<synopsis>
WINDOW <replaceable class="parameter">window_name</replaceable> AS ( <replaceable class="parameter">window_definition</replaceable> ) [, ...]
</synopsis>
    where <replaceable class="parameter">window_name</replaceable> is
    a name that can be referenced from <literal>OVER</literal> clauses or
    subsequent window definitions, and
    <replaceable class="parameter">window_definition</replaceable> is
<synopsis>
[ <replaceable class="parameter">existing_window_name</replaceable> ]
[ PARTITION BY <replaceable class="parameter">expression</replaceable> [, ...] ]
[ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operator</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <replaceable class="parameter">frame_clause</replaceable> ]
</synopsis>
   </para>
________________________________________________________-->
   <para>
    可选的<literal>WINDOW</literal>子句的形式
<synopsis>
WINDOW <replaceable class="parameter">window_name</replaceable> AS ( <replaceable class="parameter">window_definition</replaceable> ) [, ...]
</synopsis>
    其中<replaceable class="parameter">window_name</replaceable>
    是一个可以从<literal>OVER</literal>子句或者后续窗口定义中引用的名称。
    <replaceable class="parameter">window_definition</replaceable>是
<synopsis>
[ <replaceable class="parameter">existing_window_name</replaceable> ]
[ PARTITION BY <replaceable class="parameter">expression</replaceable> [, ...] ]
[ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operator</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <replaceable class="parameter">frame_clause</replaceable> ]
</synopsis>
   </para>
<!-- pgdoc-cn_end sig_en=901282843bbd737e4945e7983c5d3beb -->

<!-- pgdoc-cn_start sig_en=b14f5a9ca7f379ce53bb65d28f100fab sig_cn_org=None source=14.1 
   <para>
    If an <replaceable class="parameter">existing_window_name</replaceable>
    is specified it must refer to an earlier entry in the <literal>WINDOW</literal>
    list; the new window copies its partitioning clause from that entry,
    as well as its ordering clause if any.  In this case the new window cannot
    specify its own <literal>PARTITION BY</literal> clause, and it can specify
    <literal>ORDER BY</literal> only if the copied window does not have one.
    The new window always uses its own frame clause; the copied window
    must not specify a frame clause.
   </para>
________________________________________________________-->
   <para>
    如果指定了一个<replaceable class="parameter">existing_window_name</replaceable>，
    它必须引用<literal>WINDOW</literal>列表中一个更早出现的项。新窗口将从
    该项中复制它的划分子句以及排序子句（如果有）。在这种情况下，新窗口
    不能指定它自己的<literal>PARTITION BY</literal>子句，并且它只能在被复制
    窗口没有<literal>ORDER BY</literal>的情况下指定该子句。新窗口总是使用它
    自己的帧子句，被复制的窗口不必指定一个帧子句。
   </para>
<!-- pgdoc-cn_end sig_en=b14f5a9ca7f379ce53bb65d28f100fab -->

<!-- pgdoc-cn_start sig_en=7016207361ba478d6b99b685278e9e23 sig_cn_org=None source=14.1 
   <para>
    The elements of the <literal>PARTITION BY</literal> list are interpreted in
    much the same fashion as elements of a <link
    linkend="sql-groupby"><literal>GROUP BY</literal></link> clause, except that
    they are always simple expressions and never the name or number of an
    output column.
    Another difference is that these expressions can contain aggregate
    function calls, which are not allowed in a regular <literal>GROUP BY</literal>
    clause.  They are allowed here because windowing occurs after grouping
    and aggregation.
   </para>
________________________________________________________-->
   <para>
    <literal>PARTITION BY</literal>列表元素的解释以
    <link linkend="sql-groupby"><literal>GROUP BY</literal></link>子句元素的方式
    进行，不过它们总是简单表达式并且绝不能是输出列的名称或编号。另一个区
    别是这些表达式可以包含聚集函数调用，而这在常规<literal>GROUP BY</literal>
    子句中是不被允许的。它们被允许的原因是窗口是出现在分组和聚集之后的。
   </para>
<!-- pgdoc-cn_end sig_en=7016207361ba478d6b99b685278e9e23 -->

<!-- pgdoc-cn_start sig_en=df50c3ad086d49c7e770e62ec468fa5e sig_cn_org=None source=14.1 
   <para>
    Similarly, the elements of the <literal>ORDER BY</literal> list are interpreted
    in much the same fashion as elements of a statement-level <link
    linkend="sql-orderby"><literal>ORDER BY</literal></link> clause, except that
    the expressions are always taken as simple expressions and never the name
    or number of an output column.
   </para>
________________________________________________________-->
   <para>
    类似地，<literal>ORDER BY</literal>列表元素的解释也以语句级
    <link linkend="sql-orderby"><literal>ORDER BY</literal></link>子句元素的方式进行，
    不过该表达式总是被当做简单表达式并且绝不会是输出列的名称或编号。
   </para>
<!-- pgdoc-cn_end sig_en=df50c3ad086d49c7e770e62ec468fa5e -->

<!-- pgdoc-cn_start sig_en=dfd65ad1a072158fb24baf632f508b9b sig_cn_org=None source=14.1 
   <para>
    The optional <replaceable class="parameter">frame_clause</replaceable> defines
    the <firstterm>window frame</firstterm> for window functions that depend on the
    frame (not all do).  The window frame is a set of related rows for
    each row of the query (called the <firstterm>current row</firstterm>).
    The <replaceable class="parameter">frame_clause</replaceable> can be one of

<synopsis>
{ RANGE | ROWS | GROUPS } <replaceable>frame_start</replaceable> [ <replaceable>frame_exclusion</replaceable> ]
{ RANGE | ROWS | GROUPS } BETWEEN <replaceable>frame_start</replaceable> AND <replaceable>frame_end</replaceable> [ <replaceable>frame_exclusion</replaceable> ]
</synopsis>

    where <replaceable>frame_start</replaceable>
    and <replaceable>frame_end</replaceable> can be one of

<synopsis>
UNBOUNDED PRECEDING
<replaceable>offset</replaceable> PRECEDING
CURRENT ROW
<replaceable>offset</replaceable> FOLLOWING
UNBOUNDED FOLLOWING
</synopsis>

    and <replaceable>frame_exclusion</replaceable> can be one of

<synopsis>
EXCLUDE CURRENT ROW
EXCLUDE GROUP
EXCLUDE TIES
EXCLUDE NO OTHERS
</synopsis>

    If <replaceable>frame_end</replaceable> is omitted it defaults to <literal>CURRENT
    ROW</literal>.  Restrictions are that
    <replaceable>frame_start</replaceable> cannot be <literal>UNBOUNDED FOLLOWING</literal>,
    <replaceable>frame_end</replaceable> cannot be <literal>UNBOUNDED PRECEDING</literal>,
    and the <replaceable>frame_end</replaceable> choice cannot appear earlier in the
    above list of <replaceable>frame_start</replaceable>
    and <replaceable>frame_end</replaceable> options than
    the <replaceable>frame_start</replaceable> choice does &mdash; for example
    <literal>RANGE BETWEEN CURRENT ROW AND <replaceable>offset</replaceable>
    PRECEDING</literal> is not allowed.
   </para>
________________________________________________________-->
   <para>
    可选的<replaceable class="parameter">frame_clause</replaceable>为依赖帧的窗口函数
    定义<firstterm>窗口帧</firstterm>（并非所有窗口函数都依赖于帧）。窗口帧是查询中
    每一样（称为<firstterm>当前行</firstterm>）的相关行的集合。 
    <replaceable class="parameter">frame_clause</replaceable>可以是

<synopsis>
{ RANGE | ROWS | GROUPS } <replaceable>frame_start</replaceable> [ <replaceable>frame_exclusion</replaceable> ]
{ RANGE | ROWS | GROUPS } BETWEEN <replaceable>frame_start</replaceable> AND <replaceable>frame_end</replaceable> [ <replaceable>frame_exclusion</replaceable> ]
</synopsis>

    之一，其中<replaceable>frame_start</replaceable>和<replaceable>frame_end</replaceable>可以是

<synopsis>
UNBOUNDED PRECEDING
<replaceable>offset</replaceable> PRECEDING
CURRENT ROW
<replaceable>offset</replaceable> FOLLOWING
UNBOUNDED FOLLOWING
</synopsis>

    之一，并且<replaceable>frame_exclusion</replaceable>可以是

<synopsis>
EXCLUDE CURRENT ROW
EXCLUDE GROUP
EXCLUDE TIES
EXCLUDE NO OTHERS
</synopsis>

    之一。如果省略<replaceable>frame_end</replaceable>，它会被默认为<literal>CURRENT
    ROW</literal>。限制是：
    <replaceable>frame_start</replaceable>不能是<literal>UNBOUNDED FOLLOWING</literal>，
    <replaceable>frame_end</replaceable>不能是<literal>UNBOUNDED PRECEDING</literal>，
    并且<replaceable>frame_end</replaceable>的选择在上面of <replaceable>frame_start</replaceable>以及<replaceable>frame_end</replaceable> 选项的列表中不能早于
    <replaceable>frame_start</replaceable>的选择 &mdash; 例如
    <literal>RANGE BETWEEN CURRENT ROW AND <replaceable>offset</replaceable>
    PRECEDING</literal>是不被允许的。
   </para>
<!-- pgdoc-cn_end sig_en=dfd65ad1a072158fb24baf632f508b9b -->

<!-- pgdoc-cn_start sig_en=d19ac6fa884533be95fed80834aa336c sig_cn_org=None source=14.1 
   <para>
    The default framing option is <literal>RANGE UNBOUNDED PRECEDING</literal>,
    which is the same as <literal>RANGE BETWEEN UNBOUNDED PRECEDING AND
    CURRENT ROW</literal>; it sets the frame to be all rows from the partition start
    up through the current row's last <firstterm>peer</firstterm> (a row
    that the window's <literal>ORDER BY</literal> clause considers
    equivalent to the current row; all rows are peers if there
    is no <literal>ORDER BY</literal>).
    In general, <literal>UNBOUNDED PRECEDING</literal> means that the frame
    starts with the first row of the partition, and similarly
    <literal>UNBOUNDED FOLLOWING</literal> means that the frame ends with the last
    row of the partition, regardless
    of <literal>RANGE</literal>, <literal>ROWS</literal>
    or <literal>GROUPS</literal> mode.
    In <literal>ROWS</literal> mode, <literal>CURRENT ROW</literal> means
    that the frame starts or ends with the current row; but
    in <literal>RANGE</literal> or <literal>GROUPS</literal> mode it means
    that the frame starts or ends with the current row's first or last peer
    in the <literal>ORDER BY</literal> ordering.
    The <replaceable>offset</replaceable> <literal>PRECEDING</literal> and
    <replaceable>offset</replaceable> <literal>FOLLOWING</literal> options
    vary in meaning depending on the frame mode.
    In <literal>ROWS</literal> mode, the <replaceable>offset</replaceable>
    is an integer indicating that the frame starts or ends that many rows
    before or after the current row.
    In <literal>GROUPS</literal> mode, the <replaceable>offset</replaceable>
    is an integer indicating that the frame starts or ends that many peer
    groups before or after the current row's peer group, where
    a <firstterm>peer group</firstterm> is a group of rows that are
    equivalent according to the window's <literal>ORDER BY</literal> clause.
    In <literal>RANGE</literal> mode, use of
    an <replaceable>offset</replaceable> option requires that there be
    exactly one <literal>ORDER BY</literal> column in the window definition.
    Then the frame contains those rows whose ordering column value is no
    more than <replaceable>offset</replaceable> less than
    (for <literal>PRECEDING</literal>) or more than
    (for <literal>FOLLOWING</literal>) the current row's ordering column
    value.  In these cases the data type of
    the <replaceable>offset</replaceable> expression depends on the data
    type of the ordering column.  For numeric ordering columns it is
    typically of the same type as the ordering column, but for datetime
    ordering columns it is an <type>interval</type>.
    In all these cases, the value of the <replaceable>offset</replaceable>
    must be non-null and non-negative.  Also, while
    the <replaceable>offset</replaceable> does not have to be a simple
    constant, it cannot contain variables, aggregate functions, or window
    functions.
   </para>
________________________________________________________-->
   <para>
    默认的帧选项是<literal>RANGE UNBOUNDED PRECEDING</literal>，它和
    <literal>RANGE BETWEEN UNBOUNDED PRECEDING AND
    CURRENT ROW</literal>相同。它把帧设置为从分区开始直到当前行的最后一个<firstterm>平级</firstterm>行（被该窗口的<literal>ORDER BY</literal>子句认为等价于当前行的行，如果没有<literal>ORDER BY</literal>则所有的行都是平级的）。通常，
    <literal>UNBOUNDED PRECEDING</literal>表示从分区第一行开始的帧，类似地
    <literal>UNBOUNDED FOLLOWING</literal>表示以分区最后一行结束的帧，不论是处于<literal>RANGE</literal>、<literal>ROWS</literal>或者<literal>GROUPS</literal>模式中。在<literal>ROWS</literal>模式中，
     <literal>CURRENT ROW</literal>表示以当前行开始或者结束的帧。而在
    <literal>RANGE</literal>或者<literal>GROUPS</literal>模式中它表示当前行在<literal>ORDER BY</literal>排序中的第一个
    或者最后一个平级行开始或者结束的帧。
    <replaceable>offset</replaceable> <literal>PRECEDING</literal>和<replaceable>offset</replaceable> <literal>FOLLOWING</literal>选项的含义会随着帧模式而变化。在<literal>ROWS</literal>模式中，<replaceable>offset</replaceable>是一个整数，表示帧开始或者结束于当前行之前或者之后的那么多行处。在<literal>GROUPS</literal>模式中，<replaceable>offset</replaceable>是一个整数，表示真开始或者结束于当前行的平级组之前或者之后那么多个平级组处，其中<firstterm>平级组</firstterm>是一组根据窗口的<literal>ORDER BY</literal>子句等效的行。在<literal>RANGE</literal>模式中，<replaceable>offset</replaceable>选项的使用要求在窗口定义中正好有一个<literal>ORDER BY</literal>列。那么该帧包含的行的排序列值不超过<replaceable>offset</replaceable>且小于（对于<literal>PRECEDING</literal>）或者大于（对于<literal>FOLLOWING</literal>）当前行的排序列值。在这些情况中，<replaceable>offset</replaceable>表达式的数据类型取决于排序列的数据类型。对于数字排序列，它通常与排序列是相同类型，但对于datetime类型的排序列它是<type>interval</type>。在所有这些情况中，<replaceable>offset</replaceable>的值必须是非空和非负。此外，虽然<replaceable>offset</replaceable>并非必须是简单常量，但它不能包含变量、聚集函数或者窗口函数。
   </para>
<!-- pgdoc-cn_end sig_en=d19ac6fa884533be95fed80834aa336c -->

<!-- pgdoc-cn_start sig_en=15386d9382630abfcab114a363366871 sig_cn_org=None source=14.1 
   <para>
    The <replaceable>frame_exclusion</replaceable> option allows rows around
    the current row to be excluded from the frame, even if they would be
    included according to the frame start and frame end options.
    <literal>EXCLUDE CURRENT ROW</literal> excludes the current row from the
    frame.
    <literal>EXCLUDE GROUP</literal> excludes the current row and its
    ordering peers from the frame.
    <literal>EXCLUDE TIES</literal> excludes any peers of the current
    row from the frame, but not the current row itself.
    <literal>EXCLUDE NO OTHERS</literal> simply specifies explicitly the
    default behavior of not excluding the current row or its peers.
   </para>
________________________________________________________-->
   <para>
    <replaceable>frame_exclusion</replaceable>选项允许从帧中排除当前行周围的行，即便根据帧的起始选项来说它们应该被包含在帧中。<literal>EXCLUDE CURRENT ROW</literal>把当前行从帧中排除。<literal>EXCLUDE GROUP</literal>把当前行和它在排序上的平级行从帧中排除。<literal>EXCLUDE TIES</literal>从帧中排除当前行的任何平级行，但是不排除当前行本身。<literal>EXCLUDE NO OTHERS</literal>只是明确地指定不排除当前行或其平级行的默认行为。
   </para>
<!-- pgdoc-cn_end sig_en=15386d9382630abfcab114a363366871 -->

<!-- pgdoc-cn_start sig_en=fc892004fadf6f2234961c0b53bc425f sig_cn_org=None source=14.1 
   <para>
    Beware that the <literal>ROWS</literal> mode can produce unpredictable
    results if the <literal>ORDER BY</literal> ordering does not order the rows
    uniquely.  The <literal>RANGE</literal> and <literal>GROUPS</literal>
    modes are designed to ensure that rows that are peers in
    the <literal>ORDER BY</literal> ordering are treated alike: all rows of
    a given peer group will be in the frame or excluded from it.
   </para>
________________________________________________________-->
   <para>
    注意，如果<literal>ORDER BY</literal>排序无法把行唯一地排序，则<literal>ROWS</literal>模式可能产生不可预测的结果。<literal>RANGE</literal>以及<literal>GROUPS</literal>模式的目的是确保在<literal>ORDER BY</literal>顺序中平等的行被同样对待：一个给定平级组中的所有行将在一个帧中或者被从帧中排除。
   </para>
<!-- pgdoc-cn_end sig_en=fc892004fadf6f2234961c0b53bc425f -->

<!-- pgdoc-cn_start sig_en=f53793323a9a88abaa7bf22eab51ca3d sig_cn_org=None source=14.1 
   <para>
    The purpose of a <literal>WINDOW</literal> clause is to specify the
    behavior of <firstterm>window functions</firstterm> appearing in the query's
    <link linkend="sql-select-list"><command>SELECT</command> list</link> or
    <link linkend="sql-orderby"><literal>ORDER BY</literal></link> clause.
    These functions
    can reference the <literal>WINDOW</literal> clause entries by name
    in their <literal>OVER</literal> clauses.  A <literal>WINDOW</literal> clause
    entry does not have to be referenced anywhere, however; if it is not
    used in the query it is simply ignored.  It is possible to use window
    functions without any <literal>WINDOW</literal> clause at all, since
    a window function call can specify its window definition directly in
    its <literal>OVER</literal> clause.  However, the <literal>WINDOW</literal>
    clause saves typing when the same window definition is needed for more
    than one window function.
   </para>
________________________________________________________-->
   <para>
    <literal>WINDOW</literal>子句的目的是指定出现在查询的
    <link linkend="sql-select-list"><command>SELECT</command> list</link>或
    <link linkend="sql-orderby"><literal>ORDER BY</literal></link>子句中的
    <firstterm>窗口函数</firstterm>的行为。这些函数可以在它们的
    <literal>OVER</literal>子句中用名称引用<literal>WINDOW</literal>
    子句项。不过，<literal>WINDOW</literal>子句项不是必须被引用。
    如果在查询中没有用到它，它会被简单地忽略。可以使用根本没有任何
    <literal>WINDOW</literal>子句的窗口函数，因为窗口函数调用可
    以直接在其<literal>OVER</literal>子句中指定它的窗口定义。不过，当多
    个窗口函数都需要相同的窗口定义时，
    <literal>WINDOW</literal>子句能够减少输入。
   </para>
<!-- pgdoc-cn_end sig_en=f53793323a9a88abaa7bf22eab51ca3d -->

<!-- pgdoc-cn_start sig_en=19df3f1786568a53f5a26aace14c59c7 sig_cn_org=None source=14.1 
   <para>
    Currently, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>,
    <literal>FOR SHARE</literal> and <literal>FOR KEY SHARE</literal> cannot be
    specified with <literal>WINDOW</literal>.
   </para>
________________________________________________________-->
   <para>
    当前，<literal>FOR NO KEY UPDATE</literal>、<literal>FOR UPDATE</literal>、
    <literal>FOR SHARE</literal>和<literal>FOR KEY SHARE</literal>不能和
    <literal>WINDOW</literal>一起被指定。
   </para>
<!-- pgdoc-cn_end sig_en=19df3f1786568a53f5a26aace14c59c7 -->

<!-- pgdoc-cn_start sig_en=97bd3461b015cf4f2f1d73bcb7967670 sig_cn_org=None source=14.1 
   <para>
    Window functions are described in detail in
    <xref linkend="tutorial-window"/>,
    <xref linkend="syntax-window-functions"/>, and
    <xref linkend="queries-window"/>.
   </para>
________________________________________________________-->
   <para>
    窗口函数的详细描述在
    <xref linkend="tutorial-window"/>、
    <xref linkend="syntax-window-functions"/>以及
    <xref linkend="queries-window"/>中。
   </para>
<!-- pgdoc-cn_end sig_en=97bd3461b015cf4f2f1d73bcb7967670 -->
  </refsect2>

  <refsect2 id="sql-select-list" xreflabel="SELECT List">
<!-- pgdoc-cn_start sig_en=2d831025fa26ef92b0ba672944892cf5 sig_cn_org=None source=14.1 
   <title><command>SELECT</command> List</title>
________________________________________________________-->
   <title><command>SELECT</command> 列表</title>
<!-- pgdoc-cn_end sig_en=2d831025fa26ef92b0ba672944892cf5 -->

<!-- pgdoc-cn_start sig_en=1c341d500ddf43347fc635659358f634 sig_cn_org=None source=14.1 
   <para>
    The <command>SELECT</command> list (between the key words
    <literal>SELECT</literal> and <literal>FROM</literal>) specifies expressions
    that form the output rows of the <command>SELECT</command>
    statement.  The expressions can (and usually do) refer to columns
    computed in the <literal>FROM</literal> clause.
   </para>
________________________________________________________-->
   <para>
    <command>SELECT</command>列表（位于关键词
    <literal>SELECT</literal>和<literal>FROM</literal>之间）指定构成
    <command>SELECT</command>语句输出行的表达式。这些表达式
    可以（并且通常确实会）引用<literal>FROM</literal>子句中计算得到的列。
   </para>
<!-- pgdoc-cn_end sig_en=1c341d500ddf43347fc635659358f634 -->

<!-- pgdoc-cn_start sig_en=76743983bf80ab5ba82704758e83810a sig_cn_org=None source=14.1 
   <para>
    Just as in a table, every output column of a <command>SELECT</command>
    has a name.  In a simple <command>SELECT</command> this name is just
    used to label the column for display, but when the <command>SELECT</command>
    is a sub-query of a larger query, the name is seen by the larger query
    as the column name of the virtual table produced by the sub-query.
    To specify the name to use for an output column, write
    <literal>AS</literal> <replaceable class="parameter">output_name</replaceable>
    after the column's expression.  (You can omit <literal>AS</literal>,
    but only if the desired output name does not match any
    <productname>PostgreSQL</productname> keyword (see <xref
    linkend="sql-keywords-appendix"/>).  For protection against possible
    future keyword additions, it is recommended that you always either
    write <literal>AS</literal> or double-quote the output name.)
    If you do not specify a column name, a name is chosen automatically
    by <productname>PostgreSQL</productname>.  If the column's expression
    is a simple column reference then the chosen name is the same as that
    column's name.  In more complex cases a function or type name may be
    used, or the system may fall back on a generated name such as
    <literal>?column?</literal>.
   </para>
________________________________________________________-->
   <para>
    正如在表中一样，<command>SELECT</command>的每一个输出列都有一个名称。
    在一个简单的<command>SELECT</command>中，这个名称只是被用来标记要显
    示的列，但是当<command>SELECT</command>是一个大型查询的一个子查询时，大型查询
    会把该名称看做子查询产生的虚表的列名。要指定用于输出列的名称，在该列的表达式
    后面写上
    <literal>AS</literal> <replaceable class="parameter">output_name</replaceable>（
    你可以省略<literal>AS</literal>，但只能在期望的输出名称不匹配任何
    <productname>PostgreSQL</productname>关键词（见<xref
    linkend="sql-keywords-appendix"/>）时省略。为了避免和未来增加的关键词冲突，
    推荐总是写上<literal>AS</literal>或者用双引号引用输出名称）。如果你不指定列名，
    <productname>PostgreSQL</productname>会自动选择一个名称。如果列的表达式
    是一个简单的列引用，那么被选择的名称就和该列的名称相同。在使用函数或者类型名称
    的更复杂的情况中，系统可能会生成诸如
    <literal>?column?</literal>之类的名称。
   </para>
<!-- pgdoc-cn_end sig_en=76743983bf80ab5ba82704758e83810a -->

<!-- pgdoc-cn_start sig_en=e0add539c4cacccfc5492f9737076e43 sig_cn_org=None source=14.1 
   <para>
    An output column's name can be used to refer to the column's value in
    <literal>ORDER BY</literal> and <literal>GROUP BY</literal> clauses, but not in the
    <literal>WHERE</literal> or <literal>HAVING</literal> clauses; there you must write
    out the expression instead.
   </para>
________________________________________________________-->
   <para>
    一个输出列的名称可以被用来在<literal>ORDER BY</literal>以及
    <literal>GROUP BY</literal>子句中引用该列的值，但是不能用于
    <literal>WHERE</literal>和<literal>HAVING</literal>子句（在其中
    必须写出表达式）。
   </para>
<!-- pgdoc-cn_end sig_en=e0add539c4cacccfc5492f9737076e43 -->

<!-- pgdoc-cn_start sig_en=d76b2b4a1c5de56bbfcecb7784492cb9 sig_cn_org=None source=14.1 
   <para>
    Instead of an expression, <literal>*</literal> can be written in
    the output list as a shorthand for all the columns of the selected
    rows.  Also, you can write <literal><replaceable
    class="parameter">table_name</replaceable>.*</literal> as a
    shorthand for the columns coming from just that table.  In these
    cases it is not possible to specify new names with <literal>AS</literal>;
    the output column names will be the same as the table columns' names.
   </para>
________________________________________________________-->
   <para>
    可以在输出列表中写<literal>*</literal>来取代表达式，它是被选中
    行的所有列的一种简写方式。还可以写
    <literal><replaceable
    class="parameter">table_name</replaceable>.*</literal>，它
    是只来自那个表的所有列的简写形式。在这些情况中无法用
    <literal>AS</literal>指定新的名称，输出行的名称将和表列的名称相同。
   </para>
<!-- pgdoc-cn_end sig_en=d76b2b4a1c5de56bbfcecb7784492cb9 -->

<!-- pgdoc-cn_start sig_en=b16dcc32cd92842551e6843ab7b2a47a sig_cn_org=None source=14.1 
   <para>
    According to the SQL standard, the expressions in the output list should
    be computed before applying <literal>DISTINCT</literal>, <literal>ORDER
    BY</literal>, or <literal>LIMIT</literal>.  This is obviously necessary
    when using <literal>DISTINCT</literal>, since otherwise it's not clear
    what values are being made distinct.  However, in many cases it is
    convenient if output expressions are computed after <literal>ORDER
    BY</literal> and <literal>LIMIT</literal>; particularly if the output list
    contains any volatile or expensive functions.  With that behavior, the
    order of function evaluations is more intuitive and there will not be
    evaluations corresponding to rows that never appear in the output.
    <productname>PostgreSQL</productname> will effectively evaluate output expressions
    after sorting and limiting, so long as those expressions are not
    referenced in <literal>DISTINCT</literal>, <literal>ORDER BY</literal>
    or <literal>GROUP BY</literal>.  (As a counterexample, <literal>SELECT
    f(x) FROM tab ORDER BY 1</literal> clearly must evaluate <function>f(x)</function>
    before sorting.)  Output expressions that contain set-returning functions
    are effectively evaluated after sorting and before limiting, so
    that <literal>LIMIT</literal> will act to cut off the output from a
    set-returning function.
   </para>
________________________________________________________-->
   <para>
    根据 SQL 标准，输出列表中的表达式应该在应用<literal>DISTINCT</literal>、<literal>ORDER BY</literal>或者<literal>LIMIT</literal>之前计算。在使用<literal>DISTINCT</literal>时显然必须这样做，否则就无法搞清到底在区分什么值。不过，在很多情况下如果先计算<literal>ORDER BY</literal>和<literal>LIMIT</literal>再计算输出表达式会很方便，特别是如果输出列表中包含任何 volatile 函数或者代价昂贵的函数时尤其如此。通过这种行为，函数计算的顺序更加直观并且对于从未出现在输出中的行将不会进行计算。只要输出表达式没有被<literal>DISTINCT</literal>、<literal>ORDER BY</literal>或者<literal>GROUP BY</literal>引用，<productname>PostgreSQL</productname>实际将在排序和限制行数之后计算输出表达式（作为一个反例，<literal>SELECT f(x) FROM tab ORDER BY 1</literal>显然必须在排序之前计算<function>f(x)</function>）。包含有集合返回函数的输出表达式实际是在排序之后和限制行数之前被计算，这样<literal>LIMIT</literal>才能切断来自集合返回函数的输出。
   </para>
<!-- pgdoc-cn_end sig_en=b16dcc32cd92842551e6843ab7b2a47a -->

   <note>
<!-- pgdoc-cn_start sig_en=b9df644e439a681a49b07587a2212994 sig_cn_org=None source=14.1 
    <para>
     <productname>PostgreSQL</productname> versions before 9.6 did not provide any
     guarantees about the timing of evaluation of output expressions versus
     sorting and limiting; it depended on the form of the chosen query plan.
    </para>
________________________________________________________-->
    <para>
     9.6 版本之前的<productname>PostgreSQL</productname>不对执行输出表达式、排序、限制行数的时间顺序做任何保证，那将取决于被选中的查询计划的形式。
    </para>
<!-- pgdoc-cn_end sig_en=b9df644e439a681a49b07587a2212994 -->
   </note>
  </refsect2>

  <refsect2 id="sql-distinct" xreflabel="DISTINCT Clause">
<!-- pgdoc-cn_start sig_en=9d42ff533903da024799ef484aaceece sig_cn_org=None source=14.1 
   <title><literal>DISTINCT</literal> Clause</title>
________________________________________________________-->
   <title><literal>DISTINCT</literal> 子句</title>
<!-- pgdoc-cn_end sig_en=9d42ff533903da024799ef484aaceece -->

<!-- pgdoc-cn_start sig_en=fcdef0e50b4273dd5d9983cd084ec7f9 sig_cn_org=None source=14.1 
   <para>
    If <literal>SELECT DISTINCT</literal> is specified, all duplicate rows are
    removed from the result set (one row is kept from each group of
    duplicates).  <literal>SELECT ALL</literal> specifies the opposite: all rows are
    kept; that is the default.
   </para>
________________________________________________________-->
   <para>
    如果指定了<literal>SELECT DISTINCT</literal>，所有重复的行会被从结果
    集中移除（为每一组重复的行保留一行）。<literal>SELECT ALL</literal>则
    指定相反的行为：所有行都会被保留，这也是默认情况。
   </para>
<!-- pgdoc-cn_end sig_en=fcdef0e50b4273dd5d9983cd084ec7f9 -->

<!-- pgdoc-cn_start sig_en=569ceacfd324d3953bf18a601652a539 sig_cn_org=None source=14.1 
   <para>
    <literal>SELECT DISTINCT ON ( <replaceable
    class="parameter">expression</replaceable> [, ...] )</literal>
    keeps only the first row of each set of rows where the given
    expressions evaluate to equal.  The <literal>DISTINCT ON</literal>
    expressions are interpreted using the same rules as for
    <literal>ORDER BY</literal> (see above).  Note that the <quote>first
    row</quote> of each set is unpredictable unless <literal>ORDER
    BY</literal> is used to ensure that the desired row appears first.  For
    example:
<programlisting>
SELECT DISTINCT ON (location) location, time, report
    FROM weather_reports
    ORDER BY location, time DESC;
</programlisting>
    retrieves the most recent weather report for each location.  But
    if we had not used <literal>ORDER BY</literal> to force descending order
    of time values for each location, we'd have gotten a report from
    an unpredictable time for each location.
   </para>
________________________________________________________-->
   <para>
    <literal>SELECT DISTINCT ON ( <replaceable
    class="parameter">expression</replaceable> [, ...] )</literal>
    只保留在给定表达式上计算相等的行集合中的第一行。
    <literal>DISTINCT ON</literal>表达式使用和
    <literal>ORDER BY</literal>相同的规则（见上文）解释。注意，除非用
    <literal>ORDER BY</literal>来确保所期望的行出现在第一位，每一个集
    合的<quote>第一行</quote>是不可预测的。例如：
<programlisting>
SELECT DISTINCT ON (location) location, time, report
    FROM weather_reports
    ORDER BY location, time DESC;
</programlisting>
    为每个地点检索最近的天气报告。但是如果我们不使用
    <literal>ORDER BY</literal>来强制对每个地点的时间值进行降序排序，
    我们为每个地点得到的报告的时间可能是无法预测的。
   </para>
<!-- pgdoc-cn_end sig_en=569ceacfd324d3953bf18a601652a539 -->

<!-- pgdoc-cn_start sig_en=1922618668fc3e1cb77baf416a3adbe3 sig_cn_org=None source=14.1 
   <para>
    The <literal>DISTINCT ON</literal> expression(s) must match the leftmost
    <literal>ORDER BY</literal> expression(s).  The <literal>ORDER BY</literal> clause
    will normally contain additional expression(s) that determine the
    desired precedence of rows within each <literal>DISTINCT ON</literal> group.
   </para>
________________________________________________________-->
   <para>
    <literal>DISTINCT ON</literal>表达式必须匹配最左边的
    <literal>ORDER BY</literal>表达式。<literal>ORDER BY</literal>子句通常
    将包含额外的表达式，这些额外的表达式用于决定在每一个
    <literal>DISTINCT ON</literal>分组内行的优先级。
   </para>
<!-- pgdoc-cn_end sig_en=1922618668fc3e1cb77baf416a3adbe3 -->

<!-- pgdoc-cn_start sig_en=9c80da315cc39e572fbc05559d92bbc2 sig_cn_org=None source=14.1 
   <para>
    Currently, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>,
    <literal>FOR SHARE</literal> and <literal>FOR KEY SHARE</literal> cannot be
    specified with <literal>DISTINCT</literal>.
   </para>
________________________________________________________-->
   <para>
    当前，<literal>FOR NO KEY UPDATE</literal>、<literal>FOR UPDATE</literal>、
    <literal>FOR SHARE</literal>和<literal>FOR KEY SHARE</literal>不能和
    <literal>DISTINCT</literal>一起使用。
   </para>
<!-- pgdoc-cn_end sig_en=9c80da315cc39e572fbc05559d92bbc2 -->
  </refsect2>

  <refsect2 id="sql-union" xreflabel="UNION Clause">
<!-- pgdoc-cn_start sig_en=d23274166cf0659ccd0bb84532fb3e54 sig_cn_org=None source=14.1 
   <title><literal>UNION</literal> Clause</title>
________________________________________________________-->
   <title><literal>UNION</literal> 子句</title>
<!-- pgdoc-cn_end sig_en=d23274166cf0659ccd0bb84532fb3e54 -->

<!-- pgdoc-cn_start sig_en=c2a06104318dce664682904888a49aa1 sig_cn_org=None source=14.1 
   <para>
    The <literal>UNION</literal> clause has this general form:
<synopsis>
<replaceable class="parameter">select_statement</replaceable> UNION [ ALL | DISTINCT ] <replaceable class="parameter">select_statement</replaceable>
</synopsis><replaceable class="parameter">select_statement</replaceable> is
    any <command>SELECT</command> statement without an <literal>ORDER
    BY</literal>, <literal>LIMIT</literal>, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>,
    <literal>FOR SHARE</literal>, or <literal>FOR KEY SHARE</literal> clause.
    (<literal>ORDER BY</literal> and <literal>LIMIT</literal> can be attached to a
    subexpression if it is enclosed in parentheses.  Without
    parentheses, these clauses will be taken to apply to the result of
    the <literal>UNION</literal>, not to its right-hand input
    expression.)
   </para>
________________________________________________________-->
   <para>
    <literal>UNION</literal>子句具有下面的形式：
<synopsis>
<replaceable class="parameter">select_statement</replaceable> UNION [ ALL | DISTINCT ] <replaceable class="parameter">select_statement</replaceable>
</synopsis><replaceable class="parameter">select_statement</replaceable>
    是任何没有<literal>ORDER BY</literal>、<literal>LIMIT</literal>、
    <literal>FOR NO KEY UPDATE</literal>、<literal>FOR UPDATE</literal>、
    <literal>FOR SHARE</literal>和<literal>FOR KEY SHARE</literal>子句的
    <command>SELECT</command>语句（如果子表达式被包围在圆括号内，
    <literal>ORDER BY</literal>和<literal>LIMIT</literal>可以被附着到其上。如果没有
    圆括号，这些子句将被应用到<literal>UNION</literal>的结果而不是右手边
    的表达式上）。
   </para>
<!-- pgdoc-cn_end sig_en=c2a06104318dce664682904888a49aa1 -->

<!-- pgdoc-cn_start sig_en=396d582f5dbf1d6cfd2d2e8d1dc6e4f4 sig_cn_org=None source=14.1 
   <para>
    The <literal>UNION</literal> operator computes the set union of
    the rows returned by the involved <command>SELECT</command>
    statements.  A row is in the set union of two result sets if it
    appears in at least one of the result sets.  The two
    <command>SELECT</command> statements that represent the direct
    operands of the <literal>UNION</literal> must produce the same
    number of columns, and corresponding columns must be of compatible
    data types.
   </para>
________________________________________________________-->
   <para>
    <literal>UNION</literal>操作符计算所涉及的
    <command>SELECT</command>语句所返回的行的并集。如果一行
    至少出现在两个结果集中的一个内，它就会在并集中。作为
    <literal>UNION</literal>两个操作数的
    <command>SELECT</command>语句必须产生相同数量的列并且
    对应位置上的列必须具有兼容的数据类型。
   </para>
<!-- pgdoc-cn_end sig_en=396d582f5dbf1d6cfd2d2e8d1dc6e4f4 -->

<!-- pgdoc-cn_start sig_en=55f2dd775490f61c9b03a2f617ab311a sig_cn_org=None source=14.1 
   <para>
    The result of <literal>UNION</literal> does not contain any duplicate
    rows unless the <literal>ALL</literal> option is specified.
    <literal>ALL</literal> prevents elimination of duplicates.  (Therefore,
    <literal>UNION ALL</literal> is usually significantly quicker than
    <literal>UNION</literal>; use <literal>ALL</literal> when you can.)
    <literal>DISTINCT</literal> can be written to explicitly specify the
    default behavior of eliminating duplicate rows.
   </para>
________________________________________________________-->
   <para>
    <literal>UNION</literal>的结果不会包含重复行，除非指定了
    <literal>ALL</literal>选项。<literal>ALL</literal>会阻止消除重复（因此，
    <literal>UNION ALL</literal>通常显著地快于<literal>UNION</literal>，
    尽量使用<literal>ALL</literal>）。可以写<literal>DISTINCT</literal>来
    显式地指定消除重复行的行为。
   </para>
<!-- pgdoc-cn_end sig_en=55f2dd775490f61c9b03a2f617ab311a -->

<!-- pgdoc-cn_start sig_en=7c81067ee7fa99ab0e465a507c6edeab sig_cn_org=None source=14.1 
   <para>
    Multiple <literal>UNION</literal> operators in the same
    <command>SELECT</command> statement are evaluated left to right,
    unless otherwise indicated by parentheses.
   </para>
________________________________________________________-->
   <para>
    除非用圆括号指定计算顺序，
    同一个<command>SELECT</command>语句中的多个
    <literal>UNION</literal>操作符会从左至右计算。
   </para>
<!-- pgdoc-cn_end sig_en=7c81067ee7fa99ab0e465a507c6edeab -->

<!-- pgdoc-cn_start sig_en=7678df99f905451b9cb255d952e55286 sig_cn_org=None source=14.1 
   <para>
    Currently, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>, <literal>FOR SHARE</literal> and
    <literal>FOR KEY SHARE</literal> cannot be
    specified either for a <literal>UNION</literal> result or for any input of a
    <literal>UNION</literal>.
   </para>
________________________________________________________-->
   <para>
    当前，<literal>FOR NO KEY UPDATE</literal>、<literal>FOR UPDATE</literal>、
    <literal>FOR SHARE</literal>和
    <literal>FOR KEY SHARE</literal>不能用于<literal>UNION</literal>结果或者
    <literal>UNION</literal>的任何输入。
   </para>
<!-- pgdoc-cn_end sig_en=7678df99f905451b9cb255d952e55286 -->
  </refsect2>

  <refsect2 id="sql-intersect" xreflabel="INTERSECT Clause">
<!-- pgdoc-cn_start sig_en=f4332501e2e4d98edc29ff5601da2ba6 sig_cn_org=None source=14.1 
   <title><literal>INTERSECT</literal> Clause</title>
________________________________________________________-->
   <title><literal>INTERSECT</literal> 子句</title>
<!-- pgdoc-cn_end sig_en=f4332501e2e4d98edc29ff5601da2ba6 -->

<!-- pgdoc-cn_start sig_en=362a1ae2983294a658297be1f7397467 sig_cn_org=None source=14.1 
   <para>
    The <literal>INTERSECT</literal> clause has this general form:
<synopsis>
<replaceable class="parameter">select_statement</replaceable> INTERSECT [ ALL | DISTINCT ] <replaceable class="parameter">select_statement</replaceable>
</synopsis><replaceable class="parameter">select_statement</replaceable> is
    any <command>SELECT</command> statement without an <literal>ORDER
    BY</literal>, <literal>LIMIT</literal>, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>,
    <literal>FOR SHARE</literal>, or <literal>FOR KEY SHARE</literal> clause.
   </para>
________________________________________________________-->
   <para>
    <literal>INTERSECT</literal>子句具有下面的形式：
<synopsis>
<replaceable class="parameter">select_statement</replaceable> INTERSECT [ ALL | DISTINCT ] <replaceable class="parameter">select_statement</replaceable>
</synopsis><replaceable class="parameter">select_statement</replaceable>
    是任何没有<literal>ORDER
    BY</literal>, <literal>LIMIT</literal>、<literal>FOR NO KEY UPDATE</literal>、<literal>FOR UPDATE</literal>、
    <literal>FOR SHARE</literal>以及<literal>FOR KEY SHARE</literal>子句的
    <command>SELECT</command>语句。
   </para>
<!-- pgdoc-cn_end sig_en=362a1ae2983294a658297be1f7397467 -->

<!-- pgdoc-cn_start sig_en=1da366f4e3f9809b856460cbaec88c56 sig_cn_org=None source=14.1 
   <para>
    The <literal>INTERSECT</literal> operator computes the set
    intersection of the rows returned by the involved
    <command>SELECT</command> statements.  A row is in the
    intersection of two result sets if it appears in both result sets.
   </para>
________________________________________________________-->
   <para>
    <literal>INTERSECT</literal>操作符计算所涉及的
    <command>SELECT</command>语句返回的行的交集。如果
    一行同时出现在两个结果集中，它就在交集中。
   </para>
<!-- pgdoc-cn_end sig_en=1da366f4e3f9809b856460cbaec88c56 -->

<!-- pgdoc-cn_start sig_en=317d99a3b5fce02362dcd75cfe0ff162 sig_cn_org=None source=14.1 
   <para>
    The result of <literal>INTERSECT</literal> does not contain any
    duplicate rows unless the <literal>ALL</literal> option is specified.
    With <literal>ALL</literal>, a row that has <replaceable>m</replaceable> duplicates in the
    left table and <replaceable>n</replaceable> duplicates in the right table will appear
    min(<replaceable>m</replaceable>,<replaceable>n</replaceable>) times in the result set.
    <literal>DISTINCT</literal> can be written to explicitly specify the
    default behavior of eliminating duplicate rows.
   </para>
________________________________________________________-->
   <para>
    <literal>INTERSECT</literal>的结果不会包含重复行，除非指定了
    <literal>ALL</literal>选项。如果有<literal>ALL</literal>，一个在左表中有
    <replaceable>m</replaceable>次重复并且在右表中有<replaceable>n</replaceable>
    次重复的行将会在结果中出现
    min(<replaceable>m</replaceable>,<replaceable>n</replaceable>) 次。
    <literal>DISTINCT</literal>可以写<literal>DISTINCT</literal>来
    显式地指定消除重复行的行为。
   </para>
<!-- pgdoc-cn_end sig_en=317d99a3b5fce02362dcd75cfe0ff162 -->

<!-- pgdoc-cn_start sig_en=70afd55fd40da4fb1c7c3455e0948aed sig_cn_org=None source=14.1 
   <para>
    Multiple <literal>INTERSECT</literal> operators in the same
    <command>SELECT</command> statement are evaluated left to right,
    unless parentheses dictate otherwise.
    <literal>INTERSECT</literal> binds more tightly than
    <literal>UNION</literal>.  That is, <literal>A UNION B INTERSECT
    C</literal> will be read as <literal>A UNION (B INTERSECT
    C)</literal>.
   </para>
________________________________________________________-->
   <para>
    除非用圆括号指定计算顺序，
    同一个<command>SELECT</command>语句中的多个
    <literal>INTERSECT</literal>操作符会从左至右计算。
    <literal>INTERSECT</literal>的优先级比
    <literal>UNION</literal>更高。也就是说，
    <literal>A UNION B INTERSECT
    C</literal>将被读成<literal>A UNION (B INTERSECT
    C)</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=70afd55fd40da4fb1c7c3455e0948aed -->

<!-- pgdoc-cn_start sig_en=baa789f0cfec3eb3b99e52532bf25e6d sig_cn_org=None source=14.1 
   <para>
    Currently, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>, <literal>FOR SHARE</literal> and
    <literal>FOR KEY SHARE</literal> cannot be
    specified either for an <literal>INTERSECT</literal> result or for any input of
    an <literal>INTERSECT</literal>.
   </para>
________________________________________________________-->
   <para>
    当前，<literal>FOR NO KEY UPDATE</literal>、<literal>FOR UPDATE</literal>、
    <literal>FOR SHARE</literal>和
    <literal>FOR KEY SHARE</literal>不能用于<literal>INTERSECT</literal>结果或者
    <literal>INTERSECT</literal>的任何输入。
   </para>
<!-- pgdoc-cn_end sig_en=baa789f0cfec3eb3b99e52532bf25e6d -->
  </refsect2>

  <refsect2 id="sql-except" xreflabel="EXCEPT Clause">
<!-- pgdoc-cn_start sig_en=2696b8239c2e268074c63f30f4ffa85b sig_cn_org=None source=14.1 
   <title><literal>EXCEPT</literal> Clause</title>
________________________________________________________-->
   <title><literal>EXCEPT</literal> 子句</title>
<!-- pgdoc-cn_end sig_en=2696b8239c2e268074c63f30f4ffa85b -->

<!-- pgdoc-cn_start sig_en=dc8d2e56e442718acbb4dcd1c4f71298 sig_cn_org=None source=14.1 
   <para>
    The <literal>EXCEPT</literal> clause has this general form:
<synopsis>
<replaceable class="parameter">select_statement</replaceable> EXCEPT [ ALL | DISTINCT ] <replaceable class="parameter">select_statement</replaceable>
</synopsis><replaceable class="parameter">select_statement</replaceable> is
    any <command>SELECT</command> statement without an <literal>ORDER
    BY</literal>, <literal>LIMIT</literal>, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>,
    <literal>FOR SHARE</literal>, or <literal>FOR KEY SHARE</literal> clause.
   </para>
________________________________________________________-->
   <para>
    <literal>EXCEPT</literal>子句具有下面的形式：
<synopsis>
<replaceable class="parameter">select_statement</replaceable> EXCEPT [ ALL | DISTINCT ] <replaceable class="parameter">select_statement</replaceable>
</synopsis><replaceable class="parameter">select_statement</replaceable>
    是任何没有<literal>ORDER BY</literal>、<literal>LIMIT</literal>、<literal>FOR NO KEY UPDATE</literal>、<literal>FOR UPDATE</literal>、
    <literal>FOR SHARE</literal>以及<literal>FOR KEY SHARE</literal>子句的
    <command>SELECT</command>语句。
   </para>
<!-- pgdoc-cn_end sig_en=dc8d2e56e442718acbb4dcd1c4f71298 -->

<!-- pgdoc-cn_start sig_en=4e31548072606c5fb4e14d2a1cc92373 sig_cn_org=None source=14.1 
   <para>
    The <literal>EXCEPT</literal> operator computes the set of rows
    that are in the result of the left <command>SELECT</command>
    statement but not in the result of the right one.
   </para>
________________________________________________________-->
   <para>
    <literal>EXCEPT</literal>操作符计算位于左
    <command>SELECT</command>语句的结果中但不在右
    <command>SELECT</command>语句结果中的行集合。
   </para>
<!-- pgdoc-cn_end sig_en=4e31548072606c5fb4e14d2a1cc92373 -->

<!-- pgdoc-cn_start sig_en=25425aa0a0eb637e0f5399065bb2ac3d sig_cn_org=None source=14.1 
   <para>
    The result of <literal>EXCEPT</literal> does not contain any
    duplicate rows unless the <literal>ALL</literal> option is specified.
    With <literal>ALL</literal>, a row that has <replaceable>m</replaceable> duplicates in the
    left table and <replaceable>n</replaceable> duplicates in the right table will appear
    max(<replaceable>m</replaceable>-<replaceable>n</replaceable>,0) times in the result set.
    <literal>DISTINCT</literal> can be written to explicitly specify the
    default behavior of eliminating duplicate rows.
   </para>
________________________________________________________-->
   <para>
    <literal>EXCEPT</literal>的结果不会包含重复行，除非指定了
    <literal>ALL</literal>选项。如果有<literal>ALL</literal>，一个在左表中有
    <replaceable>m</replaceable>次重复并且在右表中有
    <replaceable>n</replaceable>次重复的行将会在结果集中出现
    max(<replaceable>m</replaceable>-<replaceable>n</replaceable>,0) 次。
    <literal>DISTINCT</literal>可以写<literal>DISTINCT</literal>来
    显式地指定消除重复行的行为。
   </para>
<!-- pgdoc-cn_end sig_en=25425aa0a0eb637e0f5399065bb2ac3d -->

<!-- pgdoc-cn_start sig_en=7af15333738bfeb7f4e9985a46046b73 sig_cn_org=None source=14.1 
   <para>
    Multiple <literal>EXCEPT</literal> operators in the same
    <command>SELECT</command> statement are evaluated left to right,
    unless parentheses dictate otherwise.  <literal>EXCEPT</literal> binds at
    the same level as <literal>UNION</literal>.
   </para>
________________________________________________________-->
   <para>
    除非用圆括号指定计算顺序，
    同一个<command>SELECT</command>语句中的多个
    <literal>EXCEPT</literal>操作符会从左至右计算。
    <literal>EXCEPT</literal>的优先级与
    <literal>UNION</literal>相同。
   </para>
<!-- pgdoc-cn_end sig_en=7af15333738bfeb7f4e9985a46046b73 -->

<!-- pgdoc-cn_start sig_en=b31402be1a4e59796140a93d0a3b652a sig_cn_org=None source=14.1 
   <para>
    Currently, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>, <literal>FOR SHARE</literal> and
    <literal>FOR KEY SHARE</literal> cannot be
    specified either for an <literal>EXCEPT</literal> result or for any input of
    an <literal>EXCEPT</literal>.
   </para>
________________________________________________________-->
   <para>
    当前，<literal>FOR NO KEY UPDATE</literal>、<literal>FOR UPDATE</literal>、
    <literal>FOR SHARE</literal>和
    <literal>FOR KEY SHARE</literal>不能用于<literal>EXCEPT</literal>结果或者
    <literal>EXCEPT</literal>的任何输入。
   </para>
<!-- pgdoc-cn_end sig_en=b31402be1a4e59796140a93d0a3b652a -->
  </refsect2>

  <refsect2 id="sql-orderby" xreflabel="ORDER BY Clause">
<!-- pgdoc-cn_start sig_en=d66f9f768b4b6ed44d691b1f81fc66b2 sig_cn_org=None source=14.1 
   <title><literal>ORDER BY</literal> Clause</title>
________________________________________________________-->
   <title><literal>ORDER BY</literal> 子句</title>
<!-- pgdoc-cn_end sig_en=d66f9f768b4b6ed44d691b1f81fc66b2 -->

<!-- pgdoc-cn_start sig_en=60b3797d0d3767922d94cccad05bc1dc sig_cn_org=None source=14.1 
   <para>
    The optional <literal>ORDER BY</literal> clause has this general form:
<synopsis>
ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operator</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...]
</synopsis>
    The <literal>ORDER BY</literal> clause causes the result rows to
    be sorted according to the specified expression(s).  If two rows are
    equal according to the leftmost expression, they are compared
    according to the next expression and so on.  If they are equal
    according to all specified expressions, they are returned in
    an implementation-dependent order.
   </para>
________________________________________________________-->
   <para>
    可选的<literal>ORDER BY</literal>子句的形式如下：
<synopsis>
ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operator</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...]
</synopsis>
    <literal>ORDER BY</literal>子句导致结果行被按照指定的表达式排序。
    如果两行按照最左边的表达式是相等的，则会根据下一个表达式比较它们，
    依次类推。如果按照所有指定的表达式它们都是相等的，则它们被返回的
    顺序取决于实现。
   </para>
<!-- pgdoc-cn_end sig_en=60b3797d0d3767922d94cccad05bc1dc -->

<!-- pgdoc-cn_start sig_en=5734761ed709860079d7e9a630415695 sig_cn_org=None source=14.1 
   <para>
    Each <replaceable class="parameter">expression</replaceable> can be the
    name or ordinal number of an output column
    (<command>SELECT</command> list item), or it can be an arbitrary
    expression formed from input-column values.
   </para>
________________________________________________________-->
   <para>
    每一个<replaceable class="parameter">expression</replaceable>
    可以是输出列（<command>SELECT</command>列表项）的名称或
    者序号，它也可以是由输入列值构成的任意表达式。
   </para>
<!-- pgdoc-cn_end sig_en=5734761ed709860079d7e9a630415695 -->

<!-- pgdoc-cn_start sig_en=4aa655a56d794771042216ed35c1a42d sig_cn_org=None source=14.1 
   <para>
    The ordinal number refers to the ordinal (left-to-right) position
    of the output column. This feature makes it possible to define an
    ordering on the basis of a column that does not have a unique
    name.  This is never absolutely necessary because it is always
    possible to assign a name to an output column using the
    <literal>AS</literal> clause.
   </para>
________________________________________________________-->
   <para>
    序号指的是输出列的顺序（从左至右）位置。这种特性可以为不具有唯一
    名称的列定义一个顺序。这不是绝对必要的，因为总是可以使用
    <literal>AS</literal>子句为输出列赋予一个名称。
   </para>
<!-- pgdoc-cn_end sig_en=4aa655a56d794771042216ed35c1a42d -->

<!-- pgdoc-cn_start sig_en=5f08ddc4b2dcc64c020821aa19ea884a sig_cn_org=None source=14.1 
   <para>
    It is also possible to use arbitrary expressions in the
    <literal>ORDER BY</literal> clause, including columns that do not
    appear in the <command>SELECT</command> output list.  Thus the
    following statement is valid:
<programlisting>
SELECT name FROM distributors ORDER BY code;
</programlisting>
    A limitation of this feature is that an <literal>ORDER BY</literal>
    clause applying to the result of a <literal>UNION</literal>,
    <literal>INTERSECT</literal>, or <literal>EXCEPT</literal> clause can only
    specify an output column name or number, not an expression.
   </para>
________________________________________________________-->
   <para>
    也可以在<literal>ORDER BY</literal>子句中使用任意表达式，包括没
    有出现在<command>SELECT</command>输出列表中的列。因此，
    下面的语句是合法的：
<programlisting>
SELECT name FROM distributors ORDER BY code;
</programlisting>
    这种特性的一个限制是一个应用在<literal>UNION</literal>、
    <literal>INTERSECT</literal>或<literal>EXCEPT</literal>子句结果上的
    <literal>ORDER BY</literal>只能指定输出列名称或序号，但不能指定表达式。
   </para>
<!-- pgdoc-cn_end sig_en=5f08ddc4b2dcc64c020821aa19ea884a -->

<!-- pgdoc-cn_start sig_en=f0d9dfb4cb8e387dadfea9c4f78a0131 sig_cn_org=None source=14.1 
   <para>
    If an <literal>ORDER BY</literal> expression is a simple name that
    matches both an output column name and an input column name,
    <literal>ORDER BY</literal> will interpret it as the output column name.
    This is the opposite of the choice that <literal>GROUP BY</literal> will
    make in the same situation.  This inconsistency is made to be
    compatible with the SQL standard.
   </para>
________________________________________________________-->
   <para>
    如果一个<literal>ORDER BY</literal>表达式是一个既匹配输出列名称又匹配
    输入列名称的简单名称，<literal>ORDER BY</literal>将把它解读成输出列名
    称。这与在同样情况下<literal>GROUP BY</literal>会做出的选择相反。这种
    不一致是为了与 SQL 标准兼容。
   </para>
<!-- pgdoc-cn_end sig_en=f0d9dfb4cb8e387dadfea9c4f78a0131 -->

<!-- pgdoc-cn_start sig_en=63f84e19024550043674971e35e56a8c sig_cn_org=None source=14.1 
   <para>
    Optionally one can add the key word <literal>ASC</literal> (ascending) or
    <literal>DESC</literal> (descending) after any expression in the
    <literal>ORDER BY</literal> clause.  If not specified, <literal>ASC</literal> is
    assumed by default.  Alternatively, a specific ordering operator
    name can be specified in the <literal>USING</literal> clause.
    An ordering operator must be a less-than or greater-than
    member of some B-tree operator family.
    <literal>ASC</literal> is usually equivalent to <literal>USING &lt;</literal> and
    <literal>DESC</literal> is usually equivalent to <literal>USING &gt;</literal>.
    (But the creator of a user-defined data type can define exactly what the
    default sort ordering is, and it might correspond to operators with other
    names.)
   </para>
________________________________________________________-->
   <para>
    可以为<literal>ORDER BY</literal>子句中的任何表达式之后增加关键词
    <literal>ASC</literal>（上升）<literal>DESC</literal>（下降）。如果没有指定，
    <literal>ASC</literal>被假定为默认值。或者，可以在<literal>USING</literal>
    子句中指定一个特定的排序操作符名称。一个排序操作符必须是某个
    B-树操作符族的小于或者大于成员。<literal>ASC</literal>通常等价于
    <literal>USING &lt;</literal>而<literal>DESC</literal>通常等价于
    <literal>USING &gt;</literal>（但是一种用户定义数据类型的创建者可以
    准确地定义默认排序顺序是什么，并且它可能会对应于其他名称的操作符）。
   </para>
<!-- pgdoc-cn_end sig_en=63f84e19024550043674971e35e56a8c -->

<!-- pgdoc-cn_start sig_en=c2c169a82ae6708e1d205492d71adc12 sig_cn_org=None source=14.1 
   <para>
    If <literal>NULLS LAST</literal> is specified, null values sort after all
    non-null values; if <literal>NULLS FIRST</literal> is specified, null values
    sort before all non-null values.  If neither is specified, the default
    behavior is <literal>NULLS LAST</literal> when <literal>ASC</literal> is specified
    or implied, and <literal>NULLS FIRST</literal> when <literal>DESC</literal> is specified
    (thus, the default is to act as though nulls are larger than non-nulls).
    When <literal>USING</literal> is specified, the default nulls ordering depends
    on whether the operator is a less-than or greater-than operator.
   </para>
________________________________________________________-->
   <para>
    如果指定<literal>NULLS LAST</literal>，空值会排在非空值之后；如果指定
    <literal>NULLS FIRST</literal>，空值会排在非空值之前。如果都没有指定，
    在指定或者隐含<literal>ASC</literal>时的默认行为是<literal>NULLS LAST</literal>，
    而指定或者隐含<literal>DESC</literal>时的默认行为是
    <literal>NULLS FIRST</literal>（因此，默认行为是空值大于非空值）。
    当指定<literal>USING</literal>时，默认的空值顺序取决于该操作符是否为
    小于或者大于操作符。
   </para>
<!-- pgdoc-cn_end sig_en=c2c169a82ae6708e1d205492d71adc12 -->

<!-- pgdoc-cn_start sig_en=b41b99c4398cfe7c2d7573c5b160e4e7 sig_cn_org=None source=14.1 
   <para>
    Note that ordering options apply only to the expression they follow;
    for example <literal>ORDER BY x, y DESC</literal> does not mean
    the same thing as <literal>ORDER BY x DESC, y DESC</literal>.
   </para>
________________________________________________________-->
   <para>
    注意顺序选项只应用到它们所跟随的表达式上。例如
    <literal>ORDER BY x, y DESC</literal>和
    <literal>ORDER BY x DESC, y DESC</literal>是不同的。
   </para>
<!-- pgdoc-cn_end sig_en=b41b99c4398cfe7c2d7573c5b160e4e7 -->

<!-- pgdoc-cn_start sig_en=e994c94bbc70c13bad65d03e9ae8feb0 sig_cn_org=None source=14.1 
   <para>
    Character-string data is sorted according to the collation that applies
    to the column being sorted.  That can be overridden at need by including
    a <literal>COLLATE</literal> clause in the
    <replaceable class="parameter">expression</replaceable>, for example
    <literal>ORDER BY mycolumn COLLATE "en_US"</literal>.
    For more information see <xref linkend="sql-syntax-collate-exprs"/> and
    <xref linkend="collation"/>.
   </para>
________________________________________________________-->
   <para>
    字符串数据会被根据引用到被排序列上的排序规则排序。根据需要可以通过在
    <replaceable class="parameter">expression</replaceable>中包括一个
    <literal>COLLATE</literal>子句来覆盖，例如
    <literal>ORDER BY mycolumn COLLATE "en_US"</literal>。更多信息请见
    <xref linkend="sql-syntax-collate-exprs"/>和
    <xref linkend="collation"/>。
   </para>
<!-- pgdoc-cn_end sig_en=e994c94bbc70c13bad65d03e9ae8feb0 -->
  </refsect2>

  <refsect2 id="sql-limit" xreflabel="LIMIT Clause">
<!-- pgdoc-cn_start sig_en=4c0159807c8b803d5ec30a6282cdb046 sig_cn_org=None source=14.1 
   <title><literal>LIMIT</literal> Clause</title>
________________________________________________________-->
   <title><literal>LIMIT</literal> 子句</title>
<!-- pgdoc-cn_end sig_en=4c0159807c8b803d5ec30a6282cdb046 -->

<!-- pgdoc-cn_start sig_en=9fcd1234bf3d1fbea80b5f54c443ffca sig_cn_org=None source=14.1 
   <para>
    The <literal>LIMIT</literal> clause consists of two independent
    sub-clauses:
<synopsis>
LIMIT { <replaceable class="parameter">count</replaceable> | ALL }
OFFSET <replaceable class="parameter">start</replaceable>
</synopsis>
    The parameter <replaceable class="parameter">count</replaceable> specifies the
    maximum number of rows to return, while <replaceable
    class="parameter">start</replaceable> specifies the number of rows
    to skip before starting to return rows.  When both are specified,
    <replaceable class="parameter">start</replaceable> rows are skipped
    before starting to count the <replaceable
    class="parameter">count</replaceable> rows to be returned.
   </para>
________________________________________________________-->
   <para>
    <literal>LIMIT</literal>子句由两个独立的子句构成：
<synopsis>
LIMIT { <replaceable class="parameter">count</replaceable> | ALL }
OFFSET <replaceable class="parameter">start</replaceable>
</synopsis>
    参数<replaceable class="parameter">count</replaceable>指定要返回
    的最大行数，而<replaceable class="parameter">start</replaceable>
    指定在返回行之前要跳过的行数。在两者都被指定时，在开始计算要返回的
    <replaceable class="parameter">count</replaceable>行之前会跳过
    <replaceable class="parameter">start</replaceable>行。
   </para>
<!-- pgdoc-cn_end sig_en=9fcd1234bf3d1fbea80b5f54c443ffca -->

<!-- pgdoc-cn_start sig_en=2af23788dbb826ed8ca404197021e868 sig_cn_org=None source=14.1 
   <para>
    If the <replaceable class="parameter">count</replaceable> expression
    evaluates to NULL, it is treated as <literal>LIMIT ALL</literal>, i.e., no
    limit.  If <replaceable class="parameter">start</replaceable> evaluates
    to NULL, it is treated the same as <literal>OFFSET 0</literal>.
   </para>
________________________________________________________-->
   <para>
    如果<replaceable class="parameter">count</replaceable>表达式计算
    为 NULL，它会被当成<literal>LIMIT ALL</literal>，即没有限制。如果
    <replaceable class="parameter">start</replaceable>计算为
    NULL，它会被当作<literal>OFFSET 0</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=2af23788dbb826ed8ca404197021e868 -->

<!-- pgdoc-cn_start sig_en=dba3a095c15b2094633293104345c1c8 sig_cn_org=None source=14.1 
   <para>
    SQL:2008 introduced a different syntax to achieve the same result,
    which <productname>PostgreSQL</productname> also supports.  It is:
<synopsis>
OFFSET <replaceable class="parameter">start</replaceable> { ROW | ROWS }
FETCH { FIRST | NEXT } [ <replaceable class="parameter">count</replaceable> ] { ROW | ROWS } { ONLY | WITH TIES }
</synopsis>
    In this syntax, the <replaceable class="parameter">start</replaceable>
    or <replaceable class="parameter">count</replaceable> value is required by
    the standard to be a literal constant, a parameter, or a variable name;
    as a <productname>PostgreSQL</productname> extension, other expressions
    are allowed, but will generally need to be enclosed in parentheses to avoid
    ambiguity.
    If <replaceable class="parameter">count</replaceable> is
    omitted in a <literal>FETCH</literal> clause, it defaults to 1.
    The <literal>WITH TIES</literal> option is used to return any additional
    rows that tie for the last place in the result set according to
    the <literal>ORDER BY</literal> clause; <literal>ORDER BY</literal>
    is mandatory in this case, and <literal>SKIP LOCKED</literal> is
    not allowed.
    <literal>ROW</literal> and <literal>ROWS</literal> as well as
    <literal>FIRST</literal> and <literal>NEXT</literal> are noise
    words that don't influence the effects of these clauses.
    According to the standard, the <literal>OFFSET</literal> clause must come
    before the <literal>FETCH</literal> clause if both are present; but
    <productname>PostgreSQL</productname> is laxer and allows either order.
   </para>
________________________________________________________-->
   <para>
    SQL:2008 引入了一种不同的语法来达到相同的结果，
    <productname>PostgreSQL</productname>也支持它：
<synopsis>
OFFSET <replaceable class="parameter">start</replaceable> { ROW | ROWS }
FETCH { FIRST | NEXT } [ <replaceable class="parameter">count</replaceable> ] { ROW | ROWS } { ONLY | WITH TIES }
</synopsis>

    在这种语法中，标准要求<replaceable class="parameter">start</replaceable>或<replaceable class="parameter">count</replaceable>是一个文本常量、一个参数或者一个变量名。
    而作为一种<productname>PostgreSQL</productname>的扩展，还允许其他的表达式，但通常需要被封闭在圆括号中以避免歧义。
    如果在一个<literal>FETCH</literal>子句中省略<replaceable class="parameter">count</replaceable>，它的默认值为 1。
    <literal>WITH TIES</literal>选项用于根据<literal>ORDER BY</literal>子句返回与结果集中最后一个位置相关的任何附加行；<literal>ORDER BY</literal>在这种情况下是强制性的，并且<literal>SKIP LOCKED</literal>是不被允许的。
    <literal>ROW</literal>和<literal>ROWS</literal>以及<literal>FIRST</literal>和<literal>NEXT</literal>是噪声，它们不影响这些子句的效果。
    根据标准，如果都存在，<literal>OFFSET</literal>子句必须出现在<literal>FETCH</literal>子句之前。
    但是<productname>PostgreSQL</productname>更宽松，它允许两种顺序。
   </para>
<!-- pgdoc-cn_end sig_en=dba3a095c15b2094633293104345c1c8 -->

<!-- pgdoc-cn_start sig_en=ad203072bf4d8d2e9eb473b9d79b2c7e sig_cn_org=None source=14.1 
   <para>
    When using <literal>LIMIT</literal>, it is a good idea to use an
    <literal>ORDER BY</literal> clause that constrains the result rows into a
    unique order.  Otherwise you will get an unpredictable subset of
    the query's rows &mdash; you might be asking for the tenth through
    twentieth rows, but tenth through twentieth in what ordering?  You
    don't know what ordering unless you specify <literal>ORDER BY</literal>.
   </para>
________________________________________________________-->
   <para>
    在使用<literal>LIMIT</literal>时，用一个<literal>ORDER BY</literal>子句把
    结果行约束到一个唯一顺序是个好办法。否则你讲得到该查询结果行的
    一个不可预测的子集 &mdash; 你可能要求从第 10 到第 20 行，但是在
    什么顺序下的第 10 到第 20 呢？除非指定<literal>ORDER BY</literal>，你
    是不知道顺序的。
   </para>
<!-- pgdoc-cn_end sig_en=ad203072bf4d8d2e9eb473b9d79b2c7e -->

<!-- pgdoc-cn_start sig_en=dc111d80b756a2d36d5f745cda914690 sig_cn_org=None source=14.1 
   <para>
    The query planner takes <literal>LIMIT</literal> into account when
    generating a query plan, so you are very likely to get different
    plans (yielding different row orders) depending on what you use
    for <literal>LIMIT</literal> and <literal>OFFSET</literal>.  Thus, using
    different <literal>LIMIT</literal>/<literal>OFFSET</literal> values to select
    different subsets of a query result <emphasis>will give
    inconsistent results</emphasis> unless you enforce a predictable
    result ordering with <literal>ORDER BY</literal>.  This is not a bug; it
    is an inherent consequence of the fact that SQL does not promise
    to deliver the results of a query in any particular order unless
    <literal>ORDER BY</literal> is used to constrain the order.
   </para>
________________________________________________________-->
   <para>
    查询规划器在生成一个查询计划时会考虑<literal>LIMIT</literal>，因此
    根据你使用的<literal>LIMIT</literal>和<literal>OFFSET</literal>，你很可能
    得到不同的计划（得到不同的行序）。所以，使用不同的
    <literal>LIMIT</literal>/<literal>OFFSET</literal>值来选择一个查询结果的
    不同子集<emphasis>将会给出不一致的结果</emphasis>，除非你
    用<literal>ORDER BY</literal>强制一种可预测的结果顺序。这不是一个
    缺陷，它是 SQL 不承诺以任何特定顺序（除非使用
    <literal>ORDER BY</literal>来约束顺序）给出一个查询结果这一事实造
    成的必然后果。
   </para>
<!-- pgdoc-cn_end sig_en=dc111d80b756a2d36d5f745cda914690 -->

<!-- pgdoc-cn_start sig_en=fb072f1dc95aabc6454288777c3e9071 sig_cn_org=None source=14.1 
   <para>
    It is even possible for repeated executions of the same <literal>LIMIT</literal>
    query to return different subsets of the rows of a table, if there
    is not an <literal>ORDER BY</literal> to enforce selection of a deterministic
    subset.  Again, this is not a bug; determinism of the results is
    simply not guaranteed in such a case.
   </para>
________________________________________________________-->
   <para>
    如果没有一个<literal>ORDER BY</literal>来强制选择一个确定的子集，
    重复执行同样的<literal>LIMIT</literal>查询甚至可能会返回一个表中行
    的不同子集。同样，这也不是一种缺陷，再这样一种情况下也无法
    保证结果的确定性。
   </para>
<!-- pgdoc-cn_end sig_en=fb072f1dc95aabc6454288777c3e9071 -->
  </refsect2>

  <refsect2 id="sql-for-update-share" xreflabel="The Locking Clause">
<!-- pgdoc-cn_start sig_en=daae5c65a9a0c5776ff622ac6434922b sig_cn_org=None source=14.1 
   <title>The Locking Clause</title>
________________________________________________________-->
   <title>锁定子句</title>
<!-- pgdoc-cn_end sig_en=daae5c65a9a0c5776ff622ac6434922b -->

<!-- pgdoc-cn_start sig_en=aa777115b7e85b3ce70bfc5dcdc4a7d0 sig_cn_org=None source=14.1 
   <para>
    <literal>FOR UPDATE</literal>, <literal>FOR NO KEY UPDATE</literal>, <literal>FOR SHARE</literal>
    and <literal>FOR KEY SHARE</literal>
    are <firstterm>locking clauses</firstterm>; they affect how <literal>SELECT</literal>
    locks rows as they are obtained from the table.
   </para>
________________________________________________________-->
   <para>
    <literal>FOR UPDATE</literal>、<literal>FOR NO KEY UPDATE</literal>、
    <literal>FOR SHARE</literal>和<literal>FOR KEY SHARE</literal>
    是<firstterm>锁定子句</firstterm>，它们影响<literal>SELECT</literal>
    把行从表中取得时如何对它们加锁。
   </para>
<!-- pgdoc-cn_end sig_en=aa777115b7e85b3ce70bfc5dcdc4a7d0 -->

<!-- pgdoc-cn_start sig_en=f459ccc7f559a2479cabcd27a933805c sig_cn_org=None source=14.1 
   <para>
    The locking clause has the general form

<synopsis>
FOR <replaceable>lock_strength</replaceable> [ OF <replaceable class="parameter">table_name</replaceable> [, ...] ] [ NOWAIT | SKIP LOCKED ]
</synopsis>

    where <replaceable>lock_strength</replaceable> can be one of

<synopsis>
UPDATE
NO KEY UPDATE
SHARE
KEY SHARE
</synopsis>
   </para>
________________________________________________________-->
   <para>
    锁定子句的一般形式：

<synopsis>
FOR <replaceable>lock_strength</replaceable> [ OF <replaceable class="parameter">table_name</replaceable> [, ...] ] [ NOWAIT | SKIP LOCKED ]
</synopsis>

    其中<replaceable>lock_strength</replaceable>可以是

<synopsis>
UPDATE
NO KEY UPDATE
SHARE
KEY SHARE
</synopsis>
   </para>
<!-- pgdoc-cn_end sig_en=f459ccc7f559a2479cabcd27a933805c -->

<!-- pgdoc-cn_start sig_en=c96a8c63c35677d1de9583f539c4eca3 sig_cn_org=None source=14.1 
   <para>
    For more information on each row-level lock mode, refer to
    <xref linkend="locking-rows"/>.
   </para>
________________________________________________________-->
   <para>
    更多关于每一种行级锁模式的信息可见
    <xref linkend="locking-rows"/>。
   </para>
<!-- pgdoc-cn_end sig_en=c96a8c63c35677d1de9583f539c4eca3 -->

<!-- pgdoc-cn_start sig_en=9916a9ff43e6094c1fa4c98b88202cd2 sig_cn_org=None source=14.1 
   <para>
    To prevent the operation from waiting for other transactions to commit,
    use either the <literal>NOWAIT</literal> or <literal>SKIP LOCKED</literal>
    option.  With <literal>NOWAIT</literal>, the statement reports an error, rather
    than waiting, if a selected row cannot be locked immediately.
    With <literal>SKIP LOCKED</literal>, any selected rows that cannot be
    immediately locked are skipped.  Skipping locked rows provides an
    inconsistent view of the data, so this is not suitable for general purpose
    work, but can be used to avoid lock contention with multiple consumers
    accessing a queue-like table.
    Note that <literal>NOWAIT</literal> and <literal>SKIP LOCKED</literal> apply only
    to the row-level lock(s) &mdash; the required <literal>ROW SHARE</literal>
    table-level lock is still taken in the ordinary way (see
    <xref linkend="mvcc"/>).  You can use
    <link linkend="sql-lock"><command>LOCK</command></link>
    with the <literal>NOWAIT</literal> option first,
    if you need to acquire the table-level lock without waiting.
   </para>
________________________________________________________-->
   <para>
    为了防止该操作等待其他事务提交，可使用<literal>NOWAIT</literal>或者<literal>SKIP LOCKED</literal>选项。
    使用<literal>NOWAIT</literal>时，如果选中的行不能被立即锁定，该语句会报告错误而不是等待。
    使用 <literal>SKIP LOCKED</literal>时，无法被立即锁定的任何选中行都会被跳过。
    跳过已锁定行会提供数据的一个不一致的视图，因此这不适合于一般目的的工作，但是可以被用来避免多个用户访问一个类似队列的表时出现锁竞争。
    注意<literal>NOWAIT</literal>和<literal>SKIP LOCKED</literal>只适合行级锁 &mdash; 所要求的<literal>ROW SHARE</literal>表级锁仍然会以常规的方式（见<xref linkend="mvcc"/>）取得。
    如果想要不等待的表级锁，你可以先使用带<literal>NOWAIT</literal>的<link linkend="sql-lock"><command>LOCK</command></link>。
   </para>
<!-- pgdoc-cn_end sig_en=9916a9ff43e6094c1fa4c98b88202cd2 -->

<!-- pgdoc-cn_start sig_en=6e26c5c6f56c2ed46107aeb47e74410a sig_cn_org=None source=14.1 
   <para>
    If specific tables are named in a locking clause,
    then only rows coming from those tables are locked; any other
    tables used in the <command>SELECT</command> are simply read as
    usual.  A locking
    clause without a table list affects all tables used in the statement.
    If a locking clause is
    applied to a view or sub-query, it affects all tables used in
    the view or sub-query.
    However, these clauses
    do not apply to <literal>WITH</literal> queries referenced by the primary query.
    If you want row locking to occur within a <literal>WITH</literal> query, specify
    a locking clause within the <literal>WITH</literal> query.
   </para>
________________________________________________________-->
   <para>
    如果在一个锁定子句中提到了特定的表，则只有来自于那些表的
    行会被锁定，任何<command>SELECT</command>中用到的
    其他表还是被简单地照常读取。一个没有表列表的锁定子句会影响
    该语句中用到的所有表。如果一个锁定子句被应用到一个视图或者
    子查询，它会影响在该视图或子查询中用到的所有表。不过，这些
    子句不适用于主查询引用的<literal>WITH</literal>查询。如果你希望
    在一个<literal>WITH</literal>查询中发生行锁定，应该在该
    <literal>WITH</literal>查询内指定一个锁定子句。
   </para>
<!-- pgdoc-cn_end sig_en=6e26c5c6f56c2ed46107aeb47e74410a -->

<!-- pgdoc-cn_start sig_en=340336269d05016ad91e6b064ae428c6 sig_cn_org=None source=14.1 
   <para>
    Multiple locking
    clauses can be written if it is necessary to specify different locking
    behavior for different tables.  If the same table is mentioned (or
    implicitly affected) by more than one locking clause,
    then it is processed as if it was only specified by the strongest one.
    Similarly, a table is processed
    as <literal>NOWAIT</literal> if that is specified in any of the clauses
    affecting it.  Otherwise, it is processed
    as <literal>SKIP LOCKED</literal> if that is specified in any of the
    clauses affecting it.
   </para>
________________________________________________________-->
   <para>
    如果有必要对不同的表指定不同的锁定行为，可以写多个锁定子句。
    如果同一个表在多于一个锁定子句中被提到（或者被隐式的影响到），
    那么会按照所指定的最强的锁定行为来处理它。类似地，如果在任何
    影响一个表的子句中指定了<literal>NOWAIT</literal>，就会按照
    <literal>NOWAIT</literal>的行为来处理该表。否则如果
    <literal>SKIP LOCKED</literal>在任何影响该表的子句中被指定，
    该表就会被按照<literal>SKIP LOCKED</literal>来处理。
   </para>
<!-- pgdoc-cn_end sig_en=340336269d05016ad91e6b064ae428c6 -->

<!-- pgdoc-cn_start sig_en=8711f7bb409528d8cf3a27c082729d58 sig_cn_org=None source=14.1 
   <para>
    The locking clauses cannot be
    used in contexts where returned rows cannot be clearly identified with
    individual table rows; for example they cannot be used with aggregation.
   </para>
________________________________________________________-->
   <para>
    如果被返回的行无法清晰地与表中的行保持一致，则不能使用锁定子句。
    例如锁定子句不能与聚集一起使用。
   </para>
<!-- pgdoc-cn_end sig_en=8711f7bb409528d8cf3a27c082729d58 -->

<!-- pgdoc-cn_start sig_en=4badb38d1e36ecc9c84ccbadf2fc9958 sig_cn_org=None source=14.1 
   <para>
    When a locking clause
    appears at the top level of a <command>SELECT</command> query, the rows that
    are locked are exactly those that are returned by the query; in the
    case of a join query, the rows locked are those that contribute to
    returned join rows.  In addition, rows that satisfied the query
    conditions as of the query snapshot will be locked, although they
    will not be returned if they were updated after the snapshot
    and no longer satisfy the query conditions.  If a
    <literal>LIMIT</literal> is used, locking stops
    once enough rows have been returned to satisfy the limit (but note that
    rows skipped over by <literal>OFFSET</literal> will get locked).  Similarly,
    if a locking clause
    is used in a cursor's query, only rows actually fetched or stepped past
    by the cursor will be locked.
   </para>
________________________________________________________-->
   <para>
    当一个锁定子句出现在一个<command>SELECT</command>查询的顶层时，
    被锁定的行正好就是该查询返回的行。在连接查询的情况下，被锁定
    的行是那些对返回的连接行有贡献的行。此外，自该查询的快照起满足
    查询条件的行将被锁定，如果它们在该快照后被更新并且不再满足
    查询条件，它们将不会被返回。如果使用了<literal>LIMIT</literal>，只要
    已经返回的行数满足了限制，锁定就会停止（但注意被
    <literal>OFFSET</literal>跳过的行将被锁定）。类似地，如果在一个游标
    的查询中使用锁定子句，只有被该游标实际取出或者跳过的行才将被
    锁定。
   </para>
<!-- pgdoc-cn_end sig_en=4badb38d1e36ecc9c84ccbadf2fc9958 -->

<!-- pgdoc-cn_start sig_en=f1b08f019e0143740623f59a36ce22ac sig_cn_org=None source=14.1 
   <para>
    When a locking clause
    appears in a sub-<command>SELECT</command>, the rows locked are those
    returned to the outer query by the sub-query.  This might involve
    fewer rows than inspection of the sub-query alone would suggest,
    since conditions from the outer query might be used to optimize
    execution of the sub-query.  For example,
<programlisting>
SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;
</programlisting>
    will lock only rows having <literal>col1 = 5</literal>, even though that
    condition is not textually within the sub-query.
   </para>
________________________________________________________-->
   <para>
    当一个锁定子句出现在一个子-<command>SELECT</command>中时，被锁定
    行是那些该子查询返回给外层查询的行。这些被锁定的行的数量可能比
    从子查询自身的角度看到的要少，因为来自外层查询的条件可能会被用
    来优化子查询的执行。例如：
<programlisting>
SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;
</programlisting>
    将只锁定具有<literal>col1 = 5</literal>的行（虽然在子查询中并没有写上
    该条件）。
   </para>
<!-- pgdoc-cn_end sig_en=f1b08f019e0143740623f59a36ce22ac -->

<!-- pgdoc-cn_start sig_en=5ef6b9b47750c7fe9738706db1bff8e2 sig_cn_org=None source=14.1 
  <para>
   Previous releases failed to preserve a lock which is upgraded by a later
   savepoint.  For example, this code:
<programlisting>
BEGIN;
SELECT * FROM mytable WHERE key = 1 FOR UPDATE;
SAVEPOINT s;
UPDATE mytable SET ... WHERE key = 1;
ROLLBACK TO s;
</programlisting>
   would fail to preserve the <literal>FOR UPDATE</literal> lock after the
   <command>ROLLBACK TO</command>.  This has been fixed in release 9.3.
  </para>
________________________________________________________-->
  <para>
   早前的发行无法维持一个被之后的保存点升级的锁。例如，这段代码：
<programlisting>
BEGIN;
SELECT * FROM mytable WHERE key = 1 FOR UPDATE;
SAVEPOINT s;
UPDATE mytable SET ... WHERE key = 1;
ROLLBACK TO s;
</programlisting>
   在<command>ROLLBACK TO</command>之后将无法维持
   <literal>FOR UPDATE</literal>锁。在 9.3 中已经修复这个问题。
  </para>
<!-- pgdoc-cn_end sig_en=5ef6b9b47750c7fe9738706db1bff8e2 -->

  <caution>
<!-- pgdoc-cn_start sig_en=fb58ea6b654f177290112a7f7e2d8193 sig_cn_org=None source=14.1 
   <para>
    It is possible for a <command>SELECT</command> command running at the <literal>READ
    COMMITTED</literal> transaction isolation level and using <literal>ORDER
    BY</literal> and a locking clause to return rows out of
    order.  This is because <literal>ORDER BY</literal> is applied first.
    The command sorts the result, but might then block trying to obtain a lock
    on one or more of the rows.  Once the <literal>SELECT</literal> unblocks, some
    of the ordering column values might have been modified, leading to those
    rows appearing to be out of order (though they are in order in terms
    of the original column values).  This can be worked around at need by
    placing the <literal>FOR UPDATE/SHARE</literal> clause in a sub-query,
    for example
<programlisting>
SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss ORDER BY column1;
</programlisting>
    Note that this will result in locking all rows of <structname>mytable</structname>,
    whereas <literal>FOR UPDATE</literal> at the top level would lock only the
    actually returned rows.  This can make for a significant performance
    difference, particularly if the <literal>ORDER BY</literal> is combined with
    <literal>LIMIT</literal> or other restrictions.  So this technique is recommended
    only if concurrent updates of the ordering columns are expected and a
    strictly sorted result is required.
   </para>
________________________________________________________-->
   <para>
    一个运行在<literal>READ
    COMMITTED</literal>事务隔离级别并且使用<literal>ORDER
    BY</literal>和锁定子句的<command>SELECT</command>命令有可能返回无序的行。
    这是因为<literal>ORDER BY</literal>会被首先应用。该命令对结果排序，但是可能
    接着在尝试获得一个或者多个行上的锁时阻塞。一旦<literal>SELECT</literal>解除
    阻塞，某些排序列值可能已经被修改，从而导致那些行变成无序的（尽管它们根
    据原始列值是有序的）。根据需要，可以通过在子查询中放置
    <literal>FOR UPDATE/SHARE</literal>来解决之一问题，例如
<programlisting>
SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss ORDER BY column1;
</programlisting>
    注意这将导致锁定<structname>mytable</structname>的所有行，而顶层的
    <literal>FOR UPDATE</literal>只会锁定实际被返回的行。这可能会导致显著的
    性能差异，特别是把<literal>ORDER BY</literal>与<literal>LIMIT</literal>或者其他
    限制组合使用时。因此只有在并发更新排序列并且要求严格的排序结果时才推
    荐使用这种技术。
   </para>
<!-- pgdoc-cn_end sig_en=fb58ea6b654f177290112a7f7e2d8193 -->

<!-- pgdoc-cn_start sig_en=4de002fb5dd7a0fc8d755cf85fff2fee sig_cn_org=388664eeca5727e9f2c486ac6054e42f source=15.7 
   <para>
    At the <literal>REPEATABLE READ</literal> or <literal>SERIALIZABLE</literal>
    transaction isolation level this would cause a serialization failure (with
    an <literal>SQLSTATE</literal> of <literal>'40001'</literal>), so there is
    no possibility of receiving rows out of order under these isolation levels.
   </para>
________________________________________________________-->
   <para>
    在<literal>REPEATABLE READ</literal>或<literal>SERIALIZABLE</literal>事务隔离级别下，
    这将导致序列化失败（带有<literal>SQLSTATE</literal>为<literal>'40001'</literal>），
    因此在这些隔离级别下不可能接收到无序的行。
</para>
<!-- pgdoc-cn_end sig_en=4de002fb5dd7a0fc8d755cf85fff2fee -->
  </caution>
  </refsect2>

  <refsect2 id="sql-table">
<!-- pgdoc-cn_start sig_en=1b96868a50076bf900777ea40309ae2f sig_cn_org=None source=14.1 
   <title><literal>TABLE</literal> Command</title>
________________________________________________________-->
   <title><literal>TABLE</literal> 命令</title>
<!-- pgdoc-cn_end sig_en=1b96868a50076bf900777ea40309ae2f -->

<!-- pgdoc-cn_start sig_en=1ef52079fbc590d2af2935ef856df8b5 sig_cn_org=None source=14.1 
   <para>
    The command
<programlisting>
TABLE <replaceable class="parameter">name</replaceable>
</programlisting>
    is equivalent to
<programlisting>
SELECT * FROM <replaceable class="parameter">name</replaceable>
</programlisting>
    It can be used as a top-level command or as a space-saving syntax
    variant in parts of complex queries. Only the <literal>WITH</literal>,
    <literal>UNION</literal>, <literal>INTERSECT</literal>, <literal>EXCEPT</literal>,
    <literal>ORDER BY</literal>, <literal>LIMIT</literal>, <literal>OFFSET</literal>,
    <literal>FETCH</literal> and <literal>FOR</literal> locking clauses can be used
    with <command>TABLE</command>; the <literal>WHERE</literal> clause and any form of
    aggregation cannot
    be used.
   </para>
________________________________________________________-->
   <para>
    命令
<programlisting>
TABLE <replaceable class="parameter">name</replaceable>
</programlisting>
    等价于
<programlisting>
SELECT * FROM <replaceable class="parameter">name</replaceable>
</programlisting>
    它可以被用作一个顶层命令，或者用在复杂查询中以节省空间。只有
    <literal>WITH</literal>、
    <literal>UNION</literal>、<literal>INTERSECT</literal>、<literal>EXCEPT</literal>、
    <literal>ORDER BY</literal>、<literal>LIMIT</literal>、<literal>OFFSET</literal>、
    <literal>FETCH</literal>以及<literal>FOR</literal>锁定子句可以用于
    <command>TABLE</command>。不能使用<literal>WHERE</literal>子句和任何形式
    的聚集。
   </para>
<!-- pgdoc-cn_end sig_en=1ef52079fbc590d2af2935ef856df8b5 -->
  </refsect2>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
  <title>Examples</title>
________________________________________________________-->
  <title>示例</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=eebe5a48beaffa3d49782206a4b11f36 sig_cn_org=872d918dce6ce429adc18cc05655fea6 source=15.7 
  <para>
   To join the table <literal>films</literal> with the table
   <literal>distributors</literal>:

<programlisting>
SELECT f.title, f.did, d.name, f.date_prod, f.kind
    FROM distributors d JOIN films f USING (did);

       title       | did |     name     | date_prod  |   kind
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;
 The Third Man     | 101 | British Lion | 1949-12-23 | Drama
 The African Queen | 101 | British Lion | 1951-08-11 | Romantic
 ...
</programlisting>
  </para>
________________________________________________________-->
  <para>
   要将表<literal>films</literal>与表<literal>distributors</literal>连接：

<programlisting>
SELECT f.title, f.did, d.name, f.date_prod, f.kind
    FROM distributors d JOIN films f USING (did);

       title       | did |     name     | date_prod  |   kind
-------------------+-----+--------------+------------+----------
 The Third Man     | 101 | British Lion | 1949-12-23 | Drama
 The African Queen | 101 | British Lion | 1951-08-11 | Romantic
 ...
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=eebe5a48beaffa3d49782206a4b11f36 -->

<!-- pgdoc-cn_start sig_en=d54bc43c322d9a65d0205056feb95466 sig_cn_org=None source=14.1 
  <para>
   To sum the column <literal>len</literal> of all films and group
   the results by <literal>kind</literal>:

<programlisting>
SELECT kind, sum(len) AS total FROM films GROUP BY kind;

   kind   | total
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
 Action   | 07:34
 Comedy   | 02:58
 Drama    | 14:28
 Musical  | 06:42
 Romantic | 04:38
</programlisting>
  </para>
________________________________________________________-->
  <para>
   要对所有电影的<literal>len</literal>列求和并且用
   <literal>kind</literal>对结果分组：

<programlisting>
SELECT kind, sum(len) AS total FROM films GROUP BY kind;

   kind   | total
----------+-------
 Action   | 07:34
 Comedy   | 02:58
 Drama    | 14:28
 Musical  | 06:42
 Romantic | 04:38
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=d54bc43c322d9a65d0205056feb95466 -->

<!-- pgdoc-cn_start sig_en=146cdcd3416358e2407d22f1d19beaf0 sig_cn_org=None source=14.1 
  <para>
   To sum the column <literal>len</literal> of all films, group
   the results by <literal>kind</literal> and show those group totals
   that are less than 5 hours:

<programlisting>
SELECT kind, sum(len) AS total
    FROM films
    GROUP BY kind
    HAVING sum(len) &lt; interval '5 hours';

   kind   | total
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
 Comedy   | 02:58
 Romantic | 04:38
</programlisting>
  </para>
________________________________________________________-->
  <para>
   要对所有电影的<literal>len</literal>列求和、对结果按照
   <literal>kind</literal>分组并且显示总长小于 5 小时的分组：

<programlisting>
SELECT kind, sum(len) AS total
    FROM films
    GROUP BY kind
    HAVING sum(len) &lt; interval '5 hours';

   kind   | total
----------+-------
 Comedy   | 02:58
 Romantic | 04:38
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=146cdcd3416358e2407d22f1d19beaf0 -->

<!-- pgdoc-cn_start sig_en=d472b381e7e313cce595531f09308291 sig_cn_org=None source=14.1 
  <para>
   The following two examples are identical ways of sorting the individual
   results according to the contents of the second column
   (<literal>name</literal>):

<programlisting>
SELECT * FROM distributors ORDER BY name;
SELECT * FROM distributors ORDER BY 2;

 did |       name
-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 109 | 20th Century Fox
 110 | Bavaria Atelier
 101 | British Lion
 107 | Columbia
 102 | Jean Luc Godard
 113 | Luso films
 104 | Mosfilm
 103 | Paramount
 106 | Toho
 105 | United Artists
 111 | Walt Disney
 112 | Warner Bros.
 108 | Westward
</programlisting>
  </para>
________________________________________________________-->
  <para>
   下面两个例子都是根据第二列（<literal>name</literal>）的内容来排序结果：

<programlisting>
SELECT * FROM distributors ORDER BY name;
SELECT * FROM distributors ORDER BY 2;

 did |       name
-----+------------------
 109 | 20th Century Fox
 110 | Bavaria Atelier
 101 | British Lion
 107 | Columbia
 102 | Jean Luc Godard
 113 | Luso films
 104 | Mosfilm
 103 | Paramount
 106 | Toho
 105 | United Artists
 111 | Walt Disney
 112 | Warner Bros.
 108 | Westward
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=d472b381e7e313cce595531f09308291 -->

<!-- pgdoc-cn_start sig_en=96efd36626e1c77099a30663cde86b14 sig_cn_org=None source=14.1 
  <para>
   The next example shows how to obtain the union of the tables
   <literal>distributors</literal> and
   <literal>actors</literal>, restricting the results to those that begin
   with the letter W in each table.  Only distinct rows are wanted, so the
   key word <literal>ALL</literal> is omitted.

<programlisting>
distributors:               actors:
 did |     name              id |     name
-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;        -&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 108 | Westward               1 | Woody Allen
 111 | Walt Disney            2 | Warren Beatty
 112 | Warner Bros.           3 | Walter Matthau
 ...                         ...

SELECT distributors.name
    FROM distributors
    WHERE distributors.name LIKE 'W%'
UNION
SELECT actors.name
    FROM actors
    WHERE actors.name LIKE 'W%';

      name
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Walt Disney
 Walter Matthau
 Warner Bros.
 Warren Beatty
 Westward
 Woody Allen
</programlisting>
  </para>
________________________________________________________-->
  <para>
   接下来的例子展示了如何得到表<literal>distributors</literal>和
   <literal>actors</literal>的并集，把结果限制为那些在每个表中以
   字母 W 开始的行。只想要可区分的行，因此省略了关键词
   <literal>ALL</literal>。

<programlisting>
distributors:               actors:
 did |     name              id |     name
-----+--------------        ----+----------------
 108 | Westward               1 | Woody Allen
 111 | Walt Disney            2 | Warren Beatty
 112 | Warner Bros.           3 | Walter Matthau
 ...                         ...

SELECT distributors.name
    FROM distributors
    WHERE distributors.name LIKE 'W%'
UNION
SELECT actors.name
    FROM actors
    WHERE actors.name LIKE 'W%';

      name
----------------
 Walt Disney
 Walter Matthau
 Warner Bros.
 Warren Beatty
 Westward
 Woody Allen
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=96efd36626e1c77099a30663cde86b14 -->

<!-- pgdoc-cn_start sig_en=37754c309e9bc3d51125594726e17f05 sig_cn_org=None source=14.1 
  <para>
   This example shows how to use a function in the <literal>FROM</literal>
   clause, both with and without a column definition list:

<programlisting>
CREATE FUNCTION distributors(int) RETURNS SETOF distributors AS $$
    SELECT * FROM distributors WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributors(111);
 did |    name
-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 111 | Walt Disney

CREATE FUNCTION distributors_2(int) RETURNS SETOF record AS $$
    SELECT * FROM distributors WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributors_2(111) AS (f1 int, f2 text);
 f1  |     f2
-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 111 | Walt Disney
</programlisting>
  </para>
________________________________________________________-->
  <para>
   这个例子展示了如何在<literal>FROM</literal>子句中使用函数，
   分别使用和不使用列定义列表：

<programlisting>
CREATE FUNCTION distributors(int) RETURNS SETOF distributors AS $$
    SELECT * FROM distributors WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributors(111);
 did |    name
-----+-------------
 111 | Walt Disney

CREATE FUNCTION distributors_2(int) RETURNS SETOF record AS $$
    SELECT * FROM distributors WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributors_2(111) AS (f1 int, f2 text);
 f1  |     f2
-----+-------------
 111 | Walt Disney
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=37754c309e9bc3d51125594726e17f05 -->

<!-- pgdoc-cn_start sig_en=c544d8231e7574780c5db4c852752fad sig_cn_org=None source=14.1 
  <para>
   Here is an example of a function with an ordinality column added:

<programlisting>
SELECT * FROM unnest(ARRAY['a','b','c','d','e','f']) WITH ORDINALITY;
 unnest | ordinality
-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;
 a      |        1
 b      |        2
 c      |        3
 d      |        4
 e      |        5
 f      |        6
(6 rows)
</programlisting>
  </para>
________________________________________________________-->
  <para>
   这里是带有增加的序数列的函数的例子：

<programlisting>
SELECT * FROM unnest(ARRAY['a','b','c','d','e','f']) WITH ORDINALITY;
 unnest | ordinality
--------+----------
 a      |        1
 b      |        2
 c      |        3
 d      |        4
 e      |        5
 f      |        6
(6 rows)
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=c544d8231e7574780c5db4c852752fad -->

<!-- pgdoc-cn_start sig_en=5827f548fc1960bd6cf7e1eaa44167cc sig_cn_org=615b45681471942615917f3d0ae5415a source=15.7 
  <para>
   This example shows how to use a simple <literal>WITH</literal> clause:

<programlisting>
WITH t AS (
    SELECT random() as x FROM generate_series(1, 3)
  )
SELECT * FROM t
UNION ALL
SELECT * FROM t;
         x
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
  0.534150459803641
  0.520092216785997
 0.0735620250925422
  0.534150459803641
  0.520092216785997
 0.0735620250925422
</programlisting>

   Notice that the <literal>WITH</literal> query was evaluated only once,
   so that we got two sets of the same three random values.
  </para>
________________________________________________________-->
  <para>
   这个示例展示了如何使用简单的<literal>WITH</literal>子句：

<programlisting>
WITH t AS (
    SELECT random() as x FROM generate_series(1, 3)
  )
SELECT * FROM t
UNION ALL
SELECT * FROM t;
         x
--------------------
  0.534150459803641
  0.520092216785997
 0.0735620250925422
  0.534150459803641
  0.520092216785997
 0.0735620250925422
</programlisting>

   注意<literal>WITH</literal>查询只被评估一次，所以我们得到了两组相同的三个随机值。
  </para>
<!-- pgdoc-cn_end sig_en=5827f548fc1960bd6cf7e1eaa44167cc -->

<!-- pgdoc-cn_start sig_en=bd1a45ddc2e72e1c3bdc7c8767065a84 sig_cn_org=None source=14.1 
  <para>
   This example uses <literal>WITH RECURSIVE</literal> to find all
   subordinates (direct or indirect) of the employee Mary, and their
   level of indirectness, from a table that shows only direct
   subordinates:

<programlisting>
WITH RECURSIVE employee_recursive(distance, employee_name, manager_name) AS (
    SELECT 1, employee_name, manager_name
    FROM employee
    WHERE manager_name = 'Mary'
  UNION ALL
    SELECT er.distance + 1, e.employee_name, e.manager_name
    FROM employee_recursive er, employee e
    WHERE er.employee_name = e.manager_name
  )
SELECT distance, employee_name FROM employee_recursive;
</programlisting>

   Notice the typical form of recursive queries:
   an initial condition, followed by <literal>UNION</literal>,
   followed by the recursive part of the query. Be sure that the
   recursive part of the query will eventually return no tuples, or
   else the query will loop indefinitely.  (See <xref linkend="queries-with"/>
   for more examples.)
  </para>
________________________________________________________-->
  <para>
   这个例子使用<literal>WITH RECURSIVE</literal>从一个只显示
   直接下属的表中寻找雇员 Mary
   的所有下属（直接的或者间接的）以及他们的间接层数：

<programlisting>
WITH RECURSIVE employee_recursive(distance, employee_name, manager_name) AS (
    SELECT 1, employee_name, manager_name
    FROM employee
    WHERE manager_name = 'Mary'
  UNION ALL
    SELECT er.distance + 1, e.employee_name, e.manager_name
    FROM employee_recursive er, employee e
    WHERE er.employee_name = e.manager_name
  )
SELECT distance, employee_name FROM employee_recursive;
</programlisting>

   注意这种递归查询的典型形式：一个初始条件，后面跟着
   <literal>UNION</literal>，然后是查询的递归部分。要确保
   查询的递归部分最终将不返回任何行，否则该查询将无限循环（
   更多例子见<xref linkend="queries-with"/>）。
  </para>
<!-- pgdoc-cn_end sig_en=bd1a45ddc2e72e1c3bdc7c8767065a84 -->

<!-- pgdoc-cn_start sig_en=3ac21809366964dd1328570990e57181 sig_cn_org=None source=14.1 
  <para>
   This example uses <literal>LATERAL</literal> to apply a set-returning function
   <function>get_product_names()</function> for each row of the
   <structname>manufacturers</structname> table:

<programlisting>
SELECT m.name AS mname, pname
FROM manufacturers m, LATERAL get_product_names(m.id) pname;
</programlisting>

    Manufacturers not currently having any products would not appear in the
    result, since it is an inner join.  If we wished to include the names of
    such manufacturers in the result, we could do:

<programlisting>
SELECT m.name AS mname, pname
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true;
</programlisting></para>
________________________________________________________-->
  <para>
   这个例子使用<literal>LATERAL</literal>为<structname>manufacturers</structname>
   表的每一行应用一个集合返回函数<function>get_product_names()</function>：

<programlisting>
SELECT m.name AS mname, pname
FROM manufacturers m, LATERAL get_product_names(m.id) pname;
</programlisting>

    当前没有任何产品的制造商不会出现在结果中，因为这是一个内连接。
    如果我们希望把这类制造商的名称包括在结果中，我们可以：

<programlisting>
SELECT m.name AS mname, pname
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true;
</programlisting></para>
<!-- pgdoc-cn_end sig_en=3ac21809366964dd1328570990e57181 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
  <title>Compatibility</title>
________________________________________________________-->
  <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=47899d0103b69468e231f7cc3da6a172 sig_cn_org=None source=14.1 
  <para>
   Of course, the <command>SELECT</command> statement is compatible
   with the SQL standard.  But there are some extensions and some
   missing features.
  </para>
________________________________________________________-->
  <para>
   当然，<command>SELECT</command>语句是兼容 SQL 标准的。
   但是也有一些扩展和缺失的特性。
  </para>
<!-- pgdoc-cn_end sig_en=47899d0103b69468e231f7cc3da6a172 -->

  <refsect2>
<!-- pgdoc-cn_start sig_en=4391ba8fca70d91899ffc5baedc3024a sig_cn_org=None source=14.1 
   <title>Omitted <literal>FROM</literal> Clauses</title>
________________________________________________________-->
   <title>省略的<literal>FROM</literal>子句</title>
<!-- pgdoc-cn_end sig_en=4391ba8fca70d91899ffc5baedc3024a -->

<!-- pgdoc-cn_start sig_en=b70e8f3af8e5eff3f8c2d9e4cde748d1 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> allows one to omit the
    <literal>FROM</literal> clause.  It has a straightforward use to
    compute the results of simple expressions:
<programlisting>
SELECT 2+2;

 ?column?
-&minus;-&minus;-&minus;-&minus;-&minus;
        4
</programlisting>
    Some other <acronym>SQL</acronym> databases cannot do this except
    by introducing a dummy one-row table from which to do the
    <command>SELECT</command>.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>允许我们省略
    <literal>FROM</literal>子句。一种简单的使用是计算简单表达式
    的结果：
<programlisting>
SELECT 2+2;

 ?column?
----------
        4
</programlisting>
    某些其他<acronym>SQL</acronym>数据库需要引入一个假的
    单行表放在该<command>SELECT</command>的
    <literal>FROM</literal>子句中才能做到这一点。
   </para>
<!-- pgdoc-cn_end sig_en=b70e8f3af8e5eff3f8c2d9e4cde748d1 -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=eea9b673ba5e464bb60a120e222d0ed2 sig_cn_org=None source=14.1 
   <title>Empty <literal>SELECT</literal> Lists</title>
________________________________________________________-->
   <title>空<literal>SELECT</literal>列表</title>
<!-- pgdoc-cn_end sig_en=eea9b673ba5e464bb60a120e222d0ed2 -->

<!-- pgdoc-cn_start sig_en=05d98ef8feb33b3d02c71f1da5f001bb sig_cn_org=None source=14.1 
   <para>
    The list of output expressions after <literal>SELECT</literal> can be
    empty, producing a zero-column result table.
    This is not valid syntax according to the SQL standard.
    <productname>PostgreSQL</productname> allows it to be consistent with
    allowing zero-column tables.
    However, an empty list is not allowed when <literal>DISTINCT</literal> is used.
   </para>
________________________________________________________-->
   <para>
    <literal>SELECT</literal>之后的输出表达式列表可以为空，
    这会产生一个零列的结果表。对 SQL 标准来说这不是合法的
    语法。<productname>PostgreSQL</productname>允许
    它是为了与允许零列表保持一致。不过在使用
    <literal>DISTINCT</literal>时不允许空列表。
   </para>
<!-- pgdoc-cn_end sig_en=05d98ef8feb33b3d02c71f1da5f001bb -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=6104943057e0859f3a2a03fe7649e975 sig_cn_org=None source=14.1 
   <title>Omitting the <literal>AS</literal> Key Word</title>
________________________________________________________-->
   <title>省略<literal>AS</literal>关键词</title>
<!-- pgdoc-cn_end sig_en=6104943057e0859f3a2a03fe7649e975 -->

<!-- pgdoc-cn_start sig_en=826d1d3a1a0d82328a8c85faaa628d2b sig_cn_org=None source=14.1 
   <para>
    In the SQL standard, the optional key word <literal>AS</literal> can be
    omitted before an output column name whenever the new column name
    is a valid column name (that is, not the same as any reserved
    keyword).  <productname>PostgreSQL</productname> is slightly more
    restrictive: <literal>AS</literal> is required if the new column name
    matches any keyword at all, reserved or not.  Recommended practice is
    to use <literal>AS</literal> or double-quote output column names, to prevent
    any possible conflict against future keyword additions.
   </para>
________________________________________________________-->
   <para>
    在 SQL 标准中，只要新列名是一个合法的列名（就是说与任何保留关键词不同），
    就可以省略输出列名之前的可选关键词<literal>AS</literal>。
    <productname>PostgreSQL</productname>要稍微严格些：只要新列名匹配
    任何关键词（保留或者非保留）就需要<literal>AS</literal>。推荐的习惯是使用
    <literal>AS</literal>或者带双引号的输出列名来防止与未来增加的关键词可能的冲突。
   </para>
<!-- pgdoc-cn_end sig_en=826d1d3a1a0d82328a8c85faaa628d2b -->

<!-- pgdoc-cn_start sig_en=c96b7674744581fe86d2405719107952 sig_cn_org=None source=14.1 
   <para>
    In <literal>FROM</literal> items, both the standard and
    <productname>PostgreSQL</productname> allow <literal>AS</literal> to
    be omitted before an alias that is an unreserved keyword.  But
    this is impractical for output column names, because of syntactic
    ambiguities.
   </para>
________________________________________________________-->
   <para>
    在<literal>FROM</literal>项中，标准和
    <productname>PostgreSQL</productname>都允许省略非保留
    关键词别名之前的<literal>AS</literal>。但是由于语法的歧义，这无法
    用于输出列名。
   </para>
<!-- pgdoc-cn_end sig_en=c96b7674744581fe86d2405719107952 -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=4396691fcf7c0416d7b5d974edbf366a sig_cn_org=None source=14.1 
   <title><literal>ONLY</literal> and Inheritance</title>
________________________________________________________-->
   <title><literal>ONLY</literal>和继承</title>
<!-- pgdoc-cn_end sig_en=4396691fcf7c0416d7b5d974edbf366a -->

<!-- pgdoc-cn_start sig_en=64c154a9ff158f8d7a814fc4b0bfd6c0 sig_cn_org=None source=14.1 
   <para>
    The SQL standard requires parentheses around the table name when
    writing <literal>ONLY</literal>, for example <literal>SELECT * FROM ONLY
    (tab1), ONLY (tab2) WHERE ...</literal>.  <productname>PostgreSQL</productname>
    considers these parentheses to be optional.
   </para>
________________________________________________________-->
   <para>
    在书写<literal>ONLY</literal>时，SQL 标准要求在表名周围加上圆括号，例如
    <literal>SELECT * FROM ONLY
    (tab1), ONLY (tab2) WHERE ...</literal>。<productname>PostgreSQL</productname>
    认为这些圆括号是可选的。
   </para>
<!-- pgdoc-cn_end sig_en=64c154a9ff158f8d7a814fc4b0bfd6c0 -->

<!-- pgdoc-cn_start sig_en=6f7062d596c2867bc65962e9322ae609 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> allows a trailing <literal>*</literal> to be written to
    explicitly specify the non-<literal>ONLY</literal> behavior of including
    child tables.  The standard does not allow this.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>允许写一个拖尾的<literal>*</literal>来
    显式指定包括子表的非-<literal>ONLY</literal>行为。而标准则不允许
    这样。
   </para>
<!-- pgdoc-cn_end sig_en=6f7062d596c2867bc65962e9322ae609 -->

<!-- pgdoc-cn_start sig_en=6752d0bf589015b1ae441bf42ec2335d sig_cn_org=None source=14.1 
   <para>
    (These points apply equally to all SQL commands supporting the
    <literal>ONLY</literal> option.)
   </para>
________________________________________________________-->
   <para>
    （这些点同等地适用于所有支持<literal>ONLY</literal>选项的 SQL 命令）。
   </para>
<!-- pgdoc-cn_end sig_en=6752d0bf589015b1ae441bf42ec2335d -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=6ec81c68d116052fc21b550107c1eda9 sig_cn_org=None source=14.1 
   <title><literal>TABLESAMPLE</literal> Clause Restrictions</title>
________________________________________________________-->
   <title><literal>TABLESAMPLE</literal>子句限制</title>
<!-- pgdoc-cn_end sig_en=6ec81c68d116052fc21b550107c1eda9 -->

<!-- pgdoc-cn_start sig_en=efd2b763e4e0e4e0ce3a2bf8aaf82def sig_cn_org=None source=14.1 
   <para>
    The <literal>TABLESAMPLE</literal> clause is currently accepted only on
    regular tables and materialized views.  According to the SQL standard
    it should be possible to apply it to any <literal>FROM</literal> item.
   </para>
________________________________________________________-->
   <para>
    当前只在常规表和物化视图上接受<literal>TABLESAMPLE</literal>子句。
    根据 SQL 标准，应该可以把它应用于任何<literal>FROM</literal>项。
   </para>
<!-- pgdoc-cn_end sig_en=efd2b763e4e0e4e0ce3a2bf8aaf82def -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=53f16f1f052bc86a2971c8c3b75b0cdf sig_cn_org=None source=14.1 
   <title>Function Calls in <literal>FROM</literal></title>
________________________________________________________-->
   <title><literal>FROM</literal>中的函数调用</title>
<!-- pgdoc-cn_end sig_en=53f16f1f052bc86a2971c8c3b75b0cdf -->

<!-- pgdoc-cn_start sig_en=1e5d2cbf8b7b4aec702f30a3a4715f77 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> allows a function call to be
    written directly as a member of the <literal>FROM</literal> list.  In the SQL
    standard it would be necessary to wrap such a function call in a
    sub-<command>SELECT</command>; that is, the syntax
    <literal>FROM <replaceable>func</replaceable>(...) <replaceable>alias</replaceable></literal>
    is approximately equivalent to
    <literal>FROM LATERAL (SELECT <replaceable>func</replaceable>(...)) <replaceable>alias</replaceable></literal>.
    Note that <literal>LATERAL</literal> is considered to be implicit; this is
    because the standard requires <literal>LATERAL</literal> semantics for an
    <literal>UNNEST()</literal> item in <literal>FROM</literal>.
    <productname>PostgreSQL</productname> treats <literal>UNNEST()</literal> the
    same as other set-returning functions.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>允许一个函数调用被直接写作
    <literal>FROM</literal>列表的一个成员。在 SQL 标准中，有必要把这样一个函数
    调用包裹在一个子-<command>SELECT</command>中。也就是说，语法
    <literal>FROM <replaceable>func</replaceable>(...) <replaceable>alias</replaceable></literal>
    近似等价于
    <literal>FROM LATERAL (SELECT <replaceable>func</replaceable>(...)) <replaceable>alias</replaceable></literal>。
    注意该<literal>LATERAL</literal>被认为是隐式的，这是因为标准对于
    <literal>FROM</literal>中的一个<literal>UNNEST()</literal>项要求
    <literal>LATERAL</literal>语义。<productname>PostgreSQL</productname>会把
    <literal>UNNEST()</literal>和其他集合返回函数同样对待。
   </para>
<!-- pgdoc-cn_end sig_en=1e5d2cbf8b7b4aec702f30a3a4715f77 -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=4b47ed08aae4d5c847698495b87d8768 sig_cn_org=None source=14.1 
   <title>Namespace Available to <literal>GROUP BY</literal> and <literal>ORDER BY</literal></title>
________________________________________________________-->
   <title><literal>GROUP BY</literal>和<literal>ORDER BY</literal>可用的名字空间</title>
<!-- pgdoc-cn_end sig_en=4b47ed08aae4d5c847698495b87d8768 -->

<!-- pgdoc-cn_start sig_en=fbc12e77009ac015f09ce81d209c5350 sig_cn_org=None source=14.1 
   <para>
    In the SQL-92 standard, an <literal>ORDER BY</literal> clause can
    only use output column names or numbers, while a <literal>GROUP
    BY</literal> clause can only use expressions based on input column
    names.  <productname>PostgreSQL</productname> extends each of
    these clauses to allow the other choice as well (but it uses the
    standard's interpretation if there is ambiguity).
    <productname>PostgreSQL</productname> also allows both clauses to
    specify arbitrary expressions.  Note that names appearing in an
    expression will always be taken as input-column names, not as
    output-column names.
   </para>
________________________________________________________-->
   <para>
    在 SQL-92 标准中，一个<literal>ORDER BY</literal>子句只能使用输出
    列名或者序号，而一个<literal>GROUP BY</literal>子句只能使用基于输
    入列名的表达式。<productname>PostgreSQL</productname>扩展了
    这两种子句以允许它们使用其他的选择（但如果有歧义时还是使用标准的
    解释）。<productname>PostgreSQL</productname>也允许两种子句
    指定任意表达式。注意出现在一个表达式中的名称将总是被当做输入列名而
    不是输出列名。
   </para>
<!-- pgdoc-cn_end sig_en=fbc12e77009ac015f09ce81d209c5350 -->

<!-- pgdoc-cn_start sig_en=bb04fd3b10f3344c01aac85b91780106 sig_cn_org=None source=14.1 
   <para>
    SQL:1999 and later use a slightly different definition which is not
    entirely upward compatible with SQL-92.
    In most cases, however, <productname>PostgreSQL</productname>
    will interpret an <literal>ORDER BY</literal> or <literal>GROUP
    BY</literal> expression the same way SQL:1999 does.
   </para>
________________________________________________________-->
   <para>
    SQL:1999 及其后的标准使用了一种略微不同的定义，它并不完全向后兼容
    SQL-92。不过，在大部分的情况下，
    <productname>PostgreSQL</productname>会以与 SQL:1999 相同的
    方式解释<literal>ORDER BY</literal>或<literal>GROUP
    BY</literal>表达式。
   </para>
<!-- pgdoc-cn_end sig_en=bb04fd3b10f3344c01aac85b91780106 -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=8577035562647587b6eb3b8a2e43d271 sig_cn_org=None source=14.1 
   <title>Functional Dependencies</title>
________________________________________________________-->
   <title>函数依赖</title>
<!-- pgdoc-cn_end sig_en=8577035562647587b6eb3b8a2e43d271 -->

<!-- pgdoc-cn_start sig_en=1dc06f4aa772009c4bd75c9b79d02a40 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> recognizes functional dependency
    (allowing columns to be omitted from <literal>GROUP BY</literal>) only when
    a table's primary key is included in the <literal>GROUP BY</literal> list.
    The SQL standard specifies additional conditions that should be
    recognized.
   </para>
________________________________________________________-->
   <para>
    只有当一个表的主键被包括在<literal>GROUP BY</literal>列表中时，
    <productname>PostgreSQL</productname>才识别函数依赖（允许
    从<literal>GROUP BY</literal>中省略列）。SQL 标准指定了应该要识别
    的额外情况。
   </para>
<!-- pgdoc-cn_end sig_en=1dc06f4aa772009c4bd75c9b79d02a40 -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=cb751aecf7fda11ec0c21f009822faf8 sig_cn_org=None source=14.1 
   <title><literal>LIMIT</literal> and <literal>OFFSET</literal></title>
________________________________________________________-->
   <title><literal>LIMIT</literal>和<literal>OFFSET</literal></title>
<!-- pgdoc-cn_end sig_en=cb751aecf7fda11ec0c21f009822faf8 -->

<!-- pgdoc-cn_start sig_en=9ae5792f6abd1e3f6a40b29997ff3a30 sig_cn_org=None source=14.1 
   <para>
    The clauses <literal>LIMIT</literal> and <literal>OFFSET</literal>
    are <productname>PostgreSQL</productname>-specific syntax, also
    used by <productname>MySQL</productname>.  The SQL:2008 standard
    has introduced the clauses <literal>OFFSET ... FETCH {FIRST|NEXT}
    ...</literal> for the same functionality, as shown above
    in <xref linkend="sql-limit"/>.  This
    syntax is also used by <productname>IBM DB2</productname>.
    (Applications written for <productname>Oracle</productname>
    frequently use a workaround involving the automatically
    generated <literal>rownum</literal> column, which is not available in
    PostgreSQL, to implement the effects of these clauses.)
   </para>
________________________________________________________-->
   <para>
    <literal>LIMIT</literal>和<literal>OFFSET</literal>子句是
    <productname>PostgreSQL</productname>-特有的语法，在
    <productname>MySQL</productname>也被使用。SQL:2008 标准已经
    引入了具有相同功能的子句<literal>OFFSET ... FETCH {FIRST|NEXT}
    ...</literal>（如上文
    <xref linkend="sql-limit"/>中所示）。这种语法
    也被<productname>IBM DB2</productname>使用（
    <productname>Oracle</productname>编写的应用常常使用自动生成的
    <literal>rownum</literal>列来实现这些子句的效果，这在 PostgreSQL 
    中是没有的）。
   </para>
<!-- pgdoc-cn_end sig_en=9ae5792f6abd1e3f6a40b29997ff3a30 -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=6375bae93e3942d3163ecab0b82576f3 sig_cn_org=None source=14.1 
   <title><literal>FOR NO KEY UPDATE</literal>, <literal>FOR UPDATE</literal>, <literal>FOR SHARE</literal>, <literal>FOR KEY SHARE</literal></title>
________________________________________________________-->
   <title><literal>FOR NO KEY UPDATE</literal>、<literal>FOR UPDATE</literal>、<literal>FOR SHARE</literal>、<literal>FOR KEY SHARE</literal></title>
<!-- pgdoc-cn_end sig_en=6375bae93e3942d3163ecab0b82576f3 -->

<!-- pgdoc-cn_start sig_en=3a6e35417ed32d046ca72cd070ec855b sig_cn_org=None source=14.1 
   <para>
    Although <literal>FOR UPDATE</literal> appears in the SQL standard, the
    standard allows it only as an option of <command>DECLARE CURSOR</command>.
    <productname>PostgreSQL</productname> allows it in any <command>SELECT</command>
    query as well as in sub-<command>SELECT</command>s, but this is an extension.
    The <literal>FOR NO KEY UPDATE</literal>, <literal>FOR SHARE</literal> and
    <literal>FOR KEY SHARE</literal> variants, as well as the <literal>NOWAIT</literal>
    and <literal>SKIP LOCKED</literal> options, do not appear in the
    standard.
   </para>
________________________________________________________-->
   <para>
    尽管 SQL 标准中出现了<literal>FOR UPDATE</literal>，但标准只允许它作为
    <command>DECLARE CURSOR</command>的一个选项。
    <productname>PostgreSQL</productname>允许它出现在任何
    <command>SELECT</command>查询以及子-<command>SELECT</command>中，但这是
    一种扩展。<literal>FOR NO KEY UPDATE</literal>、<literal>FOR SHARE</literal>
    以及<literal>FOR KEY SHARE</literal>变体以及<literal>NOWAIT</literal>
    和<literal>SKIP LOCKED</literal>选项没有在标准中出现。
   </para>
<!-- pgdoc-cn_end sig_en=3a6e35417ed32d046ca72cd070ec855b -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=b0224b5ef471c6841582275bc16c0eb8 sig_cn_org=None source=14.1 
   <title>Data-Modifying Statements in <literal>WITH</literal></title>
________________________________________________________-->
   <title><literal>WITH</literal>中的数据修改语句</title>
<!-- pgdoc-cn_end sig_en=b0224b5ef471c6841582275bc16c0eb8 -->

<!-- pgdoc-cn_start sig_en=faca5effcb0b67038264a151b353666e sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> allows <command>INSERT</command>,
    <command>UPDATE</command>, and <command>DELETE</command> to be used as <literal>WITH</literal>
    queries.  This is not found in the SQL standard.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>允许把<command>INSERT</command>、
    <command>UPDATE</command>以及<command>DELETE</command>用作<literal>WITH</literal>
    查询。这在 SQL 标准中是找不到的。
   </para>
<!-- pgdoc-cn_end sig_en=faca5effcb0b67038264a151b353666e -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=8925c208c44ca5a0a338c1bb275ad2e6 sig_cn_org=None source=14.1 
   <title>Nonstandard Clauses</title>
________________________________________________________-->
   <title>非标准子句</title>
<!-- pgdoc-cn_end sig_en=8925c208c44ca5a0a338c1bb275ad2e6 -->

<!-- pgdoc-cn_start sig_en=1d70724fd9c282e532ba1bd662f951cd sig_cn_org=None source=14.1 
   <para>
    <literal>DISTINCT ON ( ... )</literal> is an extension of the
    SQL standard.
   </para>
________________________________________________________-->
   <para>
    <literal>DISTINCT ON ( ... )</literal>是 SQL 标准的扩展。
   </para>
<!-- pgdoc-cn_end sig_en=1d70724fd9c282e532ba1bd662f951cd -->

<!-- pgdoc-cn_start sig_en=63338c2259b442c68f599855833b4677 sig_cn_org=None source=14.1 
   <para>
    <literal>ROWS FROM( ... )</literal> is an extension of the SQL standard.
   </para>
________________________________________________________-->
   <para>
    <literal>ROWS FROM( ... )</literal>是 SQL 标准的扩展。
   </para>
<!-- pgdoc-cn_end sig_en=63338c2259b442c68f599855833b4677 -->

<!-- pgdoc-cn_start sig_en=4de5a9e210b885dc73ae1748a159abc4 sig_cn_org=None source=14.1 
   <para>
    The <literal>MATERIALIZED</literal> and <literal>NOT
    MATERIALIZED</literal> options of <literal>WITH</literal> are extensions
    of the SQL standard.
   </para>
________________________________________________________-->
   <para> 
    <literal>WITH</literal>的<literal>MATERIALIZED</literal> 和 <literal>NOT MATERIALIZED</literal> 选项是SQL标准的扩展。
   </para>
<!-- pgdoc-cn_end sig_en=4de5a9e210b885dc73ae1748a159abc4 -->
  </refsect2>

 </refsect1>
</refentry>
