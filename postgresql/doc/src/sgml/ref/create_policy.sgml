<!--
doc/src/sgml/ref/create_policy.sgml
PostgreSQL documentation
-->

<refentry id="sql-createpolicy">
<!-- pgdoc-cn_start sig_en=b7ebcb5968086775b3f07e90d04ab052 sig_cn_org=None source=14.1 
 <indexterm zone="sql-createpolicy">
  <primary>CREATE POLICY</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="sql-createpolicy">
  <primary>CREATE POLICY</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=b7ebcb5968086775b3f07e90d04ab052 -->

 <refmeta>
  <refentrytitle>CREATE POLICY</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

<!-- pgdoc-cn_start sig_en=74ef080c0d47308b69c0e431dee06f45 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>CREATE POLICY</refname>
  <refpurpose>define a new row-level security policy for a table</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>CREATE POLICY</refname>
  <refpurpose>为一个表定义一条新的行级安全性策略</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=74ef080c0d47308b69c0e431dee06f45 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=8403d75d8908bba33a544c0fe7b4e9c6 sig_cn_org=None source=14.1 
<synopsis>
CREATE POLICY <replaceable class="parameter">name</replaceable> ON <replaceable class="parameter">table_name</replaceable>
    [ AS { PERMISSIVE | RESTRICTIVE } ]
    [ FOR { ALL | SELECT | INSERT | UPDATE | DELETE } ]
    [ TO { <replaceable class="parameter">role_name</replaceable> | PUBLIC | CURRENT_ROLE | CURRENT_USER | SESSION_USER } [, ...] ]
    [ USING ( <replaceable class="parameter">using_expression</replaceable> ) ]
    [ WITH CHECK ( <replaceable class="parameter">check_expression</replaceable> ) ]
</synopsis>
________________________________________________________-->
<synopsis>
CREATE POLICY <replaceable class="parameter">name</replaceable> ON <replaceable class="parameter">table_name</replaceable>
    [ AS { PERMISSIVE | RESTRICTIVE } ]
    [ FOR { ALL | SELECT | INSERT | UPDATE | DELETE } ]
    [ TO { <replaceable class="parameter">role_name</replaceable> | PUBLIC | CURRENT_ROLE | CURRENT_USER | SESSION_USER } [, ...] ]
    [ USING ( <replaceable class="parameter">using_expression</replaceable> ) ]
    [ WITH CHECK ( <replaceable class="parameter">check_expression</replaceable> ) ]
</synopsis>
<!-- pgdoc-cn_end sig_en=8403d75d8908bba33a544c0fe7b4e9c6 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=94f0dd26fd43694636fdce6e323c31be sig_cn_org=None source=14.1 
  <para>
   The <command>CREATE POLICY</command> command defines a new row-level
   security policy for a table.  Note that row-level security must be
   enabled on the table (using <command>ALTER TABLE ... ENABLE ROW LEVEL
   SECURITY</command>) in order for created policies to be applied.
  </para>
________________________________________________________-->
  <para>
   <command>CREATE POLICY</command>为一个表定义一条行级
   安全性策略。注意为了应用已被创建的策略，在表上必须启用行级安全
   性（使用<command>ALTER TABLE ... ENABLE ROW LEVEL
   SECURITY</command>）。
  </para>
<!-- pgdoc-cn_end sig_en=94f0dd26fd43694636fdce6e323c31be -->

<!-- pgdoc-cn_start sig_en=c09f3c7885210826687a64dc22e08738 sig_cn_org=None source=14.1 
  <para>
   A policy grants the permission to select, insert, update, or delete rows
   that match the relevant policy expression.  Existing table rows are
   checked against the expression specified in <literal>USING</literal>,
   while new rows that would be created via <literal>INSERT</literal>
   or <literal>UPDATE</literal> are checked against the expression specified
   in <literal>WITH CHECK</literal>.  When a <literal>USING</literal>
   expression returns true for a given row then that row is visible to the
   user, while if false or null is returned then the row is not visible.
   When a <literal>WITH CHECK</literal> expression returns true for a row
   then that row is inserted or updated, while if false or null is returned
   then an error occurs.
  </para>
________________________________________________________-->
  <para>
   一条策略授予权限以选择、插入、更新或者删除匹配相关策略表达式的行。
   现有的表行会按照<literal>USING</literal>中指定的表达式进行检查，
   而将要通过<literal>INSERT</literal>或<literal>UPDATE</literal>创建
   的新行会按照<literal>WITH CHECK</literal>中指定的表达式进行检查。
   当<literal>USING</literal>表达式对于一个给定行返回真时，该行对用户
   可见，而返回假或空时该行不可见。当一个<literal>WITH CHECK</literal>
   表达式对一行返回真时，该行会被插入或更新，而如果返回假或空时会发生
   一个错误。
  </para>
<!-- pgdoc-cn_end sig_en=c09f3c7885210826687a64dc22e08738 -->

<!-- pgdoc-cn_start sig_en=b2f415a95ba411fe651ac0a07abf90b1 sig_cn_org=2b3a485448e93ac82aa203b15f3f3772 source=15.7 
  <para>
   For <command>INSERT</command>, <command>UPDATE</command>, and
   <command>MERGE</command> statements,
   <literal>WITH CHECK</literal> expressions are enforced after
   <literal>BEFORE</literal> triggers are fired, and before any actual data
   modifications are made.  Thus a <literal>BEFORE ROW</literal> trigger may
   modify the data to be inserted, affecting the result of the security
   policy check.  <literal>WITH CHECK</literal> expressions are enforced
   before any other constraints.
  </para>
________________________________________________________-->
  <para>
   对于<command>INSERT</command>、<command>UPDATE</command>和
   <command>MERGE</command>语句，
   <literal>WITH CHECK</literal>表达式在
   <literal>BEFORE</literal>触发器触发后执行，
   并在进行任何实际数据修改之前执行。因此，<literal>BEFORE ROW</literal>触发器可能
   修改要插入的数据，从而影响安全策略检查的结果。
   <literal>WITH CHECK</literal>表达式在其他约束之前执行。
</para>
<!-- pgdoc-cn_end sig_en=b2f415a95ba411fe651ac0a07abf90b1 -->

<!-- pgdoc-cn_start sig_en=d3e945fb57e433f91141faf46adc93b8 sig_cn_org=None source=14.1 
  <para>
   Policy names are per-table.  Therefore, one policy name can be used for many
   different tables and have a definition for each table which is appropriate to
   that table.
  </para>
________________________________________________________-->
  <para>
   策略名称是针对每个表的。因此，一个策略名称可以被用于很多个不同的表
   并且对于不同的表呈现适合于该表的定义。
  </para>
<!-- pgdoc-cn_end sig_en=d3e945fb57e433f91141faf46adc93b8 -->

<!-- pgdoc-cn_start sig_en=7fd83dee4162b9d210f52362a5f69071 sig_cn_org=None source=14.1 
  <para>
   Policies can be applied for specific commands or for specific roles.  The
   default for newly created policies is that they apply for all commands and
   roles, unless otherwise specified.  Multiple policies may apply to a single
   command; see below for more details.
   <xref linkend="sql-createpolicy-summary"/> summarizes how the different types
   of policy apply to specific commands.
  </para>
________________________________________________________-->
  <para>
   策略可以被应用于特定的命令或者特定的角色。除非特别指定，新创建的策略
   的默认行为是适用于所有命令和角色。多个策略可以应用于单个命令，更多细节请见下文。<xref linkend="sql-createpolicy-summary"/>总结了不同类型的策略如何应用于特定的命令。
  </para>
<!-- pgdoc-cn_end sig_en=7fd83dee4162b9d210f52362a5f69071 -->

<!-- pgdoc-cn_start sig_en=0d221d9dc548c3660b43ad3323d51f1c sig_cn_org=None source=14.1 
  <para>
   For policies that can have both <literal>USING</literal>
   and <literal>WITH CHECK</literal> expressions (<literal>ALL</literal>
   and <literal>UPDATE</literal>), if no <literal>WITH CHECK</literal>
   expression is defined, then the <literal>USING</literal> expression will be
   used both to determine which rows are visible (normal
   <literal>USING</literal> case) and which new rows will be allowed to be
   added (<literal>WITH CHECK</literal> case).
  </para>
________________________________________________________-->
  <para>
   对同时具有<literal>USING</literal>和<literal>WITH CHECK</literal>
   表达式（<literal>ALL</literal>和<literal>UPDATE</literal>）的策略，
   如果没有定义<literal>WITH CHECK</literal>表达式，那么
   <literal>USING</literal>表达式将被用于决定哪些行可见（普通
   <literal>USING</literal>情况）以及允许哪些新行被增加（
   <literal>WITH CHECK</literal>情况）。
  </para>
<!-- pgdoc-cn_end sig_en=0d221d9dc548c3660b43ad3323d51f1c -->

<!-- pgdoc-cn_start sig_en=bae5647af2634a248224e30bddd1bb36 sig_cn_org=None source=14.1 
  <para>
   If row-level security is enabled for a table, but no applicable policies
   exist, a <quote>default deny</quote> policy is assumed, so that no rows will
   be visible or updatable.
  </para>
________________________________________________________-->
  <para>
   如果为一个表启用了行级安全性但是没有适用的策略存在，将假定为一种
   <quote>默认否定</quote>策略，这样任何行都不可见也不可更新。
  </para>
<!-- pgdoc-cn_end sig_en=bae5647af2634a248224e30bddd1bb36 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
  <title>Parameters</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">name</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=8999db1d7de737fe7a32ee798d48ea03 sig_cn_org=None source=14.1 
     <para>
      The name of the policy to be created.  This must be distinct from the
      name of any other policy for the table.
     </para>
________________________________________________________-->
     <para>
      要创建的策略的名称。这必须和该表上已有的任何其他策略名称相区分。
     </para>
<!-- pgdoc-cn_end sig_en=8999db1d7de737fe7a32ee798d48ea03 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">table_name</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=35b1d9cc0d6e8a3767adf5ef31809448 sig_cn_org=None source=14.1 
     <para>
      The name (optionally schema-qualified) of the table the
      policy applies to.
     </para>
________________________________________________________-->
     <para>
      该策略适用的表的名称（可以被模式限定）。
     </para>
<!-- pgdoc-cn_end sig_en=35b1d9cc0d6e8a3767adf5ef31809448 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>PERMISSIVE</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=b2c8163d7837784b70b2ce32b1b778f9 sig_cn_org=None source=14.1 
     <para>
      Specify that the policy is to be created as a permissive policy.
      All permissive policies which are applicable to a given query will
      be combined together using the Boolean <quote>OR</quote> operator.  By creating
      permissive policies, administrators can add to the set of records
      which can be accessed.  Policies are permissive by default.
     </para>
________________________________________________________-->
     <para>
      指定策略被创建为宽容性策略。适用于一个给定查询的所有宽容性策略将被使用布尔<quote>OR</quote>操作符组合在一起。通过创建宽容性策略，管理员可以在能被访问的记录集合中进行增加。策略默认是宽容性的。
     </para>
<!-- pgdoc-cn_end sig_en=b2c8163d7837784b70b2ce32b1b778f9 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RESTRICTIVE</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=350b1542fef51263518ff8dfa057fb84 sig_cn_org=None source=14.1 
     <para>
      Specify that the policy is to be created as a restrictive policy.
      All restrictive policies which are applicable to a given query will
      be combined together using the Boolean <quote>AND</quote> operator.  By creating
      restrictive policies, administrators can reduce the set of records
      which can be accessed as all restrictive policies must be passed for
      each record.
     </para>
________________________________________________________-->
     <para>
      指定策略被创建为限制性策略。适用于一个给定查询的所有限制性策略将被使用布尔<quote>AND</quote>操作符组合在一起。通过创建限制性策略，管理员可以减少能被访问的记录集合，因为每一条记录都必须通过所有的限制性策略。
     </para>
<!-- pgdoc-cn_end sig_en=350b1542fef51263518ff8dfa057fb84 -->

<!-- pgdoc-cn_start sig_en=5884f2d62bf3938e345264db4be16241 sig_cn_org=None source=14.1 
     <para>
      Note that there needs to be at least one permissive policy to grant
      access to records before restrictive policies can be usefully used to
      reduce that access. If only restrictive policies exist, then no records
      will be accessible. When a mix of permissive and restrictive policies
      are present, a record is only accessible if at least one of the
      permissive policies passes, in addition to all the restrictive
      policies.
     </para>
________________________________________________________-->
     <para>
      注意在限制性策略真正能发挥作用减少访问之前，需要至少一条宽容性策略来授予对记录的访问。如果只有限制性策略存在，则没有记录能被访问。当宽容性和限制性策略混合存在时，只有当一个记录能通过至少一条宽容性策略以及所有的限制性策略时，该记录才是可访问的。
     </para>
<!-- pgdoc-cn_end sig_en=5884f2d62bf3938e345264db4be16241 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">command</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=8c0c0d1e13db04dfadb436a5e3145173 sig_cn_org=None source=14.1 
     <para>
      The command to which the policy applies.  Valid options are
      <command>ALL</command>, <command>SELECT</command>,
      <command>INSERT</command>, <command>UPDATE</command>,
      and <command>DELETE</command>.
      <command>ALL</command> is the default.
      See below for specifics regarding how these are applied.
     </para>
________________________________________________________-->
     <para>
      该策略适用的命令。合法的选项是
      <command>ALL</command>、<command>SELECT</command>、
      <command>INSERT</command>、<command>UPDATE</command>
      以及<command>DELETE</command>。
      <command>ALL</command>为默认。有关这些策略如何被应用的
      细节见下文。
     </para>
<!-- pgdoc-cn_end sig_en=8c0c0d1e13db04dfadb436a5e3145173 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">role_name</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=36ca91a48044ba86824765120c6cf0c3 sig_cn_org=None source=14.1 
     <para>
      The role(s) to which the policy is to be applied.  The default is
      <literal>PUBLIC</literal>, which will apply the policy to all roles.
     </para>
________________________________________________________-->
     <para>
      该策略适用的角色。默认是<literal>PUBLIC</literal>，它将把策略应用
      到所有的角色。
     </para>
<!-- pgdoc-cn_end sig_en=36ca91a48044ba86824765120c6cf0c3 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">using_expression</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=2c09c5b5f6fe5abb32c345b798b159b2 sig_cn_org=None source=14.1 
     <para>
      Any <acronym>SQL</acronym> conditional expression (returning
      <type>boolean</type>).  The conditional expression cannot contain
      any aggregate or window functions.  This expression will be added
      to queries that refer to the table if row-level security is enabled.
      Rows for which the expression returns true will be visible.  Any
      rows for which the expression returns false or null will not be
      visible to the user (in a <command>SELECT</command>), and will not be
      available for modification (in an <command>UPDATE</command>
      or <command>DELETE</command>).  Such rows are silently suppressed; no error
      is reported.
     </para>
________________________________________________________-->
     <para>
      任意的<acronym>SQL</acronym>条件表达式（返回
      <type>boolean</type>）。该条件表达式不能包含任何聚集或者窗口
      函数。如果行级安全性被启用，这个表达式将被增加到引用该表的查询。
      让这个表达式返回真的行将可见。让这个表达式返回假或者空的任何行
      将对用户不可见（在<command>SELECT</command>中）并且将对修改不可用（
      在<command>UPDATE</command>或<command>DELETE</command>中）。这类行
      会被悄悄地禁止而不会报告错误。
     </para>
<!-- pgdoc-cn_end sig_en=2c09c5b5f6fe5abb32c345b798b159b2 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">check_expression</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=b6fe7b0f14a356cad28931582217d900 sig_cn_org=None source=14.1 
     <para>
      Any <acronym>SQL</acronym> conditional expression (returning
      <type>boolean</type>).  The conditional expression cannot contain
      any aggregate or window functions.  This expression will be used in
      <command>INSERT</command> and <command>UPDATE</command> queries against
      the table if row-level security is enabled.  Only rows for which the
      expression evaluates to true will be allowed.  An error will be thrown
      if the expression evaluates to false or null for any of the records
      inserted or any of the records that result from the update.  Note that
      the <replaceable class="parameter">check_expression</replaceable> is
      evaluated against the proposed new contents of the row, not the
      original contents.
     </para>
________________________________________________________-->
     <para>
      任意的<acronym>SQL</acronym>条件表达式（返回
      <type>boolean</type>）。该条件表达式不能包含任何聚集或者窗口
      函数。如果行级安全性被启用，这个表达式将被用在该表上的
      <command>INSERT</command>以及
      <command>UPDATE</command>查询中。只有让该表达式计算为真
      的行才被允许。如果任何被插入的记录或者跟新后的记录导致该表达式计
      算为假或者空，则会抛出一个错误。注意
      <replaceable class="parameter">check_expression</replaceable>
      是根据行的新内容而不是原始内容计算的。
     </para>
<!-- pgdoc-cn_end sig_en=b6fe7b0f14a356cad28931582217d900 -->
    </listitem>
   </varlistentry>

  </variablelist>

  <refsect2>
<!-- pgdoc-cn_start sig_en=b85fdfaa53509baa6c50e65caad8b6ab sig_cn_org=None source=14.1 
   <title>Per-Command Policies</title>
________________________________________________________-->
   <title>针对每种命令的策略</title>
<!-- pgdoc-cn_end sig_en=b85fdfaa53509baa6c50e65caad8b6ab -->

   <variablelist>

     <varlistentry id="sql-createpolicy-all">
      <term><literal>ALL</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=22c3432a1483961bb479bb211f5a2df5 sig_cn_org=None source=14.1 
       <para>
         Using <literal>ALL</literal> for a policy means that it will apply
         to all commands, regardless of the type of command.  If an
         <literal>ALL</literal> policy exists and more specific policies
         exist, then both the <literal>ALL</literal> policy and the more
         specific policy (or policies) will be applied.
         Additionally, <literal>ALL</literal> policies will be applied to
         both the selection side of a query and the modification side, using
         the <literal>USING</literal> expression for both cases if only
         a <literal>USING</literal> expression has been defined.
       </para>
________________________________________________________-->
       <para>
         为一条策略使用<literal>ALL</literal>表示它将适用于所有命令，
         不管命令的类型如何。如果存在一条<literal>ALL</literal>策略
         以及更多特定的策略，则<literal>ALL</literal>策略和那些策略
         会被应用。此外，
         <literal>ALL</literal>策略将同时适用于一个查询的选择端和修
         改端，如果只定义了一个<literal>USING</literal>表达式则将
         该<literal>USING</literal>表达式用于两种情况。
       </para>
<!-- pgdoc-cn_end sig_en=22c3432a1483961bb479bb211f5a2df5 -->
<!-- pgdoc-cn_start sig_en=522120c456bb2a5cd1ff7f247e2ef0df sig_cn_org=None source=14.1 
       <para>
         As an example, if an <literal>UPDATE</literal> is issued, then the
         <literal>ALL</literal> policy will be applicable both to what the
         <literal>UPDATE</literal> will be able to select as rows to be
         updated (applying the <literal>USING</literal> expression),
         and to the resulting updated rows, to check if they are permitted
         to be added to the table (applying the <literal>WITH CHECK</literal>
         expression, if defined, and the <literal>USING</literal> expression
         otherwise).  If an <command>INSERT</command>
         or <command>UPDATE</command> command attempts to add rows to the
         table that do not pass the <literal>ALL</literal>
         policy's <literal>WITH CHECK</literal> expression, the entire
         command will be aborted.
       </para>
________________________________________________________-->
       <para>
         例如，如果发出一个<literal>UPDATE</literal>，那么
         <literal>ALL</literal>策略将同时影响<literal>UPDATE</literal>
         能更新哪些行（应用<literal>USING</literal>表达式）以及更新后
         的行是否被允许加入到表中（如果定义了<literal>WITH CHECK</literal>
         表达式，则应用之；否则使用<literal>USING</literal>表达式）。
         如果一条<command>INSERT</command>
         或者<command>UPDATE</command>命令尝试增加行到表中，
         但行没有通过<literal>ALL</literal>策略的
         <literal>WITH CHECK</literal>表达式，则整个语句将会中断。
       </para>
<!-- pgdoc-cn_end sig_en=522120c456bb2a5cd1ff7f247e2ef0df -->
      </listitem>
     </varlistentry>

     <varlistentry id="sql-createpolicy-select">
      <term><literal>SELECT</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=e6ffbdd62e43cdf044487a629172d674 sig_cn_org=None source=14.1 
       <para>
         Using <literal>SELECT</literal> for a policy means that it will apply
         to <literal>SELECT</literal> queries and whenever
         <literal>SELECT</literal> permissions are required on the relation the
         policy is defined for.  The result is that only those records from the
         relation that pass the <literal>SELECT</literal> policy will be
         returned during a <literal>SELECT</literal> query, and that queries
         that require <literal>SELECT</literal> permissions, such as
         <literal>UPDATE</literal>, will also only see those records
         that are allowed by the <literal>SELECT</literal> policy.
         A <literal>SELECT</literal> policy cannot have a <literal>WITH
         CHECK</literal> expression, as it only applies in cases where
         records are being retrieved from the relation.
       </para>
________________________________________________________-->
       <para>
         对一条策略使用<literal>SELECT</literal>表示它将适用于
         <literal>SELECT</literal>查询，并且无论何时都要求该约束所在的关系上
         的<literal>SELECT</literal>权限。其结果是在一次
         <literal>SELECT</literal>查询期间，只有该关系中那些通过了
         <literal>SELECT</literal>策略的记录才将被返回，并且查询要求
         <literal>SELECT</literal>权限，例如
         <literal>UPDATE</literal>也将只能看到那些
         <literal>SELECT</literal>策略允许的行。一条
         <literal>SELECT</literal>策略不能具有<literal>WITH
         CHECK</literal>表达式，因为它只适用于正在从关系中检索记录的情况。
       </para>
<!-- pgdoc-cn_end sig_en=e6ffbdd62e43cdf044487a629172d674 -->
      </listitem>
     </varlistentry>

     <varlistentry id="sql-createpolicy-insert">
      <term><literal>INSERT</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=94f7783e27c7e397bc68cb135038763e sig_cn_org=09e2e86718690831aa5002416f46a39b source=15.7 
       <para>
         Using <literal>INSERT</literal> for a policy means that it will apply
         to <literal>INSERT</literal> commands and <literal>MERGE</literal>
         commands that contain <literal>INSERT</literal> actions.
         Rows being inserted that do
         not pass this policy will result in a policy violation error, and the
         entire <literal>INSERT</literal> command will be aborted.
         An <literal>INSERT</literal> policy cannot have
         a <literal>USING</literal> expression, as it only applies in cases
         where records are being added to the relation.
       </para>
________________________________________________________-->
       <para>
         使用<literal>INSERT</literal>来定义一个策略意味着它将适用于包含<literal>INSERT</literal>动作和<literal>MERGE</literal>命令的<literal>INSERT</literal>命令。
         插入的行如果不符合该策略，将导致策略违规错误，并且整个<literal>INSERT</literal>命令将被中止。
         <literal>INSERT</literal>策略不能有<literal>USING</literal>表达式，因为它仅适用于向关系添加记录的情况。
       </para>
<!-- pgdoc-cn_end sig_en=94f7783e27c7e397bc68cb135038763e -->
<!-- pgdoc-cn_start sig_en=78a9ab8f92a92659e9cb24cfe42a9b16 sig_cn_org=None source=14.1 
       <para>
         Note that <literal>INSERT</literal> with <literal>ON CONFLICT DO
         UPDATE</literal> checks <literal>INSERT</literal> policies'
         <literal>WITH CHECK</literal> expressions only for rows appended
         to the relation by the <literal>INSERT</literal> path.
       </para>
________________________________________________________-->
       <para>
         注意在带有<literal>ON CONFLICT DO
         UPDATE</literal>的<literal>INSERT</literal>中，只有对通过
         <literal>INSERT</literal>路径追加到关系的行才会检查
         <literal>INSERT</literal>策略的<literal>WITH CHECK</literal>
         表达式。
       </para>
<!-- pgdoc-cn_end sig_en=78a9ab8f92a92659e9cb24cfe42a9b16 -->
      </listitem>
     </varlistentry>

     <varlistentry id="sql-createpolicy-update">
      <term><literal>UPDATE</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=f176f34aad4ba193d5fd8635e6b389c4 sig_cn_org=22e5ad155e294efe6e3a5880dec942e9 source=15.7 
       <para>
         Using <literal>UPDATE</literal> for a policy means that it will apply
         to <literal>UPDATE</literal>, <literal>SELECT FOR UPDATE</literal>
         and <literal>SELECT FOR SHARE</literal> commands, as well as
         auxiliary <literal>ON CONFLICT DO UPDATE</literal> clauses of
         <literal>INSERT</literal> commands.
         <literal>MERGE</literal> commands containing <literal>UPDATE</literal>
         actions are affected as well.  Since <literal>UPDATE</literal>
         involves pulling an existing record and replacing it with a new
         modified record, <literal>UPDATE</literal>
         policies accept both a <literal>USING</literal> expression and
         a <literal>WITH CHECK</literal> expression.
         The <literal>USING</literal> expression determines which records
         the <literal>UPDATE</literal> command will see to operate against,
         while the <literal>WITH CHECK</literal> expression defines which
         modified rows are allowed to be stored back into the relation.
       </para>
________________________________________________________-->
       <para>
         使用<literal>UPDATE</literal>对策略意味着它将适用于<literal>UPDATE</literal>、
         <literal>SELECT FOR UPDATE</literal>和<literal>SELECT FOR SHARE</literal>命令，
         以及<literal>INSERT</literal>命令的辅助<literal>ON CONFLICT DO UPDATE</literal>子句。
         包含<literal>UPDATE</literal>操作的<literal>MERGE</literal>命令也会受到影响。
         由于<literal>UPDATE</literal>涉及提取现有记录并用新的修改记录替换它，
         <literal>UPDATE</literal>策略接受<literal>USING</literal>表达式和
         <literal>WITH CHECK</literal>表达式。
         <literal>USING</literal>表达式确定<literal>UPDATE</literal>命令将操作的记录，
         而<literal>WITH CHECK</literal>表达式定义了允许存储回关系中的修改行。
       </para>
<!-- pgdoc-cn_end sig_en=f176f34aad4ba193d5fd8635e6b389c4 -->

<!-- pgdoc-cn_start sig_en=5c993180b04a31bac8a4eddee7f93d52 sig_cn_org=None source=14.1 
       <para>
         Any rows whose updated values do not pass the
         <literal>WITH CHECK</literal> expression will cause an error, and the
         entire command will be aborted.  If only a <literal>USING</literal>
         clause is specified, then that clause will be used for both
         <literal>USING</literal> and <literal>WITH CHECK</literal> cases.
       </para>
________________________________________________________-->
       <para>
         任何更新后的值无法通过<literal>WITH CHECK</literal>表达式的行
         将会导致错误，并且整个命令将被中止。如果只指定了一个
         <literal>USING</literal>子句，那么该子句将被用于
         <literal>USING</literal>和<literal>WITH CHECK</literal>两种情况。
       </para>
<!-- pgdoc-cn_end sig_en=5c993180b04a31bac8a4eddee7f93d52 -->

<!-- pgdoc-cn_start sig_en=c0111e2592e3f61e8d868f63663e3c36 sig_cn_org=None source=14.1 
       <para>
         Typically an <literal>UPDATE</literal> command also needs to read
         data from columns in the relation being updated (e.g., in a
         <literal>WHERE</literal> clause or a <literal>RETURNING</literal>
         clause, or in an expression on the right hand side of the
         <literal>SET</literal> clause).  In this case,
         <literal>SELECT</literal> rights are also required on the relation
         being updated, and the appropriate <literal>SELECT</literal> or
         <literal>ALL</literal> policies will be applied in addition to
         the <literal>UPDATE</literal> policies.  Thus the user must have
         access to the row(s) being updated through a <literal>SELECT</literal>
         or <literal>ALL</literal> policy in addition to being granted
         permission to update the row(s) via an <literal>UPDATE</literal>
         or <literal>ALL</literal> policy.
       </para>
________________________________________________________-->
       <para>
         典型地，<literal>UPDATE</literal>命令也需要从待更新关系中的列读数据（例如在<literal>WHERE</literal>子句、<literal>RETURNING</literal>子句或在<literal>SET</literal>子句右侧的表达式中）。这种情况下，正被更新的关系上也需要<literal>SELECT</literal>权限，并且除了<literal>UPDATE</literal>策略外，也要应用适当的<literal>SELECT</literal>或者<literal>ALL</literal>策略。这样，除由<literal>UPDATE</literal>或<literal>ALL</literal>策略授权更新行之外，通过<literal>SELECT</literal>或<literal>ALL</literal>策略用也必须能访问正被更新的行。
       </para>
<!-- pgdoc-cn_end sig_en=c0111e2592e3f61e8d868f63663e3c36 -->

<!-- pgdoc-cn_start sig_en=0b1916c4bbe8cab625dc3a204edc60f0 sig_cn_org=None source=14.1 
       <para>
         When an <literal>INSERT</literal> command has an auxiliary
         <literal>ON CONFLICT DO UPDATE</literal> clause, if the
         <literal>UPDATE</literal> path is taken, the row to be updated is
         first checked against the <literal>USING</literal> expressions of
         any <literal>UPDATE</literal> policies, and then the new updated row
         is checked against the <literal>WITH CHECK</literal> expressions.
         Note, however, that unlike a standalone <literal>UPDATE</literal>
         command, if the existing row does not pass the
         <literal>USING</literal> expressions, an error will be thrown (the
         <literal>UPDATE</literal> path will <emphasis>never</emphasis> be silently
         avoided).
       </para>
________________________________________________________-->
       <para>
         当<literal>INSERT</literal>命令附加了<literal>ON CONFLICT DO UPDATE</literal>子句时，如果采用<literal>UPDATE</literal>路径，先以任何<literal>UPDATE</literal>策略的<literal>USING</literal>表达式检查待更新的行，然后以<literal>WITH CHECK</literal>表达式检查新修改的行。但要注意的是，不同于单独的<literal>UPDATE</literal>命令，如果现有的行不能通过<literal>USING</literal>表达式检查，则抛出错误（<literal>UPDATE</literal>路径<emphasis>永不</emphasis>会静默地避免）。
       </para>
<!-- pgdoc-cn_end sig_en=0b1916c4bbe8cab625dc3a204edc60f0 -->
      </listitem>
     </varlistentry>

     <varlistentry id="sql-createpolicy-delete">
      <term><literal>DELETE</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=301759c72026664d44bb4f30e45cd460 sig_cn_org=None source=14.1 
       <para>
         Using <literal>DELETE</literal> for a policy means that it will apply
         to <literal>DELETE</literal> commands.  Only rows that pass this
         policy will be seen by a <literal>DELETE</literal> command.  There can
         be rows that are visible through a <literal>SELECT</literal> that are
         not available for deletion, if they do not pass the
         <literal>USING</literal> expression for
         the <literal>DELETE</literal> policy.
       </para>
________________________________________________________-->
       <para>
         为一条策略使用<literal>DELETE</literal>表示它适用于
         <literal>DELETE</literal>命令。只有通过这条策略的行才将能被
         <literal>DELETE</literal>命令所看到。如果有的行不能通过该
         <literal>DELETE</literal>策略的<literal>USING</literal>表达式，则
         它们可以通过<literal>SELECT</literal>看到但不能被删除。
       </para>
<!-- pgdoc-cn_end sig_en=301759c72026664d44bb4f30e45cd460 -->

<!-- pgdoc-cn_start sig_en=3a34824b66989ab6d29c150dd8c5011f sig_cn_org=None source=14.1 
       <para>
         In most cases a <literal>DELETE</literal> command also needs to read
         data from columns in the relation that it is deleting from (e.g.,
         in a <literal>WHERE</literal> clause or a
         <literal>RETURNING</literal> clause). In this case,
         <literal>SELECT</literal> rights are also required on the relation,
         and the appropriate <literal>SELECT</literal> or
         <literal>ALL</literal> policies will be applied in addition to
         the <literal>DELETE</literal> policies.  Thus the user must have
         access to the row(s) being deleted through a <literal>SELECT</literal>
         or <literal>ALL</literal> policy in addition to being granted
         permission to delete the row(s) via a <literal>DELETE</literal> or
         <literal>ALL</literal> policy.
       </para>
________________________________________________________-->
       <para>
         大多数情况下，<literal>DELETE</literal>命令也需要从其所删除的关系中的列读取数据（例如在<literal>WHERE</literal>子句或<literal>RETURNING</literal>子句中）。这种情况下，在该关系上也需要<literal>SELECT</literal>权限，并且除了<literal>DELETE</literal>策略，也要应用适当的<literal>SELECT</literal>或<literal>ALL</literal>策略。这样，除由<literal>DELETE</literal>或<literal>ALL</literal>策略授权删除行之外，通过<literal>SELECT</literal>或<literal>ALL</literal>策略，用户也必须能访问正被删除的行。
       </para>
<!-- pgdoc-cn_end sig_en=3a34824b66989ab6d29c150dd8c5011f -->

<!-- pgdoc-cn_start sig_en=561bc2a5570a1ce89342295c51d1f0c8 sig_cn_org=None source=14.1 
       <para>
         A <literal>DELETE</literal> policy cannot have a <literal>WITH
         CHECK</literal> expression, as it only applies in cases where
         records are being deleted from the relation, so that there is no
         new row to check.
       </para>
________________________________________________________-->
       <para>
         <literal>DELETE</literal>策略不能具有<literal>WITH
         CHECK</literal>表达式，因为它只适用于正在从关系中删除记录的情况，
         所以没有新行需要检查。
       </para>
<!-- pgdoc-cn_end sig_en=561bc2a5570a1ce89342295c51d1f0c8 -->
      </listitem>
     </varlistentry>

   </variablelist>

   <table id="sql-createpolicy-summary">
<!-- pgdoc-cn_start sig_en=2257db8f4f29f5275f2b6ee89a3634cc sig_cn_org=None source=14.1 
    <title>Policies Applied by Command Type</title>
________________________________________________________-->
    <title>按命令类型应用的策略</title>
<!-- pgdoc-cn_end sig_en=2257db8f4f29f5275f2b6ee89a3634cc -->
    <tgroup cols="6">
     <colspec colnum="4" colname="update-using"/>
     <colspec colnum="5" colname="update-check"/>
     <spanspec namest="update-using" nameend="update-check" spanname="update"/>
     <thead>
<!-- pgdoc-cn_start sig_en=03da82b49f1b56f984524075b96e1367 sig_cn_org=None source=14.1 
      <row>
       <entry morerows="1">Command</entry>
       <entry><literal>SELECT/ALL policy</literal></entry>
       <entry><literal>INSERT/ALL policy</literal></entry>
       <entry spanname="update"><literal>UPDATE/ALL policy</literal></entry>
       <entry><literal>DELETE/ALL policy</literal></entry>
      </row>
________________________________________________________-->
      <row>
       <entry morerows="1">命令</entry>
       <entry><literal>SELECT/ALL策略</literal></entry>
       <entry><literal>INSERT/ALL策略</literal></entry>
       <entry spanname="update"><literal>UPDATE/ALL策略</literal></entry>
       <entry><literal>DELETE/ALL策略</literal></entry>
      </row>
<!-- pgdoc-cn_end sig_en=03da82b49f1b56f984524075b96e1367 -->
      <row>
       <entry><literal>USING expression</literal></entry>
       <entry><literal>WITH CHECK expression</literal></entry>
       <entry><literal>USING expression</literal></entry>
       <entry><literal>WITH CHECK expression</literal></entry>
       <entry><literal>USING expression</literal></entry>
      </row>
     </thead>
     <tbody>
<!-- pgdoc-cn_start sig_en=c0a77c7cd2c727b3ba986a39075f96b4 sig_cn_org=None source=14.1 
      <row>
       <entry><command>SELECT</command></entry>
       <entry>Existing row</entry>
       <entry>&mdash;</entry>
       <entry>&mdash;</entry>
       <entry>&mdash;</entry>
       <entry>&mdash;</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><command>SELECT</command></entry>
       <entry>现有行</entry>
       <entry>&mdash;</entry>
       <entry>&mdash;</entry>
       <entry>&mdash;</entry>
       <entry>&mdash;</entry>
      </row>
<!-- pgdoc-cn_end sig_en=c0a77c7cd2c727b3ba986a39075f96b4 -->
<!-- pgdoc-cn_start sig_en=447ef96e5e4f5a58aa6718c984b6dec0 sig_cn_org=None source=14.1 
      <row>
       <entry><command>SELECT FOR UPDATE/SHARE</command></entry>
       <entry>Existing row</entry>
       <entry>&mdash;</entry>
       <entry>Existing row</entry>
       <entry>&mdash;</entry>
       <entry>&mdash;</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><command>SELECT FOR UPDATE/SHARE</command></entry>
       <entry>现有行</entry>
       <entry>&mdash;</entry>
       <entry>现有行</entry>
       <entry>&mdash;</entry>
       <entry>&mdash;</entry>
      </row>
<!-- pgdoc-cn_end sig_en=447ef96e5e4f5a58aa6718c984b6dec0 -->
<!-- pgdoc-cn_start sig_en=80909b3b2a3b68cafb22783164d88a63 sig_cn_org=23d1130a6085815d5ea43e3c2f149587 source=15.7 
      <row>
       <entry><command>INSERT</command> / <command>MERGE ... THEN INSERT</command></entry>
       <entry>&mdash;</entry>
       <entry>New row</entry>
       <entry>&mdash;</entry>
       <entry>&mdash;</entry>
       <entry>&mdash;</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><command>INSERT</command> / <command>MERGE ... THEN INSERT</command></entry>
       <entry>&mdash;</entry>
       <entry>新行</entry>
       <entry>&mdash;</entry>
       <entry>&mdash;</entry>
       <entry>&mdash;</entry>
      </row>
<!-- pgdoc-cn_end sig_en=80909b3b2a3b68cafb22783164d88a63 -->
<!-- pgdoc-cn_start sig_en=0743cd33e8fe8201e7067afd1e495466 sig_cn_org=None source=14.1 
      <row>
       <entry><command>INSERT ... RETURNING</command></entry>
       <entry>
        New row <footnote id="rls-select-priv">
         <para>
          If read access is required to the existing or new row (for example,
          a <literal>WHERE</literal> or <literal>RETURNING</literal> clause
          that refers to columns from the relation).
         </para>
        </footnote>
       </entry>
       <entry>New row</entry>
       <entry>&mdash;</entry>
       <entry>&mdash;</entry>
       <entry>&mdash;</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><command>INSERT ... RETURNING</command></entry>
       <entry>
        新行<footnote id="rls-select-priv">
         <para>
          对于现有行或新行，如果需要读访问的话（例如涉及到关系内列的<literal>WHERE</literal>或<literal>RETURNING</literal>子句）。
         </para>
        </footnote>
       </entry>
       <entry>新行</entry>
       <entry>&mdash;</entry>
       <entry>&mdash;</entry>
       <entry>&mdash;</entry>
      </row>
<!-- pgdoc-cn_end sig_en=0743cd33e8fe8201e7067afd1e495466 -->
<!-- pgdoc-cn_start sig_en=55293d9cb8c934cc7b042909cafd1683 sig_cn_org=a6891a463f5481781db038b8cf6014d1 source=15.7 
      <row>
       <entry><command>UPDATE</command> / <command>MERGE ... THEN UPDATE</command></entry>
       <entry>
        Existing &amp; new rows <footnoteref linkend="rls-select-priv"/>
       </entry>
       <entry>&mdash;</entry>
       <entry>Existing row</entry>
       <entry>New row</entry>
       <entry>&mdash;</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><command>UPDATE</command> / <command>MERGE ... THEN UPDATE</command></entry>
       <entry>
        现有&amp;新行<footnoteref linkend="rls-select-priv"/>
       </entry>
       <entry>&mdash;</entry>
       <entry>现有行</entry>
       <entry>新行</entry>
       <entry>&mdash;</entry>
      </row>
<!-- pgdoc-cn_end sig_en=55293d9cb8c934cc7b042909cafd1683 -->
<!-- pgdoc-cn_start sig_en=354990edad92a3e89bb75897e23936ca sig_cn_org=None source=14.1 
      <row>
       <entry><command>DELETE</command></entry>
       <entry>
        Existing row <footnoteref linkend="rls-select-priv"/>
       </entry>
       <entry>&mdash;</entry>
       <entry>&mdash;</entry>
       <entry>&mdash;</entry>
       <entry>Existing row</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><command>DELETE</command></entry>
       <entry>
        现有行<footnoteref linkend="rls-select-priv"/>
       </entry>
       <entry>&mdash;</entry>
       <entry>&mdash;</entry>
       <entry>&mdash;</entry>
       <entry>现有行</entry>
      </row>
<!-- pgdoc-cn_end sig_en=354990edad92a3e89bb75897e23936ca -->
<!-- pgdoc-cn_start sig_en=dce8ef325ab49ea56860219665376292 sig_cn_org=None source=14.1 
      <row>
       <entry><command>ON CONFLICT DO UPDATE</command></entry>
       <entry>Existing &amp; new rows</entry>
       <entry>&mdash;</entry>
       <entry>Existing row</entry>
       <entry>New row</entry>
       <entry>&mdash;</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><command>ON CONFLICT DO UPDATE</command></entry>
       <entry>现有 &amp; 新行</entry>
       <entry>&mdash;</entry>
       <entry>现有行</entry>
       <entry>新行</entry>
       <entry>&mdash;</entry>
      </row>
<!-- pgdoc-cn_end sig_en=dce8ef325ab49ea56860219665376292 -->
     </tbody>
    </tgroup>
   </table>

  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=791ada75219a3d1a2a26a7270f530eb1 sig_cn_org=None source=14.1 
   <title>Application of Multiple Policies</title>
________________________________________________________-->
   <title>多重策略的应用</title>
<!-- pgdoc-cn_end sig_en=791ada75219a3d1a2a26a7270f530eb1 -->

<!-- pgdoc-cn_start sig_en=27831b79372aa6f0b19a136b92d4ab74 sig_cn_org=None source=14.1 
   <para>
    When multiple policies of different command types apply to the same command
    (for example, <literal>SELECT</literal> and <literal>UPDATE</literal>
    policies applied to an <literal>UPDATE</literal> command), then the user
    must have both types of permissions (for example, permission to select rows
    from the relation as well as permission to update them).  Thus the
    expressions for one type of policy are combined with the expressions for
    the other type of policy using the <literal>AND</literal> operator.
   </para>
________________________________________________________-->
   <para>
    当多种不同命令类型的策略应用于相同命令（例如<literal>SELECT</literal>和<literal>UPDATE</literal>策略应用于<literal>UPDATE</literal>命令）时，用户就必须同时具有这两种类型的权限（例如从关系中选取行和更新的权限）。这样一种策略类型的表达式就与另一种策略类型的表达式通过使用<literal>AND</literal>操作符组合在一起。
   </para>
<!-- pgdoc-cn_end sig_en=27831b79372aa6f0b19a136b92d4ab74 -->

<!-- pgdoc-cn_start sig_en=e8a775a86939a17045140bcee5d634cf sig_cn_org=None source=14.1 
   <para>
    When multiple policies of the same command type apply to the same command,
    then there must be at least one <literal>PERMISSIVE</literal> policy
    granting access to the relation, and all of the
    <literal>RESTRICTIVE</literal> policies must pass.  Thus all the
    <literal>PERMISSIVE</literal> policy expressions are combined using
    <literal>OR</literal>, all the <literal>RESTRICTIVE</literal> policy
    expressions are combined using <literal>AND</literal>, and the results are
    combined using <literal>AND</literal>.  If there are no
    <literal>PERMISSIVE</literal> policies, then access is denied.
   </para>
________________________________________________________-->
   <para>
    当相同命令类型的多种策略应用于同一命令时，则必须至少有一个<literal>PERMISSIVE</literal>策略授权对该关系的访问，所有的<literal>RESTRICTIVE</literal>策略必须通过。这样，所有的<literal>PERMISSIVE</literal>策略表达式都用<literal>OR</literal>来组合，所有的<literal>RESTRICTIVE</literal>策略表达式都用<literal>AND</literal>来组合，而结果用<literal>AND</literal>来组合。如果没有<literal>PERMISSIVE</literal>策略，则拒绝访问。
   </para>
<!-- pgdoc-cn_end sig_en=e8a775a86939a17045140bcee5d634cf -->

<!-- pgdoc-cn_start sig_en=ae67e04fc32d759a17a2a4cbeeeb7181 sig_cn_org=None source=14.1 
   <para>
    Note that, for the purposes of combining multiple policies,
    <literal>ALL</literal> policies are treated as having the same type as
    whichever other type of policy is being applied.
   </para>
________________________________________________________-->
   <para>
    要注意的是，出于组合多种策略的目的，将<literal>ALL</literal>策略视为与所应用的任何其他类型的策略具有相同的类型。
   </para>
<!-- pgdoc-cn_end sig_en=ae67e04fc32d759a17a2a4cbeeeb7181 -->

<!-- pgdoc-cn_start sig_en=c071d486e481669aafb5a0cc1e8f6a97 sig_cn_org=None source=14.1 
   <para>
    For example, in an <literal>UPDATE</literal> command requiring both
    <literal>SELECT</literal> and <literal>UPDATE</literal> permissions, if
    there are multiple applicable policies of each type, they will be combined
    as follows:

<programlisting>
<replaceable>expression</replaceable> from RESTRICTIVE SELECT/ALL policy 1
AND
<replaceable>expression</replaceable> from RESTRICTIVE SELECT/ALL policy 2
AND
...
AND
(
  <replaceable>expression</replaceable> from PERMISSIVE SELECT/ALL policy 1
  OR
  <replaceable>expression</replaceable> from PERMISSIVE SELECT/ALL policy 2
  OR
  ...
)
AND
<replaceable>expression</replaceable> from RESTRICTIVE UPDATE/ALL policy 1
AND
<replaceable>expression</replaceable> from RESTRICTIVE UPDATE/ALL policy 2
AND
...
AND
(
  <replaceable>expression</replaceable> from PERMISSIVE UPDATE/ALL policy 1
  OR
  <replaceable>expression</replaceable> from PERMISSIVE UPDATE/ALL policy 2
  OR
  ...
)
</programlisting></para>
________________________________________________________-->
   <para>
    例如，在<literal>UPDATE</literal>命令中，<literal>SELECT</literal>和<literal>UPDATE</literal>两种权限都需要，如果每种类型都有多个适用的策略，则将之以下面的方式组合：

<programlisting>
<replaceable>expression</replaceable> from RESTRICTIVE SELECT/ALL policy 1
AND
<replaceable>expression</replaceable> from RESTRICTIVE SELECT/ALL policy 2
AND
...
AND
(
  <replaceable>expression</replaceable> from PERMISSIVE SELECT/ALL policy 1
  OR
  <replaceable>expression</replaceable> from PERMISSIVE SELECT/ALL policy 2
  OR
  ...
)
AND
<replaceable>expression</replaceable> from RESTRICTIVE UPDATE/ALL policy 1
AND
<replaceable>expression</replaceable> from RESTRICTIVE UPDATE/ALL policy 2
AND
...
AND
(
  <replaceable>expression</replaceable> from PERMISSIVE UPDATE/ALL policy 1
  OR
  <replaceable>expression</replaceable> from PERMISSIVE UPDATE/ALL policy 2
  OR
  ...
)
</programlisting></para>
<!-- pgdoc-cn_end sig_en=c071d486e481669aafb5a0cc1e8f6a97 -->

  </refsect2>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
  <title>Notes</title>
________________________________________________________-->
  <title>注解</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->

<!-- pgdoc-cn_start sig_en=84df92a5f3d960c02e34b96e5666071c sig_cn_org=None source=14.1 
  <para>
   You must be the owner of a table to create or change policies for it.
  </para>
________________________________________________________-->
  <para>
   要为一个表创建或者修改策略，你必须是该表的拥有者。
  </para>
<!-- pgdoc-cn_end sig_en=84df92a5f3d960c02e34b96e5666071c -->

<!-- pgdoc-cn_start sig_en=bb2fdb0ab69182fac10df08caa2e9cc3 sig_cn_org=None source=14.1 
  <para>
   While policies will be applied for explicit queries against tables
   in the database, they are not applied when the system is performing internal
   referential integrity checks or validating constraints.  This means there are
   indirect ways to determine that a given value exists.  An example of this is
   attempting to insert a duplicate value into a column that is a primary key
   or has a unique constraint.  If the insert fails then the user can infer that
   the value already exists. (This example assumes that the user is permitted by
   policy to insert records which they are not allowed to see.)  Another example
   is where a user is allowed to insert into a table which references another,
   otherwise hidden table.  Existence can be determined by the user inserting
   values into the referencing table, where success would indicate that the
   value exists in the referenced table.  These issues can be addressed by
   carefully crafting policies to prevent users from being able to insert,
   delete, or update records at all which might possibly indicate a value they
   are not otherwise able to see, or by using generated values (e.g., surrogate
   keys) instead of keys with external meanings.
  </para>
________________________________________________________-->
  <para>
   虽然策略将被应用于针对数据库中表的显式查询上，但当系统正在执行
   内部引用完整性检查或者验证约束时不会应用它们。这意味着有间接的
   方法来决定一个给定的值是否存在。一个例子是向一个作为主键或者拥
   有唯一约束的列中尝试插入重复值。如果插入失败则用户可以推导出该
   值已经存在（这个例子假设用户被策略允许插入他们看不到的记录）。
   另一个例子是一个用户被允许向一个引用了其他表的表中插入，然而另
   一个表是隐藏表。通过用户向引用表中插入值可以判断存在性，
   成功表示该值存在于被引用表中。为了解决这些问题，应该仔细地制作
   策略以完全阻止用户插入、删除或者更新那些可能指示他们不能看到的
   值的记录，或者使用生成的值（例如代理键）来代替具有外部含义的键。
  </para>
<!-- pgdoc-cn_end sig_en=bb2fdb0ab69182fac10df08caa2e9cc3 -->

<!-- pgdoc-cn_start sig_en=b207667e7b9f6960eada6743e20ae330 sig_cn_org=None source=14.1 
  <para>
   Generally, the system will enforce filter conditions imposed using
   security policies prior to qualifications that appear in user queries,
   in order to prevent inadvertent exposure of the protected data to
   user-defined functions which might not be trustworthy.  However,
   functions and operators marked by the system (or the system
   administrator) as <literal>LEAKPROOF</literal> may be evaluated before
   policy expressions, as they are assumed to be trustworthy.
  </para>
________________________________________________________-->
  <para>
   通常，系统将在应用用户查询中出现的条件之前先强制由安全性策略施
   加的过滤条件，这是为了防止无意中把受保护的数据暴露给可能不可信
   的用户定义函数。不过，被系统（或者系统管理员）标记为
   <literal>LEAKPROOF</literal>的函数和操作符可以在策略表达式之前
   被计算，因为它们已经被假定为可信。
  </para>
<!-- pgdoc-cn_end sig_en=b207667e7b9f6960eada6743e20ae330 -->

<!-- pgdoc-cn_start sig_en=7adf786ae84ed48b8ae022fb1f47280f sig_cn_org=c470681fbf1c0a6b042ae0f28eb6a44d source=15.7 
  <para>
   Since policy expressions
   are added to the user's query directly, they will be run with the rights of
   the user running the overall query.  Therefore, users who are using a given
   policy must be able to access any tables or functions referenced in the
   expression or they will simply receive a permission denied error when
   attempting to query the table that has row-level security enabled.
   This does not change how views
   work, however.  As with normal queries and views, permission checks and
   policies for the tables which are referenced by a view will use the view
   owner's rights and any policies which apply to the view owner, except if
   the view is defined using the <literal>security_invoker</literal> option
   (see <link linkend="sql-createview"><command>CREATE VIEW</command></link>).
  </para>
________________________________________________________-->
  <para>
   由于策略表达式直接添加到用户的查询中，它们将以运行整体查询的用户的权限运行。
   因此，使用给定策略的用户必须能够访问表达式中引用的任何表或函数，否则当尝试查询启用了行级安全性的表时，他们将仅收到权限被拒绝的错误。
   然而，这并不改变视图的工作方式。与普通查询和视图一样，引用视图的表的权限检查和策略将使用视图所有者的权限以及适用于视图所有者的任何策略，除非视图是使用<literal>security_invoker</literal>选项定义的（请参见<link linkend="sql-createview"><command>CREATE VIEW</command></link>）。
  </para>
<!-- pgdoc-cn_end sig_en=7adf786ae84ed48b8ae022fb1f47280f -->

<!-- pgdoc-cn_start sig_en=9d82550d030c3c4117c91181b574950f sig_cn_org=ab5d794418e1a011ce8770bf3d7c376d source=15.7 
  <para>
   No separate policy exists for <command>MERGE</command>. Instead, the policies
   defined for <command>SELECT</command>, <command>INSERT</command>,
   <command>UPDATE</command>, and <command>DELETE</command> are applied
   while executing <command>MERGE</command>, depending on the actions that are
   performed.
  </para>
________________________________________________________-->
  <para>
   <command>MERGE</command>没有单独的策略。相反，在执行<command>MERGE</command>时，应用为<command>SELECT</command>、
   <command>INSERT</command>、<command>UPDATE</command>和<command>DELETE</command>定义的策略，具体取决于执行的操作。
</para>
<!-- pgdoc-cn_end sig_en=9d82550d030c3c4117c91181b574950f -->

<!-- pgdoc-cn_start sig_en=cd332cb526a70313d6230a6bdb538273 sig_cn_org=None source=14.1 
  <para>
   Additional discussion and practical examples can be found
   in <xref linkend="ddl-rowsecurity"/>.
  </para>
________________________________________________________-->
  <para>
   在<xref linkend="ddl-rowsecurity"/>中可以找到额外的讨论和实际的例子。
  </para>
<!-- pgdoc-cn_end sig_en=cd332cb526a70313d6230a6bdb538273 -->

 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
  <title>Compatibility</title>
________________________________________________________-->
  <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=75c0182b7308730a76de1a27816c660f sig_cn_org=None source=14.1 
  <para>
   <command>CREATE POLICY</command> is a <productname>PostgreSQL</productname>
   extension.
  </para>
________________________________________________________-->
  <para>
   <command>CREATE POLICY</command>是一种<productname>PostgreSQL</productname>扩展。
  </para>
<!-- pgdoc-cn_end sig_en=75c0182b7308730a76de1a27816c660f -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=8b7cc214676b443e6527e3d6bf054420 sig_cn_org=None source=14.1 
  <title>See Also</title>
________________________________________________________-->
  <title>另见</title>
<!-- pgdoc-cn_end sig_en=8b7cc214676b443e6527e3d6bf054420 -->

  <simplelist type="inline">
   <member><xref linkend="sql-alterpolicy"/></member>
   <member><xref linkend="sql-droppolicy"/></member>
   <member><xref linkend="sql-altertable"/></member>
  </simplelist>
 </refsect1>

</refentry>
