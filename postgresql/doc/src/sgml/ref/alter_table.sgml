<!--
doc/src/sgml/ref/alter_table.sgml
PostgreSQL documentation
-->

<refentry id="sql-altertable">
<!-- pgdoc-cn_start sig_en=212cc60f3ccfda59b5796f36e53b9f18 sig_cn_org=None source=14.1 
 <indexterm zone="sql-altertable">
  <primary>ALTER TABLE</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="sql-altertable">
  <primary>ALTER TABLE</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=212cc60f3ccfda59b5796f36e53b9f18 -->

 <refmeta>
  <refentrytitle>ALTER TABLE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

<!-- pgdoc-cn_start sig_en=83f20fc70f81b25518a2fdc04b99391c sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>ALTER TABLE</refname>
  <refpurpose>change the definition of a table</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>ALTER TABLE</refname>
  <refpurpose>更改一个表的定义</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=83f20fc70f81b25518a2fdc04b99391c -->

<!-- pgdoc-cn_start sig_en=62f26a908b7eb81c307a246571133723 sig_cn_org=62f26a908b7eb81c307a246571133723 source=15.7 
 <refsynopsisdiv>
<synopsis>
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="parameter">name</replaceable> [ * ]
    <replaceable class="parameter">action</replaceable> [, ... ]
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="parameter">name</replaceable> [ * ]
    RENAME [ COLUMN ] <replaceable class="parameter">column_name</replaceable> TO <replaceable class="parameter">new_column_name</replaceable>
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="parameter">name</replaceable> [ * ]
    RENAME CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> TO <replaceable class="parameter">new_constraint_name</replaceable>
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">name</replaceable>
    RENAME TO <replaceable class="parameter">new_name</replaceable>
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">name</replaceable>
    SET SCHEMA <replaceable class="parameter">new_schema</replaceable>
ALTER TABLE ALL IN TABLESPACE <replaceable class="parameter">name</replaceable> [ OWNED BY <replaceable class="parameter">role_name</replaceable> [, ... ] ]
    SET TABLESPACE <replaceable class="parameter">new_tablespace</replaceable> [ NOWAIT ]
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">name</replaceable>
    ATTACH PARTITION <replaceable class="parameter">partition_name</replaceable> { FOR VALUES <replaceable class="parameter">partition_bound_spec</replaceable> | DEFAULT }
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">name</replaceable>
    DETACH PARTITION <replaceable class="parameter">partition_name</replaceable> [ CONCURRENTLY | FINALIZE ]

<phrase>where <replaceable class="parameter">action</replaceable> is one of:</phrase>

    ADD [ COLUMN ] [ IF NOT EXISTS ] <replaceable class="parameter">column_name</replaceable> <replaceable class="parameter">data_type</replaceable> [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">column_constraint</replaceable> [ ... ] ]
    DROP [ COLUMN ] [ IF EXISTS ] <replaceable class="parameter">column_name</replaceable> [ RESTRICT | CASCADE ]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> [ SET DATA ] TYPE <replaceable class="parameter">data_type</replaceable> [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ USING <replaceable class="parameter">expression</replaceable> ]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET DEFAULT <replaceable class="parameter">expression</replaceable>
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> DROP DEFAULT
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> { SET | DROP } NOT NULL
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> DROP EXPRESSION [ IF EXISTS ]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> ADD GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>sequence_options</replaceable> ) ]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> { SET GENERATED { ALWAYS | BY DEFAULT } | SET <replaceable>sequence_option</replaceable> | RESTART [ [ WITH ] <replaceable class="parameter">restart</replaceable> ] } [...]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> DROP IDENTITY [ IF EXISTS ]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET STATISTICS <replaceable class="parameter">integer</replaceable>
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET ( <replaceable class="parameter">attribute_option</replaceable> = <replaceable class="parameter">value</replaceable> [, ... ] )
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> RESET ( <replaceable class="parameter">attribute_option</replaceable> [, ... ] )
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET COMPRESSION <replaceable class="parameter">compression_method</replaceable>
    ADD <replaceable class="parameter">table_constraint</replaceable> [ NOT VALID ]
    ADD <replaceable class="parameter">table_constraint_using_index</replaceable>
    ALTER CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
    VALIDATE CONSTRAINT <replaceable class="parameter">constraint_name</replaceable>
    DROP CONSTRAINT [ IF EXISTS ]  <replaceable class="parameter">constraint_name</replaceable> [ RESTRICT | CASCADE ]
    DISABLE TRIGGER [ <replaceable class="parameter">trigger_name</replaceable> | ALL | USER ]
    ENABLE TRIGGER [ <replaceable class="parameter">trigger_name</replaceable> | ALL | USER ]
    ENABLE REPLICA TRIGGER <replaceable class="parameter">trigger_name</replaceable>
    ENABLE ALWAYS TRIGGER <replaceable class="parameter">trigger_name</replaceable>
    DISABLE RULE <replaceable class="parameter">rewrite_rule_name</replaceable>
    ENABLE RULE <replaceable class="parameter">rewrite_rule_name</replaceable>
    ENABLE REPLICA RULE <replaceable class="parameter">rewrite_rule_name</replaceable>
    ENABLE ALWAYS RULE <replaceable class="parameter">rewrite_rule_name</replaceable>
    DISABLE ROW LEVEL SECURITY
    ENABLE ROW LEVEL SECURITY
    FORCE ROW LEVEL SECURITY
    NO FORCE ROW LEVEL SECURITY
    CLUSTER ON <replaceable class="parameter">index_name</replaceable>
    SET WITHOUT CLUSTER
    SET WITHOUT OIDS
    SET ACCESS METHOD <replaceable class="parameter">new_access_method</replaceable>
    SET TABLESPACE <replaceable class="parameter">new_tablespace</replaceable>
    SET { LOGGED | UNLOGGED }
    SET ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] )
    RESET ( <replaceable class="parameter">storage_parameter</replaceable> [, ... ] )
    INHERIT <replaceable class="parameter">parent_table</replaceable>
    NO INHERIT <replaceable class="parameter">parent_table</replaceable>
    OF <replaceable class="parameter">type_name</replaceable>
    NOT OF
    OWNER TO { <replaceable class="parameter">new_owner</replaceable> | CURRENT_ROLE | CURRENT_USER | SESSION_USER }
    REPLICA IDENTITY { DEFAULT | USING INDEX <replaceable class="parameter">index_name</replaceable> | FULL | NOTHING }

<phrase>and <replaceable class="parameter">partition_bound_spec</replaceable> is:</phrase>

IN ( <replaceable class="parameter">partition_bound_expr</replaceable> [, ...] ) |
FROM ( { <replaceable class="parameter">partition_bound_expr</replaceable> | MINVALUE | MAXVALUE } [, ...] )
  TO ( { <replaceable class="parameter">partition_bound_expr</replaceable> | MINVALUE | MAXVALUE } [, ...] ) |
WITH ( MODULUS <replaceable class="parameter">numeric_literal</replaceable>, REMAINDER <replaceable class="parameter">numeric_literal</replaceable> )

<phrase>and <replaceable class="parameter">column_constraint</replaceable> is:</phrase>

[ CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> ]
{ NOT NULL |
  NULL |
  CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ] |
  DEFAULT <replaceable>default_expr</replaceable> |
  GENERATED ALWAYS AS ( <replaceable>generation_expr</replaceable> ) STORED |
  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>sequence_options</replaceable> ) ] |
  UNIQUE [ NULLS [ NOT ] DISTINCT ] <replaceable class="parameter">index_parameters</replaceable> |
  PRIMARY KEY <replaceable class="parameter">index_parameters</replaceable> |
  REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <replaceable class="parameter">referential_action</replaceable> ] [ ON UPDATE <replaceable class="parameter">referential_action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase>and <replaceable class="parameter">table_constraint</replaceable> is:</phrase>

[ CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> ]
{ CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ] |
  UNIQUE [ NULLS [ NOT ] DISTINCT ] ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> |
  PRIMARY KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> |
  EXCLUDE [ USING <replaceable class="parameter">index_method</replaceable> ] ( <replaceable class="parameter">exclude_element</replaceable> WITH <replaceable class="parameter">operator</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> [ WHERE ( <replaceable class="parameter">predicate</replaceable> ) ] |
  FOREIGN KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <replaceable class="parameter">referential_action</replaceable> ] [ ON UPDATE <replaceable class="parameter">referential_action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase>and <replaceable class="parameter">table_constraint_using_index</replaceable> is:</phrase>

    [ CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> ]
    { UNIQUE | PRIMARY KEY } USING INDEX <replaceable class="parameter">index_name</replaceable>
    [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase><replaceable class="parameter">index_parameters</replaceable> in <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, and <literal>EXCLUDE</literal> constraints are:</phrase>

[ INCLUDE ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) ]
[ WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] ) ]
[ USING INDEX TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]

<phrase><replaceable class="parameter">exclude_element</replaceable> in an <literal>EXCLUDE</literal> constraint is:</phrase>

{ <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> [ ( <replaceable class="parameter">opclass_parameter</replaceable> = <replaceable class="parameter">value</replaceable> [, ... ] ) ] ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]

<phrase><replaceable class="parameter">referential_action</replaceable> in a <literal>FOREIGN KEY</literal>/<literal>REFERENCES</literal> constraint is:</phrase>

{ NO ACTION | RESTRICT | CASCADE | SET NULL [ ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) ] | SET DEFAULT [ ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) ] }
</synopsis>
________________________________________________________-->
 <refsynopsisdiv>
<synopsis>
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="parameter">name</replaceable> [ * ]
    <replaceable class="parameter">action</replaceable> [, ... ]
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="parameter">name</replaceable> [ * ]
    RENAME [ COLUMN ] <replaceable class="parameter">column_name</replaceable> TO <replaceable class="parameter">new_column_name</replaceable>
ALTER TABLE [ IF EXISTS ] [ ONLY ] <replaceable class="parameter">name</replaceable> [ * ]
    RENAME CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> TO <replaceable class="parameter">new_constraint_name</replaceable>
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">name</replaceable>
    RENAME TO <replaceable class="parameter">new_name</replaceable>
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">name</replaceable>
    SET SCHEMA <replaceable class="parameter">new_schema</replaceable>
ALTER TABLE ALL IN TABLESPACE <replaceable class="parameter">name</replaceable> [ OWNED BY <replaceable class="parameter">role_name</replaceable> [, ... ] ]
    SET TABLESPACE <replaceable class="parameter">new_tablespace</replaceable> [ NOWAIT ]
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">name</replaceable>
    ATTACH PARTITION <replaceable class="parameter">partition_name</replaceable> { FOR VALUES <replaceable class="parameter">partition_bound_spec</replaceable> | DEFAULT }
ALTER TABLE [ IF EXISTS ] <replaceable class="parameter">name</replaceable>
    DETACH PARTITION <replaceable class="parameter">partition_name</replaceable> [ CONCURRENTLY | FINALIZE ]

<phrase>where <replaceable class="parameter">action</replaceable> is one of:</phrase>

    ADD [ COLUMN ] [ IF NOT EXISTS ] <replaceable class="parameter">column_name</replaceable> <replaceable class="parameter">data_type</replaceable> [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">column_constraint</replaceable> [ ... ] ]
    DROP [ COLUMN ] [ IF EXISTS ] <replaceable class="parameter">column_name</replaceable> [ RESTRICT | CASCADE ]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> [ SET DATA ] TYPE <replaceable class="parameter">data_type</replaceable> [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ USING <replaceable class="parameter">expression</replaceable> ]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET DEFAULT <replaceable class="parameter">expression</replaceable>
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> DROP DEFAULT
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> { SET | DROP } NOT NULL
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> DROP EXPRESSION [ IF EXISTS ]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> ADD GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>sequence_options</replaceable> ) ]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> { SET GENERATED { ALWAYS | BY DEFAULT } | SET <replaceable>sequence_option</replaceable> | RESTART [ [ WITH ] <replaceable class="parameter">restart</replaceable> ] } [...]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> DROP IDENTITY [ IF EXISTS ]
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET STATISTICS <replaceable class="parameter">integer</replaceable>
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET ( <replaceable class="parameter">attribute_option</replaceable> = <replaceable class="parameter">value</replaceable> [, ... ] )
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> RESET ( <replaceable class="parameter">attribute_option</replaceable> [, ... ] )
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
    ALTER [ COLUMN ] <replaceable class="parameter">column_name</replaceable> SET COMPRESSION <replaceable class="parameter">compression_method</replaceable>
    ADD <replaceable class="parameter">table_constraint</replaceable> [ NOT VALID ]
    ADD <replaceable class="parameter">table_constraint_using_index</replaceable>
    ALTER CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
    VALIDATE CONSTRAINT <replaceable class="parameter">constraint_name</replaceable>
    DROP CONSTRAINT [ IF EXISTS ]  <replaceable class="parameter">constraint_name</replaceable> [ RESTRICT | CASCADE ]
    DISABLE TRIGGER [ <replaceable class="parameter">trigger_name</replaceable> | ALL | USER ]
    ENABLE TRIGGER [ <replaceable class="parameter">trigger_name</replaceable> | ALL | USER ]
    ENABLE REPLICA TRIGGER <replaceable class="parameter">trigger_name</replaceable>
    ENABLE ALWAYS TRIGGER <replaceable class="parameter">trigger_name</replaceable>
    DISABLE RULE <replaceable class="parameter">rewrite_rule_name</replaceable>
    ENABLE RULE <replaceable class="parameter">rewrite_rule_name</replaceable>
    ENABLE REPLICA RULE <replaceable class="parameter">rewrite_rule_name</replaceable>
    ENABLE ALWAYS RULE <replaceable class="parameter">rewrite_rule_name</replaceable>
    DISABLE ROW LEVEL SECURITY
    ENABLE ROW LEVEL SECURITY
    FORCE ROW LEVEL SECURITY
    NO FORCE ROW LEVEL SECURITY
    CLUSTER ON <replaceable class="parameter">index_name</replaceable>
    SET WITHOUT CLUSTER
    SET WITHOUT OIDS
    SET ACCESS METHOD <replaceable class="parameter">new_access_method</replaceable>
    SET TABLESPACE <replaceable class="parameter">new_tablespace</replaceable>
    SET { LOGGED | UNLOGGED }
    SET ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] )
    RESET ( <replaceable class="parameter">storage_parameter</replaceable> [, ... ] )
    INHERIT <replaceable class="parameter">parent_table</replaceable>
    NO INHERIT <replaceable class="parameter">parent_table</replaceable>
    OF <replaceable class="parameter">type_name</replaceable>
    NOT OF
    OWNER TO { <replaceable class="parameter">new_owner</replaceable> | CURRENT_ROLE | CURRENT_USER | SESSION_USER }
    REPLICA IDENTITY { DEFAULT | USING INDEX <replaceable class="parameter">index_name</replaceable> | FULL | NOTHING }

<phrase>and <replaceable class="parameter">partition_bound_spec</replaceable> is:</phrase>

IN ( <replaceable class="parameter">partition_bound_expr</replaceable> [, ...] ) |
FROM ( { <replaceable class="parameter">partition_bound_expr</replaceable> | MINVALUE | MAXVALUE } [, ...] )
  TO ( { <replaceable class="parameter">partition_bound_expr</replaceable> | MINVALUE | MAXVALUE } [, ...] ) |
WITH ( MODULUS <replaceable class="parameter">numeric_literal</replaceable>, REMAINDER <replaceable class="parameter">numeric_literal</replaceable> )

<phrase>and <replaceable class="parameter">column_constraint</replaceable> is:</phrase>

[ CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> ]
{ NOT NULL |
  NULL |
  CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ] |
  DEFAULT <replaceable>default_expr</replaceable> |
  GENERATED ALWAYS AS ( <replaceable>generation_expr</replaceable> ) STORED |
  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>sequence_options</replaceable> ) ] |
  UNIQUE [ NULLS [ NOT ] DISTINCT ] <replaceable class="parameter">index_parameters</replaceable> |
  PRIMARY KEY <replaceable class="parameter">index_parameters</replaceable> |
  REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <replaceable class="parameter">referential_action</replaceable> ] [ ON UPDATE <replaceable class="parameter">referential_action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase>and <replaceable class="parameter">table_constraint</replaceable> is:</phrase>

[ CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> ]
{ CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ] |
  UNIQUE [ NULLS [ NOT ] DISTINCT ] ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> |
  PRIMARY KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> |
  EXCLUDE [ USING <replaceable class="parameter">index_method</replaceable> ] ( <replaceable class="parameter">exclude_element</replaceable> WITH <replaceable class="parameter">operator</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> [ WHERE ( <replaceable class="parameter">predicate</replaceable> ) ] |
  FOREIGN KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <replaceable class="parameter">referential_action</replaceable> ] [ ON UPDATE <replaceable class="parameter">referential_action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase>and <replaceable class="parameter">table_constraint_using_index</replaceable> is:</phrase>

    [ CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> ]
    { UNIQUE | PRIMARY KEY } USING INDEX <replaceable class="parameter">index_name</replaceable>
    [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase><replaceable class="parameter">index_parameters</replaceable> in <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, and <literal>EXCLUDE</literal> constraints are:</phrase>

[ INCLUDE ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) ]
[ WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] ) ]
[ USING INDEX TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]

<phrase><replaceable class="parameter">exclude_element</replaceable> in an <literal>EXCLUDE</literal> constraint is:</phrase>

{ <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> [ ( <replaceable class="parameter">opclass_parameter</replaceable> = <replaceable class="parameter">value</replaceable> [, ... ] ) ] ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]

<phrase><replaceable class="parameter">referential_action</replaceable> in a <literal>FOREIGN KEY</literal>/<literal>REFERENCES</literal> constraint is:</phrase>

{ NO ACTION | RESTRICT | CASCADE | SET NULL [ ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) ] | SET DEFAULT [ ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) ] }
</synopsis>
<!-- pgdoc-cn_end sig_en=62f26a908b7eb81c307a246571133723 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=8a0555aa86bc56a8872f3324183ef2a7 sig_cn_org=11498b949375bb455ca0af67fbe365a4 source=15.7 
  <para>
   <command>ALTER TABLE</command> changes the definition of an existing table.
   There are several subforms described below. Note that the lock level required
   may differ for each subform. An <literal>ACCESS EXCLUSIVE</literal> lock is
   acquired unless explicitly noted. When multiple subcommands are given, the
   lock acquired will be the strictest one required by any subcommand.

  <variablelist>
   <varlistentry>
________________________________________________________-->
  <para>
   <command>ALTER TABLE</command>改变现有表的定义。下面描述了几种子形式。请注意，每种子形式所需的锁级别可能不同。除非有明确说明，否则将获取<literal>ACCESS EXCLUSIVE</literal>锁。当给出多个子命令时，将获取任何子命令所需的最严格的锁。
  
  <variablelist>
   <varlistentry>
<!-- pgdoc-cn_end sig_en=8a0555aa86bc56a8872f3324183ef2a7 -->
    <term><literal>ADD COLUMN [ IF NOT EXISTS ]</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=663d1f3b3ecf5611942ae44a916b1134 sig_cn_org=e0008cd53643a709baa4e9bb46bcefbf source=15.7 
     <para>
      This form adds a new column to the table, using the same syntax as
      <link linkend="sql-createtable"><command>CREATE TABLE</command></link>. If <literal>IF NOT EXISTS</literal>
      is specified and a column already exists with this name,
      no error is thrown.
     </para>
________________________________________________________-->
     <para>
      这个表单使用与<link linkend="sql-createtable"><command>CREATE TABLE</command></link>相同的语法向表中添加新列。
      如果指定了<literal>IF NOT EXISTS</literal>，并且已经存在具有该名称的列，
      则不会抛出错误。
</para>
<!-- pgdoc-cn_end sig_en=663d1f3b3ecf5611942ae44a916b1134 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP COLUMN [ IF EXISTS ]</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=65ffb7ee2d6850805d3d83849c18037a sig_cn_org=25c2761312c2271f70a728dfb535ee55 source=15.7 
     <para>
      This form drops a column from a table.  Indexes and
      table constraints involving the column will be automatically
      dropped as well.
      Multivariate statistics referencing the dropped column will also be
      removed if the removal of the column would cause the statistics to
      contain data for only a single column.
      You will need to say <literal>CASCADE</literal> if anything outside the table
      depends on the column, for example, foreign key references or views.
      If <literal>IF EXISTS</literal> is specified and the column
      does not exist, no error is thrown. In this case a notice
      is issued instead.
     </para>
________________________________________________________-->
     <para>
      这个表单从表中删除一列。涉及该列的索引和表约束也将被自动删除。
      如果删除列会导致多变量统计引用的列被移除，那么这些统计数据也将被移除，
      因为统计数据只包含单列数据。
      如果表外有任何依赖于该列的内容，例如外键引用或视图，您需要使用<literal>CASCADE</literal>。
      如果指定了<literal>IF EXISTS</literal>，并且该列不存在，则不会抛出错误。在这种情况下，会发出通知。
     </para>
<!-- pgdoc-cn_end sig_en=65ffb7ee2d6850805d3d83849c18037a -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET DATA TYPE</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=018d7eedba33a6e21278dbabbbd1f743 sig_cn_org=661b6b03a1d421f507de5be2f3cc7b31 source=15.7 
     <para>
      This form changes the type of a column of a table. Indexes and
      simple table constraints involving the column will be automatically
      converted to use the new column type by reparsing the originally
      supplied expression.
      The optional <literal>COLLATE</literal> clause specifies a collation
      for the new column; if omitted, the collation is the default for the
      new column type.
      The optional <literal>USING</literal>
      clause specifies how to compute the new column value from the old;
      if omitted, the default conversion is the same as an assignment
      cast from old data type to new.  A  <literal>USING</literal>
      clause must be provided if there is no implicit or assignment
      cast from old to new type.
     </para>
________________________________________________________-->
     <para>
      这个表单改变了表的一列的类型。涉及该列的索引和简单的表约束将自动转换为使用新的列类型，通过重新解析最初提供的表达式。
      可选的<literal>COLLATE</literal>子句指定新列的排序规则；如果省略，则排序规则为新列类型的默认值。
      可选的<literal>USING</literal>子句指定如何从旧值计算新列的值；如果省略，则默认转换与从旧数据类型到新数据类型的赋值转换相同。
      如果从旧类型到新类型没有隐式或赋值转换，则必须提供<literal>USING</literal>子句。
</para>
<!-- pgdoc-cn_end sig_en=018d7eedba33a6e21278dbabbbd1f743 -->

<!-- pgdoc-cn_start sig_en=1aafff6122a3bf9e5ab95a755506b839 sig_cn_org=4c819594620085b562df79efdbed2ed7 source=15.7 
     <para>
      When this form is used, the column's statistics are removed,
      so running <link linkend="sql-analyze"><command>ANALYZE</command></link>
      on the table afterwards is recommended.
     </para>
________________________________________________________-->
     <para>
      当使用此形式时，列的统计信息将被删除，因此建议之后在表上运行
      <link linkend="sql-analyze"><command>ANALYZE</command></link>。
     </para>
<!-- pgdoc-cn_end sig_en=1aafff6122a3bf9e5ab95a755506b839 -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=2805240a1252f5bf0050e9ec1f5fd194 sig_cn_org=None source=14.1 
    <term><literal>SET</literal>/<literal>DROP DEFAULT</literal></term>
________________________________________________________-->
    <term><literal>SET</literal>/<literal>DROP DEFAULT</literal></term>
<!-- pgdoc-cn_end sig_en=2805240a1252f5bf0050e9ec1f5fd194 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=5578e649ffcf9bedd5ed30744dc2293c sig_cn_org=457c11467dd9b276cd4df45abc8b5df7 source=15.7 
     <para>
      These forms set or remove the default value for a column (where
      removal is equivalent to setting the default value to NULL).  The new
      default value will only apply in subsequent <command>INSERT</command>
      or <command>UPDATE</command> commands; it does not cause rows already
      in the table to change.
     </para>
________________________________________________________-->
     <para>
      这些形式设置或删除列的默认值（其中删除等同于将默认值设置为NULL）。新的默认值仅适用于后续的<command>INSERT</command>或<command>UPDATE</command>命令；它不会导致表中已经存在的行发生变化。
     </para>
<!-- pgdoc-cn_end sig_en=5578e649ffcf9bedd5ed30744dc2293c -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=261a5ecb236012ad56f18c26df6603c6 sig_cn_org=None source=14.1 
    <term><literal>SET</literal>/<literal>DROP NOT NULL</literal></term>
________________________________________________________-->
    <term><literal>SET</literal>/<literal>DROP NOT NULL</literal></term>
<!-- pgdoc-cn_end sig_en=261a5ecb236012ad56f18c26df6603c6 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=626d61065b430d0f6d3cce9c4f28e066 sig_cn_org=c7f112d7cf676fc9a697e611e8bb4fee source=15.7 
     <para>
      These forms change whether a column is marked to allow null
      values or to reject null values.
     </para>
________________________________________________________-->
     <para>
      这些形式改变了列是否标记为允许空值或拒绝空值。
     </para>
<!-- pgdoc-cn_end sig_en=626d61065b430d0f6d3cce9c4f28e066 -->

<!-- pgdoc-cn_start sig_en=8f88953ae2a47f3b9eb412f26a7c0873 sig_cn_org=533407822eff2de2a15a232e116b83ac source=15.7 
     <para>
      <literal>SET NOT NULL</literal> may only be applied to a column
      provided none of the records in the table contain a
      <literal>NULL</literal> value for the column.  Ordinarily this is
      checked during the <literal>ALTER TABLE</literal> by scanning the
      entire table; however, if a valid <literal>CHECK</literal> constraint is
      found which proves no <literal>NULL</literal> can exist, then the
      table scan is skipped.
     </para>
________________________________________________________-->
     <para>
      <literal>SET NOT NULL</literal>只能应用于表中的列，前提是表中的记录都不包含<literal>NULL</literal>值。
      通常在<literal>ALTER TABLE</literal>期间通过扫描整个表来检查此条件；但是，如果找到一个有效的<literal>CHECK</literal>约束，
      证明不存在<literal>NULL</literal>，则跳过表扫描。
     </para>
<!-- pgdoc-cn_end sig_en=8f88953ae2a47f3b9eb412f26a7c0873 -->

<!-- pgdoc-cn_start sig_en=28fa1a23560e67708e366d7a4cbfe6e9 sig_cn_org=7d5d8ab4653e71ac9b96b39ced708216 source=15.7 
     <para>
      If this table is a partition, one cannot perform <literal>DROP NOT NULL</literal>
      on a column if it is marked <literal>NOT NULL</literal> in the parent
      table.  To drop the <literal>NOT NULL</literal> constraint from all the
      partitions, perform <literal>DROP NOT NULL</literal> on the parent
      table.  Even if there is no <literal>NOT NULL</literal> constraint on the
      parent, such a constraint can still be added to individual partitions,
      if desired; that is, the children can disallow nulls even if the parent
      allows them, but not the other way around.
     </para>
________________________________________________________-->
     <para>
      如果这个表是一个分区，那么如果在父表中标记为<literal>NOT NULL</literal>，
      则无法对列执行<literal>DROP NOT NULL</literal>操作。要从所有分区中删除
      <literal>NOT NULL</literal>约束，请在父表上执行<literal>DROP NOT NULL</literal>。
      即使父表上没有<literal>NOT NULL</literal>约束，也可以向单独的分区添加这样的约束，
      如果需要的话；也就是说，子表可以禁止空值，即使父表允许，但反之则不行。
     </para>
<!-- pgdoc-cn_end sig_en=28fa1a23560e67708e366d7a4cbfe6e9 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP EXPRESSION [ IF EXISTS ]</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=053c59bae49c6d95a2aca1ad7fb3aadc sig_cn_org=8b374f5ed43769a9c32076a113f10a3d source=15.7 
     <para>
      This form turns a stored generated column into a normal base column.
      Existing data in the columns is retained, but future changes will no
      longer apply the generation expression.
     </para>
________________________________________________________-->
     <para>
      这个表单将一个存储的生成列转换为普通的基本列。列中的现有数据将被保留，
      但以后的更改将不再应用生成表达式。
     </para>
<!-- pgdoc-cn_end sig_en=053c59bae49c6d95a2aca1ad7fb3aadc -->

<!-- pgdoc-cn_start sig_en=d89d0e46068be6aec34388f88278a809 sig_cn_org=4b2e3d43aeeef052876bd7316ff6ab3d source=15.7 
     <para>
      If <literal>DROP EXPRESSION IF EXISTS</literal> is specified and the
      column is not a stored generated column, no error is thrown.  In this
      case a notice is issued instead.
     </para>
________________________________________________________-->
     <para>
      如果指定了<literal>DROP EXPRESSION IF EXISTS</literal>，并且该列不是存储的生成列，
      则不会抛出错误。在这种情况下，会发出通知。
     </para>
<!-- pgdoc-cn_end sig_en=d89d0e46068be6aec34388f88278a809 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ADD GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY</literal></term>
    <term><literal>SET GENERATED { ALWAYS | BY DEFAULT }</literal></term>
    <term><literal>DROP IDENTITY [ IF EXISTS ]</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=0e6bf4fe76910a12f86f3618accd4489 sig_cn_org=2ea6770e5137af54b856b8ea2daa66cc source=15.7 
     <para>
      These forms change whether a column is an identity column or change the
      generation attribute of an existing identity column.
      See <link linkend="sql-createtable"><command>CREATE TABLE</command></link> for details.
      Like <literal>SET DEFAULT</literal>, these forms only affect the
      behavior of subsequent <command>INSERT</command>
      and <command>UPDATE</command> commands; they do not cause rows
      already in the table to change.
     </para>
________________________________________________________-->
     <para>
      这些形式会改变列是否为标识列，或更改现有标识列的生成属性。
      详细信息请参见<link linkend="sql-createtable"><command>CREATE TABLE</command></link>。
      与<literal>SET DEFAULT</literal>类似，这些形式仅影响后续<command>INSERT</command>
      和<command>UPDATE</command>命令的行为；它们不会导致表中已有的行发生变化。
     </para>
<!-- pgdoc-cn_end sig_en=0e6bf4fe76910a12f86f3618accd4489 -->

<!-- pgdoc-cn_start sig_en=5c4393345c9e8ce3d6bdd2db105821d8 sig_cn_org=51fc710d419d8cc00f67e6564c43239f source=15.7 
     <para>
      If <literal>DROP IDENTITY IF EXISTS</literal> is specified and the
      column is not an identity column, no error is thrown.  In this case a
      notice is issued instead.
     </para>
________________________________________________________-->
     <para>
      如果指定了<literal>DROP IDENTITY IF EXISTS</literal>，并且该列不是标识列，则不会抛出错误。
      在这种情况下，会发出一条通知。
     </para>
<!-- pgdoc-cn_end sig_en=5c4393345c9e8ce3d6bdd2db105821d8 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET <replaceable>sequence_option</replaceable></literal></term>
    <term><literal>RESTART</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=d14268a7075201a988bd9293a3bd207e sig_cn_org=390f155ba9619084895b873d27a500fe source=15.7 
     <para>
      These forms alter the sequence that underlies an existing identity
      column.  <replaceable>sequence_option</replaceable> is an option
      supported by <link linkend="sql-altersequence"><command>ALTER SEQUENCE</command></link> such
      as <literal>INCREMENT BY</literal>.
     </para>
________________________________________________________-->
     <para>
      这些形式改变了现有身份列下面的序列。<replaceable>sequence_option</replaceable>是
	  <link linkend="sql-altersequence"><command>ALTER SEQUENCE</command></link>支持的一个选项，
	  比如<literal>INCREMENT BY</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=d14268a7075201a988bd9293a3bd207e -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET STATISTICS</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=4f3470021c792f1795ff336df2bedcaa sig_cn_org=456fe1853316b703ce8d04defdd115d4 source=15.7 
     <para>
      This form
      sets the per-column statistics-gathering target for subsequent
      <link linkend="sql-analyze"><command>ANALYZE</command></link> operations.
      The target can be set in the range 0 to 10000; alternatively, set it
      to -1 to revert to using the system default statistics
      target (<xref linkend="guc-default-statistics-target"/>).
      For more information on the use of statistics by the
      <productname>PostgreSQL</productname> query planner, refer to
      <xref linkend="planner-stats"/>.
     </para>
________________________________________________________-->
     <para>
      这个表单设置了后续<link linkend="sql-analyze"><command>ANALYZE</command></link>操作的每列统计信息收集目标。
      目标可以设置在0到10000的范围内；或者，将其设置为-1以恢复使用系统默认的统计目标
      (<xref linkend="guc-default-statistics-target"/>)。
      有关<productname>PostgreSQL</productname>查询规划器使用统计信息的更多信息，请参考
      <xref linkend="planner-stats"/>。
     </para>
<!-- pgdoc-cn_end sig_en=4f3470021c792f1795ff336df2bedcaa -->
<!-- pgdoc-cn_start sig_en=72ebed4761ee552fc68b8a916d1658ac sig_cn_org=ab03c6ae2cebf96c97a212a2e0ca5766 source=15.7 
     <para>
      <literal>SET STATISTICS</literal> acquires a
      <literal>SHARE UPDATE EXCLUSIVE</literal> lock.
     </para>
________________________________________________________-->
     <para>
      <literal>SET STATISTICS</literal>获取一个<literal>SHARE UPDATE EXCLUSIVE</literal>锁。
     </para>
<!-- pgdoc-cn_end sig_en=72ebed4761ee552fc68b8a916d1658ac -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET ( <replaceable class="parameter">attribute_option</replaceable> = <replaceable class="parameter">value</replaceable> [, ... ] )</literal></term>
    <term><literal>RESET ( <replaceable class="parameter">attribute_option</replaceable> [, ... ] )</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=90adc171133fac7a25f2d661611cc236 sig_cn_org=ebe3150b03b98a543e2c0f59da926f44 source=15.7 
     <para>
      This form sets or resets per-attribute options.  Currently, the only
      defined per-attribute options are <literal>n_distinct</literal> and
      <literal>n_distinct_inherited</literal>, which override the
      number-of-distinct-values estimates made by subsequent
      <link linkend="sql-analyze"><command>ANALYZE</command></link>
      operations.  <literal>n_distinct</literal> affects the statistics for the table
      itself, while <literal>n_distinct_inherited</literal> affects the statistics
      gathered for the table plus its inheritance children.  When set to a
      positive value, <command>ANALYZE</command> will assume that the column contains
      exactly the specified number of distinct nonnull values.  When set to a
      negative value, which must be greater
      than or equal to -1, <command>ANALYZE</command> will assume that the number of
      distinct nonnull values in the column is linear in the size of the
      table; the exact count is to be computed by multiplying the estimated
      table size by the absolute value of the given number.  For example,
      a value of -1 implies that all values in the column are distinct, while
      a value of -0.5 implies that each value appears twice on the average.
      This can be useful when the size of the table changes over time, since
      the multiplication by the number of rows in the table is not performed
      until query planning time.  Specify a value of 0 to revert to estimating
      the number of distinct values normally.  For more information on the use
      of statistics by the <productname>PostgreSQL</productname> query
      planner, refer to <xref linkend="planner-stats"/>.
     </para>
________________________________________________________-->
     <para>
      这个表单设置或重置每个属性的选项。目前，唯一定义的每个属性选项是
      <literal>n_distinct</literal>和<literal>n_distinct_inherited</literal>，
      它们会覆盖后续<link linkend="sql-analyze"><command>ANALYZE</command></link>
      操作所做的不同值数量估计。<literal>n_distinct</literal>影响表本身的统计信息，
      而<literal>n_distinct_inherited</literal>影响对表及其继承子项收集的统计信息。
      当设置为正值时，<command>ANALYZE</command>将假定该列包含确切数量的不同非空值。
      当设置为负值时，必须大于或等于-1，<command>ANALYZE</command>将假定列中不同非空值的数量
      与表的大小成线性关系；精确计数将通过将估计的表大小乘以给定数字的绝对值来计算。
      例如，值为-1意味着列中的所有值都是不同的，而值为-0.5意味着每个值平均出现两次。
      当表的大小随时间变化时，这可能很有用，因为直到查询计划时才执行对表中行数的乘法。
      指定值为0以恢复正常估计不同值的数量。有关<productname>PostgreSQL</productname>查询
      规划器使用统计信息的更多信息，请参阅<xref linkend="planner-stats"/>。
</para>
<!-- pgdoc-cn_end sig_en=90adc171133fac7a25f2d661611cc236 -->
<!-- pgdoc-cn_start sig_en=ed7eebcf22443cbf6891e074eaa4e584 sig_cn_org=a18fa70a18dcbc9da1bb1f85b3cc5c7a source=15.7 
     <para>
      Changing per-attribute options acquires a
      <literal>SHARE UPDATE EXCLUSIVE</literal> lock.
     </para>
________________________________________________________-->
     <para>
      更改每个属性选项会获取一个<literal>SHARE UPDATE EXCLUSIVE</literal>锁。
     </para>
<!-- pgdoc-cn_end sig_en=ed7eebcf22443cbf6891e074eaa4e584 -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=3e48bbd0beeed3765fc0fb532585065f sig_cn_org=632edd449bb9e96ac92a8f1d25777a84 source=15.7 
    <term>
     <literal>SET STORAGE</literal>
     <indexterm>
      <primary>TOAST</primary>
      <secondary>per-column storage settings</secondary>
     </indexterm>
    </term>
________________________________________________________-->
    <term>
     <literal>SET STORAGE</literal>
     <indexterm>
      <primary>TOAST</primary>
      <secondary>每列存储设置</secondary>
     </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=3e48bbd0beeed3765fc0fb532585065f -->
    <listitem>
<!-- pgdoc-cn_start sig_en=a14461fba86a9766488e8a0fdffc2d8c sig_cn_org=3efcb33bf9c114bfdad1c795b0865d1b source=15.7 
     <para>
      This form sets the storage mode for a column. This controls whether this
      column is held inline or in a secondary <acronym>TOAST</acronym> table, and
      whether the data
      should be compressed or not. <literal>PLAIN</literal> must be used
      for fixed-length values such as <type>integer</type> and is
      inline, uncompressed. <literal>MAIN</literal> is for inline,
      compressible data. <literal>EXTERNAL</literal> is for external,
      uncompressed data, and <literal>EXTENDED</literal> is for external,
      compressed data.  <literal>EXTENDED</literal> is the default for most
      data types that support non-<literal>PLAIN</literal> storage.
      Use of <literal>EXTERNAL</literal> will make substring operations on
      very large <type>text</type> and <type>bytea</type> values run faster,
      at the penalty of increased storage space.  Note that
      <literal>SET STORAGE</literal> doesn't itself change anything in the table,
      it just sets the strategy to be pursued during future table updates.
      See <xref linkend="storage-toast"/> for more information.
     </para>
________________________________________________________-->
     <para>
      这个表单设置了列的存储模式。这控制着这个列是内联存储还是存储在一个次要的<acronym>TOAST</acronym>表中，
	  以及数据是否应该被压缩。对于固定长度的值，比如<type>integer</type>，必须使用<literal>PLAIN</literal>，
	  它是内联的，未压缩的。<literal>MAIN</literal>用于内联的，可压缩的数据。
	  <literal>EXTERNAL</literal>用于外部的，未压缩的数据，<literal>EXTENDED</literal>用于外部的，压缩的数据。
	  大多数支持非<literal>PLAIN</literal>存储的数据类型的默认值是<literal>EXTENDED</literal>。
	  使用<literal>EXTERNAL</literal>将使得对非常大的<type>text</type>和<type>bytea</type>值的子串操作运行更快，
	  但会增加存储空间的代价。请注意，<literal>SET STORAGE</literal>本身并不会改变表中的任何内容，
	  它只是设置了在未来表更新期间要采取的策略。查看<xref linkend="storage-toast"/>获取更多信息。
     </para>
<!-- pgdoc-cn_end sig_en=a14461fba86a9766488e8a0fdffc2d8c -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>SET COMPRESSION <replaceable class="parameter">compression_method</replaceable></literal>
    </term>
    <listitem>
<!-- pgdoc-cn_start sig_en=e1ebd50d08898f84f2236a78728b5127 sig_cn_org=423ee10033af80e0d06e3e167979c228 source=15.7 
     <para>
      This form sets the compression method for a column, determining how
      values inserted in future will be compressed (if the storage mode
      permits compression at all).
      This does not cause the table to be rewritten, so existing data may still
      be compressed with other compression methods.  If the table is restored
      with <application>pg_restore</application>, then all values are rewritten
      with the configured compression method.
      However, when data is inserted from another relation (for example,
      by <command>INSERT ... SELECT</command>), values from the source table are
      not necessarily detoasted, so any previously compressed data may retain
      its existing compression method, rather than being recompressed with the
      compression method of the target column.
      The supported compression
      methods are <literal>pglz</literal> and <literal>lz4</literal>.
      (<literal>lz4</literal> is available only if <option>-&minus;with-lz4</option>
      was used when building <productname>PostgreSQL</productname>.)  In
      addition, <replaceable class="parameter">compression_method</replaceable>
      can be <literal>default</literal>, which selects the default behavior of
      consulting the <xref linkend="guc-default-toast-compression"/> setting
      at the time of data insertion to determine the method to use.
     </para>
________________________________________________________-->
     <para>
      这个表单设置了列的压缩方法，确定将来插入的值将如何被压缩（如果存储模式允许压缩）。
      这不会导致表被重写，因此现有数据仍然可以用其他压缩方法进行压缩。
      如果使用<application>pg_restore</application>还原表，那么所有值都将使用配置的压缩方法重新写入。
      然而，当从另一个关系插入数据时（例如，通过<command>INSERT ... SELECT</command>），源表中的值不一定会被解压缩，因此任何先前压缩的数据可能会保留其现有的压缩方法，而不是使用目标列的压缩方法重新压缩。
      支持的压缩方法有<literal>pglz</literal>和<literal>lz4</literal>。
      （<literal>lz4</literal>仅在构建<productname>PostgreSQL</productname>时使用了<option>--with-lz4</option>才可用。）此外，<replaceable class="parameter">compression_method</replaceable>可以是<literal>default</literal>，它选择了在数据插入时咨询<xref linkend="guc-default-toast-compression"/>设置以确定要使用的方法的默认行为。
     </para>
<!-- pgdoc-cn_end sig_en=e1ebd50d08898f84f2236a78728b5127 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ADD <replaceable class="parameter">table_constraint</replaceable> [ NOT VALID ]</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=aaf40287d55ea8314f30e42992b94214 sig_cn_org=1be43bff49a3d72fc4d1bbdff6f52eb1 source=15.7 
     <para>
      This form adds a new constraint to a table using the same constraint
      syntax as <link linkend="sql-createtable"><command>CREATE TABLE</command></link>, plus the option <literal>NOT
      VALID</literal>, which is currently only allowed for foreign key
      and CHECK constraints.
     </para>
________________________________________________________-->
     <para>
      这个表单使用与<link linkend="sql-createtable"><command>CREATE TABLE</command></link>
	  相同的约束语法添加一个新的约束到表中，还有选项<literal>NOT
      VALID</literal>，目前仅允许用于外键和CHECK约束。
     </para>
<!-- pgdoc-cn_end sig_en=aaf40287d55ea8314f30e42992b94214 -->

<!-- pgdoc-cn_start sig_en=acf1bf5b4b1f70c2f09047af7fe489d0 sig_cn_org=b1da5b077d6057632dad8d0f344e0bb7 source=15.7 
     <para>
      Normally, this form will cause a scan of the table to verify that all
      existing rows in the table satisfy the new constraint.  But if
      the <literal>NOT VALID</literal> option is used, this
      potentially-lengthy scan is skipped.  The constraint will still be
      enforced against subsequent inserts or updates (that is, they'll fail
      unless there is a matching row in the referenced table, in the case
      of foreign keys, or they'll fail unless the new row matches the
      specified check condition).  But the
      database will not assume that the constraint holds for all rows in
      the table, until it is validated by using the <literal>VALIDATE
      CONSTRAINT</literal> option.
      See <xref linkend="sql-altertable-notes"/> below for more information
      about using the <literal>NOT VALID</literal> option.
     </para>
________________________________________________________-->
     <para>
      通常，此形式将导致对表进行扫描，以验证表中所有现有行是否满足新约束。
      但是，如果使用<literal>NOT VALID</literal>选项，则会跳过这个可能耗时的扫描。
      约束仍将对后续的插入或更新执行（也就是说，除非在引用表中存在匹配行，否则它们将失败，
      在外键的情况下，或者除非新行与指定的检查条件匹配）。但是，直到使用<literal>VALIDATE
      CONSTRAINT</literal>选项对其进行验证之前，数据库不会假定约束对表中的所有行都成立。
      有关使用<literal>NOT VALID</literal>选项的更多信息，请参见下面的<xref linkend="sql-altertable-notes"/>。
     </para>
<!-- pgdoc-cn_end sig_en=acf1bf5b4b1f70c2f09047af7fe489d0 -->

<!-- pgdoc-cn_start sig_en=e33e4f07d9cdea40ac5fa7368cccd522 sig_cn_org=7fcddcf227ced10c06e68d009fbbae9f source=15.7 
     <para>
      Although most forms of <literal>ADD
      <replaceable class="parameter">table_constraint</replaceable></literal>
      require an <literal>ACCESS EXCLUSIVE</literal> lock, <literal>ADD
      FOREIGN KEY</literal> requires only a <literal>SHARE ROW
      EXCLUSIVE</literal> lock.  Note that <literal>ADD FOREIGN KEY</literal>
      also acquires a <literal>SHARE ROW EXCLUSIVE</literal> lock on the
      referenced table, in addition to the lock on the table on which the
      constraint is declared.
     </para>
________________________________________________________-->
     <para>
      虽然大多数形式的<literal>ADD
      <replaceable class="parameter">table_constraint</replaceable></literal>
      需要一个<literal>ACCESS EXCLUSIVE</literal>锁，<literal>ADD
      FOREIGN KEY</literal>只需要一个<literal>SHARE ROW
      EXCLUSIVE</literal>锁。请注意，<literal>ADD FOREIGN KEY</literal>
      还会在引用的表上获取一个<literal>SHARE ROW EXCLUSIVE</literal>锁，除了在声明约束的表上获取的锁之外。
     </para>
<!-- pgdoc-cn_end sig_en=e33e4f07d9cdea40ac5fa7368cccd522 -->

<!-- pgdoc-cn_start sig_en=f034943d315beb048f2c9b8618feac91 sig_cn_org=1e587801dda35819a7f7c4731350de48 source=15.7 
     <para>
      Additional restrictions apply when unique or primary key constraints
      are added to partitioned tables; see <link linkend="sql-createtable"><command>CREATE TABLE</command></link>.
      Also, foreign key constraints on partitioned
      tables may not be declared <literal>NOT VALID</literal> at present.
     </para>
________________________________________________________-->
     <para>
      当向分区表添加唯一约束或主键约束时，会应用额外的限制；请参阅
      <link linkend="sql-createtable"><command>CREATE TABLE</command></link>。
      此外，目前分区表上的外键约束不能声明为<literal>NOT VALID</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=f034943d315beb048f2c9b8618feac91 -->

    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ADD <replaceable class="parameter">table_constraint_using_index</replaceable></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=e6895881ecec9eaa9ec6b7a20bb1dcbb sig_cn_org=0f9bbfa70336c1b0902347c823992338 source=15.7 
     <para>
      This form adds a new <literal>PRIMARY KEY</literal> or <literal>UNIQUE</literal>
      constraint to a table based on an existing unique index.  All the
      columns of the index will be included in the constraint.
     </para>
________________________________________________________-->
     <para>
      这个表单基于现有的唯一索引向表中添加一个新的<literal>PRIMARY KEY</literal>或<literal>UNIQUE</literal>约束。
      约束将包括索引的所有列。
     </para>
<!-- pgdoc-cn_end sig_en=e6895881ecec9eaa9ec6b7a20bb1dcbb -->

<!-- pgdoc-cn_start sig_en=96bd5e0bab2e3749c49d50e398b44aaf sig_cn_org=613a0e69a18f74fbe970bad2a4123ef9 source=15.7 
     <para>
      The index cannot have expression columns nor be a partial index.
      Also, it must be a b-tree index with default sort ordering.  These
      restrictions ensure that the index is equivalent to one that would be
      built by a regular <literal>ADD PRIMARY KEY</literal> or <literal>ADD UNIQUE</literal>
      command.
     </para>
________________________________________________________-->
     <para>
      索引不能有表达式列，也不能是部分索引。此外，它必须是具有默认排序顺序的B树索引。
      这些限制确保索引等效于通过常规<literal>ADD PRIMARY KEY</literal>或<literal>ADD UNIQUE</literal>命令构建的索引。
</para>
<!-- pgdoc-cn_end sig_en=96bd5e0bab2e3749c49d50e398b44aaf -->

<!-- pgdoc-cn_start sig_en=b7dd080c7fc9e064280d4ca616fa0e19 sig_cn_org=0f69f7efbc3ceafdfcc326b9bc41d49b source=15.7 
     <para>
      If <literal>PRIMARY KEY</literal> is specified, and the index's columns are not
      already marked <literal>NOT NULL</literal>, then this command will attempt to
      do <literal>ALTER COLUMN SET NOT NULL</literal> against each such column.
      That requires a full table scan to verify the column(s) contain no
      nulls.  In all other cases, this is a fast operation.
     </para>
________________________________________________________-->
     <para>
      如果指定了<literal>PRIMARY KEY</literal>，并且索引的列尚未标记为<literal>NOT NULL</literal>，
      那么此命令将尝试对每个这样的列执行<literal>ALTER COLUMN SET NOT NULL</literal>。
      这需要进行全表扫描以验证列不包含空值。在所有其他情况下，这是一个快速操作。
</para>
<!-- pgdoc-cn_end sig_en=b7dd080c7fc9e064280d4ca616fa0e19 -->

<!-- pgdoc-cn_start sig_en=2a152bd45a9392e1a7a3bd7375d4eaf7 sig_cn_org=5ff2766c141cb48c091a039eb62295d4 source=15.7 
     <para>
      If a constraint name is provided then the index will be renamed to match
      the constraint name.  Otherwise the constraint will be named the same as
      the index.
     </para>
________________________________________________________-->
     <para>
      如果提供了约束名，则索引将被重命名以匹配约束名。否则，约束将被命名为与索引相同。
     </para>
<!-- pgdoc-cn_end sig_en=2a152bd45a9392e1a7a3bd7375d4eaf7 -->

<!-- pgdoc-cn_start sig_en=8e22c74adc532979b017641a96085258 sig_cn_org=31fb026c471ed4305737cf8f71795326 source=15.7 
     <para>
      After this command is executed, the index is <quote>owned</quote> by the
      constraint, in the same way as if the index had been built by
      a regular <literal>ADD PRIMARY KEY</literal> or <literal>ADD UNIQUE</literal>
      command.  In particular, dropping the constraint will make the index
      disappear too.
     </para>
________________________________________________________-->
     <para>
      执行此命令后，索引将被约束所<quote>拥有</quote>，就像索引是由常规<literal>ADD PRIMARY KEY</literal>或<literal>ADD UNIQUE</literal>命令构建的一样。
      特别是，删除约束将导致索引也消失。
     </para>
<!-- pgdoc-cn_end sig_en=8e22c74adc532979b017641a96085258 -->

<!-- pgdoc-cn_start sig_en=ae8a2ddb97ef0bf9277802308597a92b sig_cn_org=852f86c6ad4f557f59576a168dbac06c source=15.7 
     <para>
      This form is not currently supported on partitioned tables.
     </para>
________________________________________________________-->
     <para>
      这种形式目前不支持分区表。
     </para>
<!-- pgdoc-cn_end sig_en=ae8a2ddb97ef0bf9277802308597a92b -->

     <note>
<!-- pgdoc-cn_start sig_en=b9ba2413c3543a5496387f94893c08a6 sig_cn_org=e5c4b1158c26fbd2f9e11cb2eca02eca source=15.7 
      <para>
       Adding a constraint using an existing index can be helpful in
       situations where a new constraint needs to be added without blocking
       table updates for a long time.  To do that, create the index using
       <command>CREATE INDEX CONCURRENTLY</command>, and then install it as an
       official constraint using this syntax.  See the example below.
      </para>
________________________________________________________-->
      <para>
       使用现有索引添加约束可以在需要添加新约束但又不想长时间阻塞表更新的情况下很有帮助。
       要做到这一点，使用<command>CREATE INDEX CONCURRENTLY</command>创建索引，然后使用以下语法将其安装为官方约束。
       请参见下面的示例。
      </para>
<!-- pgdoc-cn_end sig_en=b9ba2413c3543a5496387f94893c08a6 -->
     </note>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ALTER CONSTRAINT</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=5eceef8b89589514b3d8e4b9dd5702ab sig_cn_org=751e7f6b16adc717cb20f43a3460bd5b source=15.7 
     <para>
      This form alters the attributes of a constraint that was previously
      created. Currently only foreign key constraints may be altered.
     </para>
________________________________________________________-->
     <para>
      这个表单修改了先前创建的约束的属性。目前只能修改外键约束。
     </para>
<!-- pgdoc-cn_end sig_en=5eceef8b89589514b3d8e4b9dd5702ab -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>VALIDATE CONSTRAINT</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=55f64f1aea3cb2e86ea62a15d6524af5 sig_cn_org=c910a4d20bbb45ca42e011b2cc2eb6e7 source=15.7 
     <para>
      This form validates a foreign key or check constraint that was
      previously created as <literal>NOT VALID</literal>, by scanning the
      table to ensure there are no rows for which the constraint is not
      satisfied.  Nothing happens if the constraint is already marked valid.
      (See <xref linkend="sql-altertable-notes"/> below for an explanation
      of the usefulness of this command.)
     </para>
________________________________________________________-->
     <para>
      这个表单验证了之前创建的外键或检查约束，该约束之前被标记为<literal>NOT VALID</literal>，
	  通过扫描表来确保没有任何行不满足约束条件。如果约束已经标记为有效，则不会发生任何事情。
	  （有关此命令的有用性，请参见下面的<xref linkend="sql-altertable-notes"/>。）
</para>
<!-- pgdoc-cn_end sig_en=55f64f1aea3cb2e86ea62a15d6524af5 -->
<!-- pgdoc-cn_start sig_en=8a722ee927423e1edcd84b441be5819e sig_cn_org=0ceebf503fb5f0952f38fe25ea6f837e source=15.7 
     <para>
      This command acquires a <literal>SHARE UPDATE EXCLUSIVE</literal> lock.
     </para>
________________________________________________________-->
     <para>
      这个命令获取一个<literal>SHARE UPDATE EXCLUSIVE</literal>锁。
     </para>
<!-- pgdoc-cn_end sig_en=8a722ee927423e1edcd84b441be5819e -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP CONSTRAINT [ IF EXISTS ]</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=d27459c48de17bd1d6b8b1b4ef31142c sig_cn_org=49a5f4bc48a5515427a9999e7371315d source=15.7 
     <para>
      This form drops the specified constraint on a table, along with
      any index underlying the constraint.
      If <literal>IF EXISTS</literal> is specified and the constraint
      does not exist, no error is thrown. In this case a notice is issued instead.
     </para>
________________________________________________________-->
     <para>
      这个表单删除表上指定的约束，以及约束下的任何索引。
      如果指定了<literal>IF EXISTS</literal>并且约束不存在，则不会抛出错误。在这种情况下，会发出通知。
</para>
<!-- pgdoc-cn_end sig_en=d27459c48de17bd1d6b8b1b4ef31142c -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=4cc8c5cd82cd61453587d194964b82fc sig_cn_org=None source=14.1 
    <term><literal>DISABLE</literal>/<literal>ENABLE [ REPLICA | ALWAYS ] TRIGGER</literal></term>
________________________________________________________-->
    <term><literal>DISABLE</literal>/<literal>ENABLE [ REPLICA | ALWAYS ] TRIGGER</literal></term>
<!-- pgdoc-cn_end sig_en=4cc8c5cd82cd61453587d194964b82fc -->
    <listitem>
<!-- pgdoc-cn_start sig_en=28abc31adf66cbcbe6ed748fa6213642 sig_cn_org=4d2cdc05de08911ba1942b07b0eff4cc source=15.7 
     <para>
      These forms configure the firing of trigger(s) belonging to the table.
      A disabled trigger is still known to the system, but is not executed
      when its triggering event occurs.  (For a deferred trigger, the enable
      status is checked when the event occurs, not when the trigger function
      is actually executed.)  One can disable or enable a single
      trigger specified by name, or all triggers on the table, or only
      user triggers (this option excludes internally generated constraint
      triggers, such as those that are used to implement foreign key
      constraints or deferrable uniqueness and exclusion constraints).
      Disabling or enabling internally generated constraint triggers
      requires superuser privileges; it should be done with caution since
      of course the integrity of the constraint cannot be guaranteed if the
      triggers are not executed.
     </para>
________________________________________________________-->
     <para>
      这些形式配置了属于表的触发器的触发。
      禁用的触发器仍然为系统所知，但在其触发事件发生时不会被执行。
      （对于延迟触发器，启用状态在事件发生时检查，而不是在触发器函数实际执行时。）
      可以禁用或启用指定名称的单个触发器，或表上的所有触发器，或仅用户触发器
      （此选项排除内部生成的约束触发器，例如用于实现外键约束或可延迟的唯一性和排他性约束的触发器）。
      禁用或启用内部生成的约束触发器需要超级用户权限；应谨慎进行，因为如果不执行触发器，则约束的完整性无法保证。
     </para>
<!-- pgdoc-cn_end sig_en=28abc31adf66cbcbe6ed748fa6213642 -->

<!-- pgdoc-cn_start sig_en=503f93b12f367a33b205623fcaedb4ac sig_cn_org=7d6c0c751d073291fe3b7f9ec06a5865 source=15.7 
     <para>
      The trigger firing mechanism is also affected by the configuration
      variable <xref linkend="guc-session-replication-role"/>. Simply enabled
      triggers (the default) will fire when the replication role is <quote>origin</quote>
      (the default) or <quote>local</quote>. Triggers configured as <literal>ENABLE
      REPLICA</literal> will only fire if the session is in <quote>replica</quote>
      mode, and triggers configured as <literal>ENABLE ALWAYS</literal> will
      fire regardless of the current replication role.
     </para>
________________________________________________________-->
     <para>
      触发器触发机制也受配置变量<xref linkend="guc-session-replication-role"/>的影响。
      简单启用的触发器（默认）将在复制角色为<quote>origin</quote>（默认）或<quote>local</quote>时触发。
      配置为<literal>ENABLE REPLICA</literal>的触发器只会在会话处于<quote>replica</quote>模式时触发，
      而配置为<literal>ENABLE ALWAYS</literal>的触发器将在当前复制角色无关时触发。
</para>
<!-- pgdoc-cn_end sig_en=503f93b12f367a33b205623fcaedb4ac -->

<!-- pgdoc-cn_start sig_en=016c9cfb44fc9fc8e918039716a1f4ca sig_cn_org=97871a6adbc88ca291924213b1f4ee99 source=15.7 
     <para>
      The effect of this mechanism is that in the default configuration,
      triggers do not fire on replicas.  This is useful because if a trigger
      is used on the origin to propagate data between tables, then the
      replication system will also replicate the propagated data; so the
      trigger should not fire a second time on the replica, because that would
      lead to duplication.  However, if a trigger is used for another purpose
      such as creating external alerts, then it might be appropriate to set it
      to <literal>ENABLE ALWAYS</literal> so that it is also fired on
      replicas.
     </para>
________________________________________________________-->
     <para>
      这种机制的效果是，在默认配置中，触发器不会在副本上触发。这是有用的，因为如果在原始表上使用触发器来传播数据，
      那么复制系统也会复制传播的数据；因此触发器不应该在副本上第二次触发，因为那会导致重复。然而，如果触发器用于
      其他目的，比如创建外部警报，那么可能适合将其设置为<literal>ENABLE ALWAYS</literal>，以便在副本上也触发。
     </para>
<!-- pgdoc-cn_end sig_en=016c9cfb44fc9fc8e918039716a1f4ca -->

<!-- pgdoc-cn_start sig_en=b47862d3bc235b071fabd5fd75d8bd4e sig_cn_org=73e9ed595770e8025fb6bb2d8cdd0f5e source=15.7 
     <para>
      When this command is applied to a partitioned table, the states of
      corresponding clone triggers in the partitions are updated too,
      unless <literal>ONLY</literal> is specified.
     </para>
________________________________________________________-->
     <para>
      当该命令应用于分区表时，分区中对应的克隆触发器的状态也会被更新，除非指定了<literal>ONLY</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=b47862d3bc235b071fabd5fd75d8bd4e -->

<!-- pgdoc-cn_start sig_en=8b5b9356e33621e5dda3da7e640281b3 sig_cn_org=b0883060af8e9b96800afcd0c3b517f1 source=15.7 
     <para>
      This command acquires a <literal>SHARE ROW EXCLUSIVE</literal> lock.
     </para>
________________________________________________________-->
     <para>
      这个命令获取一个<literal>SHARE ROW EXCLUSIVE</literal>锁。
     </para>
<!-- pgdoc-cn_end sig_en=8b5b9356e33621e5dda3da7e640281b3 -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=5bb199a4405568d6ac93741c74809945 sig_cn_org=062f9e49026b1fbb6c227a910689d4cb source=15.7 
    <term><literal>DISABLE</literal>/<literal>ENABLE [ REPLICA | ALWAYS ] RULE</literal></term>
________________________________________________________-->
    <term><literal>DISABLE</literal>/<literal>ENABLE [ REPLICA | ALWAYS ] RULE</literal></term>
<!-- pgdoc-cn_end sig_en=5bb199a4405568d6ac93741c74809945 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=dbbfad56cee679c23c7c077579b6f809 sig_cn_org=b67611d8bd71140182e3a5b84871e104 source=15.7 
     <para>
      These forms configure the firing of rewrite rules belonging to the table.
      A disabled rule is still known to the system, but is not applied
      during query rewriting. The semantics are as for disabled/enabled
      triggers. This configuration is ignored for <literal>ON SELECT</literal> rules, which
      are always applied in order to keep views working even if the current
      session is in a non-default replication role.
     </para>
________________________________________________________-->
     <para>
      这些形式配置了属于表的重写规则的触发。
      禁用的规则仍然为系统所知，但在查询重写期间不会应用。
      语义与禁用/启用触发器相同。对于<literal>ON SELECT</literal>规则，此配置将被忽略，
      这些规则始终会被应用，以确保视图在当前会话处于非默认复制角色时仍然正常工作。
     </para>
<!-- pgdoc-cn_end sig_en=dbbfad56cee679c23c7c077579b6f809 -->

<!-- pgdoc-cn_start sig_en=dce4d13b984b942b7f512cd4592c6864 sig_cn_org=aa6173ee9a73b71f7ccea446869b5186 source=15.7 
     <para>
      The rule firing mechanism is also affected by the configuration variable
      <xref linkend="guc-session-replication-role"/>, analogous to triggers as
      described above.
     </para>
________________________________________________________-->
     <para>
      规则触发机制也受配置变量<xref linkend="guc-session-replication-role"/>的影响，类似于上面描述的触发器。
     </para>
<!-- pgdoc-cn_end sig_en=dce4d13b984b942b7f512cd4592c6864 -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=ee39b208470a83d2c462f13b6c197c6c sig_cn_org=615a3cd521a6612ce21d3e7c1bc8e471 source=15.7 
    <term><literal>DISABLE</literal>/<literal>ENABLE ROW LEVEL SECURITY</literal></term>
________________________________________________________-->
    <term><literal>DISABLE</literal>/<literal>ENABLE ROW LEVEL SECURITY</literal></term>
<!-- pgdoc-cn_end sig_en=ee39b208470a83d2c462f13b6c197c6c -->
    <listitem>
<!-- pgdoc-cn_start sig_en=fb09065adee23197955240848d000d9c sig_cn_org=3bbe570bc0ea2c5e5a45c6072671bc53 source=15.7 
     <para>
      These forms control the application of row security policies belonging
      to the table.  If enabled and no policies exist for the table, then a
      default-deny policy is applied.  Note that policies can exist for a table
      even if row-level security is disabled.  In this case, the policies will
      <emphasis>not</emphasis> be applied and the policies will be ignored.
      See also
      <link linkend="sql-createpolicy"><command>CREATE POLICY</command></link>.
     </para>
________________________________________________________-->
     <para>
      这些形式控制着属于表的行安全策略的应用。如果启用并且表没有任何策略，
      那么将应用默认拒绝策略。请注意，即使行级安全已禁用，表仍然可以存在策略。
      在这种情况下，策略将<emphasis>不会</emphasis>被应用，策略将被忽略。
      另请参阅
      <link linkend="sql-createpolicy"><command>CREATE POLICY</command></link>。
     </para>
<!-- pgdoc-cn_end sig_en=fb09065adee23197955240848d000d9c -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=72794796cd3c63ca819f8f3789c11ed9 sig_cn_org=07284569b78f894d0a0f748ce62aa16f source=15.7 
    <term><literal>NO FORCE</literal>/<literal>FORCE ROW LEVEL SECURITY</literal></term>
________________________________________________________-->
    <term><literal>NO FORCE</literal>/<literal>FORCE ROW LEVEL SECURITY</literal></term>
<!-- pgdoc-cn_end sig_en=72794796cd3c63ca819f8f3789c11ed9 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=123dc1413529756881429160b73600b5 sig_cn_org=cd53378aec17f4ceac0d4e173f23fb25 source=15.7 
     <para>
      These forms control the application of row security policies belonging
      to the table when the user is the table owner.  If enabled, row-level
      security policies will be applied when the user is the table owner.  If
      disabled (the default) then row-level security will not be applied when
      the user is the table owner.
      See also
      <link linkend="sql-createpolicy"><command>CREATE POLICY</command></link>.
     </para>
________________________________________________________-->
     <para>
      这些形式控制了用户是表所有者时对表的行安全策略的应用。如果启用，当用户是表所有者时将应用行级安全策略。
	  如果禁用（默认情况下），则当用户是表所有者时不会应用行级安全性。
      另请参阅
      <link linkend="sql-createpolicy"><command>CREATE POLICY</command></link>。
     </para>
<!-- pgdoc-cn_end sig_en=123dc1413529756881429160b73600b5 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CLUSTER ON</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=79c979a7df4dc1209e2546ac3e8c7270 sig_cn_org=c107f75cb5aa32f18667854f9bd37023 source=15.7 
     <para>
      This form selects the default index for future
      <link linkend="sql-cluster"><command>CLUSTER</command></link>
      operations.  It does not actually re-cluster the table.
     </para>
________________________________________________________-->
     <para>
      这个表单选择了将来<link linkend="sql-cluster"><command>CLUSTER</command></link>操作的默认索引。它实际上并不重新对表进行集群。
     </para>
<!-- pgdoc-cn_end sig_en=79c979a7df4dc1209e2546ac3e8c7270 -->
<!-- pgdoc-cn_start sig_en=2f16edba52f4e8e4d7fe877156259253 sig_cn_org=7099d83d77d1f54a637ba48a9dde80a0 source=15.7 
     <para>
      Changing cluster options acquires a <literal>SHARE UPDATE EXCLUSIVE</literal> lock.
     </para>
________________________________________________________-->
     <para>
      更改集群选项会获取一个<literal>SHARE UPDATE EXCLUSIVE</literal>锁。
     </para>
<!-- pgdoc-cn_end sig_en=2f16edba52f4e8e4d7fe877156259253 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITHOUT CLUSTER</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=c6add859296116920ce688e37040f1e1 sig_cn_org=7a5cfdf61501dbdfd2bbaf63ee417779 source=15.7 
     <para>
      This form removes the most recently used
      <link linkend="sql-cluster"><command>CLUSTER</command></link>
      index specification from the table.  This affects
      future cluster operations that don't specify an index.
     </para>
________________________________________________________-->
     <para>
      这个命令从表中移除最近使用的
      <link linkend="sql-cluster"><command>CLUSTER</command></link>
      索引规范。这会影响未来不指定索引的集群操作。
     </para>
<!-- pgdoc-cn_end sig_en=c6add859296116920ce688e37040f1e1 -->
<!-- pgdoc-cn_start sig_en=2f16edba52f4e8e4d7fe877156259253 sig_cn_org=7099d83d77d1f54a637ba48a9dde80a0 source=15.7 
     <para>
      Changing cluster options acquires a <literal>SHARE UPDATE EXCLUSIVE</literal> lock.
     </para>
________________________________________________________-->
     <para>
      更改集群选项会获取一个<literal>SHARE UPDATE EXCLUSIVE</literal>锁。
     </para>
<!-- pgdoc-cn_end sig_en=2f16edba52f4e8e4d7fe877156259253 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITHOUT OIDS</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=b9d75a57da9278b396932af625ecfc3c sig_cn_org=1db7a62b3bc7cbf641977ed80c81befb source=15.7 
     <para>
      Backward-compatible syntax for removing the <literal>oid</literal>
      system column.  As <literal>oid</literal> system columns cannot be
      added anymore, this never has an effect.
     </para>
________________________________________________________-->
     <para>
      向后兼容的语法，用于移除<literal>oid</literal>系统列。由于无法再添加<literal>oid</literal>系统列，因此这永远不会产生影响。
     </para>
<!-- pgdoc-cn_end sig_en=b9d75a57da9278b396932af625ecfc3c -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET ACCESS METHOD</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=9241cbd88919241345c32507c7b13903 sig_cn_org=1d4bdc9805d3512a641f19653b807319 source=15.7 
     <para>
      This form changes the access method of the table by rewriting it. See
      <xref linkend="tableam"/> for more information.
     </para>
________________________________________________________-->
     <para>
      这个表单通过重写来改变表的访问方法。更多信息请参见<xref linkend="tableam"/>。
     </para>
<!-- pgdoc-cn_end sig_en=9241cbd88919241345c32507c7b13903 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET TABLESPACE</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=7f4517d9cf489e8021555a9ff6f177a8 sig_cn_org=f5f8fba72a7b5901b3182f8a2b93b694 source=15.7 
     <para>
      This form changes the table's tablespace to the specified tablespace and
      moves the data file(s) associated with the table to the new tablespace.
      Indexes on the table, if any, are not moved; but they can be moved
      separately with additional <literal>SET TABLESPACE</literal> commands.
      When applied to a partitioned table, nothing is moved, but any
      partitions created afterwards with
      <command>CREATE TABLE PARTITION OF</command> will use that tablespace,
      unless overridden by a <literal>TABLESPACE</literal> clause.
     </para>
________________________________________________________-->
     <para>
      这个表单将表的表空间更改为指定的表空间，并将与表关联的数据文件移动到新的表空间。
      表上的索引（如果有）不会被移动；但它们可以通过额外的<literal>SET TABLESPACE</literal>命令单独移动。
      当应用于分区表时，不会移动任何内容，但之后使用<command>CREATE TABLE PARTITION OF</command>创建的任何分区将使用该表空间，
      除非被<literal>TABLESPACE</literal>子句覆盖。
</para>
<!-- pgdoc-cn_end sig_en=7f4517d9cf489e8021555a9ff6f177a8 -->

<!-- pgdoc-cn_start sig_en=38fbdaea0f29ad27e0e73fb898ec7409 sig_cn_org=fa7ef27a274815a7929db597e8b75cff source=15.7 
     <para>
      All tables in the current database in a tablespace can be moved by using
      the <literal>ALL IN TABLESPACE</literal> form, which will lock all tables
      to be moved first and then move each one.  This form also supports
      <literal>OWNED BY</literal>, which will only move tables owned by the
      roles specified.  If the <literal>NOWAIT</literal> option is specified
      then the command will fail if it is unable to acquire all of the locks
      required immediately.  Note that system catalogs are not moved by this
      command; use <command>ALTER DATABASE</command> or explicit
      <command>ALTER TABLE</command> invocations instead if desired.  The
      <literal>information_schema</literal> relations are not considered part
      of the system catalogs and will be moved.
      See also
      <link linkend="sql-createtablespace"><command>CREATE TABLESPACE</command></link>.
     </para>
________________________________________________________-->
     <para>
      当前数据库中的所有表都可以通过使用<literal>ALL IN TABLESPACE</literal>形式来移动，
      这将首先锁定要移动的所有表，然后逐个移动。此形式还支持<literal>OWNED BY</literal>，
      它只会移动由指定角色拥有的表。如果指定了<literal>NOWAIT</literal>选项，
      则如果无法立即获取所需的所有锁定，则命令将失败。请注意，系统目录不会被此命令移动；
      如果需要，可以使用<command>ALTER DATABASE</command>或显式的<command>ALTER TABLE</command>调用。
      <literal>information_schema</literal>关系不被视为系统目录的一部分，将被移动。
      另请参阅<link linkend="sql-createtablespace"><command>CREATE TABLESPACE</command></link>。
</para>
<!-- pgdoc-cn_end sig_en=38fbdaea0f29ad27e0e73fb898ec7409 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET { LOGGED | UNLOGGED }</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=7d5881819013de9cdbb5ab45e55bb0dc sig_cn_org=f62e604dd40295ee3563346abb673f1f source=15.7 
     <para>
      This form changes the table from unlogged to logged or vice-versa
      (see <xref linkend="sql-createtable-unlogged"/>).  It cannot be applied
      to a temporary table.
     </para>
________________________________________________________-->
     <para>
      这个表单将表从未记录更改为记录，反之亦然
      (参见<xref linkend="sql-createtable-unlogged"/>）。它不能应用
      到临时表。
     </para>
<!-- pgdoc-cn_end sig_en=7d5881819013de9cdbb5ab45e55bb0dc -->

<!-- pgdoc-cn_start sig_en=6bd7fff66dfb6e200611aaf9a5f2ccf8 sig_cn_org=94d1db7116244271d765ea6ed9839b81 source=15.7 
     <para>
      This also changes the persistence of any sequences linked to the table
      (for identity or serial columns).  However, it is also possible to
      change the persistence of such sequences separately.
     </para>
________________________________________________________-->
     <para>
      这也会改变与表相关联的任何序列的持久性（用于标识或序列列）。然而，也可以单独改变这些序列的持久性。
     </para>
<!-- pgdoc-cn_end sig_en=6bd7fff66dfb6e200611aaf9a5f2ccf8 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] )</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=d9e43ff5ba4c5ab01aedcfe52d15857f sig_cn_org=1c4aa0be4bfc5f2c1de7c875b007c912 source=15.7 
     <para>
      This form changes one or more storage parameters for the table.  See
      <xref linkend="sql-createtable-storage-parameters"/> in the
      <link linkend="sql-createtable"><command>CREATE TABLE</command></link> documentation
      for details on the available parameters.  Note that the table contents
      will not be modified immediately by this command; depending on the
      parameter you might need to rewrite the table to get the desired effects.
      That can be done with <link linkend="sql-vacuum"><command>VACUUM
      FULL</command></link>, <link linkend="sql-cluster"><command>CLUSTER</command></link> or one of the forms
      of <command>ALTER TABLE</command> that forces a table rewrite.
      For planner related parameters, changes will take effect from the next
      time the table is locked so currently executing queries will not be
      affected.
     </para>
________________________________________________________-->
     <para>
      这个表单用于更改表的一个或多个存储参数。请参阅
      <xref linkend="sql-createtable-storage-parameters"/>中的
      <link linkend="sql-createtable"><command>CREATE TABLE</command></link>文档
      以获取有关可用参数的详细信息。请注意，此命令不会立即修改表内容；
      根据参数，您可能需要重写表以获得所需的效果。
      可以使用 <link linkend="sql-vacuum"><command>VACUUM
      FULL</command></link>、<link linkend="sql-cluster"><command>CLUSTER</command></link>或强制表重写的一种形式
      的<command>ALTER TABLE</command>来执行此操作。
      对于与规划器相关的参数，更改将在下次锁定表时生效，因此当前正在执行的查询不会受到影响。
     </para>
<!-- pgdoc-cn_end sig_en=d9e43ff5ba4c5ab01aedcfe52d15857f -->

<!-- pgdoc-cn_start sig_en=71d45f6e555b84b31563a4756362f6b8 sig_cn_org=9ba8dced3b5d2ef5bd9f0372e145be29 source=15.7 
     <para>
      <literal>SHARE UPDATE EXCLUSIVE</literal> lock will be taken for
      fillfactor, toast and autovacuum storage parameters, as well as the
      planner parameter <varname>parallel_workers</varname>.
     </para>
________________________________________________________-->
     <para>
      <literal>SHARE UPDATE EXCLUSIVE</literal>锁将被用于fillfactor、toast和autovacuum存储参数，
      以及planner参数<varname>parallel_workers</varname>。
     </para>
<!-- pgdoc-cn_end sig_en=71d45f6e555b84b31563a4756362f6b8 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RESET ( <replaceable class="parameter">storage_parameter</replaceable> [, ... ] )</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=a5a2da31a2279aecf97cb5fe483044c8 sig_cn_org=86ffeca1793e1b80ba1614ed0fe46156 source=15.7 
     <para>
      This form resets one or more storage parameters to their
      defaults.  As with <literal>SET</literal>, a table rewrite might be
      needed to update the table entirely.
     </para>
________________________________________________________-->
     <para>
      这个表单将一个或多个存储参数重置为它们的默认值。与<literal>SET</literal>一样，可能需要进行表重写来完全更新表。
     </para>
<!-- pgdoc-cn_end sig_en=a5a2da31a2279aecf97cb5fe483044c8 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INHERIT <replaceable class="parameter">parent_table</replaceable></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=600b6647f52d34dc906b013d513a4c1d sig_cn_org=fe71d767c538ca9badf662697adac840 source=15.7 
     <para>
      This form adds the target table as a new child of the specified parent
      table.  Subsequently, queries against the parent will include records
      of the target table.  To be added as a child, the target table must
      already contain all the same columns as the parent (it could have
      additional columns, too).  The columns must have matching data types,
      and if they have <literal>NOT NULL</literal> constraints in the parent
      then they must also have <literal>NOT NULL</literal> constraints in the
      child.
     </para>
________________________________________________________-->
     <para>
      这个表单将目标表作为指定父表的新子表添加。随后，针对父表的查询将包括目标表的记录。
	  要作为子表添加，目标表必须已经包含与父表相同的所有列（也可以有额外的列）。
	  列必须具有匹配的数据类型，如果它们在父表中具有<literal>NOT NULL</literal>约束，
	  那么它们在子表中也必须具有<literal>NOT NULL</literal>约束。
     </para>
<!-- pgdoc-cn_end sig_en=600b6647f52d34dc906b013d513a4c1d -->

<!-- pgdoc-cn_start sig_en=c3b49744e9b8d8ad5975dd7c119a36db sig_cn_org=85f588491fd94fb89f5c0026bfd1bf14 source=15.7 
     <para>
      There must also be matching child-table constraints for all
      <literal>CHECK</literal> constraints of the parent, except those
      marked non-inheritable (that is, created with <literal>ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT</literal>)
      in the parent, which are ignored; all child-table constraints matched
      must not be marked non-inheritable.
      Currently
      <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, and
      <literal>FOREIGN KEY</literal> constraints are not considered, but
      this might change in the future.
     </para>
________________________________________________________-->
     <para>
      对于父表的所有<literal>CHECK</literal>约束，还必须有匹配的子表约束，除非父表中有标记为非继承的约束
      （即使用<literal>ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT</literal>创建的约束），这些约束将被忽略；
      所有匹配的子表约束不能被标记为非继承。
      目前<literal>UNIQUE</literal>、<literal>PRIMARY KEY</literal>和<literal>FOREIGN KEY</literal>约束不被考虑，
      但这可能会在将来发生变化。
     </para>
<!-- pgdoc-cn_end sig_en=c3b49744e9b8d8ad5975dd7c119a36db -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NO INHERIT <replaceable class="parameter">parent_table</replaceable></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=4082e29d8a5041fc540cb6b4a05e1abe sig_cn_org=cb9419b5da3d5c9883dc965743fc7029 source=15.7 
     <para>
      This form removes the target table from the list of children of the
      specified parent table.
      Queries against the parent table will no longer include records drawn
      from the target table.
     </para>
________________________________________________________-->
     <para>
      这个表单将目标表从指定父表的子表列表中移除。
      对父表的查询将不再包括来自目标表的记录。
     </para>
<!-- pgdoc-cn_end sig_en=4082e29d8a5041fc540cb6b4a05e1abe -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OF <replaceable class="parameter">type_name</replaceable></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=753a020881fc7e2f1ccc26ba64558b7c sig_cn_org=faba168cc4901958d96808bdeb508216 source=15.7 
     <para>
      This form links the table to a composite type as though <command>CREATE
      TABLE OF</command> had formed it.  The table's list of column names and types
      must precisely match that of the composite type.  The table must
      not inherit from any other table.  These restrictions ensure
      that <command>CREATE TABLE OF</command> would permit an equivalent table
      definition.
     </para>
________________________________________________________-->
     <para>
      这个表单将表与一个复合类型链接起来，就好像<command>CREATE TABLE OF</command>已经形成了它。
      表的列名和类型列表必须与复合类型的完全匹配。表不能继承自任何其他表。
      这些限制确保<command>CREATE TABLE OF</command>将允许一个等效的表定义。
</para>
<!-- pgdoc-cn_end sig_en=753a020881fc7e2f1ccc26ba64558b7c -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NOT OF</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=6b59cb6c155496ec50f8d6c2f06cae24 sig_cn_org=285104295b6a69924633b5c2e75372b8 source=15.7 
     <para>
      This form dissociates a typed table from its type.
     </para>
________________________________________________________-->
     <para>
      这个表单将一个类型化表格与其类型分离。
     </para>
<!-- pgdoc-cn_end sig_en=6b59cb6c155496ec50f8d6c2f06cae24 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OWNER TO</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=e84bb3cf149baa5cf8620b764732940f sig_cn_org=6335ed9a74efe5548301e28f0faa30dd source=15.7 
     <para>
      This form changes the owner of the table, sequence, view, materialized view,
      or foreign table to the specified user.
     </para>
________________________________________________________-->
     <para>
      这个表单将表、序列、视图、物化视图或外部表的所有者更改为指定的用户。
     </para>
<!-- pgdoc-cn_end sig_en=e84bb3cf149baa5cf8620b764732940f -->
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-replica-identity">
    <term><literal>REPLICA IDENTITY</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=606aebadda2cc3da0c11b8e87c24db34 sig_cn_org=5a9b28b38047ff3088d255e894a09d90 source=15.7 
     <para>
      This form changes the information which is written to the write-ahead log
      to identify rows which are updated or deleted.
      In most cases, the old value of each column is only logged if it differs
      from the new value; however, if the old value is stored externally, it is
      always logged regardless of whether it changed.
      This option has no effect except when logical replication is in use.
     <variablelist>
      <varlistentry>
       <term><literal>DEFAULT</literal></term>
       <listitem>
        <para>
         Records the old values of the columns of the primary key, if any.
         This is the default for non-system tables.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>USING INDEX <replaceable class="parameter">index_name</replaceable></literal></term>
       <listitem>
        <para>
         Records the old values of the columns covered by the named index,
         that must be unique, not partial, not deferrable, and include only
         columns marked <literal>NOT NULL</literal>. If this index is
         dropped, the behavior is the same as <literal>NOTHING</literal>.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>FULL</literal></term>
       <listitem>
        <para>
         Records the old values of all columns in the row.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>NOTHING</literal></term>
       <listitem>
        <para>
         Records no information about the old row. This is the default for
         system tables.
        </para>
       </listitem>
      </varlistentry>
     </variablelist></para>
________________________________________________________-->
     <para>
      这个表单改变了写入预写式日志的信息，以标识被更新或删除的行。
      在大多数情况下，只有当旧值与新值不同时，才记录每列的旧值；但是，如果旧值被外部存储，无论是否更改，它都会被记录。
      除非逻辑复制正在使用，否则此选项无效。
     <variablelist>
      <varlistentry>
       <term><literal>DEFAULT</literal></term>
       <listitem>
        <para>
         记录主键（如果有）的列的旧值。这是非系统表的默认值。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>USING INDEX <replaceable class="parameter">index_name</replaceable></literal></term>
       <listitem>
        <para>
         记录由指定索引覆盖的列的旧值，该索引必须是唯一的、非部分的、不可延迟的，并且只包括标记为<literal>NOT NULL</literal>的列。
         如果删除此索引，则行为与<literal>NOTHING</literal>相同。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>FULL</literal></term>
       <listitem>
        <para>
         记录行中所有列的旧值。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><literal>NOTHING</literal></term>
       <listitem>
        <para>
         不记录有关旧行的任何信息。这是系统表的默认值。
        </para>
       </listitem>
      </varlistentry>
     </variablelist></para>
<!-- pgdoc-cn_end sig_en=606aebadda2cc3da0c11b8e87c24db34 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RENAME</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=d577df66449e8d2c7bb72f4e830489d9 sig_cn_org=699ddbd71d34341d9959ce6d92c28b4a source=15.7 
     <para>
      The <literal>RENAME</literal> forms change the name of a table
      (or an index, sequence, view, materialized view, or foreign table), the
      name of an individual column in a table, or the name of a constraint of
      the table.  When renaming a constraint that has an underlying index,
      the index is renamed as well.
      There is no effect on the stored data.
     </para>
________________________________________________________-->
     <para>
      <literal>RENAME</literal>表单用于更改表（或索引、序列、视图、物化视图或外部表）的名称，
      表中单个列的名称，或表的约束的名称。重命名具有基础索引的约束时，索引也会被重命名。
      存储的数据不受影响。
</para>
<!-- pgdoc-cn_end sig_en=d577df66449e8d2c7bb72f4e830489d9 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET SCHEMA</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=e7b5cf247cdd059130723c9f37aec052 sig_cn_org=35e3a6df80dac0701c5b78ac78fbcd37 source=15.7 
     <para>
      This form moves the table into another schema.  Associated indexes,
      constraints, and sequences owned by table columns are moved as well.
     </para>
________________________________________________________-->
     <para>
      这个表单将表移动到另一个模式中。与表列相关的索引、约束和序列也将被移动。
     </para>
<!-- pgdoc-cn_end sig_en=e7b5cf247cdd059130723c9f37aec052 -->
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-attach-partition">
    <term><literal>ATTACH PARTITION <replaceable class="parameter">partition_name</replaceable> { FOR VALUES <replaceable class="parameter">partition_bound_spec</replaceable> | DEFAULT }</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=9de65f6e6e45d8c677c2779d59078415 sig_cn_org=a6a0f8455333b96dd9f9984744ade9d7 source=15.7 
     <para>
      This form attaches an existing table (which might itself be partitioned)
      as a partition of the target table. The table can be attached
      as a partition for specific values using <literal>FOR VALUES</literal>
      or as a default partition by using <literal>DEFAULT</literal>.
      For each index in the target table, a corresponding
      one will be created in the attached table; or, if an equivalent
      index already exists, it will be attached to the target table's index,
      as if <command>ALTER INDEX ATTACH PARTITION</command> had been executed.
      Note that if the existing table is a foreign table, it is currently not
      allowed to attach the table as a partition of the target table if there
      are <literal>UNIQUE</literal> indexes on the target table.  (See also
      <xref linkend="sql-createforeigntable"/>.)  For each user-defined
      row-level trigger that exists in the target table, a corresponding one
      is created in the attached table.
     </para>
________________________________________________________-->
     <para>
      这个形式将一个现有的表（可能本身已经被分区）作为目标表的一个分区附加上去。
      可以使用<literal>FOR VALUES</literal>将表作为特定值的分区附加上去，
      或者使用<literal>DEFAULT</literal>将其作为默认分区附加上去。
      对于目标表中的每个索引，附加表中将创建一个相应的索引；
      或者，如果已经存在等效的索引，则将其附加到目标表的索引上，
      就像执行了<command>ALTER INDEX ATTACH PARTITION</command>一样。
      请注意，如果现有表是一个外部表，当前不允许将该表作为目标表的分区附加上去，
      如果目标表上有<literal>UNIQUE</literal>索引。（另请参见<xref linkend="sql-createforeigntable"/>。）
      对于目标表中存在的每个用户定义的行级触发器，将在附加表中创建一个相应的触发器。
     </para>
<!-- pgdoc-cn_end sig_en=9de65f6e6e45d8c677c2779d59078415 -->

<!-- pgdoc-cn_start sig_en=49889b23b7b26beae385bcfa3c081fa7 sig_cn_org=bab111f3bae00538df7c33f6e1a8cf98 source=15.7 
     <para>
      A partition using <literal>FOR VALUES</literal> uses same syntax for
      <replaceable class="parameter">partition_bound_spec</replaceable> as
      <link linkend="sql-createtable"><command>CREATE TABLE</command></link>.  The partition bound specification
      must correspond to the partitioning strategy and partition key of the
      target table.  The table to be attached must have all the same columns
      as the target table and no more; moreover, the column types must also
      match.  Also, it must have all the <literal>NOT NULL</literal> and
      <literal>CHECK</literal> constraints of the target table.  Currently
      <literal>FOREIGN KEY</literal> constraints are not considered.
      <literal>UNIQUE</literal> and <literal>PRIMARY KEY</literal> constraints
      from the parent table will be created in the partition, if they don't
      already exist.
      If any of the <literal>CHECK</literal> constraints of the table being
      attached are marked <literal>NO INHERIT</literal>, the command will fail;
      such constraints must be recreated without the
      <literal>NO INHERIT</literal> clause.
     </para>
________________________________________________________-->
     <para>
      使用<literal>FOR VALUES</literal>的分区与<replaceable class="parameter">partition_bound_spec</replaceable>的语法相同，
      如<replaceable class="parameter">partition_bound_spec</replaceable>与
      <link linkend="sql-createtable"><command>CREATE TABLE</command></link>中的相同。
      分区边界规范必须与目标表的分区策略和分区键对应。
      要附加的表必须具有与目标表相同且不多的所有列；此外，列类型也必须匹配。
      此外，它必须具有目标表的所有<literal>NOT NULL</literal>和<literal>CHECK</literal>约束。
      目前不考虑<literal>FOREIGN KEY</literal>约束。
      如果父表中不存在<literal>UNIQUE</literal>和<literal>PRIMARY KEY</literal>约束，
      则将在分区中创建这些约束。
      如果要附加的表的任何<literal>CHECK</literal>约束标记为<literal>NO INHERIT</literal>，
      则命令将失败；这些约束必须重新创建而不带<literal>NO INHERIT</literal>子句。
</para>
<!-- pgdoc-cn_end sig_en=49889b23b7b26beae385bcfa3c081fa7 -->

<!-- pgdoc-cn_start sig_en=568259aab3534e8b5cf1232caf553c25 sig_cn_org=5705052b11bcc4c90b926df284d40e58 source=15.7 
     <para>
      If the new partition is a regular table, a full table scan is performed
      to check that existing rows in the table do not violate the partition
      constraint. It is possible to avoid this scan by adding a valid
      <literal>CHECK</literal> constraint to the table that allows only
      rows satisfying the desired partition constraint before running this
      command. The <literal>CHECK</literal> constraint will be used to
      determine that the table need not be scanned to validate the partition
      constraint. This does not work, however, if any of the partition keys
      is an expression and the partition does not accept
      <literal>NULL</literal> values. If attaching a list partition that will
      not accept <literal>NULL</literal> values, also add a
      <literal>NOT NULL</literal> constraint to the partition key column,
      unless it's an expression.
     </para>
________________________________________________________-->
     <para>
      如果新分区是一个常规表，将执行全表扫描以检查表中现有行是否违反分区约束。
      可以通过向表添加一个有效的<literal>CHECK</literal>约束来避免此扫描，
      该约束只允许满足所需分区约束的行在运行此命令之前。 
      <literal>CHECK</literal>约束将用于确定无需扫描表以验证分区约束。
      但是，如果分区键中的任何一个是表达式，并且分区不接受<literal>NULL</literal>值，
      则此方法不起作用。如果附加的列表分区不接受<literal>NULL</literal>值，
      还需向分区键列添加<literal>NOT NULL</literal>约束，除非它是一个表达式。
     </para>
<!-- pgdoc-cn_end sig_en=568259aab3534e8b5cf1232caf553c25 -->

<!-- pgdoc-cn_start sig_en=357f2e3140c8f49b645eecd18311a738 sig_cn_org=4cae37bf3fda48fead6b550337b208cb source=15.7 
     <para>
      If the new partition is a foreign table, nothing is done to verify
      that all the rows in the foreign table obey the partition constraint.
      (See the discussion in <xref linkend="sql-createforeigntable"/> about
      constraints on the foreign table.)
     </para>
________________________________________________________-->
     <para>
      如果新分区是一个外部表，不会对外部表中的所有行进行验证，以确保符合分区约束。
      （参见<xref linkend="sql-createforeigntable"/>中关于外部表约束的讨论。）
</para>
<!-- pgdoc-cn_end sig_en=357f2e3140c8f49b645eecd18311a738 -->

<!-- pgdoc-cn_start sig_en=ab78d65b711239706d8c71f2bfc57b1b sig_cn_org=d01c78f3e7814ce0b6f8ecce178e1081 source=15.7 
     <para>
      When a table has a default partition, defining a new partition changes
      the partition constraint for the default partition. The default
      partition can't contain any rows that would need to be moved to the new
      partition, and will be scanned to verify that none are present. This
      scan, like the scan of the new partition, can be avoided if an
      appropriate <literal>CHECK</literal> constraint is present. Also like
      the scan of the new partition, it is always skipped when the default
      partition is a foreign table.
     </para>
________________________________________________________-->
     <para>
      当表具有默认分区时，定义新分区会改变默认分区的分区约束。默认分区不能包含任何需要移动到新分区的行，并将扫描以验证是否存在这些行。
	  如果存在适当的<literal>CHECK</literal>约束，则可以避免这种扫描。与新分区的扫描一样，当默认分区是外部表时，总是跳过这种扫描。
     </para>
<!-- pgdoc-cn_end sig_en=ab78d65b711239706d8c71f2bfc57b1b -->

<!-- pgdoc-cn_start sig_en=b541bc706ad7e560963ca5cba1ebaf0a sig_cn_org=5871b2e5317adb8b9980a71e332e4980 source=15.7 
     <para>
      Attaching a partition acquires a
      <literal>SHARE UPDATE EXCLUSIVE</literal> lock on the parent table,
      in addition to the <literal>ACCESS EXCLUSIVE</literal> locks on the table
      being attached and on the default partition (if any).
     </para>
________________________________________________________-->
     <para>
      附加分区会在父表上获取一个<literal>SHARE UPDATE EXCLUSIVE</literal>锁，
      除了在被附加的表和默认分区（如果有）上获取<literal>ACCESS EXCLUSIVE</literal>锁。
     </para>
<!-- pgdoc-cn_end sig_en=b541bc706ad7e560963ca5cba1ebaf0a -->

<!-- pgdoc-cn_start sig_en=d9a91d02e18e0e4ad58a89d82abd157e sig_cn_org=921a2274cc931229518f14f3708fbb6c source=15.7 
     <para>
      Further locks must also be held on all sub-partitions if the table being
      attached is itself a partitioned table.  Likewise if the default
      partition is itself a partitioned table.  The locking of the
      sub-partitions can be avoided by adding a <literal>CHECK</literal>
      constraint as described in
      <xref linkend="ddl-partitioning-declarative-maintenance"/>.
     </para>
________________________________________________________-->
     <para>
      如果要附加的表本身是分区表，则还必须在所有子分区上保持锁定。同样，如果默认分区本身是分区表，则也必须保持锁定。
      通过添加如在<xref linkend="ddl-partitioning-declarative-maintenance"/>中描述的<literal>CHECK</literal>约束，可以避免对子分区的锁定。
     </para>
<!-- pgdoc-cn_end sig_en=d9a91d02e18e0e4ad58a89d82abd157e -->
    </listitem>
   </varlistentry>

   <varlistentry id="sql-altertable-detach-partition">
    <term><literal>DETACH PARTITION <replaceable class="parameter">partition_name</replaceable> [ CONCURRENTLY | FINALIZE ]</literal></term>

    <listitem>
<!-- pgdoc-cn_start sig_en=675dfb9234ca9cdcd00feb6284d4142a sig_cn_org=77795fce896ee99e776bd51b97d0b142 source=15.7 
     <para>
      This form detaches the specified partition of the target table.  The detached
      partition continues to exist as a standalone table, but no longer has any
      ties to the table from which it was detached.  Any indexes that were
      attached to the target table's indexes are detached.  Any triggers that
      were created as clones of those in the target table are removed.
      <literal>SHARE</literal> lock is obtained on any tables that reference
      this partitioned table in foreign key constraints.
     </para>
________________________________________________________-->
     <para>
      这个表单会分离目标表的指定分区。被分离的分区将继续存在作为一个独立的表，但不再与它被分离的表有任何联系。
      附加到目标表索引的任何索引都会被分离。创建为目标表克隆的任何触发器都会被移除。
      在外键约束中引用这个分区表的任何表都会获得<literal>SHARE</literal>锁。
     </para>
<!-- pgdoc-cn_end sig_en=675dfb9234ca9cdcd00feb6284d4142a -->
<!-- pgdoc-cn_start sig_en=33eaec44c3dc6d88c4e3e2c3555fc5b3 sig_cn_org=21fc12c3dfa6047a1155094d3d90ee51 source=15.7 
     <para>
      If <literal>CONCURRENTLY</literal> is specified, it runs using a reduced
      lock level to avoid blocking other sessions that might be accessing the
      partitioned table.  In this mode, two transactions are used internally.
      During the first transaction, a <literal>SHARE UPDATE EXCLUSIVE</literal>
      lock is taken on both parent table and partition, and the partition is
      marked as undergoing detach; at that point, the transaction is committed
      and all other transactions using the partitioned table are waited for.
      Once all those transactions have completed, the second transaction
      acquires <literal>SHARE UPDATE EXCLUSIVE</literal> on the partitioned
      table and <literal>ACCESS EXCLUSIVE</literal> on the partition,
      and the detach process completes.  A <literal>CHECK</literal> constraint
      that duplicates the partition constraint is added to the partition.
      <literal>CONCURRENTLY</literal> cannot be run in a transaction block and
      is not allowed if the partitioned table contains a default partition.
     </para>
________________________________________________________-->
     <para>
      如果指定了<literal>CONCURRENTLY</literal>，它将使用降低的锁级别来避免阻塞可能正在访问分区表的其他会话。
      在这种模式下，内部使用两个事务。在第一个事务期间，对父表和分区都采取<literal>SHARE UPDATE EXCLUSIVE</literal>锁，
      并将分区标记为正在分离；在那一点上，事务被提交，并等待使用分区表的所有其他事务。
      一旦所有这些事务都完成，第二个事务将在分区表上获取<literal>SHARE UPDATE EXCLUSIVE</literal>，
      在分区上获取<literal>ACCESS EXCLUSIVE</literal>，并完成分离过程。
      一个重复分区约束的<literal>CHECK</literal>约束被添加到分区中。
      <literal>CONCURRENTLY</literal>不能在事务块中运行，如果分区表包含默认分区，则不允许运行。
     </para>
<!-- pgdoc-cn_end sig_en=33eaec44c3dc6d88c4e3e2c3555fc5b3 -->
<!-- pgdoc-cn_start sig_en=3f06fe31e4dd797155055e25a11cd83f sig_cn_org=bd488f936495298f7c6f01d874ab4c09 source=15.7 
     <para>
      If <literal>FINALIZE</literal> is specified, a previous
      <literal>DETACH CONCURRENTLY</literal> invocation that was canceled or
      interrupted is completed.
      At most one partition in a partitioned table can be pending detach at
      a time.
     </para>
________________________________________________________-->
     <para>
      如果指定了<literal>FINALIZE</literal>，则会完成之前被取消或中断的<literal>DETACH CONCURRENTLY</literal>调用。
      分区表中最多只能有一个分区处于挂起的分离状态。
     </para>
<!-- pgdoc-cn_end sig_en=3f06fe31e4dd797155055e25a11cd83f -->
    </listitem>
   </varlistentry>

  </variablelist>
  </para>

<!-- pgdoc-cn_start sig_en=f9d57d584935267763465c0d27bc8b79 sig_cn_org=None source=14.1 
  <para>
   All the forms of ALTER TABLE that act on a single table, except
   <literal>RENAME</literal>, <literal>SET SCHEMA</literal>,
   <literal>ATTACH PARTITION</literal>, and
   <literal>DETACH PARTITION</literal> can be combined into
   a list of multiple alterations to be applied together.  For example, it
   is possible to add several columns and/or alter the type of several
   columns in a single command.  This is particularly useful with large
   tables, since only one pass over the table need be made.
  </para>
________________________________________________________-->
  <para>
   除了<literal>RENAME</literal>、<literal>SET SCHEMA</literal>、<literal>ATTACH PARTITION</literal>和<literal>DETACH PARTITION</literal>之外，所有形式的ALTER TABLE都作用在单个表上，前面这些形式可以被组合成一个多修改的列表被一起应用。例如，可以在一个命令中增加多个列并且/或者修改多个列的类型。对于大型表来说这会特别有用，因为只需要对表做一趟操作。
  </para>
<!-- pgdoc-cn_end sig_en=f9d57d584935267763465c0d27bc8b79 -->

<!-- pgdoc-cn_start sig_en=6b7457cdd711f788b0f4fde016f73572 sig_cn_org=None source=14.1 
  <para>
   You must own the table to use <command>ALTER TABLE</command>.
   To change the schema or tablespace of a table, you must also have
   <literal>CREATE</literal> privilege on the new schema or tablespace.
   To add the table as a new child of a parent table, you must own the parent
   table as well.  Also, to attach a table as a new partition of the table,
   you must own the table being attached.
   To alter the owner, you must also be a direct or indirect member of the new
   owning role, and that role must have <literal>CREATE</literal> privilege on
   the table's schema.  (These restrictions enforce that altering the owner
   doesn't do anything you couldn't do by dropping and recreating the table.
   However, a superuser can alter ownership of any table anyway.)
   To add a column or alter a column type or use the <literal>OF</literal>
   clause, you must also have <literal>USAGE</literal> privilege on the data
   type.
  </para>
________________________________________________________-->
  <para>
   要使用<command>ALTER TABLE</command>，你必须拥有该表。要更改一个表的
   模式或者表空间，你还必须拥有新模式或表空间上的
   <literal>CREATE</literal>特权。要把一个表作为一个父表的新子表加入，
   你必须也拥有该父表。此外，要把一个表挂接为另一个表的新分区，你必须拥有被挂接的表。要更改拥有者，你还必须
   是新拥有角色的一个直接或者间接成员，并且该角色必须具有该表的模式上的
   <literal>CREATE</literal>特权（这些限制强制修改拥有者不能做一些通过删除和重
   建表做不到的事情。不过，一个超级用户怎么都能更改任何表的所有权。）。
   要增加一个列、修改一列的类型或者使用<literal>OF</literal>子句，你还必
   须具有该数据类型上的<literal>USAGE</literal>特权。
  </para>
<!-- pgdoc-cn_end sig_en=6b7457cdd711f788b0f4fde016f73572 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
  <title>Parameters</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

    <variablelist>

     <varlistentry>
      <term><literal>IF EXISTS</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=3611f1c565b53993a8716acb375bb18c sig_cn_org=None source=14.1 
       <para>
        Do not throw an error if the table does not exist. A notice is issued
        in this case.
       </para>
________________________________________________________-->
       <para>
        如果表不存在则不要抛出一个错误。这种情况下会发出一个提示。
       </para>
<!-- pgdoc-cn_end sig_en=3611f1c565b53993a8716acb375bb18c -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=f943dc03e875eca87fd37a32bd22448b sig_cn_org=None source=14.1 
       <para>
        The name (optionally schema-qualified) of an existing table to
        alter. If <literal>ONLY</literal> is specified before the table name, only
        that table is altered. If <literal>ONLY</literal> is not specified, the table
        and all its descendant tables (if any) are altered.  Optionally,
        <literal>*</literal> can be specified after the table name to explicitly
        indicate that descendant tables are included.
       </para>
________________________________________________________-->
       <para>
        要修改的一个现有表的名称（可以是模式限定的）。如果在表名前指定了
        <literal>ONLY</literal>，则只会修改该表。如果没有指定<literal>ONLY</literal>，
        该表及其所有后代表（如果有）都会被修改。可选地，在表名后面可以指定
        <literal>*</literal>用来显式地指示包括后代表。
       </para>
<!-- pgdoc-cn_end sig_en=f943dc03e875eca87fd37a32bd22448b -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">column_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=2471886eb87a57f68af65dacf9e7f036 sig_cn_org=None source=14.1 
       <para>
        Name of a new or existing column.
       </para>
________________________________________________________-->
       <para>
        一个新列或者现有列的名称。
       </para>
<!-- pgdoc-cn_end sig_en=2471886eb87a57f68af65dacf9e7f036 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">new_column_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=2931d56c192444f3f5ee06c09c4065a5 sig_cn_org=None source=14.1 
       <para>
        New name for an existing column.
       </para>
________________________________________________________-->
       <para>
        一个现有列的新名称。
       </para>
<!-- pgdoc-cn_end sig_en=2931d56c192444f3f5ee06c09c4065a5 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">new_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=9df91ca96cfed85b771970c88e2022f8 sig_cn_org=None source=14.1 
       <para>
        New name for the table.
       </para>
________________________________________________________-->
       <para>
        该表的新名称。
       </para>
<!-- pgdoc-cn_end sig_en=9df91ca96cfed85b771970c88e2022f8 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">data_type</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=9276abecd42d179ec8c876af6a543053 sig_cn_org=None source=14.1 
       <para>
        Data type of the new column, or new data type for an existing
        column.
       </para>
________________________________________________________-->
       <para>
        一个新列的数据类型或者一个现有列的新数据类型。
       </para>
<!-- pgdoc-cn_end sig_en=9276abecd42d179ec8c876af6a543053 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">table_constraint</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=c8eec65f2872264473d3be01f95c64ee sig_cn_org=None source=14.1 
       <para>
        New table constraint for the table.
       </para>
________________________________________________________-->
       <para>
        该表的新的表约束。
       </para>
<!-- pgdoc-cn_end sig_en=c8eec65f2872264473d3be01f95c64ee -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">constraint_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=a295d76f798d2c69efa287c0439ad47a sig_cn_org=None source=14.1 
       <para>
        Name of a new or existing constraint.
       </para>
________________________________________________________-->
       <para>
        一个新约束或者现有约束的名称。
       </para>
<!-- pgdoc-cn_end sig_en=a295d76f798d2c69efa287c0439ad47a -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CASCADE</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=77bdc070eddae873ed08a629a30ebe9b sig_cn_org=None source=14.1 
       <para>
        Automatically drop objects that depend on the dropped column
        or constraint (for example, views referencing the column),
        and in turn all objects that depend on those objects
        (see <xref linkend="ddl-depend"/>).
       </para>
________________________________________________________-->
       <para>
        自动删除依赖于被删除列或约束的对象（例如引用该列的视图），
        并且接着删除依赖于那些对象的
        所有对象（见<xref linkend="ddl-depend"/>）。
       </para>
<!-- pgdoc-cn_end sig_en=77bdc070eddae873ed08a629a30ebe9b -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RESTRICT</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=b848a3a7358fc189c2cfb4a94cd4be0d sig_cn_org=None source=14.1 
       <para>
        Refuse to drop the column or constraint if there are any dependent
        objects. This is the default behavior.
       </para>
________________________________________________________-->
       <para>
        如果有任何依赖对象时拒绝删除列或者约束。这是默认行为。
       </para>
<!-- pgdoc-cn_end sig_en=b848a3a7358fc189c2cfb4a94cd4be0d -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">trigger_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=e0e220c919d821a8a61c0c73c3837b6b sig_cn_org=None source=14.1 
       <para>
        Name of a single trigger to disable or enable.
       </para>
________________________________________________________-->
       <para>
        一个要禁用或启用的触发器的名称。
       </para>
<!-- pgdoc-cn_end sig_en=e0e220c919d821a8a61c0c73c3837b6b -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ALL</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=a67b789fec176a19ea3f4db19cf03402 sig_cn_org=6323cec9cef9652c8fdd00af2ffa8724 source=15.7 
       <para>
        Disable or enable all triggers belonging to the table.
        (This requires superuser privilege if any of the triggers are
        internally generated constraint triggers, such as those that are used
        to implement foreign key constraints or deferrable uniqueness and
        exclusion constraints.)
       </para>
________________________________________________________-->
       <para>
        禁用或启用属于表的所有触发器。
        （如果任何触发器是内部生成的约束触发器，例如用于实现外键约束或可延迟唯一性和排除性约束的触发器，则需要超级用户权限。）
       </para>
<!-- pgdoc-cn_end sig_en=a67b789fec176a19ea3f4db19cf03402 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>USER</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=e7bdb230d7af837171330e353b6083bf sig_cn_org=ced74d0b3526db88fae4f686f6d58639 source=15.7 
       <para>
        Disable or enable all triggers belonging to the table except for
        internally generated constraint triggers, such as those that are used
        to implement foreign key constraints or deferrable uniqueness and
        exclusion constraints.
       </para>
________________________________________________________-->
       <para>
        禁用或启用表中除了内部生成的约束触发器之外的所有触发器，例如用于实现外键约束或可延迟唯一性和排除性约束的触发器。
       </para>
<!-- pgdoc-cn_end sig_en=e7bdb230d7af837171330e353b6083bf -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">index_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=07417061a3019206a3aa3cdc0c7f20a8 sig_cn_org=None source=14.1 
       <para>
        The name of an existing index.
       </para>
________________________________________________________-->
       <para>
        一个现有索引的名称。
       </para>
<!-- pgdoc-cn_end sig_en=07417061a3019206a3aa3cdc0c7f20a8 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">storage_parameter</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=7e02fae983853390cac080888982d188 sig_cn_org=None source=14.1 
       <para>
        The name of a table storage parameter.
       </para>
________________________________________________________-->
       <para>
        一个表存储参数的名称。
       </para>
<!-- pgdoc-cn_end sig_en=7e02fae983853390cac080888982d188 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">value</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=4e2a45430b8b2c4b43905381edccd59b sig_cn_org=None source=14.1 
       <para>
        The new value for a table storage parameter.
        This might be a number or a word depending on the parameter.
       </para>
________________________________________________________-->
       <para>
        一个表存储参数的新值。根据该参数，该值可能是一个数字或者一个词。
       </para>
<!-- pgdoc-cn_end sig_en=4e2a45430b8b2c4b43905381edccd59b -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">parent_table</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=a74d903198b7db208f92f8fa5488989b sig_cn_org=None source=14.1 
       <para>
        A parent table to associate or de-associate with this table.
       </para>
________________________________________________________-->
       <para>
        要与这个表关联或者解除关联的父表。
       </para>
<!-- pgdoc-cn_end sig_en=a74d903198b7db208f92f8fa5488989b -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">new_owner</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=c031aaa0cc41bdda7a6290e6e1d8893a sig_cn_org=None source=14.1 
       <para>
        The user name of the new owner of the table.
       </para>
________________________________________________________-->
       <para>
        该表的新拥有者的用户名。
       </para>
<!-- pgdoc-cn_end sig_en=c031aaa0cc41bdda7a6290e6e1d8893a -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">new_access_method</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=ee58cf7ea959b3df6806a98d78b11662 sig_cn_org=aeb99e62e2432a195389b152625398b5 source=15.7 
       <para>
        The name of the access method to which the table will be converted.
       </para>
________________________________________________________-->
       <para>
        将表格转换为的访问方法的名称。
       </para>
<!-- pgdoc-cn_end sig_en=ee58cf7ea959b3df6806a98d78b11662 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">new_tablespace</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=cc7409e95f5abc0621da24448bb8419f sig_cn_org=None source=14.1 
       <para>
        The name of the tablespace to which the table will be moved.
       </para>
________________________________________________________-->
       <para>
        要把该表移入其中的表空间的名称。
       </para>
<!-- pgdoc-cn_end sig_en=cc7409e95f5abc0621da24448bb8419f -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">new_schema</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=785b548a95c0ae5d7b948a1cdddf9898 sig_cn_org=None source=14.1 
       <para>
        The name of the schema to which the table will be moved.
       </para>
________________________________________________________-->
       <para>
        要把该表移入其中的模式的名称。
       </para>
<!-- pgdoc-cn_end sig_en=785b548a95c0ae5d7b948a1cdddf9898 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">partition_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=545d1b04810670d22bb2fa4bbf55fff2 sig_cn_org=None source=14.1 
       <para>
        The name of the table to attach as a new partition or to detach from this table.
       </para>
________________________________________________________-->
       <para>
        要被作为新分区附着到这个表或者从这个表上分离的表的名称。
       </para>
<!-- pgdoc-cn_end sig_en=545d1b04810670d22bb2fa4bbf55fff2 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">partition_bound_spec</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=28883de1f9b927a97fe5c99e7533c76a sig_cn_org=None source=14.1 
       <para>
        The partition bound specification for a new partition.  Refer to
        <xref linkend="sql-createtable"/> for more details on the syntax of the same.
       </para>
________________________________________________________-->
       <para>
        新分区的分区边界说明。更多细节请参考<link linkend="sql-createtable"><command>CREATE TABLE</command></link>中相同的语法。
       </para>
<!-- pgdoc-cn_end sig_en=28883de1f9b927a97fe5c99e7533c76a -->
      </listitem>
     </varlistentry>

    </variablelist>
 </refsect1>

 <refsect1 id="sql-altertable-notes" xreflabel="Notes">
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
  <title>Notes</title>
________________________________________________________-->
  <title>Notes</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->

<!-- pgdoc-cn_start sig_en=6281a8def45d03e5fe8b0907d649b9cb sig_cn_org=None source=14.1 
   <para>
    The key word <literal>COLUMN</literal> is noise and can be omitted.
   </para>
________________________________________________________-->
   <para>
    关键词<literal>COLUMN</literal>是噪声，可以被省略。
   </para>
<!-- pgdoc-cn_end sig_en=6281a8def45d03e5fe8b0907d649b9cb -->

<!-- pgdoc-cn_start sig_en=d4c501be20982e2dbb5c1eedd19859c9 sig_cn_org=None source=14.1 
   <para>
    When a column is added with <literal>ADD COLUMN</literal> and a
    non-volatile <literal>DEFAULT</literal> is specified, the default is
    evaluated at the time of the statement and the result stored in the
    table's metadata.  That value will be used for the column for all existing
    rows.  If no <literal>DEFAULT</literal> is specified, NULL is used.  In
    neither case is a rewrite of the table required.
   </para>
________________________________________________________-->
   <para>
    在使用<literal>ADD COLUMN</literal>增加一列并且指定了一个非易失性<literal>DEFAULT</literal>时，默认值会在该语句执行时计算并且结果会被保存在表的元数据中。这个值将被用于所有现有行的该列。如果没有指定<literal>DEFAULT</literal>，则使用NULL。在两种情况下都不需要重写表。
   </para>
<!-- pgdoc-cn_end sig_en=d4c501be20982e2dbb5c1eedd19859c9 -->

<!-- pgdoc-cn_start sig_en=27129bfd67f069c46707ef1d7882f87e sig_cn_org=b44185cc04f8e0f980aeb1ddd5051d6c source=15.7 
   <para>
    Adding a column with a volatile <literal>DEFAULT</literal> or
    changing the type of an existing column will require the entire table and
    its indexes to be rewritten. As an exception, when changing the type of an
    existing column, if the <literal>USING</literal> clause does not change
    the column contents and the old type is either binary coercible to the new
    type or an unconstrained domain over the new type, a table rewrite is not
    needed. However, indexes must always be rebuilt unless the system can
    verify that the new index would be logically equivalent to the existing
    one.  For example, if the collation for a column has been changed, an index
    rebuild is always required because the new sort order might be different.
    However, in the absence of a collation change, a column can be changed
    from <type>text</type> to <type>varchar</type> (or vice versa) without
    rebuilding the indexes because these data types sort identically.
    Table and/or index rebuilds may take a
    significant amount of time for a large table; and will temporarily require
    as much as double the disk space.
   </para>
________________________________________________________-->
   <para>
    添加一个带有易失性<literal>DEFAULT</literal>的列或更改现有列的类型将需要重写整个表及其索引。
    作为一个例外，当更改现有列的类型时，如果<literal>USING</literal>子句不改变列内容，
    且旧类型可以被二进制强制转换为新类型或者是新类型的无约束域，那么不需要重写表。
    然而，索引必须始终重建，除非系统可以验证新索引在逻辑上等同于现有索引。
    例如，如果更改了列的排序规则，总是需要重建索引，因为新的排序顺序可能不同。
    然而，在没有排序规则更改的情况下，可以将列从<type>text</type>更改为<type>varchar</type>
    （反之亦然）而无需重建索引，因为这些数据类型排序相同。
    对于大表，表和/或索引重建可能需要大量时间；并且暂时需要多达两倍的磁盘空间。
</para>
<!-- pgdoc-cn_end sig_en=27129bfd67f069c46707ef1d7882f87e -->

<!-- pgdoc-cn_start sig_en=49719c5800c9bb8a10b34b92916c02cf sig_cn_org=None source=14.1 
   <para>
    Adding a <literal>CHECK</literal> or <literal>NOT NULL</literal> constraint requires
    scanning the table to verify that existing rows meet the constraint,
    but does not require a table rewrite.
   </para>
________________________________________________________-->
   <para>
    增加一个<literal>CHECK</literal>或者<literal>NOT NULL</literal>约束要求扫描
    表以验证现有行符合该约束，但是不要求一次表重写。
   </para>
<!-- pgdoc-cn_end sig_en=49719c5800c9bb8a10b34b92916c02cf -->

<!-- pgdoc-cn_start sig_en=30fca905f815f339a3d0b0e8d8bccda6 sig_cn_org=None source=14.1 
   <para>
    Similarly, when attaching a new partition it may be scanned to verify that
    existing rows meet the partition constraint.
   </para>
________________________________________________________-->
   <para>
    类似地，在挂接一个新分区时，它需要被扫描以验证现有行满足该分区约束。
   </para>
<!-- pgdoc-cn_end sig_en=30fca905f815f339a3d0b0e8d8bccda6 -->

<!-- pgdoc-cn_start sig_en=160a36ff0b399c998f0f3e5703936792 sig_cn_org=None source=14.1 
   <para>
    The main reason for providing the option to specify multiple changes
    in a single <command>ALTER TABLE</command> is that multiple table scans or
    rewrites can thereby be combined into a single pass over the table.
   </para>
________________________________________________________-->
   <para>
    提供在一个<command>ALTER TABLE</command>中指定多个更改的选项的主要
    原因就是多次表扫描或者重写可以因此被整合成一次。
   </para>
<!-- pgdoc-cn_end sig_en=160a36ff0b399c998f0f3e5703936792 -->

<!-- pgdoc-cn_start sig_en=8ae7a5aea5ce01c153bb87cd1bd1af06 sig_cn_org=None source=14.1 
   <para>
    Scanning a large table to verify a new foreign key or check constraint
    can take a long time, and other updates to the table are locked out
    until the <command>ALTER TABLE ADD CONSTRAINT</command> command is
    committed.  The main purpose of the <literal>NOT VALID</literal>
    constraint option is to reduce the impact of adding a constraint on
    concurrent updates.  With <literal>NOT VALID</literal>,
    the <command>ADD CONSTRAINT</command> command does not scan the table
    and can be committed immediately.  After that, a <literal>VALIDATE
    CONSTRAINT</literal> command can be issued to verify that existing rows
    satisfy the constraint.  The validation step does not need to lock out
    concurrent updates, since it knows that other transactions will be
    enforcing the constraint for rows that they insert or update; only
    pre-existing rows need to be checked.  Hence, validation acquires only
    a <literal>SHARE UPDATE EXCLUSIVE</literal> lock on the table being
    altered.  (If the constraint is a foreign key then a <literal>ROW
    SHARE</literal> lock is also required on the table referenced by the
    constraint.)  In addition to improving concurrency, it can be useful to
    use <literal>NOT VALID</literal> and <literal>VALIDATE
    CONSTRAINT</literal> in cases where the table is known to contain
    pre-existing violations.  Once the constraint is in place, no new
    violations can be inserted, and the existing problems can be corrected
    at leisure until <literal>VALIDATE CONSTRAINT</literal> finally
    succeeds.
   </para>
________________________________________________________-->
   <para>
    扫描大型表以验证新的外键或检查约束可能需要很长时间，并且对表的其他更新将锁定，直到<command>ALTER TABLE ADD CONSTRAINT</command>命令被提交。
    <literal>NOT VALID</literal>约束选项的主要目的是减少对并发更新添加约束的影响。 
    使用 <literal>NOT VALID</literal>，<command>ADD CONSTRAINT</command>命令不扫描表，可以立即提交。
    在之后，<literal>VALIDATE CONSTRAINT</literal>命令会被发出以验证现有行是否满足约束。
    验证步骤不需要锁定并发更新，因为它知道其他事务将强制执行它们插入或更新的行的约束;只有预先存在的行需要检查。
    因此，验证在被更改的表上仅获得一个<literal>SHARE UPDATE EXCLUSIVE</literal>锁。
    （如果约束是外键，则 <literal>ROW SHARE</literal>锁也需要约束的表引用。）
    除了改进并发性外，在已知该表包含预先存在的违规行为的情况下使用 <literal>NOT VALID</literal> 和 <literal>VALIDATE CONSTRAINT</literal>也能有作用。
    一旦约束就位，就不能再插入新的违规，，并且现有问题可以在空闲时纠正，直到<literal>VALIDATE CONSTRAINT</literal>最终完成。
   </para>
<!-- pgdoc-cn_end sig_en=8ae7a5aea5ce01c153bb87cd1bd1af06 -->

<!-- pgdoc-cn_start sig_en=8187878fc84acc79cf37f4b1e0310f31 sig_cn_org=None source=14.1 
   <para>
    The <literal>DROP COLUMN</literal> form does not physically remove
    the column, but simply makes it invisible to SQL operations.  Subsequent
    insert and update operations in the table will store a null value for the
    column. Thus, dropping a column is quick but it will not immediately
    reduce the on-disk size of your table, as the space occupied
    by the dropped column is not reclaimed.  The space will be
    reclaimed over time as existing rows are updated.
   </para>
________________________________________________________-->
   <para>
    <literal>DROP COLUMN</literal>形式不会在物理上移除列，而只是简
    单地让它对 SQL 操作不可见。后续该表中的插入和更新操作将为该列存储
    一个空值。因此，删除一个列很快，但是它不会立刻减少表所占的磁盘空间，
    因为被删除列所占用的空间还没有被回收。随着现有列被更新，空间将被逐渐
    回收。
   </para>
<!-- pgdoc-cn_end sig_en=8187878fc84acc79cf37f4b1e0310f31 -->

<!-- pgdoc-cn_start sig_en=8219245b6f735cf270d7e3e46b600f3e sig_cn_org=None source=14.1 
   <para>
    To force immediate reclamation of space occupied by a dropped column,
    you can execute one of the forms of <command>ALTER TABLE</command> that
    performs a rewrite of the whole table.  This results in reconstructing
    each row with the dropped column replaced by a null value.
   </para>
________________________________________________________-->
   <para>
    要强制立即回收被已删除列占据的空间，你可以执行一种能导致全表重写的
    <command>ALTER TABLE</command>形式。这种形式会导致重新构造每一个把被
    删除列替换为空值的行。
   </para>
<!-- pgdoc-cn_end sig_en=8219245b6f735cf270d7e3e46b600f3e -->

<!-- pgdoc-cn_start sig_en=93c2b49b525b8501f27fd948de4a8d53 sig_cn_org=None source=14.1 
   <para>
    The rewriting forms of <command>ALTER TABLE</command> are not MVCC-safe.
    After a table rewrite, the table will appear empty to concurrent
    transactions, if they are using a snapshot taken before the rewrite
    occurred.  See <xref linkend="mvcc-caveats"/> for more details.
   </para>
________________________________________________________-->
   <para>
    <command>ALTER TABLE</command>的重写形式对于 MVCC 是不安全的。
    在一次表重写之后，如果并发事务使用的是一个在重写发生前取得的
    快照，该表将对这些并发事务呈现出空表的形态。详见
    <xref linkend="mvcc-caveats"/>。
   </para>
<!-- pgdoc-cn_end sig_en=93c2b49b525b8501f27fd948de4a8d53 -->

<!-- pgdoc-cn_start sig_en=2114901a1b5f687f3566d1ea46d8c427 sig_cn_org=None source=14.1 
   <para>
    The <literal>USING</literal> option of <literal>SET DATA TYPE</literal> can actually
    specify any expression involving the old values of the row; that is, it
    can refer to other columns as well as the one being converted.  This allows
    very general conversions to be done with the <literal>SET DATA TYPE</literal>
    syntax.  Because of this flexibility, the <literal>USING</literal>
    expression is not applied to the column's default value (if any); the
    result might not be a constant expression as required for a default.
    This means that when there is no implicit or assignment cast from old to
    new type, <literal>SET DATA TYPE</literal> might fail to convert the default even
    though a <literal>USING</literal> clause is supplied.  In such cases,
    drop the default with <literal>DROP DEFAULT</literal>, perform the <literal>ALTER
    TYPE</literal>, and then use <literal>SET DEFAULT</literal> to add a suitable new
    default.  Similar considerations apply to indexes and constraints involving
    the column.
   </para>
________________________________________________________-->
   <para>
    <literal>SET DATA TYPE</literal>的<literal>USING</literal>选项能实际指定
    涉及该列旧值的任何表达式。也就是说，它可以不但可以引用要被转换的列，
    还可以引用其他列。这允许使用<literal>SET DATA TYPE</literal>语法完成十分
    普遍的转换。由于这种灵活性，<literal>USING</literal>表达式不适合于列
    的默认值（如果有），结果可能不是一个默认值所需的常量表达式。这意味着
    在没有从旧类型到新类型的隐式或者赋值造型时，即便提供了一个
    <literal>USING</literal>子句，<literal>SET DATA TYPE</literal>还是可能无法
    转换默认值。在这种情况下，用<literal>DROP DEFAULT</literal>删除该默认值，
    执行<literal>ALTER TYPE</literal>并且接着使用<literal>SET DEFAULT</literal>增加
    一个合适的新默认值。类似的考虑也适用于涉及该列的索引和约束。
   </para>
<!-- pgdoc-cn_end sig_en=2114901a1b5f687f3566d1ea46d8c427 -->

<!-- pgdoc-cn_start sig_en=80baec5e0f2dba8c069dc9d87f7ff942 sig_cn_org=None source=14.1 
   <para>
    If a table has any descendant tables, it is not permitted to add,
    rename, or change the type of a column in the parent table without doing
    the same to the descendants.  This ensures that the descendants always
    have columns matching the parent.  Similarly, a <literal>CHECK</literal>
    constraint cannot be renamed in the parent without also renaming it in
    all descendants, so that <literal>CHECK</literal> constraints also match
    between the parent and its descendants.  (That restriction does not apply
    to index-based constraints, however.)
    Also, because selecting from the parent also selects from its descendants,
    a constraint on the parent cannot be marked valid unless it is also marked
    valid for those descendants.  In all of these cases, <command>ALTER TABLE
    ONLY</command> will be rejected.
   </para>
________________________________________________________-->
   <para>
    如果一个表有任何后代表，在不对后代表做相同操作的情况下，不允许在父表中增加列、重命名列或者更改列的类型。这确保了后代总是具有和父表匹配的列。类似地，如果不对所有后代上的<literal>CHECK</literal>约束进行重命名，就不能在父表中重命名该<literal>CHECK</literal>约束，这样<literal>CHECK</literal>约束也能在父表及其后代之间保持匹配（不过，这个限制不适用于基于索引的约束）。此外，因为从父表中选择也会从其后代中选择，父表上的约束不能被标记为有效，除非它在那些后代上也被标记为有效。在所有这些情况下，<command>ALTER TABLE ONLY</command>都将被拒绝。
   </para>
<!-- pgdoc-cn_end sig_en=80baec5e0f2dba8c069dc9d87f7ff942 -->

<!-- pgdoc-cn_start sig_en=f9111687740721a1ce84f85fd96dd9c3 sig_cn_org=None source=14.1 
   <para>
    A recursive <literal>DROP COLUMN</literal> operation will remove a
    descendant table's column only if the descendant does not inherit
    that column from any other parents and never had an independent
    definition of the column.  A nonrecursive <literal>DROP
    COLUMN</literal> (i.e., <command>ALTER TABLE ONLY ... DROP
    COLUMN</command>) never removes any descendant columns, but
    instead marks them as independently defined rather than inherited.
    A nonrecursive <literal>DROP COLUMN</literal> command will fail for a
    partitioned table, because all partitions of a table must have the same
    columns as the partitioning root.
   </para>
________________________________________________________-->
   <para>
    只有当一个后代表的列不是从任何其他父表继承而来并且没有该列的独立定义时，
    一次递归的<literal>DROP COLUMN</literal>操作才会移除该列。一次非递归
    的<literal>DROP COLUMN</literal>（即
    <command>ALTER TABLE ONLY ... DROP COLUMN</command>）不会移除
    任何后代列，而是会把它们标记成独立定义的列。对于一个分区表，一个非递归的<literal>DROP COLUMN</literal>命令将会失败，因为一个表的所有分区都必须有和分区根节点相同的列。
   </para>
<!-- pgdoc-cn_end sig_en=f9111687740721a1ce84f85fd96dd9c3 -->

<!-- pgdoc-cn_start sig_en=80557e5d0fbf2b972f099fdfd01e962c sig_cn_org=ad7504c4af4df0e2ab3748944a09c873 source=15.7 
   <para>
    The actions for identity columns (<literal>ADD
    GENERATED</literal>, <literal>SET</literal> etc., <literal>DROP
    IDENTITY</literal>), as well as the actions
    <literal>CLUSTER</literal>, <literal>OWNER</literal>,
    and <literal>TABLESPACE</literal> never recurse to descendant tables;
    that is, they always act as though <literal>ONLY</literal> were specified.
    Actions affecting trigger states recurse to partitions of partitioned
    tables (unless <literal>ONLY</literal> is specified), but never to
    traditional-inheritance descendants.
    Adding a constraint recurses only for <literal>CHECK</literal> constraints
    that are not marked <literal>NO INHERIT</literal>.
   </para>
________________________________________________________-->
   <para>
    对于标识列（<literal>ADD GENERATED</literal>，<literal>SET</literal>等），以及<literal>DROP IDENTITY</literal>等操作，
    以及<literal>CLUSTER</literal>，<literal>OWNER</literal>和<literal>TABLESPACE</literal>等操作，永远不会递归到后代表；
    也就是说，它们总是像指定了<literal>ONLY</literal>一样操作。
    影响触发器状态的操作会递归到分区化表的分区（除非指定了<literal>ONLY</literal>），但永远不会递归到传统继承的后代表。
    添加约束只会递归到未标记为<literal>NO INHERIT</literal>的<literal>CHECK</literal>约束。
   </para>
<!-- pgdoc-cn_end sig_en=80557e5d0fbf2b972f099fdfd01e962c -->

<!-- pgdoc-cn_start sig_en=37b90a7690900ae2f9d32dec39a3ee2d sig_cn_org=None source=14.1 
   <para>
    Changing any part of a system catalog table is not permitted.
   </para>
________________________________________________________-->
   <para>
    不允许更改一个系统目录表的任何部分。
   </para>
<!-- pgdoc-cn_end sig_en=37b90a7690900ae2f9d32dec39a3ee2d -->

<!-- pgdoc-cn_start sig_en=48ac34d3bf338ef250b3d0c3bfd92c62 sig_cn_org=None source=14.1 
   <para>
    Refer to <xref linkend="sql-createtable"/> for a further description of valid
    parameters. <xref linkend="ddl"/> has further information on
    inheritance.
   </para>
________________________________________________________-->
   <para>
    可用参数的进一步描述请见<link linkend="sql-createtable"><command>CREATE TABLE</command></link>。
    <xref linkend="ddl"/>中有关于继承的进一步信息。
   </para>
<!-- pgdoc-cn_end sig_en=48ac34d3bf338ef250b3d0c3bfd92c62 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
  <title>Examples</title>
________________________________________________________-->
  <title>示例</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=dc69dff71d86dbec60ea692195f4315e sig_cn_org=None source=14.1 
  <para>
   To add a column of type <type>varchar</type> to a table:
<programlisting>
ALTER TABLE distributors ADD COLUMN address varchar(30);
</programlisting>
   That will cause all existing rows in the table to be filled with null
   values for the new column.
  </para>
________________________________________________________-->
  <para>
   要向一个表增加一个类型为<type>varchar</type>的列：
<programlisting>
ALTER TABLE distributors ADD COLUMN address varchar(30);
</programlisting>
   这将导致表中所有现有行都用新列的空值填充。
  </para>
<!-- pgdoc-cn_end sig_en=dc69dff71d86dbec60ea692195f4315e -->

<!-- pgdoc-cn_start sig_en=0fd6a43b82508ff9aaec1eb8636ee1bd sig_cn_org=None source=14.1 
  <para>
   To add a column with a non-null default:
<programlisting>
ALTER TABLE measurements
  ADD COLUMN mtime timestamp with time zone DEFAULT now();
</programlisting>
   Existing rows will be filled with the current time as the value of the
   new column, and then new rows will receive the time of their insertion.
  </para>
________________________________________________________-->
  <para>
   要添加默认值为非空的列：
<programlisting>
ALTER TABLE measurements
  ADD COLUMN mtime timestamp with time zone DEFAULT now();
</programlisting>
   现有行将以当前时间填充为新列的值，然后新行直将使用其插入时间。
  </para>
<!-- pgdoc-cn_end sig_en=0fd6a43b82508ff9aaec1eb8636ee1bd -->

<!-- pgdoc-cn_start sig_en=7dc22b726d4c6c88a6dc6feb8939977c sig_cn_org=None source=14.1 
  <para>
   To add a column and fill it with a value different from the default to
   be used later:
<programlisting>
ALTER TABLE transactions
  ADD COLUMN status varchar(30) DEFAULT 'old',
  ALTER COLUMN status SET default 'current';
</programlisting>
   Existing rows will be filled with <literal>old</literal>, but then
   the default for subsequent commands will be <literal>current</literal>.
   The effects are the same as if the two sub-commands had been issued
   in separate <command>ALTER TABLE</command> commands.
  </para>
________________________________________________________-->
  <para>
   要添加一列并用不同于默认值的值填充它：
<programlisting>
ALTER TABLE transactions
  ADD COLUMN status varchar(30) DEFAULT 'old',
  ALTER COLUMN status SET default 'current';
</programlisting>
   现有行将用<literal>old</literal>填充，但是随后的命令的默认值将是<literal>current</literal>。 
   其效果与在单独的<command>ALTER TABLE</command>命令中发出两个子命令的效果相同。
  </para>
<!-- pgdoc-cn_end sig_en=7dc22b726d4c6c88a6dc6feb8939977c -->

<!-- pgdoc-cn_start sig_en=cbf28f04046e8b0f82c4f06909cd4767 sig_cn_org=None source=14.1 
  <para>
   To drop a column from a table:
<programlisting>
ALTER TABLE distributors DROP COLUMN address RESTRICT;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   要从表中删除一列：
<programlisting>
ALTER TABLE distributors DROP COLUMN address RESTRICT;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=cbf28f04046e8b0f82c4f06909cd4767 -->

<!-- pgdoc-cn_start sig_en=28d8116d0192f01d447840359482c67f sig_cn_org=None source=14.1 
  <para>
   To change the types of two existing columns in one operation:
<programlisting>
ALTER TABLE distributors
    ALTER COLUMN address TYPE varchar(80),
    ALTER COLUMN name TYPE varchar(100);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   要在一个操作中更改两个现有列的类型：
<programlisting>
ALTER TABLE distributors
    ALTER COLUMN address TYPE varchar(80),
    ALTER COLUMN name TYPE varchar(100);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=28d8116d0192f01d447840359482c67f -->

<!-- pgdoc-cn_start sig_en=e79ba6b55953644730f0cf7deaa338d1 sig_cn_org=None source=14.1 
  <para>
   To change an integer column containing Unix timestamps to <type>timestamp
   with time zone</type> via a <literal>USING</literal> clause:
<programlisting>
ALTER TABLE foo
    ALTER COLUMN foo_timestamp SET DATA TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second';
</programlisting>
  </para>
________________________________________________________-->
  <para>
   通过一个<literal>USING</literal>子句更改一个包含 Unix 时间戳的整数列为
   <type>timestamp with time zone</type>：
<programlisting>
ALTER TABLE foo
    ALTER COLUMN foo_timestamp SET DATA TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second';
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=e79ba6b55953644730f0cf7deaa338d1 -->

<!-- pgdoc-cn_start sig_en=7c5ab24f6818e1a64cf5af415922cce1 sig_cn_org=None source=14.1 
  <para>
   The same, when the column has a default expression that won't automatically
   cast to the new data type:
<programlisting>
ALTER TABLE foo
    ALTER COLUMN foo_timestamp DROP DEFAULT,
    ALTER COLUMN foo_timestamp TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second',
    ALTER COLUMN foo_timestamp SET DEFAULT now();
</programlisting>
  </para>
________________________________________________________-->
  <para>
   同样的，当该列具有一个不能自动造型成新数据类型的默认值表达式时：
<programlisting>
ALTER TABLE foo
    ALTER COLUMN foo_timestamp DROP DEFAULT,
    ALTER COLUMN foo_timestamp TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second',
    ALTER COLUMN foo_timestamp SET DEFAULT now();
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=7c5ab24f6818e1a64cf5af415922cce1 -->

<!-- pgdoc-cn_start sig_en=0a3f26b977b45b250e2be43023135d86 sig_cn_org=None source=14.1 
  <para>
   To rename an existing column:
<programlisting>
ALTER TABLE distributors RENAME COLUMN address TO city;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   To rename an existing column:
<programlisting>
ALTER TABLE distributors RENAME COLUMN address TO city;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=0a3f26b977b45b250e2be43023135d86 -->

<!-- pgdoc-cn_start sig_en=e8d39890237beca625abace909e06625 sig_cn_org=None source=14.1 
  <para>
   To rename an existing table:
<programlisting>
ALTER TABLE distributors RENAME TO suppliers;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   重命名一个现有的表：
<programlisting>
ALTER TABLE distributors RENAME TO suppliers;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=e8d39890237beca625abace909e06625 -->

<!-- pgdoc-cn_start sig_en=6bc967125752a615cddd1b20b475a376 sig_cn_org=None source=14.1 
  <para>
   To rename an existing constraint:
<programlisting>
ALTER TABLE distributors RENAME CONSTRAINT zipchk TO zip_check;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   重命名一个现有的约束：
<programlisting>
ALTER TABLE distributors RENAME CONSTRAINT zipchk TO zip_check;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=6bc967125752a615cddd1b20b475a376 -->

<!-- pgdoc-cn_start sig_en=8d00a9048d4864fb5826f7ae96cb48f1 sig_cn_org=None source=14.1 
  <para>
   To add a not-null constraint to a column:
<programlisting>
ALTER TABLE distributors ALTER COLUMN street SET NOT NULL;
</programlisting>
   To remove a not-null constraint from a column:
<programlisting>
ALTER TABLE distributors ALTER COLUMN street DROP NOT NULL;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   为一列增加一个非空约束：
<programlisting>
ALTER TABLE distributors ALTER COLUMN street SET NOT NULL;
</programlisting>
   从一列移除一个非空约束：
<programlisting>
ALTER TABLE distributors ALTER COLUMN street DROP NOT NULL;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=8d00a9048d4864fb5826f7ae96cb48f1 -->

<!-- pgdoc-cn_start sig_en=d396a78c3e229395796c36e8852f14e6 sig_cn_org=None source=14.1 
  <para>
   To add a check constraint to a table and all its children:
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   向一个表及其所有子女增加一个检查约束：
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=d396a78c3e229395796c36e8852f14e6 -->

<!-- pgdoc-cn_start sig_en=059a2653be252aaaa97614dfaa8774b6 sig_cn_org=None source=14.1 
  <para>
   To add a check constraint only to a table and not to its children:
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5) NO INHERIT;
</programlisting>
   (The check constraint will not be inherited by future children, either.)
  </para>
________________________________________________________-->
  <para>
   只向一个表增加一个检查约束（不为其子女增加）：
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5) NO INHERIT;
</programlisting>
   （该检查约束也不会被未来的子女继承）。
  </para>
<!-- pgdoc-cn_end sig_en=059a2653be252aaaa97614dfaa8774b6 -->

<!-- pgdoc-cn_start sig_en=22755baae1a3cf44cc3fcc6ae675c669 sig_cn_org=None source=14.1 
  <para>
   To remove a check constraint from a table and all its children:
<programlisting>
ALTER TABLE distributors DROP CONSTRAINT zipchk;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   从一个表及其子女移除一个检查约束：
<programlisting>
ALTER TABLE distributors DROP CONSTRAINT zipchk;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=22755baae1a3cf44cc3fcc6ae675c669 -->

<!-- pgdoc-cn_start sig_en=056218974208839858280896646c8185 sig_cn_org=None source=14.1 
  <para>
   To remove a check constraint from one table only:
<programlisting>
ALTER TABLE ONLY distributors DROP CONSTRAINT zipchk;
</programlisting>
   (The check constraint remains in place for any child tables.)
  </para>
________________________________________________________-->
  <para>
   只从一个表移除一个检查约束：
<programlisting>
ALTER TABLE ONLY distributors DROP CONSTRAINT zipchk;
</programlisting>
   （该检查约束仍为子女表保留在某个地方）。
  </para>
<!-- pgdoc-cn_end sig_en=056218974208839858280896646c8185 -->

<!-- pgdoc-cn_start sig_en=a8cd9c8d2b7b1d4d7f499c3e4d461587 sig_cn_org=None source=14.1 
  <para>
   To add a foreign key constraint to a table:
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   为一个表增加一个外键约束：
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=a8cd9c8d2b7b1d4d7f499c3e4d461587 -->

<!-- pgdoc-cn_start sig_en=61ebea0d0eec5207f62ae21924759b2e sig_cn_org=None source=14.1 
  <para>
   To add a foreign key constraint to a table with the least impact on other work:
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address) NOT VALID;
ALTER TABLE distributors VALIDATE CONSTRAINT distfk;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   为一个表增加一个外键约束，并且尽量不要影响其他工作：
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address) NOT VALID;
ALTER TABLE distributors VALIDATE CONSTRAINT distfk;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=61ebea0d0eec5207f62ae21924759b2e -->

<!-- pgdoc-cn_start sig_en=e8431d96784c208d0e903d801d394dcf sig_cn_org=None source=14.1 
  <para>
   To add a (multicolumn) unique constraint to a table:
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT dist_id_zipcode_key UNIQUE (dist_id, zipcode);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   为一个表增加一个（多列）唯一约束：
<programlisting>
ALTER TABLE distributors ADD CONSTRAINT dist_id_zipcode_key UNIQUE (dist_id, zipcode);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=e8431d96784c208d0e903d801d394dcf -->

<!-- pgdoc-cn_start sig_en=381da5779b8f0f4e03d5d83f0ddc1b22 sig_cn_org=None source=14.1 
  <para>
   To add an automatically named primary key constraint to a table, noting
   that a table can only ever have one primary key:
<programlisting>
ALTER TABLE distributors ADD PRIMARY KEY (dist_id);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   为一个表增加一个自动命名的主键约束，注意一个表只能拥有一个主键：
<programlisting>
ALTER TABLE distributors ADD PRIMARY KEY (dist_id);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=381da5779b8f0f4e03d5d83f0ddc1b22 -->

<!-- pgdoc-cn_start sig_en=36113fb4debdcbc42964f036c0de4f90 sig_cn_org=None source=14.1 
  <para>
   To move a table to a different tablespace:
<programlisting>
ALTER TABLE distributors SET TABLESPACE fasttablespace;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   把一个表移动到一个不同的表空间：
<programlisting>
ALTER TABLE distributors SET TABLESPACE fasttablespace;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=36113fb4debdcbc42964f036c0de4f90 -->

<!-- pgdoc-cn_start sig_en=350f09113194256fc316b14e8fbda9df sig_cn_org=None source=14.1 
  <para>
   To move a table to a different schema:
<programlisting>
ALTER TABLE myschema.distributors SET SCHEMA yourschema;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   把一个表移动到一个不同的模式：
<programlisting>
ALTER TABLE myschema.distributors SET SCHEMA yourschema;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=350f09113194256fc316b14e8fbda9df -->

<!-- pgdoc-cn_start sig_en=be1be667a3ff2bbe3319db75a82326e8 sig_cn_org=None source=14.1 
  <para>
   To recreate a primary key constraint, without blocking updates while the
   index is rebuilt:
<programlisting>
CREATE UNIQUE INDEX CONCURRENTLY dist_id_temp_idx ON distributors (dist_id);
ALTER TABLE distributors DROP CONSTRAINT distributors_pkey,
    ADD CONSTRAINT distributors_pkey PRIMARY KEY USING INDEX dist_id_temp_idx;
</programlisting></para>
________________________________________________________-->
  <para>
   重建一个主键约束，并且在重建索引期间不阻塞更新：
<programlisting>
CREATE UNIQUE INDEX CONCURRENTLY dist_id_temp_idx ON distributors (dist_id);
ALTER TABLE distributors DROP CONSTRAINT distributors_pkey,
    ADD CONSTRAINT distributors_pkey PRIMARY KEY USING INDEX dist_id_temp_idx;
</programlisting></para>
<!-- pgdoc-cn_end sig_en=be1be667a3ff2bbe3319db75a82326e8 -->

<!-- pgdoc-cn_start sig_en=adbf8d26ef6a902e03ea6a81b35fd575 sig_cn_org=None source=14.1 
  <para>
   To attach a partition to a range-partitioned table:
<programlisting>
ALTER TABLE measurement
    ATTACH PARTITION measurement_y2016m07 FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
</programlisting></para>
________________________________________________________-->
  <para>
   要把一个分区挂接到一个范围分区表上：
<programlisting>
ALTER TABLE measurement
    ATTACH PARTITION measurement_y2016m07 FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
</programlisting></para>
<!-- pgdoc-cn_end sig_en=adbf8d26ef6a902e03ea6a81b35fd575 -->

<!-- pgdoc-cn_start sig_en=c1cbe4aa41a11e0d2ccf8379e9948d81 sig_cn_org=None source=14.1 
  <para>
   To attach a partition to a list-partitioned table:
<programlisting>
ALTER TABLE cities
    ATTACH PARTITION cities_ab FOR VALUES IN ('a', 'b');
</programlisting></para>
________________________________________________________-->
  <para>
   要把一个分区挂接到一个列表分区表上：
<programlisting>
ALTER TABLE cities
    ATTACH PARTITION cities_ab FOR VALUES IN ('a', 'b');
</programlisting></para>
<!-- pgdoc-cn_end sig_en=c1cbe4aa41a11e0d2ccf8379e9948d81 -->

<!-- pgdoc-cn_start sig_en=dd7e94150ba98a15d24e9821581bf49a sig_cn_org=None source=14.1 
  <para>
   To attach a partition to a hash-partitioned table:
<programlisting>
ALTER TABLE orders
    ATTACH PARTITION orders_p4 FOR VALUES WITH (MODULUS 4, REMAINDER 3);
</programlisting></para>
________________________________________________________-->
  <para>
   要把一个分区挂接到一个哈希分区表上：
<programlisting>
ALTER TABLE orders
    ATTACH PARTITION orders_p4 FOR VALUES WITH (MODULUS 4, REMAINDER 3);
</programlisting></para>
<!-- pgdoc-cn_end sig_en=dd7e94150ba98a15d24e9821581bf49a -->

<!-- pgdoc-cn_start sig_en=ffdfd14b88cec71f58de6e28c12b2539 sig_cn_org=None source=14.1 
  <para>
   To attach a default partition to a partitioned table:
<programlisting>
ALTER TABLE cities
    ATTACH PARTITION cities_partdef DEFAULT;
</programlisting></para>
________________________________________________________-->
  <para>
   要把一个默认分区挂接到一个分区表上：
<programlisting>
ALTER TABLE cities
    ATTACH PARTITION cities_partdef DEFAULT;
</programlisting></para>
<!-- pgdoc-cn_end sig_en=ffdfd14b88cec71f58de6e28c12b2539 -->

<!-- pgdoc-cn_start sig_en=d5da8cff80c9040ac6f47978c1e40c7e sig_cn_org=None source=14.1 
  <para>
   To detach a partition from a partitioned table:
<programlisting>
ALTER TABLE measurement
    DETACH PARTITION measurement_y2015m12;
</programlisting></para>
________________________________________________________-->
  <para>
   从一个分区表分离一个分区：
<programlisting>
ALTER TABLE measurement
    DETACH PARTITION measurement_y2015m12;
</programlisting></para>
<!-- pgdoc-cn_end sig_en=d5da8cff80c9040ac6f47978c1e40c7e -->

 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
  <title>Compatibility</title>
________________________________________________________-->
  <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=19100f875320a683eaf2ee91d62b2d3b sig_cn_org=None source=14.1 
  <para>
   The forms <literal>ADD</literal> (without <literal>USING INDEX</literal>),
   <literal>DROP [COLUMN]</literal>, <literal>DROP IDENTITY</literal>, <literal>RESTART</literal>,
   <literal>SET DEFAULT</literal>, <literal>SET DATA TYPE</literal> (without <literal>USING</literal>),
   <literal>SET GENERATED</literal>, and <literal>SET <replaceable>sequence_option</replaceable></literal>
   conform with the SQL standard.  The other forms are
   <productname>PostgreSQL</productname> extensions of the SQL standard.
   Also, the ability to specify more than one manipulation in a single
   <command>ALTER TABLE</command> command is an extension.
  </para>
________________________________________________________-->
  <para>
   形式<literal>ADD</literal>（没有<literal>USING INDEX</literal>）、
   <literal>DROP [COLUMN]</literal>、<literal>DROP IDENTITY</literal>、<literal>RESTART</literal>、
   <literal>SET DEFAULT</literal>、<literal>SET DATA TYPE</literal>（没有<literal>USING</literal>)、
   <literal>SET GENERATED</literal>以及<literal>SET <replaceable>sequence_option</replaceable></literal>服从SQL标准。其他形式都是<productname>PostgreSQL</productname>对SQL标准的扩展。此外，在单个<command>ALTER TABLE</command>命令中指定多个操作的能力是一种扩展。
  </para>
<!-- pgdoc-cn_end sig_en=19100f875320a683eaf2ee91d62b2d3b -->

<!-- pgdoc-cn_start sig_en=7de1256ae2eab459b461868be09538f3 sig_cn_org=None source=14.1 
  <para>
   <command>ALTER TABLE DROP COLUMN</command> can be used to drop the only
   column of a table, leaving a zero-column table.  This is an
   extension of SQL, which disallows zero-column tables.
  </para>
________________________________________________________-->
  <para>
   <command>ALTER TABLE DROP COLUMN</command>可以被用来删除一个表的唯一的
   列，从而留下一个零列的表。这是一种 SQL 的扩展，SQL 中不允许零列的表。
  </para>
<!-- pgdoc-cn_end sig_en=7de1256ae2eab459b461868be09538f3 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=8b7cc214676b443e6527e3d6bf054420 sig_cn_org=None source=14.1 
  <title>See Also</title>
________________________________________________________-->
  <title>另见</title>
<!-- pgdoc-cn_end sig_en=8b7cc214676b443e6527e3d6bf054420 -->

  <simplelist type="inline">
   <member><xref linkend="sql-createtable"/></member>
  </simplelist>
 </refsect1>
</refentry>
