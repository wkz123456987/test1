<!--
doc/src/sgml/ref/pgupgrade.sgml
PostgreSQL documentation
-->

<refentry id="pgupgrade">
<!-- pgdoc-cn_start sig_en=095e4635ca5498b8cec536e8435cb667 sig_cn_org=None source=14.1 
 <indexterm zone="pgupgrade">
  <primary>pg_upgrade</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="pgupgrade">
  <primary>pg_upgrade</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=095e4635ca5498b8cec536e8435cb667 -->

 <refmeta>
  <refentrytitle><application>pg_upgrade</application></refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo>Application</refmiscinfo>
 </refmeta>

<!-- pgdoc-cn_start sig_en=0c504c821392b97fd4be1fbe893c83ca sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>pg_upgrade</refname>
  <refpurpose>upgrade a <productname>PostgreSQL</productname> server instance</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>pg_upgrade</refname>
  <refpurpose>升级<productname>PostgreSQL</productname>服务器实例</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=0c504c821392b97fd4be1fbe893c83ca -->

 <refsynopsisdiv>
  <cmdsynopsis>
   <command>pg_upgrade</command>
   <arg choice="plain"><option>-b</option></arg>
   <arg choice="plain"><replaceable>oldbindir</replaceable></arg>
   <arg choice="opt"><option>-B</option> <replaceable>newbindir</replaceable></arg>
   <arg choice="plain"><option>-d</option></arg>
   <arg choice="plain"><replaceable>oldconfigdir</replaceable></arg>
   <arg choice="plain"><option>-D</option></arg>
   <arg choice="plain"><replaceable>newconfigdir</replaceable></arg>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
  </cmdsynopsis>
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=20939aa3ced80ae0b138a1c162378f9a sig_cn_org=6c1ae54909cd0616c655589ac4561a66 source=15.7 
 <para>
  <application>pg_upgrade</application> (formerly called <application>pg_migrator</application>) allows data
  stored in <productname>PostgreSQL</productname> data files to be upgraded to a later <productname>PostgreSQL</productname>
  major version without the data dump/restore typically required for
  major version upgrades, e.g., from 9.5.8 to 9.6.4 or from 10.7 to 11.2.
  It is not required for minor version upgrades, e.g., from 9.6.2 to 9.6.3
  or from 10.1 to 10.2.
 </para>
________________________________________________________-->
 <para>
  <application>pg_upgrade</application>（以前称为<application>pg_migrator</application>）允许将存储在
  <productname>PostgreSQL</productname>数据文件中的数据升级到后续的<productname>PostgreSQL</productname>
  主要版本，而无需进行通常需要的数据转储/恢复
  主要版本升级，例如，从9.5.8升级到9.6.4或从10.7升级到11.2。
  对于次要版本升级，例如，从9.6.2升级到9.6.3
  或从10.1升级到10.2，则不需要。
</para>
<!-- pgdoc-cn_end sig_en=20939aa3ced80ae0b138a1c162378f9a -->

<!-- pgdoc-cn_start sig_en=228cf72a5a86f71b4df2eaa67aebf638 sig_cn_org=None source=14.1 
 <para>
  Major PostgreSQL releases regularly add new features that often
  change the layout of the system tables, but the internal data storage
  format rarely changes.  <application>pg_upgrade</application> uses this fact
  to perform rapid upgrades by creating new system tables and simply
  reusing the old user data files.  If a future major release ever
  changes the data storage format in a way that makes the old data
  format unreadable, <application>pg_upgrade</application> will not be usable
  for such upgrades.  (The community will attempt to avoid such
  situations.)
 </para>
________________________________________________________-->
 <para>
  PostgreSQL主发行版本通常会加入新的特性，这些新特性常常会更改系统表的
  布局，但是内部数据存储格式很少会改变。<application>pg_upgrade</application>
  使用这一事实来通过创建新系统表并且重用旧的用户数据文件来执行快速升级。
  如果未来的主发行版本更改了数据存储格式，导致旧数据格式不可读，那么
  <application>pg_upgrade</application>将无法用于此类升级。（社区将努力避免这种情况）。
 </para>
<!-- pgdoc-cn_end sig_en=228cf72a5a86f71b4df2eaa67aebf638 -->

<!-- pgdoc-cn_start sig_en=046bec38227c2b95310b5293f2038bc3 sig_cn_org=None source=14.1 
 <para>
  <application>pg_upgrade</application> does its best to
  make sure the old and new clusters are binary-compatible, e.g.,  by
  checking for compatible compile-time settings, including 32/64-bit
  binaries.  It is important that
  any external modules are also binary compatible, though this cannot
  be checked by <application>pg_upgrade</application>.
 </para>
________________________________________________________-->
 <para>
  <application>pg_upgrade</application>会尽力（例如通过检查兼容的编译时设
  置）确保新旧集簇在二进制上也是兼容的，包括 32/64 位二进制。保持
  外部模块也是二进制兼容的也很重要，不过
  <application>pg_upgrade</application>无法检查这一点。
 </para>
<!-- pgdoc-cn_end sig_en=046bec38227c2b95310b5293f2038bc3 -->

<!-- pgdoc-cn_start sig_en=fbf1f1fa1f1928872f8e73bf6e4fddcc sig_cn_org=bb9551cb91939b059399f1175022da7b source=15.7 
  <para>
   pg_upgrade supports upgrades from 9.2.X and later to the current
   major release of <productname>PostgreSQL</productname>, including snapshot and beta releases.
  </para>
________________________________________________________-->
  <para>
   pg_upgrade支持从9.2.X及更高版本升级到当前主要版本的<productname>PostgreSQL</productname>，包括快照和beta版本。
</para>
<!-- pgdoc-cn_end sig_en=fbf1f1fa1f1928872f8e73bf6e4fddcc -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=ee3f399228d18d2103d5b7f4e0aeeba8 sig_cn_org=None source=14.1 
  <title>Options</title>
________________________________________________________-->
  <title>选项</title>
<!-- pgdoc-cn_end sig_en=ee3f399228d18d2103d5b7f4e0aeeba8 -->

<!-- pgdoc-cn_start sig_en=3a4905f219a51a97132f6c68831a75d5 sig_cn_org=ec3841ba4f98113de31edbb90dcec674 source=15.7 
   <para>
    <application>pg_upgrade</application> accepts the following command-line arguments:

    <variablelist>

     <varlistentry>
________________________________________________________-->
   <para>
    <application>pg_upgrade</application>接受以下命令行参数：

    <variablelist>

     <varlistentry>
<!-- pgdoc-cn_end sig_en=3a4905f219a51a97132f6c68831a75d5 -->
      <term><option>-b</option> <replaceable>bindir</replaceable></term>
      <term><option>--old-bindir=</option><replaceable>bindir</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=dc80ee3d75a678f61e43cc0338233959 sig_cn_org=497a15da1e8f522bf6eb879866e29bec source=15.7 
<para>the old PostgreSQL executable directory;
      environment variable <envar>PGBINOLD</envar></para>
________________________________________________________-->
<para>旧的PostgreSQL可执行文件目录；
      环境变量<envar>PGBINOLD</envar></para>
<!-- pgdoc-cn_end sig_en=dc80ee3d75a678f61e43cc0338233959 -->
</listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-B</option> <replaceable>bindir</replaceable></term>
      <term><option>--new-bindir=</option><replaceable>bindir</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=1bccf4be84e15719cfff5714859419bc sig_cn_org=3345031f8ca2c23845c9445147691e99 source=15.7 
<para>the new PostgreSQL executable directory;
      default is the directory where <application>pg_upgrade</application> resides;
      environment variable <envar>PGBINNEW</envar></para>
________________________________________________________-->
<para>新的PostgreSQL可执行文件目录；默认为<application>pg_upgrade</application>所在的目录；
      环境变量<envar>PGBINNEW</envar></para>
<!-- pgdoc-cn_end sig_en=1bccf4be84e15719cfff5714859419bc -->
</listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-c</option></term>
      <term><option>--check</option></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=cf6d31d8faadebd33a7fd20d472522b8 sig_cn_org=106067559b3bb35d068b2f71675d9a60 source=15.7 
<para>check clusters only, don't change any data</para>
________________________________________________________-->
<para>仅检查集群，不更改任何数据</para>
<!-- pgdoc-cn_end sig_en=cf6d31d8faadebd33a7fd20d472522b8 -->
</listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-d</option> <replaceable>configdir</replaceable></term>
      <term><option>--old-datadir=</option><replaceable>configdir</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=00fad0ea90f28b7cb1470b60e4124567 sig_cn_org=b352862318346952a4600405366a768d source=15.7 
<para>the old database cluster configuration directory; environment
      variable <envar>PGDATAOLD</envar></para>
________________________________________________________-->
<para>旧数据库集群配置目录；环境变量<envar>PGDATAOLD</envar></para>
<!-- pgdoc-cn_end sig_en=00fad0ea90f28b7cb1470b60e4124567 -->
</listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-D</option> <replaceable>configdir</replaceable></term>
      <term><option>--new-datadir=</option><replaceable>configdir</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=2c7e07ebb5badfd1caed699fbc86feb8 sig_cn_org=ed6b35cfc0c23a1e7a7cf9e0e3a3c8ad source=15.7 
<para>the new database cluster configuration directory; environment
      variable <envar>PGDATANEW</envar></para>
________________________________________________________-->
<para>新的数据库集群配置目录；环境变量<envar>PGDATANEW</envar></para>
<!-- pgdoc-cn_end sig_en=2c7e07ebb5badfd1caed699fbc86feb8 -->
</listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-j <replaceable class="parameter">njobs</replaceable></option></term>
      <term><option>--jobs=<replaceable class="parameter">njobs</replaceable></option></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=b89ea48eb3a5db800149ea8fc51ef094 sig_cn_org=66cef000efe844c16bc65a6ad3385ba2 source=15.7 
<para>number of simultaneous processes or threads to use
      </para>
________________________________________________________-->
<para>同时使用的进程或线程数量</para>
<!-- pgdoc-cn_end sig_en=b89ea48eb3a5db800149ea8fc51ef094 -->
</listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-k</option></term>
      <term><option>--link</option></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=7bfb81edf32a51409fcaef61b3448054 sig_cn_org=7ce7a05d46edc83c2e62f38b867253c8 source=15.7 
<para>use hard links instead of copying files to the new
      cluster</para>
________________________________________________________-->
<para>使用硬链接而不是将文件复制到新的集群</para>
<!-- pgdoc-cn_end sig_en=7bfb81edf32a51409fcaef61b3448054 -->
</listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-N</option></term>
      <term><option>--no-sync</option></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=45d19d692019fd804d70a910a0c5b9eb sig_cn_org=ff883e1ac2a9ca2c59e942c3d8d2f9d3 source=15.7 
       <para>
        By default, <command>pg_upgrade</command> will wait for all files
        of the upgraded cluster to be written safely to disk.  This option
        causes <command>pg_upgrade</command> to return without waiting, which
        is faster, but means that a subsequent operating system crash can leave
        the data directory corrupt.  Generally, this option is
        useful for testing but should not be used on a production
        installation.
       </para>
________________________________________________________-->
       <para>
        默认情况下，<command>pg_upgrade</command>将等待升级后集群的所有文件安全写入磁盘。
        此选项使<command>pg_upgrade</command>在不等待的情况下返回，这样更快，但意味着随后的操作系统崩溃可能会导致数据目录损坏。
        通常，此选项对于测试很有用，但不应在生产安装中使用。
       </para>
<!-- pgdoc-cn_end sig_en=45d19d692019fd804d70a910a0c5b9eb -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-o</option> <replaceable class="parameter">options</replaceable></term>
      <term><option>--old-options</option> <replaceable class="parameter">options</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=8c20e5362f1dea228f9670c491351c04 sig_cn_org=540a75ebe60ec328d8f74863e6b19926 source=15.7 
<para>options to be passed directly to the
      old <command>postgres</command> command;  multiple
      option invocations are appended</para>
________________________________________________________-->
<para>要直接传递给旧的<command>postgres</command>命令的选项；多个选项调用会被追加</para>
<!-- pgdoc-cn_end sig_en=8c20e5362f1dea228f9670c491351c04 -->
</listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-O</option> <replaceable class="parameter">options</replaceable></term>
      <term><option>--new-options</option> <replaceable class="parameter">options</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=4a878bc450b71655f7f7cbc0739b6b78 sig_cn_org=4a9d02db9ee0c240ed01de738d3ae398 source=15.7 
<para>options to be passed directly to the
      new <command>postgres</command> command;  multiple
      option invocations are appended</para>
________________________________________________________-->
<para>要直接传递给新的<command>postgres</command>命令的选项；多个选项调用会被追加</para>
<!-- pgdoc-cn_end sig_en=4a878bc450b71655f7f7cbc0739b6b78 -->
</listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-p</option> <replaceable>port</replaceable></term>
      <term><option>--old-port=</option><replaceable>port</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=ddabb35ca4dd8bc07bd28e7bed2db09f sig_cn_org=19a44fda8f073b552e5d3b6844f2f186 source=15.7 
<para>the old cluster port number; environment
      variable <envar>PGPORTOLD</envar></para>
________________________________________________________-->
<para>旧的集群端口号；环境变量<envar>PGPORTOLD</envar></para>
<!-- pgdoc-cn_end sig_en=ddabb35ca4dd8bc07bd28e7bed2db09f -->
</listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-P</option> <replaceable>port</replaceable></term>
      <term><option>--new-port=</option><replaceable>port</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=2529e619861e929470e0157228559c14 sig_cn_org=b021dffb91f7a18db9466a72c8650d6a source=15.7 
<para>the new cluster port number; environment
      variable <envar>PGPORTNEW</envar></para>
________________________________________________________-->
<para>新的集群端口号；环境变量<envar>PGPORTNEW</envar></para>
<!-- pgdoc-cn_end sig_en=2529e619861e929470e0157228559c14 -->
</listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-r</option></term>
      <term><option>--retain</option></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=8b9f6b1391e48881fbd6e7d086c32a79 sig_cn_org=733a56861ecaea34f7aaf00bbd93de00 source=15.7 
<para>retain SQL and log files even after successful completion
      </para>
________________________________________________________-->
<para>即使成功完成后也保留SQL和日志文件</para>
<!-- pgdoc-cn_end sig_en=8b9f6b1391e48881fbd6e7d086c32a79 -->
</listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option> <replaceable>dir</replaceable></term>
      <term><option>--socketdir=</option><replaceable>dir</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=90c946e4acf8cf1f225254af397c6587 sig_cn_org=c6836a68f03fc3b789013dcbbfbce1d0 source=15.7 
<para>directory to use for postmaster sockets during upgrade;
      default is current working directory; environment
      variable <envar>PGSOCKETDIR</envar></para>
________________________________________________________-->
<para>用于升级期间的postmaster套接字的目录；
      默认为当前工作目录；环境变量<envar>PGSOCKETDIR</envar></para>
<!-- pgdoc-cn_end sig_en=90c946e4acf8cf1f225254af397c6587 -->
</listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-U</option> <replaceable>username</replaceable></term>
      <term><option>--username=</option><replaceable>username</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=3f3730839cefb0fe8ef1a84a1cb50351 sig_cn_org=30f6269f19e8d1cfc691215bcf49e4a6 source=15.7 
<para>cluster's install user name; environment
      variable <envar>PGUSER</envar></para>
________________________________________________________-->
<para>集群的安装用户名称；环境变量<envar>PGUSER</envar></para>
<!-- pgdoc-cn_end sig_en=3f3730839cefb0fe8ef1a84a1cb50351 -->
</listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-v</option></term>
      <term><option>--verbose</option></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=39f5bb9abe380d8928b13ed10dbc565a sig_cn_org=f06dcac537f3eae01470c7a75296d23d source=15.7 
<para>enable verbose internal logging</para>
________________________________________________________-->
<para>启用详细的内部日志记录</para>
<!-- pgdoc-cn_end sig_en=39f5bb9abe380d8928b13ed10dbc565a -->
</listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-V</option></term>
      <term><option>--version</option></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=ca0749a2219cd3be800bff218b08fa49 sig_cn_org=be17e692dde399170e2cf5e4bb2f88d3 source=15.7 
<para>display version information, then exit</para>
________________________________________________________-->
<para>显示版本信息，然后退出</para>
<!-- pgdoc-cn_end sig_en=ca0749a2219cd3be800bff218b08fa49 -->
</listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--clone</option></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=a24f69709c38a44e7a1be0fe4b116758 sig_cn_org=abd29637f8101929c5f3fd1f8b9f18a7 source=15.7 
       <para>
        Use efficient file cloning (also known as <quote>reflinks</quote> on
        some systems) instead of copying files to the new cluster.  This can
        result in near-instantaneous copying of the data files, giving the
        speed advantages of <option>-k</option>/<option>-&minus;link</option> while
        leaving the old cluster untouched.
       </para>
________________________________________________________-->
       <para>
        使用高效的文件克隆（有些系统上也称为<quote>reflinks</quote>）而不是将文件复制到新的集群中。
		这可以实现几乎瞬间复制数据文件，提供<option>-k</option>/<option>-−link</option>的速度优势，
		同时保持原有集群的完整性。
       </para>
<!-- pgdoc-cn_end sig_en=a24f69709c38a44e7a1be0fe4b116758 -->

<!-- pgdoc-cn_start sig_en=faa3eafc1fa3a11a1dd7c5619bb46b9d sig_cn_org=d0d6473875cf9a646ef23b6e7618365b source=15.7 
       <para>
        File cloning is only supported on some operating systems and file
        systems.  If it is selected but not supported, the
        <application>pg_upgrade</application> run will error.  At present, it
        is supported on Linux (kernel 4.5 or later) with Btrfs and XFS (on
        file systems created with reflink support), and on macOS with APFS.
       </para>
________________________________________________________-->
       <para>
        文件克隆仅在某些操作系统和文件系统上受支持。如果选择了但不受支持，<application>pg_upgrade</application>运行将出错。目前，在Linux（内核4.5或更高版本）上支持Btrfs和XFS（在启用reflink支持的文件系统上创建），以及在macOS上支持APFS。
       </para>
<!-- pgdoc-cn_end sig_en=faa3eafc1fa3a11a1dd7c5619bb46b9d -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-?</option></term>
      <term><option>--help</option></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=71c10514671db64dfcd5d4f753015763 sig_cn_org=ca7333244cc9b29bb000e96880b7829f source=15.7 
<para>show help, then exit</para>
________________________________________________________-->
<para>显示帮助信息，然后退出</para>
<!-- pgdoc-cn_end sig_en=71c10514671db64dfcd5d4f753015763 -->
</listitem>
     </varlistentry>

    </variablelist>
   </para>

 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=0e392a89999e0f3b2cb519a62061c2de sig_cn_org=None source=14.1 
  <title>Usage</title>
________________________________________________________-->
  <title>使用</title>
<!-- pgdoc-cn_end sig_en=0e392a89999e0f3b2cb519a62061c2de -->

<!-- pgdoc-cn_start sig_en=cba1bb95d921cbfbcceff1a3808b5a2e sig_cn_org=None source=14.1 
  <para>
   These are the steps to perform an upgrade
   with <application>pg_upgrade</application>:
  </para>
________________________________________________________-->
  <para>
   下面是用<application>pg_upgrade</application>执行一次升级的步骤：
  </para>
<!-- pgdoc-cn_end sig_en=cba1bb95d921cbfbcceff1a3808b5a2e -->

  <procedure>
   <step performance="optional">
<!-- pgdoc-cn_start sig_en=99d7b7190b15ab7806d96b4ebed19d3e sig_cn_org=None source=14.1 
    <title>Optionally move the old cluster</title>
________________________________________________________-->
    <title>移动旧集簇（可选）</title>
<!-- pgdoc-cn_end sig_en=99d7b7190b15ab7806d96b4ebed19d3e -->

<!-- pgdoc-cn_start sig_en=8287d6547a3362eb725cd28e11a8ad15 sig_cn_org=None source=14.1 
    <para>
     If you are using a version-specific installation directory, e.g.,
     <filename>/opt/PostgreSQL/&majorversion;</filename>, you do not need to move the old cluster. The
     graphical installers all use version-specific installation directories.
    </para>
________________________________________________________-->
    <para>
     如果你在使用一个与版本相关的安装目录（例如
     <filename>/opt/PostgreSQL/&majorversion;</filename>），你就不需要移动旧的集簇。
     图形化的安装程序会使用版本相关的安装目录。
    </para>
<!-- pgdoc-cn_end sig_en=8287d6547a3362eb725cd28e11a8ad15 -->

<!-- pgdoc-cn_start sig_en=bf5c2bae8937ebd8a1e8d829ebba5c57 sig_cn_org=None source=14.1 
    <para>
     If your installation directory is not version-specific, e.g.,
     <filename>/usr/local/pgsql</filename>, it is necessary to move the current PostgreSQL install
     directory so it does not interfere with the new <productname>PostgreSQL</productname> installation.
     Once the current <productname>PostgreSQL</productname> server is shut down, it is safe to rename the
     PostgreSQL installation directory; assuming the old directory is
     <filename>/usr/local/pgsql</filename>, you can do:

<programlisting>
mv /usr/local/pgsql /usr/local/pgsql.old
</programlisting>
     to rename the directory.
    </para>
________________________________________________________-->
    <para>
     如果你的安装目录不是版本相关的（例如<filename>/usr/local/pgsql</filename>），
     就有必要移动当前的 PostgreSQL 安装目录，以免它干扰新的
     <productname>PostgreSQL</productname>安装。一旦当前的
     <productname>PostgreSQL</productname>服务器被关闭，就可以安全地重命名
     PostgreSQL 安装目录。假设旧目录是
     <filename>/usr/local/pgsql</filename>，你可以这样：

<programlisting>
mv /usr/local/pgsql /usr/local/pgsql.old
</programlisting>
     来重命名该目录。
    </para>
<!-- pgdoc-cn_end sig_en=bf5c2bae8937ebd8a1e8d829ebba5c57 -->
   </step>

   <step>
<!-- pgdoc-cn_start sig_en=99555872680a3df04968fe2f942d47e6 sig_cn_org=None source=14.1 
    <title>For source installs, build the new version</title>
________________________________________________________-->
    <title>对于源码安装，编译新版本</title>
<!-- pgdoc-cn_end sig_en=99555872680a3df04968fe2f942d47e6 -->

<!-- pgdoc-cn_start sig_en=696941e543996e490ea4b27402c17c75 sig_cn_org=None source=14.1 
    <para>
     Build the new PostgreSQL source with <command>configure</command> flags that are compatible
     with the old cluster. <application>pg_upgrade</application> will check <command>pg_controldata</command> to make
     sure all settings are compatible before starting the upgrade.
    </para>
________________________________________________________-->
    <para>
     用兼容旧集簇的<command>configure</command>标记编译新的
     PostgreSQL 源码。在开始升级之前，<application>pg_upgrade</application>
     将检查<command>pg_controldata</command>来确保所有设置都是兼容的。
    </para>
<!-- pgdoc-cn_end sig_en=696941e543996e490ea4b27402c17c75 -->
   </step>

   <step>
<!-- pgdoc-cn_start sig_en=fb164ef4e204cd9a38da43d3453f99bd sig_cn_org=None source=14.1 
    <title>Install the new PostgreSQL binaries</title>
________________________________________________________-->
    <title>安装新的 PostgreSQL 二进制文件</title>
<!-- pgdoc-cn_end sig_en=fb164ef4e204cd9a38da43d3453f99bd -->

<!-- pgdoc-cn_start sig_en=a4f93c3dfcb052195bd7ba3ccb0eae9e sig_cn_org=None source=14.1 
    <para>
     Install the new server's binaries and support
     files.  <application>pg_upgrade</application> is included in a default installation.
    </para>
________________________________________________________-->
    <para>
     安装新服务器的二进制文件和支持文件。<application>pg_upgrade</application>
     会被包含在默认的安装中。
    </para>
<!-- pgdoc-cn_end sig_en=a4f93c3dfcb052195bd7ba3ccb0eae9e -->

<!-- pgdoc-cn_start sig_en=6f082abdb6db8c7f09bab2418f8c08fa sig_cn_org=None source=14.1 
    <para>
     For source installs, if you wish to install the new server in a custom
     location, use the <literal>prefix</literal> variable:

<programlisting>
make prefix=/usr/local/pgsql.new install
</programlisting></para>
________________________________________________________-->
    <para>
     对于源码安装，如果你希望把新服务器安装在一个自定义的位置，
     可以使用<literal>prefix</literal>变量：

<programlisting>
make prefix=/usr/local/pgsql.new install
</programlisting></para>
<!-- pgdoc-cn_end sig_en=6f082abdb6db8c7f09bab2418f8c08fa -->
   </step>

   <step>
<!-- pgdoc-cn_start sig_en=97b7953c920b16a9cb0d56b5bbcc1716 sig_cn_org=None source=14.1 
    <title>Initialize the new PostgreSQL cluster</title>
________________________________________________________-->
    <title>初始化新的 PostgreSQL 集簇</title>
<!-- pgdoc-cn_end sig_en=97b7953c920b16a9cb0d56b5bbcc1716 -->

<!-- pgdoc-cn_start sig_en=ba1b774042337a56700d3ffb65fd9849 sig_cn_org=None source=14.1 
    <para>
     Initialize the new cluster using <command>initdb</command>.
     Again, use compatible <command>initdb</command>
     flags that match the old cluster. Many
     prebuilt installers do this step automatically. There is no need to
     start the new cluster.
    </para>
________________________________________________________-->
    <para>
     使用<command>initdb</command>初始化新集簇。这里也要使用与
     旧集簇相兼容的<command>initdb</command>标志。许多预编译的
     安装程序会自动做这个步骤。这里没有必要启动新集簇。
    </para>
<!-- pgdoc-cn_end sig_en=ba1b774042337a56700d3ffb65fd9849 -->
   </step>

   <step>
<!-- pgdoc-cn_start sig_en=e6a0a5256b095e9ceef1a0b064eddc30 sig_cn_org=None source=14.1 
    <title>Install extension shared object files</title>
________________________________________________________-->
    <title>安装扩展共享对象文件</title>
<!-- pgdoc-cn_end sig_en=e6a0a5256b095e9ceef1a0b064eddc30 -->

<!-- pgdoc-cn_start sig_en=1258ea8e5a5ab196ad8cebde37b53ac9 sig_cn_org=None source=14.1 
    <para>
     Many extensions and custom modules, whether from
     <filename>contrib</filename> or another source, use shared object
     files (or DLLs), e.g., <filename>pgcrypto.so</filename>.  If the old
     cluster used these, shared object files matching the new server binary
     must be installed in the new cluster, usually via operating system
     commands.  Do not load the schema definitions, e.g., <command>CREATE
     EXTENSION pgcrypto</command>, because these will be duplicated from
     the old cluster.  If extension updates are available,
     <application>pg_upgrade</application> will report this and create
     a script that can be run later to update them.
    </para>
________________________________________________________-->
    <para>
     许多扩展和自定义模块，无论是来自<filename>contrib</filename>或其他源，使用共享对象文件(或DLLs)，例如， <filename>pgcrypto.so</filename>。
     如果旧集群使用过这些，匹配新服务器二进制的共享对象文件，必须安装在新集群中。
     通常是通过操作系统命令。
     不要加载模式定义，例如<command>CREATE EXTENSION pgcrypto</command>，因为这些将从旧集群复制。
     如果扩展更新是可用的，<application>pg_upgrade</application>将报告这一点，并创建一个脚本，可以稍后运行来更新它们。
    </para>
<!-- pgdoc-cn_end sig_en=1258ea8e5a5ab196ad8cebde37b53ac9 -->
   </step>

   <step>
<!-- pgdoc-cn_start sig_en=ab337ec4cf1c5fa002e8159a52bbbbd0 sig_cn_org=None source=14.1 
    <title>Copy custom full-text search files</title>
________________________________________________________-->
    <title>拷贝定制的全文本检索文件</title>
<!-- pgdoc-cn_end sig_en=ab337ec4cf1c5fa002e8159a52bbbbd0 -->

<!-- pgdoc-cn_start sig_en=84930c8bc61107f5a254a9cb1c807e8c sig_cn_org=None source=14.1 
    <para>
     Copy any custom full text search files (dictionary, synonym,
     thesaurus, stop words) from the old to the new cluster.
    </para>
________________________________________________________-->
    <para>
     从旧集群向新集群拷贝任何定制化全文本检索文件(词典、同义词、辞典、停用词)
    </para>
<!-- pgdoc-cn_end sig_en=84930c8bc61107f5a254a9cb1c807e8c -->
   </step>

   <step>
<!-- pgdoc-cn_start sig_en=ca6d2e3a3f6f559b8af7e380056cbe07 sig_cn_org=None source=14.1 
    <title>Adjust authentication</title>
________________________________________________________-->
    <title>调整认证</title>
<!-- pgdoc-cn_end sig_en=ca6d2e3a3f6f559b8af7e380056cbe07 -->

<!-- pgdoc-cn_start sig_en=cd55d4f6d78331e8d4d401bdfa8e2e47 sig_cn_org=None source=14.1 
    <para>
     <command>pg_upgrade</command> will connect to the old and new servers several
     times, so you might want to set authentication to <literal>peer</literal>
     in <filename>pg_hba.conf</filename> or use a <filename>~/.pgpass</filename> file
     (see <xref linkend="libpq-pgpass"/>).
    </para>
________________________________________________________-->
    <para>
     <command>pg_upgrade</command>将会多次连接到旧服务器和新服务器，因此
     你可能想要在<filename>pg_hba.conf</filename>中把认证设置成
     <literal>peer</literal>或者使用一个<filename>~/.pgpass</filename>文件（见
     <xref linkend="libpq-pgpass"/>）。
    </para>
<!-- pgdoc-cn_end sig_en=cd55d4f6d78331e8d4d401bdfa8e2e47 -->
   </step>

   <step>
<!-- pgdoc-cn_start sig_en=ae016e1959de714262f9b7200fd91c13 sig_cn_org=None source=14.1 
    <title>Stop both servers</title>
________________________________________________________-->
    <title>停止两个服务器</title>
<!-- pgdoc-cn_end sig_en=ae016e1959de714262f9b7200fd91c13 -->

<!-- pgdoc-cn_start sig_en=82dca03a0eceb837fdb674879fea9bf7 sig_cn_org=None source=14.1 
    <para>
     Make sure both database servers are stopped using, on Unix, e.g.:

<programlisting>
pg_ctl -D /opt/PostgreSQL/9.6 stop
pg_ctl -D /opt/PostgreSQL/&majorversion; stop
</programlisting>

     or on Windows, using the proper service names:

<programlisting>
NET STOP postgresql-9.6
NET STOP postgresql-&majorversion;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     确认两个数据库服务器都被停止使用，例如在 Unix 上可以：

<programlisting>
pg_ctl -D /opt/PostgreSQL/9.6 stop
pg_ctl -D /opt/PostgreSQL/&majorversion; stop
</programlisting>

     或者在 Windows 上使用正确的服务名：

<programlisting>
NET STOP postgresql-9.6
NET STOP postgresql-&majorversion;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=82dca03a0eceb837fdb674879fea9bf7 -->

<!-- pgdoc-cn_start sig_en=1aebbfe69600c1b9babb0e5e2c2a647b sig_cn_org=7bacf951d0042b69acf4c62e3918bff6 source=15.7 
    <para>
     Streaming replication and log-shipping standby servers must be
     running during this shutdown so they receive all changes.
    </para>
________________________________________________________-->
    <para>
     流复制和日志传送备用服务器必须在此关闭期间运行，以便它们接收所有更改。
    </para>
<!-- pgdoc-cn_end sig_en=1aebbfe69600c1b9babb0e5e2c2a647b -->
   </step>

   <step>
<!-- pgdoc-cn_start sig_en=54d9313bc84126414235163b2f0ac5c0 sig_cn_org=None source=14.1 
    <title>Prepare for standby server upgrades</title>
________________________________________________________-->
    <title>为后备服务器升级做准备</title>
<!-- pgdoc-cn_end sig_en=54d9313bc84126414235163b2f0ac5c0 -->

<!-- pgdoc-cn_start sig_en=b98106ab20a70a7d10eb57a573b6d4f3 sig_cn_org=764c58a085362a92fbf69d7ab266d93f source=15.7 
    <para>
     If you are upgrading standby servers using methods outlined in section <xref
     linkend="pgupgrade-step-replicas"/>, verify that the old standby
     servers are caught up by running <application>pg_controldata</application>
     against the old primary and standby clusters.  Verify that the
     <quote>Latest checkpoint location</quote> values match in all clusters.
     Also, make sure <varname>wal_level</varname> is not set to
     <literal>minimal</literal> in the <filename>postgresql.conf</filename> file on the
     new primary cluster.
    </para>
________________________________________________________-->
    <para>
     如果您正在使用第<xref linkend="pgupgrade-step-replicas"/>节中概述的方法升级备用服务器，请通过运行<application>pg_controldata</application>命令检查旧的备用服务器和主服务器集群是否同步。
     确保所有集群中<quote>最新检查点位置</quote>的值匹配。此外，请确保在新的主服务器集群的<filename>postgresql.conf</filename>文件中未将<varname>wal_level</varname>设置为<literal>minimal</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=b98106ab20a70a7d10eb57a573b6d4f3 -->
   </step>

   <step>
<!-- pgdoc-cn_start sig_en=d3830d0f2b2cf17d91d79f2b1ee2f524 sig_cn_org=None source=14.1 
    <title>Run <application>pg_upgrade</application></title>
________________________________________________________-->
    <title>运行 <application>pg_upgrade</application></title>
<!-- pgdoc-cn_end sig_en=d3830d0f2b2cf17d91d79f2b1ee2f524 -->

<!-- pgdoc-cn_start sig_en=d9a5289a4d6da80b157dc21883ae2f8b sig_cn_org=None source=14.1 
    <para>
     Always run the <application>pg_upgrade</application> binary of the new server, not the old one.
     <application>pg_upgrade</application> requires the specification of the old and new cluster's
     data and executable (<filename>bin</filename>) directories. You can also specify
     user and port values, and whether you want the data files linked or cloned
     instead of the default copy behavior.
    </para>
________________________________________________________-->
    <para>
     总是应该运行新服务器而不是旧服务器的<application>pg_upgrade</application>二进制文件。
     <application>pg_upgrade</application>要求制定新旧集簇的数据和可执行文件（<filename>bin</filename>）目录。
     你也可以指定用户和端口值，以及你是否想要用链接或克隆来取代默认的复制行为对数据文件进行处理。
    </para>
<!-- pgdoc-cn_end sig_en=d9a5289a4d6da80b157dc21883ae2f8b -->

<!-- pgdoc-cn_start sig_en=159fc83a41dce18624b769ab5892a4a2 sig_cn_org=None source=14.1 
    <para>
     If you use link mode, the upgrade will be much faster (no file
     copying) and use less disk space, but you will not be able to access
     your old cluster
     once you start the new cluster after the upgrade.  Link mode also
     requires that the old and new cluster data directories be in the
     same file system.  (Tablespaces and <filename>pg_wal</filename> can be on
     different file systems.)
     Clone mode provides the same speed and disk space advantages but
     does not cause the old cluster to be unusable once the new cluster
     is started.  Clone mode also requires that the old and new data
     directories be in the same file system.  This mode is only available
     on certain operating systems and file systems.
    </para>
________________________________________________________-->
    <para>
     如果你使用链接模式，升级将会快很多（不需要文件拷贝）并且将使用
     更少的磁盘空间，但是在升级后一旦启动新集簇，旧集簇就无法被访问。
     链接模式也要求新旧集簇数据目录位于同一个文件系统中（表空间和
     <filename>pg_wal</filename>可以在不同的文件系统中）。
     克隆模式提供了相同的速度以及磁盘空间优势，但不会导致新群集启动后旧群集不可用。 
     克隆模式还需要新旧数据目录位于同一文件系统中。 此模式仅在某些操作系统和文件系统上可用。
    </para>
<!-- pgdoc-cn_end sig_en=159fc83a41dce18624b769ab5892a4a2 -->

<!-- pgdoc-cn_start sig_en=baa8519f4e5a74f7b58812f1bb24fd11 sig_cn_org=0e04bb241fcc9d530bab1944d0f7dca5 source=15.7 
    <para>
     The <option>-&minus;jobs</option> option allows multiple CPU cores to be used
     for copying/linking of files and to dump and restore database schemas
     in parallel;  a good place to start is the maximum of the number of
     CPU cores and tablespaces.  This option can dramatically reduce the
     time to upgrade a multi-database server running on a multiprocessor
     machine.
    </para>
________________________________________________________-->
    <para>
     <option>--jobs</option>选项允许多个CPU核用于文件的复制/链接以及并行转储和恢复数据库模式；一个好的起点是CPU核数和表空间数的最大值。这个选项可以显著减少在多处理器机器上运行的多数据库服务器升级所需的时间。
    </para>
<!-- pgdoc-cn_end sig_en=baa8519f4e5a74f7b58812f1bb24fd11 -->

<!-- pgdoc-cn_start sig_en=be04a162d3ca3391e25fadf9f11bef0a sig_cn_org=None source=14.1 
    <para>
     For Windows users, you must be logged into an administrative account, and
     then start a shell as the <literal>postgres</literal> user and set the proper path:

<programlisting>
RUNAS /USER:postgres "CMD.EXE"
SET PATH=%PATH%;C:\Program Files\PostgreSQL\&majorversion;\bin;
</programlisting>

     and then run <application>pg_upgrade</application> with quoted directories, e.g.:

<programlisting>
pg_upgrade.exe
        -&minus;old-datadir "C:/Program Files/PostgreSQL/9.6/data"
        -&minus;new-datadir "C:/Program Files/PostgreSQL/&majorversion;/data"
        -&minus;old-bindir "C:/Program Files/PostgreSQL/9.6/bin"
        -&minus;new-bindir "C:/Program Files/PostgreSQL/&majorversion;/bin"
</programlisting>

     Once started, <command>pg_upgrade</command> will verify the two clusters are compatible
     and then do the upgrade. You can use <command>pg_upgrade -&minus;check</command>
     to perform only the checks, even if the old server is still
     running. <command>pg_upgrade -&minus;check</command> will also outline any
     manual adjustments you will need to make after the upgrade.  If you
     are going to be using link or clone mode, you should use the option
     <option>-&minus;link</option> or <option>-&minus;clone</option> with
     <option>-&minus;check</option> to enable mode-specific checks.
     <command>pg_upgrade</command> requires write permission in the current directory.
    </para>
________________________________________________________-->
    <para>
     对于 Windows 用户，你必须以一个超级账号登录，并且以
     <literal>postgres</literal>用户启动一个 shell 并且设置正确的路径：

<programlisting>
RUNAS /USER:postgres "CMD.EXE"
SET PATH=%PATH%;C:\Program Files\PostgreSQL\&majorversion;\bin;
</programlisting>

     并且用带引号的目录运行<application>pg_upgrade</application>，例如：

<programlisting>
pg_upgrade.exe
        --old-datadir "C:/Program Files/PostgreSQL/9.6/data"
        --new-datadir "C:/Program Files/PostgreSQL/&majorversion;/data"
        --old-bindir "C:/Program Files/PostgreSQL/9.6/bin"
        --new-bindir "C:/Program Files/PostgreSQL/&majorversion;/bin"
</programlisting>

     一旦启动，<command>pg_upgrade</command>将验证两个集簇是否兼容并且
     执行升级。你可以使用<command>pg_upgrade --check</command>来只执行检查，
     这种模式即使在旧服务器还在运行时也能使用。
     <command>pg_upgrade --check</command>也将列出任何在更新后需要做的手工调整。
     如果你将要使用链接或克隆模式，你应该使用<option>--link</option>或<option>--clone</option>选项和<option>--check</option>一起来启用链接模式相关的检查。
     <command>pg_upgrade</command>要求在当前目录中的写权限。
    </para>
<!-- pgdoc-cn_end sig_en=be04a162d3ca3391e25fadf9f11bef0a -->

<!-- pgdoc-cn_start sig_en=de24ab19abfea77d6c94d27f15811cf3 sig_cn_org=None source=14.1 
    <para>
     Obviously, no one should be accessing the clusters during the
     upgrade.  <application>pg_upgrade</application> defaults to running servers
     on port 50432 to avoid unintended client connections.
     You can use the same port number for both clusters when doing an
     upgrade because the old and new clusters will not be running at the
     same time.  However, when checking an old running server, the old
     and new port numbers must be different.
    </para>
________________________________________________________-->
    <para>
     显然，没有人可以在升级期间访问这些集簇。<application>pg_upgrade</application>
     默认会在端口 50432 上运行服务器来避免意外的客户端连接。在做升级时，
     可以对两个集簇使用相同的端口号，因为新旧集簇不会在同时被运行。不过，
     在检查一个旧的运行中服务器时，新旧端口号必须不同。
    </para>
<!-- pgdoc-cn_end sig_en=de24ab19abfea77d6c94d27f15811cf3 -->

<!-- pgdoc-cn_start sig_en=7fd0db4e2069d4d687ef1ef656c5fea8 sig_cn_org=None source=14.1 
    <para>
     If an error occurs while restoring the database schema, <command>pg_upgrade</command> will
     exit and you will have to revert to the old cluster as outlined in <xref linkend="pgupgrade-step-revert"/>
     below. To try <command>pg_upgrade</command> again, you will need to modify the old
     cluster so the pg_upgrade schema restore succeeds. If the problem is a
     <filename>contrib</filename> module, you might need to uninstall the <filename>contrib</filename> module from
     the old cluster and install it in the new cluster after the upgrade,
     assuming the module is not being used to store user data.
    </para>
________________________________________________________-->
    <para>
     如果在恢复数据库模式时发生错误，<command>pg_upgrade</command>将会退出
     并且你必须按照下文<xref linkend="pgupgrade-step-revert"/>中所说的恢复
     旧集簇。要再次尝试<command>pg_upgrade</command>，你将需要修改
     旧集簇，这样 pg_upgrade 模式会成功恢复。如果问题是一个
     <filename>contrib</filename>模块，
     你可能需要从旧集簇中卸载该模块并且在升级后重新把它安装在新集簇中，不过
     这样做的前提是该模块没有被用来存储用户数据。
    </para>
<!-- pgdoc-cn_end sig_en=7fd0db4e2069d4d687ef1ef656c5fea8 -->
   </step>

   <step id="pgupgrade-step-replicas">
<!-- pgdoc-cn_start sig_en=06c651d045154f848e4dde254f0c862d sig_cn_org=None source=14.1 
    <title>Upgrade streaming replication and log-shipping standby servers</title>
________________________________________________________-->
    <title>升级流复制和日志传送后备服务器</title>
<!-- pgdoc-cn_end sig_en=06c651d045154f848e4dde254f0c862d -->

<!-- pgdoc-cn_start sig_en=314385b00565aceece93852cab04d7bc sig_cn_org=None source=14.1 
    <para>
     If you used link mode and have Streaming Replication (see <xref
     linkend="streaming-replication"/>) or Log-Shipping (see <xref
     linkend="warm-standby"/>) standby servers, you can follow these steps to
     quickly upgrade them.  You will not be running <application>pg_upgrade</application> on
     the standby servers, but rather <application>rsync</application> on the primary.
     Do not start any servers yet.
    </para>
________________________________________________________-->
    <para>
     如果使用链接模式并且有流复制（见<xref linkend="streaming-replication"/>）或者日志
     传送（见<xref linkend="warm-standby"/>）后备服务器，你可以遵照下面的
     步骤对它们进行快速的升级。你将不用在这些后备服务器上运行
     <application>pg_upgrade</application>，而是在主服务器上运行<application>rsync</application>。
     到这里还不要启动任何服务器。
    </para>
<!-- pgdoc-cn_end sig_en=314385b00565aceece93852cab04d7bc -->

<!-- pgdoc-cn_start sig_en=9f5aaa6bbfa17446063bf366144e993a sig_cn_org=None source=14.1 
    <para>
     If you did <emphasis>not</emphasis> use link mode, do not have or do not
     want to use <application>rsync</application>, or want an easier solution, skip
     the instructions in this section and simply recreate the standby
     servers once <application>pg_upgrade</application> completes and the new primary
     is running.
    </para>
________________________________________________________-->
    <para>
     如果你<emphasis>没有</emphasis>使用链接模式、没有或不想使用<application>rsync</application>或者想用一种更容易的解决方案，请跳过这一节中的过程并且在<application>pg_upgrade</application>完成并且新的主集簇开始运行后重建后备服务器。
    </para>
<!-- pgdoc-cn_end sig_en=9f5aaa6bbfa17446063bf366144e993a -->

    <procedure>

     <step>
<!-- pgdoc-cn_start sig_en=d3efa0bd459c162c33fdc5e094a1ae87 sig_cn_org=None source=14.1 
      <title>Install the new PostgreSQL binaries on standby servers</title>
________________________________________________________-->
      <title>在后备服务器上安装新的 PostgreSQL 二进制文件</title>
<!-- pgdoc-cn_end sig_en=d3efa0bd459c162c33fdc5e094a1ae87 -->

<!-- pgdoc-cn_start sig_en=7f3afa9c24720ef04f10488c0cf0dac8 sig_cn_org=None source=14.1 
      <para>
       Make sure the new binaries and support files are installed on all
       standby servers.
      </para>
________________________________________________________-->
      <para>
       确保新的二进制和支持文件被安装在所有后备服务器上。
      </para>
<!-- pgdoc-cn_end sig_en=7f3afa9c24720ef04f10488c0cf0dac8 -->
     </step>

     <step>
<!-- pgdoc-cn_start sig_en=c02580ccb27e4ebec74be4ec9f404986 sig_cn_org=None source=14.1 
      <title>Make sure the new standby data directories do <emphasis>not</emphasis> exist</title>
________________________________________________________-->
      <title>确保<emphasis>不</emphasis>存在新的后备机数据目录</title>
<!-- pgdoc-cn_end sig_en=c02580ccb27e4ebec74be4ec9f404986 -->

<!-- pgdoc-cn_start sig_en=c76b02e9e8b05ed829bdd7a9465d9359 sig_cn_org=None source=14.1 
      <para>
       Make sure the new standby data directories do <emphasis>not</emphasis>
       exist or are empty.  If <application>initdb</application> was run, delete
       the standby servers' new data directories.
      </para>
________________________________________________________-->
      <para>
       确保新的后备机数据目录<emphasis>不</emphasis>存在或者为空。如果
       运行过<application>initdb</application>，请删除后备服务器的新数据目录。
      </para>
<!-- pgdoc-cn_end sig_en=c76b02e9e8b05ed829bdd7a9465d9359 -->
     </step>

     <step>
<!-- pgdoc-cn_start sig_en=e6a0a5256b095e9ceef1a0b064eddc30 sig_cn_org=None source=14.1 
      <title>Install extension shared object files</title>
________________________________________________________-->
      <title>安装扩展共享对象文件</title>
<!-- pgdoc-cn_end sig_en=e6a0a5256b095e9ceef1a0b064eddc30 -->

<!-- pgdoc-cn_start sig_en=d041c67f406ee04c0c5827564553f2a3 sig_cn_org=None source=14.1 
      <para>
       Install the same extension shared object files on the new standbys
       that you installed in the new primary cluster.
      </para>
________________________________________________________-->
      <para>
       在新的后备机上安装和新的主集簇中相同的扩展共享对象文件。
      </para>
<!-- pgdoc-cn_end sig_en=d041c67f406ee04c0c5827564553f2a3 -->
     </step>

     <step>
<!-- pgdoc-cn_start sig_en=fcd9c4f0e8f8f96fd5d2eeb05e722b2b sig_cn_org=None source=14.1 
      <title>Stop standby servers</title>
________________________________________________________-->
      <title>停止后备服务器</title>
<!-- pgdoc-cn_end sig_en=fcd9c4f0e8f8f96fd5d2eeb05e722b2b -->

<!-- pgdoc-cn_start sig_en=aec9ba3c6dd669e3b043cd612a2ba07b sig_cn_org=None source=14.1 
      <para>
       If the standby servers are still running, stop them now using the
       above instructions.
      </para>
________________________________________________________-->
      <para>
       如果后备服务器仍在运行，现在使用上述的指令停止它们。
      </para>
<!-- pgdoc-cn_end sig_en=aec9ba3c6dd669e3b043cd612a2ba07b -->
     </step>

     <step>
<!-- pgdoc-cn_start sig_en=900332246c58d0a39fe339e649e1887b sig_cn_org=None source=14.1 
      <title>Save configuration files</title>
________________________________________________________-->
      <title>保存配置文件</title>
<!-- pgdoc-cn_end sig_en=900332246c58d0a39fe339e649e1887b -->

<!-- pgdoc-cn_start sig_en=6972e49698bddc51aef6ccf2312dd94c sig_cn_org=None source=14.1 
      <para>
       Save any configuration files from the old standbys' configuration
       directories you need to keep, e.g.,  <filename>postgresql.conf</filename>
       (and any files included by it), <filename>postgresql.auto.conf</filename>,
       <literal>pg_hba.conf</literal>, because these will be overwritten
       or removed in the next step.
      </para>
________________________________________________________-->
      <para>
       从旧后备机的配置目录保存任何需要保留的配置文件，例如
       <filename>postgresql.conf</filename>（以及它包含的任何文件）、
       <filename>postgresql.auto.conf</filename>、<literal>pg_hba.conf</literal>，
       因为这些文件在下一步中会被重写或者移除。
      </para>
<!-- pgdoc-cn_end sig_en=6972e49698bddc51aef6ccf2312dd94c -->
     </step>

     <step>
<!-- pgdoc-cn_start sig_en=74adca3fe924e897fe5c7c6d7b7bf0f3 sig_cn_org=None source=14.1 
      <title>Run <application>rsync</application></title>
________________________________________________________-->
      <title>运行<application>rsync</application></title>
<!-- pgdoc-cn_end sig_en=74adca3fe924e897fe5c7c6d7b7bf0f3 -->

<!-- pgdoc-cn_start sig_en=8330d25bdcbb2af09f04448b95edab9e sig_cn_org=None source=14.1 
      <para>
       When using link mode, standby servers can be quickly upgraded using
       <application>rsync</application>.  To accomplish this, from a directory on
       the primary server that is above the old and new database cluster
       directories, run this on the <emphasis>primary</emphasis> for each standby
       server:

<programlisting>
rsync -&minus;archive -&minus;delete -&minus;hard-links -&minus;size-only -&minus;no-inc-recursive old_cluster new_cluster remote_dir
</programlisting>

       where <option>old_cluster</option> and <option>new_cluster</option> are relative
       to the current directory on the primary, and <option>remote_dir</option>
       is <emphasis>above</emphasis> the old and new cluster directories
       on the standby.  The directory structure under the specified
       directories on the primary and standbys must match.  Consult the
       <application>rsync</application> manual page for details on specifying the
       remote directory, e.g.,

<programlisting>
rsync -&minus;archive -&minus;delete -&minus;hard-links -&minus;size-only -&minus;no-inc-recursive /opt/PostgreSQL/9.5 \
      /opt/PostgreSQL/9.6 standby.example.com:/opt/PostgreSQL
</programlisting>

       You can verify what the command will do using
       <application>rsync</application>'s <option>-&minus;dry-run</option> option.  While
       <application>rsync</application> must be run on the primary for at least one
       standby, it is possible to run <application>rsync</application> on an upgraded
       standby to upgrade other standbys, as long as the upgraded standby
       has not been started.
      </para>
________________________________________________________-->
      <para>
       在使用链接模式时，后备服务器可以使用<application>rsync</application>快速升级。为了实现这一点，在<emphasis>主</emphasis>服务器上一个高于新旧数据库集簇目录的目录中为每个后备服务器运行这个命令：

<programlisting>
rsync --archive --delete --hard-links --size-only --no-inc-recursive old_cluster new_cluster remote_dir
</programlisting>

       其中<option>old_cluster</option>和<option>new_cluster</option>是相对于主服务器上的当前目录的，而<option>remote_dir</option>是后备服务器上<emphasis>高于</emphasis>新旧集簇目录的一个目录。在主服务器和后备服务器上指定目录之下的目录结构必须匹配。指定远程目录的详细情况请参考<application>rsync</application>的手册，例如：

<programlisting>
rsync --archive --delete --hard-links --size-only --no-inc-recursive /opt/PostgreSQL/9.5 \
      /opt/PostgreSQL/9.6 standby.example.com:/opt/PostgreSQL
</programlisting>

       可以使用<application>rsync</application>的<option>--dry-run</option>选项验证该命令将做的事情。虽然在主服务器上必须为至少一台后备运行<application>rsync</application>，可以在一台已经升级过的后备服务器上运行<application>rsync</application>来升级其他的后备服务器，只要已升级的后备服务器还没有被启动。
      </para>
<!-- pgdoc-cn_end sig_en=8330d25bdcbb2af09f04448b95edab9e -->

<!-- pgdoc-cn_start sig_en=6205d56f4f4f74cb0c3e8642b453652a sig_cn_org=None source=14.1 
      <para>
       What this does is to record the links created by
       <application>pg_upgrade</application>'s link mode that connect files in the
       old and new clusters on the primary server.  It then finds matching
       files in the standby's old cluster and creates links for them in the
       standby's new cluster.  Files that were not linked on the primary
       are copied from the primary to the standby.  (They are usually
       small.)  This provides rapid standby upgrades.  Unfortunately,
       <application>rsync</application> needlessly copies files associated with
       temporary and unlogged tables because these files don't normally
       exist on standby servers.
      </para>
________________________________________________________-->
      <para>
       这个命令所做的事情是记录由<application>pg_upgrade</application>的链接模式创建的链接，它们连接主服务器上新旧集簇中的文件。该命令接下来在后备服务器的旧集簇中寻找匹配的文件并且为它们在该后备的新集簇中创建链接。主服务器上没有被链接的文件会被从主服务器拷贝到后备服务器（通常都很小）。这提供了快速的后备服务器升级。不幸地是，<application>rsync</application>会不必要地拷贝与临时表和不做日志表相关的文件，因为通常在后备服务器上不存在这些文件。
      </para>
<!-- pgdoc-cn_end sig_en=6205d56f4f4f74cb0c3e8642b453652a -->

<!-- pgdoc-cn_start sig_en=8c4db772258fd2d827474abef3d52a63 sig_cn_org=None source=14.1 
      <para>
       If you have tablespaces, you will need to run a similar
       <application>rsync</application> command for each tablespace directory, e.g.:

<programlisting>
rsync -&minus;archive -&minus;delete -&minus;hard-links -&minus;size-only -&minus;no-inc-recursive /vol1/pg_tblsp/PG_9.5_201510051 \
      /vol1/pg_tblsp/PG_9.6_201608131 standby.example.com:/vol1/pg_tblsp
</programlisting>

       If you have relocated <filename>pg_wal</filename> outside the data
       directories, <application>rsync</application> must be run on those directories
       too.
      </para>
________________________________________________________-->
      <para>
       如果有表空间，你将需要为每个表空间目录运行一个类似的<application>rsync</application>命令，例如：

<programlisting>
rsync --archive --delete --hard-links --size-only --no-inc-recursive /vol1/pg_tblsp/PG_9.5_201510051 \
      /vol1/pg_tblsp/PG_9.6_201608131 standby.example.com:/vol1/pg_tblsp
</programlisting>

       如果你已经把<filename>pg_wal</filename>放在数据目录外面，也必须在那些目录上运行<application>rsync</application>。
      </para>
<!-- pgdoc-cn_end sig_en=8c4db772258fd2d827474abef3d52a63 -->
     </step>

     <step>
<!-- pgdoc-cn_start sig_en=b0ddc9053dd397a6ca14df5078f0b6f8 sig_cn_org=None source=14.1 
      <title>Configure streaming replication and log-shipping standby servers</title>
________________________________________________________-->
      <title>配置流复制和日志传送后备服务器</title>
<!-- pgdoc-cn_end sig_en=b0ddc9053dd397a6ca14df5078f0b6f8 -->

<!-- pgdoc-cn_start sig_en=e8eb599c839d96af7b131b5356f5b8ec sig_cn_org=bf790e3147482a53b38923795a82fb38 source=15.7 
      <para>
       Configure the servers for log shipping.  (You do not need to run
       <function>pg_backup_start()</function> and <function>pg_backup_stop()</function>
       or take a file system backup as the standbys are still synchronized
       with the primary.)  Replication slots are not copied and must
       be recreated.
      </para>
________________________________________________________-->
      <para>
       配置服务器进行日志传送。(您无需运行<function>pg_backup_start()</function>和<function>pg_backup_stop()</function>
       或进行文件系统备份，因为备用服务器仍与主服务器同步。) 复制槽不会被复制，必须重新创建。
      </para>
<!-- pgdoc-cn_end sig_en=e8eb599c839d96af7b131b5356f5b8ec -->
     </step>

    </procedure>

   </step>

   <step>
<!-- pgdoc-cn_start sig_en=33cba446396b2d13bbc5f565673bd508 sig_cn_org=None source=14.1 
    <title>Restore <filename>pg_hba.conf</filename></title>
________________________________________________________-->
    <title>恢复 <filename>pg_hba.conf</filename></title>
<!-- pgdoc-cn_end sig_en=33cba446396b2d13bbc5f565673bd508 -->

<!-- pgdoc-cn_start sig_en=449a1b52f042f108fadd14e2df776bdf sig_cn_org=None source=14.1 
    <para>
     If you modified <filename>pg_hba.conf</filename>, restore its original settings.
     It might also be necessary to adjust other configuration files in the new
     cluster to match the old cluster, e.g., <filename>postgresql.conf</filename>
     (and any files included by it), <filename>postgresql.auto.conf</filename>.
    </para>
________________________________________________________-->
    <para>
     如果你修改了<filename>pg_hba.conf</filename>，则要将其恢复到原始的设置。
     也可能需要调整新集簇中的其他配置文件来匹配旧集簇，例如
     <filename>postgresql.conf</filename>（以及它包含的任何文件）和
     <filename>postgresql.auto.conf</filename>。
    </para>
<!-- pgdoc-cn_end sig_en=449a1b52f042f108fadd14e2df776bdf -->
   </step>

   <step>
<!-- pgdoc-cn_start sig_en=266555aed843154e6ed4408c16f5c991 sig_cn_org=None source=14.1 
    <title>Start the new server</title>
________________________________________________________-->
    <title>启动新服务器</title>
<!-- pgdoc-cn_end sig_en=266555aed843154e6ed4408c16f5c991 -->

<!-- pgdoc-cn_start sig_en=2250c1f3e67195c7d1f7509afb89960c sig_cn_org=None source=14.1 
    <para>
     The new server can now be safely started, and then any
     <application>rsync</application>'ed standby servers.
    </para>
________________________________________________________-->
    <para>
     现在可以安全地启动新的服务器，并且可以接着启动任何
     <application>rsync</application>过的后备服务器。
    </para>
<!-- pgdoc-cn_end sig_en=2250c1f3e67195c7d1f7509afb89960c -->
   </step>

   <step>
<!-- pgdoc-cn_start sig_en=b7595f0699ad24c5c8aa7d01b2c26645 sig_cn_org=None source=14.1 
    <title>Post-upgrade processing</title>
________________________________________________________-->
    <title>升级后处理</title>
<!-- pgdoc-cn_end sig_en=b7595f0699ad24c5c8aa7d01b2c26645 -->

<!-- pgdoc-cn_start sig_en=2529c15bbd7fe4190b39fc8bd44d3f7c sig_cn_org=None source=14.1 
    <para>
     If any post-upgrade processing is required, pg_upgrade will issue
     warnings as it completes. It will also generate script files that must
     be run by the administrator. The script files will connect to each
     database that needs post-upgrade processing. Each script should be
     run using:

<programlisting>
psql -&minus;username=postgres -&minus;file=script.sql postgres
</programlisting>

     The scripts can be run in any order and can be deleted once they have
     been run.
    </para>
________________________________________________________-->
    <para>
     如果需要做任何升级后处理，pg_upgrade 将在完成后发出警告。它也将
     生成必须由管理员运行的脚本文件。这些脚本文件将连接到每一个需要做
     升级后处理的数据库。每一个脚本应该这样运行：

<programlisting>
psql --username=postgres --file=script.sql postgres
</programlisting>

     这些脚本可以以任何顺序运行并且在运行之后立即删除。
    </para>
<!-- pgdoc-cn_end sig_en=2529c15bbd7fe4190b39fc8bd44d3f7c -->

    <caution>
<!-- pgdoc-cn_start sig_en=7a3319f0500753526cc14bd5b52f1229 sig_cn_org=None source=14.1 
    <para>
     In general it is unsafe to access tables referenced in rebuild scripts
     until the rebuild scripts have run to completion; doing so could yield
     incorrect results or poor performance. Tables not referenced in rebuild
     scripts can be accessed immediately.
    </para>
________________________________________________________-->
    <para>
     通常在重建脚本运行完成之前访问重建脚本中引用的表是不安全的，这样做
     可能会得到不正确的结果或者很差的性能。没有在重建脚本中引用的表可以
     随时被访问。
    </para>
<!-- pgdoc-cn_end sig_en=7a3319f0500753526cc14bd5b52f1229 -->
    </caution>
   </step>

   <step>
<!-- pgdoc-cn_start sig_en=f1a3f390a3e63ccb3fe565b359aa7a01 sig_cn_org=None source=14.1 
    <title>Statistics</title>
________________________________________________________-->
    <title>统计信息</title>
<!-- pgdoc-cn_end sig_en=f1a3f390a3e63ccb3fe565b359aa7a01 -->

<!-- pgdoc-cn_start sig_en=c0e0864a458de7001f6de7c2a36a9f07 sig_cn_org=None source=14.1 
    <para>
     Because optimizer statistics are not transferred by <command>pg_upgrade</command>, you will
     be instructed to run a command to regenerate that information at the end
     of the upgrade.  You might need to set connection parameters to
     match your new cluster.
    </para>
________________________________________________________-->
    <para>
     由于<command>pg_upgrade</command>并未传输优化器统计信息，在升级的尾声
     你将被指示运行一个命令来生成这些信息。你可能需要设置连接参数来匹配你
     的新集簇。
    </para>
<!-- pgdoc-cn_end sig_en=c0e0864a458de7001f6de7c2a36a9f07 -->
   </step>

   <step>
<!-- pgdoc-cn_start sig_en=26978be058ad9e8d0df1e1f64029a4db sig_cn_org=None source=14.1 
    <title>Delete old cluster</title>
________________________________________________________-->
    <title>删除旧集簇</title>
<!-- pgdoc-cn_end sig_en=26978be058ad9e8d0df1e1f64029a4db -->

<!-- pgdoc-cn_start sig_en=dfdd04f384d24e7359ad09c5111f1535 sig_cn_org=None source=14.1 
    <para>
     Once you are satisfied with the upgrade, you can delete the old
     cluster's data directories by running the script mentioned when
     <command>pg_upgrade</command> completes. (Automatic deletion is not
     possible if you have user-defined tablespaces inside the old data
     directory.)  You can also delete the old installation directories
     (e.g., <filename>bin</filename>, <filename>share</filename>).
    </para>
________________________________________________________-->
    <para>
     一旦你对升级表示满意，你就可以通过运行
     <command>pg_upgrade</command>完成时提到的脚本来删除旧集簇的
     数据目录（如果在旧数据目录中有用户定义的表空间就不可能实现自动删除）。
     你也可以删除旧安装目录（例如<filename>bin</filename>、<filename>share</filename>）。
    </para>
<!-- pgdoc-cn_end sig_en=dfdd04f384d24e7359ad09c5111f1535 -->
   </step>

   <step id="pgupgrade-step-revert" performance="optional">
<!-- pgdoc-cn_start sig_en=452858b1b59552dc5f93d366941d6467 sig_cn_org=None source=14.1 
    <title>Reverting to old cluster</title>
________________________________________________________-->
    <title>恢复到旧集簇</title>
<!-- pgdoc-cn_end sig_en=452858b1b59552dc5f93d366941d6467 -->

<!-- pgdoc-cn_start sig_en=b03c402c8f1fa9079d0d53439ac75802 sig_cn_org=None source=14.1 
    <para>
     If, after running <command>pg_upgrade</command>, you wish to revert to the old cluster,
     there are several options:

     <itemizedlist>
      <listitem>
       <para>
        If the <option>-&minus;check</option> option was used, the old cluster
        was unmodified;  it can be restarted.
       </para>
      </listitem>

      <listitem>
       <para>
        If the <option>-&minus;link</option> option was <emphasis>not</emphasis>
        used, the old cluster was unmodified;  it can be restarted.
       </para>
      </listitem>

      <listitem>
       <para>
        If the <option>-&minus;link</option> option was used, the data
        files might be shared between the old and new cluster:

        <itemizedlist>
         <listitem>
          <para>
           If <command>pg_upgrade</command> aborted before linking started,
           the old cluster was unmodified;  it can be restarted.
          </para>
         </listitem>

         <listitem>
          <para>
           If you did <emphasis>not</emphasis> start the new cluster, the old
           cluster was unmodified except that, when linking started, a
           <literal>.old</literal> suffix was appended to
           <filename>$PGDATA/global/pg_control</filename>.  To reuse the old
           cluster, remove the <filename>.old</filename> suffix from
           <filename>$PGDATA/global/pg_control</filename>; you can then restart
           the old cluster.
          </para>
         </listitem>

         <listitem>
          <para>
           If you did start the new cluster, it has written to shared files
           and it is unsafe to use the old cluster.  The old cluster will
           need to be restored from backup in this case.
          </para>
         </listitem>

        </itemizedlist></para>
      </listitem>
     </itemizedlist></para>
________________________________________________________-->
    <para>
     在运行<command>pg_upgrade</command>之后，如果你希望恢复到
     旧集簇，有几个选项：

     <itemizedlist>
      <listitem>
       <para>
        如果使用了 <option>--check</option> 选项, 则旧集群没有被修改；它可以被重新启动。
       </para>
      </listitem>

      <listitem>
       <para>
        如果 <option>--link</option> 选项 <emphasis>没有</emphasis>被使用, 旧集群没有被修改；它可以被重新启动。
       </para>
      </listitem>

      <listitem>
       <para>
        如果使用了<option>--link</option> 选项, 数据文件可能在新旧群集之间共享:

        <itemizedlist>
         <listitem>
          <para>
           如果<command>pg_upgrade</command>在链接启动之前中止，旧群集没有被修改，它可以重新启动。
          </para>
         </listitem>

         <listitem>
          <para>
           如果你<emphasis>没有</emphasis>启动新集群，旧集群没有被修改，当链接启动时，一个<literal>.old</literal>后缀会附加到<filename>$PGDATA/global/pg_control</filename>。
           如果要重用旧集群，从<filename>$PGDATA/global/pg_control</filename>移除<filename>.old</filename>后缀；你就可以重启旧集群。
          </para>
         </listitem>

         <listitem>
          <para>
           如果你已经启动新群集，它已经写入了共享文件，并且使用旧群集会不安全。这种情况下，需要从备份中还原旧群集。
          </para>
         </listitem>

        </itemizedlist>
       </para>
      </listitem>
     </itemizedlist>
    </para>
<!-- pgdoc-cn_end sig_en=b03c402c8f1fa9079d0d53439ac75802 -->
   </step>
  </procedure>

 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
  <title>Notes</title>
________________________________________________________-->
  <title>注解</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->

<!-- pgdoc-cn_start sig_en=79690d7f795b442ed127d6b67f26cf07 sig_cn_org=1042d8f5ab95e256a96037217159f774 source=15.7 
  <para>
   <application>pg_upgrade</application> creates various working files, such
   as schema dumps, stored within <filename>pg_upgrade_output.d</filename> in
   the directory of the new cluster. Each run creates a new subdirectory named
   with a timestamp formatted as per ISO 8601
   (<literal>%Y%m%dT%H%M%S</literal>), where all its generated files are
   stored.
   <filename>pg_upgrade_output.d</filename> and its contained files will be
   removed automatically if <application>pg_upgrade</application> completes
   successfully; but in the event of trouble, the files there may provide
   useful debugging information.
  </para>
________________________________________________________-->
  <para>
   <application>pg_upgrade</application>创建各种工作文件，例如模式转储，存储在新集群目录中的<filename>pg_upgrade_output.d</filename>中。
   每次运行都会创建一个新的子目录，以ISO 8601格式化的时间戳命名（<literal>%Y%m%dT%H%M%S</literal>），其中存储了所有生成的文件。
   如果<application>pg_upgrade</application>成功完成，则<filename>pg_upgrade_output.d</filename>及其包含的文件将被自动删除；
   但如果出现问题，则那里的文件可能提供有用的调试信息。
</para>
<!-- pgdoc-cn_end sig_en=79690d7f795b442ed127d6b67f26cf07 -->

<!-- pgdoc-cn_start sig_en=b6284c0590c85278aeba1a918d8a1389 sig_cn_org=None source=14.1 
  <para>
   <application>pg_upgrade</application> launches short-lived postmasters in
   the old and new data directories.  Temporary Unix socket files for
   communication with these postmasters are, by default, made in the current
   working directory.  In some situations the path name for the current
   directory might be too long to be a valid socket name.  In that case you
   can use the <option>-s</option> option to put the socket files in some
   directory with a shorter path name.  For security, be sure that that
   directory is not readable or writable by any other users.
   (This is not supported on Windows.)
  </para>
________________________________________________________-->
  <para>
   <application>pg_upgrade</application>在新旧数据目录中启动短期的postmasters。临时 Unix 套接字文件用于与这些postmasters通信，默认情况下，在当前工作目录中进行。
   在某些情况下，当前目录的路径名称可能太长，无法成为有效的套接字名称。这种情况下你可以使用<option>-s</option>选项将套接字文件放在某些具有较短路径名称的目录中。
   为了安全原因，请确保该目录不可被任何其他用户读取或者写入。（这在 Windows 上不受支持。）
  </para>
<!-- pgdoc-cn_end sig_en=b6284c0590c85278aeba1a918d8a1389 -->

<!-- pgdoc-cn_start sig_en=02c98cd143dc4b7fc8138c58c66f99be sig_cn_org=None source=14.1 
  <para>
   All failure, rebuild, and reindex cases will be reported by
   <application>pg_upgrade</application> if they affect your installation;
   post-upgrade scripts to rebuild tables and indexes will be
   generated automatically.  If you are trying to automate the upgrade
   of many clusters, you should find that clusters with identical database
   schemas require the same post-upgrade steps for all cluster upgrades;
   this is because the post-upgrade steps are based on the database
   schemas, and not user data.
  </para>
________________________________________________________-->
  <para>
   如果失败、重建和重新索引会影响你的安装，<application>pg_upgrade</application>
   将会报告这些情况。用来重建表和索引的升级后脚本将会自动被建立。
   如果你正在尝试自动升级很多集簇，你应该发现具有相同数据库模式的集簇
   对所有集簇升级都要求同样的升级后步骤，这是因为升级后步骤是基于数据
   库模式而不是用户数据。
  </para>
<!-- pgdoc-cn_end sig_en=02c98cd143dc4b7fc8138c58c66f99be -->

<!-- pgdoc-cn_start sig_en=2bbd4088c9da49534cfccbcd7dbab036 sig_cn_org=None source=14.1 
  <para>
   For deployment testing, create a schema-only copy of the old cluster,
   insert dummy data, and upgrade that.
  </para>
________________________________________________________-->
  <para>
   对于部署测试，创建一个只有模式的旧集簇副本，在其中插入假数据并且升级。
  </para>
<!-- pgdoc-cn_end sig_en=2bbd4088c9da49534cfccbcd7dbab036 -->

<!-- pgdoc-cn_start sig_en=d9023be13e6a9900452e2c4484278564 sig_cn_org=None source=14.1 
  <para>
   <application>pg_upgrade</application> does not support upgrading of databases
   containing table columns using these <type>reg*</type> OID-referencing system data types:
   <simplelist>
    <member><type>regcollation</type></member>
    <member><type>regconfig</type></member>
    <member><type>regdictionary</type></member>
    <member><type>regnamespace</type></member>
    <member><type>regoper</type></member>
    <member><type>regoperator</type></member>
    <member><type>regproc</type></member>
    <member><type>regprocedure</type></member>
   </simplelist>
   (<type>regclass</type>, <type>regrole</type>, and <type>regtype</type> can be upgraded.)
  </para>
________________________________________________________-->
  <para>
   <application>pg_upgrade</application>不支持包含使用这些<type>reg*</type> OID-引用 系统数据类型的表列的数据库的升级：
   <simplelist>
    <member><type>regcollation</type></member>
    <member><type>regconfig</type></member>
    <member><type>regdictionary</type></member>
    <member><type>regnamespace</type></member>
    <member><type>regoper</type></member>
    <member><type>regoperator</type></member>
    <member><type>regproc</type></member>
    <member><type>regprocedure</type></member>
   </simplelist>
   (<type>regclass</type>, <type>regrole</type>, and <type>regtype</type> can be upgraded.)
  </para>
<!-- pgdoc-cn_end sig_en=d9023be13e6a9900452e2c4484278564 -->

<!-- pgdoc-cn_start sig_en=3e22bd81221de69dd2cdba0e6c029da6 sig_cn_org=None source=14.1 
  <para>
   If you want to use link mode and you do not want your old cluster
   to be modified when the new cluster is started, consider using the clone mode.
   If that is not available, make a copy of the
   old cluster and upgrade that in link mode. To make a valid copy
   of the old cluster, use <command>rsync</command> to create a dirty
   copy of the old cluster while the server is running, then shut down
   the old server and run <command>rsync -&minus;checksum</command> again to update the
   copy with any changes to make it consistent.  (<option>-&minus;checksum</option>
   is necessary because <command>rsync</command> only has file modification-time
   granularity of one second.)  You might want to exclude some
   files, e.g., <filename>postmaster.pid</filename>, as documented in <xref
   linkend="backup-lowlevel-base-backup"/>.  If your file system supports
   file system snapshots or copy-on-write file copies, you can use that
   to make a backup of the old cluster and tablespaces, though the snapshot
   and copies must be created simultaneously or while the database server
   is down.
  </para>
________________________________________________________-->
  <para>
   如果你想要使用链接模式并且你不想让你的旧集簇在新集簇启动时被修改，考虑使用克隆模式。
   如果(克隆模式)不可用，可以复制一份旧集簇并且在副本上以链接模式进行升级。要创建旧集簇的一
   份合法拷贝，可以在服务器运行时使用<command>rsync</command>创建旧集簇的
   一份脏拷贝，然后关闭旧服务器并且再次运行<command>rsync --checksum</command>
   把更改更新到该拷贝以让其一致（<option>--checksum</option>是必要的，因为
   <command>rsync</command>在判断文件修改时间的更改时的精度只能到秒级）。如
   <xref linkend="backup-lowlevel-base-backup"/>中所述，你可能想要排除
   一些文件，例如<filename>postmaster.pid</filename>。如果你的文件系统支持文
   件系统快照或者 copy-on-write 文件副本，你可以使用它们来创建旧集簇和
   表空间的一个备份，不过快照和副本必须被同时创建或者在数据库服务器关闭
   期间被创建。
  </para>
<!-- pgdoc-cn_end sig_en=3e22bd81221de69dd2cdba0e6c029da6 -->

 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=8b7cc214676b443e6527e3d6bf054420 sig_cn_org=None source=14.1 
  <title>See Also</title>
________________________________________________________-->
  <title>另见</title>
<!-- pgdoc-cn_end sig_en=8b7cc214676b443e6527e3d6bf054420 -->

  <simplelist type="inline">
   <member><xref linkend="app-initdb"/></member>
   <member><xref linkend="app-pg-ctl"/></member>
   <member><xref linkend="app-pgdump"/></member>
   <member><xref linkend="app-postgres"/></member>
  </simplelist>
 </refsect1>
</refentry>
