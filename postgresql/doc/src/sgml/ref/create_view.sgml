<!--
doc/src/sgml/ref/create_view.sgml
PostgreSQL documentation
-->

<refentry id="sql-createview">
<!-- pgdoc-cn_start sig_en=bda65bb18d498d7987f7a8accc465c05 sig_cn_org=None source=14.1 
 <indexterm zone="sql-createview">
  <primary>CREATE VIEW</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="sql-createview">
  <primary>CREATE VIEW</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=bda65bb18d498d7987f7a8accc465c05 -->

 <refmeta>
  <refentrytitle>CREATE VIEW</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

<!-- pgdoc-cn_start sig_en=cb32eba7bdc86bdc201e2f907c0efa32 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>CREATE VIEW</refname>
  <refpurpose>define a new view</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>CREATE VIEW</refname>
  <refpurpose>定义一个新视图</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=cb32eba7bdc86bdc201e2f907c0efa32 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=08d6a4e58adc976b89196a304784ad1f sig_cn_org=None source=14.1 
<synopsis>
CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] [ RECURSIVE ] VIEW <replaceable class="parameter">name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    [ WITH ( <replaceable class="parameter">view_option_name</replaceable> [= <replaceable class="parameter">view_option_value</replaceable>] [, ... ] ) ]
    AS <replaceable class="parameter">query</replaceable>
    [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]
</synopsis>
________________________________________________________-->
<synopsis>
CREATE [ OR REPLACE ] [ TEMP | TEMPORARY ] [ RECURSIVE ] VIEW <replaceable class="parameter">name</replaceable> [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    [ WITH ( <replaceable class="parameter">view_option_name</replaceable> [= <replaceable class="parameter">view_option_value</replaceable>] [, ... ] ) ]
    AS <replaceable class="parameter">query</replaceable>
    [ WITH [ CASCADED | LOCAL ] CHECK OPTION ]
</synopsis>
<!-- pgdoc-cn_end sig_en=08d6a4e58adc976b89196a304784ad1f -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=acda9a0d87d33153d8aa23d6fb9e4512 sig_cn_org=None source=14.1 
  <para>
   <command>CREATE VIEW</command> defines a view of a query.  The view
   is not physically materialized. Instead, the query is run every time
   the view is referenced in a query.
  </para>
________________________________________________________-->
  <para>
   <command>CREATE VIEW</command>定义一个查询的视图。该视图不会被
   物理上物质化。相反，在每一次有查询引用该视图时，视图的查询都会被运行。
  </para>
<!-- pgdoc-cn_end sig_en=acda9a0d87d33153d8aa23d6fb9e4512 -->

<!-- pgdoc-cn_start sig_en=afb7a68f7e1ea4f171ab15b1b7a1eaf2 sig_cn_org=None source=14.1 
  <para>
   <command>CREATE OR REPLACE VIEW</command> is similar, but if a view
   of the same name already exists, it is replaced.  The new query must
   generate the same columns that were generated by the existing view query
   (that is, the same column names in the same order and with the same data
   types), but it may add additional columns to the end of the list.  The
   calculations giving rise to the output columns may be completely different.
  </para>
________________________________________________________-->
  <para>
   <command>CREATE OR REPLACE VIEW</command>与之相似，但是如果
   已经存在一个同名视图，该视图会被替换。新查询必须产生和现有试图查询相同
   的列（也就是相同的列序、相同的列名、相同的数据类型），但是它可以在列表
   的末尾加上额外的列。产生输出列的计算可以完全不同。
  </para>
<!-- pgdoc-cn_end sig_en=afb7a68f7e1ea4f171ab15b1b7a1eaf2 -->

<!-- pgdoc-cn_start sig_en=130741862b438e003e14b4bf6511898c sig_cn_org=3a01c22391bdf3c5efdd04225c77ae2f source=15.7 
  <para>
   If a schema name is given (for example, <literal>CREATE VIEW
   myschema.myview ...</literal>) then the view is created in the specified
   schema.  Otherwise it is created in the current schema.  Temporary
   views exist in a special schema, so a schema name cannot be given
   when creating a temporary view. The name of the view must be
   distinct from the name of any other relation (table, sequence, index, view,
   materialized view, or foreign table) in the same schema.
  </para>
________________________________________________________-->
  <para>
   如果给出了模式名称（例如，<literal>CREATE VIEW
   myschema.myview ...</literal>），则视图将在指定的模式中创建。
   否则，它将在当前模式中创建。 临时视图存在于一个特殊的模式中，因此在创建临时视图时不能给出模式名称。
   视图的名称必须与同一模式中的任何其他关系（表、序列、索引、视图、
   材料化视图或外部表）的名称不同。
</para>
<!-- pgdoc-cn_end sig_en=130741862b438e003e14b4bf6511898c -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
  <title>Parameters</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

  <variablelist>
   <varlistentry>
<!-- pgdoc-cn_start sig_en=38f5f15c2286c0019a288ab70bbfb93e sig_cn_org=None source=14.1 
    <term><literal>TEMPORARY</literal> or <literal>TEMP</literal></term>
________________________________________________________-->
    <term><literal>TEMPORARY</literal>或者<literal>TEMP</literal></term>
<!-- pgdoc-cn_end sig_en=38f5f15c2286c0019a288ab70bbfb93e -->
    <listitem>
<!-- pgdoc-cn_start sig_en=234fada04a485272a67524df1419d93d sig_cn_org=None source=14.1 
     <para>
      If specified, the view is created as a temporary view.
      Temporary views are automatically dropped at the end of the
      current session.  Existing
      permanent relations with the same name are not visible to the
      current session while the temporary view exists, unless they are
      referenced with schema-qualified names.
     </para>
________________________________________________________-->
     <para>
      如果被指定，视图被创建为一个临时视图。在当前会话结束时会自动
      删掉临时视图。当临时视图存在时，具有相同名称的已有永久视图对
      当前会话不可见，除非用模式限定的名称引用它们。
     </para>
<!-- pgdoc-cn_end sig_en=234fada04a485272a67524df1419d93d -->

<!-- pgdoc-cn_start sig_en=51fda6ed6cabb446b015273aeafbfc05 sig_cn_org=None source=14.1 
     <para>
      If any of the tables referenced by the view are temporary,
      the view is created as a temporary view (whether
      <literal>TEMPORARY</literal> is specified or not).
     </para>
________________________________________________________-->
     <para>
      如果视图引用的任何表是临时的，视图将被创建为临时视图（不管有
      没有指定<literal>TEMPORARY</literal>）。
     </para>
<!-- pgdoc-cn_end sig_en=51fda6ed6cabb446b015273aeafbfc05 -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=2d863ab36df17e3e3bd909ce39205b87 sig_cn_org=None source=14.1 
    <term><literal>RECURSIVE</literal>
      <indexterm zone="sql-createview">
       <primary>RECURSIVE</primary>
       <secondary>in views</secondary>
      </indexterm>
    </term>
________________________________________________________-->
    <term><literal>RECURSIVE</literal>
      <indexterm zone="sql-createview">
       <primary>RECURSIVE</primary>
       <secondary>in views</secondary>
      </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=2d863ab36df17e3e3bd909ce39205b87 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=e488babc0393a83706e0619cef1e0620 sig_cn_org=None source=14.1 
     <para>
      Creates a recursive view.  The syntax
<synopsis>
CREATE RECURSIVE VIEW [ <replaceable>schema</replaceable> . ] <replaceable>view_name</replaceable> (<replaceable>column_names</replaceable>) AS SELECT <replaceable>...</replaceable>;
</synopsis>
      is equivalent to
<synopsis>
CREATE VIEW [ <replaceable>schema</replaceable> . ] <replaceable>view_name</replaceable> AS WITH RECURSIVE <replaceable>view_name</replaceable> (<replaceable>column_names</replaceable>) AS (SELECT <replaceable>...</replaceable>) SELECT <replaceable>column_names</replaceable> FROM <replaceable>view_name</replaceable>;
</synopsis>
      A view column name list must be specified for a recursive view.
     </para>
________________________________________________________-->
     <para>
      创建一个递归视图。语法
<synopsis>
CREATE RECURSIVE VIEW [ <replaceable>schema</replaceable> . ] <replaceable>view_name</replaceable> (<replaceable>column_names</replaceable>) AS SELECT <replaceable>...</replaceable>;
</synopsis>
      等效于
<synopsis>
CREATE VIEW [ <replaceable>schema</replaceable> . ] <replaceable>view_name</replaceable> AS WITH RECURSIVE <replaceable>view_name</replaceable> (<replaceable>column_names</replaceable>) AS (SELECT <replaceable>...</replaceable>) SELECT <replaceable>column_names</replaceable> FROM <replaceable>view_name</replaceable>;
</synopsis>
      对于一个递归视图必须指定一个视图列名列表。
     </para>
<!-- pgdoc-cn_end sig_en=e488babc0393a83706e0619cef1e0620 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">name</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=4bfd98c4f1f18186eef6226b9e6e3533 sig_cn_org=None source=14.1 
     <para>
      The name (optionally schema-qualified) of a view to be created.
     </para>
________________________________________________________-->
     <para>
      要创建的视图的名字（可以是模式限定的）。
     </para>
<!-- pgdoc-cn_end sig_en=4bfd98c4f1f18186eef6226b9e6e3533 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">column_name</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=fe42d6ef4b192f1e0ec3d2f1e9fb6fa0 sig_cn_org=None source=14.1 
     <para>
      An optional list of names to be used for columns of the view.
      If not given, the column names are deduced from the query.
     </para>
________________________________________________________-->
     <para>
      要用于视图列的名称列表，可选。如果没有给出，列名会根据查询
      推导。
     </para>
<!-- pgdoc-cn_end sig_en=fe42d6ef4b192f1e0ec3d2f1e9fb6fa0 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH ( <replaceable class="parameter">view_option_name</replaceable> [= <replaceable class="parameter">view_option_value</replaceable>] [, ... ] )</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=08e1086455914f802c2bc43d319b6e58 sig_cn_org=fd512a077fb9f50b7fafd073c3d9b45f source=15.7 
     <para>
      This clause specifies optional parameters for a view; the following
      parameters are supported:

      <variablelist>
       <varlistentry>
        <term><literal>check_option</literal> (<type>enum</type>)</term>
        <listitem>
         <para>
          This parameter may be either <literal>local</literal> or
          <literal>cascaded</literal>, and is equivalent to specifying
          <literal>WITH [ CASCADED | LOCAL ] CHECK OPTION</literal> (see below).
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>security_barrier</literal> (<type>boolean</type>)</term>
        <listitem>
         <para>
          This should be used if the view is intended to provide row-level
          security.  See <xref linkend="rules-privileges"/> for full details.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>security_invoker</literal> (<type>boolean</type>)</term>
        <listitem>
         <para>
          This option causes the underlying base relations to be checked
          against the privileges of the user of the view rather than the view
          owner.  See the notes below for full details.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

      All of the above options can be changed on existing views using <link
      linkend="sql-alterview"><command>ALTER VIEW</command></link>.
     </para>
________________________________________________________-->
     <para>
      本节指定了视图的可选参数；支持以下参数：

      <variablelist>
       <varlistentry>
        <term><literal>check_option</literal> (<type>enum</type>)</term>
        <listitem>
         <para>
          此参数可以是<literal>local</literal>或<literal>cascaded</literal>，等同于指定
          <literal>WITH [ CASCADED | LOCAL ] CHECK OPTION</literal>（见下文）。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>security_barrier</literal> (<type>boolean</type>)</term>
        <listitem>
         <para>
          如果视图旨在提供逐行安全性，则应使用此选项。详细信息请参见<xref linkend="rules-privileges"/>。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>security_invoker</literal> (<type>boolean</type>)</term>
        <listitem>
         <para>
          此选项导致基础基本关系根据视图用户的权限而不是视图所有者的权限进行检查。详细信息请参见下文的注释。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>

      所有上述选项都可以使用<link linkend="sql-alterview"><command>ALTER VIEW</command></link>更改现有视图。
     </para>
<!-- pgdoc-cn_end sig_en=08e1086455914f802c2bc43d319b6e58 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">query</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=bb7d7e400188e54e944cc6ede1273bb6 sig_cn_org=None source=14.1 
     <para>
      A <link linkend="sql-select"><command>SELECT</command></link> or
      <link linkend="sql-values"><command>VALUES</command></link> command
      which will provide the columns and rows of the view.
     </para>
________________________________________________________-->
     <para>
      提供视图的行和列的一个<link linkend="sql-select"><command>SELECT</command></link> 或者 <link linkend="sql-values"><command>VALUES</command></link>命令。
     </para>
<!-- pgdoc-cn_end sig_en=bb7d7e400188e54e944cc6ede1273bb6 -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=5b47aa6458ac07f38681d69fb4978911 sig_cn_org=None source=14.1 
    <term><literal>WITH [ CASCADED | LOCAL ] CHECK OPTION</literal>
      <indexterm zone="sql-createview">
       <primary>CHECK OPTION</primary>
      </indexterm>
      <indexterm zone="sql-createview">
       <primary>WITH CHECK OPTION</primary>
      </indexterm>
    </term>
________________________________________________________-->
    <term><literal>WITH [ CASCADED | LOCAL ] CHECK OPTION</literal>
      <indexterm zone="sql-createview">
       <primary>CHECK OPTION</primary>
      </indexterm>
      <indexterm zone="sql-createview">
       <primary>WITH CHECK OPTION</primary>
      </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=5b47aa6458ac07f38681d69fb4978911 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=358cbb316b41fd3c9acaa0091bdd516a sig_cn_org=None source=14.1 
     <para>
      This option controls the behavior of automatically updatable views.  When
      this option is specified, <command>INSERT</command> and <command>UPDATE</command>
      commands on the view will be checked to ensure that new rows satisfy the
      view-defining condition (that is, the new rows are checked to ensure that
      they are visible through the view).  If they are not, the update will be
      rejected.  If the <literal>CHECK OPTION</literal> is not specified,
      <command>INSERT</command> and <command>UPDATE</command> commands on the view are
      allowed to create rows that are not visible through the view.  The
      following check options are supported:

      <variablelist>
       <varlistentry>
        <term><literal>LOCAL</literal></term>
        <listitem>
         <para>
          New rows are only checked against the conditions defined directly in
          the view itself.  Any conditions defined on underlying base views are
          not checked (unless they also specify the <literal>CHECK OPTION</literal>).
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>CASCADED</literal></term>
        <listitem>
         <para>
          New rows are checked against the conditions of the view and all
          underlying base views.  If the <literal>CHECK OPTION</literal> is specified,
          and neither <literal>LOCAL</literal> nor <literal>CASCADED</literal> is specified,
          then <literal>CASCADED</literal> is assumed.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
________________________________________________________-->
     <para>
      这个选项控制自动可更新视图的行为。这个选项被指定时，将检查该视图上的
      <command>INSERT</command>和<command>UPDATE</command>命令以确保新行满足
      视图的定义条件（也就是，将检查新行来确保通过视图能看到它们）。如果新行
      不满足条件，更新将被拒绝。如果没有指定<literal>CHECK OPTION</literal>，
      会允许该视图上的<command>INSERT</command>和<command>UPDATE</command>命令
      创建通过该视图不可见的行。支持下列检查选项：

      <variablelist>
       <varlistentry>
        <term><literal>LOCAL</literal></term>
        <listitem>
         <para>
          只根据直接定义在该视图本身的条件检查新行。任何定义在底层基视图上的
          条件都不会被检查（除非它们也指定了<literal>CHECK OPTION</literal>）。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>CASCADED</literal></term>
        <listitem>
         <para>
          会根据该视图和所有底层基视图上的条件检查新行。如果
          <literal>CHECK OPTION</literal>被指定，并且没有指定
          <literal>LOCAL</literal>和<literal>CASCADED</literal>，则会假定为
          <literal>CASCADED</literal>。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
<!-- pgdoc-cn_end sig_en=358cbb316b41fd3c9acaa0091bdd516a -->

<!-- pgdoc-cn_start sig_en=f90f4df8c18bf155f0024fa977721865 sig_cn_org=None source=14.1 
     <para>
      The <literal>CHECK OPTION</literal> may not be used with <literal>RECURSIVE</literal>
      views.
     </para>
________________________________________________________-->
     <para>
      <literal>CHECK OPTION</literal>不应该和<literal>RECURSIVE</literal>视图一起使用。
     </para>
<!-- pgdoc-cn_end sig_en=f90f4df8c18bf155f0024fa977721865 -->

<!-- pgdoc-cn_start sig_en=6fdc7add04620d659f2356b38b52f2e3 sig_cn_org=None source=14.1 
     <para>
      Note that the <literal>CHECK OPTION</literal> is only supported on views that
      are automatically updatable, and do not have <literal>INSTEAD OF</literal>
      triggers or <literal>INSTEAD</literal> rules.  If an automatically updatable
      view is defined on top of a base view that has <literal>INSTEAD OF</literal>
      triggers, then the <literal>LOCAL CHECK OPTION</literal> may be used to check
      the conditions on the automatically updatable view, but the conditions
      on the base view with <literal>INSTEAD OF</literal> triggers will not be
      checked (a cascaded check option will not cascade down to a
      trigger-updatable view, and any check options defined directly on a
      trigger-updatable view will be ignored).  If the view or any of its base
      relations has an <literal>INSTEAD</literal> rule that causes the
      <command>INSERT</command> or <command>UPDATE</command> command to be rewritten, then
      all check options will be ignored in the rewritten query, including any
      checks from automatically updatable views defined on top of the relation
      with the <literal>INSTEAD</literal> rule.
     </para>
________________________________________________________-->
     <para>
      注意，只有在自动可更新的、没有<literal>INSTEAD OF</literal>触发器或者
      <literal>INSTEAD</literal>规则的视图上才支持<literal>CHECK OPTION</literal>。
      如果一个自动可更新的视图被定义在一个具有<literal>INSTEAD OF</literal>
      触发器的基视图之上，那么<literal>LOCAL CHECK OPTION</literal>可以被
      用来检查该自动可更新的视图之上的条件，但具有<literal>INSTEAD OF</literal>
      触发器的基视图上的条件不会被检查（一个级联检查选项将不会级联到一个
      触发器可更新的视图，并且任何直接定义在一个触发器可更新视图上的检查
      选项将被忽略）。如果该视图或者任何基础关系具有导致
      <command>INSERT</command>或<command>UPDATE</command>命令被重写的
      <literal>INSTEAD</literal>规则，那么在被重写的查询中将忽略所有检查选项，
      包括任何来自于定义在带有<literal>INSTEAD</literal>规则的关系之上的自动
      可更新视图的检查。
     </para>
<!-- pgdoc-cn_end sig_en=6fdc7add04620d659f2356b38b52f2e3 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
  <title>Notes</title>
________________________________________________________-->
  <title>注解</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->

<!-- pgdoc-cn_start sig_en=d27415897c6e32e2a62577d8c7740d4f sig_cn_org=None source=14.1 
   <para>
    Use the <link linkend="sql-dropview"><command>DROP VIEW</command></link>
    statement to drop views.
   </para>
________________________________________________________-->
   <para>
    使用<link linkend="sql-dropview"><command>DROP VIEW</command></link>语句删除视图。
   </para>
<!-- pgdoc-cn_end sig_en=d27415897c6e32e2a62577d8c7740d4f -->

<!-- pgdoc-cn_start sig_en=6f15f97c3f078e558ea383acf41a6c09 sig_cn_org=None source=14.1 
   <para>
    Be careful that the names and types of the view's columns will be
    assigned the way you want.  For example:
<programlisting>
CREATE VIEW vista AS SELECT 'Hello World';
</programlisting>
    is bad form because the column name defaults to <literal>?column?</literal>;
    also, the column data type defaults to <type>text</type>, which might not
    be what you wanted.  Better style for a string literal in a view's
    result is something like:
<programlisting>
CREATE VIEW vista AS SELECT text 'Hello World' AS hello;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    要小心视图列的名称和类型将会按照你想要的方式指定。例如：
<programlisting>
CREATE VIEW vista AS SELECT 'Hello World';
</programlisting>
    是不好的形式，因为列名默认为<literal>?column?</literal>，而且列的数据类型默认为<type>text</type>，这可能不是用户想要的。视图结果中一个字符串更好的风格类似于这样：
<programlisting>
CREATE VIEW vista AS SELECT text 'Hello World' AS hello;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=6f15f97c3f078e558ea383acf41a6c09 -->

<!-- pgdoc-cn_start sig_en=ff850968d1193ea4f0fbf0f4117389f3 sig_cn_org=46e62a4ca3a5bfbddd48f170b0779b7d source=15.7 
   <para>
    By default, access to the underlying base relations referenced in the view
    is determined by the permissions of the view owner.  In some cases, this
    can be used to provide secure but restricted access to the underlying
    tables.  However, not all views are secure against tampering; see <xref
    linkend="rules-privileges"/> for details.
   </para>
________________________________________________________-->
   <para>
    默认情况下，对视图中引用的基础关系的访问权限由视图所有者的权限确定。在某些情况下，
    这可以用来提供对基础表的安全但受限制的访问。然而，并非所有视图都能防止篡改；详见
    <xref linkend="rules-privileges"/>。
   </para>
<!-- pgdoc-cn_end sig_en=ff850968d1193ea4f0fbf0f4117389f3 -->

<!-- pgdoc-cn_start sig_en=be485ecbd7adb4cd2616c1096a183b2b sig_cn_org=6efb41a101853366b7589d3610071407 source=15.7 
   <para>
    If the view has the <literal>security_invoker</literal> property set to
    <literal>true</literal>, access to the underlying base relations is
    determined by the permissions of the user executing the query, rather than
    the view owner.  Thus, the user of a security invoker view must have the
    relevant permissions on the view and its underlying base relations.
   </para>
________________________________________________________-->
   <para>
    如果视图的<literal>security_invoker</literal>属性设置为<literal>true</literal>，
    则对基础关系的访问权限取决于执行查询的用户的权限，而不是视图所有者的权限。
    因此，安全调用者视图的用户必须对视图及其基础关系具有相关权限。
</para>
<!-- pgdoc-cn_end sig_en=be485ecbd7adb4cd2616c1096a183b2b -->

<!-- pgdoc-cn_start sig_en=6f3ca74e41eb6babe857f09c629422c3 sig_cn_org=81c1a99fe22cf4f3f04a8c549af866e3 source=15.7 
   <para>
    If any of the underlying base relations is a security invoker view, it
    will be treated as if it had been accessed directly from the original
    query.  Thus, a security invoker view will always check its underlying
    base relations using the permissions of the current user, even if it is
    accessed from a view without the <literal>security_invoker</literal>
    property.
   </para>
________________________________________________________-->
   <para>
    如果任何基础关系中有一个是安全调用者视图，它将被视为直接从原始查询中访问。
    因此，安全调用者视图将始终使用当前用户的权限检查其基础关系，即使它是从没有
    <literal>security_invoker</literal>属性的视图中访问。
</para>
<!-- pgdoc-cn_end sig_en=6f3ca74e41eb6babe857f09c629422c3 -->

<!-- pgdoc-cn_start sig_en=322e6e8f8e401d7469c30426638b3e78 sig_cn_org=56e7e54d11af9b40894edd84fa302534 source=15.7 
   <para>
    If any of the underlying base relations has
    <link linkend="ddl-rowsecurity">row-level security</link> enabled, then
    by default, the row-level security policies of the view owner are applied,
    and access to any additional relations referred to by those policies is
    determined by the permissions of the view owner.  However, if the view has
    <literal>security_invoker</literal> set to <literal>true</literal>, then
    the policies and permissions of the invoking user are used instead, as if
    the base relations had been referenced directly from the query using the
    view.
   </para>
________________________________________________________-->
   <para>
    如果任何基础关系中有启用<link linkend="ddl-rowsecurity">行级安全</link>，那么默认情况下，视图所有者的行级安全策略将被应用，
    并且对于这些策略引用的任何其他关系的访问将由视图所有者的权限确定。然而，如果视图设置了<literal>security_invoker</literal>为<literal>true</literal>，
    那么调用用户的策略和权限将被使用，就好像基础关系直接从查询中使用视图引用一样。
   </para>
<!-- pgdoc-cn_end sig_en=322e6e8f8e401d7469c30426638b3e78 -->

<!-- pgdoc-cn_start sig_en=1cc4a3b7a9c075dee49e9575cb1f085b sig_cn_org=62eb57e63ce3f73ab7c803831fdddc9f source=15.7 
   <para>
    Functions called in the view are treated the same as if they had been
    called directly from the query using the view.  Therefore, the user of
    a view must have permissions to call all functions used by the view.
    Functions in the view are executed with the privileges of the user
    executing the query or the function owner, depending on whether the
    functions are defined as <literal>SECURITY INVOKER</literal> or
    <literal>SECURITY DEFINER</literal>.  Thus, for example, calling
    <literal>CURRENT_USER</literal> directly in a view will always return the
    invoking user, not the view owner.  This is not affected by the view's
    <literal>security_invoker</literal> setting, and so a view with
    <literal>security_invoker</literal> set to <literal>false</literal> is
    <emphasis>not</emphasis> equivalent to a
    <literal>SECURITY DEFINER</literal> function and those concepts should not
    be confused.
   </para>
________________________________________________________-->
   <para>
    在视图中调用的函数与直接从查询中使用视图调用的函数一样对待。因此，视图的用户必须具有调用视图中使用的所有函数的权限。
    视图中的函数以执行查询的用户或函数所有者的权限执行，具体取决于这些函数是否被定义为<literal>SECURITY INVOKER</literal>或<literal>SECURITY DEFINER</literal>。
    因此，例如，在视图中直接调用<literal>CURRENT_USER</literal>将始终返回调用用户，而不是视图所有者。
    这不受视图的<literal>security_invoker</literal>设置的影响，因此，将<literal>security_invoker</literal>设置为<literal>false</literal>的视图
    <emphasis>不</emphasis>等同于<literal>SECURITY DEFINER</literal>函数，这些概念不应混淆。
</para>
<!-- pgdoc-cn_end sig_en=1cc4a3b7a9c075dee49e9575cb1f085b -->

<!-- pgdoc-cn_start sig_en=431eaf5dfb2c5942ba0062e4be364e69 sig_cn_org=fa8e0e4780955595407b68f6ab8b7aa1 source=15.7 
   <para>
    The user creating or replacing a view must have <literal>USAGE</literal>
    privileges on any schemas referred to in the view query, in order to look
    up the referenced objects in those schemas.  Note, however, that this
    lookup only happens when the view is created or replaced.  Therefore, the
    user of the view only requires the <literal>USAGE</literal> privilege on
    the schema containing the view, not on the schemas referred to in the view
    query, even for a security invoker view.
   </para>
________________________________________________________-->
   <para>
    创建或替换视图的用户必须对视图查询中引用的任何模式具有<literal>USAGE</literal>权限，
    以便在这些模式中查找引用的对象。然而，请注意，此查找仅在创建或替换视图时发生。
    因此，视图的用户只需要对包含视图的模式具有<literal>USAGE</literal>权限，而不需要对视图查询中引用的模式具有权限，即使是安全调用者视图。
   </para>
<!-- pgdoc-cn_end sig_en=431eaf5dfb2c5942ba0062e4be364e69 -->

<!-- pgdoc-cn_start sig_en=158633ac23f0a22a03005a6f543181ae sig_cn_org=a8678cb3508a34568668ec788f390fb1 source=15.7 
   <para>
    When <command>CREATE OR REPLACE VIEW</command> is used on an existing
    view, only the view's defining SELECT rule, plus any
    <literal>WITH ( ... )</literal> parameters and its
    <literal>CHECK OPTION</literal> are changed.
    Other view properties, including ownership, permissions, and non-SELECT
    rules, remain unchanged.  You must own the view
    to replace it (this includes being a member of the owning role).
   </para>
________________________________________________________-->
   <para>
    当使用<command>CREATE OR REPLACE VIEW</command>来更新现有视图时，只有视图的定义SELECT规则，
    以及任何<literal>WITH ( ... )</literal>参数和其<literal>CHECK OPTION</literal>会被更改。
    其他视图属性，包括所有权、权限和非SELECT规则，保持不变。您必须拥有该视图才能替换它（这包括成为拥有角色的成员）。
</para>
<!-- pgdoc-cn_end sig_en=158633ac23f0a22a03005a6f543181ae -->

  <refsect2 id="sql-createview-updatable-views">
<!-- pgdoc-cn_start sig_en=104283a64d82eef3dbc9e85a07ef31a7 sig_cn_org=None source=14.1 
   <title>Updatable Views</title>
________________________________________________________-->
   <title>可更新视图</title>
<!-- pgdoc-cn_end sig_en=104283a64d82eef3dbc9e85a07ef31a7 -->

<!-- pgdoc-cn_start sig_en=01f3850c8d8eee4dfbb2f6671329dfaf sig_cn_org=None source=14.1 
   <indexterm zone="sql-createview-updatable-views">
    <primary>updatable views</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="sql-createview-updatable-views">
    <primary>可更新视图</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=01f3850c8d8eee4dfbb2f6671329dfaf -->

<!-- pgdoc-cn_start sig_en=441019400c85647f05aecaabc8aa69c8 sig_cn_org=None source=14.1 
   <para>
    Simple views are automatically updatable: the system will allow
    <command>INSERT</command>, <command>UPDATE</command> and <command>DELETE</command> statements
    to be used on the view in the same way as on a regular table.  A view is
    automatically updatable if it satisfies all of the following conditions:

    <itemizedlist>
     <listitem>
      <para>
       The view must have exactly one entry in its <literal>FROM</literal> list,
       which must be a table or another updatable view.
      </para>
     </listitem>

     <listitem>
      <para>
       The view definition must not contain <literal>WITH</literal>,
       <literal>DISTINCT</literal>, <literal>GROUP BY</literal>, <literal>HAVING</literal>,
       <literal>LIMIT</literal>, or <literal>OFFSET</literal> clauses at the top level.
      </para>
     </listitem>

     <listitem>
      <para>
       The view definition must not contain set operations (<literal>UNION</literal>,
       <literal>INTERSECT</literal> or <literal>EXCEPT</literal>) at the top level.
      </para>
     </listitem>

     <listitem>
      <para>
       The view's select list must not contain any aggregates, window functions
       or set-returning functions.
      </para>
     </listitem>
    </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    简单视图是自动可更新的：系统将允许在这类视图上以在常规表上相同的方式
    使用<command>INSERT</command>、<command>UPDATE</command>以及
    <command>DELETE</command>语句。如果一个视图满足以下条件，它就是自动
    可更新的：

    <itemizedlist>
     <listitem>
      <para>
       在该视图的<literal>FROM</literal>列表中刚好只有一项，并且它必须是一个
       表或者另一个可更新视图。
      </para>
     </listitem>

     <listitem>
      <para>
       视图定义的顶层不能包含<literal>WITH</literal>、<literal>DISTINCT</literal>、
       <literal>GROUP BY</literal>、<literal>HAVING</literal>、
       <literal>LIMIT</literal>或者<literal>OFFSET</literal>子句。
      </para>
     </listitem>

     <listitem>
      <para>
       视图定义的顶层不能包含集合操作（<literal>UNION</literal>、
       <literal>INTERSECT</literal>或者<literal>EXCEPT</literal>）。
      </para>
     </listitem>

     <listitem>
      <para>
       视图的选择列表不能包含任何聚集、窗口函数或者集合返回函数。
      </para>
     </listitem>
    </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=441019400c85647f05aecaabc8aa69c8 -->

<!-- pgdoc-cn_start sig_en=6a7a5a0eebe7a17faa8b104a92db179f sig_cn_org=None source=14.1 
   <para>
    An automatically updatable view may contain a mix of updatable and
    non-updatable columns.  A column is updatable if it is a simple reference
    to an updatable column of the underlying base relation; otherwise the
    column is read-only, and an error will be raised if an <command>INSERT</command>
    or <command>UPDATE</command> statement attempts to assign a value to it.
   </para>
________________________________________________________-->
   <para>
    一个自动可更新的视图可以混合可更新列以及不可更新列。如果一个列是对底层
    基本关系中一个可更新列的简单引用，则它是可更新的。否则该列是只读的，并
    且在一个<command>INSERT</command>或者<command>UPDATE</command>语句尝试对
    它赋值时会报出一个错误。
   </para>
<!-- pgdoc-cn_end sig_en=6a7a5a0eebe7a17faa8b104a92db179f -->

<!-- pgdoc-cn_start sig_en=cdaa771ab557eae2e02ae1f9fb34807f sig_cn_org=None source=14.1 
   <para>
    If the view is automatically updatable the system will convert any
    <command>INSERT</command>, <command>UPDATE</command> or <command>DELETE</command> statement
    on the view into the corresponding statement on the underlying base
    relation.  <command>INSERT</command> statements that have an <literal>ON
    CONFLICT UPDATE</literal> clause are fully supported.
   </para>
________________________________________________________-->
   <para>
    如果视图是自动可更新的，系统将把视图上的任何<command>INSERT</command>、
    <command>UPDATE</command>或者<command>DELETE</command>语句转换成在底层
    基本关系上的对应语句。带有<literal>ON CONFLICT UPDATE</literal>子句的
    <command>INSERT</command>语句已经被完全支持。
   </para>
<!-- pgdoc-cn_end sig_en=cdaa771ab557eae2e02ae1f9fb34807f -->

<!-- pgdoc-cn_start sig_en=46c3bbdefb588b9d6c639969f338efd1 sig_cn_org=None source=14.1 
   <para>
    If an automatically updatable view contains a <literal>WHERE</literal>
    condition, the condition restricts which rows of the base relation are
    available to be modified by <command>UPDATE</command> and <command>DELETE</command>
    statements on the view.  However, an <command>UPDATE</command> is allowed to
    change a row so that it no longer satisfies the <literal>WHERE</literal>
    condition, and thus is no longer visible through the view.  Similarly,
    an <command>INSERT</command> command can potentially insert base-relation rows
    that do not satisfy the <literal>WHERE</literal> condition and thus are not
    visible through the view (<literal>ON CONFLICT UPDATE</literal> may
    similarly affect an existing row not visible through the view).
    The <literal>CHECK OPTION</literal> may be used to prevent
    <command>INSERT</command> and <command>UPDATE</command> commands from creating
    such rows that are not visible through the view.
   </para>
________________________________________________________-->
   <para>
    如果一个自动可更新视图包含一个<literal>WHERE</literal>条件，该条件会限制
    基本关系的哪些行可以被该视图上的<command>UPDATE</command>以及
    <command>DELETE</command>语句修改。不过，一个允许被<command>UPDATE</command>
    修改的行可能让该行不再满足<literal>WHERE</literal>条件，并且因此也不再能
    从视图中可见。类似地，一个<command>INSERT</command>命令可能插入不满足
    <literal>WHERE</literal>条件的基本关系行，并且因此从视图中也看不到这些行
    （<literal>ON CONFLICT UPDATE</literal>可能会类似地影响无法通过该视图见
    到的现有行）。
    <literal>CHECK OPTION</literal>可以被用来阻止<command>INSERT</command>和
    <command>UPDATE</command>命令创建这类从视图中无法看到的行。
   </para>
<!-- pgdoc-cn_end sig_en=46c3bbdefb588b9d6c639969f338efd1 -->

<!-- pgdoc-cn_start sig_en=0a097d5906b156b33b70b32a521c3579 sig_cn_org=None source=14.1 
   <para>
    If an automatically updatable view is marked with the
    <literal>security_barrier</literal> property then all the view's <literal>WHERE</literal>
    conditions (and any conditions using operators which are marked as <literal>LEAKPROOF</literal>)
    will always be evaluated before any conditions that a user of the view has
    added.   See <xref linkend="rules-privileges"/> for full details.  Note that,
    due to this, rows which are not ultimately returned (because they do not
    pass the user's <literal>WHERE</literal> conditions) may still end up being locked.
    <command>EXPLAIN</command> can be used to see which conditions are
    applied at the relation level (and therefore do not lock rows) and which are
    not.
   </para>
________________________________________________________-->
   <para>
    如果一个自动可更新视图被标记了<literal>security_barrier</literal>属性，那么
    所有该属性的<literal>WHERE</literal>条件（以及任何使用标记为
    <literal>LEAKPROOF</literal>的操作符的条件）将在该视图使用者的任何条件
    之前计算。详见<xref linkend="rules-privileges"/>。注意正因为这样，不会
    被最终返回的行（因为它们不会通过用户的<literal>WHERE</literal>条件）可能
    仍会结束被锁定的状态。可以用<command>EXPLAIN</command>来查看
    哪些条件被应用在关系层面（并且因此不锁定行）以及哪些不会被应用在关系
    层面。
   </para>
<!-- pgdoc-cn_end sig_en=0a097d5906b156b33b70b32a521c3579 -->

<!-- pgdoc-cn_start sig_en=b4bcf6e418e47bcc32d6dbeafc2bfd36 sig_cn_org=None source=14.1 
   <para>
    A more complex view that does not satisfy all these conditions is
    read-only by default: the system will not allow an insert, update, or
    delete on the view.  You can get the effect of an updatable view by
    creating <literal>INSTEAD OF</literal> triggers on the view, which must
    convert attempted inserts, etc. on the view into appropriate actions
    on other tables.  For more information see <xref
    linkend="sql-createtrigger"/>.  Another possibility is to create rules
    (see <xref linkend="sql-createrule"/>), but in practice triggers are
    easier to understand and use correctly.
   </para>
________________________________________________________-->
   <para>
    一个更加复杂的不满足所有这些条件的视图默认是只读的：系统将不允许在
    该视图上的插入、更新或者删除。可以通过在该视图上创建一个
    <literal>INSTEAD OF</literal>触发器来获得可更新视图的效果，该触发器必须
    把该视图上的尝试的插入等转换成其他表上合适的动作。更多信息请见<xref
    linkend="sql-createtrigger"/>。另一种可能性是创建规则（见
    <xref linkend="sql-createrule"/>），不过实际中触发器更容易理解和正确使用。
   </para>
<!-- pgdoc-cn_end sig_en=b4bcf6e418e47bcc32d6dbeafc2bfd36 -->

<!-- pgdoc-cn_start sig_en=be36b085b57ac7bfd651b658684bfade sig_cn_org=bed89d35576d8db7284bded733121850 source=15.7 
   <para>
    Note that the user performing the insert, update or delete on the view
    must have the corresponding insert, update or delete privilege on the
    view.  In addition, by default, the view's owner must have the relevant
    privileges on the underlying base relations, whereas the user performing
    the update does not need any permissions on the underlying base relations
    (see <xref linkend="rules-privileges"/>).  However, if the view has
    <literal>security_invoker</literal> set to <literal>true</literal>, the
    user performing the update, rather than the view owner, must have the
    relevant privileges on the underlying base relations.
   </para>
________________________________________________________-->
   <para>
    注意，执行对视图进行插入、更新或删除操作的用户必须对该视图具有相应的插入、更新或删除权限。
    另外，默认情况下，视图的所有者必须对底层基本关系具有相关权限，而执行更新操作的用户不需要对底层基本关系有任何权限
    （参见<xref linkend="rules-privileges"/>）。然而，如果视图的<literal>security_invoker</literal>设置为<literal>true</literal>，
    执行更新操作的用户，而不是视图所有者，必须对底层基本关系具有相关权限。
   </para>
<!-- pgdoc-cn_end sig_en=be36b085b57ac7bfd651b658684bfade -->
  </refsect2>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
  <title>Examples</title>
________________________________________________________-->
  <title>示例</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=1496c0373c189ac8678781bcf8b6ee98 sig_cn_org=None source=14.1 
  <para>
   Create a view consisting of all comedy films:

<programlisting>
CREATE VIEW comedies AS
    SELECT *
    FROM films
    WHERE kind = 'Comedy';
</programlisting>
   This will create a view containing the columns that are in the
   <literal>film</literal> table at the time of view creation.  Though
   <literal>*</literal> was used to create the view, columns added later to
   the table will not be part of the view.
  </para>
________________________________________________________-->
  <para>
   创建一个由所有喜剧电影组成的视图：

<programlisting>
CREATE VIEW comedies AS
    SELECT *
    FROM films
    WHERE kind = 'Comedy';
</programlisting>
   创建的视图包含创建时<literal>film</literal>表中的列。尽管<literal>*</literal>
   被用来创建该视图，后来被加入到该表中的列不会成为该视图的组成部分。
  </para>
<!-- pgdoc-cn_end sig_en=1496c0373c189ac8678781bcf8b6ee98 -->

<!-- pgdoc-cn_start sig_en=c08bdffa5ee99f7b96e1b139f4ee9b61 sig_cn_org=None source=14.1 
  <para>
   Create a view with <literal>LOCAL CHECK OPTION</literal>:

<programlisting>
CREATE VIEW universal_comedies AS
    SELECT *
    FROM comedies
    WHERE classification = 'U'
    WITH LOCAL CHECK OPTION;
</programlisting>
   This will create a view based on the <literal>comedies</literal> view, showing
   only films with <literal>kind = 'Comedy'</literal> and
   <literal>classification = 'U'</literal>. Any attempt to <command>INSERT</command> or
   <command>UPDATE</command> a row in the view will be rejected if the new row
   doesn't have <literal>classification = 'U'</literal>, but the film
   <literal>kind</literal> will not be checked.
  </para>
________________________________________________________-->
  <para>
   创建带有<literal>LOCAL CHECK OPTION</literal>的视图：

<programlisting>
CREATE VIEW universal_comedies AS
    SELECT *
    FROM comedies
    WHERE classification = 'U'
    WITH LOCAL CHECK OPTION;
</programlisting>
   这将创建一个基于<literal>comedies</literal>视图的视图，只显示
   <literal>kind = 'Comedy'</literal>和<literal>classification = 'U'</literal>的电影。
   如果新行没有<literal>classification = 'U'</literal>，在该视图中的任何
   <command>INSERT</command>或<command>UPDATE</command>尝试将被拒绝，
   但是电影的<literal>kind</literal>将不会被检查。
  </para>
<!-- pgdoc-cn_end sig_en=c08bdffa5ee99f7b96e1b139f4ee9b61 -->

<!-- pgdoc-cn_start sig_en=538732254f88becef2503e695ad9033a sig_cn_org=None source=14.1 
  <para>
   Create a view with <literal>CASCADED CHECK OPTION</literal>:

<programlisting>
CREATE VIEW pg_comedies AS
    SELECT *
    FROM comedies
    WHERE classification = 'PG'
    WITH CASCADED CHECK OPTION;
</programlisting>
   This will create a view that checks both the <literal>kind</literal> and
   <literal>classification</literal> of new rows.
  </para>
________________________________________________________-->
  <para>
   用<literal>CASCADED CHECK OPTION</literal>创建一个视图：

<programlisting>
CREATE VIEW pg_comedies AS
    SELECT *
    FROM comedies
    WHERE classification = 'PG'
    WITH CASCADED CHECK OPTION;
</programlisting>
   这将创建一个检查新行的<literal>kind</literal>和<literal>classification</literal>
   的视图。
  </para>
<!-- pgdoc-cn_end sig_en=538732254f88becef2503e695ad9033a -->

<!-- pgdoc-cn_start sig_en=6f8ebd6c1b68362ba3aaef6574fb7fab sig_cn_org=None source=14.1 
  <para>
   Create a view with a mix of updatable and non-updatable columns:

<programlisting>
CREATE VIEW comedies AS
    SELECT f.*,
           country_code_to_name(f.country_code) AS country,
           (SELECT avg(r.rating)
            FROM user_ratings r
            WHERE r.film_id = f.id) AS avg_rating
    FROM films f
    WHERE f.kind = 'Comedy';
</programlisting>
   This view will support <command>INSERT</command>, <command>UPDATE</command> and
   <command>DELETE</command>.  All the columns from the <literal>films</literal> table will
   be updatable, whereas the computed columns <literal>country</literal> and
   <literal>avg_rating</literal> will be read-only.
  </para>
________________________________________________________-->
  <para>
   创建一个由可更新列和不可更新列混合而成的视图：

<programlisting>
CREATE VIEW comedies AS
    SELECT f.*,
           country_code_to_name(f.country_code) AS country,
           (SELECT avg(r.rating)
            FROM user_ratings r
            WHERE r.film_id = f.id) AS avg_rating
    FROM films f
    WHERE f.kind = 'Comedy';
</programlisting>
   这个视图将支持<command>INSERT</command>、<command>UPDATE</command>
   以及<command>DELETE</command>。所有来自于<literal>films</literal>表的列都
   将是可更新的，而计算列<literal>country</literal>和<literal>avg_rating</literal>
   将是只读的。
  </para>
<!-- pgdoc-cn_end sig_en=6f8ebd6c1b68362ba3aaef6574fb7fab -->

<!-- pgdoc-cn_start sig_en=3eef555795a27ba5361c5288339b09a1 sig_cn_org=None source=14.1 
  <para>
   Create a recursive view consisting of the numbers from 1 to 100:
<programlisting>
CREATE RECURSIVE VIEW public.nums_1_100 (n) AS
    VALUES (1)
UNION ALL
    SELECT n+1 FROM nums_1_100 WHERE n &lt; 100;
</programlisting>
   Notice that although the recursive view's name is schema-qualified in this
   <command>CREATE</command>, its internal self-reference is not schema-qualified.
   This is because the implicitly-created CTE's name cannot be
   schema-qualified.
  </para>
________________________________________________________-->
  <para>
   创建一个由数字 1 到 100 组成的递归视图：
<programlisting>
CREATE RECURSIVE VIEW public.nums_1_100 (n) AS
    VALUES (1)
UNION ALL
    SELECT n+1 FROM nums_1_100 WHERE n &lt; 100;
</programlisting>
   注意在这个<command>CREATE</command>中尽管递归的视图名称是方案限定的，但它内部的自引用不是方案限定的。这是因为隐式创建的CTE的名称不能是方案限定的。
  </para>
<!-- pgdoc-cn_end sig_en=3eef555795a27ba5361c5288339b09a1 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
  <title>Compatibility</title>
________________________________________________________-->
  <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=b4f058737cf49646f299f4a48814f45a sig_cn_org=53a73050c0577044fbafd267b02a8de4 source=15.7 
  <para>
   <command>CREATE OR REPLACE VIEW</command> is a
   <productname>PostgreSQL</productname> language extension.
   So is the concept of a temporary view.
   The <literal>WITH ( ... )</literal> clause is an extension as well, as are
   security barrier views and security invoker views.
  </para>
________________________________________________________-->
  <para>
   <command>CREATE OR REPLACE VIEW</command>是一个<productname>PostgreSQL</productname>语言扩展。
   临时视图的概念也是如此。
   <literal>WITH ( ... )</literal>子句也是一个扩展，安全屏障视图和安全调用者视图也是如此。
</para>
<!-- pgdoc-cn_end sig_en=b4f058737cf49646f299f4a48814f45a -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=8b7cc214676b443e6527e3d6bf054420 sig_cn_org=None source=14.1 
  <title>See Also</title>
________________________________________________________-->
  <title>另见</title>
<!-- pgdoc-cn_end sig_en=8b7cc214676b443e6527e3d6bf054420 -->

  <simplelist type="inline">
   <member><xref linkend="sql-alterview"/></member>
   <member><xref linkend="sql-dropview"/></member>
   <member><xref linkend="sql-creatematerializedview"/></member>
  </simplelist>
 </refsect1>
</refentry>
