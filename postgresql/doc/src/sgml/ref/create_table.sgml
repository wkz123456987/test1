<!--
doc/src/sgml/ref/create_table.sgml
PostgreSQL documentation
-->

<refentry id="sql-createtable">
<!-- pgdoc-cn_start sig_en=0c1b10acddde46ab4058d5ecaa3cc919 sig_cn_org=None source=14.1 
 <indexterm zone="sql-createtable">
  <primary>CREATE TABLE</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="sql-createtable">
  <primary>CREATE TABLE</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=0c1b10acddde46ab4058d5ecaa3cc919 -->

 <refmeta>
  <refentrytitle>CREATE TABLE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

<!-- pgdoc-cn_start sig_en=7b26fb8e4a113a55d86ecc65a31b82f1 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>CREATE TABLE</refname>
  <refpurpose>define a new table</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>CREATE TABLE</refname>
  <refpurpose>定义一个新表</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=7b26fb8e4a113a55d86ecc65a31b82f1 -->

<!-- pgdoc-cn_start sig_en=4d1f533f6730be2eaca319c0797d2ff0 sig_cn_org=be72eab754a0922759aa91f8fb73d346 source=15.7 
 <refsynopsisdiv>
<synopsis>
CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <replaceable class="parameter">table_name</replaceable> ( [
  { <replaceable class="parameter">column_name</replaceable> <replaceable class="parameter">data_type</replaceable> [ COMPRESSION <replaceable>compression_method</replaceable> ] [ COLLATE <replaceable>collation</replaceable> ] [ <replaceable class="parameter">column_constraint</replaceable> [ ... ] ]
    | <replaceable>table_constraint</replaceable>
    | LIKE <replaceable>source_table</replaceable> [ <replaceable>like_option</replaceable> ... ] }
    [, ... ]
] )
[ INHERITS ( <replaceable>parent_table</replaceable> [, ... ] ) ]
[ PARTITION BY { RANGE | LIST | HASH } ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [, ... ] ) ]
[ USING <replaceable class="parameter">method</replaceable> ]
[ WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] ) | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <replaceable class="parameter">table_name</replaceable>
    OF <replaceable class="parameter">type_name</replaceable> [ (
  { <replaceable class="parameter">column_name</replaceable> [ WITH OPTIONS ] [ <replaceable class="parameter">column_constraint</replaceable> [ ... ] ]
    | <replaceable>table_constraint</replaceable> }
    [, ... ]
) ]
[ PARTITION BY { RANGE | LIST | HASH } ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [, ... ] ) ]
[ USING <replaceable class="parameter">method</replaceable> ]
[ WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] ) | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <replaceable class="parameter">table_name</replaceable>
    PARTITION OF <replaceable class="parameter">parent_table</replaceable> [ (
  { <replaceable class="parameter">column_name</replaceable> [ WITH OPTIONS ] [ <replaceable class="parameter">column_constraint</replaceable> [ ... ] ]
    | <replaceable>table_constraint</replaceable> }
    [, ... ]
) ] { FOR VALUES <replaceable class="parameter">partition_bound_spec</replaceable> | DEFAULT }
[ PARTITION BY { RANGE | LIST | HASH } ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [, ... ] ) ]
[ USING <replaceable class="parameter">method</replaceable> ]
[ WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] ) | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]

<phrase>where <replaceable class="parameter">column_constraint</replaceable> is:</phrase>

[ CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> ]
{ NOT NULL |
  NULL |
  CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ] |
  DEFAULT <replaceable>default_expr</replaceable> |
  GENERATED ALWAYS AS ( <replaceable>generation_expr</replaceable> ) STORED |
  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>sequence_options</replaceable> ) ] |
  UNIQUE [ NULLS [ NOT ] DISTINCT ] <replaceable class="parameter">index_parameters</replaceable> |
  PRIMARY KEY <replaceable class="parameter">index_parameters</replaceable> |
  REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <replaceable class="parameter">referential_action</replaceable> ] [ ON UPDATE <replaceable class="parameter">referential_action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase>and <replaceable class="parameter">table_constraint</replaceable> is:</phrase>

[ CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> ]
{ CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ] |
  UNIQUE [ NULLS [ NOT ] DISTINCT ] ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> |
  PRIMARY KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> |
  EXCLUDE [ USING <replaceable class="parameter">index_method</replaceable> ] ( <replaceable class="parameter">exclude_element</replaceable> WITH <replaceable class="parameter">operator</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> [ WHERE ( <replaceable class="parameter">predicate</replaceable> ) ] |
  FOREIGN KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <replaceable
class="parameter">referential_action</replaceable> ] [ ON UPDATE <replaceable class="parameter">referential_action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase>and <replaceable class="parameter">like_option</replaceable> is:</phrase>

{ INCLUDING | EXCLUDING } { COMMENTS | COMPRESSION | CONSTRAINTS | DEFAULTS | GENERATED | IDENTITY | INDEXES | STATISTICS | STORAGE | ALL }

<phrase>and <replaceable class="parameter">partition_bound_spec</replaceable> is:</phrase>

IN ( <replaceable class="parameter">partition_bound_expr</replaceable> [, ...] ) |
FROM ( { <replaceable class="parameter">partition_bound_expr</replaceable> | MINVALUE | MAXVALUE } [, ...] )
  TO ( { <replaceable class="parameter">partition_bound_expr</replaceable> | MINVALUE | MAXVALUE } [, ...] ) |
WITH ( MODULUS <replaceable class="parameter">numeric_literal</replaceable>, REMAINDER <replaceable class="parameter">numeric_literal</replaceable> )

<phrase><replaceable class="parameter">index_parameters</replaceable> in <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, and <literal>EXCLUDE</literal> constraints are:</phrase>

[ INCLUDE ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) ]
[ WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] ) ]
[ USING INDEX TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]

<phrase><replaceable class="parameter">exclude_element</replaceable> in an <literal>EXCLUDE</literal> constraint is:</phrase>

{ <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> [ ( <replaceable class="parameter">opclass_parameter</replaceable> = <replaceable class="parameter">value</replaceable> [, ... ] ) ] ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]

<phrase><replaceable class="parameter">referential_action</replaceable> in a <literal>FOREIGN KEY</literal>/<literal>REFERENCES</literal> constraint is:</phrase>

{ NO ACTION | RESTRICT | CASCADE | SET NULL [ ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) ] | SET DEFAULT [ ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) ] }
</synopsis>
________________________________________________________-->
 <refsynopsisdiv>
<synopsis>
CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <replaceable class="parameter">table_name</replaceable> ( [
  { <replaceable class="parameter">column_name</replaceable> <replaceable class="parameter">data_type</replaceable> [ COMPRESSION <replaceable>compression_method</replaceable> ] [ COLLATE <replaceable>collation</replaceable> ] [ <replaceable class="parameter">column_constraint</replaceable> [ ... ] ]
    | <replaceable>table_constraint</replaceable>
    | LIKE <replaceable>source_table</replaceable> [ <replaceable>like_option</replaceable> ... ] }
    [, ... ]
] )
[ INHERITS ( <replaceable>parent_table</replaceable> [, ... ] ) ]
[ PARTITION BY { RANGE | LIST | HASH } ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [, ... ] ) ]
[ USING <replaceable class="parameter">method</replaceable> ]
[ WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] ) | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <replaceable class="parameter">table_name</replaceable>
    OF <replaceable class="parameter">type_name</replaceable> [ (
  { <replaceable class="parameter">column_name</replaceable> [ WITH OPTIONS ] [ <replaceable class="parameter">column_constraint</replaceable> [ ... ] ]
    | <replaceable>table_constraint</replaceable> }
    [, ... ]
) ]
[ PARTITION BY { RANGE | LIST | HASH } ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [, ... ] ) ]
[ USING <replaceable class="parameter">method</replaceable> ]
[ WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] ) | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <replaceable class="parameter">table_name</replaceable>
    PARTITION OF <replaceable class="parameter">parent_table</replaceable> [ (
  { <replaceable class="parameter">column_name</replaceable> [ WITH OPTIONS ] [ <replaceable class="parameter">column_constraint</replaceable> [ ... ] ]
    | <replaceable>table_constraint</replaceable> }
    [, ... ]
) ] { FOR VALUES <replaceable class="parameter">partition_bound_spec</replaceable> | DEFAULT }
[ PARTITION BY { RANGE | LIST | HASH } ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [, ... ] ) ]
[ USING <replaceable class="parameter">method</replaceable> ]
[ WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] ) | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]

<phrase>where <replaceable class="parameter">column_constraint</replaceable> is:</phrase>

[ CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> ]
{ NOT NULL |
  NULL |
  CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ] |
  DEFAULT <replaceable>default_expr</replaceable> |
  GENERATED ALWAYS AS ( <replaceable>generation_expr</replaceable> ) STORED |
  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>sequence_options</replaceable> ) ] |
  UNIQUE [ NULLS [ NOT ] DISTINCT ] <replaceable class="parameter">index_parameters</replaceable> |
  PRIMARY KEY <replaceable class="parameter">index_parameters</replaceable> |
  REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <replaceable class="parameter">referential_action</replaceable> ] [ ON UPDATE <replaceable class="parameter">referential_action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase>and <replaceable class="parameter">table_constraint</replaceable> is:</phrase>

[ CONSTRAINT <replaceable class="parameter">constraint_name</replaceable> ]
{ CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ] |
  UNIQUE [ NULLS [ NOT ] DISTINCT ] ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> |
  PRIMARY KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> |
  EXCLUDE [ USING <replaceable class="parameter">index_method</replaceable> ] ( <replaceable class="parameter">exclude_element</replaceable> WITH <replaceable class="parameter">operator</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> [ WHERE ( <replaceable class="parameter">predicate</replaceable> ) ] |
  FOREIGN KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <replaceable
class="parameter">referential_action</replaceable> ] [ ON UPDATE <replaceable class="parameter">referential_action</replaceable> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<phrase>and <replaceable class="parameter">like_option</replaceable> is:</phrase>

{ INCLUDING | EXCLUDING } { COMMENTS | COMPRESSION | CONSTRAINTS | DEFAULTS | GENERATED | IDENTITY | INDEXES | STATISTICS | STORAGE | ALL }

<phrase>and <replaceable class="parameter">partition_bound_spec</replaceable> is:</phrase>

IN ( <replaceable class="parameter">partition_bound_expr</replaceable> [, ...] ) |
FROM ( { <replaceable class="parameter">partition_bound_expr</replaceable> | MINVALUE | MAXVALUE } [, ...] )
  TO ( { <replaceable class="parameter">partition_bound_expr</replaceable> | MINVALUE | MAXVALUE } [, ...] ) |
WITH ( MODULUS <replaceable class="parameter">numeric_literal</replaceable>, REMAINDER <replaceable class="parameter">numeric_literal</replaceable> )

<phrase><replaceable class="parameter">index_parameters</replaceable> in <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>, and <literal>EXCLUDE</literal> constraints are:</phrase>

[ INCLUDE ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) ]
[ WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] ) ]
[ USING INDEX TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]

<phrase><replaceable class="parameter">exclude_element</replaceable> in an <literal>EXCLUDE</literal> constraint is:</phrase>

{ <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> [ ( <replaceable class="parameter">opclass_parameter</replaceable> = <replaceable class="parameter">value</replaceable> [, ... ] ) ] ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]

<phrase><replaceable class="parameter">referential_action</replaceable> in a <literal>FOREIGN KEY</literal>/<literal>REFERENCES</literal> constraint is:</phrase>

{ NO ACTION | RESTRICT | CASCADE | SET NULL [ ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) ] | SET DEFAULT [ ( <replaceable class="parameter">column_name</replaceable> [, ... ] ) ] }
</synopsis>
<!-- pgdoc-cn_end sig_en=4d1f533f6730be2eaca319c0797d2ff0 -->

 </refsynopsisdiv>

 <refsect1 id="sql-createtable-description">
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=99b8de90d68202e1a4536bc2c7832993 sig_cn_org=None source=14.1 
  <para>
   <command>CREATE TABLE</command> will create a new, initially empty table
   in the current database. The table will be owned by the user issuing the
   command.
  </para>
________________________________________________________-->
  <para>
   <command>CREATE TABLE</command>将在当前数据库中创建一个新的、初始为空的表。该表将由发出该命令的用户所拥有。
  </para>
<!-- pgdoc-cn_end sig_en=99b8de90d68202e1a4536bc2c7832993 -->

<!-- pgdoc-cn_start sig_en=e33008bb2c029e12d5b8cb12ee22d1a2 sig_cn_org=dc6e5e60f233029b190f83c446e1fb8b source=15.7 
  <para>
   If a schema name is given (for example, <literal>CREATE TABLE
   myschema.mytable ...</literal>) then the table is created in the specified
   schema.  Otherwise it is created in the current schema.  Temporary
   tables exist in a special schema, so a schema name cannot be given
   when creating a temporary table.  The name of the table must be
   distinct from the name of any other relation (table, sequence, index, view,
   materialized view, or foreign table) in the same schema.
  </para>
________________________________________________________-->
  <para>
   如果给出了模式名称（例如，<literal>CREATE TABLE
   myschema.mytable ...</literal>），则表将在指定的模式中创建。
   否则，它将在当前模式中创建。 临时表存在于一个特殊的模式中，因此在创建临时表时不能给出模式名称。
   表的名称必须与同一模式中的任何其他关系（表、序列、索引、视图、物化视图或外部表）的名称不同。
</para>
<!-- pgdoc-cn_end sig_en=e33008bb2c029e12d5b8cb12ee22d1a2 -->

<!-- pgdoc-cn_start sig_en=3306a6eb9c9b32cd6973fcfa71c3c909 sig_cn_org=None source=14.1 
  <para>
   <command>CREATE TABLE</command> also automatically creates a data
   type that represents the composite type corresponding
   to one row of the table.  Therefore, tables cannot have the same
   name as any existing data type in the same schema.
  </para>
________________________________________________________-->
  <para>
   <command>CREATE TABLE</command>也会自动地创建一个数据类型来表示对应于该表一行的组合类型。因此，表不能用同一个模式中任何已有数据类型的名称。
  </para>
<!-- pgdoc-cn_end sig_en=3306a6eb9c9b32cd6973fcfa71c3c909 -->

<!-- pgdoc-cn_start sig_en=e9da1d304bd09d27583044089fc3717c sig_cn_org=None source=14.1 
  <para>
   The optional constraint clauses specify constraints (tests) that
   new or updated rows must satisfy for an insert or update operation
   to succeed.  A constraint is an SQL object that helps define the
   set of valid values in the table in various ways.
  </para>
________________________________________________________-->
  <para>
   可选的约束子句指定一个插入或更新操作要成功，新的或更新过的行必须满足的约束（测试）。一个约束是一个 SQL 对象，它帮助以多种方式定义表中的合法值集合。
  </para>
<!-- pgdoc-cn_end sig_en=e9da1d304bd09d27583044089fc3717c -->

<!-- pgdoc-cn_start sig_en=6243a3e9f2378f1780af3061f04593ff sig_cn_org=None source=14.1 
  <para>
   There are two ways to define constraints: table constraints and
   column constraints.  A column constraint is defined as part of a
   column definition.  A table constraint definition is not tied to a
   particular column, and it can encompass more than one column.
   Every column constraint can also be written as a table constraint;
   a column constraint is only a notational convenience for use when the
   constraint only affects one column.
  </para>
________________________________________________________-->
  <para>
   有两种方式来定义约束：表约束和列约束。一个列约束会作为列定义的一部分定义。一个表约束定义不与一个特定列绑定，并且它可以包含多于一个列。每一个列约束也可以被写作一个表约束，列约束只是一种当约束只影响一列时方便书写的记号习惯。
  </para>
<!-- pgdoc-cn_end sig_en=6243a3e9f2378f1780af3061f04593ff -->

<!-- pgdoc-cn_start sig_en=cb5742f142c997bfd045589db0e08b4f sig_cn_org=None source=14.1 
  <para>
   To be able to create a table, you must have <literal>USAGE</literal>
   privilege on all column types or the type in the <literal>OF</literal>
   clause, respectively.
  </para>
________________________________________________________-->
  <para>
   要能创建一个表，你必须分别具有所有列类型或<literal>OF</literal>子句中类型的<literal>USAGE</literal>特权。
  </para>
<!-- pgdoc-cn_end sig_en=cb5742f142c997bfd045589db0e08b4f -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
  <title>Parameters</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

  <variablelist>

   <varlistentry id="sql-createtable-temporary">
<!-- pgdoc-cn_start sig_en=38f5f15c2286c0019a288ab70bbfb93e sig_cn_org=None source=14.1 
    <term><literal>TEMPORARY</literal> or <literal>TEMP</literal></term>
________________________________________________________-->
    <term><literal>TEMPORARY</literal> or <literal>TEMP</literal></term>
<!-- pgdoc-cn_end sig_en=38f5f15c2286c0019a288ab70bbfb93e -->
    <listitem>
<!-- pgdoc-cn_start sig_en=9a825f0ebb4132be54416b8ad76c793a sig_cn_org=None source=14.1 
     <para>
      If specified, the table is created as a temporary table.
      Temporary tables are automatically dropped at the end of a
      session, or optionally at the end of the current transaction
      (see <literal>ON COMMIT</literal> below).  The default
      search_path includes the temporary schema first and so identically
      named existing permanent tables are not chosen for new plans
      while the temporary table exists, unless they are referenced
      with schema-qualified names. Any indexes created on a temporary
      table are automatically temporary as well.
     </para>
________________________________________________________-->
     <para>
      如果指定，该表被创建为一个临时表。
      临时表会被在会话结束时自动被删除，或者也可以选择在当前事务结束时删除（见下文的<literal>ON COMMIT</literal>）。
      默认搜索路径首先包括临时模式，因此当临时表存在时，不会为新计划选择同名的已有的永久表，除非它们使用模式限定的名称进行引用。	  
      在一个临时表上创建的任何索引也自动地变为临时的。
     </para>
<!-- pgdoc-cn_end sig_en=9a825f0ebb4132be54416b8ad76c793a -->

<!-- pgdoc-cn_start sig_en=8f28a540f70684576205d1369869ac0f sig_cn_org=None source=14.1 
     <para>
      The <link linkend="autovacuum">autovacuum daemon</link> cannot
      access and therefore cannot vacuum or analyze temporary tables.
      For this reason, appropriate vacuum and analyze operations should be
      performed via session SQL commands.  For example, if a temporary
      table is going to be used in complex queries, it is wise to run
      <command>ANALYZE</command> on the temporary table after it is populated.
     </para>
________________________________________________________-->
     <para>
      <link linkend="autovacuum">自动清理守护进程</link>不能访问并且因此也不能清理或分析临时表。由于这个原因，应该通过会话的 SQL 命令执行合适的清理和分析操作。例如，如果一个临时表将要被用于复杂的查询，最好在把它填充完毕后在其上运行<command>ANALYZE</command>。
     </para>
<!-- pgdoc-cn_end sig_en=8f28a540f70684576205d1369869ac0f -->

<!-- pgdoc-cn_start sig_en=e059f4843d787b50f2e3a073e3d35139 sig_cn_org=None source=14.1 
     <para>
      Optionally, <literal>GLOBAL</literal> or <literal>LOCAL</literal>
      can be written before <literal>TEMPORARY</literal> or <literal>TEMP</literal>.
      This presently makes no difference in <productname>PostgreSQL</productname>
      and is deprecated; see
      <xref linkend="sql-createtable-compatibility"/> below.
     </para>
________________________________________________________-->
     <para>
      可以选择将<literal>GLOBAL</literal>或<literal>LOCAL</literal>写在<literal>TEMPORARY</literal>或<literal>TEMP</literal>的前面。这当前在<productname>PostgreSQL</productname>中没有区别并且已被废弃，见<xref linkend="sql-createtable-compatibility"/>。
     </para>
<!-- pgdoc-cn_end sig_en=e059f4843d787b50f2e3a073e3d35139 -->
    </listitem>
   </varlistentry>

   <varlistentry id="sql-createtable-unlogged">
    <term><literal>UNLOGGED</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=38cd3c7b30588b64a53f5b83c1f3cb67 sig_cn_org=None source=14.1 
     <para>
      If specified, the table is created as an unlogged table.  Data written
      to unlogged tables is not written to the write-ahead log (see <xref
      linkend="wal"/>), which makes them considerably faster than ordinary
      tables.  However, they are not crash-safe: an unlogged table is
      automatically truncated after a crash or unclean shutdown.  The contents
      of an unlogged table are also not replicated to standby servers.
      Any indexes created on an unlogged table are automatically unlogged as
      well.
     </para>
________________________________________________________-->
     <para>
      如果指定，该表被创建为一个不受日志记录的表。被写入到不做日志的表中的数据不会被写到预写式日志中（见<xref linkend="wal"/>），这让它们比普通表快非常多。不过，它们在崩溃时是不安全的：一个不做日志的表在一次崩溃或非干净关闭之后会被自动地截断。一个不做日志的表中的内容也不会被复制到后备服务器中。在一个不做日志的表上创建的任何索引也会自动地不被日志记录。
     </para>
<!-- pgdoc-cn_end sig_en=38cd3c7b30588b64a53f5b83c1f3cb67 -->

<!-- pgdoc-cn_start sig_en=f1fe410afec5c1611999923f23f98fc3 sig_cn_org=ff9d3a6b7c3ae51f7953dfc04c4ad06c source=15.7 
     <para>
      If this is specified, any sequences created together with the unlogged
      table (for identity or serial columns) are also created as unlogged.
     </para>
________________________________________________________-->
     <para>
      如果指定了这个选项，那么与非记录表一起创建的任何序列（用于标识或序列列）也将被创建为非记录的。
     </para>
<!-- pgdoc-cn_end sig_en=f1fe410afec5c1611999923f23f98fc3 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>IF NOT EXISTS</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=8b230bc7b271cc6fa0e0e8d969266139 sig_cn_org=None source=14.1 
     <para>
      Do not throw an error if a relation with the same name already exists.
      A notice is issued in this case.  Note that there is no guarantee that
      the existing relation is anything like the one that would have been
      created.
     </para>
________________________________________________________-->
     <para>
      如果一个同名关系已经存在，不要抛出一个错误。在这种情况下会发出一个提示。注意这不保证现有的关系是和将要被创建的表相似的东西。
     </para>
<!-- pgdoc-cn_end sig_en=8b230bc7b271cc6fa0e0e8d969266139 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">table_name</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=53bb0823460e7bb61174fdc991c87c9a sig_cn_org=None source=14.1 
     <para>
      The name (optionally schema-qualified) of the table to be created.
     </para>
________________________________________________________-->
     <para>
      要被创建的表名（可以选择用模式限定）。
     </para>
<!-- pgdoc-cn_end sig_en=53bb0823460e7bb61174fdc991c87c9a -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OF <replaceable class="parameter">type_name</replaceable></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=8f41ace42c8a059c7fbeaf629663eb80 sig_cn_org=None source=14.1 
     <para>
      Creates a <firstterm>typed table</firstterm>, which takes its
      structure from the specified composite type (name optionally
      schema-qualified).  A typed table is tied to its type; for
      example the table will be dropped if the type is dropped
      (with <literal>DROP TYPE ... CASCADE</literal>).
     </para>
________________________________________________________-->
     <para>
      创建一个<firstterm>类型化的表</firstterm>，它的结构取自于指定的组合类型（名字可以选择用模式限定）。一个类型化的表和它的类型绑定在一起，例如如果类型被删除，该表也将被删除（用<literal>DROP TYPE ... CASCADE</literal>）。
     </para>
<!-- pgdoc-cn_end sig_en=8f41ace42c8a059c7fbeaf629663eb80 -->

<!-- pgdoc-cn_start sig_en=7adc016fa58fe748d2e88bc37aa1b597 sig_cn_org=None source=14.1 
     <para>
      When a typed table is created, then the data types of the
      columns are determined by the underlying composite type and are
      not specified by the <literal>CREATE TABLE</literal> command.
      But the <literal>CREATE TABLE</literal> command can add defaults
      and constraints to the table and can specify storage parameters.
     </para>
________________________________________________________-->
     <para>
      当一个类型化的表被创建时，列的数据类型由底层的组合类型决定而没有在<literal>CREATE TABLE</literal>命令中直接指定。但是<literal>CREATE TABLE</literal>命令可以对表增加默认值和约束，并且可以指定存储参数。
     </para>
<!-- pgdoc-cn_end sig_en=7adc016fa58fe748d2e88bc37aa1b597 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">column_name</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=4fc30e2a7de04c922abb02a57f46ce78 sig_cn_org=None source=14.1 
     <para>
      The name of a column to be created in the new table.
     </para>
________________________________________________________-->
     <para>
      列的名称会在新表中被建立.
     </para>
<!-- pgdoc-cn_end sig_en=4fc30e2a7de04c922abb02a57f46ce78 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">data_type</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=28664c2469604c58925a2321661bd00b sig_cn_org=None source=14.1 
     <para>
      The data type of the column. This can include array
      specifiers. For more information on the data types supported by
      <productname>PostgreSQL</productname>, refer to <xref
      linkend="datatype"/>.
     </para>
________________________________________________________-->
     <para>
      列的数据类型. 这可以包括数组
      规格. 有关<productname>PostgreSQL</productname>支持数据类型的详细信息, 请参考<xref
      linkend="datatype"/>.
     </para>
<!-- pgdoc-cn_end sig_en=28664c2469604c58925a2321661bd00b -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>COLLATE <replaceable>collation</replaceable></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=a6a4ce9d315a3680172ae9e01b4f9f8a sig_cn_org=None source=14.1 
     <para>
      The <literal>COLLATE</literal> clause assigns a collation to
      the column (which must be of a collatable data type).
      If not specified, the column data type's default collation is used.
     </para>
________________________________________________________-->
     <para>
      <literal>COLLATE</literal>子句为该列（必须是一种可排序数据类型）赋予一个排序规则。
      如果没有指定，将使用该列数据类型的默认排序规则。
     </para>
<!-- pgdoc-cn_end sig_en=a6a4ce9d315a3680172ae9e01b4f9f8a -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>COMPRESSION <replaceable class="parameter">compression_method</replaceable></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=4f1663686e00aebf89fd72dc2825e723 sig_cn_org=None source=14.1 
     <para>
      The <literal>COMPRESSION</literal> clause sets the compression method
      for the column.  Compression is supported only for variable-width data
      types, and is used only when the column's storage mode
      is <literal>main</literal> or <literal>extended</literal>.
      (See <xref linkend="sql-altertable"/> for information on
      column storage modes.) Setting this property for a partitioned table
      has no direct effect, because such tables have no storage of their own,
      but the configured value will be inherited by newly-created partitions.
      The supported compression methods are <literal>pglz</literal> and
      <literal>lz4</literal>.  (<literal>lz4</literal> is available only if
      <option>-&minus;with-lz4</option> was used when building
      <productname>PostgreSQL</productname>.)  In addition,
      <replaceable class="parameter">compression_method</replaceable>
      can be <literal>default</literal> to explicitly specify the default
      behavior, which is to consult the
      <xref linkend="guc-default-toast-compression"/> setting at the time of
      data insertion to determine the method to use.
     </para>
________________________________________________________-->
     <para>
      <literal>COMPRESSION</literal>子句设置列的压缩方法。
	  压缩仅支持变宽数据类型，并且仅可在列的存储模式为<literal>main</literal> 或 <literal>extended</literal>的时候使用。
	  (列存储模式的信息请参见<xref linkend="sql-altertable"/>。)
	  为分区表设置此属性没有直接影响，因为该表没有自己的存储空间，但是配置值将由新创建的分区继承。
	  支持的压缩方法为<literal>pglz</literal> 和<literal>lz4</literal>。
	  (仅在构建<productname>PostgreSQL</productname>时使用了<option>--with-lz4</option>的时候，<literal>lz4</literal> 才可用。)
	  此外，<replaceable class="parameter">compression_method</replaceable>可以<literal>default</literal>的来显式地指定默认行为，也就是在数据插入时参考<xref linkend="guc-default-toast-compression"/> 设置，以确定要使用的方法。
     </para>
<!-- pgdoc-cn_end sig_en=4f1663686e00aebf89fd72dc2825e723 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INHERITS ( <replaceable>parent_table</replaceable> [, ... ] )</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=b526a2269ba6e792db13dbae4c546c11 sig_cn_org=None source=14.1 
     <para>
      The optional <literal>INHERITS</literal> clause specifies a list of
      tables from which the new table automatically inherits all
      columns.  Parent tables can be plain tables or foreign tables.
     </para>
________________________________________________________-->
     <para>
      可选的<literal>INHERITS</literal>子句指定一个表的列表，
    新表将从其中自动地继承所有列。
    父表可以是普通表或者外部表。
     </para>
<!-- pgdoc-cn_end sig_en=b526a2269ba6e792db13dbae4c546c11 -->

<!-- pgdoc-cn_start sig_en=e7d61a8f6d7f7ba9b24edb2d3f5983ce sig_cn_org=None source=14.1 
     <para>
      Use of <literal>INHERITS</literal> creates a persistent relationship
      between the new child table and its parent table(s).  Schema
      modifications to the parent(s) normally propagate to children
      as well, and by default the data of the child table is included in
      scans of the parent(s).
     </para>
________________________________________________________-->
     <para>
      <literal>INHERITS</literal>的使用在新的子表和它的父表之间创建一种持久的关系。
    对于父表的模式修改通常也会传播到子表，
    并且默认情况下子表的数据会被包括在对父表的扫描中。
     </para>
<!-- pgdoc-cn_end sig_en=e7d61a8f6d7f7ba9b24edb2d3f5983ce -->

<!-- pgdoc-cn_start sig_en=f9ef200913650c34dea178e0684eb92b sig_cn_org=None source=14.1 
     <para>
      If the same column name exists in more than one parent
      table, an error is reported unless the data types of the columns
      match in each of the parent tables.  If there is no conflict,
      then the duplicate columns are merged to form a single column in
      the new table.  If the column name list of the new table
      contains a column name that is also inherited, the data type must
      likewise match the inherited column(s), and the column
      definitions are merged into one.  If the
      new table explicitly specifies a default value for the column,
      this default overrides any defaults from inherited declarations
      of the column.  Otherwise, any parents that specify default
      values for the column must all specify the same default, or an
      error will be reported.
     </para>
________________________________________________________-->
     <para>
      如果在多个父表中存在同名的列，除非父表中每一个这种列的数据类型都能匹配，
    否则会报告一个错误。如果没有冲突，那么重复列会被融合来形成新表中的一个单一列。
    如果新表中的列名列表包含一个也是继承而来的列名，该数据类型必须也匹配继承的列，
    并且列定义会被融合成一个。如果新表显式地为列指定了任何默认值，
    这个默认值将覆盖来自该列继承声明中的默认值。
    否则，任何父表都必须为该列指定相同的默认值，或者会报告一个错误。
     </para>
<!-- pgdoc-cn_end sig_en=f9ef200913650c34dea178e0684eb92b -->

<!-- pgdoc-cn_start sig_en=e2b9e3f8086f7216a24fab59eb0869d9 sig_cn_org=None source=14.1 
     <para>
      <literal>CHECK</literal> constraints are merged in essentially the same way as
      columns: if multiple parent tables and/or the new table definition
      contain identically-named <literal>CHECK</literal> constraints, these
      constraints must all have the same check expression, or an error will be
      reported.  Constraints having the same name and expression will
      be merged into one copy.  A constraint marked <literal>NO INHERIT</literal> in a
      parent will not be considered.  Notice that an unnamed <literal>CHECK</literal>
      constraint in the new table will never be merged, since a unique name
      will always be chosen for it.
     </para>
________________________________________________________-->
     <para>
      <literal>CHECK</literal>约束本质上也采用和列相同的方式被融合：
    如果多个父表或者新表定义中包含相同的命名<literal>CHECK</literal>约束，
    这些约束必须全部具有相同的检查表达式，否则将报告一个错误。
    具有相同名称和表达式的约束将被融合成一份拷贝。
    一个父表中的被标记为<literal>NO INHERIT</literal>的约束将不会被考虑。
    注意新表中一个未命名的<literal>CHECK</literal>约束将永远不会被融合，
    因为那样总是会为它选择一个唯一的名字。
     </para>
<!-- pgdoc-cn_end sig_en=e2b9e3f8086f7216a24fab59eb0869d9 -->

<!-- pgdoc-cn_start sig_en=eddb1b8873ecaf8f50462e83088f9577 sig_cn_org=None source=14.1 
     <para>
      Column <literal>STORAGE</literal> settings are also copied from parent tables.
     </para>
________________________________________________________-->
     <para>
      列的<literal>STORAGE</literal>设置也会从父表复制过来。
     </para>
<!-- pgdoc-cn_end sig_en=eddb1b8873ecaf8f50462e83088f9577 -->

<!-- pgdoc-cn_start sig_en=bdcae099527ac96bc97f6dc8b5c2c606 sig_cn_org=None source=14.1 
     <para>
      If a column in the parent table is an identity column, that property is
      not inherited.  A column in the child table can be declared identity
      column if desired.
     </para>
________________________________________________________-->
     <para>
      如果父表中的列是标识列，那么该属性不会被继承。
    如果需要，可以将子表中的列声明为标识列。
     </para>
<!-- pgdoc-cn_end sig_en=bdcae099527ac96bc97f6dc8b5c2c606 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>PARTITION BY { RANGE | LIST | HASH } ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ <replaceable class="parameter">opclass</replaceable> ] [, ...] ) </literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=a2a31aa8b42f35923d9397a8d2d8c411 sig_cn_org=None source=14.1 
     <para>
      The optional <literal>PARTITION BY</literal> clause specifies a strategy
      of partitioning the table.  The table thus created is called a
      <firstterm>partitioned</firstterm> table.  The parenthesized list of
      columns or expressions forms the <firstterm>partition key</firstterm>
      for the table.  When using range or hash partitioning, the partition key
      can include multiple columns or expressions (up to 32, but this limit can
      be altered when building <productname>PostgreSQL</productname>), but for
      list partitioning, the partition key must consist of a single column or
      expression.
     </para>
________________________________________________________-->
     <para>
      可选的<literal>PARTITION BY</literal>子句指定了对表进行分区的策略。
    这样创建的表称为<firstterm>分区</firstterm>表。
    带括号的列或表达式的列表构成表的<firstterm>分区键</firstterm>。
    使用范围或哈希分区时，分区键可以包含多个列或表达式（最多32个，但在构建
    <productname>PostgreSQL</productname>时可以更改此限制），
    但对于列表分区，分区键必须由单个列或表达式组成。
     </para>
<!-- pgdoc-cn_end sig_en=a2a31aa8b42f35923d9397a8d2d8c411 -->

<!-- pgdoc-cn_start sig_en=f7f668220f7c7d507eb8689a4f3dc3de sig_cn_org=None source=14.1 
     <para>
      Range and list partitioning require a btree operator class, while hash
      partitioning requires a hash operator class.  If no operator class is
      specified explicitly, the default operator class of the appropriate
      type will be used; if no default operator class exists, an error will
      be raised.  When hash partitioning is used, the operator class used
      must implement support function 2 (see <xref linkend="xindex-support"/>
      for details).
     </para>
________________________________________________________-->
     <para>
      范围和列表分区需要 btree 运算符类，而哈希分区需要哈希运算符类。
    如果没有运算符类被显式指定，将使用相应类型的默认运算符类;
    如果不存在默认运算符类，则将引发错误。 
    使用哈希分区时，所使用的运算符类必须实现支持功能 2（详情请参阅<xref linkend="xindex-support"/>）。
     </para>
<!-- pgdoc-cn_end sig_en=f7f668220f7c7d507eb8689a4f3dc3de -->

<!-- pgdoc-cn_start sig_en=572d8fdd74ed776c44bb3ff3b687e10b sig_cn_org=None source=14.1 
     <para>
      A partitioned table is divided into sub-tables (called partitions),
      which are created using separate <literal>CREATE TABLE</literal> commands.
      The partitioned table is itself empty.  A data row inserted into the
      table is routed to a partition based on the value of columns or
      expressions in the partition key.  If no existing partition matches
      the values in the new row, an error will be reported.
     </para>
________________________________________________________-->
     <para>
      分区表被分成多个子表（称为分区），它们是使用单独的<literal>CREATE TABLE</literal>命令创建的。
    分区表本身是空的。插入到表中的数据行将根据分区键中的列或表达式的值路由到分区。
    如果没有现有的分区与新行中的值匹配，则会报告错误。
     </para>
<!-- pgdoc-cn_end sig_en=572d8fdd74ed776c44bb3ff3b687e10b -->

<!-- pgdoc-cn_start sig_en=acf4b2ce4d82913e0a97d342901322aa sig_cn_org=None source=14.1 
     <para>
      Partitioned tables do not support <literal>EXCLUDE</literal> constraints;
      however, you can define these constraints on individual partitions.
     </para>
________________________________________________________-->
     <para>
      分区表不支持<literal>EXCLUDE</literal>约束；
      但是，你可以在各个分区上定义这些约束。
     </para>
<!-- pgdoc-cn_end sig_en=acf4b2ce4d82913e0a97d342901322aa -->

<!-- pgdoc-cn_start sig_en=74e99fefa1acc7cdfc845ff3b2b02239 sig_cn_org=None source=14.1 
     <para>
      See <xref linkend="ddl-partitioning"/> for more discussion on table
      partitioning.
     </para>
________________________________________________________-->
     <para>
      有关表分区的更多讨论，请参阅<xref linkend="ddl-partitioning"/>
     </para>
<!-- pgdoc-cn_end sig_en=74e99fefa1acc7cdfc845ff3b2b02239 -->

    </listitem>
   </varlistentry>

   <varlistentry id="sql-createtable-partition">
    <term><literal>PARTITION OF <replaceable class="parameter">parent_table</replaceable> { FOR VALUES <replaceable class="parameter">partition_bound_spec</replaceable> | DEFAULT }</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=f3866b1a8ed0a4bb34188c2a95ae0609 sig_cn_org=None source=14.1 
     <para>
      Creates the table as a <firstterm>partition</firstterm> of the specified
      parent table. The table can be created either as a partition for specific
      values using <literal>FOR VALUES</literal> or as a default partition
      using <literal>DEFAULT</literal>.  Any indexes, constraints and
      user-defined row-level triggers that exist in the parent table are cloned
      on the new partition.
     </para>
________________________________________________________-->
     <para>
      将表创建为指定父表的<firstterm>分区</firstterm>。
      该表建立时，可以使用<literal>FOR VALUES</literal>创建为特定值的分区，
      也可以使用<literal>DEFAULT</literal>创建默认分区。父表中存在的任何索引、
      约束和用户定义的行级触发器都将克隆到新分区上。
     </para>
<!-- pgdoc-cn_end sig_en=f3866b1a8ed0a4bb34188c2a95ae0609 -->

<!-- pgdoc-cn_start sig_en=03be4a8c1cb2ca48a8ccf95e704a5151 sig_cn_org=None source=14.1 
     <para>
      The <replaceable class="parameter">partition_bound_spec</replaceable>
      must correspond to the partitioning method and partition key of the
      parent table, and must not overlap with any existing partition of that
      parent.  The form with <literal>IN</literal> is used for list partitioning,
      the form with <literal>FROM</literal> and <literal>TO</literal> is used
      for range partitioning, and the form with <literal>WITH</literal> is used
      for hash partitioning.
     </para>
________________________________________________________-->
     <para>
      <replaceable class="parameter">partition_bound_spec</replaceable>
    必须对应于父表的分区方法和分区键，并且必须不能与该父表的任何现有分区重叠。
    具有<literal>IN</literal>的形式用于列表分区，
    具有<literal>FROM</literal>和<literal>TO</literal>的形式用于范围分区，
    具有<literal>WITH</literal>的形式用于哈希分区。
     </para>
<!-- pgdoc-cn_end sig_en=03be4a8c1cb2ca48a8ccf95e704a5151 -->

<!-- pgdoc-cn_start sig_en=b3d27e593b191f0ef197351578805818 sig_cn_org=None source=14.1 
     <para>
      <replaceable class="parameter">partition_bound_expr</replaceable> is
      any variable-free expression (subqueries, window functions, aggregate
      functions, and set-returning functions are not allowed).  Its data type
      must match the data type of the corresponding partition key column.
      The expression is evaluated once at table creation time, so it can
      even contain volatile expressions such as
      <literal><function>CURRENT_TIMESTAMP</function></literal>.
     </para>
________________________________________________________-->
     <para>
      <replaceable class="parameter">partition_bound_expr</replaceable>是任何无变量表达式（不允许子查询、窗口函数、聚合函数和集返回函数）。
      它的数据类型必须与相应分区键列的数据类型相匹配。
      表达式在表创建时只计算一次，因此它甚至可以包含易失性表达式，如<literal><function>CURRENT_TIMESTAMP</function></literal>。
     </para>
<!-- pgdoc-cn_end sig_en=b3d27e593b191f0ef197351578805818 -->

<!-- pgdoc-cn_start sig_en=e29b8935aa3d0182214f310fa73043fa sig_cn_org=None source=14.1 
     <para>
      When creating a list partition, <literal>NULL</literal> can be
      specified to signify that the partition allows the partition key
      column to be null.  However, there cannot be more than one such
      list partition for a given parent table.  <literal>NULL</literal>
      cannot be specified for range partitions.
     </para>
________________________________________________________-->
     <para>
      在创建列表分区时，可以指定<literal>NULL</literal>来表示分区允许分区键列为空。
    但是，给定父表不能有多于一个这样的列表分区。无法为范围分区指定
    <literal>NULL</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=e29b8935aa3d0182214f310fa73043fa -->

<!-- pgdoc-cn_start sig_en=b3327df71edc8f383b6d62f19ecd6453 sig_cn_org=None source=14.1 
     <para>
      When creating a range partition, the lower bound specified with
      <literal>FROM</literal> is an inclusive bound, whereas the upper
      bound specified with <literal>TO</literal> is an exclusive bound.
      That is, the values specified in the <literal>FROM</literal> list
      are valid values of the corresponding partition key columns for this
      partition, whereas those in the <literal>TO</literal> list are
      not.  Note that this statement must be understood according to the
      rules of row-wise comparison (<xref linkend="row-wise-comparison"/>).
      For example, given <literal>PARTITION BY RANGE (x,y)</literal>, a partition
      bound <literal>FROM (1, 2) TO (3, 4)</literal>
      allows <literal>x=1</literal> with any <literal>y&gt;=2</literal>,
      <literal>x=2</literal> with any non-null <literal>y</literal>,
      and <literal>x=3</literal> with any <literal>y&lt;4</literal>.
     </para>
________________________________________________________-->
     <para>
      创建范围分区时，由<literal>FROM</literal>指定的下限是一个包含范围，
    而用<literal>TO</literal>指定的上限是排除范围。也就是说，
    在<literal>FROM</literal>列表中指定的值是该分区的相应分区键列的有效值，
    而<literal>TO</literal>列表中的值不是。请注意，
    必须根据按行比较的规则来理解此语句（<xref linkend="row-wise-comparison"/>）。
    例如，给定<literal>PARTITION BY RANGE (x,y)</literal>，分区范围
    <literal>FROM (1, 2) TO (3, 4)</literal>允许<literal>x=1</literal>与任何<literal>y&gt;=2</literal>，
    <literal>x=2</literal>与任何非空<literal>y</literal>，和<literal>x=3</literal>与任何<literal>y&lt;4</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=b3327df71edc8f383b6d62f19ecd6453 -->

<!-- pgdoc-cn_start sig_en=99a4396c42a5f7185b1d53d08c353459 sig_cn_org=None source=14.1 
     <para>
      The special values <literal>MINVALUE</literal> and <literal>MAXVALUE</literal>
      may be used when creating a range partition to indicate that there
      is no lower or upper bound on the column's value. For example, a
      partition defined using <literal>FROM (MINVALUE) TO (10)</literal> allows
      any values less than 10, and a partition defined using
      <literal>FROM (10) TO (MAXVALUE)</literal> allows any values greater than
      or equal to 10.
     </para>
________________________________________________________-->
     <para>
      在创建范围分区以指示列值没有下限或上限时，可以使用特殊值<literal>MINVALUE</literal>
    和<literal>MAXVALUE</literal>。例如，使用<literal>FROM (MINVALUE) TO (10)</literal>
    定义的分区允许任何小于10的值，并且使用<literal>FROM (10) TO (MAXVALUE)</literal>
    定义的分区允许任何大于或等于10的值。
     </para>
<!-- pgdoc-cn_end sig_en=99a4396c42a5f7185b1d53d08c353459 -->

<!-- pgdoc-cn_start sig_en=4babe645e9920ba9b3bb9be52d078062 sig_cn_org=None source=14.1 
     <para>
      When creating a range partition involving more than one column, it
      can also make sense to use <literal>MAXVALUE</literal> as part of the lower
      bound, and <literal>MINVALUE</literal> as part of the upper bound. For
      example, a partition defined using
      <literal>FROM (0, MAXVALUE) TO (10, MAXVALUE)</literal> allows any rows
      where the first partition key column is greater than 0 and less than
      or equal to 10. Similarly, a partition defined using
      <literal>FROM ('a', MINVALUE) TO ('b', MINVALUE)</literal> allows any rows
      where the first partition key column starts with "a".
     </para>
________________________________________________________-->
     <para>
      创建涉及多个列的范围分区时，将<literal>MAXVALUE</literal>作为下限的一部分并将
    <literal>MINVALUE</literal>作为上限的一部分也是有意义的。例如，使用
    <literal>FROM (0, MAXVALUE) TO (10, MAXVALUE)</literal>
    定义的分区允许第一个分区键列大于0且小于或等于10的任何行。类似地，
    使用<literal>FROM ('a', MINVALUE) TO ('b', MINVALUE)</literal>定义的分区
    允许第一个分区键列以"a"开头的任何行。
     </para>
<!-- pgdoc-cn_end sig_en=4babe645e9920ba9b3bb9be52d078062 -->

<!-- pgdoc-cn_start sig_en=2a68196a8993581e911bbf326d4380ff sig_cn_org=None source=14.1 
     <para>
      Note that if <literal>MINVALUE</literal> or <literal>MAXVALUE</literal> is used for
      one column of a partitioning bound, the same value must be used for all
      subsequent columns.  For example, <literal>(10, MINVALUE, 0)</literal> is not
      a valid bound; you should write <literal>(10, MINVALUE, MINVALUE)</literal>.
     </para>
________________________________________________________-->
     <para>
      请注意，如果<literal>MINVALUE</literal>或<literal>MAXVALUE</literal>用于分区边界的一列，
    则必须为所有后续列使用相同的值。例如，<literal>(10, MINVALUE, 0)</literal>
    不是有效的边界；你应该写<literal>(10, MINVALUE, MINVALUE)</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=2a68196a8993581e911bbf326d4380ff -->

<!-- pgdoc-cn_start sig_en=c66b62c3ee7d4cf79ce5a90d412df567 sig_cn_org=None source=14.1 
     <para>
      Also note that some element types, such as <literal>timestamp</literal>,
      have a notion of "infinity", which is just another value that can
      be stored. This is different from <literal>MINVALUE</literal> and
      <literal>MAXVALUE</literal>, which are not real values that can be stored,
      but rather they are ways of saying that the value is unbounded.
      <literal>MAXVALUE</literal> can be thought of as being greater than any
      other value, including "infinity" and <literal>MINVALUE</literal> as being
      less than any other value, including "minus infinity". Thus the range
      <literal>FROM ('infinity') TO (MAXVALUE)</literal> is not an empty range; it
      allows precisely one value to be stored &mdash; "infinity".
     </para>
________________________________________________________-->
     <para>
      还要注意，某些元素类型，如<literal>timestamp</literal>，具有“无穷”的概念，
    这只是另一个可以存储的值。这与<literal>MINVALUE</literal>和<literal>MAXVALUE</literal>不同，
    它们不是可以存储的实际值，而是它们表示值无界的方式。<literal>MAXVALUE</literal> 
    可以被认为比任何其他值（包括“无穷”）都大的值，<literal>MINVALUE</literal>
    可以被认为是比任何其他值（包括“负无穷”）都小的值。因此，
    范围<literal>FROM ('infinity') TO (MAXVALUE)</literal>不是空的范围；
    它只允许存储一个值&mdash; "infinity"。
     </para>
<!-- pgdoc-cn_end sig_en=c66b62c3ee7d4cf79ce5a90d412df567 -->

<!-- pgdoc-cn_start sig_en=f73fb4e95be53fdad932fe8126fa52fd sig_cn_org=None source=14.1 
     <para>
      If <literal>DEFAULT</literal> is specified, the table will be
      created as the default partition of the parent table.  This option
      is not available for hash-partitioned tables.  A partition key value
      not fitting into any other partition of the given parent will be
      routed to the default partition.
     </para>
________________________________________________________-->
     <para>
      如果指定了<literal>DEFAULT</literal>，则表将创建为父表的默认分区。此选项不适用于哈希分区表。
      不适合给定父级表的任何其他分区的分区键值将路由到默认分区。
     </para>
<!-- pgdoc-cn_end sig_en=f73fb4e95be53fdad932fe8126fa52fd -->

<!-- pgdoc-cn_start sig_en=ef5e89a7ef8649459cf98c0e49aafb79 sig_cn_org=None source=14.1 
     <para>
      When a table has an existing <literal>DEFAULT</literal> partition and
      a new partition is added to it, the default partition must
      be scanned to verify that it does not contain any rows which properly
      belong in the new partition.  If the default partition contains a
      large number of rows, this may be slow.  The scan will be skipped if
      the default partition is a foreign table or if it has a constraint which
      proves that it cannot contain rows which should be placed in the new
      partition.
     </para>
________________________________________________________-->
     <para>
      当一个表已有<literal>DEFAULT</literal> 分区并且要对它添加新分区时，
      必须扫描默认分区以验证它不包含可能属于新分区的任何行。 
      如果默认分区包含大量行，则速度可能会很慢。
      如果默认分区是外表或者它具有可证明的不可能包含能放置在新分区中的行的约束，则将略过扫描   
     </para>
<!-- pgdoc-cn_end sig_en=ef5e89a7ef8649459cf98c0e49aafb79 -->

<!-- pgdoc-cn_start sig_en=c2caa0acb98da01ad6d8c615a46ef091 sig_cn_org=None source=14.1 
     <para>
      When creating a hash partition, a modulus and remainder must be specified.
      The modulus must be a positive integer, and the remainder must be a
      non-negative integer less than the modulus.  Typically, when initially
      setting up a hash-partitioned table, you should choose a modulus equal to
      the number of partitions and assign every table the same modulus and a
      different remainder (see examples, below).   However, it is not required
      that every partition have the same modulus, only that every modulus which
      occurs among the partitions of a hash-partitioned table is a factor of the
      next larger modulus.  This allows the number of partitions to be increased
      incrementally without needing to move all the data at once.  For example,
      suppose you have a hash-partitioned table with 8 partitions, each of which
      has modulus 8, but find it necessary to increase the number of partitions
      to 16.  You can detach one of the modulus-8 partitions, create two new
      modulus-16 partitions covering the same portion of the key space (one with
      a remainder equal to the remainder of the detached partition, and the
      other with a remainder equal to that value plus 8), and repopulate them
      with data.  You can then repeat this -&minus; perhaps at a later time -&minus; for
      each modulus-8 partition until none remain.  While this may still involve
      a large amount of data movement at each step, it is still better than
      having to create a whole new table and move all the data at once.
     </para>
________________________________________________________-->
     <para>
      当创建哈希分区时，必须指定模数和余数。
    模数必须是正整数，余数必须是小于模数的非负整数。
    通常情况下，当初始设置哈希分区表时，应选择一个与分区数相等的模数，并为每个表分配相同的模数和不同的余数（请参阅下方示例）。
    不过，并不要求每个分区都具有相同的模数，只要求哈希分区表里面的分区中出现的每个模数都是下一个较大模数的因数。
    这允许以增量的方式增加分区数量而不需要一次移动所有数据。
    例如，假设你有一个包含 8 个分区的哈希分区表，每个分区有模数8，但发现有必要将分区数增加到 16 个。
    您可以拆分其中一个模数-8分区，然后创建两个新的模数-16分区来覆盖键空间的相同部分（一个的余数等于被拆分的分区的余数，另一个的余数等于该值加 8），而后用数据重新填充他们。
    然后，你可以对每一个余数-8分区重复此操作过程，直到没有剩余。
    虽然这其中的每个步骤都可能会导致大量的数据移动操作，它仍然要好于建一个全新的表并一次移动全部数据。
     </para>
<!-- pgdoc-cn_end sig_en=c2caa0acb98da01ad6d8c615a46ef091 -->

<!-- pgdoc-cn_start sig_en=fa91ae7cbd12cae2ebc296943d9cd6a2 sig_cn_org=None source=14.1 
     <para>
      A partition must have the same column names and types as the partitioned
      table to which it belongs. Modifications to the column names or types of
      a partitioned table will automatically propagate to all partitions.
      <literal>CHECK</literal> constraints will be inherited automatically by
      every partition, but an individual partition may specify additional
      <literal>CHECK</literal> constraints; additional constraints with the
      same name and condition as in the parent will be merged with the parent
      constraint.  Defaults may be specified separately for each partition.
      But note that a partition's default value is not applied when inserting
      a tuple through a partitioned table.
     </para>
________________________________________________________-->
     <para>
      分区必须与其所属的分区表的字段名和类型相同。
      对分区表字段名或类型的修改，将自动传播到所有分区。
      <literal>CHECK</literal>约束将自动被每一个分区继承，但是单独的分区可以指定额外的<literal>CHECK</literal>约束；与父表相同名称和条件的额外约束将被父表约束合并。
      可以为每个分区分别指定默认值。但是请注意，在通过分区表插入元组时不会应用分区的默认值。
     </para>
<!-- pgdoc-cn_end sig_en=fa91ae7cbd12cae2ebc296943d9cd6a2 -->

<!-- pgdoc-cn_start sig_en=f80ce9ae540cbe8f53cc1204abf9d330 sig_cn_org=None source=14.1 
     <para>
      Rows inserted into a partitioned table will be automatically routed to
      the correct partition.  If no suitable partition exists, an error will
      occur.
     </para>
________________________________________________________-->
     <para>
      插入分区表中的行将自动路由到正确的分区。如果不存在合适的分区，则会发生错误。
     </para>
<!-- pgdoc-cn_end sig_en=f80ce9ae540cbe8f53cc1204abf9d330 -->

<!-- pgdoc-cn_start sig_en=4cf93977e6c5fd8f58792f855f6f7b27 sig_cn_org=121101db3e053e19cc9bb042d82745b4 source=15.7 
     <para>
      Operations such as <command>TRUNCATE</command>
      which normally affect a table and all of its
      inheritance children will cascade to all partitions, but may also be
      performed on an individual partition.
     </para>
________________________________________________________-->
     <para>
      操作，如<command>TRUNCATE</command>通常会影响表及其所有继承子代，将会级联到所有分区，但也可以在单个分区上执行。
     </para>
<!-- pgdoc-cn_end sig_en=4cf93977e6c5fd8f58792f855f6f7b27 -->

<!-- pgdoc-cn_start sig_en=d4c79b5ed28a25e8126e343ad241eb74 sig_cn_org=9eef3d3ec00a8e67befac70603d00779 source=15.7 
     <para>
      Note that creating a partition using <literal>PARTITION OF</literal>
      requires taking an <literal>ACCESS EXCLUSIVE</literal> lock on the
      parent partitioned table.  Likewise, dropping a partition
      with <command>DROP TABLE</command> requires taking
      an <literal>ACCESS EXCLUSIVE</literal> lock on the parent table.
      It is possible to use <link linkend="sql-altertable"><command>ALTER
      TABLE ATTACH/DETACH PARTITION</command></link> to perform these
      operations with a weaker lock, thus reducing interference with
      concurrent operations on the partitioned table.
     </para>
________________________________________________________-->
     <para>
      注意，使用<literal>PARTITION OF</literal>创建分区需要在父分区表上获取一个<literal>ACCESS EXCLUSIVE</literal>锁。
      同样，使用<command>DROP TABLE</command>删除分区需要在父表上获取一个<literal>ACCESS EXCLUSIVE</literal>锁。
      可以使用<link linkend="sql-altertable"><command>ALTER TABLE ATTACH/DETACH PARTITION</command></link>来执行这些操作，使用更弱的锁，从而减少对分区表上并发操作的干扰。
     </para>
<!-- pgdoc-cn_end sig_en=d4c79b5ed28a25e8126e343ad241eb74 -->

    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>LIKE <replaceable>source_table</replaceable> [ <replaceable>like_option</replaceable> ... ]</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=3d45ac2eb4d573186069e82e6c2a7ef6 sig_cn_org=None source=14.1 
     <para>
      The <literal>LIKE</literal> clause specifies a table from which
      the new table automatically copies all column names, their data types,
      and their not-null constraints.
     </para>
________________________________________________________-->
     <para>
      <literal>LIKE</literal>指定新表将从哪一个表自动地复制所有的列名、数据类型以及它们的非空约束。
     </para>
<!-- pgdoc-cn_end sig_en=3d45ac2eb4d573186069e82e6c2a7ef6 -->
<!-- pgdoc-cn_start sig_en=35cfcf08b4d8aa12aaf040e8762b0a6a sig_cn_org=None source=14.1 
     <para>
      Unlike <literal>INHERITS</literal>, the new table and original table
      are completely decoupled after creation is complete.  Changes to the
      original table will not be applied to the new table, and it is not
      possible to include data of the new table in scans of the original
      table.
     </para>
________________________________________________________-->
     <para>
      和<literal>INHERITS</literal>不同，新表和原始表在创建完成之后是完全分离的。对原始表的更改将不会被应用到新表，并且不可能在原始表的扫描中包括新表的数据。
     </para>
<!-- pgdoc-cn_end sig_en=35cfcf08b4d8aa12aaf040e8762b0a6a -->
<!-- pgdoc-cn_start sig_en=e861c74f494f02bd4935c9f67df84db5 sig_cn_org=None source=14.1 
      <para>
      Also unlike <literal>INHERITS</literal>, columns and
      constraints copied by <literal>LIKE</literal> are not merged with similarly
      named columns and constraints.
      If the same name is specified explicitly or in another
      <literal>LIKE</literal> clause, an error is signaled.
     </para>
________________________________________________________-->
      <para>
      同样与<literal>INHERITS</literal>不同，用<literal>LIKE</literal>拷贝的列和约束不会和相似的命名列及约束融合。如果显式指定了相同的名称或者在另一个<literal>LIKE</literal>子句中指定了相同的名称，将会发出一个错误。
     </para>
<!-- pgdoc-cn_end sig_en=e861c74f494f02bd4935c9f67df84db5 -->
<!-- pgdoc-cn_start sig_en=95b4abb62c59f6dda67d62e9a0b829e4 sig_cn_org=None source=14.1 
     <para>
      The optional <replaceable>like_option</replaceable> clauses specify
      which additional properties of the original table to copy.  Specifying
      <literal>INCLUDING</literal> copies the property, specifying
      <literal>EXCLUDING</literal> omits the property.
      <literal>EXCLUDING</literal> is the default.  If multiple specifications
      are made for the same kind of object, the last one is used.  The
      available options are:

      <variablelist>
       <varlistentry>
        <term><literal>INCLUDING COMMENTS</literal></term>
        <listitem>
         <para>
          Comments for the copied columns, constraints, and indexes will be
          copied.  The default behavior is to exclude comments, resulting in
          the copied columns and constraints in the new table having no
          comments.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING COMPRESSION</literal></term>
        <listitem>
         <para>
          Compression method of the columns will be copied.  The default
          behavior is to exclude compression methods, resulting in columns
          having the default compression method.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING CONSTRAINTS</literal></term>
        <listitem>
         <para>
          <literal>CHECK</literal> constraints will be copied.  No distinction
          is made between column constraints and table constraints.  Not-null
          constraints are always copied to the new table.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING DEFAULTS</literal></term>
        <listitem>
         <para>
          Default expressions for the copied column definitions will be
          copied.  Otherwise, default expressions are not copied, resulting in
          the copied columns in the new table having null defaults.  Note that
          copying defaults that call database-modification functions, such as
          <function>nextval</function>, may create a functional linkage
          between the original and new tables.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING GENERATED</literal></term>
        <listitem>
         <para>
          Any generation expressions of copied column definitions will be
          copied.  By default, new columns will be regular base columns.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING IDENTITY</literal></term>
        <listitem>
         <para>
          Any identity specifications of copied column definitions will be
          copied.  A new sequence is created for each identity column of the
          new table, separate from the sequences associated with the old
          table.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING INDEXES</literal></term>
        <listitem>
         <para>
          Indexes, <literal>PRIMARY KEY</literal>, <literal>UNIQUE</literal>,
          and <literal>EXCLUDE</literal> constraints on the original table
          will be created on the new table.  Names for the new indexes and
          constraints are chosen according to the default rules, regardless of
          how the originals were named.  (This behavior avoids possible
          duplicate-name failures for the new indexes.)
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING STATISTICS</literal></term>
        <listitem>
         <para>
          Extended statistics are copied to the new table.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING STORAGE</literal></term>
        <listitem>
         <para>
          <literal>STORAGE</literal> settings for the copied column
          definitions will be copied.  The default behavior is to exclude
          <literal>STORAGE</literal> settings, resulting in the copied columns
          in the new table having type-specific default settings.  For more on
          <literal>STORAGE</literal> settings, see <xref
          linkend="storage-toast"/>.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING ALL</literal></term>
        <listitem>
         <para>
          <literal>INCLUDING ALL</literal> is an abbreviated form selecting
          all the available individual options.  (It could be useful to write
          individual <literal>EXCLUDING</literal> clauses after
          <literal>INCLUDING ALL</literal> to select all but some specific
          options.)
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
________________________________________________________-->
     <para>
      可选的<replaceable>like_option</replaceable>子句指定要复制的原始表的附加属性。
      指定 <literal>INCLUDING</literal> 复制该属性, 指定 <literal>EXCLUDING</literal> 忽略该属性。<literal>EXCLUDING</literal>为默认值。
      如果对同一类型的对象指定了多个规范，则使用最后一个规范。可用的选项包括：

      <variablelist>
       <varlistentry>
        <term><literal>INCLUDING COMMENTS</literal></term>
        <listitem>
         <para>
          复制的列、约束和索引的注释将被复制。默认行为是去除注释，从而导致新表中复制的列和约束没有注释。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING COMPRESSION</literal></term>
        <listitem>
         <para>
          列的压缩方法将被拷贝。
          默认行为是去除压缩方法，使得列采用默认压缩方法。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING CONSTRAINTS</literal></term>
        <listitem>
         <para>
          <literal>CHECK</literal>约束将被复制。 列约束和表约束之间没有区别。非空约束始终复制到新表。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING DEFAULTS</literal></term>
        <listitem>
         <para>
          复制列定义的默认表达式将被复制。否则，不会复制默认表达式，从而导致新表中复制的列具有空默认值。
          注意，复制调用数据库修改函数的默认值，例如<function>nextval</function>，可能在原始表和新表之间创建功能联系。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING GENERATED</literal></term>
        <listitem>
         <para>
          列定义的任何生成表达式将被复制。 默认情况下，新列将是常规基本列。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING IDENTITY</literal></term>
        <listitem>
         <para>
          已复制列定义的任何标识规范都将被复制。为新表的每个标识列创建一个新序列，与与旧表关联的序列分开。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING INDEXES</literal></term>
        <listitem>
         <para>
          原始表上的索引、<literal>PRIMARY KEY</literal>、 <literal>UNIQUE</literal>和 <literal>EXCLUDE</literal>约束将被建立在新表上。
          根据默认规则选择新索引和约束的名称，而不考虑原始的命名。（此行为可避免新索引可能出现重复名称失败。）
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING STATISTICS</literal></term>
        <listitem>
         <para>
          扩展统计信息将复制到新表。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING STORAGE</literal></term>
        <listitem>
         <para>
          已复制列定义的<literal>STORAGE</literal>设置将被复制。
          默认行为是排除<literal>STORAGE</literal>设置，从而导致新表中已复制列具有类型规定的默认设置。 
          关于<literal>STORAGE</literal>设置的更多信息，参见<xref linkend="storage-toast"/>。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>INCLUDING ALL</literal></term>
        <listitem>
         <para>
          <literal>INCLUDING ALL</literal> 是选择所有可用的单独选项的缩写形式。
          （它能被用于在<literal>INCLUDING ALL</literal>之后写单独的<literal>EXCLUDING</literal>子句，以选择部分指定选项之外的所有选项。）
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
<!-- pgdoc-cn_end sig_en=95b4abb62c59f6dda67d62e9a0b829e4 -->

<!-- pgdoc-cn_start sig_en=4f0f84e1e64d1283aa5fc03a041cb360 sig_cn_org=None source=14.1 
     <para>
      The <literal>LIKE</literal> clause can also be used to copy column
      definitions from views, foreign tables, or composite types.
      Inapplicable options (e.g., <literal>INCLUDING INDEXES</literal> from
      a view) are ignored.
     </para>
________________________________________________________-->
     <para>
      <literal>LIKE</literal>子句也能被用来从视图、外部表或组合类型拷贝列定义。不适合的选项（例如来自视图的<literal>INCLUDING INDEXES</literal>）会被忽略。
     </para>
<!-- pgdoc-cn_end sig_en=4f0f84e1e64d1283aa5fc03a041cb360 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CONSTRAINT <replaceable class="parameter">constraint_name</replaceable></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=70946fb60dbdfd395aefa5ffc4397182 sig_cn_org=None source=14.1 
     <para>
      An optional name for a column or table constraint.  If the
      constraint is violated, the constraint name is present in error messages,
      so constraint names like <literal>col must be positive</literal> can be used
      to communicate helpful constraint information to client applications.
      (Double-quotes are needed to specify constraint names that contain spaces.)
      If a constraint name is not specified, the system generates a name.
     </para>
________________________________________________________-->
     <para>
      一个列约束或表约束的可选名称。如果该约束被违背，约束名将会出现在错误消息中，这样类似<literal>列必须为正</literal>的约束名可以用来与客户端应用沟通有用的约束信息（指定包含空格的约束名时需要用到双引号）。如果没有指定约束名，系统将生成一个。
     </para>
<!-- pgdoc-cn_end sig_en=70946fb60dbdfd395aefa5ffc4397182 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NOT NULL</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=00d37bc36172cb3150a654b82a336661 sig_cn_org=None source=14.1 
     <para>
      The column is not allowed to contain null values.
     </para>
________________________________________________________-->
     <para>
      该列不允许包含空值。
     </para>
<!-- pgdoc-cn_end sig_en=00d37bc36172cb3150a654b82a336661 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>NULL</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=9ce7b4fd206dfcace8810b0a0cb21442 sig_cn_org=None source=14.1 
     <para>
      The column is allowed to contain null values. This is the default.
     </para>
________________________________________________________-->
     <para>
      该列允许包含空值。这是默认情况。
     </para>
<!-- pgdoc-cn_end sig_en=9ce7b4fd206dfcace8810b0a0cb21442 -->

<!-- pgdoc-cn_start sig_en=7a0bd5fe66fb977ac9c3da28718380e1 sig_cn_org=None source=14.1 
     <para>
      This clause is only provided for compatibility with
      non-standard SQL databases.  Its use is discouraged in new
      applications.
     </para>
________________________________________________________-->
     <para>
      这个子句只是提供与非标准 SQL 数据库的兼容。在新的应用中不推荐使用。
     </para>
<!-- pgdoc-cn_end sig_en=7a0bd5fe66fb977ac9c3da28718380e1 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CHECK ( <replaceable class="parameter">expression</replaceable> ) [ NO INHERIT ] </literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=43050bc040cf186165104b06b084714c sig_cn_org=None source=14.1 
     <para>
      The <literal>CHECK</literal> clause specifies an expression producing a
      Boolean result which new or updated rows must satisfy for an
      insert or update operation to succeed.  Expressions evaluating
      to TRUE or UNKNOWN succeed.  Should any row of an insert or
      update operation produce a FALSE result, an error exception is
      raised and the insert or update does not alter the database.  A
      check constraint specified as a column constraint should
      reference that column's value only, while an expression
      appearing in a table constraint can reference multiple columns.
     </para>
________________________________________________________-->
     <para>
      <literal>CHECK</literal>指定一个产生布尔结果的表达式，一个插入或更新操作要想成功，其中新的或被更新的行必须满足该表达式。计算出 TRUE 或 UNKNOWN 的表达式就会成功。只要任何一个插入或更新操作的行产生了 FALSE 结果，将报告一个错误异常并且插入或更新不会修改数据库。一个被作为列约束指定的检查约束只应该引用该列的值，而一个出现在表约束中的表达式可以引用多列。
     </para>
<!-- pgdoc-cn_end sig_en=43050bc040cf186165104b06b084714c -->

<!-- pgdoc-cn_start sig_en=a88fd2391fcb3f2c872c8bf504321713 sig_cn_org=None source=14.1 
     <para>
      Currently, <literal>CHECK</literal> expressions cannot contain
      subqueries nor refer to variables other than columns of the
      current row (see <xref linkend="ddl-constraints-check-constraints"/>).
      The system column <literal>tableoid</literal>
      may be referenced, but not any other system column.
     </para>
________________________________________________________-->
     <para>
      当前，<literal>CHECK</literal>表达式不能包含子查询，也不能引用当前行的列之外的变量（参见 <xref linkend="ddl-constraints-check-constraints"/>）。可以引用系统列<literal>tableoid</literal>，但不能引用其他系统列。
     </para>
<!-- pgdoc-cn_end sig_en=a88fd2391fcb3f2c872c8bf504321713 -->

<!-- pgdoc-cn_start sig_en=1d3cfedec04b7f0aeaf89c9a09063955 sig_cn_org=None source=14.1 
     <para>
      A constraint marked with <literal>NO INHERIT</literal> will not propagate to
      child tables.
     </para>
________________________________________________________-->
     <para>
      一个被标记为<literal>NO INHERIT</literal>的约束将不会传播到子表。
     </para>
<!-- pgdoc-cn_end sig_en=1d3cfedec04b7f0aeaf89c9a09063955 -->

<!-- pgdoc-cn_start sig_en=de0232badad372c0745832c8aff0604b sig_cn_org=None source=14.1 
     <para>
      When a table has multiple <literal>CHECK</literal> constraints,
      they will be tested for each row in alphabetical order by name,
      after checking <literal>NOT NULL</literal> constraints.
      (<productname>PostgreSQL</productname> versions before 9.5 did not honor any
      particular firing order for <literal>CHECK</literal> constraints.)
     </para>
________________________________________________________-->
     <para>
      当一个表有多个<literal>CHECK</literal>约束时，检查完<literal>NOT NULL</literal>约束后，对于每一行会以它们名称的字母表顺序来进行检查（版本 9.5 之前的<productname>PostgreSQL</productname>对于<literal>CHECK</literal>约束不遵从任何特定的引发顺序）。
     </para>
<!-- pgdoc-cn_end sig_en=de0232badad372c0745832c8aff0604b -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFAULT
    <replaceable>default_expr</replaceable></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=2db497f0a3dfdbea52a58cd2f803e86c sig_cn_org=None source=14.1 
     <para>
      The <literal>DEFAULT</literal> clause assigns a default data value for
      the column whose column definition it appears within.  The value
      is any variable-free expression (in particular, cross-references
      to other columns in the current table are not allowed).  Subqueries
      are not allowed either.  The data type of the default expression must
      match the data type of the column.
     </para>
________________________________________________________-->
     <para>
      <literal>DEFAULT</literal>子句为出现在其定义中的列赋予一个默认数据。该值是可以使用变量的表达式（特别是，不允许用对其他列的交叉引用）。子查询也是不允许的。
      默认值表达式的数据类型必须匹配列的数据类型。
     </para>
<!-- pgdoc-cn_end sig_en=2db497f0a3dfdbea52a58cd2f803e86c -->

<!-- pgdoc-cn_start sig_en=f98e17b690c6d55a408e1963a5fd9f38 sig_cn_org=None source=14.1 
     <para>
      The default expression will be used in any insert operation that
      does not specify a value for the column.  If there is no default
      for a column, then the default is null.
     </para>
________________________________________________________-->
     <para>
      默认值表达式将被用在任何没有为该列指定值的插入操作中。如果一列没有默认值，那么默认值为空值。
     </para>
<!-- pgdoc-cn_end sig_en=f98e17b690c6d55a408e1963a5fd9f38 -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=c14062d006c7ec19efa2c58ee41ca504 sig_cn_org=None source=14.1 
    <term><literal>GENERATED ALWAYS AS ( <replaceable>generation_expr</replaceable> ) STORED</literal><indexterm><primary>generated column</primary></indexterm></term>
________________________________________________________-->
    <term><literal>GENERATED ALWAYS AS ( <replaceable>generation_expr</replaceable> ) STORED</literal><indexterm><primary>generated column</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=c14062d006c7ec19efa2c58ee41ca504 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=6d2f46f4bba89bbeb2a5155cfc8112ce sig_cn_org=None source=14.1 
     <para>
      This clause creates the column as a <firstterm>generated
      column</firstterm>.  The column cannot be written to, and when read the
      result of the specified expression will be returned.
     </para>
________________________________________________________-->
     <para>
      此子句将列创建为<firstterm>generated column</firstterm>。 列无法被写入，读取时将返回指定表达式的结果。
     </para>
<!-- pgdoc-cn_end sig_en=6d2f46f4bba89bbeb2a5155cfc8112ce -->

<!-- pgdoc-cn_start sig_en=fe9c820c69f8d24f5b03014c3a47ade5 sig_cn_org=None source=14.1 
     <para>
      The keyword <literal>STORED</literal> is required to signify that the
      column will be computed on write and will be stored on disk.
     </para>
________________________________________________________-->
     <para>
      关键字<literal>STORED</literal>表示将在写入时计算列并将存储在磁盘上。
     </para>
<!-- pgdoc-cn_end sig_en=fe9c820c69f8d24f5b03014c3a47ade5 -->

<!-- pgdoc-cn_start sig_en=93273596f2ef247a8316beb0884b50e3 sig_cn_org=None source=14.1 
     <para>
      The generation expression can refer to other columns in the table, but
      not other generated columns.  Any functions and operators used must be
      immutable.  References to other tables are not allowed.
     </para>
________________________________________________________-->
     <para>
      生成表达式可以引用表中的其他列，但不能引用其他生成的列。使用的任何函数和运算符都必须是不可改变的。不允许引用其他表。
     </para>
<!-- pgdoc-cn_end sig_en=93273596f2ef247a8316beb0884b50e3 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <replaceable>sequence_options</replaceable> ) ]</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=622dae90a300b3f82b20c65f221a7ad7 sig_cn_org=None source=14.1 
     <para>
      This clause creates the column as an <firstterm>identity
      column</firstterm>.  It will have an implicit sequence attached to it
      and the column in new rows will automatically have values from the
      sequence assigned to it.
      Such a column is implicitly <literal>NOT NULL</literal>.
     </para>
________________________________________________________-->
     <para>
      该子句将列创建为<firstterm>标识列</firstterm>。
      它将拥有一个隐式序列附加到它，并且新行中的列将自动从分配给它的序列中获取值。
      这样的列为隐式<literal>NOT NULL</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=622dae90a300b3f82b20c65f221a7ad7 -->

<!-- pgdoc-cn_start sig_en=c4ae5a653e6d95b7615b06481fb36e24 sig_cn_org=None source=14.1 
     <para>
      The clauses <literal>ALWAYS</literal> and <literal>BY DEFAULT</literal>
      determine how explicitly user-specified values are handled in
      <command>INSERT</command> and <command>UPDATE</command> commands.
     </para>
________________________________________________________-->
     <para>
      子句<literal>ALWAYS</literal>和<literal>BY DEFAULT</literal>确定如何在
      <command>INSERT</command>和<command>UPDATE</command>命令中明确处理用户指定的值。
     </para>
<!-- pgdoc-cn_end sig_en=c4ae5a653e6d95b7615b06481fb36e24 -->

<!-- pgdoc-cn_start sig_en=96222b23fd2385820da2ca8a43b13d0e sig_cn_org=None source=14.1 
     <para>
      In an <command>INSERT</command> command, if <literal>ALWAYS</literal> is
      selected, a user-specified value is only accepted if the
      <command>INSERT</command> statement specifies <literal>OVERRIDING SYSTEM
      VALUE</literal>.  If <literal>BY DEFAULT</literal> is selected, then the
      user-specified value takes precedence.  See <xref linkend="sql-insert"/>
      for details.  (In the <command>COPY</command> command, user-specified
      values are always used regardless of this setting.)
     </para>
________________________________________________________-->
     <para>
      在<command>INSERT</command>命令中，如果选择了<literal>ALWAYS</literal>，则仅当
      <command>INSERT</command> 语句指定<literal>OVERRIDING SYSTEM VALUE</literal>时
      才接受用户指定的值。如果选择<literal>BY DEFAULT</literal>，则用户指定的值优先。
      有关详细信息，请参阅<xref linkend="sql-insert"/>。（在<command>COPY</command>命令中，
      无论此设置如何，始终使用用户指定的值。）
     </para>
<!-- pgdoc-cn_end sig_en=96222b23fd2385820da2ca8a43b13d0e -->

<!-- pgdoc-cn_start sig_en=14958f76666b6fc5f9774de444925283 sig_cn_org=None source=14.1 
     <para>
      In an <command>UPDATE</command> command, if <literal>ALWAYS</literal> is
      selected, any update of the column to any value other than
      <literal>DEFAULT</literal> will be rejected.  If <literal>BY
      DEFAULT</literal> is selected, the column can be updated normally.
      (There is no <literal>OVERRIDING</literal> clause for the
      <command>UPDATE</command> command.)
     </para>
________________________________________________________-->
     <para>
      在<command>UPDATE</command>命令中，如果选择了<literal>ALWAYS</literal>，
      则将列更新为除<literal>DEFAULT</literal>之外的任何值都将被拒绝。
      如果选择<literal>BY DEFAULT</literal>，则该列可以正常更新。
      （<command>UPDATE</command>命令没有<literal>OVERRIDING</literal>子句。）
     </para>
<!-- pgdoc-cn_end sig_en=14958f76666b6fc5f9774de444925283 -->

<!-- pgdoc-cn_start sig_en=be701f5d3327319b59d24ecb06ba4e57 sig_cn_org=None source=14.1 
     <para>
      The optional <replaceable>sequence_options</replaceable> clause can be
      used to override the options of the sequence.
      See <xref linkend="sql-createsequence"/> for details.
     </para>
________________________________________________________-->
     <para>
      可选的<replaceable>sequence_options</replaceable>子句可用于覆盖序列的选项。
    有关详细信息，请参见<xref linkend="sql-createsequence"/>。
     </para>
<!-- pgdoc-cn_end sig_en=be701f5d3327319b59d24ecb06ba4e57 -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=c61eba96da88d2d9682fbc8dc9e60916 sig_cn_org=f88a96dcb0f2f88296f9cbaab9d696e7 source=15.7 
    <term><literal>UNIQUE [ NULLS [ NOT ] DISTINCT ]</literal> (column constraint)</term>
________________________________________________________-->
    <term><literal>UNIQUE [ NULLS [ NOT ] DISTINCT ]</literal> (column constraint)</term>
<!-- pgdoc-cn_end sig_en=c61eba96da88d2d9682fbc8dc9e60916 -->
<!-- pgdoc-cn_start sig_en=89aac4ea4c052db150b599efd7437db8 sig_cn_org=f31f131aa465de3863c09ab686e7f3f3 source=15.7 
    <term><literal>UNIQUE [ NULLS [ NOT ] DISTINCT ] ( <replaceable class="parameter">column_name</replaceable> [, ... ] )</literal>
    <optional> <literal>INCLUDE ( <replaceable class="parameter">column_name</replaceable> [, ...])</literal> </optional> (table constraint)</term>
________________________________________________________-->
    <term>
    <literal>UNIQUE [ NULLS [ NOT ] DISTINCT ] ( <replaceable class="parameter">column_name</replaceable> [, ... ] )</literal>
    <optional> <literal>INCLUDE ( <replaceable class="parameter">column_name</replaceable> [, ...])</literal> </optional> (table constraint)
</term>
<!-- pgdoc-cn_end sig_en=89aac4ea4c052db150b599efd7437db8 -->

    <listitem>
<!-- pgdoc-cn_start sig_en=0b04b972a682acd6bab1809fce1184c1 sig_cn_org=None source=14.1 
     <para>
      The <literal>UNIQUE</literal> constraint specifies that a
      group of one or more columns of a table can contain
      only unique values. The behavior of a unique table constraint
      is the same as that of a unique column constraint, with the
      additional capability to span multiple columns.  The constraint
      therefore enforces that any two rows must differ in at least one
      of these columns.
     </para>
________________________________________________________-->
     <para>
      <literal>UNIQUE</literal>约束指定一个表中的一列或多列组成的组包含唯一的值。
      唯一表约束的行为与唯一列约束的行为相同，只是表约束能够跨越多列。
      约束因此强制在这些列中的至少一列的任何两行必须不同。
     </para>
<!-- pgdoc-cn_end sig_en=0b04b972a682acd6bab1809fce1184c1 -->

<!-- pgdoc-cn_start sig_en=11b49715d9c6528cc063dc0f3e46e633 sig_cn_org=3a570cc6d20f6b6467614d7d04e0d5a5 source=15.7 
     <para>
      For the purpose of a unique constraint, null values are not
      considered equal, unless <literal>NULLS NOT DISTINCT</literal> is
      specified.
     </para>
________________________________________________________-->
     <para>
      对于唯一约束的目的，null值不被视为相等，除非指定了<literal>NULLS NOT DISTINCT</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=11b49715d9c6528cc063dc0f3e46e633 -->

<!-- pgdoc-cn_start sig_en=0af4001c4c192a40875917ffdd60aa5a sig_cn_org=None source=14.1 
     <para>
      Each unique constraint should name a set of columns that is
      different from the set of columns named by any other unique or
      primary key constraint defined for the table.  (Otherwise, redundant
      unique constraints will be discarded.)
     </para>
________________________________________________________-->
     <para>
      每一个唯一表约束将命名一个列的集合，并且它与该表上任何其他唯一或主键约束所命名的列集合都不相同。
      （否则，冗余的唯一约束将被丢弃。）
     </para>
<!-- pgdoc-cn_end sig_en=0af4001c4c192a40875917ffdd60aa5a -->

<!-- pgdoc-cn_start sig_en=95925a63633ab7423627baaf7c4b1531 sig_cn_org=None source=14.1 
     <para>
      When establishing a unique constraint for a multi-level partition
      hierarchy, all the columns in the partition key of the target
      partitioned table, as well as those of all its descendant partitioned
      tables, must be included in the constraint definition.
     </para>
________________________________________________________-->
     <para>
      在为多级分区层次结构建立唯一约束时，
      目标分区表的分区键中的所有列，以及那些由它派生的所有分区表，
      必须被包含在约束定义中。
     </para>
<!-- pgdoc-cn_end sig_en=95925a63633ab7423627baaf7c4b1531 -->

<!-- pgdoc-cn_start sig_en=8c0d42e57e01363aa4293867c2d55291 sig_cn_org=None source=14.1 
     <para>
      Adding a unique constraint will automatically create a unique btree
      index on the column or group of columns used in the constraint.
     </para>
________________________________________________________-->
     <para>
      添加唯一约束将自动在使用于约束的列或列组上创建唯一的 btree索引。
     </para>
<!-- pgdoc-cn_end sig_en=8c0d42e57e01363aa4293867c2d55291 -->

<!-- pgdoc-cn_start sig_en=f97f8e953dcdca97c06cd740bf671627 sig_cn_org=None source=14.1 
     <para>
      The optional <literal>INCLUDE</literal> clause adds to that index
      one or more columns that are simply <quote>payload</quote>: uniqueness
      is not enforced on them, and the index cannot be searched on the basis
      of those columns.  However they can be retrieved by an index-only scan.
      Note that although the constraint is not enforced on included columns,
      it still depends on them.  Consequently, some operations on such columns
      (e.g., <literal>DROP COLUMN</literal>) can cause cascaded constraint and
      index deletion.
     </para>
________________________________________________________-->
     <para>
      可选 <literal>INCLUDE</literal>子句向该索引添加一个或多个列是简单的<quote>payload</quote>：在它们上面唯一性是不强制的，并且该索引不能基于这些列搜索。
      然而它们可以通过一个仅对索引的扫描检索。
      请注意虽然约束在包含的列上是非强制的，但是它仍然依赖于它们。
      因此，这样的列上的某些操作（例如<literal>DROP COLUMN</literal>）可能会导致级联约束和索引删除。
     </para>
<!-- pgdoc-cn_end sig_en=f97f8e953dcdca97c06cd740bf671627 -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=56d6245f01f30e2944bb847b3b6d4f6f sig_cn_org=None source=14.1 
    <term><literal>PRIMARY KEY</literal> (column constraint)</term>
________________________________________________________-->
    <term><literal>PRIMARY KEY</literal> （列约束）</term>
<!-- pgdoc-cn_end sig_en=56d6245f01f30e2944bb847b3b6d4f6f -->
<!-- pgdoc-cn_start sig_en=7394c00f5fe969b71b7af21fc652026b sig_cn_org=None source=14.1 
    <term><literal>PRIMARY KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] )</literal>
    <optional> <literal>INCLUDE ( <replaceable class="parameter">column_name</replaceable> [, ...])</literal> </optional> (table constraint)</term>
________________________________________________________-->
    <term><literal>PRIMARY KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] )</literal>
    <optional> <literal>INCLUDE ( <replaceable class="parameter">column_name</replaceable> [, ...])</literal> </optional> (table constraint)</term>
<!-- pgdoc-cn_end sig_en=7394c00f5fe969b71b7af21fc652026b -->
    <listitem>
<!-- pgdoc-cn_start sig_en=0bcdba6f553f8c00b9c13ca47ce2564e sig_cn_org=None source=14.1 
     <para>
      The <literal>PRIMARY KEY</literal> constraint specifies that a column or
      columns of a table can contain only unique (non-duplicate), nonnull
      values. Only one primary key can be specified for a table, whether as a
      column constraint or a table constraint.
     </para>
________________________________________________________-->
     <para>
      <literal>PRIMARY KEY</literal>约束指定表的一个或者多个列只能包含唯一（不重复）、非空的值。一个表上只能指定一个主键，可以作为列约束或表约束。
     </para>
<!-- pgdoc-cn_end sig_en=0bcdba6f553f8c00b9c13ca47ce2564e -->

<!-- pgdoc-cn_start sig_en=90113ab9997300dce308573d86a0ea68 sig_cn_org=None source=14.1 
     <para>
      The primary key constraint should name a set of columns that is
      different from the set of columns named by any unique
      constraint defined for the same table.  (Otherwise, the unique
      constraint is redundant and will be discarded.)
     </para>
________________________________________________________-->
     <para>
      主键约束所涉及的列集合应该不同于同一个表上定义的任何唯一约束的列集合（否则，该唯一约束是多余的并且会被丢弃）。
     </para>
<!-- pgdoc-cn_end sig_en=90113ab9997300dce308573d86a0ea68 -->

<!-- pgdoc-cn_start sig_en=50dce93e9309821cc7ecd22e422b6004 sig_cn_org=None source=14.1 
     <para>
      <literal>PRIMARY KEY</literal> enforces the same data constraints as
      a combination of <literal>UNIQUE</literal> and <literal>NOT
      NULL</literal>.  However,
      identifying a set of columns as the primary key also provides metadata
      about the design of the schema, since a primary key implies that other
      tables can rely on this set of columns as a unique identifier for rows.
     </para>
________________________________________________________-->
     <para>
      <literal>PRIMARY KEY</literal>强制的数据约束可以看成是<literal>UNIQUE</literal>和<literal>NOT NULL</literal>的组合，
      然而，把一组列标识为主键也为模式设计提供了元数据，因为主键标识其他表可以依赖这一个列集合作为行的唯一标识符。
     </para>
<!-- pgdoc-cn_end sig_en=50dce93e9309821cc7ecd22e422b6004 -->

<!-- pgdoc-cn_start sig_en=953c3e237ebf2efc9ad91b837d8a92a6 sig_cn_org=None source=14.1 
     <para>
      When placed on a partitioned table, <literal>PRIMARY KEY</literal>
      constraints share the restrictions previously described
      for <literal>UNIQUE</literal> constraints.
     </para>
________________________________________________________-->
     <para>
      当放到分区表上时，<literal>PRIMARY KEY</literal> 约束共享前面描述的<literal>UNIQUE</literal> 约束的限制。
     </para>
<!-- pgdoc-cn_end sig_en=953c3e237ebf2efc9ad91b837d8a92a6 -->

<!-- pgdoc-cn_start sig_en=1d069dd8bcaa3a1563614dc471c85524 sig_cn_org=None source=14.1 
     <para>
      Adding a <literal>PRIMARY KEY</literal> constraint will automatically
      create a unique btree index on the column or group of columns used in the
      constraint.
     </para>
________________________________________________________-->
     <para>
      添加<literal>PRIMARY KEY</literal>约束将自动在用于约束的列或列组上创建唯一的 btree 索引。
     </para>
<!-- pgdoc-cn_end sig_en=1d069dd8bcaa3a1563614dc471c85524 -->

<!-- pgdoc-cn_start sig_en=f97f8e953dcdca97c06cd740bf671627 sig_cn_org=None source=14.1 
     <para>
      The optional <literal>INCLUDE</literal> clause adds to that index
      one or more columns that are simply <quote>payload</quote>: uniqueness
      is not enforced on them, and the index cannot be searched on the basis
      of those columns.  However they can be retrieved by an index-only scan.
      Note that although the constraint is not enforced on included columns,
      it still depends on them.  Consequently, some operations on such columns
      (e.g., <literal>DROP COLUMN</literal>) can cause cascaded constraint and
      index deletion.
     </para>
________________________________________________________-->
     <para>
      可选 <literal>INCLUDE</literal>子句向该索引添加一个或多个列是简单的<quote>payload</quote>：在它们上面唯一性是不强制的，并且该索引不能基于这些列搜索。
      然而它们可以通过一个仅对索引的扫描检索。
      请注意虽然约束在包含的列上是非强制的，但是它仍然依赖于它们。
      因此，这样的列上的某些操作（例如<literal>DROP COLUMN</literal>）可能会导致级联约束和索引删除。
     </para>
<!-- pgdoc-cn_end sig_en=f97f8e953dcdca97c06cd740bf671627 -->
    </listitem>
   </varlistentry>

   <varlistentry id="sql-createtable-exclude">
    <term><literal>EXCLUDE [ USING <replaceable class="parameter">index_method</replaceable> ] ( <replaceable class="parameter">exclude_element</replaceable> WITH <replaceable class="parameter">operator</replaceable> [, ... ] ) <replaceable class="parameter">index_parameters</replaceable> [ WHERE ( <replaceable class="parameter">predicate</replaceable> ) ]</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=b02f3e6a3d9cb3336e6b314ae907ed81 sig_cn_org=7f4c1968096b3c83b69d763853235329 source=15.7 
     <para>
      The <literal>EXCLUDE</literal> clause defines an exclusion
      constraint, which guarantees that if
      any two rows are compared on the specified column(s) or
      expression(s) using the specified operator(s), not all of these
      comparisons will return <literal>TRUE</literal>.  If all of the
      specified operators test for equality, this is equivalent to a
      <literal>UNIQUE</literal> constraint, although an ordinary unique constraint
      will be faster.  However, exclusion constraints can specify
      constraints that are more general than simple equality.
      For example, you can specify a constraint that
      no two rows in the table contain overlapping circles
      (see <xref linkend="datatype-geometric"/>) by using the
      <literal>&amp;&amp;</literal> operator.
      The operator(s) are required to be commutative.
     </para>
________________________________________________________-->
     <para>
      <literal>EXCLUDE</literal>子句定义了一个排除约束，该约束保证如果
      任意两行在指定的列或表达式上使用指定的操作符进行比较，不会有所有这些
      比较返回<literal>TRUE</literal>。如果所有指定的操作符都测试相等，这等同于一个
      <literal>UNIQUE</literal>约束，尽管普通的唯一约束会更快。然而，排除约束可以指定
      比简单相等更一般的约束。例如，您可以指定一个约束，表中没有两行包含重叠的圆
      (参见<xref linkend="datatype-geometric"/>)，通过使用
      <literal>&amp;&amp;</literal>操作符。操作符需要是可交换的。
     </para>
<!-- pgdoc-cn_end sig_en=b02f3e6a3d9cb3336e6b314ae907ed81 -->

<!-- pgdoc-cn_start sig_en=99e846cc348fa4f0df39ae7aded6386f sig_cn_org=9fbdb9be1ad4d4cf9b4f5b48ffdbeb7d source=15.7 
     <para>
      Exclusion constraints are implemented using
      an index, so each specified operator must be associated with an
      appropriate operator class
      (see <xref linkend="indexes-opclass"/>) for the index access
      method <replaceable>index_method</replaceable>.
      Each <replaceable class="parameter">exclude_element</replaceable>
      defines a column of the index, so it can optionally specify a collation,
      an operator class, operator class parameters, and/or ordering options;
      these are described fully under <xref linkend="sql-createindex"/>.
     </para>
________________________________________________________-->
     <para>
      排除约束使用索引实现，因此每个指定的操作符必须与适当的操作符类关联
      (参见<xref linkend="indexes-opclass"/>)，用于索引访问方法<replaceable>index_method</replaceable>。
      每个<replaceable class="parameter">exclude_element</replaceable>定义索引的一列，因此可以选择性地指定排序规则、
      操作符类、操作符类参数和/或排序选项；这些在<xref linkend="sql-createindex"/>下有详细描述。
</para>
<!-- pgdoc-cn_end sig_en=99e846cc348fa4f0df39ae7aded6386f -->

<!-- pgdoc-cn_start sig_en=fff09749c35bb310d3f16776c61846b3 sig_cn_org=None source=14.1 
     <para>
      The access method must support <literal>amgettuple</literal> (see <xref
      linkend="indexam"/>); at present this means <acronym>GIN</acronym>
      cannot be used.  Although it's allowed, there is little point in using
      B-tree or hash indexes with an exclusion constraint, because this
      does nothing that an ordinary unique constraint doesn't do better.
      So in practice the access method will always be <acronym>GiST</acronym> or
      <acronym>SP-GiST</acronym>.
     </para>
________________________________________________________-->
     <para>
      访问方法必须支持<literal>amgettuple</literal>（见<xref linkend="indexam"/>），目前这意味着<acronym>GIN</acronym>无法使用。尽管允许，但是在一个排除约束中使用 B-树或哈希索引没有意义，因为它无法做得比一个普通唯一索引更出色。因此在实践中访问方法将总是<acronym>GiST</acronym>或<acronym>SP-GiST</acronym>。
     </para>
<!-- pgdoc-cn_end sig_en=fff09749c35bb310d3f16776c61846b3 -->

<!-- pgdoc-cn_start sig_en=773152c469850aed5f01464f86a1a810 sig_cn_org=None source=14.1 
     <para>
      The <replaceable class="parameter">predicate</replaceable> allows you to specify an
      exclusion constraint on a subset of the table; internally this creates a
      partial index. Note that parentheses are required around the predicate.
     </para>
________________________________________________________-->
     <para>
      <replaceable class="parameter">predicate</replaceable>允许你在该表的一个子集上指定一个排除约束。在内部这会创建一个部分索引。注意在为此周围的圆括号是必须的。
     </para>
<!-- pgdoc-cn_end sig_en=773152c469850aed5f01464f86a1a810 -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=0d725372ad8b83ed3b05e26c750e2f57 sig_cn_org=None source=14.1 
    <term><literal>REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> ) ] [ MATCH <replaceable class="parameter">matchtype</replaceable> ] [ ON DELETE <replaceable class="parameter">referential_action</replaceable> ] [ ON UPDATE <replaceable class="parameter">referential_action</replaceable> ]</literal> (column constraint)</term>
________________________________________________________-->
    <term><literal>REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> ) ] [ MATCH <replaceable class="parameter">matchtype</replaceable> ] [ ON DELETE <replaceable class="parameter">referential_action</replaceable> ] [ ON UPDATE <replaceable class="parameter">referential_action</replaceable> ]</literal> (column constraint)</term>
<!-- pgdoc-cn_end sig_en=0d725372ad8b83ed3b05e26c750e2f57 -->

<!-- pgdoc-cn_start sig_en=1a87789d22c2a5f15d789befd341e6f4 sig_cn_org=None source=14.1 
   <term><literal>FOREIGN KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] )
    REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> [, ... ] ) ]
    [ MATCH <replaceable class="parameter">matchtype</replaceable> ]
    [ ON DELETE <replaceable class="parameter">referential_action</replaceable> ]
    [ ON UPDATE <replaceable class="parameter">referential_action</replaceable> ]</literal>
    (table constraint)</term>
________________________________________________________-->
   <term><literal>FOREIGN KEY ( <replaceable class="parameter">column_name</replaceable> [, ... ] )
    REFERENCES <replaceable class="parameter">reftable</replaceable> [ ( <replaceable class="parameter">refcolumn</replaceable> [, ... ] ) ]
    [ MATCH <replaceable class="parameter">matchtype</replaceable> ]
    [ ON DELETE <replaceable class="parameter">referential_action</replaceable> ]
    [ ON UPDATE <replaceable class="parameter">referential_action</replaceable> ]</literal>
    (table constraint)</term>
<!-- pgdoc-cn_end sig_en=1a87789d22c2a5f15d789befd341e6f4 -->

    <listitem>
<!-- pgdoc-cn_start sig_en=2000f13dbc0aedf2365c6a3d230280d4 sig_cn_org=036b6fb5e1986f2e114e623581c6e7a9 source=15.7 
     <para>
      These clauses specify a foreign key constraint, which requires
      that a group of one or more columns of the new table must only
      contain values that match values in the referenced
      column(s) of some row of the referenced table.  If the <replaceable
      class="parameter">refcolumn</replaceable> list is omitted, the
      primary key of the <replaceable class="parameter">reftable</replaceable>
      is used.  Otherwise, the <replaceable class="parameter">refcolumn</replaceable>
      list must refer to the columns of a non-deferrable unique or primary key
      constraint or be the columns of a non-partial unique index.  The user
      must have <literal>REFERENCES</literal> permission on the referenced
      table (either the whole table, or the specific referenced columns).  The
      addition of a foreign key constraint requires a
      <literal>SHARE ROW EXCLUSIVE</literal> lock on the referenced table.
      Note that foreign key constraints cannot be defined between temporary
      tables and permanent tables.
     </para>
________________________________________________________-->
     <para>
      这些子句指定了外键约束，要求新表的一个或多个列只能包含与引用表的某行的引用列中匹配的值。
      如果<replaceable class="parameter">refcolumn</replaceable>列表被省略，则使用<replaceable class="parameter">reftable</replaceable>的主键。
      否则，<replaceable class="parameter">refcolumn</replaceable>列表必须引用非延迟唯一或主键约束的列，或者是非部分唯一索引的列。
      用户必须对引用表（整个表或特定引用列）具有<literal>REFERENCES</literal>权限。
      添加外键约束需要在引用表上进行<literal>SHARE ROW EXCLUSIVE</literal>锁定。
      请注意，临时表和永久表之间不能定义外键约束。
     </para>
<!-- pgdoc-cn_end sig_en=2000f13dbc0aedf2365c6a3d230280d4 -->

<!-- pgdoc-cn_start sig_en=725311c15cb626f143c1102d54d9a11c sig_cn_org=None source=14.1 
     <para>
      A value inserted into the referencing column(s) is matched against the
      values of the referenced table and referenced columns using the
      given match type.  There are three match types: <literal>MATCH
      FULL</literal>, <literal>MATCH PARTIAL</literal>, and <literal>MATCH
      SIMPLE</literal> (which is the default).  <literal>MATCH
      FULL</literal> will not allow one column of a multicolumn foreign key
      to be null unless all foreign key columns are null; if they are all
      null, the row is not required to have a match in the referenced table.
      <literal>MATCH SIMPLE</literal> allows any of the foreign key columns
      to be null; if any of them are null, the row is not required to have a
      match in the referenced table.
      <literal>MATCH PARTIAL</literal> is not yet implemented.
      (Of course, <literal>NOT NULL</literal> constraints can be applied to the
      referencing column(s) to prevent these cases from arising.)
     </para>
________________________________________________________-->
     <para>
      被插入到引用列的一个值会使用给定的匹配类型与被引用表的值进行匹配。
    有三种匹配类型：<literal>MATCH FULL</literal>、<literal>MATCH PARTIAL</literal>以及<literal>MATCH SIMPLE</literal>（这是默认值）。  
    <literal>MATCH FULL</literal>将不允许一个多列外键中的一列为空，除非所有外键列都是空；如果它们都是空，则不要求该行在被引用表中有一个匹配。
    <literal>MATCH SIMPLE</literal>允许任意外键列为空，如果任一为空，则不要求该行在被引用表中有一个匹配。
    <literal>MATCH PARTIAL</literal>现在还没有被实现（当然，<literal>NOT NULL</literal>约束能被应用在引用列上来组织这些情况发生）。
     </para>
<!-- pgdoc-cn_end sig_en=725311c15cb626f143c1102d54d9a11c -->

<!-- pgdoc-cn_start sig_en=e49ce0bb123a08dc5348c886b90eb52d sig_cn_org=23964b538a83a2d80894dc9ac7189286 source=15.7 
     <para>
      In addition, when the data in the referenced columns is changed,
      certain actions are performed on the data in this table's
      columns.  The <literal>ON DELETE</literal> clause specifies the
      action to perform when a referenced row in the referenced table is
      being deleted.  Likewise, the <literal>ON UPDATE</literal>
      clause specifies the action to perform when a referenced column
      in the referenced table is being updated to a new value. If the
      row is updated, but the referenced column is not actually
      changed, no action is done. Referential actions other than the
      <literal>NO ACTION</literal> check cannot be deferred, even if
      the constraint is declared deferrable. There are the following possible
      actions for each clause:

      <variablelist>
       <varlistentry>
        <term><literal>NO ACTION</literal></term>
        <listitem>
         <para>
          Produce an error indicating that the deletion or update
          would create a foreign key constraint violation.
          If the constraint is deferred, this
          error will be produced at constraint check time if there still
          exist any referencing rows.  This is the default action.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>RESTRICT</literal></term>
        <listitem>
         <para>
          Produce an error indicating that the deletion or update
          would create a foreign key constraint violation.
          This is the same as <literal>NO ACTION</literal> except that
          the check is not deferrable.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>CASCADE</literal></term>
        <listitem>
         <para>
          Delete any rows referencing the deleted row, or update the
          values of the referencing column(s) to the new values of the
          referenced columns, respectively.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>SET NULL [ ( <replaceable>column_name</replaceable> [, ... ] ) ]</literal></term>
        <listitem>
         <para>
          Set all of the referencing columns, or a specified subset of the
          referencing columns, to null. A subset of columns can only be
          specified for <literal>ON DELETE</literal> actions.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>SET DEFAULT [ ( <replaceable>column_name</replaceable> [, ... ] ) ]</literal></term>
        <listitem>
         <para>
          Set all of the referencing columns, or a specified subset of the
          referencing columns, to their default values. A subset of columns
          can only be specified for <literal>ON DELETE</literal> actions.
          (There must be a row in the referenced table matching the default
          values, if they are not null, or the operation will fail.)
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
________________________________________________________-->
     <para>
      另外，当引用列中的数据发生更改时，将对此表中的数据执行某些操作。
      <literal>ON DELETE</literal>子句指定在引用表中的引用行正在被删除时执行的操作。
      同样，<literal>ON UPDATE</literal>子句指定在引用表中的引用列正在更新为新值时执行的操作。
      如果更新了行，但实际上未更改引用列，则不执行任何操作。
      除了<literal>NO ACTION</literal>检查之外的引用操作不能被延迟，即使约束被声明为可延迟。
      对于每个子句，有以下可能的操作：

      <variablelist>
       <varlistentry>
        <term><literal>NO ACTION</literal></term>
        <listitem>
         <para>
          生成一个错误，指示删除或更新将创建外键约束违规。
          如果约束被延迟，如果仍然存在任何引用行，则在约束检查时将产生此错误。
          这是默认操作。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>RESTRICT</literal></term>
        <listitem>
         <para>
          生成一个错误，指示删除或更新将创建外键约束违规。
          这与<literal>NO ACTION</literal>相同，只是检查不可延迟。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>CASCADE</literal></term>
        <listitem>
         <para>
          删除引用已删除行的任何行，或将引用列的值更新为相应引用列的新值。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>SET NULL [ ( <replaceable>column_name</replaceable> [, ... ] ) ]</literal></term>
        <listitem>
         <para>
          将所有引用列或指定的引用列子集设置为null。只能为<literal>ON DELETE</literal>操作指定列的子集。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>SET DEFAULT [ ( <replaceable>column_name</replaceable> [, ... ] ) ]</literal></term>
        <listitem>
         <para>
          将所有引用列或指定的引用列子集设置为它们的默认值。
          只能为<literal>ON DELETE</literal>操作指定列的子集。
          （如果默认值不为null，则在引用表中必须有一行匹配这些默认值，否则操作将失败。）
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
<!-- pgdoc-cn_end sig_en=e49ce0bb123a08dc5348c886b90eb52d -->

<!-- pgdoc-cn_start sig_en=2e96e4dc836fb699c4dd605659404007 sig_cn_org=None source=14.1 
     <para>
      If the referenced column(s) are changed frequently, it might be wise to
      add an index to the referencing column(s) so that referential actions
      associated with the foreign key constraint can be performed more
      efficiently.
     </para>
________________________________________________________-->
     <para>
      如果被引用列被频繁地更改，最好在引用列上加上一个索引，这样与外键约束相关的引用动作能够更高效地被执行。
     </para>
<!-- pgdoc-cn_end sig_en=2e96e4dc836fb699c4dd605659404007 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFERRABLE</literal></term>
    <term><literal>NOT DEFERRABLE</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=1b9d417e3289ffef783113243a667e11 sig_cn_org=None source=14.1 
     <para>
      This controls whether the constraint can be deferred.  A
      constraint that is not deferrable will be checked immediately
      after every command.  Checking of constraints that are
      deferrable can be postponed until the end of the transaction
      (using the <link linkend="sql-set-constraints"><command>SET CONSTRAINTS</command></link> command).
      <literal>NOT DEFERRABLE</literal> is the default.
      Currently, only <literal>UNIQUE</literal>, <literal>PRIMARY KEY</literal>,
      <literal>EXCLUDE</literal>, and
      <literal>REFERENCES</literal> (foreign key) constraints accept this
      clause.  <literal>NOT NULL</literal> and <literal>CHECK</literal> constraints are not
      deferrable.  Note that deferrable constraints cannot be used as
      conflict arbitrators in an <command>INSERT</command> statement that
      includes an <literal>ON CONFLICT DO UPDATE</literal> clause.
     </para>
________________________________________________________-->
     <para>
      这个子句控制该约束是否能被延迟。
      一个不可延迟的约束将在每一次命令后立刻被检查。
      可延迟约束的检查将被推迟到事务结束时进行（使用<link linkend="sql-set-constraints"><command>SET CONSTRAINTS</command></link>命令）。
      <literal>NOT DEFERRABLE</literal>是默认值。
      当前，只有<literal>UNIQUE</literal>、<literal>PRIMARY KEY</literal>、<literal>EXCLUDE</literal>以及<literal>REFERENCES</literal>（外键）约束接受这个子句。
      <literal>NOT NULL</literal>以及<literal>CHECK</literal>约束是不可延迟的。
      注意在包括<literal>ON CONFLICT DO UPDATE</literal>子句的<command>INSERT</command>语句中，可延迟约束不能被用作冲突裁判者。
     </para>
<!-- pgdoc-cn_end sig_en=1b9d417e3289ffef783113243a667e11 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INITIALLY IMMEDIATE</literal></term>
    <term><literal>INITIALLY DEFERRED</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=7314e7c41f754f06ea970d8d13510778 sig_cn_org=None source=14.1 
     <para>
      If a constraint is deferrable, this clause specifies the default
      time to check the constraint.  If the constraint is
      <literal>INITIALLY IMMEDIATE</literal>, it is checked after each
      statement. This is the default.  If the constraint is
      <literal>INITIALLY DEFERRED</literal>, it is checked only at the
      end of the transaction.  The constraint check time can be
      altered with the <link linkend="sql-set-constraints"><command>SET CONSTRAINTS</command></link> command.
     </para>
________________________________________________________-->
     <para>
      如果一个约束是可延迟的，这个子句指定检查该约束的默认时间。
      如果该约束是<literal>INITIALLY IMMEDIATE</literal>，它会在每一个语句之后被检查。
      这是默认值。
      如果该约束是<literal>INITIALLY DEFERRED</literal>，它只会在事务结束时被检查。
      约束检查时间可以用<link linkend="sql-set-constraints"><command>SET CONSTRAINTS</command></link>命令修改。
     </para>
<!-- pgdoc-cn_end sig_en=7314e7c41f754f06ea970d8d13510778 -->
    </listitem>
   </varlistentry>

   <varlistentry id="sql-createtable-method">
    <term><literal>USING <replaceable class="parameter">method</replaceable></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=36b376f827f70f9767acccb66dbd91c5 sig_cn_org=None source=14.1 
     <para>
      This optional clause specifies the table access method to use to store
      the contents for the new table; the method needs be an access method of
      type <literal>TABLE</literal>. See <xref linkend="tableam"/> for more
      information.  If this option is not specified, the default table access
      method is chosen for the new table. See <xref
      linkend="guc-default-table-access-method"/> for more information.
     </para>
________________________________________________________-->
     <para>
      此可选子句指定用于存储新表内容的表访问方法；该方法需要的是类型<literal>TABLE</literal>的访问方法。详见 <xref linkend="tableam"/> 。
      如果未指定此选项，则为新表选择默认表访问方法。详见<xref linkend="guc-default-table-access-method"/>。
     </para>
<!-- pgdoc-cn_end sig_en=36b376f827f70f9767acccb66dbd91c5 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] )</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=ec7f8bbac7bd9861e14af9616ff89439 sig_cn_org=None source=14.1 
     <para>
      This clause specifies optional storage parameters for a table or index;
      see <xref linkend="sql-createtable-storage-parameters"/> below for more
      information.  For backward-compatibility the <literal>WITH</literal>
      clause for a table can also include <literal>OIDS=FALSE</literal> to
      specify that rows of the new table should not contain OIDs (object
      identifiers), <literal>OIDS=TRUE</literal> is not supported anymore.
     </para>
________________________________________________________-->
     <para>
      这个子句为一个表或索引指定可选的存储参数，详见<xref linkend="sql-createtable-storage-parameters"/> 。
      为了向后兼容性，表的<literal>WITH</literal>子句还可以包括<literal>OIDS=FALSE</literal>以便指定新表的行不应包含 OIDs （对象标识符），<literal>OIDS=TRUE</literal>不再受支持。
     </para>
<!-- pgdoc-cn_end sig_en=ec7f8bbac7bd9861e14af9616ff89439 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITHOUT OIDS</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=7f550091d903456b178cf5db7f65ebda sig_cn_org=None source=14.1 
     <para>
      This is backward-compatible syntax for declaring a table
      <literal>WITHOUT OIDS</literal>, creating a table <literal>WITH
      OIDS</literal> is not supported anymore.
     </para>
________________________________________________________-->
     <para>
      这是向后兼容的语法，用于声明表<literal>WITHOUT OIDS</literal>，不再支持创建表<literal>WITH OIDS</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=7f550091d903456b178cf5db7f65ebda -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ON COMMIT</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=63875a5b564317abf03d638af6abc90d sig_cn_org=None source=14.1 
     <para>
      The behavior of temporary tables at the end of a transaction
      block can be controlled using <literal>ON COMMIT</literal>.
      The three options are:

      <variablelist>
       <varlistentry>
        <term><literal>PRESERVE ROWS</literal></term>
        <listitem>
         <para>
          No special action is taken at the ends of transactions.
          This is the default behavior.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>DELETE ROWS</literal></term>
        <listitem>
         <para>
          All rows in the temporary table will be deleted at the end
          of each transaction block.  Essentially, an automatic <link
          linkend="sql-truncate"><command>TRUNCATE</command></link> is done
          at each commit.  When used on a partitioned table, this
          is not cascaded to its partitions.
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>DROP</literal></term>
        <listitem>
         <para>
          The temporary table will be dropped at the end of the current
          transaction block.  When used on a partitioned table, this action
          drops its partitions and when used on tables with inheritance
          children, it drops the dependent children.
         </para>
        </listitem>
       </varlistentry>
      </variablelist></para>
________________________________________________________-->
     <para>
      临时表在一个事务块结束时的行为由<literal>ON COMMIT</literal>控制。三种选项是：

      <variablelist>
       <varlistentry>
        <term><literal>PRESERVE ROWS</literal></term>
        <listitem>
         <para>
          在事务结束时不采取特殊的动作。这是默认行为。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>DELETE ROWS</literal></term>
        <listitem>
         <para>
          在每一个事务块结束时将删除临时表中的所有行。
      实质上，在每一次提交时会完成一次自动的<link linkend="sql-truncate"><command>TRUNCATE</command></link>。
      当应用于分区表上时，这不会级联到它的分区。
         </para>
        </listitem>
       </varlistentry>

       <varlistentry>
        <term><literal>DROP</literal></term>
        <listitem>
         <para>
         在当前事务块结束时将删除临时表。
     当在分区表上使用时，这个操作会删除他的分区，而在具有继承子级的表上使用时，它将删除依赖的子级。
         </para>
        </listitem>
       </varlistentry>
      </variablelist></para>
<!-- pgdoc-cn_end sig_en=63875a5b564317abf03d638af6abc90d -->
    </listitem>
   </varlistentry>

   <varlistentry id="sql-createtable-tablespace">
    <term><literal>TABLESPACE <replaceable class="parameter">tablespace_name</replaceable></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=03c457cd43c41bb851d9db75de076fea sig_cn_org=None source=14.1 
     <para>
      The <replaceable class="parameter">tablespace_name</replaceable> is the name
      of the tablespace in which the new table is to be created.
      If not specified,
      <xref linkend="guc-default-tablespace"/> is consulted, or
      <xref linkend="guc-temp-tablespaces"/> if the table is temporary.  For
      partitioned tables, since no storage is required for the table itself,
      the tablespace specified overrides <literal>default_tablespace</literal>
      as the default tablespace to use for any newly created partitions when no
      other tablespace is explicitly specified.
     </para>
________________________________________________________-->
     <para>
      <replaceable class="parameter">tablespace_name</replaceable>是新表要创建于其中的表空间名称。如果没有指定，将参考<xref linkend="guc-default-tablespace"/>，或者如果表是临时的则参考<xref linkend="guc-temp-tablespaces"/>。
      对于分区表，由于表本身不需要存储，指定表空间将 <literal>default_tablespace</literal>作为默认表空间覆盖，在未显式指定其他表空间时用于任何新创建的分区。
     </para>
<!-- pgdoc-cn_end sig_en=03c457cd43c41bb851d9db75de076fea -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>USING INDEX TABLESPACE <replaceable class="parameter">tablespace_name</replaceable></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=a9b4c0d964f223290b5300475de0930e sig_cn_org=None source=14.1 
     <para>
      This clause allows selection of the tablespace in which the index
      associated with a <literal>UNIQUE</literal>, <literal>PRIMARY
      KEY</literal>, or <literal>EXCLUDE</literal> constraint will be created.
      If not specified,
      <xref linkend="guc-default-tablespace"/> is consulted, or
      <xref linkend="guc-temp-tablespaces"/> if the table is temporary.
     </para>
________________________________________________________-->
     <para>
      这个子句允许选择与一个<literal>UNIQUE</literal>、<literal>PRIMARY KEY</literal>或者<literal>EXCLUDE</literal>约束相关的索引将被创建在哪个表空间中。如果没有指定，将参考<xref linkend="guc-default-tablespace"/>，或者如果表是临时的则参考<xref linkend="guc-temp-tablespaces"/>。
     </para>
<!-- pgdoc-cn_end sig_en=a9b4c0d964f223290b5300475de0930e -->
    </listitem>
   </varlistentry>

  </variablelist>

  <refsect2 id="sql-createtable-storage-parameters" xreflabel="Storage Parameters">
<!-- pgdoc-cn_start sig_en=5e5af3fd8e74e3b34f9432b4e128157f sig_cn_org=None source=14.1 
   <title>Storage Parameters</title>
________________________________________________________-->
   <title>存储参数</title>
<!-- pgdoc-cn_end sig_en=5e5af3fd8e74e3b34f9432b4e128157f -->

<!-- pgdoc-cn_start sig_en=3069fdca28362a278817e2723c574192 sig_cn_org=None source=14.1 
 <indexterm zone="sql-createtable-storage-parameters">
  <primary>storage parameters</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="sql-createtable-storage-parameters">
  <primary>存储参数</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=3069fdca28362a278817e2723c574192 -->

<!-- pgdoc-cn_start sig_en=9f786940f48d317498fc9c89d037de0a sig_cn_org=None source=14.1 
   <para>
    The <literal>WITH</literal> clause can specify <firstterm>storage parameters</firstterm>
    for tables, and for indexes associated with a <literal>UNIQUE</literal>,
    <literal>PRIMARY KEY</literal>, or <literal>EXCLUDE</literal> constraint.
    Storage parameters for
    indexes are documented in <xref linkend="sql-createindex"/>.
    The storage parameters currently
    available for tables are listed below.  For many of these parameters, as
    shown, there is an additional parameter with the same name prefixed with
    <literal>toast.</literal>, which controls the behavior of the
    table's secondary <acronym>TOAST</acronym> table, if any
    (see <xref linkend="storage-toast"/> for more information about TOAST).
    If a table parameter value is set and the
    equivalent <literal>toast.</literal> parameter is not, the TOAST table
    will use the table's parameter value.
    Specifying these parameters for partitioned tables is not supported,
    but you may specify them for individual leaf partitions.
   </para>
________________________________________________________-->
   <para>
    <literal>WITH</literal>子句能够为表或与一个<literal>UNIQUE</literal>、<literal>PRIMARY KEY</literal>或者<literal>EXCLUDE</literal>约束相关的索引指定<firstterm>存储参数</firstterm>。
  用于索引的存储参数已经在<xref linkend="sql-createindex"/>中介绍过。
  当前可用于表的存储参数在下文中列出。
  如下文所示，对于很多这类参数，都有一个名字带有<literal>toast.</literal>前缀的附加参数，它能被用来控制该表的二级<acronym>TOAST</acronym>表（如果存在）的行为（关于 TOAST 详见<xref linkend="storage-toast"/>）。
  如果一个表的参数值被设置但是相应的<literal>toast.</literal>参数没有被设置，那么 TOAST 表将使用该表的参数值。
  不支持为分区表指定这些参数，但可以为单个叶子分区指定它们。
   </para>
<!-- pgdoc-cn_end sig_en=9f786940f48d317498fc9c89d037de0a -->

   <variablelist>

    <varlistentry id="reloption-fillfactor" xreflabel="fillfactor">
<!-- pgdoc-cn_start sig_en=aa3a4189b012d90de887e26baaeb2edc sig_cn_org=None source=14.1 
    <term><varname>fillfactor</varname> (<type>integer</type>)
    <indexterm>
     <primary><varname>fillfactor</varname> storage parameter</primary>
    </indexterm>
    </term>
________________________________________________________-->
    <term><varname>fillfactor</varname> (<type>integer</type>)
    <indexterm>
     <primary><varname>fillfactor</varname> 存储参数</primary>
    </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=aa3a4189b012d90de887e26baaeb2edc -->
    <listitem>
<!-- pgdoc-cn_start sig_en=b53e94a02568af60f2ffb10efafadaec sig_cn_org=b245ce61a8743787485029ffc5a368d2 source=15.7 
     <para>
      The fillfactor for a table is a percentage between 10 and 100.
      100 (complete packing) is the default.  When a smaller fillfactor
      is specified, <command>INSERT</command> operations pack table pages only
      to the indicated percentage; the remaining space on each page is
      reserved for updating rows on that page.  This gives <command>UPDATE</command>
      a chance to place the updated copy of a row on the same page as the
      original, which is more efficient than placing it on a different
      page, and makes <link linkend="storage-hot">heap-only tuple
      updates</link> more likely.
      For a table whose entries are never updated, complete packing is the
      best choice, but in heavily updated tables smaller fillfactors are
      appropriate.  This parameter cannot be set for TOAST tables.
     </para>
________________________________________________________-->
     <para>
      表的填充因子是介于10和100之间的百分比。
      100（完全填充）是默认值。当指定较小的填充因子时，<command>INSERT</command>操作仅将表页填充到指定的百分比；
      每页上剩余的空间用于更新该页上的行。这使得<command>UPDATE</command>有机会将更新后的行的副本放在
      与原始行相同的页上，这比放在不同的页上更有效，并使<link linkend="storage-hot">仅堆元组更新</link>更有可能发生。
      对于条目永远不会更新的表，完全填充是最佳选择，但在频繁更新的表中，较小的填充因子更合适。此参数不能
      为TOAST表设置。
     </para>
<!-- pgdoc-cn_end sig_en=b53e94a02568af60f2ffb10efafadaec -->
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-toast-tuple-target" xreflabel="toast_tuple_target">
<!-- pgdoc-cn_start sig_en=88432f73a14cd29fdc188ea341ba4b1a sig_cn_org=None source=14.1 
    <term><literal>toast_tuple_target</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>toast_tuple_target</varname> storage parameter</primary>
    </indexterm>
    </term>
________________________________________________________-->
    <term><literal>toast_tuple_target</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>toast_tuple_target</varname> 存储参数</primary>
    </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=88432f73a14cd29fdc188ea341ba4b1a -->
    <listitem>
<!-- pgdoc-cn_start sig_en=808a55a45f90f64f1b7f6c18dde74552 sig_cn_org=None source=14.1 
     <para>
      The toast_tuple_target specifies the minimum tuple length required before
      we try to compress and/or move long column values into TOAST tables, and
      is also the target length we try to reduce the length below once toasting
      begins. This affects columns marked as External (for move),
      Main (for compression), or Extended (for both) and applies only to new
      tuples. There is no effect on existing rows.
      By default this parameter is set to allow at least 4 tuples per block,
      which with the default block size will be 2040 bytes. Valid values are
      between 128 bytes and the (block size - header), by default 8160 bytes.
      Changing this value may not be useful for very short or very long rows.
      Note that the default setting is often close to optimal, and
      it is possible that setting this parameter could have negative
      effects in some cases.
      This parameter cannot be set for TOAST tables.
     </para>
________________________________________________________-->
     <para>
      在我们尝试压缩和/或将长列值移动到TOAST表中之前，toast_tuple_target指定需要的最小元组长度，
      也是在toasting开始时尝试减少长度的目标长度。这会影响标记为 External（用于移动）、
      Main（用于压缩）或 Extended（用于两者）的列，并且仅适用于新元组。 对现有行没有影响。
      这仅影响标记为"外部"或"扩展"的列，并且仅适用于新元数 - 对现有行没有影响。
      默认情况下此参数设置为允许每个块至少 4 个元组，默认块大小为 2040 字节。
      有效值介于 128 字节和(块大小-标头)之间，默认大小为 8160 字节。 
      更改此值对于非常短或非常长的行可能没有用处。
      请注意默认设置通常接近最佳状态，在某些情况下设置此参数可能会产生负面影响。
      不能对TOAST表设置此参数。
     </para>
<!-- pgdoc-cn_end sig_en=808a55a45f90f64f1b7f6c18dde74552 -->
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-parallel-workers" xreflabel="parallel_workers">
<!-- pgdoc-cn_start sig_en=7b6345668b9627d15a7d71bab12c9423 sig_cn_org=None source=14.1 
    <term><literal>parallel_workers</literal> (<type>integer</type>)
     <indexterm>
     <primary><varname>parallel_workers</varname> storage parameter</primary>
    </indexterm>
    </term>
________________________________________________________-->
    <term><literal>parallel_workers</literal> (<type>integer</type>)
     <indexterm>
     <primary><varname>parallel_workers</varname> 存储参数</primary>
    </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=7b6345668b9627d15a7d71bab12c9423 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=88356627b463e5e00e1f03e9b8bfc224 sig_cn_org=None source=14.1 
     <para>
      This sets the number of workers that should be used to assist a parallel
      scan of this table.  If not set, the system will determine a value based
      on the relation size.  The actual number of workers chosen by the planner
      or by utility statements that use parallel scans may be less, for example
      due to the setting of <xref linkend="guc-max-worker-processes"/>.
     </para>
________________________________________________________-->
     <para>
      这个参数设置用于辅助并行扫描这个表的工作者数量。
    如果没有设置这个参数，系统将基于关系的尺寸来决定一个值。
    规划者或使用并行扫描的实用程序选择的工作者数量可能会比较少，例如<xref linkend="guc-max-worker-processes"/>的设置较小就是一种可能的原因。
     </para>
<!-- pgdoc-cn_end sig_en=88356627b463e5e00e1f03e9b8bfc224 -->
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-enabled" xreflabel="autovacuum_enabled">
<!-- pgdoc-cn_start sig_en=2f1a63fb9722ca0ea4ee22f54ebc5ac4 sig_cn_org=None source=14.1 
    <term><literal>autovacuum_enabled</literal>, <literal>toast.autovacuum_enabled</literal> (<type>boolean</type>)
    <indexterm>
     <primary><varname>autovacuum_enabled</varname> storage parameter</primary>
    </indexterm>
    </term>
________________________________________________________-->
    <term><literal>autovacuum_enabled</literal>, <literal>toast.autovacuum_enabled</literal> (<type>boolean</type>)
    <indexterm>
     <primary><varname>autovacuum_enabled</varname> 存储参数</primary>
    </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=2f1a63fb9722ca0ea4ee22f54ebc5ac4 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=afacdaec39f0e6318b8d70fb464df4a8 sig_cn_org=None source=14.1 
     <para>
     Enables or disables the autovacuum daemon for a particular table.
     If true, the autovacuum daemon will perform automatic <command>VACUUM</command>
     and/or <command>ANALYZE</command> operations on this table following the rules
     discussed in <xref linkend="autovacuum"/>.
     If false, this table will not be autovacuumed, except to prevent
     transaction ID wraparound. See <xref linkend="vacuum-for-wraparound"/> for
     more about wraparound prevention.
     Note that the autovacuum daemon does not run at all (except to prevent
     transaction ID wraparound) if the <xref linkend="guc-autovacuum"/>
     parameter is false; setting individual tables' storage parameters does
     not override that.  Therefore there is seldom much point in explicitly
     setting this storage parameter to <literal>true</literal>, only
     to <literal>false</literal>.
     </para>
________________________________________________________-->
     <para>
     为一个特定的表启用或者禁用自动清理守护进程。如果为真，自动清理守护进程将遵照<xref linkend="autovacuum"/>中讨论的规则在这个表上执行自动的<command>VACUUM</command>或者<command>ANALYZE</command>操作。如果为假，这个表不会被自动清理，不过为了阻止事务 ID 回卷时还是会对它进行自动的清理。有关回卷阻止请见<xref linkend="vacuum-for-wraparound"/>。如果<xref linkend="guc-autovacuum"/>参数为假，自动清理守护进程根本就不会运行（除非为了阻止事务 ID 回卷），设置独立的表存储参数也不会覆盖这个设置。因此显式地将这个存储参数设置为<literal>true</literal>很少有大的意义，只有设置为<literal>false</literal>才更有用。
     </para>
<!-- pgdoc-cn_end sig_en=afacdaec39f0e6318b8d70fb464df4a8 -->
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-vacuum-index-cleanup" xreflabel="vacuum_index_cleanup">
<!-- pgdoc-cn_start sig_en=d61360d420202b361eb10fb1aff09d37 sig_cn_org=None source=14.1 
    <term><literal>vacuum_index_cleanup</literal>, <literal>toast.vacuum_index_cleanup</literal> (<type>enum</type>)
    <indexterm>
     <primary><varname>vacuum_index_cleanup</varname> storage parameter</primary>
    </indexterm>
    </term>
________________________________________________________-->
    <term><literal>vacuum_index_cleanup</literal>, <literal>toast.vacuum_index_cleanup</literal> (<type>enum</type>)
    <indexterm>
     <primary><varname>vacuum_index_cleanup</varname> 存储参数</primary>
    </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=d61360d420202b361eb10fb1aff09d37 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=53fd6d6479a227cf02d2fa58fe8a9403 sig_cn_org=None source=14.1 
     <para>
      Forces or disables index cleanup when <command>VACUUM</command>
      is run on this table.  The default value is
      <literal>AUTO</literal>.  With <literal>OFF</literal>, index
      cleanup is disabled, with <literal>ON</literal> it is enabled,
      and with <literal>AUTO</literal> a decision is made dynamically,
      each time <command>VACUUM</command> runs.  The dynamic behavior
      allows <command>VACUUM</command> to avoid needlessly scanning
      indexes to remove very few dead tuples.  Forcibly disabling all
      index cleanup can speed up <command>VACUUM</command> very
      significantly, but may also lead to severely bloated indexes if
      table modifications are frequent.  The
      <literal>INDEX_CLEANUP</literal> parameter of <link
       linkend="sql-vacuum"><command>VACUUM</command></link>, if
      specified, overrides the value of this option.
     </para>
________________________________________________________-->
     <para>
      当<command>VACUUM</command>在此表上运行时强制或禁用索引清理。
      默认值为<literal>AUTO</literal>。
      用<literal>OFF</literal>，索引清理被禁用，用<literal>ON</literal>则被启用，而采用<literal>AUTO</literal> ，决定被动态做出，每次<command>VACUUM</command>运行时。
      动态行为允许<command>VACUUM</command>不需要的扫描索引以移除很少的死元组。
      强制禁用全部索引清理可以显著加快<command>VACUUM</command>，但如果表修改很频繁，也可能导致索引严重膨胀。 
      <link linkend="sql-vacuum"><command>VACUUM</command></link>的<literal>INDEX_CLEANUP</literal>参数，如果指定，将覆盖此选项的值。
     </para>
<!-- pgdoc-cn_end sig_en=53fd6d6479a227cf02d2fa58fe8a9403 -->
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-vacuum-truncate" xreflabel="vacuum_truncate">
<!-- pgdoc-cn_start sig_en=df24f4d75bc1e412291a619001ed4e12 sig_cn_org=None source=14.1 
    <term><literal>vacuum_truncate</literal>, <literal>toast.vacuum_truncate</literal> (<type>boolean</type>)
    <indexterm>
     <primary><varname>vacuum_truncate</varname> storage parameter</primary>
    </indexterm>
    </term>
________________________________________________________-->
    <term><literal>vacuum_truncate</literal>, <literal>toast.vacuum_truncate</literal> (<type>boolean</type>)
    <indexterm>
     <primary><varname>vacuum_truncate</varname> 存储参数</primary>
    </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=df24f4d75bc1e412291a619001ed4e12 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=1607b0d259a07cfa4fbc93ecd9e73a35 sig_cn_org=None source=14.1 
     <para>
      Enables or disables vacuum to try to truncate off any empty pages
      at the end of this table. The default value is <literal>true</literal>.
      If <literal>true</literal>, <command>VACUUM</command> and
      autovacuum do the truncation and the disk space for
      the truncated pages is returned to the operating system.
      Note that the truncation requires <literal>ACCESS EXCLUSIVE</literal>
      lock on the table. The <literal>TRUNCATE</literal> parameter
      of <link linkend="sql-vacuum"><command>VACUUM</command></link>, if specified, overrides the value
      of this option.
     </para>
________________________________________________________-->
     <para>
      启用或禁用vacuum以尝试截断此表末尾的任何空页。默认值为<literal>true</literal>。
      如果<literal>true</literal>，<command>VACUUM</command>和autovacuum将执行截断，截断页的磁盘空间将返回到操作系统。
      请注意，截断需要 <literal>ACCESS EXCLUSIVE</literal>在表上锁定。
      <link linkend="sql-vacuum"><command>VACUUM</command></link>的<literal>TRUNCATE</literal>参数，如果指定，覆盖此选项的值。
     </para>
<!-- pgdoc-cn_end sig_en=1607b0d259a07cfa4fbc93ecd9e73a35 -->
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-vacuum-threshold" xreflabel="autovacuum_vacuum_threshold">
<!-- pgdoc-cn_start sig_en=98f6a1e8d2570706ad6aa0d42c58c0ee sig_cn_org=None source=14.1 
    <term><literal>autovacuum_vacuum_threshold</literal>, <literal>toast.autovacuum_vacuum_threshold</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_vacuum_threshold</varname></primary>
     <secondary>storage parameter</secondary>
    </indexterm>
    </term>
________________________________________________________-->
    <term><literal>autovacuum_vacuum_threshold</literal>, <literal>toast.autovacuum_vacuum_threshold</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_vacuum_threshold</varname></primary>
     <secondary>存储参数</secondary>
    </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=98f6a1e8d2570706ad6aa0d42c58c0ee -->
    <listitem>
<!-- pgdoc-cn_start sig_en=1e1069ea53850eed51bebf5fbdfe0cdf sig_cn_org=None source=14.1 
     <para>
      Per-table value for <xref linkend="guc-autovacuum-vacuum-threshold"/>
      parameter.
     </para>
________________________________________________________-->
     <para>
      <xref linkend="guc-autovacuum-vacuum-threshold"/>参数对于每个表的值。
     </para>
<!-- pgdoc-cn_end sig_en=1e1069ea53850eed51bebf5fbdfe0cdf -->
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-vacuum-scale-factor" xreflabel="autovacuum_vacuum_scale_factor">
<!-- pgdoc-cn_start sig_en=d830503df3a1ee485c4723e72dff3798 sig_cn_org=None source=14.1 
    <term><literal>autovacuum_vacuum_scale_factor</literal>, <literal>toast.autovacuum_vacuum_scale_factor</literal> (<type>floating point</type>)
    <indexterm>
     <primary><varname>autovacuum_vacuum_scale_factor</varname> </primary>
     <secondary>storage parameter</secondary>
    </indexterm>
    </term>
________________________________________________________-->
    <term><literal>autovacuum_vacuum_scale_factor</literal>, <literal>toast.autovacuum_vacuum_scale_factor</literal> (<type>floating point</type>)
    <indexterm>
     <primary><varname>autovacuum_vacuum_scale_factor</varname> </primary>
     <secondary>存储参数</secondary>
    </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=d830503df3a1ee485c4723e72dff3798 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=d843bb50b437fc57c6c19b7b7019144f sig_cn_org=None source=14.1 
     <para>
      Per-table value for <xref linkend="guc-autovacuum-vacuum-scale-factor"/>
      parameter.
     </para>
________________________________________________________-->
     <para>
      <xref linkend="guc-autovacuum-vacuum-scale-factor"/>参数对于每个表的值。
     </para>
<!-- pgdoc-cn_end sig_en=d843bb50b437fc57c6c19b7b7019144f -->
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-vacuum-insert-threshold" xreflabel="autovacuum_vacuum_insert_threshold">
<!-- pgdoc-cn_start sig_en=fe2231c04c3bd106ee19f51d00466e12 sig_cn_org=None source=14.1 
    <term><literal>autovacuum_vacuum_insert_threshold</literal>, <literal>toast.autovacuum_vacuum_insert_threshold</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_vacuum_insert_threshold</varname></primary>
     <secondary>storage parameter</secondary>
    </indexterm>
    </term>
________________________________________________________-->
    <term><literal>autovacuum_vacuum_insert_threshold</literal>, <literal>toast.autovacuum_vacuum_insert_threshold</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_vacuum_insert_threshold</varname></primary>
     <secondary>storage parameter</secondary>
    </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=fe2231c04c3bd106ee19f51d00466e12 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=58c6dffae06a8d11058eeed2c7020201 sig_cn_org=None source=14.1 
     <para>
      Per-table value for <xref linkend="guc-autovacuum-vacuum-insert-threshold"/>
      parameter.  The special value of -1 may be used to disable insert vacuums on the table.
     </para>
________________________________________________________-->
     <para>
      <xref linkend="guc-autovacuum-vacuum-insert-threshold"/>参数对于每个表的值。特殊值-1可用于禁用表上的插入为空。
     </para>
<!-- pgdoc-cn_end sig_en=58c6dffae06a8d11058eeed2c7020201 -->
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-vacuum-insert-scale-factor" xreflabel="autovacuum_vacuum_insert_scale_factor">
<!-- pgdoc-cn_start sig_en=e8caa76e918121a18ca7c54234696ba6 sig_cn_org=None source=14.1 
    <term><literal>autovacuum_vacuum_insert_scale_factor</literal>, <literal>toast.autovacuum_vacuum_insert_scale_factor</literal> (<type>floating point</type>)
    <indexterm>
     <primary><varname>autovacuum_vacuum_insert_scale_factor</varname> </primary>
     <secondary>storage parameter</secondary>
    </indexterm>
    </term>
________________________________________________________-->
    <term><literal>autovacuum_vacuum_insert_scale_factor</literal>, <literal>toast.autovacuum_vacuum_insert_scale_factor</literal> (<type>floating point</type>)
    <indexterm>
     <primary><varname>autovacuum_vacuum_insert_scale_factor</varname> </primary>
     <secondary>storage parameter</secondary>
    </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=e8caa76e918121a18ca7c54234696ba6 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=e9db1b2b589913d4445973b618b9cab4 sig_cn_org=None source=14.1 
     <para>
      Per-table value for <xref linkend="guc-autovacuum-vacuum-insert-scale-factor"/>
      parameter.
     </para>
________________________________________________________-->
     <para>
      <xref linkend="guc-autovacuum-vacuum-insert-scale-factor"/>参数对于每个表的值。
     </para>
<!-- pgdoc-cn_end sig_en=e9db1b2b589913d4445973b618b9cab4 -->
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-analyze-threshold" xreflabel="autovacuum_analyze_threshold">
<!-- pgdoc-cn_start sig_en=6049e2662fdc39956d149a62f396a82f sig_cn_org=None source=14.1 
    <term><literal>autovacuum_analyze_threshold</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_analyze_threshold</varname></primary>
     <secondary>storage parameter</secondary>
    </indexterm>
    </term>
________________________________________________________-->
    <term><literal>autovacuum_analyze_threshold</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_analyze_threshold</varname></primary>
     <secondary>存储参数</secondary>
    </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=6049e2662fdc39956d149a62f396a82f -->
    <listitem>
<!-- pgdoc-cn_start sig_en=ae7531cc03d0e92c13d7eafa1780bd32 sig_cn_org=None source=14.1 
     <para>
      Per-table value for <xref linkend="guc-autovacuum-analyze-threshold"/>
      parameter.
     </para>
________________________________________________________-->
     <para>
      <xref linkend="guc-autovacuum-analyze-threshold"/>参数对于每个表的值。
     </para>
<!-- pgdoc-cn_end sig_en=ae7531cc03d0e92c13d7eafa1780bd32 -->
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-analyze-scale-factor" xreflabel="autovacuum_analyze_scale_factor">
<!-- pgdoc-cn_start sig_en=a17c25e5c372e2ce0704f1301f8a641f sig_cn_org=None source=14.1 
    <term><literal>autovacuum_analyze_scale_factor</literal> (<type>floating point</type>)
    <indexterm>
     <primary><varname>autovacuum_analyze_scale_factor</varname></primary>
     <secondary>storage parameter</secondary>
    </indexterm>
    </term>
________________________________________________________-->
    <term><literal>autovacuum_analyze_scale_factor</literal> (<type>floating point</type>)
    <indexterm>
     <primary><varname>autovacuum_analyze_scale_factor</varname></primary>
     <secondary>存储参数</secondary>
    </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=a17c25e5c372e2ce0704f1301f8a641f -->
    <listitem>
<!-- pgdoc-cn_start sig_en=715a51b40c05641ed5e1fddfc1f2014b sig_cn_org=None source=14.1 
     <para>
      Per-table value for <xref linkend="guc-autovacuum-analyze-scale-factor"/>
      parameter.
     </para>
________________________________________________________-->
     <para>
      <xref linkend="guc-autovacuum-analyze-scale-factor"/>参数对于每个表的值。
     </para>
<!-- pgdoc-cn_end sig_en=715a51b40c05641ed5e1fddfc1f2014b -->
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-vacuum-cost-delay" xreflabel="autovacuum_vacuum_cost_delay">
<!-- pgdoc-cn_start sig_en=5faf8a2c8474d16df7326371e7b306ef sig_cn_org=None source=14.1 
    <term><literal>autovacuum_vacuum_cost_delay</literal>, <literal>toast.autovacuum_vacuum_cost_delay</literal> (<type>floating point</type>)
    <indexterm>
     <primary><varname>autovacuum_vacuum_cost_delay</varname></primary>
     <secondary>storage parameter</secondary>
    </indexterm>
    </term>
________________________________________________________-->
    <term><literal>autovacuum_vacuum_cost_delay</literal>, <literal>toast.autovacuum_vacuum_cost_delay</literal> (<type>floating point</type>)
    <indexterm>
     <primary><varname>autovacuum_vacuum_cost_delay</varname></primary>
     <secondary>存储参数</secondary>
    </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=5faf8a2c8474d16df7326371e7b306ef -->
    <listitem>
<!-- pgdoc-cn_start sig_en=b15ad573d6fbebba3fec4a586c0edbad sig_cn_org=None source=14.1 
     <para>
      Per-table value for <xref linkend="guc-autovacuum-vacuum-cost-delay"/>
      parameter.
     </para>
________________________________________________________-->
     <para>
      <xref linkend="guc-autovacuum-vacuum-cost-delay"/>参数对于每个表的值。
     </para>
<!-- pgdoc-cn_end sig_en=b15ad573d6fbebba3fec4a586c0edbad -->
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-vacuum-cost-limit" xreflabel="autovacuum_vacuum_cost_limit">
<!-- pgdoc-cn_start sig_en=b5481ad998813f801cd6df3f9f15c962 sig_cn_org=None source=14.1 
    <term><literal>autovacuum_vacuum_cost_limit</literal>, <literal>toast.autovacuum_vacuum_cost_limit</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_vacuum_cost_limit</varname></primary>
     <secondary>storage parameter</secondary>
    </indexterm>
    </term>
________________________________________________________-->
    <term><literal>autovacuum_vacuum_cost_limit</literal>, <literal>toast.autovacuum_vacuum_cost_limit</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_vacuum_cost_limit</varname></primary>
     <secondary>存储参数</secondary>
    </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=b5481ad998813f801cd6df3f9f15c962 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=ff7a6ac7b48de4f3b4a1e5faeb973fac sig_cn_org=None source=14.1 
     <para>
      Per-table value for <xref linkend="guc-autovacuum-vacuum-cost-limit"/>
      parameter.
     </para>
________________________________________________________-->
     <para>
      <xref linkend="guc-autovacuum-vacuum-cost-limit"/>参数对于每个表的值。
     </para>
<!-- pgdoc-cn_end sig_en=ff7a6ac7b48de4f3b4a1e5faeb973fac -->
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-freeze-min-age" xreflabel="autovacuum_freeze_min_age">
<!-- pgdoc-cn_start sig_en=142d2453d8193309c1d3edfb4a807a8e sig_cn_org=None source=14.1 
    <term><literal>autovacuum_freeze_min_age</literal>, <literal>toast.autovacuum_freeze_min_age</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_freeze_min_age</varname> storage parameter</primary>
    </indexterm>
    </term>
________________________________________________________-->
    <term><literal>autovacuum_freeze_min_age</literal>, <literal>toast.autovacuum_freeze_min_age</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_freeze_min_age</varname>存储参数</primary>
    </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=142d2453d8193309c1d3edfb4a807a8e -->
    <listitem>
<!-- pgdoc-cn_start sig_en=a0127630f62bbec0991af495367ba7e5 sig_cn_org=None source=14.1 
     <para>
      Per-table value for <xref linkend="guc-vacuum-freeze-min-age"/>
      parameter.  Note that autovacuum will ignore
      per-table <literal>autovacuum_freeze_min_age</literal> parameters that are
      larger than half the
      system-wide <xref linkend="guc-autovacuum-freeze-max-age"/> setting.
     </para>
________________________________________________________-->
     <para>
      <xref linkend="guc-vacuum-freeze-min-age"/>参数对于每个表的值。注意自动清理将忽略超过系统范围<xref linkend="guc-autovacuum-freeze-max-age"/>参数一半的针对每个表的<literal>autovacuum_freeze_min_age</literal>参数。
     </para>
<!-- pgdoc-cn_end sig_en=a0127630f62bbec0991af495367ba7e5 -->
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-freeze-max-age" xreflabel="autovacuum_freeze_max_age">
<!-- pgdoc-cn_start sig_en=b8415238ec88dcb80d4c090060f24b03 sig_cn_org=None source=14.1 
    <term><literal>autovacuum_freeze_max_age</literal>, <literal>toast.autovacuum_freeze_max_age</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_freeze_max_age</varname></primary>
     <secondary>storage parameter</secondary>
    </indexterm>
    </term>
________________________________________________________-->
    <term><literal>autovacuum_freeze_max_age</literal>, <literal>toast.autovacuum_freeze_max_age</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_freeze_max_age</varname></primary>
     <secondary>存储参数</secondary>
    </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=b8415238ec88dcb80d4c090060f24b03 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=ddd5c8c494ee7592dcb3e693766e8705 sig_cn_org=None source=14.1 
     <para>
      Per-table value for <xref linkend="guc-autovacuum-freeze-max-age"/>
      parameter.  Note that autovacuum will ignore
      per-table <literal>autovacuum_freeze_max_age</literal> parameters that are
      larger than the system-wide setting (it can only be set smaller).
     </para>
________________________________________________________-->
     <para>
      <xref linkend="guc-autovacuum-freeze-max-age"/>参数对于每个表的值。注意自动清理将忽略超过系统范围参数（只能被设置得较小）一半的针对每个表的<literal>autovacuum_freeze_max_age</literal>参数。
     </para>
<!-- pgdoc-cn_end sig_en=ddd5c8c494ee7592dcb3e693766e8705 -->
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-freeze-table-age" xreflabel="autovacuum_freeze_table_age">
<!-- pgdoc-cn_start sig_en=a40a67a535dd67b07e1fd257259487a1 sig_cn_org=None source=14.1 
    <term><literal>autovacuum_freeze_table_age</literal>, <literal>toast.autovacuum_freeze_table_age</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_freeze_table_age</varname> storage parameter</primary>
    </indexterm>
    </term>
________________________________________________________-->
    <term><literal>autovacuum_freeze_table_age</literal>, <literal>toast.autovacuum_freeze_table_age</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_freeze_table_age</varname>存储参数</primary>
    </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=a40a67a535dd67b07e1fd257259487a1 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=ae72f9992f7ae427a509163132aeec0f sig_cn_org=None source=14.1 
     <para>
      Per-table value for <xref linkend="guc-vacuum-freeze-table-age"/>
      parameter.
     </para>
________________________________________________________-->
     <para>
      <xref linkend="guc-vacuum-freeze-table-age"/>参数对于每个表的值。
     </para>
<!-- pgdoc-cn_end sig_en=ae72f9992f7ae427a509163132aeec0f -->
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-multixact-freeze-min-age" xreflabel="autovacuum_multixact_freeze_min_age">
<!-- pgdoc-cn_start sig_en=c15dde960c3b7d1747e2e3c0d65e8b5f sig_cn_org=None source=14.1 
    <term><literal>autovacuum_multixact_freeze_min_age</literal>, <literal>toast.autovacuum_multixact_freeze_min_age</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_multixact_freeze_min_age</varname> storage parameter</primary>
    </indexterm>
    </term>
________________________________________________________-->
    <term><literal>autovacuum_multixact_freeze_min_age</literal>, <literal>toast.autovacuum_multixact_freeze_min_age</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_multixact_freeze_min_age</varname> 存储参数</primary>
    </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=c15dde960c3b7d1747e2e3c0d65e8b5f -->
    <listitem>
<!-- pgdoc-cn_start sig_en=32dbc6946ed60c88fcd6eed26f088ddd sig_cn_org=None source=14.1 
     <para>
      Per-table value for <xref linkend="guc-vacuum-multixact-freeze-min-age"/>
      parameter.  Note that autovacuum will ignore
      per-table <literal>autovacuum_multixact_freeze_min_age</literal> parameters
      that are larger than half the
      system-wide <xref linkend="guc-autovacuum-multixact-freeze-max-age"/>
      setting.
     </para>
________________________________________________________-->
     <para>
      <xref linkend="guc-vacuum-multixact-freeze-min-age"/>参数对于每个表的值。注意自动清理将忽略超过系统范围<xref linkend="guc-autovacuum-multixact-freeze-max-age"/>参数一半的针对每个表的<literal>autovacuum_multixact_freeze_min_age</literal>参数。
     </para>
<!-- pgdoc-cn_end sig_en=32dbc6946ed60c88fcd6eed26f088ddd -->
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-multixact-freeze-max-age" xreflabel="autovacuum_multixact_freeze_max_age">
<!-- pgdoc-cn_start sig_en=c5f730d66f015a0371f6c3df2648d698 sig_cn_org=None source=14.1 
    <term><literal>autovacuum_multixact_freeze_max_age</literal>, <literal>toast.autovacuum_multixact_freeze_max_age</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_multixact_freeze_max_age</varname></primary>
     <secondary>storage parameter</secondary>
    </indexterm>
    </term>
________________________________________________________-->
    <term><literal>autovacuum_multixact_freeze_max_age</literal>, <literal>toast.autovacuum_multixact_freeze_max_age</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_multixact_freeze_max_age</varname></primary>
     <secondary>存储参数</secondary>
    </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=c5f730d66f015a0371f6c3df2648d698 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=5277478f39b5122e0d77b8ae1027fae4 sig_cn_org=None source=14.1 
     <para>
      Per-table value
      for <xref linkend="guc-autovacuum-multixact-freeze-max-age"/> parameter.
      Note that autovacuum will ignore
      per-table <literal>autovacuum_multixact_freeze_max_age</literal> parameters
      that are larger than the system-wide setting (it can only be set
      smaller).
     </para>
________________________________________________________-->
     <para>
      <xref linkend="guc-autovacuum-multixact-freeze-max-age"/>参数对于每个表的值。注意自动清理将忽略超过系统范围参数（只能被设置得较小）一半的针对每个表的<literal>autovacuum_multixact_freeze_max_age</literal>参数。
     </para>
<!-- pgdoc-cn_end sig_en=5277478f39b5122e0d77b8ae1027fae4 -->
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-autovacuum-multixact-freeze-table-age" xreflabel="autovacuum_multixact_freeze_table_age">
<!-- pgdoc-cn_start sig_en=4621adda161c63df1837d4105b3a2dba sig_cn_org=None source=14.1 
    <term><literal>autovacuum_multixact_freeze_table_age</literal>, <literal>toast.autovacuum_multixact_freeze_table_age</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_multixact_freeze_table_age</varname> storage parameter</primary>
    </indexterm>
    </term>
________________________________________________________-->
    <term><literal>autovacuum_multixact_freeze_table_age</literal>, <literal>toast.autovacuum_multixact_freeze_table_age</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>autovacuum_multixact_freeze_table_age</varname> 存储参数</primary>
    </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=4621adda161c63df1837d4105b3a2dba -->
    <listitem>
<!-- pgdoc-cn_start sig_en=179138115c3b354f908d8c919b5e0f41 sig_cn_org=None source=14.1 
     <para>
      Per-table value
      for <xref linkend="guc-vacuum-multixact-freeze-table-age"/> parameter.
     </para>
________________________________________________________-->
     <para>
      <xref linkend="guc-vacuum-multixact-freeze-table-age"/>参数对于每个表的值。
     </para>
<!-- pgdoc-cn_end sig_en=179138115c3b354f908d8c919b5e0f41 -->
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-log-autovacuum-min-duration" xreflabel="log_autovacuum_min_duration">
<!-- pgdoc-cn_start sig_en=d89f0aece93c8e3b8a7fcc8e48d502f8 sig_cn_org=None source=14.1 
    <term><literal>log_autovacuum_min_duration</literal>, <literal>toast.log_autovacuum_min_duration</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>log_autovacuum_min_duration</varname></primary>
     <secondary>storage parameter</secondary>
    </indexterm>
    </term>
________________________________________________________-->
    <term><literal>log_autovacuum_min_duration</literal>, <literal>toast.log_autovacuum_min_duration</literal> (<type>integer</type>)
    <indexterm>
     <primary><varname>log_autovacuum_min_duration</varname></primary>
     <secondary>存储参数</secondary>
    </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=d89f0aece93c8e3b8a7fcc8e48d502f8 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=be353b34089f6e1f8cd1d09944d83609 sig_cn_org=None source=14.1 
     <para>
      Per-table value for <xref linkend="guc-log-autovacuum-min-duration"/>
      parameter.
     </para>
________________________________________________________-->
     <para>
      <xref linkend="guc-log-autovacuum-min-duration"/>参数对于每个表的值。
     </para>
<!-- pgdoc-cn_end sig_en=be353b34089f6e1f8cd1d09944d83609 -->
    </listitem>
   </varlistentry>

   <varlistentry id="reloption-user-catalog-table" xreflabel="user_catalog_table">
<!-- pgdoc-cn_start sig_en=4f69811c172d5310224b7dba9ab5798d sig_cn_org=None source=14.1 
    <term><literal>user_catalog_table</literal> (<type>boolean</type>)
    <indexterm>
     <primary><varname>user_catalog_table</varname> storage parameter</primary>
    </indexterm>
    </term>
________________________________________________________-->
    <term><literal>user_catalog_table</literal> (<type>boolean</type>)
    <indexterm>
     <primary><varname>user_catalog_table</varname> 存储参数</primary>
    </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=4f69811c172d5310224b7dba9ab5798d -->
    <listitem>
<!-- pgdoc-cn_start sig_en=5f805b43a7e5a3827a9ff933bddd774c sig_cn_org=None source=14.1 
     <para>
      Declare the table as an additional catalog table for purposes of
      logical replication. See
      <xref linkend="logicaldecoding-capabilities"/> for details.
      This parameter cannot be set for TOAST tables.
     </para>
________________________________________________________-->
     <para>
      声明该表是一个用于逻辑复制目的的额外的目录表。详见<xref linkend="logicaldecoding-capabilities"/>。不能对 TOAST 表设置这个参数。
     </para>
<!-- pgdoc-cn_end sig_en=5f805b43a7e5a3827a9ff933bddd774c -->
    </listitem>
   </varlistentry>

   </variablelist>

  </refsect2>
 </refsect1>

 <refsect1 id="sql-createtable-notes">
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
  <title>Notes</title>
________________________________________________________-->
  <title>注解</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->
<!-- pgdoc-cn_start sig_en=35c27e3bb48ae9de8d3f8b9efe05299f sig_cn_org=None source=14.1 
    <para>
     <productname>PostgreSQL</productname> automatically creates an
     index for each unique constraint and primary key constraint to
     enforce uniqueness.  Thus, it is not necessary to create an
     index explicitly for primary key columns.  (See <xref
     linkend="sql-createindex"/> for more information.)
    </para>
________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>为每一个唯一约束和主键约束创建一个索引来强制唯一性。因此，没有必要显式地为主键列创建一个索引（详见<xref linkend="sql-createindex"/>）。
    </para>
<!-- pgdoc-cn_end sig_en=35c27e3bb48ae9de8d3f8b9efe05299f -->

<!-- pgdoc-cn_start sig_en=9a6c35ff910acc6a73a8c002fe2a1ee1 sig_cn_org=None source=14.1 
    <para>
     Unique constraints and primary keys are not inherited in the
     current implementation.  This makes the combination of
     inheritance and unique constraints rather dysfunctional.
    </para>
________________________________________________________-->
    <para>
     在当前的实现中，唯一约束和主键不会被继承。这使得继承和唯一约束的组合相当不正常。
    </para>
<!-- pgdoc-cn_end sig_en=9a6c35ff910acc6a73a8c002fe2a1ee1 -->

<!-- pgdoc-cn_start sig_en=35dde0bad8587d79b3dba5c2e3c762aa sig_cn_org=None source=14.1 
    <para>
     A table cannot have more than 1600 columns.  (In practice, the
     effective limit is usually lower because of tuple-length constraints.)
    </para>
________________________________________________________-->
    <para>
     一个表不能有超过 1600 列（实际上，由于元组长度限制，有效的限制通常更低）。
    </para>
<!-- pgdoc-cn_end sig_en=35dde0bad8587d79b3dba5c2e3c762aa -->

 </refsect1>


 <refsect1 id="sql-createtable-examples">
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
  <title>Examples</title>
________________________________________________________-->
  <title>例子</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=460ed37833c3d4e492d7cc1b0f4c8650 sig_cn_org=None source=14.1 
  <para>
   Create table <structname>films</structname> and table
   <structname>distributors</structname>:

<programlisting>
CREATE TABLE films (
    code        char(5) CONSTRAINT firstkey PRIMARY KEY,
    title       varchar(40) NOT NULL,
    did         integer NOT NULL,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute
);

CREATE TABLE distributors (
     did    integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
     name   varchar(40) NOT NULL CHECK (name &lt;&gt; '')
);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   创建表<structname>films</structname>和表<structname>distributors</structname>：

<programlisting>
CREATE TABLE films (
    code        char(5) CONSTRAINT firstkey PRIMARY KEY,
    title       varchar(40) NOT NULL,
    did         integer NOT NULL,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute
);

CREATE TABLE distributors (
     did    integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
     name   varchar(40) NOT NULL CHECK (name &lt;&gt; '')
);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=460ed37833c3d4e492d7cc1b0f4c8650 -->

<!-- pgdoc-cn_start sig_en=3c1afb1dcb076eff4de02f0af5992e58 sig_cn_org=None source=14.1 
  <para>
   Create a table with a 2-dimensional array:

<programlisting>
CREATE TABLE array_int (
    vector  int[][]
);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   创建有一个二维数组的表：

<programlisting>
CREATE TABLE array_int (
    vector  int[][]
);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=3c1afb1dcb076eff4de02f0af5992e58 -->

<!-- pgdoc-cn_start sig_en=e147150e1abf1547eac9ca68a84f5320 sig_cn_org=None source=14.1 
  <para>
   Define a unique table constraint for the table
   <literal>films</literal>.  Unique table constraints can be defined
   on one or more columns of the table:

<programlisting>
CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT production UNIQUE(date_prod)
);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   为表<literal>films</literal>定义一个唯一表约束。唯一表约束能够被定义在表的一列或多列上：

<programlisting>
CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT production UNIQUE(date_prod)
);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=e147150e1abf1547eac9ca68a84f5320 -->

<!-- pgdoc-cn_start sig_en=8cb6775ff4dfb7843e6ed0f0f08c6e40 sig_cn_org=None source=14.1 
  <para>
   Define a check column constraint:

<programlisting>
CREATE TABLE distributors (
    did     integer CHECK (did &gt; 100),
    name    varchar(40)
);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   定义一个列检查约束：

<programlisting>
CREATE TABLE distributors (
    did     integer CHECK (did &gt; 100),
    name    varchar(40)
);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=8cb6775ff4dfb7843e6ed0f0f08c6e40 -->

<!-- pgdoc-cn_start sig_en=cdcbac19ee1b51f9ebf7f3243db94710 sig_cn_org=None source=14.1 
  <para>
   Define a check table constraint:

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    CONSTRAINT con1 CHECK (did &gt; 100 AND name &lt;&gt; '')
);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   定义一个表检查约束：

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    CONSTRAINT con1 CHECK (did &gt; 100 AND name &lt;&gt; '')
);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=cdcbac19ee1b51f9ebf7f3243db94710 -->

<!-- pgdoc-cn_start sig_en=222d803008508d362b3344e063013889 sig_cn_org=None source=14.1 
  <para>
   Define a primary key table constraint for the table
   <structname>films</structname>:

<programlisting>
CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT code_title PRIMARY KEY(code,title)
);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   为表<structname>films</structname>定义一个主键表约束：

<programlisting>
CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT code_title PRIMARY KEY(code,title)
);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=222d803008508d362b3344e063013889 -->

<!-- pgdoc-cn_start sig_en=2fc1c79f99c3bd2166ef2ead7b776520 sig_cn_org=None source=14.1 
  <para>
   Define a primary key constraint for table
   <structname>distributors</structname>.  The following two examples are
   equivalent, the first using the table constraint syntax, the second
   the column constraint syntax:

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    PRIMARY KEY(did)
);

CREATE TABLE distributors (
    did     integer PRIMARY KEY,
    name    varchar(40)
);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   为表<structname>distributors</structname>定义一个主键约束。下面的两个例子是等价的，第一个使用表约束语法，第二个使用列约束语法：

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    PRIMARY KEY(did)
);

CREATE TABLE distributors (
    did     integer PRIMARY KEY,
    name    varchar(40)
);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=2fc1c79f99c3bd2166ef2ead7b776520 -->

<!-- pgdoc-cn_start sig_en=59f6478fa16191243e33e4e192d3b408 sig_cn_org=None source=14.1 
  <para>
   Assign a literal constant default value for the column
   <literal>name</literal>, arrange for the default value of column
   <literal>did</literal> to be generated by selecting the next value
   of a sequence object, and make the default value of
   <literal>modtime</literal> be the time at which the row is
   inserted:

<programlisting>
CREATE TABLE distributors (
    name      varchar(40) DEFAULT 'Luso Films',
    did       integer DEFAULT nextval('distributors_serial'),
    modtime   timestamp DEFAULT current_timestamp
);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   为列<literal>name</literal>赋予一个文字常量默认值，安排列<literal>did</literal>的默认值是从一个序列对象中选择下一个值产生，并且让<literal>modtime</literal>的默认值是该行被插入的时间：

<programlisting>
CREATE TABLE distributors (
    name      varchar(40) DEFAULT 'Luso Films',
    did       integer DEFAULT nextval('distributors_serial'),
    modtime   timestamp DEFAULT current_timestamp
);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=59f6478fa16191243e33e4e192d3b408 -->

<!-- pgdoc-cn_start sig_en=83bf69c99ab5ecc6ea9aa39cd81bb0f1 sig_cn_org=None source=14.1 
  <para>
   Define two <literal>NOT NULL</literal> column constraints on the table
   <classname>distributors</classname>, one of which is explicitly
   given a name:

<programlisting>
CREATE TABLE distributors (
    did     integer CONSTRAINT no_null NOT NULL,
    name    varchar(40) NOT NULL
);
</programlisting>
    </para>
________________________________________________________-->
  <para>
   在表<classname>distributors</classname>上定义两个<literal>NOT NULL</literal>列约束，其中之一被显式给定了一个名称：

<programlisting>
CREATE TABLE distributors (
    did     integer CONSTRAINT no_null NOT NULL,
    name    varchar(40) NOT NULL
);
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=83bf69c99ab5ecc6ea9aa39cd81bb0f1 -->

<!-- pgdoc-cn_start sig_en=a60abd1d5a1202c1f82c04c2c90200fa sig_cn_org=None source=14.1 
    <para>
     Define a unique constraint for the <literal>name</literal> column:

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40) UNIQUE
);
</programlisting>

     The same, specified as a table constraint:

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name)
);
</programlisting>
  </para>
________________________________________________________-->
    <para>
     为<literal>name</literal>列定义一个唯一约束：

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40) UNIQUE
);
</programlisting>

     同样的唯一约束用表约束指定：

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name)
);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=a60abd1d5a1202c1f82c04c2c90200fa -->

<!-- pgdoc-cn_start sig_en=0afdffc65071b7706967a55074ce96a8 sig_cn_org=None source=14.1 
  <para>
   Create the same table, specifying 70% fill factor for both the table
   and its unique index:

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name) WITH (fillfactor=70)
)
WITH (fillfactor=70);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   创建相同的表，指定表和它的唯一索引指定 70% 的填充因子：

<programlisting>
CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name) WITH (fillfactor=70)
)
WITH (fillfactor=70);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=0afdffc65071b7706967a55074ce96a8 -->

<!-- pgdoc-cn_start sig_en=e6be8d7213ace436484dca55f1c7cd82 sig_cn_org=None source=14.1 
  <para>
   Create table <structname>circles</structname> with an exclusion
   constraint that prevents any two circles from overlapping:

<programlisting>
CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   创建表<structname>circles</structname>，带有一个排除约束阻止任意两个圆重叠：

<programlisting>
CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=e6be8d7213ace436484dca55f1c7cd82 -->

<!-- pgdoc-cn_start sig_en=dbecf9c3678805c45c3a4e73762f5fcf sig_cn_org=None source=14.1 
  <para>
   Create table <structname>cinemas</structname> in tablespace <structname>diskvol1</structname>:

<programlisting>
CREATE TABLE cinemas (
        id serial,
        name text,
        location text
) TABLESPACE diskvol1;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   在表空间<structname>diskvol1</structname>中创建表<structname>cinemas</structname>：

<programlisting>
CREATE TABLE cinemas (
        id serial,
        name text,
        location text
) TABLESPACE diskvol1;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=dbecf9c3678805c45c3a4e73762f5fcf -->

<!-- pgdoc-cn_start sig_en=7982ece07904720a855eac9cdea36971 sig_cn_org=None source=14.1 
  <para>
   Create a composite type and a typed table:
<programlisting>
CREATE TYPE employee_type AS (name text, salary numeric);

CREATE TABLE employees OF employee_type (
    PRIMARY KEY (name),
    salary WITH OPTIONS DEFAULT 1000
);
</programlisting></para>
________________________________________________________-->
  <para>
   创建一个组合类型以及一个类型化的表：
<programlisting>
CREATE TYPE employee_type AS (name text, salary numeric);

CREATE TABLE employees OF employee_type (
    PRIMARY KEY (name),
    salary WITH OPTIONS DEFAULT 1000
);
</programlisting></para>
<!-- pgdoc-cn_end sig_en=7982ece07904720a855eac9cdea36971 -->

<!-- pgdoc-cn_start sig_en=8ebcede31351cf77ca3b6e79478a7368 sig_cn_org=None source=14.1 
  <para>
   Create a range partitioned table:
<programlisting>
CREATE TABLE measurement (
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (logdate);
</programlisting></para>
________________________________________________________-->
  <para>
   创建一个范围分区表：
<programlisting>
CREATE TABLE measurement (
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (logdate);
</programlisting></para>
<!-- pgdoc-cn_end sig_en=8ebcede31351cf77ca3b6e79478a7368 -->

<!-- pgdoc-cn_start sig_en=ddf735ef044f8991b89bdcd4ebf379f1 sig_cn_org=None source=14.1 
  <para>
   Create a range partitioned table with multiple columns in the partition key:
<programlisting>
CREATE TABLE measurement_year_month (
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (EXTRACT(YEAR FROM logdate), EXTRACT(MONTH FROM logdate));
</programlisting></para>
________________________________________________________-->
  <para>
   创建在分区键中具有多个列的范围分区表：
<programlisting>
CREATE TABLE measurement_year_month (
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (EXTRACT(YEAR FROM logdate), EXTRACT(MONTH FROM logdate));
</programlisting></para>
<!-- pgdoc-cn_end sig_en=ddf735ef044f8991b89bdcd4ebf379f1 -->

<!-- pgdoc-cn_start sig_en=d52fc69bd11035d1b675808ba73bfcee sig_cn_org=None source=14.1 
  <para>
   Create a list partitioned table:
<programlisting>
CREATE TABLE cities (
    city_id      bigserial not null,
    name         text not null,
    population   bigint
) PARTITION BY LIST (left(lower(name), 1));
</programlisting></para>
________________________________________________________-->
  <para>
   创建列表分区表：
<programlisting>
CREATE TABLE cities (
    city_id      bigserial not null,
    name         text not null,
    population   bigint
) PARTITION BY LIST (left(lower(name), 1));
</programlisting></para>
<!-- pgdoc-cn_end sig_en=d52fc69bd11035d1b675808ba73bfcee -->

<!-- pgdoc-cn_start sig_en=efff3aa3ebec8c88c454120bcbd4ca2b sig_cn_org=None source=14.1 
  <para>
   Create a hash partitioned table:
<programlisting>
CREATE TABLE orders (
    order_id     bigint not null,
    cust_id      bigint not null,
    status       text
) PARTITION BY HASH (order_id);
</programlisting></para>
________________________________________________________-->
  <para>
   建立哈希分区表:
<programlisting>
CREATE TABLE orders (
    order_id     bigint not null,
    cust_id      bigint not null,
    status       text
) PARTITION BY HASH (order_id);
</programlisting></para>
<!-- pgdoc-cn_end sig_en=efff3aa3ebec8c88c454120bcbd4ca2b -->

<!-- pgdoc-cn_start sig_en=1267258d6c2ba64ac956a1e7fbf1293b sig_cn_org=None source=14.1 
  <para>
   Create partition of a range partitioned table:
<programlisting>
CREATE TABLE measurement_y2016m07
    PARTITION OF measurement (
    unitsales DEFAULT 0
) FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
</programlisting></para>
________________________________________________________-->
  <para>
   创建范围分区表的分区：
<programlisting>
CREATE TABLE measurement_y2016m07
    PARTITION OF measurement (
    unitsales DEFAULT 0
) FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');
</programlisting></para>
<!-- pgdoc-cn_end sig_en=1267258d6c2ba64ac956a1e7fbf1293b -->

<!-- pgdoc-cn_start sig_en=12cddfe0b29ef893568037942fff982e sig_cn_org=None source=14.1 
  <para>
   Create a few partitions of a range partitioned table with multiple
   columns in the partition key:
<programlisting>
CREATE TABLE measurement_ym_older
    PARTITION OF measurement_year_month
    FOR VALUES FROM (MINVALUE, MINVALUE) TO (2016, 11);

CREATE TABLE measurement_ym_y2016m11
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2016, 11) TO (2016, 12);

CREATE TABLE measurement_ym_y2016m12
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2016, 12) TO (2017, 01);

CREATE TABLE measurement_ym_y2017m01
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2017, 01) TO (2017, 02);
</programlisting></para>
________________________________________________________-->
  <para>
   使用分区键中的多个列创建范围分区表的几个分区：
<programlisting>
CREATE TABLE measurement_ym_older
    PARTITION OF measurement_year_month
    FOR VALUES FROM (MINVALUE, MINVALUE) TO (2016, 11);

CREATE TABLE measurement_ym_y2016m11
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2016, 11) TO (2016, 12);

CREATE TABLE measurement_ym_y2016m12
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2016, 12) TO (2017, 01);

CREATE TABLE measurement_ym_y2017m01
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2017, 01) TO (2017, 02);
</programlisting></para>
<!-- pgdoc-cn_end sig_en=12cddfe0b29ef893568037942fff982e -->

<!-- pgdoc-cn_start sig_en=ff0efe0ae1313b45d20958fa340b0d89 sig_cn_org=None source=14.1 
  <para>
   Create partition of a list partitioned table:
<programlisting>
CREATE TABLE cities_ab
    PARTITION OF cities (
    CONSTRAINT city_id_nonzero CHECK (city_id != 0)
) FOR VALUES IN ('a', 'b');
</programlisting></para>
________________________________________________________-->
  <para>
   创建列表分区表的分区：
<programlisting>
CREATE TABLE cities_ab
    PARTITION OF cities (
    CONSTRAINT city_id_nonzero CHECK (city_id != 0)
) FOR VALUES IN ('a', 'b');
</programlisting></para>
<!-- pgdoc-cn_end sig_en=ff0efe0ae1313b45d20958fa340b0d89 -->

<!-- pgdoc-cn_start sig_en=201bd2da6b117528ddc1619aca1a8d28 sig_cn_org=None source=14.1 
  <para>
   Create partition of a list partitioned table that is itself further
   partitioned and then add a partition to it:
<programlisting>
CREATE TABLE cities_ab
    PARTITION OF cities (
    CONSTRAINT city_id_nonzero CHECK (city_id != 0)
) FOR VALUES IN ('a', 'b') PARTITION BY RANGE (population);

CREATE TABLE cities_ab_10000_to_100000
    PARTITION OF cities_ab FOR VALUES FROM (10000) TO (100000);
</programlisting></para>
________________________________________________________-->
  <para>
   创建本身是分区的列表分区表的分区，然后向其添加分区：
<programlisting>
CREATE TABLE cities_ab
    PARTITION OF cities (
    CONSTRAINT city_id_nonzero CHECK (city_id != 0)
) FOR VALUES IN ('a', 'b') PARTITION BY RANGE (population);

CREATE TABLE cities_ab_10000_to_100000
    PARTITION OF cities_ab FOR VALUES FROM (10000) TO (100000);
</programlisting></para>
<!-- pgdoc-cn_end sig_en=201bd2da6b117528ddc1619aca1a8d28 -->

<!-- pgdoc-cn_start sig_en=384521d2ec9671641be3cb717f72b8fc sig_cn_org=None source=14.1 
  <para>
   Create partitions of a hash partitioned table:
<programlisting>
CREATE TABLE orders_p1 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE orders_p2 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 1);
CREATE TABLE orders_p3 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE orders_p4 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 3);
</programlisting></para>
________________________________________________________-->
  <para>
   建立哈希分区表的分区：
<programlisting>
CREATE TABLE orders_p1 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 0);
CREATE TABLE orders_p2 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 1);
CREATE TABLE orders_p3 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 2);
CREATE TABLE orders_p4 PARTITION OF orders
    FOR VALUES WITH (MODULUS 4, REMAINDER 3);
</programlisting></para>
<!-- pgdoc-cn_end sig_en=384521d2ec9671641be3cb717f72b8fc -->

<!-- pgdoc-cn_start sig_en=4c2664c33fff92cbc3eee0ac9b10b088 sig_cn_org=None source=14.1 
  <para>
   Create a default partition:
<programlisting>
CREATE TABLE cities_partdef
    PARTITION OF cities DEFAULT;
</programlisting></para>
________________________________________________________-->
  <para>
   建立默认分区：
<programlisting>
CREATE TABLE cities_partdef
    PARTITION OF cities DEFAULT;
</programlisting></para>
<!-- pgdoc-cn_end sig_en=4c2664c33fff92cbc3eee0ac9b10b088 -->
 </refsect1>

 <refsect1 id="sql-createtable-compatibility" xreflabel="Compatibility">
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
  <title>Compatibility</title>
________________________________________________________-->
  <title>Compatibility</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=6d39fb78d68121f8b1f6b99fdc1f2959 sig_cn_org=None source=14.1 
  <para>
   The <command>CREATE TABLE</command> command conforms to the
   <acronym>SQL</acronym> standard, with exceptions listed below.
  </para>
________________________________________________________-->
  <para>
   <command>CREATE TABLE</command>命令遵从<acronym>SQL</acronym>标准，除了以下例外。
  </para>
<!-- pgdoc-cn_end sig_en=6d39fb78d68121f8b1f6b99fdc1f2959 -->

  <refsect2>
<!-- pgdoc-cn_start sig_en=e18ae3ca86d69df9ab604d54c7fd81cc sig_cn_org=None source=14.1 
   <title>Temporary Tables</title>
________________________________________________________-->
   <title>临时表</title>
<!-- pgdoc-cn_end sig_en=e18ae3ca86d69df9ab604d54c7fd81cc -->

<!-- pgdoc-cn_start sig_en=4107cf5e79e8e8f0c320aa11641ad8a1 sig_cn_org=None source=14.1 
   <para>
    Although the syntax of <literal>CREATE TEMPORARY TABLE</literal>
    resembles that of the SQL standard, the effect is not the same.  In the
    standard,
    temporary tables are defined just once and automatically exist (starting
    with empty contents) in every session that needs them.
    <productname>PostgreSQL</productname> instead
    requires each session to issue its own <literal>CREATE TEMPORARY
    TABLE</literal> command for each temporary table to be used.  This allows
    different sessions to use the same temporary table name for different
    purposes, whereas the standard's approach constrains all instances of a
    given temporary table name to have the same table structure.
   </para>
________________________________________________________-->
   <para>
    尽管<literal>CREATE TEMPORARY TABLE</literal>的语法很像 SQL 标准的语法，但事实是并不相同。在标准中，临时表只需要被定义一次并且会自动地存在（从空内容开始）于需要它们的每一个会话中。<productname>PostgreSQL</productname>则要求每一个会话为每一个要用的临时表发出它自己的<literal>CREATE TEMPORARY TABLE</literal>命令。这允许不同的会话为不同的目的使用相同的临时表名，而标准的方法约束一个给定临时表名的所有实例都必须具有相同的表结构。
   </para>
<!-- pgdoc-cn_end sig_en=4107cf5e79e8e8f0c320aa11641ad8a1 -->

<!-- pgdoc-cn_start sig_en=409f155f079662fb857f28977addbd17 sig_cn_org=None source=14.1 
   <para>
    The standard's definition of the behavior of temporary tables is
    widely ignored.  <productname>PostgreSQL</productname>'s behavior
    on this point is similar to that of several other SQL databases.
   </para>
________________________________________________________-->
   <para>
    标准中对于临时表行为的定义被广泛地忽略了。<productname>PostgreSQL</productname>在这一点上的行为和多种其他 SQL 数据库是相似的。
   </para>
<!-- pgdoc-cn_end sig_en=409f155f079662fb857f28977addbd17 -->

<!-- pgdoc-cn_start sig_en=0c86acc8b484e4544860d0044bcede46 sig_cn_org=None source=14.1 
   <para>
    The SQL standard also distinguishes between global and local temporary
    tables, where a local temporary table has a separate set of contents for
    each SQL module within each session, though its definition is still shared
    across sessions.  Since <productname>PostgreSQL</productname> does not
    support SQL modules, this distinction is not relevant in
    <productname>PostgreSQL</productname>.
   </para>
________________________________________________________-->
   <para>
    SQL 标准也区分全局和局部临时表，其中一个局部临时表为每一个会话中的每一个 SQL 模块具有一个独立的内容集合，但是它的定义仍然是多个会话共享的。因为<productname>PostgreSQL</productname>不支持 SQL 模块，这种区别与<productname>PostgreSQL</productname>无关。
   </para>
<!-- pgdoc-cn_end sig_en=0c86acc8b484e4544860d0044bcede46 -->

<!-- pgdoc-cn_start sig_en=99097574234cd1aae55a3d99fa85d9c8 sig_cn_org=None source=14.1 
   <para>
    For compatibility's sake, <productname>PostgreSQL</productname> will
    accept the <literal>GLOBAL</literal> and <literal>LOCAL</literal> keywords
    in a temporary table declaration, but they currently have no effect.
    Use of these keywords is discouraged, since future versions of
    <productname>PostgreSQL</productname> might adopt a more
    standard-compliant interpretation of their meaning.
   </para>
________________________________________________________-->
   <para>
    为了兼容性目的，<productname>PostgreSQL</productname>将在临时表声明中接受<literal>GLOBAL</literal>和<literal>LOCAL</literal>关键词，但是它们当前没有效果。我们不鼓励使用这些关键词，因为未来版本的<productname>PostgreSQL</productname>可能采用一种更兼容标准的（对它们含义的）解释。
   </para>
<!-- pgdoc-cn_end sig_en=99097574234cd1aae55a3d99fa85d9c8 -->

<!-- pgdoc-cn_start sig_en=a5a9d69f5f61fa618dcda48a7d50dc9a sig_cn_org=None source=14.1 
   <para>
    The <literal>ON COMMIT</literal> clause for temporary tables
    also resembles the SQL standard, but has some differences.
    If the <literal>ON COMMIT</literal> clause is omitted, SQL specifies that the
    default behavior is <literal>ON COMMIT DELETE ROWS</literal>.  However, the
    default behavior in <productname>PostgreSQL</productname> is
    <literal>ON COMMIT PRESERVE ROWS</literal>.  The <literal>ON COMMIT
    DROP</literal> option does not exist in SQL.
   </para>
________________________________________________________-->
   <para>
    临时表的<literal>ON COMMIT</literal>子句也和 SQL 标准相似，但是有一些不同。如果忽略<literal>ON COMMIT</literal>子句，SQL 指定默认行为是<literal>ON COMMIT DELETE ROWS</literal>。但是，<productname>PostgreSQL</productname>中的默认行为是<literal>ON COMMIT PRESERVE ROWS</literal>。SQL 中不存在<literal>ON COMMIT DROP</literal>选项。
   </para>
<!-- pgdoc-cn_end sig_en=a5a9d69f5f61fa618dcda48a7d50dc9a -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=4a6f19a7d305d95582df7002675ca824 sig_cn_org=None source=14.1 
   <title>Non-Deferred Uniqueness Constraints</title>
________________________________________________________-->
   <title>非延迟唯一性约束</title>
<!-- pgdoc-cn_end sig_en=4a6f19a7d305d95582df7002675ca824 -->

<!-- pgdoc-cn_start sig_en=830808b444235d1de25974214d8309ab sig_cn_org=None source=14.1 
   <para>
    When a <literal>UNIQUE</literal> or <literal>PRIMARY KEY</literal> constraint is
    not deferrable, <productname>PostgreSQL</productname> checks for
    uniqueness immediately whenever a row is inserted or modified.
    The SQL standard says that uniqueness should be enforced only at
    the end of the statement; this makes a difference when, for example,
    a single command updates multiple key values.  To obtain
    standard-compliant behavior, declare the constraint as
    <literal>DEFERRABLE</literal> but not deferred (i.e., <literal>INITIALLY
    IMMEDIATE</literal>).  Be aware that this can be significantly slower than
    immediate uniqueness checking.
   </para>
________________________________________________________-->
   <para>
    但一个<literal>UNIQUE</literal>或<literal>PRIMARY KEY</literal>约束是非可延迟的，只要一个行被插入或修改，<productname>PostgreSQL</productname>就会立即检查唯一性。SQL 标准指出只有在语句结束时才应该强制唯一性。当一个单一命令更新多个键值时，这两者是不同的。要得到兼容标准的行为，将该约束声明为<literal>DEFERRABLE</literal>但是不延迟（即<literal>INITIALLY IMMEDIATE</literal>）。注意这可能要显著地慢于立即唯一性检查。
   </para>
<!-- pgdoc-cn_end sig_en=830808b444235d1de25974214d8309ab -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=ccf7cdce7895cf4487e02cbf7cfc9da9 sig_cn_org=None source=14.1 
   <title>Column Check Constraints</title>
________________________________________________________-->
   <title>列检查约束</title>
<!-- pgdoc-cn_end sig_en=ccf7cdce7895cf4487e02cbf7cfc9da9 -->

<!-- pgdoc-cn_start sig_en=1dc2dd46dfdba133b4ba449ea622e29a sig_cn_org=None source=14.1 
   <para>
    The SQL standard says that <literal>CHECK</literal> column constraints
    can only refer to the column they apply to; only <literal>CHECK</literal>
    table constraints can refer to multiple columns.
    <productname>PostgreSQL</productname> does not enforce this
    restriction; it treats column and table check constraints alike.
   </para>
________________________________________________________-->
   <para>
    SQL 标准指出<literal>CHECK</literal>列约束只能引用它们应用到的列，只有<literal>CHECK</literal>表约束能够引用多列。<productname>PostgreSQL</productname>并没有强制这个限制，它同样处理列检查约束和表检查约束。
   </para>
<!-- pgdoc-cn_end sig_en=1dc2dd46dfdba133b4ba449ea622e29a -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=c5e7a0860cd5afbf892ce6edc7298b99 sig_cn_org=None source=14.1 
   <title><literal>EXCLUDE</literal> Constraint</title>
________________________________________________________-->
   <title><literal>EXCLUDE</literal> 约束</title>
<!-- pgdoc-cn_end sig_en=c5e7a0860cd5afbf892ce6edc7298b99 -->

<!-- pgdoc-cn_start sig_en=e2d57156b214ab69bf4f86f292de0821 sig_cn_org=None source=14.1 
   <para>
    The <literal>EXCLUDE</literal> constraint type is a
    <productname>PostgreSQL</productname> extension.
   </para>
________________________________________________________-->
   <para>
    <literal>EXCLUDE</literal>约束类型是一种<productname>PostgreSQL</productname>扩展。
   </para>
<!-- pgdoc-cn_end sig_en=e2d57156b214ab69bf4f86f292de0821 -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=167d7b92e5facc2154706431520c3ade sig_cn_org=d0f421e30c99ec8caaf88a5bcc77f5d0 source=15.7 
   <title>Foreign Key Constraints</title>
________________________________________________________-->
   <title>外键约束</title>
<!-- pgdoc-cn_end sig_en=167d7b92e5facc2154706431520c3ade -->

<!-- pgdoc-cn_start sig_en=91453da0d2d9ce5e5de03611ff470369 sig_cn_org=d167cd9591ac19b4b1023b2726ce19f9 source=15.7 
   <para>
    The ability to specify column lists in the foreign key actions
    <literal>SET DEFAULT</literal> and <literal>SET NULL</literal> is a
    <productname>PostgreSQL</productname> extension.
   </para>
________________________________________________________-->
   <para>
    在外键操作中指定列列表的能力<literal>SET DEFAULT</literal>和<literal>SET NULL</literal>是一个<productname>PostgreSQL</productname>扩展。
</para>
<!-- pgdoc-cn_end sig_en=91453da0d2d9ce5e5de03611ff470369 -->

<!-- pgdoc-cn_start sig_en=1e6844321c3b7fd50a3df9df9de44e01 sig_cn_org=38b2141ee8e8bcfc9d9d6786c8bb61e8 source=15.7 
   <para>
    It is a <productname>PostgreSQL</productname> extension that a
    foreign key constraint may reference columns of a unique index instead of
    columns of a primary key or unique constraint.
   </para>
________________________________________________________-->
   <para>
    它是一个<productname>PostgreSQL</productname>扩展，外键约束可以引用唯一索引的列，而不是主键或唯一约束的列。
   </para>
<!-- pgdoc-cn_end sig_en=1e6844321c3b7fd50a3df9df9de44e01 -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=575f60a30cf87a9c581c9c025da2af3d sig_cn_org=None source=14.1 
   <title><literal>NULL</literal> <quote>Constraint</quote></title>
________________________________________________________-->
   <title><literal>NULL</literal> <quote>约束</quote></title>
<!-- pgdoc-cn_end sig_en=575f60a30cf87a9c581c9c025da2af3d -->

<!-- pgdoc-cn_start sig_en=31c9b398de060486f57bb04dd6c71426 sig_cn_org=None source=14.1 
   <para>
    The <literal>NULL</literal> <quote>constraint</quote> (actually a
    non-constraint) is a <productname>PostgreSQL</productname>
    extension to the SQL standard that is included for compatibility with some
    other database systems (and for symmetry with the <literal>NOT
    NULL</literal> constraint).  Since it is the default for any
    column, its presence is simply noise.
   </para>
________________________________________________________-->
   <para>
    <literal>NULL</literal> <quote>约束</quote>（实际上是一个非约束）是一个<productname>PostgreSQL</productname>对 SQL 标准的扩展，它也被包括（以及对称的<literal>NOT NULL</literal>约束）在一些其他的数据库系统中以实现兼容性。因为它是任意列的默认值，它的存在就像噪声一样。
   </para>
<!-- pgdoc-cn_end sig_en=31c9b398de060486f57bb04dd6c71426 -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=33ffa397fbe7c97743ecae7466e1ceb6 sig_cn_org=None source=14.1 
   <title>Constraint Naming</title>
________________________________________________________-->
   <title>Constraint Naming</title>
<!-- pgdoc-cn_end sig_en=33ffa397fbe7c97743ecae7466e1ceb6 -->

<!-- pgdoc-cn_start sig_en=ee8720fae361b58354998e4e2d5d930f sig_cn_org=None source=14.1 
   <para>
    The SQL standard says that table and domain constraints must have names
    that are unique across the schema containing the table or domain.
    <productname>PostgreSQL</productname> is laxer: it only requires
    constraint names to be unique across the constraints attached to a
    particular table or domain.  However, this extra freedom does not exist
    for index-based constraints (<literal>UNIQUE</literal>,
    <literal>PRIMARY KEY</literal>, and <literal>EXCLUDE</literal>
    constraints), because the associated index is named the same as the
    constraint, and index names must be unique across all relations within
    the same schema.
   </para>
________________________________________________________-->
   <para>
    SQL标准规定在包含表或域的模式范围内表和域的约束必须具有唯一的名称。
    <productname>PostgreSQL</productname>是比较宽松的：它只需要约束名称在附加到特定表或域的约束之间是唯一的。
    但是，对于基于索引的约束(<literal>UNIQUE</literal>,<literal>PRIMARY KEY</literal>, and <literal>EXCLUDE</literal>constraints)，
    这个特别的自由度并不存在，因为关联的索引被命名为与约束相同的名称，并且索引名称在相同模式的所有关系中必须是唯一的。  
   </para>
<!-- pgdoc-cn_end sig_en=ee8720fae361b58354998e4e2d5d930f -->

<!-- pgdoc-cn_start sig_en=b2eb0e1c2a16bf852c45ff3d6611fe85 sig_cn_org=None source=14.1 
   <para>
    Currently, <productname>PostgreSQL</productname> does not record names
    for <literal>NOT NULL</literal> constraints at all, so they are not
    subject to the uniqueness restriction.  This might change in a future
    release.
   </para>
________________________________________________________-->
   <para>
    当前，<productname>PostgreSQL</productname>没有记录<literal>NOT NULL</literal>约束的名称，因此它们不受唯一性限制的影响。
    这在将来的版本中可能会改变。 
   </para>
<!-- pgdoc-cn_end sig_en=b2eb0e1c2a16bf852c45ff3d6611fe85 -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=402ce8e5e5c53d3b32e1e9b0026d33d1 sig_cn_org=None source=14.1 
   <title>Inheritance</title>
________________________________________________________-->
   <title>继承</title>
<!-- pgdoc-cn_end sig_en=402ce8e5e5c53d3b32e1e9b0026d33d1 -->

<!-- pgdoc-cn_start sig_en=40610be90f12131b72a374ce46588231 sig_cn_org=None source=14.1 
   <para>
    Multiple inheritance via the <literal>INHERITS</literal> clause is
    a <productname>PostgreSQL</productname> language extension.
    SQL:1999 and later define single inheritance using a
    different syntax and different semantics.  SQL:1999-style
    inheritance is not yet supported by
    <productname>PostgreSQL</productname>.
   </para>
________________________________________________________-->
   <para>
    通过<literal>INHERITS</literal>子句的多继承是一种<productname>PostgreSQL</productname>的语言扩展。SQL:1999 以及之后的标准使用一种不同的语法和不同的语义定义了单继承。SQL:1999-风格的继承还没有被<productname>PostgreSQL</productname>。
   </para>
<!-- pgdoc-cn_end sig_en=40610be90f12131b72a374ce46588231 -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=e5adec2f306a3f0862ac72d0659c7bef sig_cn_org=None source=14.1 
   <title>Zero-Column Tables</title>
________________________________________________________-->
   <title>零列表</title>
<!-- pgdoc-cn_end sig_en=e5adec2f306a3f0862ac72d0659c7bef -->

<!-- pgdoc-cn_start sig_en=9619d4a70129eb6dbfe055e4c24b95df sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> allows a table of no columns
    to be created (for example, <literal>CREATE TABLE foo();</literal>).  This
    is an extension from the SQL standard, which does not allow zero-column
    tables.  Zero-column tables are not in themselves very useful, but
    disallowing them creates odd special cases for <command>ALTER TABLE
    DROP COLUMN</command>, so it seems cleaner to ignore this spec restriction.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>允许创建一个没有列的表（例如<literal>CREATE TABLE foo();</literal>）。这是一个对于 SQL 标准的扩展，它不允许零列表。零列表本身并不是很有用，但是不允许它们会为<command>ALTER TABLE DROP COLUMN</command>带来奇怪的特殊情况，因此忽略这种规则限制看起来更加整洁。
   </para>
<!-- pgdoc-cn_end sig_en=9619d4a70129eb6dbfe055e4c24b95df -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=76e575dcdddfb81c74fe89bef73b7b58 sig_cn_org=None source=14.1 
   <title>Multiple Identity Columns</title>
________________________________________________________-->
   <title>多个标识列</title>
<!-- pgdoc-cn_end sig_en=76e575dcdddfb81c74fe89bef73b7b58 -->

<!-- pgdoc-cn_start sig_en=1e222c32a808988a45af8abe4a9cfd3a sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> allows a table to have more than one
    identity column.  The standard specifies that a table can have at most one
    identity column.  This is relaxed mainly to give more flexibility for
    doing schema changes or migrations.  Note that
    the <command>INSERT</command> command supports only one override clause
    that applies to the entire statement, so having multiple identity columns
    with different behaviors is not well supported.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>允许一个表拥有多个标识列。
    该标准指定一个表最多只能有一个标识列。
    这主要是为了给模式更改或迁移提供更大的灵活性。
    请注意，<command>INSERT</command>命令仅支持一个适用于整个语句的覆盖子句，因此不支持具有不同行为的多个标识列。
   </para>
<!-- pgdoc-cn_end sig_en=1e222c32a808988a45af8abe4a9cfd3a -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=a45a8965a5cd9b3db4869bda7f83fb5c sig_cn_org=None source=14.1 
   <title>Generated Columns</title>
________________________________________________________-->
   <title>Generated Columns</title>
<!-- pgdoc-cn_end sig_en=a45a8965a5cd9b3db4869bda7f83fb5c -->

<!-- pgdoc-cn_start sig_en=dcca63d39c1d5b604b279db5ef1b06fc sig_cn_org=None source=14.1 
   <para>
    The option <literal>STORED</literal> is not standard but is also used by
    other SQL implementations.  The SQL standard does not specify the storage
    of generated columns.
   </para>
________________________________________________________-->
   <para>
    <literal>STORED</literal>选项不是标准，但也用于其他 SQL 实现。 SQL 标准不规定生成列的存储。
   </para>
<!-- pgdoc-cn_end sig_en=dcca63d39c1d5b604b279db5ef1b06fc -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=6fcfa10c9879e9c405752fadc3e95bbe sig_cn_org=None source=14.1 
   <title><literal>LIKE</literal> Clause</title>
________________________________________________________-->
   <title><literal>LIKE</literal> 子句</title>
<!-- pgdoc-cn_end sig_en=6fcfa10c9879e9c405752fadc3e95bbe -->

<!-- pgdoc-cn_start sig_en=53c1efb7f79229fc95ad7cf743a47ffe sig_cn_org=None source=14.1 
   <para>
    While a <literal>LIKE</literal> clause exists in the SQL standard, many of the
    options that <productname>PostgreSQL</productname> accepts for it are not
    in the standard, and some of the standard's options are not implemented
    by <productname>PostgreSQL</productname>.
   </para>
________________________________________________________-->
   <para>
    虽然 SQL 标准中有一个<literal>LIKE</literal>子句，但是<productname>PostgreSQL</productname>接受的很多<literal>LIKE</literal>子句选项却不在标准中，并且有些标准中的选项也没有被<productname>PostgreSQL</productname>实现。
   </para>
<!-- pgdoc-cn_end sig_en=53c1efb7f79229fc95ad7cf743a47ffe -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=ce0b5c87d02b944e51865a12f85bea11 sig_cn_org=None source=14.1 
   <title><literal>WITH</literal> Clause</title>
________________________________________________________-->
   <title><literal>WITH</literal>子句</title>
<!-- pgdoc-cn_end sig_en=ce0b5c87d02b944e51865a12f85bea11 -->

<!-- pgdoc-cn_start sig_en=3f5785cf17c75545c9991f790a4a2c47 sig_cn_org=None source=14.1 
   <para>
    The <literal>WITH</literal> clause is a <productname>PostgreSQL</productname>
    extension; storage parameters are not in the standard.
   </para>
________________________________________________________-->
   <para>
    <literal>WITH</literal>子句是一个<productname>PostgreSQL</productname>扩展，存储参数不在标准中。
   </para>
<!-- pgdoc-cn_end sig_en=3f5785cf17c75545c9991f790a4a2c47 -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=9373e1f8f4f298333d3310ce024466f5 sig_cn_org=None source=14.1 
   <title>Tablespaces</title>
________________________________________________________-->
   <title>表空间</title>
<!-- pgdoc-cn_end sig_en=9373e1f8f4f298333d3310ce024466f5 -->

<!-- pgdoc-cn_start sig_en=4446360df52e30fe61a79e134346844d sig_cn_org=None source=14.1 
   <para>
    The <productname>PostgreSQL</productname> concept of tablespaces is not
    part of the standard.  Hence, the clauses <literal>TABLESPACE</literal>
    and <literal>USING INDEX TABLESPACE</literal> are extensions.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>的表空间概念不是标准的一部分。因此，子句<literal>TABLESPACE</literal>和<literal>USING INDEX TABLESPACE</literal>是扩展。
   </para>
<!-- pgdoc-cn_end sig_en=4446360df52e30fe61a79e134346844d -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=d4c05dc9eac208da13d354e27a2cc911 sig_cn_org=None source=14.1 
   <title>Typed Tables</title>
________________________________________________________-->
   <title>类型化的表</title>
<!-- pgdoc-cn_end sig_en=d4c05dc9eac208da13d354e27a2cc911 -->

<!-- pgdoc-cn_start sig_en=0dd9c140da3e56484e44d258ffb3f3ff sig_cn_org=None source=14.1 
   <para>
    Typed tables implement a subset of the SQL standard.  According to
    the standard, a typed table has columns corresponding to the
    underlying composite type as well as one other column that is
    the <quote>self-referencing column</quote>.
    <productname>PostgreSQL</productname> does not support self-referencing
    columns explicitly.
   </para>
________________________________________________________-->
   <para>
    类型化的表实现了 SQL 标准的一个子集。根据标准，一个类型化的表具有与底层组合类型相对应的列，以及其他的<quote>自引用列</quote>。<productname>PostgreSQL</productname>不显式支持自引用列。
   </para>
<!-- pgdoc-cn_end sig_en=0dd9c140da3e56484e44d258ffb3f3ff -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=6545712fe740a6bb7ef5a7f7117862c7 sig_cn_org=None source=14.1 
   <title><literal>PARTITION BY</literal> Clause</title>
________________________________________________________-->
   <title><literal>PARTITION BY</literal> 子句</title>
<!-- pgdoc-cn_end sig_en=6545712fe740a6bb7ef5a7f7117862c7 -->

<!-- pgdoc-cn_start sig_en=edd3a38fd8634f5e457ec040ad1729b2 sig_cn_org=None source=14.1 
   <para>
    The <literal>PARTITION BY</literal> clause is a
    <productname>PostgreSQL</productname> extension.
   </para>
________________________________________________________-->
   <para>
    <literal>PARTITION BY</literal>子句是<productname>PostgreSQL</productname>的一个扩展。
   </para>
<!-- pgdoc-cn_end sig_en=edd3a38fd8634f5e457ec040ad1729b2 -->
  </refsect2>

  <refsect2>
<!-- pgdoc-cn_start sig_en=276211f673f0c34b59c165cfd7317602 sig_cn_org=None source=14.1 
   <title><literal>PARTITION OF</literal> Clause</title>
________________________________________________________-->
   <title><literal>PARTITION OF</literal> 子句</title>
<!-- pgdoc-cn_end sig_en=276211f673f0c34b59c165cfd7317602 -->

<!-- pgdoc-cn_start sig_en=f6134d1dd63ba7bad41498b106bbba35 sig_cn_org=None source=14.1 
   <para>
    The <literal>PARTITION OF</literal> clause is a
    <productname>PostgreSQL</productname> extension.
   </para>
________________________________________________________-->
   <para>
    <literal>PARTITION OF</literal>子句<productname>PostgreSQL</productname>的一个扩展。
   </para>
<!-- pgdoc-cn_end sig_en=f6134d1dd63ba7bad41498b106bbba35 -->
  </refsect2>

 </refsect1>


 <refsect1>
<!-- pgdoc-cn_start sig_en=8b7cc214676b443e6527e3d6bf054420 sig_cn_org=None source=14.1 
  <title>See Also</title>
________________________________________________________-->
  <title>参见</title>
<!-- pgdoc-cn_end sig_en=8b7cc214676b443e6527e3d6bf054420 -->

  <simplelist type="inline">
   <member><xref linkend="sql-altertable"/></member>
   <member><xref linkend="sql-droptable"/></member>
   <member><xref linkend="sql-createtableas"/></member>
   <member><xref linkend="sql-createtablespace"/></member>
   <member><xref linkend="sql-createtype"/></member>
  </simplelist>
 </refsect1>
</refentry>
