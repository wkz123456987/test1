<!--
doc/src/sgml/ref/create_trigger.sgml
PostgreSQL documentation
-->

<refentry id="sql-createtrigger">
<!-- pgdoc-cn_start sig_en=a29973e29fe21daece1ce396d6d59328 sig_cn_org=None source=14.1 
 <indexterm zone="sql-createtrigger">
  <primary>CREATE TRIGGER</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="sql-createtrigger">
  <primary>CREATE TRIGGER</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=a29973e29fe21daece1ce396d6d59328 -->

<!-- pgdoc-cn_start sig_en=9c335dd6839398402741e575aa281d9d sig_cn_org=None source=14.1 
 <indexterm>
  <primary>transition tables</primary>
  <seealso>ephemeral named relation</seealso>
 </indexterm>
________________________________________________________-->
 <indexterm>
  <primary>transition tables</primary>
  <seealso>ephemeral named relation</seealso>
 </indexterm>
<!-- pgdoc-cn_end sig_en=9c335dd6839398402741e575aa281d9d -->

 <refmeta>
  <refentrytitle>CREATE TRIGGER</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

<!-- pgdoc-cn_start sig_en=99f256323e46f962588a3969ba3089bc sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>CREATE TRIGGER</refname>
  <refpurpose>define a new trigger</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>CREATE TRIGGER</refname>
  <refpurpose>定义一个新触发器</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=99f256323e46f962588a3969ba3089bc -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=477b42a04a0f5d009969b1609b3a65c9 sig_cn_org=None source=14.1 
<synopsis>
CREATE [ OR REPLACE ] [ CONSTRAINT ] TRIGGER <replaceable class="parameter">name</replaceable> { BEFORE | AFTER | INSTEAD OF } { <replaceable class="parameter">event</replaceable> [ OR ... ] }
    ON <replaceable class="parameter">table_name</replaceable>
    [ FROM <replaceable class="parameter">referenced_table_name</replaceable> ]
    [ NOT DEFERRABLE | [ DEFERRABLE ] [ INITIALLY IMMEDIATE | INITIALLY DEFERRED ] ]
    [ REFERENCING { { OLD | NEW } TABLE [ AS ] <replaceable class="parameter">transition_relation_name</replaceable> } [ ... ] ]
    [ FOR [ EACH ] { ROW | STATEMENT } ]
    [ WHEN ( <replaceable class="parameter">condition</replaceable> ) ]
    EXECUTE { FUNCTION | PROCEDURE } <replaceable class="parameter">function_name</replaceable> ( <replaceable class="parameter">arguments</replaceable> )

<phrase>where <replaceable class="parameter">event</replaceable> can be one of:</phrase>

    INSERT
    UPDATE [ OF <replaceable class="parameter">column_name</replaceable> [, ... ] ]
    DELETE
    TRUNCATE
</synopsis>
________________________________________________________-->
<synopsis>
CREATE [ OR REPLACE ] [ CONSTRAINT ] TRIGGER <replaceable class="parameter">name</replaceable> { BEFORE | AFTER | INSTEAD OF } { <replaceable class="parameter">event</replaceable> [ OR ... ] }
    ON <replaceable class="parameter">table_name</replaceable>
    [ FROM <replaceable class="parameter">referenced_table_name</replaceable> ]
    [ NOT DEFERRABLE | [ DEFERRABLE ] [ INITIALLY IMMEDIATE | INITIALLY DEFERRED ] ]
    [ REFERENCING { { OLD | NEW } TABLE [ AS ] <replaceable class="parameter">transition_relation_name</replaceable> } [ ... ] ]
    [ FOR [ EACH ] { ROW | STATEMENT } ]
    [ WHEN ( <replaceable class="parameter">condition</replaceable> ) ]
    EXECUTE { FUNCTION | PROCEDURE } <replaceable class="parameter">function_name</replaceable> ( <replaceable class="parameter">arguments</replaceable> )

<phrase>这里的<replaceable class="parameter">event</replaceable>可以是下列之一：</phrase>

    INSERT
    UPDATE [ OF <replaceable class="parameter">column_name</replaceable> [, ... ] ]
    DELETE
    TRUNCATE
</synopsis>
<!-- pgdoc-cn_end sig_en=477b42a04a0f5d009969b1609b3a65c9 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=aa4e4d46c757a45a0dd231f9c9d64935 sig_cn_org=None source=14.1 
  <para>
   <command>CREATE TRIGGER</command> creates a new trigger.
   <command>CREATE OR REPLACE TRIGGER</command> will either create a
   new trigger, or replace an existing trigger.  The
   trigger will be associated with the specified table, view, or foreign table
   and will execute the specified
   function <replaceable class="parameter">function_name</replaceable> when
   certain operations are performed on that table.
  </para>
________________________________________________________-->
  <para>
   <command>CREATE TRIGGER</command>创建一个新触发器。
   <command>CREATE OR REPLACE TRIGGER</command> 将创建一个新触发器，或者替换一个已有的触发器。  
   该触发器将被关联到指定的表、视图或者外部表并且在表上发生特定操作时将执行指定的函数<replaceable class="parameter">function_name</replaceable>。
  </para>
<!-- pgdoc-cn_end sig_en=aa4e4d46c757a45a0dd231f9c9d64935 -->

<!-- pgdoc-cn_start sig_en=b8e5f927fc40ca8aa42fe432deba4eb9 sig_cn_org=None source=14.1 
  <para>
   To replace the current definition of an existing trigger, use
   <command>CREATE OR REPLACE TRIGGER</command>, specifying the existing
   trigger's name and parent table.  All other properties are replaced.
  </para>
________________________________________________________-->
  <para> 
   要替换已有触发器的当前定义，使用<command>CREATE OR REPLACE TRIGGER</command>，指定已有触发器的名称和父表。
   所有其他的属性会被替换。
  </para>
<!-- pgdoc-cn_end sig_en=b8e5f927fc40ca8aa42fe432deba4eb9 -->

<!-- pgdoc-cn_start sig_en=6a97ad62eea268c09e5d18a436bdaf33 sig_cn_org=None source=14.1 
  <para>
   The trigger can be specified to fire before the
   operation is attempted on a row (before constraints are checked and
   the <command>INSERT</command>, <command>UPDATE</command>, or
   <command>DELETE</command> is attempted); or after the operation has
   completed (after constraints are checked and the
   <command>INSERT</command>, <command>UPDATE</command>, or
   <command>DELETE</command> has completed); or instead of the operation
   (in the case of inserts, updates or deletes on a view).
   If the trigger fires before or instead of the event, the trigger can skip
   the operation for the current row, or change the row being inserted (for
   <command>INSERT</command> and <command>UPDATE</command> operations
   only). If the trigger fires after the event, all changes, including
   the effects of other triggers, are <quote>visible</quote>
   to the trigger.
  </para>
________________________________________________________-->
  <para>
   该触发器可以被指定为在一行上尝试该操作之前触发（在约束被检查并且<command>INSERT</command>、<command>UPDATE</command>或者<command>DELETE</command>被尝试之前）；也可以在该操作完成之后触发（在约束被检查并且<command>INSERT</command>、<command>UPDATE</command>或者<command>DELETE</command>完成之后）；或者取代该操作（在对一个视图插入、更新或删除的情况中）。如果该触发器在事件之前触发或者取代事件，该触发器可以跳过对当前行的操作或者改变正在被插入的行（只对<command>INSERT</command>以及<command>UPDATE</command>操作）。如果该触发器在事件之后触发，所有更改（包括其他触发器的效果）对该触发器<quote>可见</quote>。
  </para>
<!-- pgdoc-cn_end sig_en=6a97ad62eea268c09e5d18a436bdaf33 -->

<!-- pgdoc-cn_start sig_en=7851687ec9bb538678085dbfaad77b8d sig_cn_org=None source=14.1 
  <para>
   A trigger that is marked <literal>FOR EACH ROW</literal> is called
   once for every row that the operation modifies. For example, a
   <command>DELETE</command> that affects 10 rows will cause any
   <literal>ON DELETE</literal> triggers on the target relation to be
   called 10 separate times, once for each deleted row. In contrast, a
   trigger that is marked <literal>FOR EACH STATEMENT</literal> only
   executes once for any given operation, regardless of how many rows
   it modifies (in particular, an operation that modifies zero rows
   will still result in the execution of any applicable <literal>FOR
   EACH STATEMENT</literal> triggers).
  </para>
________________________________________________________-->
  <para>
   一个被标记为<literal>FOR EACH ROW</literal>的触发器会对该操作修改的每一行都调用一次。例如，一个影响 10 行的<command>DELETE</command>将导致在目标关系上的任何<literal>ON DELETE</literal>触发器被独立调用 10 次，也就是为每一个被删除的行调用一次。与此相反，一个被标记为<literal>FOR EACH STATEMENT</literal>的触发器只会为任何给定的操作执行一次，不管该操作修改多少行（特别地，一个修改零行的操作将仍会导致任何可用的<literal>FOR EACH STATEMENT</literal>触发器被执行）。
  </para>
<!-- pgdoc-cn_end sig_en=7851687ec9bb538678085dbfaad77b8d -->

<!-- pgdoc-cn_start sig_en=f1f17f7722926684d0ec9471efb04c92 sig_cn_org=None source=14.1 
  <para>
   Triggers that are specified to fire <literal>INSTEAD OF</literal> the trigger
   event must be marked <literal>FOR EACH ROW</literal>, and can only be defined
   on views. <literal>BEFORE</literal> and <literal>AFTER</literal> triggers on a view
   must be marked as <literal>FOR EACH STATEMENT</literal>.
  </para>
________________________________________________________-->
  <para>
   被指定为要触发<literal>INSTEAD OF</literal>触发器事件的触发器必须被标记为<literal>FOR EACH ROW</literal>，并且只能被定义在视图上。一个视图上的<literal>BEFORE</literal>和<literal>AFTER</literal>触发器必须被标记为<literal>FOR EACH STATEMENT</literal>。
  </para>
<!-- pgdoc-cn_end sig_en=f1f17f7722926684d0ec9471efb04c92 -->

<!-- pgdoc-cn_start sig_en=b0f3fdd1fdc703849c2c9a62757ae60f sig_cn_org=None source=14.1 
  <para>
   In addition, triggers may be defined to fire for
   <command>TRUNCATE</command>, though only
   <literal>FOR EACH STATEMENT</literal>.
  </para>
________________________________________________________-->
  <para>
   此外，触发器可以被定义成为<command>TRUNCATE</command>触发，但只能是<literal>FOR EACH STATEMENT</literal>。
  </para>
<!-- pgdoc-cn_end sig_en=b0f3fdd1fdc703849c2c9a62757ae60f -->

<!-- pgdoc-cn_start sig_en=b0269b2cf281a03ec6f87fc61ae630cb sig_cn_org=None source=14.1 
  <para>
   The following table summarizes which types of triggers may be used on
   tables, views, and foreign tables:
  </para>
________________________________________________________-->
  <para>
   下面的表格总结了哪些触发器类型可以被用在表、视图和外部表上：
  </para>
<!-- pgdoc-cn_end sig_en=b0269b2cf281a03ec6f87fc61ae630cb -->

  <informaltable id="supported-trigger-types">
   <tgroup cols="4">
    <thead>
<!-- pgdoc-cn_start sig_en=062324a597903e62b0b63daa79686a29 sig_cn_org=None source=14.1 
     <row>
      <entry>When</entry>
      <entry>Event</entry>
      <entry>Row-level</entry>
      <entry>Statement-level</entry>
     </row>
________________________________________________________-->
     <row>
      <entry>何时</entry>
      <entry>事件</entry>
      <entry>行级</entry>
      <entry>语句级</entry>
     </row>
<!-- pgdoc-cn_end sig_en=062324a597903e62b0b63daa79686a29 -->
    </thead>
    <tbody>
<!-- pgdoc-cn_start sig_en=5111dbf1296bfbd44580f6c503cfd763 sig_cn_org=None source=14.1 
     <row>
      <entry align="center" morerows="1"><literal>BEFORE</literal></entry>
      <entry align="center"><command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command></entry>
      <entry align="center">Tables and foreign tables</entry>
      <entry align="center">Tables, views, and foreign tables</entry>
     </row>
________________________________________________________-->
     <row>
      <entry align="center" morerows="1"><literal>BEFORE</literal></entry>
      <entry align="center"><command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command></entry>
      <entry align="center">表和外部表</entry>
      <entry align="center">表、视图和外部表</entry>
     </row>
<!-- pgdoc-cn_end sig_en=5111dbf1296bfbd44580f6c503cfd763 -->
<!-- pgdoc-cn_start sig_en=2d645ae3db450313c7fe05f3437a2e42 sig_cn_org=None source=14.1 
     <row>
      <entry align="center"><command>TRUNCATE</command></entry>
      <entry align="center">&mdash;</entry>
      <entry align="center">Tables</entry>
     </row>
________________________________________________________-->
     <row>
      <entry align="center"><command>TRUNCATE</command></entry>
      <entry align="center">&mdash;</entry>
      <entry align="center">表</entry>
     </row>
<!-- pgdoc-cn_end sig_en=2d645ae3db450313c7fe05f3437a2e42 -->
<!-- pgdoc-cn_start sig_en=e93734559e14578d82069c6784546f12 sig_cn_org=None source=14.1 
     <row>
      <entry align="center" morerows="1"><literal>AFTER</literal></entry>
      <entry align="center"><command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command></entry>
      <entry align="center">Tables and foreign tables</entry>
      <entry align="center">Tables, views, and foreign tables</entry>
     </row>
________________________________________________________-->
     <row>
      <entry align="center" morerows="1"><literal>AFTER</literal></entry>
      <entry align="center"><command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command></entry>
      <entry align="center">表和外部表</entry>
      <entry align="center">表、视图和外部表</entry>
     </row>
<!-- pgdoc-cn_end sig_en=e93734559e14578d82069c6784546f12 -->
<!-- pgdoc-cn_start sig_en=2d645ae3db450313c7fe05f3437a2e42 sig_cn_org=None source=14.1 
     <row>
      <entry align="center"><command>TRUNCATE</command></entry>
      <entry align="center">&mdash;</entry>
      <entry align="center">Tables</entry>
     </row>
________________________________________________________-->
     <row>
      <entry align="center"><command>TRUNCATE</command></entry>
      <entry align="center">&mdash;</entry>
      <entry align="center">表</entry>
     </row>
<!-- pgdoc-cn_end sig_en=2d645ae3db450313c7fe05f3437a2e42 -->
<!-- pgdoc-cn_start sig_en=afc1934e9ee604ccc6ec68df2b56299f sig_cn_org=None source=14.1 
     <row>
      <entry align="center" morerows="1"><literal>INSTEAD OF</literal></entry>
      <entry align="center"><command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command></entry>
      <entry align="center">Views</entry>
      <entry align="center">&mdash;</entry>
     </row>
________________________________________________________-->
     <row>
      <entry align="center" morerows="1"><literal>INSTEAD OF</literal></entry>
      <entry align="center"><command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command></entry>
      <entry align="center">视图</entry>
      <entry align="center">&mdash;</entry>
     </row>
<!-- pgdoc-cn_end sig_en=afc1934e9ee604ccc6ec68df2b56299f -->
<!-- pgdoc-cn_start sig_en=135bf2ac3e5e66f38cb9579ab254df0d sig_cn_org=None source=14.1 
     <row>
      <entry align="center"><command>TRUNCATE</command></entry>
      <entry align="center">&mdash;</entry>
      <entry align="center">&mdash;</entry>
     </row>
________________________________________________________-->
     <row>
      <entry align="center"><command>TRUNCATE</command></entry>
      <entry align="center">&mdash;</entry>
      <entry align="center">&mdash;</entry>
     </row>
<!-- pgdoc-cn_end sig_en=135bf2ac3e5e66f38cb9579ab254df0d -->
    </tbody>
   </tgroup>
  </informaltable>

<!-- pgdoc-cn_start sig_en=a463754efba64ed1f479ada1a6efbe12 sig_cn_org=None source=14.1 
  <para>
   Also, a trigger definition can specify a Boolean <literal>WHEN</literal>
   condition, which will be tested to see whether the trigger should
   be fired.  In row-level triggers the <literal>WHEN</literal> condition can
   examine the old and/or new values of columns of the row.  Statement-level
   triggers can also have <literal>WHEN</literal> conditions, although the feature
   is not so useful for them since the condition cannot refer to any values
   in the table.
  </para>
________________________________________________________-->
  <para>
   还有，一个触发器定义可以指定一个布尔的<literal>WHEN</literal>条件，它将被测试来看看该触发器是否应该被触发。在行级触发器中，<literal>WHEN</literal>条件可以检查该行的列的新旧值。语句级触发器也可以有<literal>WHEN</literal>条件，尽管该特性对于它们不是很有用（因为条件不能引用表中的任何值）。
  </para>
<!-- pgdoc-cn_end sig_en=a463754efba64ed1f479ada1a6efbe12 -->

<!-- pgdoc-cn_start sig_en=5115376aaa6f67befcb37dc59744990d sig_cn_org=None source=14.1 
  <para>
   If multiple triggers of the same kind are defined for the same event,
   they will be fired in alphabetical order by name.
  </para>
________________________________________________________-->
  <para>
   如果有多个同种触发器被定义为相同事件触发，它们将按照名称的字母表顺序被触发。
  </para>
<!-- pgdoc-cn_end sig_en=5115376aaa6f67befcb37dc59744990d -->

<!-- pgdoc-cn_start sig_en=49b6a876c5ba7f8edeaf50dba074204c sig_cn_org=f354f7af1c02ae10354d7f5a6b817870 source=15.7 
  <para>
   When the <literal>CONSTRAINT</literal> option is specified, this command creates a
   <firstterm>constraint trigger</firstterm>.<indexterm><primary>trigger</primary>
   <secondary>constraint trigger</secondary></indexterm>
   This is the same as a regular trigger
   except that the timing of the trigger firing can be adjusted using
   <link linkend="sql-set-constraints"><command>SET CONSTRAINTS</command></link>.
   Constraint triggers must be <literal>AFTER ROW</literal> triggers on plain
   tables (not foreign tables).  They
   can be fired either at the end of the statement causing the triggering
   event, or at the end of the containing transaction; in the latter case they
   are said to be <firstterm>deferred</firstterm>.  A pending deferred-trigger firing
   can also be forced to happen immediately by using <command>SET
   CONSTRAINTS</command>.  Constraint triggers are expected to raise an exception
   when the constraints they implement are violated.
  </para>
________________________________________________________-->
  <para>
   当指定<literal>CONSTRAINT</literal>选项时，此命令将创建一个<firstterm>约束触发器</firstterm>。
   <indexterm><primary>触发器</primary><secondary>约束触发器</secondary></indexterm>
   这与常规触发器相同，只是触发器触发的时机可以使用<link linkend="sql-set-constraints"><command>SET CONSTRAINTS</command></link>进行调整。
   约束触发器必须是普通表（而非外部表）上的<literal>AFTER ROW</literal>触发器。
   它们可以在引发触发事件的语句结束时触发，也可以在包含事务结束时触发；在后一种情况下，它们被称为<firstterm>延迟触发器</firstterm>。
   通过使用<command>SET CONSTRAINTS</command>，也可以强制触发挂起的延迟触发器立即发生。
   预期约束触发器在违反其实施的约束时引发异常。
</para>
<!-- pgdoc-cn_end sig_en=49b6a876c5ba7f8edeaf50dba074204c -->

<!-- pgdoc-cn_start sig_en=4093f6c5d3fbfa39ff2e86fadd41fc11 sig_cn_org=None source=14.1 
  <para>
   The <literal>REFERENCING</literal> option enables collection
   of <firstterm>transition relations</firstterm>, which are row sets that include all
   of the rows inserted, deleted, or modified by the current SQL statement.
   This feature lets the trigger see a global view of what the statement did,
   not just one row at a time.  This option is only allowed for
   an <literal>AFTER</literal> trigger that is not a constraint trigger; also, if
   the trigger is an <literal>UPDATE</literal> trigger, it must not specify
   a <replaceable class="parameter">column_name</replaceable> list.
   <literal>OLD TABLE</literal> may only be specified once, and only for a trigger
   that can fire on <literal>UPDATE</literal> or <literal>DELETE</literal>; it creates a
   transition relation containing the <firstterm>before-images</firstterm> of all rows
   updated or deleted by the statement.
   Similarly, <literal>NEW TABLE</literal> may only be specified once, and only for
   a trigger that can fire on <literal>UPDATE</literal> or <literal>INSERT</literal>;
   it creates a transition relation containing the <firstterm>after-images</firstterm>
   of all rows updated or inserted by the statement.
  </para>
________________________________________________________-->
  <para>
   <literal>REFERENCING</literal>选项启用对<firstterm>传递关系</firstterm>的收集，传递关系是包括被当前SQL语句插入、删除或者修改的行的行集合。这个特性让触发器能看到该语句做的事情的全局视图，而不是一次只看到一行。仅对非约束触发器的<literal>AFTER</literal>触发器允许这个选项。此外，如果触发器是一个<literal>UPDATE</literal>触发器，则它不能指定<replaceable class="parameter">column_name</replaceable>列表。<literal>OLD TABLE</literal>仅可以被指定一次，并且只能为在<literal>UPDATE</literal>或<literal>DELETE</literal>事件上引发的触发器指定，它创建的传递关系包含有该语句更新或删除的所有行的<firstterm>前映像</firstterm>。类似地，<literal>NEW TABLE</literal>仅可以被指定一次，并且只能为在<literal>UPDATE</literal>或<literal>INSERT</literal>事件上引发的触发器指定，它创建的传递关系包含有该语句更新或插入的所有行的<firstterm>后映像</firstterm>。
  </para>
<!-- pgdoc-cn_end sig_en=4093f6c5d3fbfa39ff2e86fadd41fc11 -->

<!-- pgdoc-cn_start sig_en=d00c14193ba6dce41d5940aab930b0c5 sig_cn_org=None source=14.1 
  <para>
   <command>SELECT</command> does not modify any rows so you cannot
   create <command>SELECT</command> triggers.  Rules and views may provide
   workable solutions to problems that seem to need <command>SELECT</command>
   triggers.
  </para>
________________________________________________________-->
  <para>
   <command>SELECT</command>不修改任何行，因此你无法创建<command>SELECT</command>触发器。规则和视图可以为需要<command>SELECT</command>触发器的问题提供可行的解决方案。
  </para>
<!-- pgdoc-cn_end sig_en=d00c14193ba6dce41d5940aab930b0c5 -->

<!-- pgdoc-cn_start sig_en=5da6188962bcf858770865548dc0ba2d sig_cn_org=None source=14.1 
  <para>
   Refer to <xref linkend="triggers"/> for more information about triggers.
  </para>
________________________________________________________-->
  <para>
   关于触发器的更多信息请见<xref linkend="triggers"/>。
  </para>
<!-- pgdoc-cn_end sig_en=5da6188962bcf858770865548dc0ba2d -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
  <title>Parameters</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">name</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=cfd3f7aedf07280ec7148d757a26658d sig_cn_org=None source=14.1 
     <para>
      The name to give the new trigger.  This must be distinct from
      the name of any other trigger for the same table.
      The name cannot be schema-qualified &mdash; the trigger inherits the
      schema of its table.  For a constraint trigger, this is also the name to
      use when modifying the trigger's behavior using
      <command>SET CONSTRAINTS</command>.
     </para>
________________________________________________________-->
     <para>
      给新触发器的名称。这必须与同一个表上的任何其他触发器相区别。名称不能是模式限定的 &mdash; 该触发器会继承它所在表的模式。对于一个约束触发器，这也是使用<command>SET CONSTRAINTS</command>修改触发器行为时要用到的名字。
     </para>
<!-- pgdoc-cn_end sig_en=cfd3f7aedf07280ec7148d757a26658d -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>BEFORE</literal></term>
    <term><literal>AFTER</literal></term>
    <term><literal>INSTEAD OF</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=b11c461c84a51ad2358c295752e03b5f sig_cn_org=None source=14.1 
     <para>
      Determines whether the function is called before, after, or instead of
      the event.  A constraint trigger can only be specified as
      <literal>AFTER</literal>.
     </para>
________________________________________________________-->
     <para>
      决定该函数是要在事件之前、之后被调用还是会取代该事件。一个约束触发器也能被指定为<literal>AFTER</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=b11c461c84a51ad2358c295752e03b5f -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">event</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=d3e78792a27184d3930e4710473ff981 sig_cn_org=None source=14.1 
     <para>
      One of <literal>INSERT</literal>, <literal>UPDATE</literal>,
      <literal>DELETE</literal>, or <literal>TRUNCATE</literal>;
      this specifies the event that will fire the trigger. Multiple
      events can be specified using <literal>OR</literal>, except when
      transition relations are requested.
     </para>
________________________________________________________-->
     <para>
      <literal>INSERT</literal>、<literal>UPDATE</literal>、<literal>DELETE</literal>或者<literal>TRUNCATE</literal>之一，这指定了将要引发该触发器的事件。多个事件可以用<literal>OR</literal>指定，要求传递关系的时候除外。
     </para>
<!-- pgdoc-cn_end sig_en=d3e78792a27184d3930e4710473ff981 -->

<!-- pgdoc-cn_start sig_en=924671af92d4bd00fb72f171ff9fd527 sig_cn_org=None source=14.1 
     <para>
      For <literal>UPDATE</literal> events, it is possible to
      specify a list of columns using this syntax:
<synopsis>
UPDATE OF <replaceable>column_name1</replaceable> [, <replaceable>column_name2</replaceable> ... ]
</synopsis>
      The trigger will only fire if at least one of the listed columns
      is mentioned as a target of the <command>UPDATE</command> command
      or if one of the listed columns is a generated column that depends on a
      column that is the target of the <command>UPDATE</command>.
     </para>
________________________________________________________-->
     <para>
      对于<literal>UPDATE</literal>事件，可以使用下面的语法指定一个列的列表：
<synopsis>
UPDATE OF <replaceable>column_name1</replaceable> [, <replaceable>column_name2</replaceable> ... ]
</synopsis>
      只有当至少一个被列出的列出现在<command>UPDATE</command>命令的更新目标中时，或者如果列出的列之一是生成的列，而且依赖的列是<command>UPDATE</command>的目标，该触发器才会触发。
     </para>
<!-- pgdoc-cn_end sig_en=924671af92d4bd00fb72f171ff9fd527 -->

<!-- pgdoc-cn_start sig_en=3002429a87a02f84ee5d7b65aaa8f187 sig_cn_org=None source=14.1 
     <para>
      <literal>INSTEAD OF UPDATE</literal> events do not allow a list of columns.
      A column list cannot be specified when requesting transition relations,
      either.
     </para>
________________________________________________________-->
     <para>
      <literal>INSTEAD OF UPDATE</literal>事件不允许列的列表。在请求传递关系时，也不能指定列的列表。
     </para>
<!-- pgdoc-cn_end sig_en=3002429a87a02f84ee5d7b65aaa8f187 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">table_name</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=62bcfde8169941447b25a6c4731167d3 sig_cn_org=None source=14.1 
     <para>
      The name (optionally schema-qualified) of the table, view, or foreign
      table the trigger is for.
     </para>
________________________________________________________-->
     <para>
      要使用该触发器的表、视图或外部表的名称（可能是模式限定的）。
     </para>
<!-- pgdoc-cn_end sig_en=62bcfde8169941447b25a6c4731167d3 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">referenced_table_name</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=d548a4c0d84c573b462fbe79e6dba428 sig_cn_org=None source=14.1 
     <para>
      The (possibly schema-qualified) name of another table referenced by the
      constraint.  This option is used for foreign-key constraints and is not
      recommended for general use.  This can only be specified for
      constraint triggers.
     </para>
________________________________________________________-->
     <para>
      约束引用的另一个表的名称（可能是模式限定的）。这个选项被用于外键约束并且不推荐用于一般的目的。这只能为约束触发器指定。
     </para>
<!-- pgdoc-cn_end sig_en=d548a4c0d84c573b462fbe79e6dba428 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DEFERRABLE</literal></term>
    <term><literal>NOT DEFERRABLE</literal></term>
    <term><literal>INITIALLY IMMEDIATE</literal></term>
    <term><literal>INITIALLY DEFERRED</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=e3c155948640366bf436338dbf5d9e26 sig_cn_org=None source=14.1 
     <para>
      The default timing of the trigger.
      See the <xref linkend="sql-createtable"/> documentation for details of
      these constraint options.  This can only be specified for constraint
      triggers.
     </para>
________________________________________________________-->
     <para>
      该触发器的默认时机。这些约束选项的细节可参考<xref linkend="sql-createtable"/>文档。这只能为约束触发器指定。
     </para>
<!-- pgdoc-cn_end sig_en=e3c155948640366bf436338dbf5d9e26 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>REFERENCING</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=d9484997eed2162f50466610830623c8 sig_cn_org=None source=14.1 
     <para>
      This keyword immediately precedes the declaration of one or two
      relation names that provide access to the transition relations of the
      triggering statement.
     </para>
________________________________________________________-->
     <para>
      这个关键词紧接在一个或者两个关系名的声明之前，这些关系提供对触发语句的传递关系的访问。
     </para>
<!-- pgdoc-cn_end sig_en=d9484997eed2162f50466610830623c8 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OLD TABLE</literal></term>
    <term><literal>NEW TABLE</literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=648ff3dad57235316387ce6bc7788f52 sig_cn_org=None source=14.1 
     <para>
      This clause indicates whether the following relation name is for the
      before-image transition relation or the after-image transition
      relation.
     </para>
________________________________________________________-->
     <para>
      这个子句指示接下来的关系名是用于前映像传递关系还是后映像传递关系。
     </para>
<!-- pgdoc-cn_end sig_en=648ff3dad57235316387ce6bc7788f52 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">transition_relation_name</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=176f200450692d3128539cc96b108c8f sig_cn_org=None source=14.1 
     <para>
      The (unqualified) name to be used within the trigger for this
      transition relation.
     </para>
________________________________________________________-->
     <para>
      在该触发器中这个传递关系要使用的（未限定）名称。
     </para>
<!-- pgdoc-cn_end sig_en=176f200450692d3128539cc96b108c8f -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FOR EACH ROW</literal></term>
    <term><literal>FOR EACH STATEMENT</literal></term>

    <listitem>
<!-- pgdoc-cn_start sig_en=7ef15c14c9e36027d184b856132e9a8b sig_cn_org=None source=14.1 
     <para>
      This specifies whether the trigger function should be fired
      once for every row affected by the trigger event, or just once
      per SQL statement. If neither is specified, <literal>FOR EACH
      STATEMENT</literal> is the default.  Constraint triggers can only
      be specified <literal>FOR EACH ROW</literal>.
     </para>
________________________________________________________-->
     <para>
      这指定该触发器函数是应该为该触发器事件影响的每一行被引发一次，还是只为每个 SQL 语句被引发一次。如果都没有被指定，<literal>FOR EACH STATEMENT</literal>会是默认值。约束触发器只能被指定为<literal>FOR EACH ROW</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=7ef15c14c9e36027d184b856132e9a8b -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">condition</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=5ee576a748b86c97ccd0121e2734a26e sig_cn_org=None source=14.1 
     <para>
      A Boolean expression that determines whether the trigger function
      will actually be executed.  If <literal>WHEN</literal> is specified, the
      function will only be called if the <replaceable
      class="parameter">condition</replaceable> returns <literal>true</literal>.
      In <literal>FOR EACH ROW</literal> triggers, the <literal>WHEN</literal>
      condition can refer to columns of the old and/or new row values
      by writing <literal>OLD.<replaceable
      class="parameter">column_name</replaceable></literal> or
      <literal>NEW.<replaceable
      class="parameter">column_name</replaceable></literal> respectively.
      Of course, <literal>INSERT</literal> triggers cannot refer to <literal>OLD</literal>
      and <literal>DELETE</literal> triggers cannot refer to <literal>NEW</literal>.
     </para>
________________________________________________________-->
     <para>
      一个决定该触发器函数是否将被实际执行的布尔表达式。如果指定了<literal>WHEN</literal>，只有<replaceable class="parameter">condition</replaceable>返回<literal>true</literal>时才会调用该函数。在<literal>FOR EACH ROW</literal>触发器中，<literal>WHEN</literal>条件可以分别写<literal>OLD.<replaceable class="parameter">column_name</replaceable></literal>或者<literal>NEW.<replaceable class="parameter">column_name</replaceable></literal>来引用列的新旧行值。当然，<literal>INSERT</literal>触发器不能引用<literal>OLD</literal>并且<literal>DELETE</literal>触发器不能引用<literal>NEW</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=5ee576a748b86c97ccd0121e2734a26e -->

<!-- pgdoc-cn_start sig_en=37df37dc4f2d09dd58338fde3f5c5a8a sig_cn_org=None source=14.1 
     <para><literal>INSTEAD OF</literal> triggers do not support <literal>WHEN</literal>
      conditions.
     </para>
________________________________________________________-->
     <para><literal>INSTEAD OF</literal>触发器不支持<literal>WHEN</literal>条件。
     </para>
<!-- pgdoc-cn_end sig_en=37df37dc4f2d09dd58338fde3f5c5a8a -->

<!-- pgdoc-cn_start sig_en=bb88058d4889306f4110f8751463b30c sig_cn_org=None source=14.1 
     <para>
      Currently, <literal>WHEN</literal> expressions cannot contain
      subqueries.
     </para>
________________________________________________________-->
     <para>
      当前，<literal>WHEN</literal>表达式不能包含子查询。
     </para>
<!-- pgdoc-cn_end sig_en=bb88058d4889306f4110f8751463b30c -->

<!-- pgdoc-cn_start sig_en=dd53370845074fb27c1ca2962c349c51 sig_cn_org=None source=14.1 
     <para>
      Note that for constraint triggers, evaluation of the <literal>WHEN</literal>
      condition is not deferred, but occurs immediately after the row update
      operation is performed. If the condition does not evaluate to true then
      the trigger is not queued for deferred execution.
     </para>
________________________________________________________-->
     <para>
      注意对于约束触发器，对于<literal>WHEN</literal>条件的计算不会被延迟，而是直接在行更新操作被执行之后立刻发生。如果该条件计算得不到真，那么该触发器就不会被放在延迟执行的队列中。
     </para>
<!-- pgdoc-cn_end sig_en=dd53370845074fb27c1ca2962c349c51 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">function_name</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=74ca81050051891e7b812afbaf7f9b72 sig_cn_org=None source=14.1 
     <para>
      A user-supplied function that is declared as taking no arguments
      and returning type <literal>trigger</literal>, which is executed when
      the trigger fires.
     </para>
________________________________________________________-->
     <para>
      一个用户提供的函数，它被声明为不用参数并且返回类型<literal>trigger</literal>，当触发器引发时会执行该函数。
     </para>
<!-- pgdoc-cn_end sig_en=74ca81050051891e7b812afbaf7f9b72 -->

<!-- pgdoc-cn_start sig_en=b9e13f029ed78f4562a82f0d52218965 sig_cn_org=None source=14.1 
     <para>
      In the syntax of <literal>CREATE TRIGGER</literal>, the keywords
      <literal>FUNCTION</literal> and <literal>PROCEDURE</literal> are
      equivalent, but the referenced function must in any case be a function,
      not a procedure.  The use of the keyword <literal>PROCEDURE</literal>
      here is historical and deprecated.
     </para>
________________________________________________________-->
     <para>
      在<literal>CREATE TRIGGER</literal>的语法中，关键词<literal>FUNCTION</literal>和<literal>PROCEDURE</literal>是等效的，但是任何情况下被引用的函数必须是一个函数而不是过程。这里，关键词<literal>PROCEDURE</literal>的使用是有历史原因的并且已经被废弃。
     </para>
<!-- pgdoc-cn_end sig_en=b9e13f029ed78f4562a82f0d52218965 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">arguments</replaceable></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=1f8912396dbcd4667481a8a5732890d2 sig_cn_org=None source=14.1 
     <para>
      An optional comma-separated list of arguments to be provided to
      the function when the trigger is executed.  The arguments are
      literal string constants.  Simple names and numeric constants
      can be written here, too, but they will all be converted to
      strings.  Please check the description of the implementation
      language of the trigger function to find out how these arguments
      can be accessed within the function; it might be different from
      normal function arguments.
     </para>
________________________________________________________-->
     <para>
      一个可选的逗号分隔的参数列表，它在该触发器被执行时会被提供给该函数。参数是字符串常量。简单的名称和数字常量也可以被写在这里，但是它们将全部被转换成字符串。请检查该触发器函数的实现语言的描述来找出在函数内部如何访问这些参数，这可能与普通函数参数不同。
     </para>
<!-- pgdoc-cn_end sig_en=1f8912396dbcd4667481a8a5732890d2 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1 id="sql-createtrigger-notes">
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
  <title>Notes</title>
________________________________________________________-->
  <title>注解</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->

<!-- pgdoc-cn_start sig_en=284861e91db83d5024196c651dca97ff sig_cn_org=None source=14.1 
  <para>
   To create or replace a trigger on a table, the user must have the
   <literal>TRIGGER</literal> privilege on the table.  The user must
   also have <literal>EXECUTE</literal> privilege on the trigger function.
  </para>
________________________________________________________-->
  <para>
   要在一个表上创建或替换一个触发器，用户必须具有该表上的<literal>TRIGGER</literal>特权。
   用户还必须具有在触发器函数上的<literal>EXECUTE</literal>特权。
  </para>
<!-- pgdoc-cn_end sig_en=284861e91db83d5024196c651dca97ff -->

<!-- pgdoc-cn_start sig_en=b3ad164ce4b9151c3afbbebd96f1b347 sig_cn_org=None source=14.1 
  <para>
   Use <link linkend="sql-droptrigger"><command>DROP TRIGGER</command></link> to remove a trigger.
  </para>
________________________________________________________-->
  <para>
   使用<link linkend="sql-droptrigger"><command>DROP TRIGGER</command></link>移除一个触发器。
  </para>
<!-- pgdoc-cn_end sig_en=b3ad164ce4b9151c3afbbebd96f1b347 -->

<!-- pgdoc-cn_start sig_en=7cb4a2493fd9bc78f0401b22cbf31296 sig_cn_org=None source=14.1 
  <para>
   Creating a row-level trigger on a partitioned table will cause an
   identical <quote>clone</quote> trigger to be created on each of its
   existing partitions; and any partitions created or attached later will have
   an identical trigger, too.  If there is a conflictingly-named trigger on a
   child partition already, an error occurs unless <command>CREATE OR REPLACE
   TRIGGER</command> is used, in which case that trigger is replaced with a
   clone trigger.  When a partition is detached from its parent, its clone
   triggers are removed.
  </para>
________________________________________________________-->
  <para>
   在分区表上创建行级触发器将导致在每个它的已有分区上创建相同的<quote>clone</quote>触发器;以后创建或附加的任何分区也将具有相同的触发器。
   如果子分区上已经有冲突命名的触发器，则会发生错误，除非使用<command>CREATE OR REPLACE   TRIGGER</command>  。
   在这种情况下，该触发器将由一个克隆触发器替换。
   当一个分区从其父分区脱离时，它的克隆触发器将被删除。
  </para>
<!-- pgdoc-cn_end sig_en=7cb4a2493fd9bc78f0401b22cbf31296 -->

<!-- pgdoc-cn_start sig_en=f2059ca31aa4e043f7bfa7034650b0df sig_cn_org=None source=14.1 
  <para>
   A column-specific trigger (one defined using the <literal>UPDATE OF
   <replaceable>column_name</replaceable></literal> syntax) will fire when any
   of its columns are listed as targets in the <command>UPDATE</command>
   command's <literal>SET</literal> list.  It is possible for a column's value
   to change even when the trigger is not fired, because changes made to the
   row's contents by <literal>BEFORE UPDATE</literal> triggers are not considered.
   Conversely, a command such as <literal>UPDATE ... SET x = x ...</literal>
   will fire a trigger on column <literal>x</literal>, even though the column's
   value did not change.
  </para>
________________________________________________________-->
  <para>
   当一个列相关的触发器（使用<literal>UPDATE OF <replaceable>column_name</replaceable></literal>语法定义的触发器）的列被列为<command>UPDATE</command>命令的<literal>SET</literal>列表目标时，它会被触发。即便该触发器没有被引发，一个列的值也可能改变，因为<literal>BEFORE UPDATE</literal>触发器对行内容所作的改变不会被考虑。相反，一个诸如<literal>UPDATE ... SET x = x ...</literal>的命令将引发一个位于列<literal>x</literal>上的触发器，即便该列的值没有改变。
  </para>
<!-- pgdoc-cn_end sig_en=f2059ca31aa4e043f7bfa7034650b0df -->

<!-- pgdoc-cn_start sig_en=277fa3bdcd763da6f49f41dbaea3c829 sig_cn_org=None source=14.1 
  <para>
   In a <literal>BEFORE</literal> trigger, the <literal>WHEN</literal> condition is
   evaluated just before the function is or would be executed, so using
   <literal>WHEN</literal> is not materially different from testing the same
   condition at the beginning of the trigger function.  Note in particular
   that the <literal>NEW</literal> row seen by the condition is the current value,
   as possibly modified by earlier triggers.  Also, a <literal>BEFORE</literal>
   trigger's <literal>WHEN</literal> condition is not allowed to examine the
   system columns of the <literal>NEW</literal> row (such as <literal>ctid</literal>),
   because those won't have been set yet.
  </para>
________________________________________________________-->
  <para>
   在一个<literal>BEFORE</literal>触发器中，<literal>WHEN</literal>条件正好在函数被或者将被执行之前被计算，因此使用<literal>WHEN</literal>与在触发器函数的开始测试同一个条件没有实质上的区别。特别注意该条件看到的<literal>NEW</literal>行是当前值，虽然可能已被早前的触发器所修改。还有，一个<literal>BEFORE</literal>触发器的<literal>WHEN</literal>条件不允许检查<literal>NEW</literal>行的系统列（例如<literal>ctid</literal>），因为那些列还没有被设置。
  </para>
<!-- pgdoc-cn_end sig_en=277fa3bdcd763da6f49f41dbaea3c829 -->

<!-- pgdoc-cn_start sig_en=aa04dba702ddc0bb0f63cbae4774876d sig_cn_org=None source=14.1 
  <para>
   In an <literal>AFTER</literal> trigger, the <literal>WHEN</literal> condition is
   evaluated just after the row update occurs, and it determines whether an
   event is queued to fire the trigger at the end of statement.  So when an
   <literal>AFTER</literal> trigger's <literal>WHEN</literal> condition does not return
   true, it is not necessary to queue an event nor to re-fetch the row at end
   of statement.  This can result in significant speedups in statements that
   modify many rows, if the trigger only needs to be fired for a few of the
   rows.
  </para>
________________________________________________________-->
  <para>
   在一个<literal>AFTER</literal>触发器中，<literal>WHEN</literal>条件正好在行更新发生之后被计算，并且它决定一个事件是否要被放入队列以便在语句的末尾引发该触发器。因此当一个<literal>AFTER</literal>触发器的<literal>WHEN</literal>条件不返回真时，没有必要把一个事件放入队列或者在语句末尾重新取得该行。如果触发器只需要为一些行被引发，就能够显著地加快修改很多行的语句的速度。
  </para>
<!-- pgdoc-cn_end sig_en=aa04dba702ddc0bb0f63cbae4774876d -->

<!-- pgdoc-cn_start sig_en=3627a68db59c36bf7cf919253c9ab8b1 sig_cn_org=None source=14.1 
  <para>
   In some cases it is possible for a single SQL command to fire more than
   one kind of trigger.  For instance an <command>INSERT</command> with
   an <literal>ON CONFLICT DO UPDATE</literal> clause may cause both insert and
   update operations, so it will fire both kinds of triggers as needed.
   The transition relations supplied to triggers are
   specific to their event type; thus an <command>INSERT</command> trigger
   will see only the inserted rows, while an <command>UPDATE</command>
   trigger will see only the updated rows.
  </para>
________________________________________________________-->
  <para>
   在一些情况下，单一的SQL命令可能会引发多种触发器。例如，一个带有<literal>ON CONFLICT DO UPDATE</literal>子句的<command>INSERT</command>可能同时导致插入和更新操作，因此它将根据需要引发这两种触发器。提供给触发器的传递关系与它们的事件类型有关，因此<command>INSERT</command>触发器将只看到被插入的行，而<command>UPDATE</command>触发器将只看到被更新的行。
  </para>
<!-- pgdoc-cn_end sig_en=3627a68db59c36bf7cf919253c9ab8b1 -->

<!-- pgdoc-cn_start sig_en=f6d305aace052d554e6c8504d94aa058 sig_cn_org=None source=14.1 
  <para>
   Row updates or deletions caused by foreign-key enforcement actions, such
   as <literal>ON UPDATE CASCADE</literal> or <literal>ON DELETE SET NULL</literal>, are
   treated as part of the SQL command that caused them (note that such
   actions are never deferred).  Relevant triggers on the affected table will
   be fired, so that this provides another way in which an SQL command might
   fire triggers not directly matching its type.  In simple cases, triggers
   that request transition relations will see all changes caused in their
   table by a single original SQL command as a single transition relation.
   However, there are cases in which the presence of an <literal>AFTER ROW</literal>
   trigger that requests transition relations will cause the foreign-key
   enforcement actions triggered by a single SQL command to be split into
   multiple steps, each with its own transition relation(s).  In such cases,
   any statement-level triggers that are present will be fired once per
   creation of a transition relation set, ensuring that the triggers see
   each affected row in a transition relation once and only once.
  </para>
________________________________________________________-->
  <para>
   由外键强制动作导致的行更新或删除（例如<literal>ON UPDATE CASCADE</literal>或<literal>ON DELETE SET NULL</literal>）被当做导致它们的SQL命令的一部分。受影响的表上的相关触发器将被引发，这样就提供了另一种方法让SQL命令引发不直接匹配其类型的触发器。在简单的情况中，请求传递关系的触发器将在一个传递关系中看到由原始SQL命令在其表中做出的所有改变。不过，有些情况中一个请求传递关系的<literal>AFTER ROW</literal>触发器的存在将导致由单个SQL命令触发的外键强制动作被分成多步，每一步都有其自己的传递关系。在这种情况下，没创建一个传递关系集合都会引发存在的所有语句级触发器，确保那些触发器能够在一个传递关系中看到每个受影响的行一次，并且只看到一次。
  </para>
<!-- pgdoc-cn_end sig_en=f6d305aace052d554e6c8504d94aa058 -->

<!-- pgdoc-cn_start sig_en=4515b34b1763149706ed417682c5a27a sig_cn_org=None source=14.1 
  <para>
   Statement-level triggers on a view are fired only if the action on the
   view is handled by a row-level <literal>INSTEAD OF</literal> trigger.
   If the action is handled by an <literal>INSTEAD</literal> rule, then
   whatever statements are emitted by the rule are executed in place of the
   original statement naming the view, so that the triggers that will be
   fired are those on tables named in the replacement statements.
   Similarly, if the view is automatically updatable, then the action is
   handled by automatically rewriting the statement into an action on the
   view's base table, so that the base table's statement-level triggers are
   the ones that are fired.
  </para>
________________________________________________________-->
  <para>
   只有当视图上的动作被一个行级<literal>INSTEAD OF</literal>触发器处理时才会引发视图上的语句级触发器。如果动作被一个<literal>INSTEAD</literal>规则处理，那么该语句发出的任何语句都会代替提及该视图的原始语句执行，这样将被引发的触发器是替换语句中提及的表上的那些触发器。类似地，如果视图是自动可更新的，则该动作将被处理为把该语句自动重写成在视图基表上的一个动作，这样基表的语句级触发器就是要被引发的。
  </para>
<!-- pgdoc-cn_end sig_en=4515b34b1763149706ed417682c5a27a -->

<!-- pgdoc-cn_start sig_en=7ac1130b03ccc9276972334622f7f579 sig_cn_org=None source=14.1 
  <para>
   Modifying a partitioned table or a table with inheritance children fires
   statement-level triggers attached to the explicitly named table, but not
   statement-level triggers for its partitions or child tables.  In contrast,
   row-level triggers are fired on the rows in affected partitions or
   child tables, even if they are not explicitly named in the query.
   If a statement-level trigger has been defined with transition relations
   named by a <literal>REFERENCING</literal> clause, then before and after
   images of rows are visible from all affected partitions or child tables.
   In the case of inheritance children, the row images include only columns
   that are present in the table that the trigger is attached to.
  </para>
________________________________________________________-->
  <para>
   修改分区表或者带有继承子表的表会引发挂接到显式提及表的语句级触发器，但不会引发其分区或子表的语句级触发器。
   相反，行级触发器会在受影响的分区或子表上引发，即便它们在查询中没有被明确提及。
   如果一个语句级触发器用<literal>REFERENCING</literal>子句定义有传递关系，则来自所有受影响分区或子表中的行的前后映像都是可见的。
   在继承子表的情况中，行映像仅包括该触发器所附属的表中存在的列。
  </para>
<!-- pgdoc-cn_end sig_en=7ac1130b03ccc9276972334622f7f579 -->

<!-- pgdoc-cn_start sig_en=aa87bc554aa345237d8425040b2bf684 sig_cn_org=None source=14.1 
  <para>
   Currently, row-level triggers with transition relations cannot be defined
   on partitions or inheritance child tables.  Also, triggers on partitioned
   tables may not be <literal>INSTEAD OF</literal>.
  </para>
________________________________________________________-->
  <para>
   当前，有事务关系的行级触发器不能再分区或继承的子表上定义。
   此外，分区表上的触发器不能被<literal>INSTEAD OF</literal>。
  </para>
<!-- pgdoc-cn_end sig_en=aa87bc554aa345237d8425040b2bf684 -->

<!-- pgdoc-cn_start sig_en=f9f99443c1b41e96d0f5c2d9fab812cf sig_cn_org=None source=14.1 
  <para>
   Currently, the <literal>OR REPLACE</literal> option is not supported for
   constraint triggers.
  </para>
________________________________________________________-->
  <para>
   当前, <literal>OR REPLACE</literal> 选项不支持约束触发器。
  </para>
<!-- pgdoc-cn_end sig_en=f9f99443c1b41e96d0f5c2d9fab812cf -->

<!-- pgdoc-cn_start sig_en=931658ad7bad09a95c3b212a60aa4a65 sig_cn_org=None source=14.1 
  <para>
   Replacing an existing trigger within a transaction that has already
   performed updating actions on the trigger's table is not recommended.
   Trigger firing decisions, or portions of firing decisions, that have
   already been made will not be reconsidered, so the effects could be
   surprising.
  </para>
________________________________________________________-->
  <para>
   不建议在已经对触发器的表执行过更新操作的事务中替换已有的触发器。
   触发器点火决定，或部分点火决定，已经被做出的将不会被重新考虑，所以作用可能会令人惊讶。
  </para>
<!-- pgdoc-cn_end sig_en=931658ad7bad09a95c3b212a60aa4a65 -->

<!-- pgdoc-cn_start sig_en=94819493e409cc43f6563f3f21535ae3 sig_cn_org=None source=14.1 
  <para>
   There are a few built-in trigger functions that can be used to
   solve common problems without having to write your own trigger code;
   see <xref linkend="functions-trigger"/>.
  </para>
________________________________________________________-->
  <para>
   有少量内置触发器函数可以用于解决常见问题而不用写你自己的触发器代码；参见<xref linkend="functions-trigger"/>。
  </para>
<!-- pgdoc-cn_end sig_en=94819493e409cc43f6563f3f21535ae3 -->
 </refsect1>

 <refsect1 id="sql-createtrigger-examples">
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
  <title>Examples</title>
________________________________________________________-->
  <title>例子</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=22415d81e573e9db4500cd472d308bdd sig_cn_org=None source=14.1 
  <para>
   Execute the function <function>check_account_update</function> whenever
   a row of the table <literal>accounts</literal> is about to be updated:

<programlisting>
CREATE TRIGGER check_update
    BEFORE UPDATE ON accounts
    FOR EACH ROW
    EXECUTE FUNCTION check_account_update();
</programlisting>

   Modify that trigger definition to only execute the function if
   column <literal>balance</literal> is specified as a target in
   the <command>UPDATE</command> command:

<programlisting>
CREATE OR REPLACE TRIGGER check_update
    BEFORE UPDATE OF balance ON accounts
    FOR EACH ROW
    EXECUTE FUNCTION check_account_update();
</programlisting>

   This form only executes the function if column <literal>balance</literal>
   has in fact changed value:

<programlisting>
CREATE TRIGGER check_update
    BEFORE UPDATE ON accounts
    FOR EACH ROW
    WHEN (OLD.balance IS DISTINCT FROM NEW.balance)
    EXECUTE FUNCTION check_account_update();
</programlisting>

   Call a function to log updates of <literal>accounts</literal>, but only if
   something changed:

<programlisting>
CREATE TRIGGER log_update
    AFTER UPDATE ON accounts
    FOR EACH ROW
    WHEN (OLD.* IS DISTINCT FROM NEW.*)
    EXECUTE FUNCTION log_account_update();
</programlisting>

   Execute the function <function>view_insert_row</function> for each row to insert
   rows into the tables underlying a view:

<programlisting>
CREATE TRIGGER view_insert
    INSTEAD OF INSERT ON my_view
    FOR EACH ROW
    EXECUTE FUNCTION view_insert_row();
</programlisting>

   Execute the function <function>check_transfer_balances_to_zero</function> for each
   statement to confirm that the <literal>transfer</literal> rows offset to a net of
   zero:

<programlisting>
CREATE TRIGGER transfer_insert
    AFTER INSERT ON transfer
    REFERENCING NEW TABLE AS inserted
    FOR EACH STATEMENT
    EXECUTE FUNCTION check_transfer_balances_to_zero();
</programlisting>

   Execute the function <function>check_matching_pairs</function> for each row to
   confirm that changes are made to matching pairs at the same time (by the
   same statement):

<programlisting>
CREATE TRIGGER paired_items_update
    AFTER UPDATE ON paired_items
    REFERENCING NEW TABLE AS newtab OLD TABLE AS oldtab
    FOR EACH ROW
    EXECUTE FUNCTION check_matching_pairs();
</programlisting>
  </para>
________________________________________________________-->
  <para>
   只要表<literal>accounts</literal>的一行即将要被更新时会执行函数<function>check_account_update</function>：

<programlisting>
CREATE TRIGGER check_update
    BEFORE UPDATE ON accounts
    FOR EACH ROW
    EXECUTE FUNCTION check_account_update();
</programlisting>

   修改该触发器定义，使其仅在<command>UPDATE</command>命令中将<literal>balance</literal>列指定为目标时执行函数:

<programlisting>
CREATE OR REPLACE TRIGGER check_update
    BEFORE UPDATE OF balance ON accounts
    FOR EACH ROW
    EXECUTE FUNCTION check_account_update();
</programlisting>

   这种形式只有列<literal>balance</literal>具有真正被改变的值时才执行该函数：

<programlisting>
CREATE TRIGGER check_update
    BEFORE UPDATE ON accounts
    FOR EACH ROW
    WHEN (OLD.balance IS DISTINCT FROM NEW.balance)
    EXECUTE FUNCTION check_account_update();
</programlisting>

   调用一个函数来记录<literal>accounts</literal>的更新，但是只在有东西被改变时才调用：

<programlisting>
CREATE TRIGGER log_update
    AFTER UPDATE ON accounts
    FOR EACH ROW
    WHEN (OLD.* IS DISTINCT FROM NEW.*)
    EXECUTE FUNCTION log_account_update();
</programlisting>

   为每一个要插入到视图底层表中的行执行函数<function>view_insert_row</function>：

<programlisting>
CREATE TRIGGER view_insert
    INSTEAD OF INSERT ON my_view
    FOR EACH ROW
    EXECUTE FUNCTION view_insert_row();
</programlisting>

   为每个语句执行函数<function>check_transfer_balances_to_zero</function>以确认<literal>transfer</literal>的行不会有净值增加：

<programlisting>
CREATE TRIGGER transfer_insert
    AFTER INSERT ON transfer
    REFERENCING NEW TABLE AS inserted
    FOR EACH STATEMENT
    EXECUTE FUNCTION check_transfer_balances_to_zero();
</programlisting>

   为每一行执行函数<function>check_matching_pairs</function>以确认（同一个语句）同时对匹配对做了更改 ：

<programlisting>
CREATE TRIGGER paired_items_update
    AFTER UPDATE ON paired_items
    REFERENCING NEW TABLE AS newtab OLD TABLE AS oldtab
    FOR EACH ROW
    EXECUTE FUNCTION check_matching_pairs();
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=22415d81e573e9db4500cd472d308bdd -->

<!-- pgdoc-cn_start sig_en=cbe0b53b943519d9b14f20d8b51e7962 sig_cn_org=None source=14.1 
  <para>
   <xref linkend="trigger-example"/> contains a complete example of a trigger
   function written in C.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="trigger-example"/>包含一个用 C 编写的触发器函数的完整例子。
  </para>
<!-- pgdoc-cn_end sig_en=cbe0b53b943519d9b14f20d8b51e7962 -->
 </refsect1>

 <refsect1 id="sql-createtrigger-compatibility">
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
  <title>Compatibility</title>
________________________________________________________-->
  <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

  <!--
   It's not clear whether SQL/MED contemplates triggers on foreign tables.
   Its <drop basic column definition> General Rules do mention the possibility
   of a reference from a trigger column list.  On the other hand, nothing
   overrides the fact that CREATE TRIGGER only targets base tables.  For now,
   do not document the compatibility status of triggers on foreign tables.
  -->

<!-- pgdoc-cn_start sig_en=59a0e4620db61167fcb4b12ecedf3688 sig_cn_org=None source=14.1 
  <para>
   The <command>CREATE TRIGGER</command> statement in
   <productname>PostgreSQL</productname> implements a subset of the
   <acronym>SQL</acronym> standard. The following functionalities are currently
   missing:

   <itemizedlist>
    <listitem>
     <para>
      While transition table names for <literal>AFTER</literal> triggers are
      specified using the <literal>REFERENCING</literal> clause in the standard way,
      the row variables used in <literal>FOR EACH ROW</literal> triggers may not be
      specified in a <literal>REFERENCING</literal> clause.  They are available in a
      manner that is dependent on the language in which the trigger function
      is written, but is fixed for any one language.  Some languages
      effectively behave as though there is a <literal>REFERENCING</literal> clause
      containing <literal>OLD ROW AS OLD NEW ROW AS NEW</literal>.
     </para>
    </listitem>

    <listitem>
     <para>
      The standard allows transition tables to be used with
      column-specific <literal>UPDATE</literal> triggers, but then the set of rows
      that should be visible in the transition tables depends on the
      trigger's column list.  This is not currently implemented by
      <productname>PostgreSQL</productname>.
     </para>
    </listitem>

    <listitem>
     <para>
      <productname>PostgreSQL</productname> only allows the execution
      of a user-defined function for the triggered action.  The standard
      allows the execution of a number of other SQL commands, such as
      <command>CREATE TABLE</command>, as the triggered action.  This
      limitation is not hard to work around by creating a user-defined
      function that executes the desired commands.
     </para>
    </listitem>

   </itemizedlist>
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>中的<command>CREATE TRIGGER</command>语句实现了<acronym>SQL</acronym>标准的一个子集。目前缺少下列功能：

   <itemizedlist>
    <listitem>
     <para>
      虽然<literal>AFTER</literal>触发器的传递表名是以标准的方式用<literal>REFERENCING</literal>子句指定，但<literal>REFERENCING</literal>子句中不能指定<literal>FOR EACH ROW</literal>触发器中用到的行变量。它们以依赖于编写该触发器函数的语言的方式可用，但是对任意一种语言来说是固定的。一些语言实际上的行为就像有包含<literal>OLD ROW AS OLD NEW ROW AS NEW</literal>的<literal>REFERENCING</literal>子句存在一样。
     </para>
    </listitem>

    <listitem>
     <para>
      标准允许把传递表与和列相关的<literal>UPDATE</literal>触发器一起使用，那么应该在传递表中可见的行集合取决于该触发器的列列表。当前<productname>PostgreSQL</productname>没有实现这一点。
     </para>
    </listitem>

    <listitem>
     <para><productname>PostgreSQL</productname>只允许为被触发动作执行一个用户定义的函数。标准允许执行许多其他的 SQL 命令作为被触发的动作，例如<command>CREATE TABLE</command>。这种限制可以很容易地通过创建一个执行想要的命令的用户定义函数来绕过。
     </para>
    </listitem>

   </itemizedlist>
  </para>
<!-- pgdoc-cn_end sig_en=59a0e4620db61167fcb4b12ecedf3688 -->

<!-- pgdoc-cn_start sig_en=0a1e534211d00ffcceafc0994a60ad3d sig_cn_org=None source=14.1 
  <para>
   SQL specifies that multiple triggers should be fired in
   time-of-creation order.  <productname>PostgreSQL</productname> uses
   name order, which was judged to be more convenient.
  </para>
________________________________________________________-->
  <para>
   SQL 指定多个触发器应该以被创建时间的顺序触发。<productname>PostgreSQL</productname>则使用名称顺序，这被认为更加方便。
  </para>
<!-- pgdoc-cn_end sig_en=0a1e534211d00ffcceafc0994a60ad3d -->

<!-- pgdoc-cn_start sig_en=a4e1c08085aa8250fc672fe536e8241e sig_cn_org=None source=14.1 
  <para>
   SQL specifies that <literal>BEFORE DELETE</literal> triggers on cascaded
   deletes fire <emphasis>after</emphasis> the cascaded <literal>DELETE</literal> completes.
   The <productname>PostgreSQL</productname> behavior is for <literal>BEFORE
   DELETE</literal> to always fire before the delete action, even a cascading
   one.  This is considered more consistent.  There is also nonstandard
   behavior if <literal>BEFORE</literal> triggers modify rows or prevent
   updates during an update that is caused by a referential action.  This can
   lead to constraint violations or stored data that does not honor the
   referential constraint.
  </para>
________________________________________________________-->
  <para>
   SQL 指定级联删除上的<literal>BEFORE DELETE</literal>触发器在级联的<literal>DELETE</literal>完成<emphasis>之后</emphasis>引发。<productname>PostgreSQL</productname>的行为则是<literal>BEFORE DELETE</literal>总是在删除动作之前引发，即使是一个级联删除。这被认为更加一致。 如果<literal>BEFORE</literal>触发器修改行或者在引用动作引起的更新期间阻止更新，这也是非标准行为。这能导致约束违背或者被存储的数据不遵从引用约束。
  </para>
<!-- pgdoc-cn_end sig_en=a4e1c08085aa8250fc672fe536e8241e -->

<!-- pgdoc-cn_start sig_en=b4854f61286a9cd1485b9e1a004efcfc sig_cn_org=None source=14.1 
  <para>
   The ability to specify multiple actions for a single trigger using
   <literal>OR</literal> is a <productname>PostgreSQL</productname> extension of
   the SQL standard.
  </para>
________________________________________________________-->
  <para>
   使用<literal>OR</literal>为一个单一触发器指定多个动作的能力是 SQL 标准的一个<productname>PostgreSQL</productname>扩展。
  </para>
<!-- pgdoc-cn_end sig_en=b4854f61286a9cd1485b9e1a004efcfc -->

<!-- pgdoc-cn_start sig_en=7bf4f5a7a8d0f389a07dd7107e17332d sig_cn_org=None source=14.1 
  <para>
   The ability to fire triggers for <command>TRUNCATE</command> is a
   <productname>PostgreSQL</productname> extension of the SQL standard, as is the
   ability to define statement-level triggers on views.
  </para>
________________________________________________________-->
  <para>
   为<command>TRUNCATE</command>引发触发器的能力是 SQL 标准的一个<productname>PostgreSQL</productname>扩展，在视图上定义语句级触发器的能力也是一样。
  </para>
<!-- pgdoc-cn_end sig_en=7bf4f5a7a8d0f389a07dd7107e17332d -->

<!-- pgdoc-cn_start sig_en=c83d213f6e8808346774dc87ada2d997 sig_cn_org=None source=14.1 
  <para>
   <command>CREATE CONSTRAINT TRIGGER</command> is a
   <productname>PostgreSQL</productname> extension of the <acronym>SQL</acronym>
   standard.
   So is the <literal>OR REPLACE</literal> option.
  </para>
________________________________________________________-->
  <para>
   <command>CREATE CONSTRAINT TRIGGER</command>是<acronym>SQL</acronym>标准的一个<productname>PostgreSQL</productname>扩展。
   所以是<literal>OR REPLACE</literal> 选项。
  </para>
<!-- pgdoc-cn_end sig_en=c83d213f6e8808346774dc87ada2d997 -->

 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=8b7cc214676b443e6527e3d6bf054420 sig_cn_org=None source=14.1 
  <title>See Also</title>
________________________________________________________-->
  <title>参见</title>
<!-- pgdoc-cn_end sig_en=8b7cc214676b443e6527e3d6bf054420 -->

  <simplelist type="inline">
   <member><xref linkend="sql-altertrigger"/></member>
   <member><xref linkend="sql-droptrigger"/></member>
   <member><xref linkend="sql-createfunction"/></member>
   <member><xref linkend="sql-set-constraints"/></member>
  </simplelist>
 </refsect1>
</refentry>
