<!--
doc/src/sgml/ref/create_index.sgml
PostgreSQL documentation
-->

<refentry id="sql-createindex">
<!-- pgdoc-cn_start sig_en=8652f5f1150da98dfcfd350d654cffba sig_cn_org=None source=14.1 
 <indexterm zone="sql-createindex">
  <primary>CREATE INDEX</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="sql-createindex">
  <primary>CREATE INDEX</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=8652f5f1150da98dfcfd350d654cffba -->

 <refmeta>
  <refentrytitle>CREATE INDEX</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

<!-- pgdoc-cn_start sig_en=bb7c523213277782fcc90aadda9ebec7 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>CREATE INDEX</refname>
  <refpurpose>define a new index</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>CREATE INDEX</refname>
  <refpurpose>定义一个新索引</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=bb7c523213277782fcc90aadda9ebec7 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=aeb71b7d164f788df4b35d7f593481e2 sig_cn_org=aeb71b7d164f788df4b35d7f593481e2 source=15.7 
<synopsis>
CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ [ IF NOT EXISTS ] <replaceable class="parameter">name</replaceable> ] ON [ ONLY ] <replaceable class="parameter">table_name</replaceable> [ USING <replaceable class="parameter">method</replaceable> ]
    ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> [ ( <replaceable class="parameter">opclass_parameter</replaceable> = <replaceable class="parameter">value</replaceable> [, ... ] ) ] ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] )
    [ INCLUDE ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    [ NULLS [ NOT ] DISTINCT ]
    [ WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] ) ]
    [ TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]
    [ WHERE <replaceable class="parameter">predicate</replaceable> ]
</synopsis>
________________________________________________________-->
<synopsis>
CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ [ IF NOT EXISTS ] <replaceable class="parameter">name</replaceable> ] ON [ ONLY ] <replaceable class="parameter">table_name</replaceable> [ USING <replaceable class="parameter">method</replaceable> ]
    ( { <replaceable class="parameter">column_name</replaceable> | ( <replaceable class="parameter">expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> [ ( <replaceable class="parameter">opclass_parameter</replaceable> = <replaceable class="parameter">value</replaceable> [, ... ] ) ] ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] )
    [ INCLUDE ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    [ NULLS [ NOT ] DISTINCT ]
    [ WITH ( <replaceable class="parameter">storage_parameter</replaceable> [= <replaceable class="parameter">value</replaceable>] [, ... ] ) ]
    [ TABLESPACE <replaceable class="parameter">tablespace_name</replaceable> ]
    [ WHERE <replaceable class="parameter">predicate</replaceable> ]
</synopsis>
<!-- pgdoc-cn_end sig_en=aeb71b7d164f788df4b35d7f593481e2 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=3eee53d9e0806729689d8db78da38f6a sig_cn_org=None source=14.1 
  <para>
   <command>CREATE INDEX</command> constructs an index on the specified column(s)
   of the specified relation, which can be a table or a materialized view.
   Indexes are primarily used to enhance database performance (though
   inappropriate use can result in slower performance).
  </para>
________________________________________________________-->
  <para>
   <command>CREATE INDEX</command>在指定关系的指定列上构建
   一个索引，该关系可以是一个表或者一个物化视图。索引主要被用来提升
   数据库性能（不过不当的使用会导致性能变差）。
  </para>
<!-- pgdoc-cn_end sig_en=3eee53d9e0806729689d8db78da38f6a -->

<!-- pgdoc-cn_start sig_en=dc5a45bdc9f04c82617c4b322608e16a sig_cn_org=None source=14.1 
  <para>
   The key field(s) for the index are specified as column names,
   or alternatively as expressions written in parentheses.
   Multiple fields can be specified if the index method supports
   multicolumn indexes.
  </para>
________________________________________________________-->
  <para>
   索引的键域被指定为列名或者写在圆括号中的表达式。如果索引方法支持
   多列索引，可以指定多个域。
  </para>
<!-- pgdoc-cn_end sig_en=dc5a45bdc9f04c82617c4b322608e16a -->

<!-- pgdoc-cn_start sig_en=3ec568f558225f9f14c780d839988df1 sig_cn_org=None source=14.1 
  <para>
   An index field can be an expression computed from the values of
   one or more columns of the table row.  This feature can be used
   to obtain fast access to data based on some transformation of
   the basic data. For example, an index computed on
   <literal>upper(col)</literal> would allow the clause
   <literal>WHERE upper(col) = 'JIM'</literal> to use an index.
  </para>
________________________________________________________-->
  <para>
   一个索引域可以是一个从表行的一列或者更多列值进行计算的表达式。
   这种特性可以被用来获得对基于基本数据某种变换的数据的快速访问。
   例如，一个在<literal>upper(col)</literal>上计算的索引可以允许子句
   <literal>WHERE upper(col) = 'JIM'</literal>使用索引。
  </para>
<!-- pgdoc-cn_end sig_en=3ec568f558225f9f14c780d839988df1 -->

<!-- pgdoc-cn_start sig_en=b1ffed8f0353ffd39e9ab0c770ef6c38 sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> provides the index methods
   B-tree, hash, GiST, SP-GiST, GIN, and BRIN.  Users can also define their own
   index methods, but that is fairly complicated.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>提供了索引方法
   B-树、哈希、GiST、SP-GiST、GIN 以及 BRIN。用户也可以定义自己的索引
   方法，但是相对较复杂。
  </para>
<!-- pgdoc-cn_end sig_en=b1ffed8f0353ffd39e9ab0c770ef6c38 -->

<!-- pgdoc-cn_start sig_en=0dd8c1db2a89544e4598aed71e4946fb sig_cn_org=None source=14.1 
  <para>
    When the <literal>WHERE</literal> clause is present, a
    <firstterm>partial index</firstterm> is created.
    A partial index is an index that contains entries for only a portion of
    a table, usually a portion that is more useful for indexing than the
    rest of the table. For example, if you have a table that contains both
    billed and unbilled orders where the unbilled orders take up a small
    fraction of the total table and yet that is an often used section, you
    can improve performance by creating an index on just that portion.
    Another possible application is to use <literal>WHERE</literal> with
    <literal>UNIQUE</literal> to enforce uniqueness over a subset of a
    table.  See <xref linkend="indexes-partial"/> for more discussion.
  </para>
________________________________________________________-->
  <para>
    当<literal>WHERE</literal>子句存在时，会创建一个
    <firstterm>部分索引</firstterm>。部分索引只包含表中一部分行的项，
    通常索引这一部分会比表的其他部分更有用。例如，如果有一个表包含了
    已付和未付订单，其中未付订单占了整个表的一小部分并且是经常被使用
    的部分，可以通过只在这一部分上创建一个索引来改进性能。另一种可能
    的应用是使用带有<literal>UNIQUE</literal>的
    <literal>WHERE</literal>在表的一个子集上强制唯一性。更多的讨论
    请见<xref linkend="indexes-partial"/>。
  </para>
<!-- pgdoc-cn_end sig_en=0dd8c1db2a89544e4598aed71e4946fb -->

<!-- pgdoc-cn_start sig_en=634492bfeeda0aa2dd48ec8f847a3f8a sig_cn_org=None source=14.1 
  <para>
    The expression used in the <literal>WHERE</literal> clause can refer
    only to columns of the underlying table, but it can use all columns,
    not just the ones being indexed.  Presently, subqueries and
    aggregate expressions are also forbidden in <literal>WHERE</literal>.
    The same restrictions apply to index fields that are expressions.
  </para>
________________________________________________________-->
  <para>
    <literal>WHERE</literal>子句中使用的表达式只能引用底层表的列，但
    它可以引用所有列而不仅仅是被索引的列。当前，
    <literal>WHERE</literal>中也禁止使用子查询和聚集表达式。同样的
    限制也适用于表达式索引中的表达式域。
  </para>
<!-- pgdoc-cn_end sig_en=634492bfeeda0aa2dd48ec8f847a3f8a -->

<!-- pgdoc-cn_start sig_en=4d3157907d40174043a5029fea5dc738 sig_cn_org=None source=14.1 
  <para>
   All functions and operators used in an index definition must be
   <quote>immutable</quote>, that is, their results must depend only on
   their arguments and never on any outside influence (such as
   the contents of another table or the current time).  This restriction
   ensures that the behavior of the index is well-defined.  To use a
   user-defined function in an index expression or <literal>WHERE</literal>
   clause, remember to mark the function immutable when you create it.
  </para>
________________________________________________________-->
  <para>
   所有在索引定义中使用的函数和操作符必须是<quote>不可变的</quote>，
   就是说它们的结果必须仅依赖于它们的参数而不受外在因素（例如另
   一个表的内容和当前的时间）的影响。这种限制确保了索引的行为是
   良定的。要在一个索引表达式或者<literal>WHERE</literal>子句中
   使用用户定义的函数，记住在创建函数时把它标记为不可变。
  </para>
<!-- pgdoc-cn_end sig_en=4d3157907d40174043a5029fea5dc738 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
  <title>Parameters</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

    <variablelist>
     <varlistentry>
      <term><literal>UNIQUE</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=3b821409e6bd82e08e4b7feaf4e484d7 sig_cn_org=None source=14.1 
       <para>
        Causes the system to check for
        duplicate values in the table when the index is created (if data
        already exist) and each time data is added. Attempts to
        insert or update data which would result in duplicate entries
        will generate an error.
       </para>
________________________________________________________-->
       <para>
        导致系统在索引被创建时（如果数据已经存在）或者加入数据时
        检查重复值。会导致重复项的数据插入或者更新尝试将会产生一
        个错误。
       </para>
<!-- pgdoc-cn_end sig_en=3b821409e6bd82e08e4b7feaf4e484d7 -->

<!-- pgdoc-cn_start sig_en=76729ddb6737ca0689f78d426a7c2424 sig_cn_org=None source=14.1 
       <para>
        Additional restrictions apply when unique indexes are applied to
        partitioned tables; see <xref linkend="sql-createtable" />.
       </para>
________________________________________________________-->
       <para>
        当唯一索引被应用在分区边上时会有额外的限制，请参考<xref linkend="sql-createtable" />。
       </para>
<!-- pgdoc-cn_end sig_en=76729ddb6737ca0689f78d426a7c2424 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CONCURRENTLY</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=87af5f957748ee6398620d0173167431 sig_cn_org=None source=14.1 
       <para>
        When this option is used, <productname>PostgreSQL</productname> will build the
        index without taking any locks that prevent concurrent inserts,
        updates, or deletes on the table; whereas a standard index build
        locks out writes (but not reads) on the table until it's done.
        There are several caveats to be aware of when using this option
        &mdash; see <xref linkend="sql-createindex-concurrently"/> below.
       </para>
________________________________________________________-->
       <para>
        当使用了这个选项时，<productname>PostgreSQL</productname>在构建索引时
        不会取得任何会阻止该表上并发插入、更新或者删除的锁。而标准的索引
        构建将会把表锁住以阻止对表的写（但不阻塞读），这种锁定会持续到索
        引创建完毕。在使用这个选项时有多个需要注意的地方 &mdash; 请见
        <xref linkend="sql-createindex-concurrently"/>。
       </para>
<!-- pgdoc-cn_end sig_en=87af5f957748ee6398620d0173167431 -->
<!-- pgdoc-cn_start sig_en=8040ad1eae56c635cf1b3e23d4544fa5 sig_cn_org=None source=14.1 
       <para>
        For temporary tables, <command>CREATE INDEX</command> is always
        non-concurrent, as no other session can access them, and
        non-concurrent index creation is cheaper.
       </para>
________________________________________________________-->
       <para>
        对于临时表，<command>CREATE INDEX</command>始终是非并发的，因为没有其他会话可以访问它们，并且创建非并发索引的成本更低。
       </para>
<!-- pgdoc-cn_end sig_en=8040ad1eae56c635cf1b3e23d4544fa5 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>IF NOT EXISTS</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=ac1402b27c5bc8339a4e522a5355f161 sig_cn_org=None source=14.1 
       <para>
        Do not throw an error if a relation with the same name already exists.
        A notice is issued in this case. Note that there is no guarantee that
        the existing index is anything like the one that would have been created.
        Index name is required when <literal>IF NOT EXISTS</literal> is specified.
       </para>
________________________________________________________-->
       <para>
        如果一个同名关系已经存在则不要抛出错误。这种情况下会发出一个提示。
        注意着并不保证现有的索引与将要创建的索引有任何相似。当
        <literal>IF NOT EXISTS</literal>被指定时，需要指定索引名。
       </para>
<!-- pgdoc-cn_end sig_en=ac1402b27c5bc8339a4e522a5355f161 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>INCLUDE</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=e81ac4d7636277af105b93210ea079d4 sig_cn_org=None source=14.1 
       <para>
        The optional <literal>INCLUDE</literal> clause specifies a
        list of columns which will be included in the index
        as <firstterm>non-key</firstterm> columns.  A non-key column cannot
        be used in an index scan search qualification, and it is disregarded
        for purposes of any uniqueness or exclusion constraint enforced by
        the index.  However, an index-only scan can return the contents of
        non-key columns without having to visit the index's table, since
        they are available directly from the index entry.  Thus, addition of
        non-key columns allows index-only scans to be used for queries that
        otherwise could not use them.
       </para>
________________________________________________________-->
       <para>
        可选的<literal>INCLUDE</literal>子句指定一个列的列表，其中的列将被包括在索引中作为<firstterm>非键</firstterm>列。非键列不能作为索引扫描的条件，并且该索引所强制的任何唯一性或者排除约束都不会考虑它们。不过，只用索引的扫描可以返回非键列的内容而无需访问该索引的基表，因为在索引项中就能直接拿到它们。因此，非键列的增加允许查询使用只用索引的扫描，否则就无法使用。
       </para>
<!-- pgdoc-cn_end sig_en=e81ac4d7636277af105b93210ea079d4 -->

<!-- pgdoc-cn_start sig_en=3610d95fc11fd69e608e4e933b65cf4a sig_cn_org=None source=14.1 
       <para>
        It's wise to be conservative about adding non-key columns to an
        index, especially wide columns.  If an index tuple exceeds the
        maximum size allowed for the index type, data insertion will fail.
        In any case, non-key columns duplicate data from the index's table
        and bloat the size of the index, thus potentially slowing searches.
        Furthermore, B-tree deduplication is never used with indexes
        that have a non-key column.
       </para>
________________________________________________________-->
       <para>
        保守地向索引中增加非键列是明智的，特别是很宽的列。如果一个索引元组超过索引类型允许的最大尺寸，数据插入将会失败。在任何情况下，非键列都会重复来自索引基表的数据并且让索引的尺寸膨胀，因此可能会拖慢搜索。此外，B树重复数据删除永远不会与具有非关键列的索引一起使用。
       </para>
<!-- pgdoc-cn_end sig_en=3610d95fc11fd69e608e4e933b65cf4a -->

<!-- pgdoc-cn_start sig_en=ae76edd337267cffd24be68715cfa48b sig_cn_org=None source=14.1 
       <para>
        Columns listed in the <literal>INCLUDE</literal> clause don't need
        appropriate operator classes; the clause can include
        columns whose data types don't have operator classes defined for
        a given access method.
       </para>
________________________________________________________-->
       <para>
        <literal>INCLUDE</literal>子句中列出的列不需要合适的操作符类，甚至数据类型没有为给定的访问方法定义操作符类的列都可以包括在这个子句中。
       </para>
<!-- pgdoc-cn_end sig_en=ae76edd337267cffd24be68715cfa48b -->

<!-- pgdoc-cn_start sig_en=0ec9ee63fb0e9ec4476c3c89473d0fc6 sig_cn_org=None source=14.1 
       <para>
        Expressions are not supported as included columns since they cannot be
        used in index-only scans.
       </para>
________________________________________________________-->
       <para>
        不支持把表达式作为被包括列，因为它们不能被用在只用索引的扫描中。
       </para>
<!-- pgdoc-cn_end sig_en=0ec9ee63fb0e9ec4476c3c89473d0fc6 -->

<!-- pgdoc-cn_start sig_en=84e70bc4f6f5f873072cc54eb68756f8 sig_cn_org=None source=14.1 
       <para>
        Currently, the B-tree, GiST and SP-GiST index access methods support
        this feature.  In these indexes, the values of columns listed
        in the <literal>INCLUDE</literal> clause are included in leaf tuples
        which correspond to heap tuples, but are not included in upper-level
        index entries used for tree navigation.
       </para>
________________________________________________________-->
       <para>
        当前，有B-树、GiST和SP-GiST索引访问方法支持这一特性。
        在这些索引中，<literal>INCLUDE</literal>子句中列出的列的值被包括在对应于堆元组的叶子元组中，但是不包括在用于树导航的上层索引项中。
       </para>
<!-- pgdoc-cn_end sig_en=84e70bc4f6f5f873072cc54eb68756f8 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=6b9a863f715d4989b741523649385c96 sig_cn_org=68d782281c6bc1b07f3b36b84e098c0d source=15.7 
       <para>
        The name of the index to be created.  No schema name can be included
        here; the index is always created in the same schema as its parent
        table.  The name of the index must be distinct from the name of any
        other relation (table, sequence, index, view, materialized view, or
        foreign table) in that schema.
        If the name is omitted, <productname>PostgreSQL</productname> chooses a
        suitable name based on the parent table's name and the indexed column
        name(s).
       </para>
________________________________________________________-->
       <para>
        要创建的索引的名称。这里不能包含模式名称；索引总是在其父表所在的模式中创建。
        索引的名称必须与该模式中的任何其他关系（表、序列、索引、视图、物化视图或外部表）的名称不同。
        如果省略名称，<productname>PostgreSQL</productname>会根据父表的名称和索引列的名称选择一个合适的名称。
       </para>
<!-- pgdoc-cn_end sig_en=6b9a863f715d4989b741523649385c96 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ONLY</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=491e9f2fa9e74123badbe16c48646040 sig_cn_org=None source=14.1 
       <para>
        Indicates not to recurse creating indexes on partitions, if the
        table is partitioned.  The default is to recurse.
       </para>
________________________________________________________-->
       <para>
        如果该表是分区表，指示不要在分区上递归创建索引。默认会递归创建索引。
       </para>
<!-- pgdoc-cn_end sig_en=491e9f2fa9e74123badbe16c48646040 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">table_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=c7b6401f97833e3f75053525f19c8ba8 sig_cn_org=None source=14.1 
       <para>
        The name (possibly schema-qualified) of the table to be indexed.
       </para>
________________________________________________________-->
       <para>
        要被索引的表的名称（可以被模式限定）。
       </para>
<!-- pgdoc-cn_end sig_en=c7b6401f97833e3f75053525f19c8ba8 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">method</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=fc0bd35a69132feccf8a4782e97f9ccb sig_cn_org=0737b455bf4d1fcc864d5ebe6859c182 source=15.7 
       <para>
        The name of the index method to be used.  Choices are
        <literal>btree</literal>, <literal>hash</literal>,
        <literal>gist</literal>, <literal>spgist</literal>, <literal>gin</literal>,
        <literal>brin</literal>, or user-installed access methods like
        <link linkend="bloom">bloom</link>.
        The default method is <literal>btree</literal>.
       </para>
________________________________________________________-->
       <para>
        要使用的索引方法的名称。选择包括<literal>btree</literal>、<literal>hash</literal>、
        <literal>gist</literal>、<literal>spgist</literal>、<literal>gin</literal>、
        <literal>brin</literal>，或用户安装的访问方法，如
        <link linkend="bloom">bloom</link>。
        默认方法是<literal>btree</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=fc0bd35a69132feccf8a4782e97f9ccb -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">column_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=d6ae956f887228aef2b13b8ff4c7b8b2 sig_cn_org=None source=14.1 
       <para>
        The name of a column of the table.
       </para>
________________________________________________________-->
       <para>
        一个表列的名称。
       </para>
<!-- pgdoc-cn_end sig_en=d6ae956f887228aef2b13b8ff4c7b8b2 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">expression</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=dc4b65ec9e0cf76e6c586d519be22295 sig_cn_org=None source=14.1 
       <para>
        An expression based on one or more columns of the table.  The
        expression usually must be written with surrounding parentheses,
        as shown in the syntax.  However, the parentheses can be omitted
        if the expression has the form of a function call.
       </para>
________________________________________________________-->
       <para>
        一个基于一个或者更多个表列的表达式。如语法中所示，表达式通常必须
        被写在圆括号中。不过，如果该表达式是一个函数调用的形式，圆括号可
        以被省略。
       </para>
<!-- pgdoc-cn_end sig_en=dc4b65ec9e0cf76e6c586d519be22295 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">collation</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=cf5c248fe89bd3bfefb916dfd2b70767 sig_cn_org=None source=14.1 
       <para>
        The name of the collation to use for the index.  By default,
        the index uses the collation declared for the column to be
        indexed or the result collation of the expression to be
        indexed.  Indexes with non-default collations can be useful for
        queries that involve expressions using non-default collations.
       </para>
________________________________________________________-->
       <para>
        要用于该索引的排序规则的名称。默认情况下，该索引使用被索引列
        的排序规则或者被索引表达式的结果排序规则。当查询涉及到使用非
        默认排序规则的表达式时，使用非默认排序规则的索引就能排上用场。
       </para>
<!-- pgdoc-cn_end sig_en=cf5c248fe89bd3bfefb916dfd2b70767 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">opclass</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=950850b46c7be109dd121549e5f9731a sig_cn_org=None source=14.1 
       <para>
        The name of an operator class. See below for details.
       </para>
________________________________________________________-->
       <para>
        一个操作符类的名称。详见下文。
       </para>
<!-- pgdoc-cn_end sig_en=950850b46c7be109dd121549e5f9731a -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">opclass_parameter</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=b4263e4931b93596350ffce0083f5937 sig_cn_org=None source=14.1 
       <para>
        The name of an operator class parameter. See below for details.
       </para>
________________________________________________________-->
       <para>
        运算符类参数的名称。详情请见下文。
       </para>
<!-- pgdoc-cn_end sig_en=b4263e4931b93596350ffce0083f5937 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ASC</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=5bfa318be843a053990bb183e6cd986d sig_cn_org=None source=14.1 
       <para>
        Specifies ascending sort order (which is the default).
       </para>
________________________________________________________-->
       <para>
        指定上升排序（默认）。
       </para>
<!-- pgdoc-cn_end sig_en=5bfa318be843a053990bb183e6cd986d -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DESC</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=9025e66434aff5980f7140153a6a90a0 sig_cn_org=None source=14.1 
       <para>
        Specifies descending sort order.
       </para>
________________________________________________________-->
       <para>
        指定下降排序。
       </para>
<!-- pgdoc-cn_end sig_en=9025e66434aff5980f7140153a6a90a0 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NULLS FIRST</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=15fc266fd9c557ca55d48e559792d4c5 sig_cn_org=None source=14.1 
       <para>
        Specifies that nulls sort before non-nulls.  This is the default
        when <literal>DESC</literal> is specified.
       </para>
________________________________________________________-->
       <para>
        指定把空值排序在非空值前面。在指定<literal>DESC</literal>时，
        这是默认行为。
       </para>
<!-- pgdoc-cn_end sig_en=15fc266fd9c557ca55d48e559792d4c5 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NULLS LAST</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=39c427c81e106affa1b24c14f043224f sig_cn_org=None source=14.1 
       <para>
        Specifies that nulls sort after non-nulls.  This is the default
        when <literal>DESC</literal> is not specified.
       </para>
________________________________________________________-->
       <para>
        指定把空值排序在非空值后面。在没有指定<literal>DESC</literal>时，
        这是默认行为。
       </para>
<!-- pgdoc-cn_end sig_en=39c427c81e106affa1b24c14f043224f -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NULLS DISTINCT</literal></term>
      <term><literal>NULLS NOT DISTINCT</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=64c9b2345c3f1aa0bc7735d56213ce43 sig_cn_org=e394c0c8ad30bd9f98d6a516faedebc8 source=15.7 
       <para>
        Specifies whether for a unique index, null values should be considered
        distinct (not equal).  The default is that they are distinct, so that
        a unique index could contain multiple null values in a column.
       </para>
________________________________________________________-->
       <para>
        指定对于唯一索引，是否应将空值视为不同（而非相等）。默认情况下，它们是不同的，
        因此唯一索引可以在列中包含多个空值。
       </para>
<!-- pgdoc-cn_end sig_en=64c9b2345c3f1aa0bc7735d56213ce43 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">storage_parameter</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=018a1bad477fbb36c64bb032cab6dd32 sig_cn_org=None source=14.1 
       <para>
        The name of an index-method-specific storage parameter.  See
        <xref linkend="sql-createindex-storage-parameters"/> below
        for details.
       </para>
________________________________________________________-->
       <para>
        索引方法相关的存储参数的名称。详见
        <xref linkend="sql-createindex-storage-parameters"/>。
       </para>
<!-- pgdoc-cn_end sig_en=018a1bad477fbb36c64bb032cab6dd32 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">tablespace_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=1e9b8792c266abc783b0d71ab1fe37e2 sig_cn_org=None source=14.1 
       <para>
        The tablespace in which to create the index.  If not specified,
        <xref linkend="guc-default-tablespace"/> is consulted, or
        <xref linkend="guc-temp-tablespaces"/> for indexes on temporary
        tables.
       </para>
________________________________________________________-->
       <para>
        在其中创建索引的表空间。如果没有指定，将会使用
        <xref linkend="guc-default-tablespace"/>。或者对临时表上的索引使用
        <xref linkend="guc-temp-tablespaces"/>。
       </para>
<!-- pgdoc-cn_end sig_en=1e9b8792c266abc783b0d71ab1fe37e2 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">predicate</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=dc30f0efc0d0dbcf3ffafbf704e5101e sig_cn_org=None source=14.1 
       <para>
        The constraint expression for a partial index.
       </para>
________________________________________________________-->
       <para>
        部分索引的约束表达式。
       </para>
<!-- pgdoc-cn_end sig_en=dc30f0efc0d0dbcf3ffafbf704e5101e -->
      </listitem>
     </varlistentry>

    </variablelist>

  <refsect2 id="sql-createindex-storage-parameters" xreflabel="Index Storage Parameters">
<!-- pgdoc-cn_start sig_en=96c8e58589051efac3d43ad4c256e7e0 sig_cn_org=None source=14.1 
   <title>Index Storage Parameters</title>
________________________________________________________-->
   <title>索引存储参数</title>
<!-- pgdoc-cn_end sig_en=96c8e58589051efac3d43ad4c256e7e0 -->

<!-- pgdoc-cn_start sig_en=d783b967552be02d56edc94b91d1eab1 sig_cn_org=None source=14.1 
   <para>
    The optional <literal>WITH</literal> clause specifies <firstterm>storage
    parameters</firstterm> for the index.  Each index method has its own set of allowed
    storage parameters.  The B-tree, hash, GiST and SP-GiST index methods all
    accept this parameter:
   </para>
________________________________________________________-->
   <para>
    可选的<literal>WITH</literal>子句为索引指定<firstterm>存储参数</firstterm>。每一种
    索引方法都有自己的存储参数集合。B-树、哈希、GiST以及SP-GiST索引方法都接受这个参数：
   </para>
<!-- pgdoc-cn_end sig_en=d783b967552be02d56edc94b91d1eab1 -->

   <variablelist>
   <varlistentry id="index-reloption-fillfactor" xreflabel="fillfactor">
<!-- pgdoc-cn_start sig_en=9106d94f321b5fb20feffc596344b699 sig_cn_org=None source=14.1 
    <term><literal>fillfactor</literal> (<type>integer</type>)
     <indexterm>
      <primary><varname>fillfactor</varname> storage parameter</primary>
     </indexterm>
    </term>
________________________________________________________-->
    <term><literal>fillfactor</literal> (<type>integer</type>)
     <indexterm>
      <primary><varname>fillfactor</varname> 存储参数</primary>
     </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=9106d94f321b5fb20feffc596344b699 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=838da41c1d4d8b144138e0cc2f8020e0 sig_cn_org=None source=14.1 
     <para>
      The fillfactor for an index is a percentage that determines how full
      the index method will try to pack index pages.  For B-trees, leaf pages
      are filled to this percentage during initial index builds, and also
      when extending the index at the right (adding new largest key values).
      If pages
      subsequently become completely full, they will be split, leading to
      fragmentation of the on-disk index structure.  B-trees use a default
      fillfactor of 90, but any integer value from 10 to 100 can be selected.
     </para>
________________________________________________________-->
     <para>
      索引的填充因子是一个百分数，它决定索引方法将尝试填充索引页面的充满程度。
      对于B-树，在初始的索引构建过程中，叶子页面会被填充至该百分数，当在索引右端扩展索引
      （增加新的最大键值）时也会这样处理。如果页面后来被完全填满，它们就会被分裂，
      导致在磁盘上的索引结构上产生碎片。
      B-树使用了默认的填充因子 90，但是也可以选择为 10 到 100 的任何整数值。
     </para>
<!-- pgdoc-cn_end sig_en=838da41c1d4d8b144138e0cc2f8020e0 -->
<!-- pgdoc-cn_start sig_en=2728b40a47645cc4ddf310d4f16185d5 sig_cn_org=None source=14.1 
     <para>
      B-tree indexes on tables where many inserts and/or updates are
      anticipated can benefit from lower fillfactor settings at
      <command>CREATE INDEX</command> time (following bulk loading into the
      table).  Values in the range of 50 - 90 can usefully <quote>smooth
       out</quote> the <emphasis>rate</emphasis> of page splits during the
      early life of the B-tree index (lowering fillfactor like this may even
      lower the absolute number of page splits, though this effect is highly
      workload dependent).  The B-tree bottom-up index deletion technique
      described in <xref linkend="btree-deletion"/> is dependent on having
      some <quote>extra</quote> space on pages to store <quote>extra</quote>
      tuple versions, and so can be affected by fillfactor (though the effect
      is usually not significant).
     </para>
________________________________________________________-->
     <para>
      对需要进行多次插入和(或)更新的表，B-树索引可以从<command>CREATE INDEX</command>
      时设置的较低的填充因子中受益（跟随批量加载数据到表）。
      50-90范围内的值可以有效地<quote>平滑</quote>在B-树索引的早期生命周期中页面分割的<emphasis>速率</emphasis>
      （这样降低填充因子甚至可以降低页面分割的绝对数量，尽管这种效果高度依赖于工作负载）。
      <xref linkend="btree-deletion"/>中描述的B-树自底向上索引删除技术依赖于页面上有一些
      <quote>额外的</quote>空间来存储<quote>额外的</quote>元组版本，
      因此可能会受到填充因子的影响（尽管效果通常不显著）。
     </para>
<!-- pgdoc-cn_end sig_en=2728b40a47645cc4ddf310d4f16185d5 -->
<!-- pgdoc-cn_start sig_en=32c097ea4c1458fc51feedad54cefddb sig_cn_org=None source=14.1 
     <para>
      In other specific cases it might be useful to increase fillfactor to
      100 at <command>CREATE INDEX</command> time as a way of maximizing
      space utilization.  You should only consider this when you are
      completely sure that the table is static (i.e. that it will never be
      affected by either inserts or updates).  A fillfactor setting of 100
      otherwise risks <emphasis>harming</emphasis> performance: even a few
      updates or inserts will cause a sudden flood of page splits.
     </para>
________________________________________________________-->
     <para>
      在其他特定情况下，在<command>CREATE INDEX</command>时将填充因子增加到100
      可能是有用的，这是一种最大化空间利用率的方法。只有当您完全确定表是静态的
      （即它永远不会受到插入或更新的影响）时，才应该考虑这一点。
      如果填充因子设置为100，则会有<emphasis>损害</emphasis>性能的风险：
      即使是少量更新或插入也会导致页面突然大量拆分。
     </para>
<!-- pgdoc-cn_end sig_en=32c097ea4c1458fc51feedad54cefddb -->
<!-- pgdoc-cn_start sig_en=0ffe553e42a1cb36e880857d2a54e81b sig_cn_org=None source=14.1 
     <para>
      The other index methods use fillfactor in different but roughly
      analogous ways; the default fillfactor varies between methods.
     </para>
________________________________________________________-->
     <para>
      其他索引方法以不同但大致类似的方式使用填充因子；默认填充因子因方法而异。
     </para>
<!-- pgdoc-cn_end sig_en=0ffe553e42a1cb36e880857d2a54e81b -->
    </listitem>
   </varlistentry>
   </variablelist>

<!-- pgdoc-cn_start sig_en=87cbba0860a1b494b587c8e93670490d sig_cn_org=None source=14.1 
   <para>
    B-tree indexes additionally accept this parameter:
   </para>
________________________________________________________-->
   <para>
    B-树索引还接受这个参数：
   </para>
<!-- pgdoc-cn_end sig_en=87cbba0860a1b494b587c8e93670490d -->

   <variablelist>
   <varlistentry id="index-reloption-deduplicate-items" xreflabel="deduplicate_items">
<!-- pgdoc-cn_start sig_en=ddec373de20fbe6e41ee671c61abead6 sig_cn_org=None source=14.1 
    <term><literal>deduplicate_items</literal> (<type>boolean</type>)
     <indexterm>
      <primary><varname>deduplicate_items</varname> storage parameter</primary>
     </indexterm>
    </term>
________________________________________________________-->
    <term><literal>deduplicate_items</literal> (<type>boolean</type>)
     <indexterm>
      <primary><varname>deduplicate_items</varname> storage parameter</primary>
     </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=ddec373de20fbe6e41ee671c61abead6 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=dda5637a395447c7b522acd185ae2cdd sig_cn_org=None source=14.1 
    <para>
      Controls usage of the B-tree deduplication technique described
      in <xref linkend="btree-deduplication"/>.  Set to
      <literal>ON</literal> or <literal>OFF</literal> to enable or
      disable the optimization.  (Alternative spellings of
      <literal>ON</literal> and <literal>OFF</literal> are allowed as
      described in <xref linkend="config-setting"/>.) The default is
      <literal>ON</literal>.
    </para>
________________________________________________________-->
    <para>
      控制<xref linkend="btree-deduplication"/>中描述的 B-树重复数据删除技术的使用。设置为
      <literal>ON</literal>或<literal>OFF</literal>以启用或禁用优化（<literal>ON</literal>
      和<literal>OFF</literal>的其他写法在<xref linkend="config-setting"/>中有介绍）。
      默认值为<literal>ON</literal>.
    </para>
<!-- pgdoc-cn_end sig_en=dda5637a395447c7b522acd185ae2cdd -->

    <note>
<!-- pgdoc-cn_start sig_en=0e5aac393f0fb8696045643999ac6b73 sig_cn_org=None source=14.1 
     <para>
      Turning <literal>deduplicate_items</literal> off via
      <command>ALTER INDEX</command> prevents future insertions from
      triggering deduplication, but does not in itself make existing
      posting list tuples use the standard tuple representation.
     </para>
________________________________________________________-->
     <para>
      通过<command>ALTER INDEX</command>关闭<literal>deduplicate_items</literal>
      可以防止将来的插入触发重复数据删除，但本身不会使现有的发布列表元组使用标准的元组表示。
     </para>
<!-- pgdoc-cn_end sig_en=0e5aac393f0fb8696045643999ac6b73 -->
    </note>
    </listitem>
   </varlistentry>
   </variablelist>

<!-- pgdoc-cn_start sig_en=5c32e5fba86d8a8db74c82beb6800df5 sig_cn_org=None source=14.1 
   <para>
    GiST indexes additionally accept this parameter:
   </para>
________________________________________________________-->
   <para>
    GiST还额外接受这个参数：
   </para>
<!-- pgdoc-cn_end sig_en=5c32e5fba86d8a8db74c82beb6800df5 -->

   <variablelist>
   <varlistentry id="index-reloption-buffering" xreflabel="buffering">
<!-- pgdoc-cn_start sig_en=c62a68e73b5b8a0d2bfc3f5e762a4a45 sig_cn_org=None source=14.1 
    <term><literal>buffering</literal> (<type>enum</type>)
     <indexterm>
      <primary><varname>buffering</varname> storage parameter</primary>
     </indexterm>
    </term>
________________________________________________________-->
    <term><literal>buffering</literal> (<type>enum</type>)
     <indexterm>
      <primary><varname>buffering</varname> 存储参数</primary>
     </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=c62a68e73b5b8a0d2bfc3f5e762a4a45 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=ea1521e6e8a29ede71191c45853be56b sig_cn_org=None source=14.1 
    <para>
     Determines whether the buffered build technique described in
     <xref linkend="gist-buffering-build"/> is used to build the index. With
     <literal>OFF</literal> buffering is disabled, with <literal>ON</literal>
     it is enabled, and with <literal>AUTO</literal> it is initially disabled,
     but is turned on on-the-fly once the index size reaches
     <xref linkend="guc-effective-cache-size"/>.  The default
     is <literal>AUTO</literal>.
     Note that if sorted build is possible, it will be used instead of
     buffered build unless <literal>buffering=ON</literal> is specified.
    </para>
________________________________________________________-->
    <para>
    决定是否用<xref linkend="gist-buffering-build"/>中描述的缓冲构建技术来构建索引。
   当<literal>OFF</literal>时，缓冲被禁用，当<literal>ON</literal>时，它被启用，
   当<literal>AUTO</literal>时，它最初被禁用，但当索引大小达到
   <xref linkend="guc-effective-cache-size"/>时，会立即启用。
   默认值为<literal>AUTO</literal>。
   请注意，如果排序构建是可能的，则除非指定了<literal>buffering=ON</literal>，
   否则将使用排序构建而不是缓冲构建。
    </para>
<!-- pgdoc-cn_end sig_en=ea1521e6e8a29ede71191c45853be56b -->
    </listitem>
   </varlistentry>
   </variablelist>

<!-- pgdoc-cn_start sig_en=23193646d7b0cfe4e0d1873d72b39cd5 sig_cn_org=None source=14.1 
   <para>
    GIN indexes accept different parameters:
   </para>
________________________________________________________-->
   <para>
    GIN索引接受不同的参数：
   </para>
<!-- pgdoc-cn_end sig_en=23193646d7b0cfe4e0d1873d72b39cd5 -->

   <variablelist>
   <varlistentry id="index-reloption-fastupdate" xreflabel="fastupdate">
<!-- pgdoc-cn_start sig_en=bb4125d36dfaf14df27e3751d23614e9 sig_cn_org=None source=14.1 
    <term><literal>fastupdate</literal> (<type>boolean</type>)
     <indexterm>
      <primary><varname>fastupdate</varname> storage parameter</primary>
     </indexterm>
    </term>
________________________________________________________-->
    <term><literal>fastupdate</literal> (<type>boolean</type>)
     <indexterm>
      <primary><varname>fastupdate</varname> 存储参数</primary>
     </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=bb4125d36dfaf14df27e3751d23614e9 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=ba34b0fb67980457fc35b1db04421a3f sig_cn_org=None source=14.1 
    <para>
     This setting controls usage of the fast update technique described in
     <xref linkend="gin-fast-update"/>.  It is a Boolean parameter:
     <literal>ON</literal> enables fast update, <literal>OFF</literal> disables it.
     The default is <literal>ON</literal>.
    </para>
________________________________________________________-->
    <para>
     这个设置控制<xref linkend="gin-fast-update"/>中描述的快速更新
     技术的使用。它是一个布尔参数：<literal>ON</literal>启用快速更新，
     <literal>OFF</literal>禁用之。默认是
     <literal>ON</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=ba34b0fb67980457fc35b1db04421a3f -->

    <note>
<!-- pgdoc-cn_start sig_en=113d3096e52e3792c2aac66250a8bc4e sig_cn_org=None source=14.1 
     <para>
      Turning <literal>fastupdate</literal> off via <command>ALTER INDEX</command> prevents
      future insertions from going into the list of pending index entries,
      but does not in itself flush previous entries.  You might want to
      <command>VACUUM</command> the table or call <function>gin_clean_pending_list</function>
      function afterward to ensure the pending list is emptied.
     </para>
________________________________________________________-->
     <para>
      通过<command>ALTER INDEX</command>关闭<literal>fastupdate</literal>
      会阻止未来的更新进入到待处理索引项列表中，但它不会自己处理之前的
      待处理项。可以使用<command>VACUUM</command>或者调用
      <function>gin_clean_pending_list</function>确保处理完待处理列表的项。
     </para>
<!-- pgdoc-cn_end sig_en=113d3096e52e3792c2aac66250a8bc4e -->
    </note>
    </listitem>
   </varlistentry>
   </variablelist>

   <variablelist>
   <varlistentry id="index-reloption-gin-pending-list-limit" xreflabel="gin_pending_list_limit">
<!-- pgdoc-cn_start sig_en=e756db27141ecaf5d0acb8add4a0e364 sig_cn_org=None source=14.1 
    <term><literal>gin_pending_list_limit</literal> (<type>integer</type>)
     <indexterm>
      <primary><varname>gin_pending_list_limit</varname></primary>
      <secondary>storage parameter</secondary>
     </indexterm>
    </term>
________________________________________________________-->
    <term><literal>gin_pending_list_limit</literal> (<type>integer</type>)
     <indexterm>
      <primary><varname>gin_pending_list_limit</varname></primary>
      <secondary>存储参数</secondary>
     </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=e756db27141ecaf5d0acb8add4a0e364 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=dab7ebc6836ad3dc3cc62957c0c33305 sig_cn_org=None source=14.1 
    <para>
     Custom <xref linkend="guc-gin-pending-list-limit"/> parameter.
     This value is specified in kilobytes.
    </para>
________________________________________________________-->
    <para>
     自定义<xref linkend="guc-gin-pending-list-limit"/>参数。这个值
     要以千字节来指定。
    </para>
<!-- pgdoc-cn_end sig_en=dab7ebc6836ad3dc3cc62957c0c33305 -->
    </listitem>
   </varlistentry>
   </variablelist>

<!-- pgdoc-cn_start sig_en=02dbdf86c53050d89848bacf0be441e9 sig_cn_org=None source=14.1 
   <para>
    <acronym>BRIN</acronym> indexes accept different parameters:
   </para>
________________________________________________________-->
   <para>
    <acronym>BRIN</acronym>索引接受不同的参数：
   </para>
<!-- pgdoc-cn_end sig_en=02dbdf86c53050d89848bacf0be441e9 -->

   <variablelist>
   <varlistentry id="index-reloption-pages-per-range" xreflabel="pages_per_range">
<!-- pgdoc-cn_start sig_en=2d761ec5666c64d33047d8d5969a57e7 sig_cn_org=None source=14.1 
    <term><literal>pages_per_range</literal> (<type>integer</type>)
     <indexterm>
      <primary><varname>pages_per_range</varname> storage parameter</primary>
     </indexterm>
    </term>
________________________________________________________-->
    <term><literal>pages_per_range</literal> (<type>integer</type>)
     <indexterm>
      <primary><varname>pages_per_range</varname> 存储参数</primary>
     </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=2d761ec5666c64d33047d8d5969a57e7 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=9b479b12df9a446c80aaeb1e91184cdc sig_cn_org=None source=14.1 
    <para>
     Defines the number of table blocks that make up one block range for
     each entry of a <acronym>BRIN</acronym> index (see <xref linkend="brin-intro"/>
     for more details).  The default is <literal>128</literal>.
    </para>
________________________________________________________-->
    <para>
     定义用于每一个<acronym>BRIN</acronym>索引项的块范围由多少个表块组成（详见
     <xref linkend="brin-intro"/>）。默认是<literal>128</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=9b479b12df9a446c80aaeb1e91184cdc -->
    </listitem>
   </varlistentry>

   <varlistentry id="index-reloption-autosummarize" xreflabel="autosummarize">
<!-- pgdoc-cn_start sig_en=6fc33fd5fd15f28c33109d5951bac145 sig_cn_org=None source=14.1 
    <term><literal>autosummarize</literal> (<type>boolean</type>)
     <indexterm>
      <primary><varname>autosummarize</varname> storage parameter</primary>
     </indexterm>
    </term>
________________________________________________________-->
    <term><literal>autosummarize</literal> (<type>boolean</type>)
     <indexterm>
      <primary><varname>autosummarize</varname> 存储参数</primary>
     </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=6fc33fd5fd15f28c33109d5951bac145 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=683faa6d4bf7b459b636bda2d5a88d65 sig_cn_org=3a12c7e5713099ddd57010b5a0a8ab54 source=15.7 
    <para>
     Defines whether a summarization run is queued for the previous page
     range whenever an insertion is detected on the next one.
     See <xref linkend="brin-operation"/> for more details.
     The default is <literal>off</literal>.
    </para>
________________________________________________________-->
    <para>
     定义了在下一页检测到插入时，是否为前一页范围排队进行摘要运行。
     更多详细信息请参见<xref linkend="brin-operation"/>。
     默认值为<literal>off</literal>。
</para>
<!-- pgdoc-cn_end sig_en=683faa6d4bf7b459b636bda2d5a88d65 -->
    </listitem>
   </varlistentry>
   </variablelist>
  </refsect2>

  <refsect2 id="sql-createindex-concurrently" xreflabel="Building Indexes Concurrently">
<!-- pgdoc-cn_start sig_en=9abe7564d02a141be99c97d8f445299d sig_cn_org=None source=14.1 
   <title>Building Indexes Concurrently</title>
________________________________________________________-->
   <title>并发构建索引</title>
<!-- pgdoc-cn_end sig_en=9abe7564d02a141be99c97d8f445299d -->

<!-- pgdoc-cn_start sig_en=8a9a1cbcd5d705b9cefd3803a35e3c60 sig_cn_org=None source=14.1 
   <indexterm zone="sql-createindex-concurrently">
   <primary>index</primary>
   <secondary>building concurrently</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="sql-createindex-concurrently">
   <primary>index</primary>
   <secondary>building concurrently</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=8a9a1cbcd5d705b9cefd3803a35e3c60 -->

<!-- pgdoc-cn_start sig_en=85b191f3bf680cc1b3323a49f552a730 sig_cn_org=None source=14.1 
   <para>
    Creating an index can interfere with regular operation of a database.
    Normally <productname>PostgreSQL</productname> locks the table to be indexed against
    writes and performs the entire index build with a single scan of the
    table. Other transactions can still read the table, but if they try to
    insert, update, or delete rows in the table they will block until the
    index build is finished. This could have a severe effect if the system is
    a live production database.  Very large tables can take many hours to be
    indexed, and even for smaller tables, an index build can lock out writers
    for periods that are unacceptably long for a production system.
   </para>
________________________________________________________-->
   <para>
    创建索引可能会干扰数据库的常规操作。通常
    <productname>PostgreSQL</productname>会锁住要被索引的表，让它不能被写入，
    并且用该表上的一次扫描来执行整个索引的构建。其他事务仍然可以读取表 ，
    但是如果它们尝试在该表上进行插入、更新或者删除，它们会被阻塞直到索引
    构建完成。如果系统是一个生产数据库，这可能会导致严重的后果。索引非常
    大的表可能会需要很多个小时，而且即使是较小的表，在构建索引过程中阻塞
    写入者一段时间在生产系统中也是不能接受的。
   </para>
<!-- pgdoc-cn_end sig_en=85b191f3bf680cc1b3323a49f552a730 -->

<!-- pgdoc-cn_start sig_en=08b05fd9bfd8542e0e120ef4c0cad991 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> supports building indexes without locking
    out writes.  This method is invoked by specifying the
    <literal>CONCURRENTLY</literal> option of <command>CREATE INDEX</command>.
    When this option is used,
    <productname>PostgreSQL</productname> must perform two scans of the table, and in
    addition it must wait for all existing transactions that could potentially
    modify or use the index to terminate.  Thus
    this method requires more total work than a standard index build and takes
    significantly longer to complete.  However, since it allows normal
    operations to continue while the index is built, this method is useful for
    adding new indexes in a production environment.  Of course, the extra CPU
    and I/O load imposed by the index creation might slow other operations.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>支持构建索引时不阻塞写入。这种方法通过
    指定<command>CREATE INDEX</command>的<literal>CONCURRENTLY</literal>选项
    实现。当使用这个选项时，<productname>PostgreSQL</productname>必须执行该表的
    两次扫描，此外它必须等待所有现有可能会修改或者使用该索引的事务终止。因此这种
    方法比起标准索引构建过程来说要做更多工作并且需要更多时间。不过，由于它
    允许在构建索引时继续普通操作，这种方式对于在生产环境中增加新索引很有用。
    当然，由索引创建带来的额外 CPU 和 I/O 开销可能会拖慢其他操作。
   </para>
<!-- pgdoc-cn_end sig_en=08b05fd9bfd8542e0e120ef4c0cad991 -->

<!-- pgdoc-cn_start sig_en=4e6a1ab6ab26a78d23c0647a3324a9fa sig_cn_org=3329aec4e756531cecad56b19b4abd32 source=15.7 
   <para>
    In a concurrent index build, the index is actually entered as an
    <quote>invalid</quote> index into
    the system catalogs in one transaction, then two table scans occur in
    two more transactions.  Before each table scan, the index build must
    wait for existing transactions that have modified the table to terminate.
    After the second scan, the index build must wait for any transactions
    that have a snapshot (see <xref linkend="mvcc"/>) predating the second
    scan to terminate, including transactions used by any phase of concurrent
    index builds on other tables, if the indexes involved are partial or have
    columns that are not simple column references.
    Then finally the index can be marked <quote>valid</quote> and ready for use,
    and the <command>CREATE INDEX</command> command terminates.
    Even then, however, the index may not be immediately usable for queries:
    in the worst case, it cannot be used as long as transactions exist that
    predate the start of the index build.
   </para>
________________________________________________________-->
   <para>
    在并发索引构建中，索引实际上是在一个事务中作为一个<quote>无效</quote>索引输入到系统目录中，
    然后在另外两个事务中进行两次表扫描。在每次表扫描之前，索引构建必须等待已经修改表的现有事务终止。
    在第二次扫描之后，索引构建必须等待任何具有早于第二次扫描的快照（参见<xref linkend="mvcc"/>）的事务终止，
    包括任何并发索引构建的其他表上使用的事务，如果涉及的索引是部分索引或具有不是简单列引用的列。
    然后最终索引可以标记为<quote>有效</quote>并准备好使用，<command>CREATE INDEX</command>命令终止。
    即使如此，索引可能不会立即用于查询：在最坏的情况下，只要存在早于索引构建开始的事务，索引就无法使用。
</para>
<!-- pgdoc-cn_end sig_en=4e6a1ab6ab26a78d23c0647a3324a9fa -->

<!-- pgdoc-cn_start sig_en=f2581e77f39d8fa09de401ddc2a7bb1c sig_cn_org=c44d0f9f20c7f68cc9f338bb20815da2 source=15.7 
   <para>
    If a problem arises while scanning the table, such as a deadlock or a
    uniqueness violation in a unique index, the <command>CREATE INDEX</command>
    command will fail but leave behind an <quote>invalid</quote> index. This index
    will be ignored for querying purposes because it might be incomplete;
    however it will still consume update overhead. The <application>psql</application>
    <command>\d</command> command will report such an index as <literal>INVALID</literal>:

<programlisting>
postgres=# \d tab
       Table "public.tab"
 Column |  Type   | Collation | Nullable | Default
-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-
 col    | integer |           |          |
Indexes:
    "idx" btree (col) INVALID
</programlisting>

    The recommended recovery
    method in such cases is to drop the index and try again to perform
    <command>CREATE INDEX CONCURRENTLY</command>.  (Another possibility is
    to rebuild the index with <command>REINDEX INDEX CONCURRENTLY</command>).
   </para>
________________________________________________________-->
   <para>
    如果在扫描表时出现问题，比如死锁或唯一索引中的唯一性冲突，<command>CREATE INDEX</command>命令将失败，
    但会留下一个<quote>无效</quote>的索引。这个索引将被忽略用于查询，因为它可能是不完整的；
    但它仍会消耗更新开销。 <application>psql</application> <command>\d</command> 命令将把这样的索引报告为 <literal>INVALID</literal>：

<programlisting>
postgres=# \d tab
       Table "public.tab"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 col    | integer |           |          |
Indexes:
    "idx" btree (col) INVALID
</programlisting>

    在这种情况下推荐的恢复方法是删除索引，然后尝试再次执行 <command>CREATE INDEX CONCURRENTLY</command>。
    （另一种可能性是使用 <command>REINDEX INDEX CONCURRENTLY</command> 重建索引）。
   </para>
<!-- pgdoc-cn_end sig_en=f2581e77f39d8fa09de401ddc2a7bb1c -->

<!-- pgdoc-cn_start sig_en=ceac8b981e66eeb83e313fe466c73a09 sig_cn_org=None source=14.1 
   <para>
    Another caveat when building a unique index concurrently is that the
    uniqueness constraint is already being enforced against other transactions
    when the second table scan begins.  This means that constraint violations
    could be reported in other queries prior to the index becoming available
    for use, or even in cases where the index build eventually fails.  Also,
    if a failure does occur in the second scan, the <quote>invalid</quote> index
    continues to enforce its uniqueness constraint afterwards.
   </para>
________________________________________________________-->
   <para>
    并发构建一个唯一索引时需要注意的另一点是，当第二次表扫描开始时，唯一约束
    已经被强制在其他事务上。这意味着在该索引变得可用之前，其他查询中可能就会
    报告该约束被违背，或者甚至在索引构建最终失败的情况中也是这样。还有，如果在
    第二次扫描时发生失败，<quote>无效的</quote>索引也会继续强制它的唯一性约束。
   </para>
<!-- pgdoc-cn_end sig_en=ceac8b981e66eeb83e313fe466c73a09 -->

<!-- pgdoc-cn_start sig_en=861b3b7d76db75f3ce84c57447c0d6e6 sig_cn_org=None source=14.1 
   <para>
    Concurrent builds of expression indexes and partial indexes are supported.
    Errors occurring in the evaluation of these expressions could cause
    behavior similar to that described above for unique constraint violations.
   </para>
________________________________________________________-->
   <para>
    表达式索引和部分索引的并发构建也被支持。在这些表达式计算过程中发生的
    错误可能导致和上述唯一约束违背类似的行为。
   </para>
<!-- pgdoc-cn_end sig_en=861b3b7d76db75f3ce84c57447c0d6e6 -->

<!-- pgdoc-cn_start sig_en=6613bbc4b74938f4eccfc21d68b4d093 sig_cn_org=None source=14.1 
   <para>
    Regular index builds permit other regular index builds on the
    same table to occur simultaneously, but only one concurrent index build
    can occur on a table at a time.  In either case, schema modification of the
    table is not allowed while the index is being built.  Another difference is
    that a regular <command>CREATE INDEX</command> command can be performed
    within a transaction block, but <command>CREATE INDEX CONCURRENTLY</command>
    cannot.
   </para>
________________________________________________________-->
   <para>
    常规索引构建允许在同一个表上同时构建其他常规索引，但是在一个表上同时
    只能有一个并发索引构建发生。在两种情况下，在索引被构建时不允许表的模式修改。另一个不同是，一个常规<command>CREATE INDEX</command>
    命令可以在一个事务块中执行，但是
    <command>CREATE INDEX CONCURRENTLY</command>不行。
   </para>
<!-- pgdoc-cn_end sig_en=6613bbc4b74938f4eccfc21d68b4d093 -->

<!-- pgdoc-cn_start sig_en=30ac42782470fc5a934348ab626792e4 sig_cn_org=None source=14.1 
   <para>
    Concurrent builds for indexes on partitioned tables are currently not
    supported.  However, you may concurrently build the index on each
    partition individually and then finally create the partitioned index
    non-concurrently in order to reduce the time where writes to the
    partitioned table will be locked out.  In this case, building the
    partitioned index is a metadata only operation.
   </para>
________________________________________________________-->
   <para>
    当前不支持在分区表上并发生成索引。
    然而，你可以在每个分区上单独的并发构建索引，然后最终以非并发的方式创建分区索引，以减少对分区表的写入被锁定的时间。   
    在这种情况下，生成分区索引仅是元数据操作。
   </para>
<!-- pgdoc-cn_end sig_en=30ac42782470fc5a934348ab626792e4 -->

  </refsect2>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
  <title>Notes</title>
________________________________________________________-->
  <title>注解</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->

<!-- pgdoc-cn_start sig_en=7203cdee804252a37e87f4424f3c39ef sig_cn_org=None source=14.1 
  <para>
   See <xref linkend="indexes"/> for information about when indexes can
   be used, when they are not used, and in which particular situations
   they can be useful.
  </para>
________________________________________________________-->
  <para>
   关于索引何时能被使用、何时不被使用以及什么情况下它们有用的信息请
   见<xref linkend="indexes"/>。
  </para>
<!-- pgdoc-cn_end sig_en=7203cdee804252a37e87f4424f3c39ef -->

<!-- pgdoc-cn_start sig_en=90ff912608be5155f9d298a0a456d38b sig_cn_org=None source=14.1 
  <para>
   Currently, only the B-tree, GiST, GIN, and BRIN index methods support
   multiple-key-column indexes.  Whether there can be multiple key
   columns is independent of whether <literal>INCLUDE</literal> columns
   can be added to the index.  Indexes can have up to 32 columns,
   including <literal>INCLUDE</literal> columns.
   (This limit can be altered when building
   <productname>PostgreSQL</productname>.)  Only B-tree currently
   supports unique indexes.
  </para>
________________________________________________________-->
  <para>
   当前，只有 B-树、GiST、GIN 和 BRIN 索引方法支持多键列索引。
   是否可以有多个键列与是否可以将<literal>INCLUDE</literal>列添加到索引无关。
   索引最多可以有32列，包括<literal>INCLUDE</literal>列。
   （可以在构建<productname>PostgreSQL</productname>时修改这个限制）。
   当前只有 B-树支持唯一索引。
  </para>
<!-- pgdoc-cn_end sig_en=90ff912608be5155f9d298a0a456d38b -->

<!-- pgdoc-cn_start sig_en=b3889323983d20731968cbe66dc665e8 sig_cn_org=None source=14.1 
  <para>
   An <firstterm>operator class</firstterm> with optional parameters
   can be specified for each column of an index.
   The operator class identifies the operators to be
   used by the index for that column. For example, a B-tree index on
   four-byte integers would use the <literal>int4_ops</literal> class;
   this operator class includes comparison functions for four-byte
   integers. In practice the default operator class for the column's data
   type is usually sufficient. The main point of having operator classes
   is that for some data types, there could be more than one meaningful
   ordering. For example, we might want to sort a complex-number data
   type either by absolute value or by real part. We could do this by
   defining two operator classes for the data type and then selecting
   the proper class when creating an index.  More information about
   operator classes is in <xref linkend="indexes-opclass"/> and in <xref
   linkend="xindex"/>.
  </para>
________________________________________________________-->
  <para>
   为索引的每一列可以指定一个带可选参数的<firstterm>操作符类</firstterm>。该操作符
   类标识要被该索引用于该列的操作符。例如，一个四字节整数上的 B-树索引
   会使用<literal>int4_ops</literal>类。这个操作符类包括了用于四字节整数
   的比较函数。实际上，通常列数据类型的默认操作符类就足够了。对某些数据
   类型指定操作符类的主要原因是，可能会有多于一种有意义的顺序。例如，
   我们可能想用绝对值或者实数部分对复数类型排序。我们可以通过为该数据
   类型定义两个操作符类来做到，并且在创建索引时选择其中合适的类。更多
   有关操作符类的信息请见<xref linkend="indexes-opclass"/>以及<xref
   linkend="xindex"/>。
  </para>
<!-- pgdoc-cn_end sig_en=b3889323983d20731968cbe66dc665e8 -->

<!-- pgdoc-cn_start sig_en=1b2ea0573788dcaab10d6bf84b09d1ab sig_cn_org=None source=14.1 
  <para>
   When <literal>CREATE INDEX</literal> is invoked on a partitioned
   table, the default behavior is to recurse to all partitions to ensure
   they all have matching indexes.
   Each partition is first checked to determine whether an equivalent
   index already exists, and if so, that index will become attached as a
   partition index to the index being created, which will become its
   parent index.
   If no matching index exists, a new index will be created and
   automatically attached; the name of the new index in each partition
   will be determined as if no index name had been specified in the
   command.
   If the <literal>ONLY</literal> option is specified, no recursion
   is done, and the index is marked invalid.
   (<command>ALTER INDEX ... ATTACH PARTITION</command> marks the index
   valid, once all partitions acquire matching indexes.)  Note, however,
   that any partition that is created in the future using
   <command>CREATE TABLE ... PARTITION OF</command> will automatically
   have a matching index, regardless of whether <literal>ONLY</literal> is
   specified.
  </para>
________________________________________________________-->
  <para>
   当在一个分区表上调用<literal>CREATE INDEX</literal>时，默认的行为是递归到所有的分区上以确保它们都具有匹配的索引。每一个分区首先会被检查是否有一个等效的索引存在，如果有则该索引将被挂接为被创建索引的一个分区索引，而被创建的索引将成为其父索引。如果不存在匹配的索引，则会创建一个新的索引并且自动进行挂接。如果命令中没有指定索引名称，每个分区中的新索引的名称将被自动决定。如果指定了<literal>ONLY</literal>选项，则不会进行递归，并且该索引会被标记为无效（一旦所有的分区都得到该索引，<command>ALTER INDEX ... ATTACH PARTITION</command>可以把该索引标记为有效）。不过，要注意不管是否指定这一选项，未来使用<command>CREATE TABLE ... PARTITION OF</command>创建的任何分区将自动有一个匹配的索引，不管有没有指定<literal>ONLY</literal>。
  </para>
<!-- pgdoc-cn_end sig_en=1b2ea0573788dcaab10d6bf84b09d1ab -->

<!-- pgdoc-cn_start sig_en=b2341a0f7cf64f386f16342242a55401 sig_cn_org=None source=14.1 
  <para>
   For index methods that support ordered scans (currently, only B-tree),
   the optional clauses <literal>ASC</literal>, <literal>DESC</literal>, <literal>NULLS
   FIRST</literal>, and/or <literal>NULLS LAST</literal> can be specified to modify
   the sort ordering of the index.  Since an ordered index can be
   scanned either forward or backward, it is not normally useful to create a
   single-column <literal>DESC</literal> index &mdash; that sort ordering is already
   available with a regular index.  The value of these options is that
   multicolumn indexes can be created that match the sort ordering requested
   by a mixed-ordering query, such as <literal>SELECT ... ORDER BY x ASC, y
   DESC</literal>.  The <literal>NULLS</literal> options are useful if you need to support
   <quote>nulls sort low</quote> behavior, rather than the default <quote>nulls
   sort high</quote>, in queries that depend on indexes to avoid sorting steps.
  </para>
________________________________________________________-->
  <para>
   对于支持有序扫描的索引方法（当前只有 B-树），可以指定可选子句<literal>ASC</literal>、
   <literal>DESC</literal>、<literal>NULLS FIRST</literal>以及<literal>NULLS LAST</literal>
   来修改索引的排序顺序。由于一个有序索引能前向或者反向扫描，通常创建一个
   单列<literal>DESC</literal>索引没什么用处 &mdash; 一个常规索引已经提供了排序
   顺序。这些选项的价值是可以创建多列索引，让它的排序顺序匹配有混合排序要求
   的查询，例如<literal>SELECT ... ORDER BY x ASC, y
   DESC</literal>。如果你想要在依靠索引避免排序步骤的查询中支持
   <quote>空值排序低</quote>这种行为，<literal>NULLS</literal>选项就能派上用场，默认
   的行为是<quote>空值排序高</quote>。
  </para>
<!-- pgdoc-cn_end sig_en=b2341a0f7cf64f386f16342242a55401 -->

<!-- pgdoc-cn_start sig_en=1050d015a37a2d64180ac2bc09b83850 sig_cn_org=None source=14.1 
  <para>
   The system regularly collects statistics on all of a table's
   columns.  Newly-created non-expression indexes can immediately
   use these statistics to determine an index's usefulness.
   For new expression indexes, it is necessary to run <link
   linkend="sql-analyze"><command>ANALYZE</command></link> or wait for
   the <link linkend="autovacuum">autovacuum daemon</link> to analyze
   the table to generate statistics for these indexes.
  </para>
________________________________________________________-->
  <para>
   系统定期收集表中所有列的统计信息。新创建的非表达式索引可以立即使用
   这些统计数据来确定索引的有用性。对于新的表达式索引，需要运行
   <link linkend="sql-analyze"><command>ANALYZE</command></link>
   或等待<link linkend="autovacuum">autovacuum守护程序</link>分析表以
   生成这些索引的统计信息。
  </para>
<!-- pgdoc-cn_end sig_en=1050d015a37a2d64180ac2bc09b83850 -->

<!-- pgdoc-cn_start sig_en=607cb05ad3de1d07e6926ca646ade7e7 sig_cn_org=None source=14.1 
  <para>
   For most index methods, the speed of creating an index is
   dependent on the setting of <xref linkend="guc-maintenance-work-mem"/>.
   Larger values will reduce the time needed for index creation, so long
   as you don't make it larger than the amount of memory really available,
   which would drive the machine into swapping.
  </para>
________________________________________________________-->
  <para>
   对于大多数索引方法，索引的创建速度取决于
   <xref linkend="guc-maintenance-work-mem"/>的设置。较大的值将会减少
   索引创建所需的时间，当然不要把它设置得超过实际可用的内存量（那会迫使
   机器进行交换）。
  </para>
<!-- pgdoc-cn_end sig_en=607cb05ad3de1d07e6926ca646ade7e7 -->

<!-- pgdoc-cn_start sig_en=db08ad9590064974749ab21c518c4bcb sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> can build indexes while
   leveraging multiple CPUs in order to process the table rows faster.
   This feature is known as <firstterm>parallel index
   build</firstterm>.  For index methods that support building indexes
   in parallel (currently, only B-tree),
   <varname>maintenance_work_mem</varname> specifies the maximum
   amount of memory that can be used by each index build operation as
   a whole, regardless of how many worker processes were started.
   Generally, a cost model automatically determines how many worker
   processes should be requested, if any.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>可以在构建索引时利用多个CPU以更快地处理表行。这种特性被称为<firstterm>并行索引构建</firstterm>。对于支持并行构建索引的索引方法（当前只有B-树），<varname>maintenance_work_mem</varname>指定每次索引构建操作整体可用的最大内存量，而不管启动了多少工作者进程。一般来说，一个代价模型（如果有）自动判断应该请求多少工作者进程。
  </para>
<!-- pgdoc-cn_end sig_en=db08ad9590064974749ab21c518c4bcb -->

<!-- pgdoc-cn_start sig_en=8ea6b645e08a6dc76afbc220047bf222 sig_cn_org=None source=14.1 
  <para>
   Parallel index builds may benefit from increasing
   <varname>maintenance_work_mem</varname> where an equivalent serial
   index build will see little or no benefit.  Note that
   <varname>maintenance_work_mem</varname> may influence the number of
   worker processes requested, since parallel workers must have at
   least a <literal>32MB</literal> share of the total
   <varname>maintenance_work_mem</varname> budget.  There must also be
   a remaining <literal>32MB</literal> share for the leader process.
   Increasing <xref linkend="guc-max-parallel-maintenance-workers"/>
   may allow more workers to be used, which will reduce the time
   needed for index creation, so long as the index build is not
   already I/O bound.  Of course, there should also be sufficient
   CPU capacity that would otherwise lie idle.
  </para>
________________________________________________________-->
  <para>
   增加<varname>maintenance_work_mem</varname>可以让并行索引构建受益，而等效的串行索引构建将无法受益或者得到很小的益处。注意<varname>maintenance_work_mem</varname>可能会影响请求的工作者进程的数量，因为并行工作者必须在总的<varname>maintenance_work_mem</varname>预算中占有至少<literal>32MB</literal>的份额。还必须有<literal>32MB</literal>的份额留给领袖进程。增加<xref linkend="guc-max-parallel-maintenance-workers"/>可以允许使用更多的工作者，这将降低索引创建所需的时间，只要索引构建不是I/O密集型的。当然，还需要有足够的CPU计算能力，否则工作者们会闲置。
  </para>
<!-- pgdoc-cn_end sig_en=8ea6b645e08a6dc76afbc220047bf222 -->

<!-- pgdoc-cn_start sig_en=912cc98504fec1462bc93e2a86c2fb76 sig_cn_org=None source=14.1 
  <para>
   Setting a value for <literal>parallel_workers</literal> via <link
   linkend="sql-altertable"><command>ALTER TABLE</command></link> directly controls how many parallel
   worker processes will be requested by a <command>CREATE
   INDEX</command> against the table.  This bypasses the cost model
   completely, and prevents <varname>maintenance_work_mem</varname>
   from affecting how many parallel workers are requested.  Setting
   <literal>parallel_workers</literal> to 0 via <command>ALTER
   TABLE</command> will disable parallel index builds on the table in
   all cases.
  </para>
________________________________________________________-->
  <para>
   通过<link linkend="sql-altertable"><command>ALTER TABLE</command></link>为<literal>parallel_workers</literal>设置一个值直接控制着<command>CREATE INDEX</command>会对表请求多少并行工作者进程。这会完全绕过代价模型，并且防止<varname>maintenance_work_mem</varname>对请求多少并行工作者产生影响。通过<command>ALTER TABLE</command>将<literal>parallel_workers</literal>设置为0将禁用所有情况下的并行索引构建。
  </para>
<!-- pgdoc-cn_end sig_en=912cc98504fec1462bc93e2a86c2fb76 -->

  <tip>
<!-- pgdoc-cn_start sig_en=fb7baecfbd507558f0fc33dadf07cb6d sig_cn_org=None source=14.1 
   <para>
    You might want to reset <literal>parallel_workers</literal> after
    setting it as part of tuning an index build.  This avoids
    inadvertent changes to query plans, since
    <literal>parallel_workers</literal> affects
    <emphasis>all</emphasis> parallel table scans.
   </para>
________________________________________________________-->
   <para>
    在把<literal>parallel_workers</literal>用于调优一次索引构建之后，你可能想要重置<literal>parallel_workers</literal>。这可以避免对查询计划的无意更改，因为<literal>parallel_workers</literal>影响<emphasis>所有的</emphasis>并行表扫描。
   </para>
<!-- pgdoc-cn_end sig_en=fb7baecfbd507558f0fc33dadf07cb6d -->
  </tip>

<!-- pgdoc-cn_start sig_en=85f47914eafff03ade7ef1febe4ef6fe sig_cn_org=None source=14.1 
  <para>
   While <command>CREATE INDEX</command> with the
   <literal>CONCURRENTLY</literal> option supports parallel builds
   without special restrictions, only the first table scan is actually
   performed in parallel.
  </para>
________________________________________________________-->
  <para>
   虽然带有<literal>CONCURRENTLY</literal>选项的<command>CREATE INDEX</command>支持并行构建并且没有特殊的限制，但只有第一次表扫描会实际以并行方式执行。
  </para>
<!-- pgdoc-cn_end sig_en=85f47914eafff03ade7ef1febe4ef6fe -->

<!-- pgdoc-cn_start sig_en=9e29190f5d9c4ffb06f03dde97f653bf sig_cn_org=None source=14.1 
  <para>
   Use <link linkend="sql-dropindex"><command>DROP INDEX</command></link>
   to remove an index.
  </para>
________________________________________________________-->
  <para>
   使用<link linkend="sql-dropindex"><command>DROP INDEX</command></link>可以移除一个索引。
  </para>
<!-- pgdoc-cn_end sig_en=9e29190f5d9c4ffb06f03dde97f653bf -->

<!-- pgdoc-cn_start sig_en=32d3d897541b868819ac2ece34538244 sig_cn_org=dea9c95b63034e4925687b21a49f73f3 source=15.7 
  <para>
   Like any long-running transaction, <command>CREATE INDEX</command> on a
   table can affect which tuples can be removed by concurrent
   <command>VACUUM</command> on any other table.
  </para>
________________________________________________________-->
  <para>
   与任何长时间运行的事务一样，在表上执行<command>CREATE INDEX</command>可能会影响哪些元组可以被并发的<command>VACUUM</command>在任何其他表上移除。
  </para>
<!-- pgdoc-cn_end sig_en=32d3d897541b868819ac2ece34538244 -->

<!-- pgdoc-cn_start sig_en=db387b7b09beb1220fa03c512709d87d sig_cn_org=None source=14.1 
  <para>
   Prior releases of <productname>PostgreSQL</productname> also had an
   R-tree index method.  This method has been removed because
   it had no significant advantages over the GiST method.
   If <literal>USING rtree</literal> is specified, <command>CREATE INDEX</command>
   will interpret it as <literal>USING gist</literal>, to simplify conversion
   of old databases to GiST.
  </para>
________________________________________________________-->
  <para>
   以前的<productname>PostgreSQL</productname>发行也有一种 R-树
   索引方法。这种方法已经被移除，因为它比起 GiST 方法来说没有什么明显的
   优势。如果指定了<literal>USING rtree</literal>，<command>CREATE INDEX</command>
   将会把它解释为<literal>USING gist</literal>，以便把旧的数据库转换成 GiST。
  </para>
<!-- pgdoc-cn_end sig_en=db387b7b09beb1220fa03c512709d87d -->

<!-- pgdoc-cn_start sig_en=8a642cfc301af6cc1fbdc04f49ca313e sig_cn_org=None source=14.1 
  <para>
    Each backend running <command>CREATE INDEX</command> will report its
    progress in the <structname>pg_stat_progress_create_index</structname>
    view. See <xref linkend="create-index-progress-reporting"/> for details.
  </para>
________________________________________________________-->
  <para>
    每个运行<command>CREATE INDEX</command>的后端将在
    <structname>pg_stat_progress_create_index</structname>视图中报告其进度。
    有关详细信息，请参见<xref linkend="create-index-progress-reporting"/>。
  </para>
<!-- pgdoc-cn_end sig_en=8a642cfc301af6cc1fbdc04f49ca313e -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
  <title>Examples</title>
________________________________________________________-->
  <title>示例</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=f6acd33cca04cec436429c81836db002 sig_cn_org=None source=14.1 
  <para>
   To create a unique B-tree index on the column <literal>title</literal> in
   the table <literal>films</literal>:
<programlisting>
CREATE UNIQUE INDEX title_idx ON films (title);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   在表<literal>films</literal>中的列<literal>title</literal>上创建一个
   B-树索引：
<programlisting>
CREATE UNIQUE INDEX title_idx ON films (title);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=f6acd33cca04cec436429c81836db002 -->

<!-- pgdoc-cn_start sig_en=1ddc0b406e16d8e919b6cec85dae473e sig_cn_org=None source=14.1 
  <para>
   To create a unique B-tree index on the column <literal>title</literal>
   with included columns <literal>director</literal>
   and <literal>rating</literal> in the table <literal>films</literal>:
<programlisting>
CREATE UNIQUE INDEX title_idx ON films (title) INCLUDE (director, rating);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   要在表<literal>films</literal>的列<literal>title</literal>上创建一个唯一的B-树索引并且包括列<literal>director</literal>和<literal>rating</literal>：
<programlisting>
CREATE UNIQUE INDEX title_idx ON films (title) INCLUDE (director, rating);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=1ddc0b406e16d8e919b6cec85dae473e -->

<!-- pgdoc-cn_start sig_en=affcaaf87912b2da84508515bae168aa sig_cn_org=None source=14.1 
  <para>
   To create a B-Tree index with deduplication disabled:
<programlisting>
CREATE INDEX title_idx ON films (title) WITH (deduplicate_items = off);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   要创建禁用重复数据删除的 B 树索引：
<programlisting>
CREATE INDEX title_idx ON films (title) WITH (deduplicate_items = off);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=affcaaf87912b2da84508515bae168aa -->

<!-- pgdoc-cn_start sig_en=34720359dbad33ab3ced64eb2ebbb92a sig_cn_org=None source=14.1 
  <para>
   To create an index on the expression <literal>lower(title)</literal>,
   allowing efficient case-insensitive searches:
<programlisting>
CREATE INDEX ON films ((lower(title)));
</programlisting>
   (In this example we have chosen to omit the index name, so the system
   will choose a name, typically <literal>films_lower_idx</literal>.)
  </para>
________________________________________________________-->
  <para>
   在表达式<literal>lower(title)</literal>上创建一个索引来允许高效的大小写
   无关搜索：
<programlisting>
CREATE INDEX ON films ((lower(title)));
</programlisting>
   （在这个例子中我们选择省略索引名称，这样系统会选择一个名字，
   通常是<literal>films_lower_idx</literal>）。
  </para>
<!-- pgdoc-cn_end sig_en=34720359dbad33ab3ced64eb2ebbb92a -->

<!-- pgdoc-cn_start sig_en=914de0065261b9b7613ee3c21f08f8c2 sig_cn_org=None source=14.1 
  <para>
   To create an index with non-default collation:
<programlisting>
CREATE INDEX title_idx_german ON films (title COLLATE "de_DE");
</programlisting>
  </para>
________________________________________________________-->
  <para>
   创建一个具有非默认排序规则的索引：
<programlisting>
CREATE INDEX title_idx_german ON films (title COLLATE "de_DE");
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=914de0065261b9b7613ee3c21f08f8c2 -->

<!-- pgdoc-cn_start sig_en=17e125bc5433fa5ea03ba0cce2d439c4 sig_cn_org=None source=14.1 
  <para>
   To create an index with non-default sort ordering of nulls:
<programlisting>
CREATE INDEX title_idx_nulls_low ON films (title NULLS FIRST);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   创建一个具有非默认空值排序顺序的索引：
<programlisting>
CREATE INDEX title_idx_nulls_low ON films (title NULLS FIRST);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=17e125bc5433fa5ea03ba0cce2d439c4 -->

<!-- pgdoc-cn_start sig_en=f1b949d2e30a12ca65da8bb1d32ce69f sig_cn_org=None source=14.1 
  <para>
   To create an index with non-default fill factor:
<programlisting>
CREATE UNIQUE INDEX title_idx ON films (title) WITH (fillfactor = 70);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   创建一个具有非默认填充因子的索引：
<programlisting>
CREATE UNIQUE INDEX title_idx ON films (title) WITH (fillfactor = 70);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=f1b949d2e30a12ca65da8bb1d32ce69f -->

<!-- pgdoc-cn_start sig_en=ee9aeded5ebd68ee5b138467d5cbc548 sig_cn_org=None source=14.1 
  <para>
   To create a <acronym>GIN</acronym> index with fast updates disabled:
<programlisting>
CREATE INDEX gin_idx ON documents_table USING GIN (locations) WITH (fastupdate = off);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   创建一个禁用快速更新的<acronym>GIN</acronym>索引：
<programlisting>
CREATE INDEX gin_idx ON documents_table USING GIN (locations) WITH (fastupdate = off);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=ee9aeded5ebd68ee5b138467d5cbc548 -->

<!-- pgdoc-cn_start sig_en=02e8bf2f304a80d33d3f7311a16d9d0e sig_cn_org=None source=14.1 
  <para>
   To create an index on the column <literal>code</literal> in the table
   <literal>films</literal> and have the index reside in the tablespace
   <literal>indexspace</literal>:
<programlisting>
CREATE INDEX code_idx ON films (code) TABLESPACE indexspace;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   在表<literal>films</literal>中的列<literal>code</literal>上创建一个而索引并且
   把索引放在表空间<literal>indexspace</literal>中：
<programlisting>
CREATE INDEX code_idx ON films (code) TABLESPACE indexspace;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=02e8bf2f304a80d33d3f7311a16d9d0e -->

<!-- pgdoc-cn_start sig_en=0045fef0bf19702f42d7ac229ea4323e sig_cn_org=None source=14.1 
  <para>
   To create a GiST index on a point attribute so that we
   can efficiently use box operators on the result of the
   conversion function:
<programlisting>
CREATE INDEX pointloc
    ON points USING gist (box(location,location));
SELECT * FROM points
    WHERE box(location,location) &amp;&amp; '(0,0),(1,1)'::box;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   在一个点属性上创建一个 GiST 索引，这样我们可以在转换函数的结果
   上有效地使用 box 操作符：
<programlisting>
CREATE INDEX pointloc
    ON points USING gist (box(location,location));
SELECT * FROM points
    WHERE box(location,location) &amp;&amp; '(0,0),(1,1)'::box;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=0045fef0bf19702f42d7ac229ea4323e -->

<!-- pgdoc-cn_start sig_en=7841de70d4176d8ec019fbb45f3a35c8 sig_cn_org=None source=14.1 
  <para>
   To create an index without locking out writes to the table:
<programlisting>
CREATE INDEX CONCURRENTLY sales_quantity_index ON sales_table (quantity);
</programlisting></para>
________________________________________________________-->
  <para>
   创建一个表而不排斥对表的写操作：
<programlisting>
CREATE INDEX CONCURRENTLY sales_quantity_index ON sales_table (quantity);
</programlisting></para>
<!-- pgdoc-cn_end sig_en=7841de70d4176d8ec019fbb45f3a35c8 -->

 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
  <title>Compatibility</title>
________________________________________________________-->
  <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=9dc80775307351af33d2cbb6e61d80ad sig_cn_org=None source=14.1 
  <para>
   <command>CREATE INDEX</command> is a
   <productname>PostgreSQL</productname> language extension.  There
   are no provisions for indexes in the SQL standard.
  </para>
________________________________________________________-->
  <para>
   <command>CREATE INDEX</command>是一种
   <productname>PostgreSQL</productname>的语言扩展。在 SQL 标准中
   没有对于索引的规定。
  </para>
<!-- pgdoc-cn_end sig_en=9dc80775307351af33d2cbb6e61d80ad -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=8b7cc214676b443e6527e3d6bf054420 sig_cn_org=None source=14.1 
  <title>See Also</title>
________________________________________________________-->
  <title>另见</title>
<!-- pgdoc-cn_end sig_en=8b7cc214676b443e6527e3d6bf054420 -->

  <simplelist type="inline">
   <member><xref linkend="sql-alterindex"/></member>
   <member><xref linkend="sql-dropindex"/></member>
   <member><xref linkend="sql-reindex"/></member>
   <member><xref linkend="create-index-progress-reporting"/></member>
  </simplelist>
 </refsect1>
</refentry>
