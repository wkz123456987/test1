<!--
doc/src/sgml/ref/insert.sgml
PostgreSQL documentation
-->

<refentry id="sql-insert">
<!-- pgdoc-cn_start sig_en=8a0f32732d2d6c85e0910146e9051641 sig_cn_org=None source=14.1 
 <indexterm zone="sql-insert">
  <primary>INSERT</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="sql-insert">
  <primary>INSERT</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=8a0f32732d2d6c85e0910146e9051641 -->

 <refmeta>
  <refentrytitle>INSERT</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

<!-- pgdoc-cn_start sig_en=4562342d445659dc28993312dcce30a1 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>INSERT</refname>
  <refpurpose>create new rows in a table</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>INSERT</refname>
  <refpurpose>在一个表中创建新行</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=4562342d445659dc28993312dcce30a1 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=5e0bcfe3997521bb4bedd3281ebe8467 sig_cn_org=None source=14.1 
<synopsis>
[ WITH [ RECURSIVE ] <replaceable class="parameter">with_query</replaceable> [, ...] ]
INSERT INTO <replaceable class="parameter">table_name</replaceable> [ AS <replaceable class="parameter">alias</replaceable> ] [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    [ OVERRIDING { SYSTEM | USER } VALUE ]
    { DEFAULT VALUES | VALUES ( { <replaceable class="parameter">expression</replaceable> | DEFAULT } [, ...] ) [, ...] | <replaceable class="parameter">query</replaceable> }
    [ ON CONFLICT [ <replaceable class="parameter">conflict_target</replaceable> ] <replaceable class="parameter">conflict_action</replaceable> ]
    [ RETURNING * | <replaceable class="parameter">output_expression</replaceable> [ [ AS ] <replaceable class="parameter">output_name</replaceable> ] [, ...] ]

<phrase>where <replaceable class="parameter">conflict_target</replaceable> can be one of:</phrase>

    ( { <replaceable class="parameter">index_column_name</replaceable> | ( <replaceable class="parameter">index_expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [, ...] ) [ WHERE <replaceable class="parameter">index_predicate</replaceable> ]
    ON CONSTRAINT <replaceable class="parameter">constraint_name</replaceable>

<phrase>and <replaceable class="parameter">conflict_action</replaceable> is one of:</phrase>

    DO NOTHING
    DO UPDATE SET { <replaceable class="parameter">column_name</replaceable> = { <replaceable class="parameter">expression</replaceable> | DEFAULT } |
                    ( <replaceable class="parameter">column_name</replaceable> [, ...] ) = [ ROW ] ( { <replaceable class="parameter">expression</replaceable> | DEFAULT } [, ...] ) |
                    ( <replaceable class="parameter">column_name</replaceable> [, ...] ) = ( <replaceable class="parameter">sub-SELECT</replaceable> )
                  } [, ...]
              [ WHERE <replaceable class="parameter">condition</replaceable> ]
</synopsis>
________________________________________________________-->
<synopsis>
[ WITH [ RECURSIVE ] <replaceable class="parameter">with_query</replaceable> [, ...] ]
INSERT INTO <replaceable class="parameter">table_name</replaceable> [ AS <replaceable class="parameter">alias</replaceable> ] [ ( <replaceable class="parameter">column_name</replaceable> [, ...] ) ]
    [ OVERRIDING { SYSTEM | USER } VALUE ]
    { DEFAULT VALUES | VALUES ( { <replaceable class="parameter">expression</replaceable> | DEFAULT } [, ...] ) [, ...] | <replaceable class="parameter">query</replaceable> }
    [ ON CONFLICT [ <replaceable class="parameter">conflict_target</replaceable> ] <replaceable class="parameter">conflict_action</replaceable> ]
    [ RETURNING * | <replaceable class="parameter">output_expression</replaceable> [ [ AS ] <replaceable class="parameter">output_name</replaceable> ] [, ...] ]

<phrase>其中 <replaceable class="parameter">conflict_target</replaceable> 可以是以下之一：</phrase>

    ( { <replaceable class="parameter">index_column_name</replaceable> | ( <replaceable class="parameter">index_expression</replaceable> ) } [ COLLATE <replaceable class="parameter">collation</replaceable> ] [ <replaceable class="parameter">opclass</replaceable> ] [, ...] ) [ WHERE <replaceable class="parameter">index_predicate</replaceable> ]
    ON CONSTRAINT <replaceable class="parameter">constraint_name</replaceable>

<phrase>并且 <replaceable class="parameter">conflict_action</replaceable> 是以下之一：</phrase>

    DO NOTHING
    DO UPDATE SET { <replaceable class="parameter">column_name</replaceable> = { <replaceable class="parameter">expression</replaceable> | DEFAULT } |
                    ( <replaceable class="parameter">column_name</replaceable> [, ...] ) = [ ROW ] ( { <replaceable class="parameter">expression</replaceable> | DEFAULT } [, ...] ) |
                    ( <replaceable class="parameter">column_name</replaceable> [, ...] ) = ( <replaceable class="parameter">sub-SELECT</replaceable> )
                  } [, ...]
              [ WHERE <replaceable class="parameter">condition</replaceable> ]
</synopsis>
<!-- pgdoc-cn_end sig_en=5e0bcfe3997521bb4bedd3281ebe8467 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=0cc9f3a40a63a2518d89741818d7d6bb sig_cn_org=None source=14.1 
  <para>
   <command>INSERT</command> inserts new rows into a table.
   One can insert one or more rows specified by value expressions,
   or zero or more rows resulting from a query.
  </para>
________________________________________________________-->
  <para>
   <command>INSERT</command>将新行插入到一个表中。我们可以
   插入一个或者更多由值表达式指定的行，或者插入来自一个查询的零行
   或者更多行。
  </para>
<!-- pgdoc-cn_end sig_en=0cc9f3a40a63a2518d89741818d7d6bb -->

<!-- pgdoc-cn_start sig_en=0cec17912a309d2b4b89fc4886852519 sig_cn_org=None source=14.1 
  <para>
   The target column names can be listed in any order.  If no list of
   column names is given at all, the default is all the columns of the
   table in their declared order; or the first <replaceable>N</replaceable> column
   names, if there are only <replaceable>N</replaceable> columns supplied by the
   <literal>VALUES</literal> clause or <replaceable>query</replaceable>.  The values
   supplied by the <literal>VALUES</literal> clause or <replaceable>query</replaceable> are
   associated with the explicit or implicit column list left-to-right.
  </para>
________________________________________________________-->
  <para>
   目标列的名称可以以任意顺序列出。如果没有给出列名列表，则有两种确定
   目标列的可能性。第一种是以被声明的顺序列出该表的所有列。另一种可能
   性是，如果<literal>VALUES</literal> 子句或者<replaceable>query</replaceable>只提
   供<replaceable>N</replaceable>个列，则以被声明的顺序列出该表的前
   <replaceable>N</replaceable>列。<literal>VALUES</literal> 子句或者
   <replaceable>query</replaceable>提供的值会被从左至右关联到这些显式或者隐式
   给出的目标列。
  </para>
<!-- pgdoc-cn_end sig_en=0cec17912a309d2b4b89fc4886852519 -->

<!-- pgdoc-cn_start sig_en=312f65932be6fe37b73da35fe7b4b512 sig_cn_org=None source=14.1 
  <para>
   Each column not present in the explicit or implicit column list will be
   filled with a default value, either its declared default value
   or null if there is none.
  </para>
________________________________________________________-->
  <para>
   每一个没有出现在显式或者隐式列列表中的列都将被默认填充，如果为该列
   声明过默认值则用默认值填充，否则用空值填充。
  </para>
<!-- pgdoc-cn_end sig_en=312f65932be6fe37b73da35fe7b4b512 -->

<!-- pgdoc-cn_start sig_en=db42a18a9446253b3381a046873150f4 sig_cn_org=None source=14.1 
  <para>
   If the expression for any column is not of the correct data type,
   automatic type conversion will be attempted.
  </para>
________________________________________________________-->
  <para>
   如果任意列的表达式不是正确的数据类型，将会尝试自动类型转换。
  </para>
<!-- pgdoc-cn_end sig_en=db42a18a9446253b3381a046873150f4 -->

<!-- pgdoc-cn_start sig_en=49b7ce23722fefbd0c646821fb2a3bf7 sig_cn_org=f38f9257496c7b756f59daaa41ec612d source=15.7 
  <para>
   <command>INSERT</command> into tables that lack unique indexes will
   not be blocked by concurrent activity.  Tables with unique indexes
   might block if concurrent sessions perform actions that lock or modify
   rows matching the unique index values being inserted;  the details
   are covered in <xref linkend="index-unique-checks"/>.
   <literal>ON CONFLICT</literal> can be used to specify an alternative
   action to raising a unique constraint or exclusion constraint
   violation error. (See <xref linkend="sql-on-conflict"/> below.)
  </para>
________________________________________________________-->
  <para>
   <command>INSERT</command>缺少唯一索引的表不会被并发活动阻塞。
   如果并发会话执行锁定或修改与要插入的唯一索引值匹配的行的操作，则具有唯一索引的表可能会阻塞；
   详细信息在<xref linkend="index-unique-checks"/>中介绍。
   <literal>ON CONFLICT</literal>可以用来指定替代操作，以避免引发唯一约束或排他约束违反错误。
   (参见下面的<xref linkend="sql-on-conflict"/>。)
</para>
<!-- pgdoc-cn_end sig_en=49b7ce23722fefbd0c646821fb2a3bf7 -->

<!-- pgdoc-cn_start sig_en=4fc7df78f19b60154e095b4e3f0fb22e sig_cn_org=None source=14.1 
  <para>
   The optional <literal>RETURNING</literal> clause causes <command>INSERT</command>
   to compute and return value(s) based on each row actually inserted
   (or updated, if an <literal>ON CONFLICT DO UPDATE</literal> clause was
   used).  This is primarily useful for obtaining values that were
   supplied by defaults, such as a serial sequence number.  However,
   any expression using the table's columns is allowed.  The syntax of
   the <literal>RETURNING</literal> list is identical to that of the output
   list of <command>SELECT</command>.  Only rows that were successfully
   inserted or updated will be returned.  For example, if a row was
   locked but not updated because an <literal>ON CONFLICT DO UPDATE
   ... WHERE</literal> clause <replaceable
   class="parameter">condition</replaceable> was not satisfied, the
   row will not be returned.
  </para>
________________________________________________________-->
  <para>
   可选的<literal>RETURNING</literal>子句让<command>INSERT</command>根据
   实际被插入（如果使用了<literal>ON CONFLICT DO UPDATE</literal>子句，
   可能是被更新）的每一行来计算和返回值。这主要用来获取由默认值提供
   的值，例如一个序列号。不过，允许在其中包括使用该表列的任何表达式。
   <literal>RETURNING</literal>列表的语法与<command>SELECT</command>的输出
   列表的相同。只有被成功地插入或者更新的行才将被返回。例如，如果一
   行被锁定但由于不满足<literal>ON CONFLICT DO UPDATE
   ... WHERE</literal> clause <replaceable
   class="parameter">condition</replaceable>没有被更新，该行将
   不被返回。
  </para>
<!-- pgdoc-cn_end sig_en=4fc7df78f19b60154e095b4e3f0fb22e -->

<!-- pgdoc-cn_start sig_en=d856a14e06a76ce4e74342d7aad2f9f8 sig_cn_org=None source=14.1 
  <para>
   You must have <literal>INSERT</literal> privilege on a table in
   order to insert into it.  If <literal>ON CONFLICT DO UPDATE</literal> is
   present, <literal>UPDATE</literal> privilege on the table is also
   required.
  </para>
________________________________________________________-->
  <para>
   为了向表中插入，你必须具有其上的<literal>INSERT</literal>特权。
   如果存在<literal>ON CONFLICT DO UPDATE</literal>子句，还要求该表上
   的<literal>UPDATE</literal>特权。
  </para>
<!-- pgdoc-cn_end sig_en=d856a14e06a76ce4e74342d7aad2f9f8 -->

<!-- pgdoc-cn_start sig_en=488fc0c3d2b71fabc041463dacc6f1af sig_cn_org=None source=14.1 
  <para>
   If a column list is specified, you only need
   <literal>INSERT</literal> privilege on the listed columns.
   Similarly, when <literal>ON CONFLICT DO UPDATE</literal> is specified, you
   only need <literal>UPDATE</literal> privilege on the column(s) that are
   listed to be updated.  However, <literal>ON CONFLICT DO UPDATE</literal>
   also requires <literal>SELECT</literal> privilege on any column whose
   values are read in the <literal>ON CONFLICT DO UPDATE</literal>
   expressions or <replaceable>condition</replaceable>.
  </para>
________________________________________________________-->
  <para>
   如果一个列列表被指定，你只需要其中的列上的<literal>INSERT</literal>
   特权。类似地，在指定了<literal>ON CONFLICT DO UPDATE</literal>时，你只
   需要被列出要更新的列上的<literal>UPDATE</literal>特权。不过，
   <literal>ON CONFLICT DO UPDATE</literal>还要求其值被
   <literal>ON CONFLICT DO UPDATE</literal>表达式或者
   <replaceable>condition</replaceable>使用的列上的<literal>SELECT</literal>特权。
  </para>
<!-- pgdoc-cn_end sig_en=488fc0c3d2b71fabc041463dacc6f1af -->

<!-- pgdoc-cn_start sig_en=72f4c92c9b1fa6de61dfb1317b6ca4d7 sig_cn_org=None source=14.1 
  <para>
   Use of the <literal>RETURNING</literal> clause requires <literal>SELECT</literal>
   privilege on all columns mentioned in <literal>RETURNING</literal>.
   If you use the <replaceable
   class="parameter">query</replaceable> clause to insert rows from a
   query, you of course need to have <literal>SELECT</literal> privilege on
   any table or column used in the query.
  </para>
________________________________________________________-->
  <para>
    使用<literal>RETURNING</literal>子句需要<literal>RETURNING</literal>中提到的所有列的
    <literal>SELECT</literal>权限。
    如果使用<replaceable class="parameter">query</replaceable>子句从查询中插入行，
    则当然需要对查询中使用的任何表或列具有<literal>SELECT</literal>权限。
  </para>
<!-- pgdoc-cn_end sig_en=72f4c92c9b1fa6de61dfb1317b6ca4d7 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
  <title>Parameters</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

  <refsect2>
<!-- pgdoc-cn_start sig_en=95533ab32e2e44d84b1d5822db820ea4 sig_cn_org=None source=14.1 
   <title>Inserting</title>
________________________________________________________-->
   <title>插入</title>
<!-- pgdoc-cn_end sig_en=95533ab32e2e44d84b1d5822db820ea4 -->

<!-- pgdoc-cn_start sig_en=0673ee67027ee473c4549df631cf5657 sig_cn_org=None source=14.1 
   <para>
    This section covers parameters that may be used when only
    inserting new rows.  Parameters <emphasis>exclusively</emphasis>
    used with the <literal>ON CONFLICT</literal> clause are described
    separately.
   </para>
________________________________________________________-->
   <para>
    这个小节介绍了在只插入新行时可以使用的参数。
    <emphasis>专门用于</emphasis><literal>ON CONFLICT</literal>子句的
    参数会单独介绍。
   </para>
<!-- pgdoc-cn_end sig_en=0673ee67027ee473c4549df631cf5657 -->

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">with_query</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=11045435f4149f709a501516b1e29726 sig_cn_org=None source=14.1 
       <para>
        The <literal>WITH</literal> clause allows you to specify one or more
        subqueries that can be referenced by name in the <command>INSERT</command>
        query. See <xref linkend="queries-with"/> and <xref linkend="sql-select"/>
        for details.
       </para>
________________________________________________________-->
       <para>
       <literal>WITH</literal>子句允许指定一个或者更多子查询，在
       <command>INSERT</command>查询中可以用名称引用这些子查询。详见
       <xref linkend="queries-with"/>以及<xref linkend="sql-select"/>。
      </para>
<!-- pgdoc-cn_end sig_en=11045435f4149f709a501516b1e29726 -->
<!-- pgdoc-cn_start sig_en=9303f279f59164bc3151aa223b418ba4 sig_cn_org=None source=14.1 
       <para>
        It is possible for the <replaceable class="parameter">query</replaceable>
        (<command>SELECT</command> statement)
        to also contain a <literal>WITH</literal> clause.  In such a case both
        sets of <replaceable>with_query</replaceable> can be referenced within
        the <replaceable class="parameter">query</replaceable>, but the
        second one takes precedence since it is more closely nested.
       </para>
________________________________________________________-->
       <para>
       <replaceable class="parameter">query</replaceable>
       （<command>SELECT</command>语句）也可以包含一个
       <literal>WITH</literal>子句。在这种情况下
       <replaceable class="parameter">query</replaceable>中可以引用
       两组<replaceable>with_query</replaceable>，但是第二个优先级更
       高（因为它被嵌套更近）。
      </para>
<!-- pgdoc-cn_end sig_en=9303f279f59164bc3151aa223b418ba4 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">table_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=66970abfa75445e6347b7211402f4442 sig_cn_org=None source=14.1 
       <para>
        The name (optionally schema-qualified) of an existing table.
       </para>
________________________________________________________-->
       <para>
       一个已有表的名称（可以被模式限定）。
      </para>
<!-- pgdoc-cn_end sig_en=66970abfa75445e6347b7211402f4442 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">alias</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=78bf24e7647a553deb7c32a8188cee36 sig_cn_org=11c33829cba0ec3cac3d70406d9daa1d source=15.7 
       <para>
        A substitute name for <replaceable
        class="parameter">table_name</replaceable>.  When an alias is
        provided, it completely hides the actual name of the table.
        This is particularly useful when <literal>ON CONFLICT DO UPDATE</literal>
        targets a table named <varname>excluded</varname>, since that will otherwise
        be taken as the name of the special table representing the row proposed
        for insertion.
       </para>
________________________________________________________-->
       <para>
        一个<replaceable class="parameter">table_name</replaceable>的替代名称。当提供了别名时，
        它完全隐藏了表的实际名称。当<literal>ON CONFLICT DO UPDATE</literal>指向一个名为
        <varname>excluded</varname>的表时，这特别有用，因为否则将被视为代表拟议插入行的特殊表的名称。
</para>
<!-- pgdoc-cn_end sig_en=78bf24e7647a553deb7c32a8188cee36 -->
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><replaceable class="parameter">column_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=e0eb0c357244732d07b7834991f65027 sig_cn_org=None source=14.1 
       <para>
        The name of a column in the table named by <replaceable
        class="parameter">table_name</replaceable>.  The column name
        can be qualified with a subfield name or array subscript, if
        needed.  (Inserting into only some fields of a composite
        column leaves the other fields null.)  When referencing a
        column with <literal>ON CONFLICT DO UPDATE</literal>, do not include
        the table's name in the specification of a target column.  For
        example, <literal>INSERT INTO table_name ... ON CONFLICT DO UPDATE
        SET table_name.col = 1</literal> is invalid (this follows the general
        behavior for <command>UPDATE</command>).
       </para>
________________________________________________________-->
       <para>
        名为<replaceable
        class="parameter">table_name</replaceable>的表中的一个列
        的名称。如有必要，列名可以用一个子域名或者数组下标限定（指向
        一个组合列的某些列中插入会让其他域为空）。当用
        <literal>ON CONFLICT DO UPDATE</literal>引用一列时，不要在一个
        目标列的说明中国包括表名。例如，
        <literal>INSERT INTO table_name ... ON CONFLICT DO UPDATE
        SET table_name.col = 1</literal>是非法的（这遵循<command>UPDATE</command>
        的一般行为）。
       </para>
<!-- pgdoc-cn_end sig_en=e0eb0c357244732d07b7834991f65027 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>OVERRIDING SYSTEM VALUE</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=ed3f36531238dc3273f00efbe2a7fd64 sig_cn_org=None source=14.1 
       <para>
        If this clause is specified, then any values supplied for identity
        columns will override the default sequence-generated values.
       </para>
________________________________________________________-->
       <para>
        如果指定了此子句，那么为标识列提供的任何值都将覆盖默认的序列生成的值。
       </para>
<!-- pgdoc-cn_end sig_en=ed3f36531238dc3273f00efbe2a7fd64 -->

<!-- pgdoc-cn_start sig_en=064dbbde31a7e74ba0c2e3c0c2169e5e sig_cn_org=None source=14.1 
       <para>
        For an identity column defined as <literal>GENERATED ALWAYS</literal>,
        it is an error to insert an explicit value (other than
        <literal>DEFAULT</literal>) without specifying either
        <literal>OVERRIDING SYSTEM VALUE</literal> or <literal>OVERRIDING USER
        VALUE</literal>.  (For an identity column defined as
        <literal>GENERATED BY DEFAULT</literal>, <literal>OVERRIDING SYSTEM
        VALUE</literal> is the normal behavior and specifying it does nothing,
        but <productname>PostgreSQL</productname> allows it as an extension.)
       </para>
________________________________________________________-->
       <para>
        对于定义为<literal>GENERATED ALWAYS</literal>的标识列，插入显式值（<literal>DEFAULT</literal>除外）而不指定
        <literal>OVERRIDING SYSTEM VALUE</literal>或<literal>OVERRIDING USER VALUE</literal>是错误的。（对于定义
        为<literal>GENERATED BY DEFAULT</literal>的标识列，<literal>OVERRIDING SYSTEM VALUE</literal>是正常行为，
        并指定其不执行任何操作，但是<productname>PostgreSQL</productname>允许它作为扩展名。）
       </para>
<!-- pgdoc-cn_end sig_en=064dbbde31a7e74ba0c2e3c0c2169e5e -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>OVERRIDING USER VALUE</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=22fd6af76bdaff2c2922380493409a4c sig_cn_org=None source=14.1 
       <para>
        If this clause is specified, then any values supplied for identity
        columns are ignored and the default sequence-generated values are
        applied.
       </para>
________________________________________________________-->
       <para>
        如果指定了此子句，则将忽略为标识列提供的任何值，并应用默认的序列生成的值。
       </para>
<!-- pgdoc-cn_end sig_en=22fd6af76bdaff2c2922380493409a4c -->

<!-- pgdoc-cn_start sig_en=47eba0fccfe47f06eb4f7ecf66f80443 sig_cn_org=None source=14.1 
       <para>
        This clause is useful for example when copying values between tables.
        Writing <literal>INSERT INTO tbl2 OVERRIDING USER VALUE SELECT * FROM
        tbl1</literal> will copy from <literal>tbl1</literal> all columns that
        are not identity columns in <literal>tbl2</literal> while values for
        the identity columns in <literal>tbl2</literal> will be generated by
        the sequences associated with <literal>tbl2</literal>.
       </para>
________________________________________________________-->
       <para>
        例如，当在表之间拷贝值时，这个子句有能派上用场。<literal>INSERT INTO tbl2 OVERRIDING USER VALUE SELECT * FROM tbl1</literal>将从<literal>tbl1</literal>中拷贝所有在<literal>tbl2</literal>中不是标识列的列，而<literal>tbl2</literal>中标识列的值将由与<literal>tbl2</literal>关联的序列产生。
       </para>
<!-- pgdoc-cn_end sig_en=47eba0fccfe47f06eb4f7ecf66f80443 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DEFAULT VALUES</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=01ebaf0338a91dbe3db6de44768a5e94 sig_cn_org=None source=14.1 
       <para>
        All columns will be filled with their default values, as if
        <literal>DEFAULT</literal> were explicitly specified for each column.
        (An <literal>OVERRIDING</literal> clause is not permitted in this
        form.)
       </para>
________________________________________________________-->
       <para>
        所有列都将被其默认值填充，就像为每个列显式指定了<literal>DEFAULT</literal>。
        （例如这种形式下不允许<literal>OVERRIDING</literal>子句）。
       </para>
<!-- pgdoc-cn_end sig_en=01ebaf0338a91dbe3db6de44768a5e94 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">expression</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=d625289f3f106e41b358d59a75feac55 sig_cn_org=None source=14.1 
       <para>
        An expression or value to assign to the corresponding column.
       </para>
________________________________________________________-->
       <para>
        要赋予给相应列的表达式或者值。
       </para>
<!-- pgdoc-cn_end sig_en=d625289f3f106e41b358d59a75feac55 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DEFAULT</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=b24a0a62e94e38a5bfcf8f0ca0ed158d sig_cn_org=None source=14.1 
       <para>
        The corresponding column will be filled with its default value.  An
        identity column will be filled with a new value generated by the
        associated sequence.  For a generated column, specifying this is
        permitted but merely specifies the normal behavior of computing the
        column from its generation expression.
       </para>
________________________________________________________-->
       <para>
        相应的列将填充其默认值。标识列将由关联序列生成的新值填充。对于生成的列，允许指定该值，但仅指定根据其生成表达式计算该列的正常行为。
       </para>
<!-- pgdoc-cn_end sig_en=b24a0a62e94e38a5bfcf8f0ca0ed158d -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">query</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=3fe806a902e8544109bfeba4b5a21371 sig_cn_org=None source=14.1 
       <para>
        A query (<command>SELECT</command> statement) that supplies the
        rows to be inserted.  Refer to the
        <xref linkend="sql-select"/>
        statement for a description of the syntax.
       </para>
________________________________________________________-->
       <para>
        提供要被插入行的查询（<command>SELECT</command>语句）。
        其语法描述请参考<xref linkend="sql-select"/>语句。
       </para>
<!-- pgdoc-cn_end sig_en=3fe806a902e8544109bfeba4b5a21371 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">output_expression</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=8f3b36c992a87e261ebc771db9e5c6b7 sig_cn_org=None source=14.1 
       <para>
        An expression to be computed and returned by the
        <command>INSERT</command> command after each row is inserted or
        updated. The expression can use any column names of the table
        named by <replaceable
        class="parameter">table_name</replaceable>.  Write
        <literal>*</literal> to return all columns of the inserted or updated
        row(s).
       </para>
________________________________________________________-->
       <para>
        在每一行被插入或更新后由<command>INSERT</command>命令计算并且返回的
        表达式。该表达式可以使用<replaceable class="parameter">table_name</replaceable>
        指定的表中的任何列。写成<literal>*</literal>可返回被插入或更新行的所有列。
       </para>
<!-- pgdoc-cn_end sig_en=8f3b36c992a87e261ebc771db9e5c6b7 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">output_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=b3fc72000b5ed039331822e47eda5b33 sig_cn_org=None source=14.1 
       <para>
        A name to use for a returned column.
       </para>
________________________________________________________-->
       <para>
        要用于被返回列的名称。
       </para>
<!-- pgdoc-cn_end sig_en=b3fc72000b5ed039331822e47eda5b33 -->
      </listitem>
     </varlistentry>
    </variablelist>
  </refsect2>

  <refsect2 id="sql-on-conflict" xreflabel="ON CONFLICT Clause">
<!-- pgdoc-cn_start sig_en=60c6136f3499ba929813946fd182960e sig_cn_org=None source=14.1 
   <title><literal>ON CONFLICT</literal> Clause</title>
________________________________________________________-->
   <title><literal>ON CONFLICT</literal> 子句</title>
<!-- pgdoc-cn_end sig_en=60c6136f3499ba929813946fd182960e -->
<!-- pgdoc-cn_start sig_en=f99981ebc48d9be5060e1723c0ea3ff1 sig_cn_org=None source=14.1 
   <indexterm zone="sql-insert">
    <primary>UPSERT</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="sql-insert">
    <primary>UPSERT</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=f99981ebc48d9be5060e1723c0ea3ff1 -->
<!-- pgdoc-cn_start sig_en=77c8cfa416f7ce987661ce86f2dceb41 sig_cn_org=None source=14.1 
   <indexterm zone="sql-insert">
    <primary>ON CONFLICT</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="sql-insert">
    <primary>ON CONFLICT</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=77c8cfa416f7ce987661ce86f2dceb41 -->
<!-- pgdoc-cn_start sig_en=b20689abd424aea56e5296056ffd7035 sig_cn_org=None source=14.1 
   <para>
    The optional <literal>ON CONFLICT</literal> clause specifies an
    alternative action to raising a unique violation or exclusion
    constraint violation error.  For each individual row proposed for
    insertion, either the insertion proceeds, or, if an
    <emphasis>arbiter</emphasis> constraint or index specified by
    <parameter>conflict_target</parameter> is violated, the
    alternative <parameter>conflict_action</parameter> is taken.
    <literal>ON CONFLICT DO NOTHING</literal> simply avoids inserting
    a row as its alternative action.  <literal>ON CONFLICT DO
    UPDATE</literal> updates the existing row that conflicts with the
    row proposed for insertion as its alternative action.
   </para>
________________________________________________________-->
   <para>
    可选的<literal>ON CONFLICT</literal>子句为出现唯一性违背或排除
    约束违背错误时提供另一种可供选择的动作。对于每一个要插入的行，
    不管是插入进行下去还是由<parameter>conflict_target</parameter>
    指定的一个<emphasis>仲裁者</emphasis>约束或者索引被违背，都会
    采取可供选择的<parameter>conflict_action</parameter>。
    <literal>ON CONFLICT DO NOTHING</literal>简单地把避免插入行。
    <literal>ON CONFLICT DO UPDATE</literal>则会
    更新与要插入的行冲突的已有行。
   </para>
<!-- pgdoc-cn_end sig_en=b20689abd424aea56e5296056ffd7035 -->

<!-- pgdoc-cn_start sig_en=3d8f7dbbc9517b59eae457e3a8378039 sig_cn_org=None source=14.1 
   <para>
    <parameter>conflict_target</parameter> can perform
    <emphasis>unique index inference</emphasis>.  When performing
    inference, it consists of one or more <replaceable
    class="parameter">index_column_name</replaceable> columns and/or
    <replaceable class="parameter">index_expression</replaceable>
    expressions, and an optional <replaceable class="parameter">index_predicate</replaceable>.  All <replaceable
    class="parameter">table_name</replaceable> unique indexes that,
    without regard to order, contain exactly the
    <parameter>conflict_target</parameter>-specified
    columns/expressions are inferred (chosen) as arbiter indexes.  If
    an <replaceable class="parameter">index_predicate</replaceable> is
    specified, it must, as a further requirement for inference,
    satisfy arbiter indexes.  Note that this means a non-partial
    unique index (a unique index without a predicate) will be inferred
    (and thus used by <literal>ON CONFLICT</literal>) if such an index
    satisfying every other criteria is available.  If an attempt at
    inference is unsuccessful, an error is raised.
   </para>
________________________________________________________-->
   <para>
    <parameter>conflict_target</parameter>可以执行
    <emphasis>唯一索引推断</emphasis>。在执行推断时，它由一个或者多个
    <replaceable class="parameter">index_column_name</replaceable>
    列或者
    <replaceable class="parameter">index_expression</replaceable>
    表达式以及一个可选的<replaceable class="parameter">
    index_predicate</replaceable>构成。所有刚好包含
    <parameter>conflict_target</parameter>指定的列/表达式的<replaceable
    class="parameter">table_name</replaceable>唯一索引（不管顺序）都
    会被推断为（选择为）仲裁者索引。如果指定了
    <replaceable class="parameter">index_predicate</replaceable>，它
    必须满足仲裁者索引（也是推断过程的一个进一步的要求）。注意这意味着如果
    有一个满足其他条件的非部分唯一索引（没有谓词的唯一索引）可用，它将被
    推断为仲裁者（并且会被<literal>ON CONFLICT</literal>使用）。如果推断
    尝试不成功，则会发生一个错误。
   </para>
<!-- pgdoc-cn_end sig_en=3d8f7dbbc9517b59eae457e3a8378039 -->

<!-- pgdoc-cn_start sig_en=ee638eaee67b2e3f92f9e0476366d663 sig_cn_org=None source=14.1 
   <para>
    <literal>ON CONFLICT DO UPDATE</literal> guarantees an atomic
    <command>INSERT</command> or <command>UPDATE</command> outcome;
    provided there is no independent error, one of those two outcomes
    is guaranteed, even under high concurrency.  This is also known as
    <firstterm>UPSERT</firstterm> &mdash; <quote>UPDATE or
    INSERT</quote>.
   </para>
________________________________________________________-->
   <para>
    <literal>ON CONFLICT DO UPDATE</literal>保证一个原子的
    <command>INSERT</command>或者
    <command>UPDATE</command>结果。在没有无关错误的前提下，这两种
    结果之一可以得到保证，即使在很高的并发度也能保证。这也可以被称作
    <firstterm>UPSERT</firstterm> &mdash; <quote>UPDATE 或
    INSERT</quote>。
   </para>
<!-- pgdoc-cn_end sig_en=ee638eaee67b2e3f92f9e0476366d663 -->

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">conflict_target</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=d18ff0e03401bdfb8ac2c490d8b87b1a sig_cn_org=None source=14.1 
       <para>
        Specifies which conflicts <literal>ON CONFLICT</literal> takes
        the alternative action on by choosing <firstterm>arbiter
        indexes</firstterm>.  Either performs <emphasis>unique index
        inference</emphasis>, or names a constraint explicitly.  For
        <literal>ON CONFLICT DO NOTHING</literal>, it is optional to
        specify a <parameter>conflict_target</parameter>; when
        omitted, conflicts with all usable constraints (and unique
        indexes) are handled.  For <literal>ON CONFLICT DO
        UPDATE</literal>, a <parameter>conflict_target</parameter>
        <emphasis>must</emphasis> be provided.
       </para>
________________________________________________________-->
       <para>
        通过选择<firstterm>仲裁者索引</firstterm>来指定哪些行与
        <literal>ON CONFLICT</literal>在其上采取可替代动作的行相冲突。
        要么执行<emphasis>唯一索引推断</emphasis>，要么显式命名一个
        约束。对于<literal>ON CONFLICT DO NOTHING</literal>来说，
        它对于指定一个<parameter>conflict_target</parameter>是可选的。
        在被省略时，与所有有效约束（以及唯一索引）的冲突都会被处理。对于
        <literal>ON CONFLICT DO UPDATE</literal>，<emphasis>必须</emphasis>
        提供一个<parameter>conflict_target</parameter>。
       </para>
<!-- pgdoc-cn_end sig_en=d18ff0e03401bdfb8ac2c490d8b87b1a -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">conflict_action</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=062b67380358fa940f5d80decd0c240e sig_cn_org=469a2834c348ada421893cf85f98e29b source=15.7 
       <para>
        <parameter>conflict_action</parameter> specifies an
        alternative <literal>ON CONFLICT</literal> action.  It can be
        either <literal>DO NOTHING</literal>, or a <literal>DO
        UPDATE</literal> clause specifying the exact details of the
        <literal>UPDATE</literal> action to be performed in case of a
        conflict.  The <literal>SET</literal> and
        <literal>WHERE</literal> clauses in <literal>ON CONFLICT DO
        UPDATE</literal> have access to the existing row using the
        table's name (or an alias), and to the row proposed for insertion
        using the special <varname>excluded</varname> table.
        <literal>SELECT</literal> privilege is required on any column in the
        target table where corresponding <varname>excluded</varname>
        columns are read.
       </para>
________________________________________________________-->
       <para>
        <parameter>conflict_action</parameter>指定了一个替代的<literal>ON CONFLICT</literal>操作。
        它可以是<literal>DO NOTHING</literal>，或者一个<literal>DO UPDATE</literal>子句，
        指定在冲突发生时执行的<literal>UPDATE</literal>操作的确切细节。
        在<literal>ON CONFLICT DO UPDATE</literal>中，<literal>SET</literal>和
        <literal>WHERE</literal>子句可以访问现有行，使用表的名称（或别名），
        并使用特殊的<varname>excluded</varname>表访问提议插入的行。
        在目标表中任何列上需要<literal>SELECT</literal>权限，对应的<varname>excluded</varname>列被读取。
       </para>
<!-- pgdoc-cn_end sig_en=062b67380358fa940f5d80decd0c240e -->
<!-- pgdoc-cn_start sig_en=919a17abfcd637cf753c9543a5ee0b9d sig_cn_org=None source=14.1 
       <para>
        Note that the effects of all per-row <literal>BEFORE
        INSERT</literal> triggers are reflected in
        <varname>excluded</varname> values, since those effects may
        have contributed to the row being excluded from insertion.
       </para>
________________________________________________________-->
       <para>
        注意所有行级<literal>BEFORE INSERT</literal>触发器的效果都会
        反映在<varname>被排除</varname>值中，因为那些效果可能会
        让该行避免被插入。
       </para>
<!-- pgdoc-cn_end sig_en=919a17abfcd637cf753c9543a5ee0b9d -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">index_column_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=9febe0bb28ec8da0e03eced70cf332e1 sig_cn_org=None source=14.1 
       <para>
        The name of a <replaceable
        class="parameter">table_name</replaceable> column.  Used to
        infer arbiter indexes.  Follows <command>CREATE
        INDEX</command> format.  <literal>SELECT</literal> privilege on
        <replaceable class="parameter">index_column_name</replaceable>
        is required.
       </para>
________________________________________________________-->
       <para>
        一个<replaceable class="parameter">table_name</replaceable>列
        的名称。它被用来推断仲裁者索引。它遵循<command>CREATE
        INDEX</command>格式。这要求
        <replaceable class="parameter">index_column_name</replaceable>
        上的<literal>SELECT</literal>特权。
       </para>
<!-- pgdoc-cn_end sig_en=9febe0bb28ec8da0e03eced70cf332e1 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">index_expression</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=01d0a37dd91ed0f614041698dbbbe807 sig_cn_org=None source=14.1 
       <para>
        Similar to <replaceable
        class="parameter">index_column_name</replaceable>, but used to
        infer expressions on <replaceable
        class="parameter">table_name</replaceable> columns appearing
        within index definitions (not simple columns).  Follows
        <command>CREATE INDEX</command> format.  <literal>SELECT</literal>
        privilege on any column appearing within <replaceable
        class="parameter">index_expression</replaceable> is required.
       </para>
________________________________________________________-->
       <para>
        和<replaceable
        class="parameter">index_column_name</replaceable>类似，但是
        被用来推断出现在索引定义中的<replaceable
        class="parameter">table_name</replaceable>列（非简单列）上的
        表达式。遵循<command>CREATE INDEX</command>格式。这要求
        任何出现在<replaceable
        class="parameter">index_expression</replaceable>中的列上的
        <literal>SELECT</literal>特权。
       </para>
<!-- pgdoc-cn_end sig_en=01d0a37dd91ed0f614041698dbbbe807 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">collation</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=c070e52b331d89a08a28bd2ee94307c3 sig_cn_org=None source=14.1 
       <para>
        When specified, mandates that corresponding <replaceable
        class="parameter">index_column_name</replaceable> or
        <replaceable class="parameter">index_expression</replaceable>
        use a particular collation in order to be matched during
        inference.  Typically this is omitted, as collations usually
        do not affect whether or not a constraint violation occurs.
        Follows <command>CREATE INDEX</command> format.
       </para>
________________________________________________________-->
       <para>
        指定时，强制相应的<replaceable
        class="parameter">index_column_name</replaceable>或
        <replaceable class="parameter">index_expression</replaceable>
        使用一种特定的排序规则以便在推断期间能被匹配上。通常
        会被省略，因为排序规则通常不会影响约束违背的发生。遵循
        <command>CREATE INDEX</command>格式。
       </para>
<!-- pgdoc-cn_end sig_en=c070e52b331d89a08a28bd2ee94307c3 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">opclass</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=1a35f0b3402bad5af9311bb59368ca16 sig_cn_org=None source=14.1 
       <para>
        When specified, mandates that corresponding <replaceable
        class="parameter">index_column_name</replaceable> or
        <replaceable class="parameter">index_expression</replaceable>
        use particular operator class in order to be matched during
        inference.  Typically this is omitted,  as the
        <emphasis>equality</emphasis> semantics are often equivalent
        across a type's operator classes anyway, or because it's
        sufficient to trust that the defined unique indexes have the
        pertinent definition of equality.  Follows <command>CREATE
        INDEX</command> format.
       </para>
________________________________________________________-->
       <para>
        指定时，强制相应的<replaceable
        class="parameter">index_column_name</replaceable>或
        <replaceable class="parameter">index_expression</replaceable>
        使用特定的操作符类以便在推断期间能被匹配上。通常会被省略，
        因为<emphasis>相等</emphasis>语义在一种类型的操作符类
        之间都是等价的，或者因为足以信任已定义的唯一索引具有适当的
        相等定义。遵循<command>CREATE INDEX</command>格式。
       </para>
<!-- pgdoc-cn_end sig_en=1a35f0b3402bad5af9311bb59368ca16 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">index_predicate</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=600c7dca26ce1db4bad8fc6c0f45f65d sig_cn_org=None source=14.1 
       <para>
        Used to allow inference of partial unique indexes.  Any
        indexes that satisfy the predicate (which need not actually be
        partial indexes) can be inferred.  Follows <command>CREATE
        INDEX</command> format.  <literal>SELECT</literal> privilege on any
        column appearing within <replaceable
        class="parameter">index_predicate</replaceable> is required.
       </para>
________________________________________________________-->
       <para>
        用于允许推断部分唯一索引。任何满足该谓词（不一定需要真的是
        部分索引）的索引都能被推断。遵循<command>CREATE
        INDEX</command>格式。这要求任何出现在<replaceable
        class="parameter">index_predicate</replaceable>中的列上
        的<literal>SELECT</literal>特权。
       </para>
<!-- pgdoc-cn_end sig_en=600c7dca26ce1db4bad8fc6c0f45f65d -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">constraint_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=cf6bed8dcee76de2fbc4b59aac771c99 sig_cn_org=None source=14.1 
       <para>
        Explicitly specifies an arbiter
        <emphasis>constraint</emphasis> by name, rather than inferring
        a constraint or index.
       </para>
________________________________________________________-->
       <para>
        用名称显式地指定一个仲裁者<emphasis>约束</emphasis>，
        而不是推断一个约束或者索引。
       </para>
<!-- pgdoc-cn_end sig_en=cf6bed8dcee76de2fbc4b59aac771c99 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">condition</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=2262d62c77d23a0034b6867f6d20ce45 sig_cn_org=None source=14.1 
       <para>
        An expression that returns a value of type
        <type>boolean</type>.  Only rows for which this expression
        returns <literal>true</literal> will be updated, although all
        rows will be locked when the <literal>ON CONFLICT DO UPDATE</literal>
        action is taken.  Note that
        <replaceable>condition</replaceable> is evaluated last, after
        a conflict has been identified as a candidate to update.
       </para>
________________________________________________________-->
       <para>
        一个能返回<type>boolean</type>值的表达式。只有让这个表达式返回
        <literal>true</literal>的行才将被更新，不过在采用
        <literal>ON CONFLICT DO UPDATE</literal>动作时所有的行都会被锁定。
        注意<replaceable>condition</replaceable>会被最后计算，即一个冲突
        被标识为要更新的候选对象之后。
       </para>
<!-- pgdoc-cn_end sig_en=2262d62c77d23a0034b6867f6d20ce45 -->
      </listitem>
     </varlistentry>
    </variablelist>
<!-- pgdoc-cn_start sig_en=5f06f5948d4bf0019ae289dd196ca44e sig_cn_org=None source=14.1 
   <para>
    Note that exclusion constraints are not supported as arbiters with
    <literal>ON CONFLICT DO UPDATE</literal>. In all cases, only
    <literal>NOT DEFERRABLE</literal> constraints and unique indexes
    are supported as arbiters.
   </para>
________________________________________________________-->
   <para>
    注意不支持把排除约束作为<literal>ON CONFLICT DO UPDATE</literal>的
    仲裁者。在所有的情况中，只支持<literal>NOT DEFERRABLE</literal>约束和
    唯一索引作为仲裁者。
   </para>
<!-- pgdoc-cn_end sig_en=5f06f5948d4bf0019ae289dd196ca44e -->

<!-- pgdoc-cn_start sig_en=23f3fed00d1b5a0feb30db92a86302ae sig_cn_org=None source=14.1 
   <para>
    <command>INSERT</command> with an <literal>ON CONFLICT DO UPDATE</literal>
    clause is a <quote>deterministic</quote> statement.  This means
    that the command will not be allowed to affect any single existing
    row more than once; a cardinality violation error will be raised
    when this situation arises.  Rows proposed for insertion should
    not duplicate each other in terms of attributes constrained by an
    arbiter index or constraint.
   </para>
________________________________________________________-->
   <para>
    带有<literal>ON CONFLICT DO UPDATE</literal>子句的
    <command>INSERT</command>是一种<quote>确定性的</quote>
    语句。这表明不允许该命令影响任何单个现有行超过一次，如果发生则会
    发生一个基数违背错误。要插入的行不应该在仲裁者索引或约束所限制的
    属性上相重复。
   </para>
<!-- pgdoc-cn_end sig_en=23f3fed00d1b5a0feb30db92a86302ae -->

<!-- pgdoc-cn_start sig_en=c9fe55708c44c877f9aa0c4b8063b647 sig_cn_org=None source=14.1 
   <para>
    Note that it is currently not supported for the
    <literal>ON CONFLICT DO UPDATE</literal> clause of an
    <command>INSERT</command> applied to a partitioned table to update the
    partition key of a conflicting row such that it requires the row be moved
    to a new partition.
   </para>
________________________________________________________-->
   <para>
    注意，当前不支持用分区表上的<command>INSERT</command>的<literal>ON CONFLICT DO UPDATE</literal>子句更新冲突行的分区键，因为那样会让行移动到新的分区中。
   </para>
<!-- pgdoc-cn_end sig_en=c9fe55708c44c877f9aa0c4b8063b647 -->
   <tip>
<!-- pgdoc-cn_start sig_en=2b7ff8211969ad1135ac94800d38df94 sig_cn_org=None source=14.1 
    <para>
     It is often preferable to use unique index inference rather than
     naming a constraint directly using <literal>ON CONFLICT ON
     CONSTRAINT</literal> <replaceable class="parameter">
     constraint_name</replaceable>.  Inference will continue to work
     correctly when the underlying index is replaced by another more
     or less equivalent index in an overlapping way, for example when
     using <literal>CREATE UNIQUE INDEX ...  CONCURRENTLY</literal>
     before dropping the index being replaced.
    </para>
________________________________________________________-->
    <para>
     使用唯一索引推断通常比使用<literal>ON CONFLICT ON CONSTRAINT</literal> <replaceable class="parameter">constraint_name</replaceable>直接提名一个约束更好。当底层索引被以重叠方式替换成另一个或多或少等效的索引时，推断将能继续正确地工作，例如在删除要被替换的索引之前使用<literal>CREATE UNIQUE INDEX ...  CONCURRENTLY</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=2b7ff8211969ad1135ac94800d38df94 -->
   </tip>

  </refsect2>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=83a929047ae9374bbfd2aa827d90c66a sig_cn_org=None source=14.1 
  <title>Outputs</title>
________________________________________________________-->
  <title>输出</title>
<!-- pgdoc-cn_end sig_en=83a929047ae9374bbfd2aa827d90c66a -->

<!-- pgdoc-cn_start sig_en=b832de7ebe45054c059d569d12c98656 sig_cn_org=None source=14.1 
  <para>
   On successful completion, an <command>INSERT</command> command returns a command
   tag of the form
<screen>
INSERT <replaceable>oid</replaceable> <replaceable class="parameter">count</replaceable>
</screen>
   The <replaceable class="parameter">count</replaceable> is the number of
   rows inserted or updated.  <replaceable>oid</replaceable> is always 0 (it
   used to be the <acronym>OID</acronym> assigned to the inserted row if
   <replaceable>count</replaceable> was exactly one and the target table was
   declared <literal>WITH OIDS</literal> and 0 otherwise, but creating a table
   <literal>WITH OIDS</literal> is not supported anymore).
  </para>
________________________________________________________-->
  <para>
   成功完成时，<command>INSERT</command>命令会返回以下形式的命令标签：
<screen>
INSERT <replaceable>oid</replaceable> <replaceable class="parameter">count</replaceable>
</screen>
   <replaceable class="parameter">count</replaceable>是被插入或更新的行数。
   <replaceable>oid</replaceable>总是0（过去，如果<replaceable>count</replaceable>恰好为1，
   并且目标表被声明为<literal>WITH OIDS</literal>，则它是分配给插入行的<acronym>OID</acronym>，
   否则为0， 但现在已不再支持创建<literal>WITH OIDS</literal>表）。
  </para>
<!-- pgdoc-cn_end sig_en=b832de7ebe45054c059d569d12c98656 -->

<!-- pgdoc-cn_start sig_en=522a6d1ad79ee0bb033b0b343b954a42 sig_cn_org=None source=14.1 
  <para>
   If the <command>INSERT</command> command contains a <literal>RETURNING</literal>
   clause, the result will be similar to that of a <command>SELECT</command>
   statement containing the columns and values defined in the
   <literal>RETURNING</literal> list, computed over the row(s) inserted or
   updated by the command.
  </para>
________________________________________________________-->
  <para>
   如果<command>INSERT</command>命令包含<literal>RETURNING</literal>子句，
   其结果会类似于包含<literal>RETURNING</literal>列表中定义的列和值的
   <command>SELECT</command>语句，这些结果是由该命令在被插入或更新行上
   计算得到。
  </para>
<!-- pgdoc-cn_end sig_en=522a6d1ad79ee0bb033b0b343b954a42 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
  <title>Notes</title>
________________________________________________________-->
  <title>注解</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->

<!-- pgdoc-cn_start sig_en=adeeeae98b29273b2497d6c5766d5a15 sig_cn_org=None source=14.1 
  <para>
   If the specified table is a partitioned table, each row is routed to
   the appropriate partition and inserted into it.  If the specified table
   is a partition, an error will occur if one of the input rows violates
   the partition constraint.
  </para>
________________________________________________________-->
  <para>
   如果指定的表是一个分区表，每一行都会被路由到合适的分区并且插入其中。如果指定的表是一个分区，如果输入行之一违背该分区的约束则将发生错误。
  </para>
<!-- pgdoc-cn_end sig_en=adeeeae98b29273b2497d6c5766d5a15 -->

<!-- pgdoc-cn_start sig_en=6be955de7b8a41ee7f9468055b7ee1fc sig_cn_org=a2b13cbb05cb4ffc0c7b69a00215b96d source=15.7 
  <para>
   You may also wish to consider using <command>MERGE</command>, since that
   allows mixing <command>INSERT</command>, <command>UPDATE</command>, and
   <command>DELETE</command> within a single statement.
   See <xref linkend="sql-merge"/>.
  </para>
________________________________________________________-->
  <para>
   您可能还希望考虑使用<command>MERGE</command>，因为它允许在单个语句中混合<command>INSERT</command>、<command>UPDATE</command>和<command>DELETE</command>。
   请参阅<xref linkend="sql-merge"/>。
</para>
<!-- pgdoc-cn_end sig_en=6be955de7b8a41ee7f9468055b7ee1fc -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
  <title>Examples</title>
________________________________________________________-->
  <title>示例</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=e0133ff1ff3a65da9fbf1d082c70d4c2 sig_cn_org=None source=14.1 
  <para>
   Insert a single row into table <literal>films</literal>:

<programlisting>
INSERT INTO films VALUES
    ('UA502', 'Bananas', 105, '1971-07-13', 'Comedy', '82 minutes');
</programlisting>
  </para>
________________________________________________________-->
  <para>
   向<literal>films</literal>中插入一行：

<programlisting>
INSERT INTO films VALUES
    ('UA502', 'Bananas', 105, '1971-07-13', 'Comedy', '82 minutes');
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=e0133ff1ff3a65da9fbf1d082c70d4c2 -->

<!-- pgdoc-cn_start sig_en=483d403d6b16d01c85fe6d300b82dbf1 sig_cn_org=None source=14.1 
  <para>
   In this example, the <literal>len</literal> column is
   omitted and therefore it will have the default value:

<programlisting>
INSERT INTO films (code, title, did, date_prod, kind)
    VALUES ('T_601', 'Yojimbo', 106, '1961-06-16', 'Drama');
</programlisting>
  </para>
________________________________________________________-->
  <para>
   在这个例子中，<literal>len</literal>列被省略并且因此会具有默认值：

<programlisting>
INSERT INTO films (code, title, did, date_prod, kind)
    VALUES ('T_601', 'Yojimbo', 106, '1961-06-16', 'Drama');
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=483d403d6b16d01c85fe6d300b82dbf1 -->

<!-- pgdoc-cn_start sig_en=58e1109ee6c112278b3f5a6112bf8450 sig_cn_org=None source=14.1 
  <para>
   This example uses the <literal>DEFAULT</literal> clause for
   the date columns rather than specifying a value:

<programlisting>
INSERT INTO films VALUES
    ('UA502', 'Bananas', 105, DEFAULT, 'Comedy', '82 minutes');
INSERT INTO films (code, title, did, date_prod, kind)
    VALUES ('T_601', 'Yojimbo', 106, DEFAULT, 'Drama');
</programlisting>
  </para>
________________________________________________________-->
  <para>
   这个例子为日期列使用<literal>DEFAULT</literal>子句而不是指定一个值：

<programlisting>
INSERT INTO films VALUES
    ('UA502', 'Bananas', 105, DEFAULT, 'Comedy', '82 minutes');
INSERT INTO films (code, title, did, date_prod, kind)
    VALUES ('T_601', 'Yojimbo', 106, DEFAULT, 'Drama');
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=58e1109ee6c112278b3f5a6112bf8450 -->

<!-- pgdoc-cn_start sig_en=cdcdd3b18d8e82aa344e3db6907dc539 sig_cn_org=None source=14.1 
  <para>
   To insert a row consisting entirely of default values:

<programlisting>
INSERT INTO films DEFAULT VALUES;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   插入一个完全由默认值构成的行：

<programlisting>
INSERT INTO films DEFAULT VALUES;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=cdcdd3b18d8e82aa344e3db6907dc539 -->

<!-- pgdoc-cn_start sig_en=f69a0f638f3e519a2a7e9935cc9827f4 sig_cn_org=None source=14.1 
  <para>
   To insert multiple rows using the multirow <command>VALUES</command> syntax:

<programlisting>
INSERT INTO films (code, title, did, date_prod, kind) VALUES
    ('B6717', 'Tampopo', 110, '1985-02-10', 'Comedy'),
    ('HG120', 'The Dinner Game', 140, DEFAULT, 'Comedy');
</programlisting>
  </para>
________________________________________________________-->
  <para>
   用多行<command>VALUES</command>语法插入多个行：

<programlisting>
INSERT INTO films (code, title, did, date_prod, kind) VALUES
    ('B6717', 'Tampopo', 110, '1985-02-10', 'Comedy'),
    ('HG120', 'The Dinner Game', 140, DEFAULT, 'Comedy');
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=f69a0f638f3e519a2a7e9935cc9827f4 -->

<!-- pgdoc-cn_start sig_en=889d07cf391fb794aa91a19dd7fcc708 sig_cn_org=None source=14.1 
  <para>
   This example inserts some rows into table
   <literal>films</literal> from a table <literal>tmp_films</literal>
   with the same column layout as <literal>films</literal>:

<programlisting>
INSERT INTO films SELECT * FROM tmp_films WHERE date_prod &lt; '2004-05-07';
</programlisting>
  </para>
________________________________________________________-->
  <para>
   这个例子从表<literal>tmp_films</literal>中获得一些行插入到表
   <literal>films</literal>中，两个表具有相同的列布局：

<programlisting>
INSERT INTO films SELECT * FROM tmp_films WHERE date_prod &lt; '2004-05-07';
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=889d07cf391fb794aa91a19dd7fcc708 -->

<!-- pgdoc-cn_start sig_en=5858f25e220a3043d49d034a3bfd7b72 sig_cn_org=None source=14.1 
  <para>
   This example inserts into array columns:

<programlisting>
-&minus; Create an empty 3x3 gameboard for noughts-and-crosses
INSERT INTO tictactoe (game, board[1:3][1:3])
    VALUES (1, '{{" "," "," "},{" "," "," "},{" "," "," "}}');
-&minus; The subscripts in the above example aren't really needed
INSERT INTO tictactoe (game, board)
    VALUES (2, '{{X," "," "},{" ",O," "},{" ",X," "}}');
</programlisting>
  </para>
________________________________________________________-->
  <para>
   这个例子插入数组列：

<programlisting>
-- 为 noughts-and-crosses 游戏创建一个空的 3x3 棋盘
INSERT INTO tictactoe (game, board[1:3][1:3])
    VALUES (1, '{{" "," "," "},{" "," "," "},{" "," "," "}}');
-- 实际上可以不用上面例子中的下标
INSERT INTO tictactoe (game, board)
    VALUES (2, '{{X," "," "},{" ",O," "},{" ",X," "}}');
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=5858f25e220a3043d49d034a3bfd7b72 -->

<!-- pgdoc-cn_start sig_en=723e7d4040da19842a8b736b566098f0 sig_cn_org=None source=14.1 
  <para>
   Insert a single row into table <literal>distributors</literal>, returning
   the sequence number generated by the <literal>DEFAULT</literal> clause:

<programlisting>
INSERT INTO distributors (did, dname) VALUES (DEFAULT, 'XYZ Widgets')
   RETURNING did;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   向表<literal>distributors</literal>中插入一行，返回由
   <literal>DEFAULT</literal>子句生成的序号：

<programlisting>
INSERT INTO distributors (did, dname) VALUES (DEFAULT, 'XYZ Widgets')
   RETURNING did;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=723e7d4040da19842a8b736b566098f0 -->

<!-- pgdoc-cn_start sig_en=020dec97166a234f3a0ebb176e219d01 sig_cn_org=None source=14.1 
  <para>
   Increment the sales count of the salesperson who manages the
   account for Acme Corporation, and record the whole updated row
   along with current time in a log table:
<programlisting>
WITH upd AS (
  UPDATE employees SET sales_count = sales_count + 1 WHERE id =
    (SELECT sales_person FROM accounts WHERE name = 'Acme Corporation')
    RETURNING *
)
INSERT INTO employees_log SELECT *, current_timestamp FROM upd;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   增加为 Acme Corporation 管理账户的销售人员的销量，并且把整个被
   更新的行以及当前时间记录到一个日志表中：
<programlisting>
WITH upd AS (
  UPDATE employees SET sales_count = sales_count + 1 WHERE id =
    (SELECT sales_person FROM accounts WHERE name = 'Acme Corporation')
    RETURNING *
)
INSERT INTO employees_log SELECT *, current_timestamp FROM upd;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=020dec97166a234f3a0ebb176e219d01 -->
<!-- pgdoc-cn_start sig_en=f24884bff8bf29a868f48661539ff435 sig_cn_org=None source=14.1 
  <para>
   Insert or update new distributors as appropriate.  Assumes a unique
   index has been defined that constrains values appearing in the
   <literal>did</literal> column.  Note that the special
   <varname>excluded</varname> table is used to reference values originally
   proposed for insertion:
<programlisting>
INSERT INTO distributors (did, dname)
    VALUES (5, 'Gizmo Transglobal'), (6, 'Associated Computing, Inc')
    ON CONFLICT (did) DO UPDATE SET dname = EXCLUDED.dname;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   酌情插入或者更新新的 distributor。假设已经定义了一个唯一索引来约束
   出现在<literal>did</literal>列中的值。注意，特殊的
   <varname>excluded</varname>表被用来引用原来要插入的值：
<programlisting>
INSERT INTO distributors (did, dname)
    VALUES (5, 'Gizmo Transglobal'), (6, 'Associated Computing, Inc')
    ON CONFLICT (did) DO UPDATE SET dname = EXCLUDED.dname;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=f24884bff8bf29a868f48661539ff435 -->
<!-- pgdoc-cn_start sig_en=1001f6ded82f84b52067604eac30564f sig_cn_org=None source=14.1 
  <para>
   Insert a distributor, or do nothing for rows proposed for insertion
   when an existing, excluded row (a row with a matching constrained
   column or columns after before row insert triggers fire) exists.
   Example assumes a unique index has been defined that constrains
   values appearing in the <literal>did</literal> column:
<programlisting>
INSERT INTO distributors (did, dname) VALUES (7, 'Redline GmbH')
    ON CONFLICT (did) DO NOTHING;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   插入一个 distributor，或者在一个被排除的行（具有一个匹配约束的列或者
   会让行级前（或者后）插入触发器引发的列的行）存在时不处理要插入的行。
   例子假设已经定义了一个唯一触发器来约束出现在<literal>did</literal>列
   中的值：
<programlisting>
INSERT INTO distributors (did, dname) VALUES (7, 'Redline GmbH')
    ON CONFLICT (did) DO NOTHING;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=1001f6ded82f84b52067604eac30564f -->
<!-- pgdoc-cn_start sig_en=1aa92d17369ad8a53fccc01280289503 sig_cn_org=None source=14.1 
  <para>
   Insert or update new distributors as appropriate.  Example assumes
   a unique index has been defined that constrains values appearing in
   the <literal>did</literal> column.  <literal>WHERE</literal> clause is
   used to limit the rows actually updated (any existing row not
   updated will still be locked, though):
<programlisting>
-&minus; Don't update existing distributors based in a certain ZIP code
INSERT INTO distributors AS d (did, dname) VALUES (8, 'Anvil Distribution')
    ON CONFLICT (did) DO UPDATE
    SET dname = EXCLUDED.dname || ' (formerly ' || d.dname || ')'
    WHERE d.zipcode &lt;&gt; '21201';

-&minus; Name a constraint directly in the statement (uses associated
-&minus; index to arbitrate taking the DO NOTHING action)
INSERT INTO distributors (did, dname) VALUES (9, 'Antwerp Design')
    ON CONFLICT ON CONSTRAINT distributors_pkey DO NOTHING;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   酌情插入或者更新新的 distributor。例子假设已经定义了一个唯一触发器来
   约束出现在<literal>did</literal>列中的值。<literal>WHERE</literal>子句被用
   来限制实际被更新的行（不过，任何没有被更新的已有行仍将被锁定）：
<programlisting>
-- 根据一个特定的 ZIP 编码更新 distributors
INSERT INTO distributors AS d (did, dname) VALUES (8, 'Anvil Distribution')
    ON CONFLICT (did) DO UPDATE
    SET dname = EXCLUDED.dname || ' (formerly ' || d.dname || ')'
    WHERE d.zipcode &lt;&gt; '21201';

-- 直接在语句中命名一个约束（使用相关的索引来判断是否做
-- DO NOTHING 动作）
INSERT INTO distributors (did, dname) VALUES (9, 'Antwerp Design')
    ON CONFLICT ON CONSTRAINT distributors_pkey DO NOTHING;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=1aa92d17369ad8a53fccc01280289503 -->
<!-- pgdoc-cn_start sig_en=11b2caa371c3934cc4d10367ce8d7792 sig_cn_org=None source=14.1 
  <para>
   Insert new distributor if possible;  otherwise
   <literal>DO NOTHING</literal>.  Example assumes a unique index has been
   defined that constrains values appearing in the
   <literal>did</literal> column on a subset of rows where the
   <literal>is_active</literal> Boolean column evaluates to
   <literal>true</literal>:
<programlisting>
-&minus; This statement could infer a partial unique index on "did"
-&minus; with a predicate of "WHERE is_active", but it could also
-&minus; just use a regular unique constraint on "did"
INSERT INTO distributors (did, dname) VALUES (10, 'Conrad International')
    ON CONFLICT (did) WHERE is_active DO NOTHING;
</programlisting></para>
________________________________________________________-->
  <para>
   如果可能就插入新的 distributor，否则<literal>DO NOTHING</literal>。
   例子假设已经定义了一个唯一索引，它约束让<literal>is_active</literal>
   布尔列为<literal>true</literal>的行子集上<literal>did</literal>列中的值：
<programlisting>
-- 这个语句可能推断出一个在 "did" 上带有谓词 "WHERE is_active"
-- 的部分唯一索引，但是它可能也只是使用了 "did" 上的一个常规唯一约束
INSERT INTO distributors (did, dname) VALUES (10, 'Conrad International')
    ON CONFLICT (did) WHERE is_active DO NOTHING;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=11b2caa371c3934cc4d10367ce8d7792 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
  <title>Compatibility</title>
________________________________________________________-->
  <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=fdd94d48d843f2df0e9d971fab686dd8 sig_cn_org=b555e9ed37c256d0588098e1e8ae42c1 source=15.7 
  <para>
   <command>INSERT</command> conforms to the SQL standard, except that
   the <literal>RETURNING</literal> clause is a
   <productname>PostgreSQL</productname> extension, as is the ability
   to use <literal>WITH</literal> with <command>INSERT</command>, and the ability to
   specify an alternative action with <literal>ON CONFLICT</literal>.
   Also, the case in
   which a column name list is omitted, but not all the columns are
   filled from the <literal>VALUES</literal> clause or <replaceable>query</replaceable>,
   is disallowed by the standard. If you prefer a more SQL standard
   conforming statement than <literal>ON CONFLICT</literal>, see
   <xref linkend="sql-merge"/>.
  </para>
________________________________________________________-->
  <para>
   <command>INSERT</command>符合SQL标准，除了<literal>RETURNING</literal>子句是<productname>PostgreSQL</productname>的扩展，
   还可以在<command>INSERT</command>中使用<literal>WITH</literal>，以及使用<literal>ON CONFLICT</literal>指定替代操作。
   此外，标准不允许省略列名列表，但不是所有列都从<literal>VALUES</literal>子句或<replaceable>query</replaceable>中填充。
   如果您更喜欢符合SQL标准的语句而不是<literal>ON CONFLICT</literal>，请参阅<xref linkend="sql-merge"/>。
</para>
<!-- pgdoc-cn_end sig_en=fdd94d48d843f2df0e9d971fab686dd8 -->

<!-- pgdoc-cn_start sig_en=d99d085178350b7df8f2f86a7671742f sig_cn_org=None source=14.1 
  <para>
   The SQL standard specifies that <literal>OVERRIDING SYSTEM VALUE</literal>
   can only be specified if an identity column that is generated always
   exists.  PostgreSQL allows the clause in any case and ignores it if it is
   not applicable.
  </para>
________________________________________________________-->
  <para>
   SQL标准指定只有存在一个总是会生成值的标识列时才能指定<literal>OVERRIDING SYSTEM VALUE</literal>。而PostgreSQL在任何情况下都允许这个子句，并且在不适用时会忽略它。
  </para>
<!-- pgdoc-cn_end sig_en=d99d085178350b7df8f2f86a7671742f -->

<!-- pgdoc-cn_start sig_en=3770bf4fc33efef97749a9a653e330b9 sig_cn_org=None source=14.1 
  <para>
   Possible limitations of the <replaceable
   class="parameter">query</replaceable> clause are documented under
   <xref linkend="sql-select"/>.
  </para>
________________________________________________________-->
  <para>
   <replaceable
   class="parameter">query</replaceable>子句可能的限制在
   <xref linkend="sql-select"/>有介绍。
  </para>
<!-- pgdoc-cn_end sig_en=3770bf4fc33efef97749a9a653e330b9 -->
 </refsect1>
</refentry>
