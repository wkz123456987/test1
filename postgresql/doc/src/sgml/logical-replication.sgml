<!-- doc/src/sgml/logical-replication.sgml -->

<chapter id="logical-replication">
<!-- pgdoc-cn_start sig_en=fecd01d5379694ff210e913ab6e91060 sig_cn_org=None source=14.1 
 <title>Logical Replication</title>
________________________________________________________-->
 <title>逻辑复制</title>
<!-- pgdoc-cn_end sig_en=fecd01d5379694ff210e913ab6e91060 -->

<!-- pgdoc-cn_start sig_en=b53ca12a3114c1f7b000f80d110a2769 sig_cn_org=None source=14.1 
 <para>
  Logical replication is a method of replicating data objects and their
  changes, based upon their replication identity (usually a primary key).  We
  use the term logical in contrast to physical replication, which uses exact
  block addresses and byte-by-byte replication.  PostgreSQL supports both
  mechanisms concurrently, see <xref linkend="high-availability"/>.  Logical
  replication allows fine-grained control over both data replication and
  security.
 </para>
________________________________________________________-->
 <para>
  逻辑复制是一种基于数据对象的复制标识（通常是主键）复制数据对象及其更改的方法。我们使用术语“逻辑”来与物理复制加以区分，后者使用准确的块地址以及逐字节的复制方式。PostgreSQL两种机制都支持，请见<xref linkend="high-availability"/>。逻辑复制允许在数据复制和安全性上更细粒度的控制。
 </para>
<!-- pgdoc-cn_end sig_en=b53ca12a3114c1f7b000f80d110a2769 -->

<!-- pgdoc-cn_start sig_en=72618307e48bbf539840e1b7318c5d89 sig_cn_org=None source=14.1 
 <para>
  Logical replication uses a <firstterm>publish</firstterm>
  and <firstterm>subscribe</firstterm> model with one or
  more <firstterm>subscribers</firstterm> subscribing to one or more
  <firstterm>publications</firstterm> on a <firstterm>publisher</firstterm>
  node.  Subscribers pull data from the publications they subscribe to and may
  subsequently re-publish data to allow cascading replication or more complex
  configurations.
 </para>
________________________________________________________-->
 <para>
  逻辑复制使用一种<firstterm>发布</firstterm>和<firstterm>订阅</firstterm>模型，其中有一个或者更多<firstterm>订阅者</firstterm>订阅一个<firstterm>发布者</firstterm>节点上的一个或者更多<firstterm>发布</firstterm> 。订阅者从它们所订阅的发布拉取数据并且可能后续重新发布这些数据以允许级联复制或者更复杂的配置。
 </para>
<!-- pgdoc-cn_end sig_en=72618307e48bbf539840e1b7318c5d89 -->

<!-- pgdoc-cn_start sig_en=b5fdc9ebc030a78bec02518aed3303fb sig_cn_org=None source=14.1 
 <para>
  Logical replication of a table typically starts with taking a snapshot
  of the data on the publisher database and copying that to the subscriber.
  Once that is done, the changes on the publisher are sent to the subscriber
  as they occur in real-time.  The subscriber applies the data in the same
  order as the publisher so that transactional consistency is guaranteed for
  publications within a single subscription.  This method of data replication
  is sometimes referred to as transactional replication.
 </para>
________________________________________________________-->
 <para>
  一个表的逻辑复制通常开始于对发布者服务器上的数据取得一个快照并且将快照拷贝给订阅者。一旦这项工作完成，发布者上的更改会被实时发送给订阅者。订阅者以与发布者相同的顺序应用那些数据，这样在一个订阅中能够保证发布的事务一致性。这种数据复制的方法有时候也被称为事务性复制。
 </para>
<!-- pgdoc-cn_end sig_en=b5fdc9ebc030a78bec02518aed3303fb -->

<!-- pgdoc-cn_start sig_en=35d8106d7f3021b5b9e1a2383041325e sig_cn_org=None source=14.1 
 <para>
  The typical use-cases for logical replication are:

  <itemizedlist>
   <listitem>
    <para>
     Sending incremental changes in a single database or a subset of a
     database to subscribers as they occur.
    </para>
   </listitem>

   <listitem>
    <para>
     Firing triggers for individual changes as they arrive on the
     subscriber.
    </para>
   </listitem>

   <listitem>
    <para>
     Consolidating multiple databases into a single one (for example for
     analytical purposes).
    </para>
   </listitem>

   <listitem>
    <para>
     Replicating between different major versions of PostgreSQL.
    </para>
   </listitem>

   <listitem>
    <para>
     Replicating between PostgreSQL instances on different platforms (for
     example Linux to Windows)
    </para>
   </listitem>

   <listitem>
    <para>
     Giving access to replicated data to different groups of users.
    </para>
   </listitem>

   <listitem>
    <para>
     Sharing a subset of the database between multiple databases.
    </para>
   </listitem>
  </itemizedlist>
 </para>
________________________________________________________-->
 <para>
  逻辑复制的典型用法是：

  <itemizedlist>
   <listitem>
    <para>
     在一个数据库或者一个数据库的子集中发生更改时，把增量的改变发送给订阅者。
    </para>
   </listitem>

   <listitem>
    <para>
     在更改到达订阅者时引发触发器。
    </para>
   </listitem>

   <listitem>
    <para>
     把多个数据库联合到单一数据库中（例如用于分析目的）。
    </para>
   </listitem>

   <listitem>
    <para>
     在PostgreSQL的不同主版本之间进行复制。
    </para>
   </listitem>

   <listitem>
    <para>
     在不同平台上（例如Linux到Windows）的PostgreSQL实例之间进行复制。
    </para>
   </listitem>

   <listitem>
    <para>
     将复制数据的访问给予不同的用户组。
    </para>
   </listitem>

   <listitem>
    <para>
     在多个数据库间共享数据库的一个子集。
    </para>
   </listitem>
  </itemizedlist>
 </para>
<!-- pgdoc-cn_end sig_en=35d8106d7f3021b5b9e1a2383041325e -->

<!-- pgdoc-cn_start sig_en=d052c46a2d5c021cd9e528194bb6b9db sig_cn_org=None source=14.1 
 <para>
  The subscriber database behaves in the same way as any other PostgreSQL
  instance and can be used as a publisher for other databases by defining its
  own publications.  When the subscriber is treated as read-only by
  application, there will be no conflicts from a single subscription.  On the
  other hand, if there are other writes done either by an application or by other
  subscribers to the same set of tables, conflicts can arise.
 </para>
________________________________________________________-->
 <para>
  订阅者数据库的行为与任何其他PostgreSQL实例相同，并且可以被用作其他数据库的发布者，只需要定义它自己的发布。当订阅者被应用当作只读时，单一的订阅中不会有冲突。在另一方面，如果应用或者对相同表集合的订阅者执行了其他的写动作，冲突可能会发生。
 </para>
<!-- pgdoc-cn_end sig_en=d052c46a2d5c021cd9e528194bb6b9db -->

 <sect1 id="logical-replication-publication">
<!-- pgdoc-cn_start sig_en=717b90baf94d7baab2825683a16d6084 sig_cn_org=None source=14.1 
  <title>Publication</title>
________________________________________________________-->
  <title>发布</title>
<!-- pgdoc-cn_end sig_en=717b90baf94d7baab2825683a16d6084 -->

<!-- pgdoc-cn_start sig_en=1b033b0d68e2e3fcb33176b4e41029d0 sig_cn_org=None source=14.1 
  <para>
   A <firstterm>publication</firstterm> can be defined on any physical
   replication primary.  The node where a publication is defined is referred to
   as <firstterm>publisher</firstterm>.  A publication is a set of changes
   generated from a table or a group of tables, and might also be described as
   a change set or replication set.  Each publication exists in only one database.
  </para>
________________________________________________________-->
  <para>
   <firstterm>发布</firstterm>可以被定义在任何物理复制的主服务器上。定义有发布的节点被称为<firstterm>发布者</firstterm>。发布是从一个表或者一组表生成的改变的集合，也可以被描述为更改集合或者复制集合。每个发布都只存在于一个数据库中。
  </para>
<!-- pgdoc-cn_end sig_en=1b033b0d68e2e3fcb33176b4e41029d0 -->

<!-- pgdoc-cn_start sig_en=b199588d2ac5a4009aeebeb7589e1436 sig_cn_org=532718a39540d3feecc981baf489138f source=15.7 
  <para>
   Publications are different from schemas and do not affect how the table is
   accessed.  Each table can be added to multiple publications if needed.
   Publications may currently only contain tables and all tables in schema.
   Objects must be added explicitly, except when a publication is created for
   <literal>ALL TABLES</literal>.
  </para>
________________________________________________________-->
  <para>
   发布物与模式不同，不影响表的访问。每个表可以添加到多个发布物中（如果需要）。
   发布物目前只能包含模式中的所有表。对象必须显式添加，除非为<literal>ALL TABLES</literal>创建了一个发布物。
</para>
<!-- pgdoc-cn_end sig_en=b199588d2ac5a4009aeebeb7589e1436 -->

<!-- pgdoc-cn_start sig_en=5b4dc3156027cc7f81ae36979b0bb0ab sig_cn_org=51c5807e2990aeadd4a8d2d573b9e0a3 source=15.7 
  <para>
   Publications can choose to limit the changes they produce to
   any combination of <command>INSERT</command>, <command>UPDATE</command>,
   <command>DELETE</command>, and <command>TRUNCATE</command>, similar to how triggers are fired by
   particular event types. By default, all operation types are replicated.
   These publication specifications apply only for DML operations; they do not affect the initial
   data synchronization copy. (Row filters have no effect for
   <command>TRUNCATE</command>. See <xref linkend="logical-replication-row-filter"/>).
  </para>
________________________________________________________-->
  <para>
   出版物可以选择将它们产生的更改限制为<command>INSERT</command>、<command>UPDATE</command>、
   <command>DELETE</command>和<command>TRUNCATE</command>的任意组合，类似于触发器如何由特定事件类型触发。
   默认情况下，所有操作类型都会被复制。这些出版规范仅适用于DML操作；它们不影响初始数据同步副本。
   （行过滤器对<command>TRUNCATE</command>没有影响。请参见<xref linkend="logical-replication-row-filter"/>）。
</para>
<!-- pgdoc-cn_end sig_en=5b4dc3156027cc7f81ae36979b0bb0ab -->

<!-- pgdoc-cn_start sig_en=45c3b94f3b8d22cfee4b6399f08c0f16 sig_cn_org=None source=14.1 
  <para>
   A published table must have a <quote>replica identity</quote> configured in
   order to be able to replicate <command>UPDATE</command>
   and <command>DELETE</command> operations, so that appropriate rows to
   update or delete can be identified on the subscriber side.  By default,
   this is the primary key, if there is one.  Another unique index (with
   certain additional requirements) can also be set to be the replica
   identity.  If the table does not have any suitable key, then it can be set
   to replica identity <quote>full</quote>, which means the entire row becomes
   the key.  This, however, is very inefficient and should only be used as a
   fallback if no other solution is possible.  If a replica identity other
   than <quote>full</quote> is set on the publisher side, a replica identity
   comprising the same or fewer columns must also be set on the subscriber
   side.  See <xref linkend="sql-altertable-replica-identity"/> for details on
   how to set the replica identity.  If a table without a replica identity is
   added to a publication that replicates <command>UPDATE</command>
   or <command>DELETE</command> operations then
   subsequent <command>UPDATE</command> or <command>DELETE</command>
   operations will cause an error on the publisher.  <command>INSERT</command>
   operations can proceed regardless of any replica identity.
  </para>
________________________________________________________-->
  <para>
   为了能够复制<command>UPDATE</command>和<command>DELETE</command>操作，被发布的表必须配置有一个<quote>复制标识</quote>，这样在订阅者那一端才能标识对于更新或删除合适的行。默认情况下，复制标识就是主键（如果有主键）。也可以在复制标识上设置另一个唯一索引（有特定的额外要求）。如果表没有合适的键，那么可以设置成复制标识<quote>full</quote>，它表示整个行都成为那个键。不过，这样做效率很低，只有在没有其他方案的情况下才应该使用。如果在发布者端设置了<quote>full</quote>之外的复制标识，在订阅者端也必须设置一个复制标识，它应该由相同的或者少一些的列组成。如何设置复制标识的细节请参考<xref linkend="sql-altertable-replica-identity"/>。如果在复制<command>UPDATE</command>或<command>DELETE</command>操作的发布中加入了没有复制标识的表，那么订阅者上后续的<command>UPDATE</command>或<command>DELETE</command>操作将导致错误。不管有没有复制标识，<command>INSERT</command>操作都能继续下去。
  </para>
<!-- pgdoc-cn_end sig_en=45c3b94f3b8d22cfee4b6399f08c0f16 -->

<!-- pgdoc-cn_start sig_en=f1ec7808870382ff6e99eaf96ff625f5 sig_cn_org=None source=14.1 
  <para>
   Every publication can have multiple subscribers.
  </para>
________________________________________________________-->
  <para>
   每一个发布都可以由多个订阅者。
  </para>
<!-- pgdoc-cn_end sig_en=f1ec7808870382ff6e99eaf96ff625f5 -->

<!-- pgdoc-cn_start sig_en=07fa9280fb925e147851007ef3f01335 sig_cn_org=None source=14.1 
  <para>
   A publication is created using the <link linkend="sql-createpublication"><command>CREATE PUBLICATION</command></link>
   command and may later be altered or dropped using corresponding commands.
  </para>
________________________________________________________-->
  <para>
   Publication通过使用<link linkend="sql-createpublication"><command>CREATE PUBLICATION</command></link>命令创建并且可以在之后使用相应的命令进行修改或者删除。
  </para>
<!-- pgdoc-cn_end sig_en=07fa9280fb925e147851007ef3f01335 -->

<!-- pgdoc-cn_start sig_en=c9dea665e3c513e8be0aebfdf4a3c425 sig_cn_org=None source=14.1 
  <para>
   The individual tables can be added and removed dynamically using
   <link linkend="sql-alterpublication"><command>ALTER PUBLICATION</command></link>.  Both the <literal>ADD
   TABLE</literal> and <literal>DROP TABLE</literal> operations are
   transactional; so the table will start or stop replicating at the correct
   snapshot once the transaction has committed.
  </para>
________________________________________________________-->
  <para>
   表可以使用<link linkend="sql-alterpublication"><command>ALTER PUBLICATION</command></link>动态地增加或者移除。<literal>ADD TABLE</literal>以及<literal>DROP TABLE</literal>操作都是事务性的，因此一旦该事务提交，该表将以正确的快照开始或者停止复制。
  </para>
<!-- pgdoc-cn_end sig_en=c9dea665e3c513e8be0aebfdf4a3c425 -->
 </sect1>

 <sect1 id="logical-replication-subscription">
<!-- pgdoc-cn_start sig_en=6525b1403dc1d2ab15f877ff0071bfad sig_cn_org=None source=14.1 
  <title>Subscription</title>
________________________________________________________-->
  <title>订阅</title>
<!-- pgdoc-cn_end sig_en=6525b1403dc1d2ab15f877ff0071bfad -->

<!-- pgdoc-cn_start sig_en=f2494666498f00a04cde6de377599ddc sig_cn_org=None source=14.1 
  <para>
   A <firstterm>subscription</firstterm> is the downstream side of logical
   replication.  The node where a subscription is defined is referred to as
   the <firstterm>subscriber</firstterm>.  A subscription defines the connection
   to another database and set of publications (one or more) to which it wants
   to subscribe.
  </para>
________________________________________________________-->
  <para>
   <firstterm>订阅</firstterm>是逻辑复制的下游端。订阅被定义在其中的节点被称为<firstterm>订阅者</firstterm>。一个订阅会定义到另一个数据库的连接以及它想要订阅的发布集合（一个或者多个）。
  </para>
<!-- pgdoc-cn_end sig_en=f2494666498f00a04cde6de377599ddc -->

<!-- pgdoc-cn_start sig_en=0c946034d53c36041e11837112d6dbb1 sig_cn_org=None source=14.1 
  <para>
   The subscriber database behaves in the same way as any other PostgreSQL
   instance and can be used as a publisher for other databases by defining its
   own publications.
  </para>
________________________________________________________-->
  <para>
   订阅者数据库的行为与任何其他PostgreSQL实例相同，并且可以被用作其他数据库的发布者，只需要定义它自己的发布。
  </para>
<!-- pgdoc-cn_end sig_en=0c946034d53c36041e11837112d6dbb1 -->

<!-- pgdoc-cn_start sig_en=ba711a19ed32585046493b1e45e9e532 sig_cn_org=None source=14.1 
  <para>
   A subscriber node may have multiple subscriptions if desired.  It is
   possible to define multiple subscriptions between a single
   publisher-subscriber pair, in which case care must be taken to ensure
   that the subscribed publication objects don't overlap.
  </para>
________________________________________________________-->
  <para>
   如果需要，一个订阅者节点可以有多个订阅。可以在一对发布者-订阅者之间定义多个订阅，在这种情况下要确保被订阅的发布对象不会重叠。
  </para>
<!-- pgdoc-cn_end sig_en=ba711a19ed32585046493b1e45e9e532 -->

<!-- pgdoc-cn_start sig_en=2df7c82648caa9391bb4c1ad736e28ed sig_cn_org=None source=14.1 
  <para>
   Each subscription will receive changes via one replication slot (see
   <xref linkend="streaming-replication-slots"/>).  Additional replication
   slots may be required for the initial data synchronization of
   pre-existing table data and those will be dropped at the end of data
   synchronization.
  </para>
________________________________________________________-->
  <para>
   每一个订阅都将通过一个复制槽（见<xref linkend="streaming-replication-slots"/>）接收更改。预先存在的表数据的初始数据同步过程可能会要求额外的复制槽，并且在数据同步结束后删除。
  </para>
<!-- pgdoc-cn_end sig_en=2df7c82648caa9391bb4c1ad736e28ed -->

<!-- pgdoc-cn_start sig_en=aed95f2c40f26781e794a11cb78ea7fe sig_cn_org=None source=14.1 
  <para>
   A logical replication subscription can be a standby for synchronous
   replication (see <xref linkend="synchronous-replication"/>).  The standby
   name is by default the subscription name.  An alternative name can be
   specified as <literal>application_name</literal> in the connection
   information of the subscription.
  </para>
________________________________________________________-->
  <para>
   逻辑复制订阅可以是同步复制（见<xref linkend="synchronous-replication"/>）的后备服务器。后备名称默认是该订阅的名称。可以在订阅的连接信息中用<literal>application_name</literal>指定一个可供选择的名称。
  </para>
<!-- pgdoc-cn_end sig_en=aed95f2c40f26781e794a11cb78ea7fe -->

<!-- pgdoc-cn_start sig_en=b32571bbca8ab542321fd34e4530b700 sig_cn_org=None source=14.1 
  <para>
   Subscriptions are dumped by <command>pg_dump</command> if the current user
   is a superuser.  Otherwise a warning is written and subscriptions are
   skipped, because non-superusers cannot read all subscription information
   from the <structname>pg_subscription</structname> catalog.
  </para>
________________________________________________________-->
  <para>
   如果当前用户是一个超级用户，则订阅会被<command>pg_dump</command>转储。否则订阅会被跳过并且写出一个警告，因为非超级用户不能从<structname>pg_subscription</structname>目录中读取所有的订阅信息。
  </para>
<!-- pgdoc-cn_end sig_en=b32571bbca8ab542321fd34e4530b700 -->

<!-- pgdoc-cn_start sig_en=8d2cc83edf485c282656b4f28befc184 sig_cn_org=None source=14.1 
  <para>
   The subscription is added using <link linkend="sql-createsubscription"><command>CREATE SUBSCRIPTION</command></link> and
   can be stopped/resumed at any time using the
   <link linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION</command></link> command and removed using
   <link linkend="sql-dropsubscription"><command>DROP SUBSCRIPTION</command></link>.
  </para>
________________________________________________________-->
  <para>
   可以使用<link linkend="sql-createsubscription"><command>CREATE SUBSCRIPTION</command></link>增加订阅，并且使用<link linkend="sql-altersubscription"><command>ALTER SUBSCRIPTION</command></link>在任何时刻停止/继续订阅，还可以使用<link linkend="sql-dropsubscription"><command>DROP SUBSCRIPTION</command></link>删除订阅。
  </para>
<!-- pgdoc-cn_end sig_en=8d2cc83edf485c282656b4f28befc184 -->

<!-- pgdoc-cn_start sig_en=67136d8302d60e6808ecbaba36f497fe sig_cn_org=None source=14.1 
  <para>
   When a subscription is dropped and recreated, the synchronization
   information is lost.  This means that the data has to be resynchronized
   afterwards.
  </para>
________________________________________________________-->
  <para>
   在一个订阅被删除并且重建时，同步信息会丢失。这意味着数据必须被重新同步。
  </para>
<!-- pgdoc-cn_end sig_en=67136d8302d60e6808ecbaba36f497fe -->

<!-- pgdoc-cn_start sig_en=2aabc5973a2bef66bb1adb97689409b0 sig_cn_org=None source=14.1 
  <para>
   The schema definitions are not replicated, and the published tables must
   exist on the subscriber.  Only regular tables may be
   the target of replication.  For example, you can't replicate to a view.
  </para>
________________________________________________________-->
  <para>
   模式定义不会被复制，并且被发布的表必须在订阅者上存在。只有常规表可以成为复制的目标。例如，不能复制视图。
  </para>
<!-- pgdoc-cn_end sig_en=2aabc5973a2bef66bb1adb97689409b0 -->

<!-- pgdoc-cn_start sig_en=55ac9e8425a7c6621c13f5e927101d73 sig_cn_org=None source=14.1 
  <para>
   The tables are matched between the publisher and the subscriber using the
   fully qualified table name.  Replication to differently-named tables on the
   subscriber is not supported.
  </para>
________________________________________________________-->
  <para>
   表在发布者和订阅者之间使用完全限定的表名进行匹配。不支持复制到订阅者上命名不同的表。
  </para>
<!-- pgdoc-cn_end sig_en=55ac9e8425a7c6621c13f5e927101d73 -->

<!-- pgdoc-cn_start sig_en=82b9d1aa4a66fb3639944633cd02f226 sig_cn_org=None source=14.1 
  <para>
   Columns of a table are also matched by name.  The order of columns in the
   subscriber table does not need to match that of the publisher.  The data
   types of the columns do not need to match, as long as the text
   representation of the data can be converted to the target type.  For
   example, you can replicate from a column of type <type>integer</type> to a
   column of type <type>bigint</type>.  The target table can also have
   additional columns not provided by the published table.  Any such columns
   will be filled with the default value as specified in the definition of the
   target table.
  </para>
________________________________________________________-->
  <para>
   表的列也通过名称匹配。订阅表中的列顺序不需要与发布表中的顺序一样。
   列的数据类型也不需要一样，只要可以将数据的文本表示形式转换为目标类型即可。
   例如，您可以从<type>integer</type>类型的列复制到<type>bigint</type>类型的列。
   目标表还可以具有发布表中不存在的额外列。额外列都将使用目标表的定义中指定的默认值填充。
  </para>
<!-- pgdoc-cn_end sig_en=82b9d1aa4a66fb3639944633cd02f226 -->

  <sect2 id="logical-replication-subscription-slot">
<!-- pgdoc-cn_start sig_en=a070e4820a991557394830f9f6f6f8cf sig_cn_org=None source=14.1 
   <title>Replication Slot Management</title>
________________________________________________________-->
   <title>复制槽管理</title>
<!-- pgdoc-cn_end sig_en=a070e4820a991557394830f9f6f6f8cf -->

<!-- pgdoc-cn_start sig_en=717be12583ca68e993c2eb6978ad360a sig_cn_org=None source=14.1 
   <para>
    As mentioned earlier, each (active) subscription receives changes from a
    replication slot on the remote (publishing) side.
   </para>
________________________________________________________-->
   <para>
    如早前所提到的，每一个（活跃的）订阅会从远（发布）端上的一个复制槽接收更改。
    </para>
<!-- pgdoc-cn_end sig_en=717be12583ca68e993c2eb6978ad360a -->
<!-- pgdoc-cn_start sig_en=c7f3b3e4b2f024b1b00207f708806d76 sig_cn_org=None source=14.1 
   <para>
    Additional table synchronization slots are normally transient, created
    internally to perform initial table synchronization and dropped
    automatically when they are no longer needed. These table synchronization
    slots have generated names: <quote><literal>pg_%u_sync_%u_%llu</literal></quote>
    (parameters: Subscription <parameter>oid</parameter>,
    Table <parameter>relid</parameter>, system identifier <parameter>sysid</parameter>)
   </para>
________________________________________________________-->
   <para>
    额外的表同步槽通常是临时的，在内部创建以执行初始表同步，并在它们不再被需要时自动删除。这些表同步槽命名为: <quote><literal>pg_%u_sync_%u_%llu</literal></quote>
    (参数是: Subscription <parameter>oid</parameter>,
    Table <parameter>relid</parameter>, system identifier <parameter>sysid</parameter>)
   </para>
<!-- pgdoc-cn_end sig_en=c7f3b3e4b2f024b1b00207f708806d76 -->
<!-- pgdoc-cn_start sig_en=84fe7c2e2f085b3b3c450205b30e4899 sig_cn_org=None source=14.1 
   <para>
    Normally, the remote replication slot is created automatically when the
    subscription is created using <command>CREATE SUBSCRIPTION</command> and it
    is dropped automatically when the subscription is dropped using
    <command>DROP SUBSCRIPTION</command>.  In some situations, however, it can
    be useful or necessary to manipulate the subscription and the underlying
    replication slot separately.  Here are some scenarios:

    <itemizedlist>
     <listitem>
      <para>
       When creating a subscription, the replication slot already exists.  In
       that case, the subscription can be created using
       the <literal>create_slot = false</literal> option to associate with the
       existing slot.
      </para>
     </listitem>

     <listitem>
      <para>
       When creating a subscription, the remote host is not reachable or in an
       unclear state.  In that case, the subscription can be created using
       the <literal>connect = false</literal> option.  The remote host will then not
       be contacted at all.  This is what <application>pg_dump</application>
       uses.  The remote replication slot will then have to be created
       manually before the subscription can be activated.
      </para>
     </listitem>

     <listitem>
      <para>
       When dropping a subscription, the replication slot should be kept.
       This could be useful when the subscriber database is being moved to a
       different host and will be activated from there.  In that case,
       disassociate the slot from the subscription using <command>ALTER
       SUBSCRIPTION</command> before attempting to drop the subscription.
      </para>
     </listitem>

     <listitem>
      <para>
       When dropping a subscription, the remote host is not reachable.  In
       that case, disassociate the slot from the subscription
       using <command>ALTER SUBSCRIPTION</command> before attempting to drop
       the subscription.  If the remote database instance no longer exists, no
       further action is then necessary.  If, however, the remote database
       instance is just unreachable, the replication slot (and any still
       remaining table synchronization slots) should then be
       dropped manually; otherwise it/they would continue to reserve WAL and might
       eventually cause the disk to fill up.  Such cases should be carefully
       investigated.
      </para>
     </listitem>
    </itemizedlist>
   </para>
________________________________________________________-->
   <para>
   通常，远程复制槽是在使用<command>CREATE SUBSCRIPTION</command>创建订阅是自动创建的，并且在使用<command>DROP SUBSCRIPTION</command>删除订阅时，复制槽也会自动被删除。不过，在一些情况下，有必要单独操纵订阅以及其底层的复制槽。下面是一些场景：

    <itemizedlist>
     <listitem>
      <para>
       在创建一个订阅时，复制槽已经存在。在这种情况下，可以使用<literal>create_slot = false</literal>选项创建订阅并关联到现有的槽。
      </para>
     </listitem>

     <listitem>
      <para>
       在创建一个订阅时，远程主机不可达或者处于一种不明状态。在这种情况下，可以使用<literal>connect = false</literal>选项创建订阅。那么远程主机将根本不会被联系。这是<application>pg_dump</application>所使用的方式。这样，在订阅可以被激活之前，必须手工创建远程复制槽。
      </para>
     </listitem>

     <listitem>
      <para>
       在删除一个订阅时，复制槽应该被保留。当订阅者数据库正在被移动到一台不同的主机并且将从那里再被激活时，这种行为很有用。在这种情况下，可以在尝试删除该订阅之前，使用<command>ALTER SUBSCRIPTION</command>将复制槽解除关联。
      </para>
     </listitem>

     <listitem>
      <para>
       在删除一个订阅时，远程主机不可达。在这种情况下，可以在尝试删除该订阅之前，使用<command>ALTER SUBSCRIPTION</command>将复制槽解除关联。如果远程数据库实例不再存在，那么不需要进一步的行动。不过，如果远程数据库实例只是不可达，那么复制槽应该被手动删除（以及任何剩余的表同步槽）。否则它将会继续保留WAL并且最终可能会导致磁盘被填满。这种情况应该要仔细地研究。
      </para>
     </listitem>
    </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=84fe7c2e2f085b3b3c450205b30e4899 -->
  </sect2>

  <sect2 id="logical-replication-subscription-examples">
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
    <title>Examples</title>
________________________________________________________-->
    <title>例子</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=38580881cfa6826dd1225d52c440e513 sig_cn_org=48f4c875276247bccde225002d33dadf source=15.7 
    <para>
     Create some test tables on the publisher.
<programlisting>
test_pub=# CREATE TABLE t1(a int, b text, PRIMARY KEY(a));
CREATE TABLE
test_pub=# CREATE TABLE t2(c int, d text, PRIMARY KEY(c));
CREATE TABLE
test_pub=# CREATE TABLE t3(e int, f text, PRIMARY KEY(e));
CREATE TABLE
</programlisting></para>
________________________________________________________-->
    <para>
     在发布者上创建一些测试表。
<programlisting>
test_pub=# 创建表 t1(a int, b text, PRIMARY KEY(a));
CREATE TABLE
test_pub=# 创建表 t2(c int, d text, PRIMARY KEY(c));
CREATE TABLE
test_pub=# 创建表 t3(e int, f text, PRIMARY KEY(e));
CREATE TABLE
</programlisting></para>
<!-- pgdoc-cn_end sig_en=38580881cfa6826dd1225d52c440e513 -->

<!-- pgdoc-cn_start sig_en=8fcba6a8f79d1775cdfd927f351162c8 sig_cn_org=dc9161bc6532c7c61197467017a0eadf source=15.7 
    <para>
     Create the same tables on the subscriber.
<programlisting>
test_sub=# CREATE TABLE t1(a int, b text, PRIMARY KEY(a));
CREATE TABLE
test_sub=# CREATE TABLE t2(c int, d text, PRIMARY KEY(c));
CREATE TABLE
test_sub=# CREATE TABLE t3(e int, f text, PRIMARY KEY(e));
CREATE TABLE
</programlisting></para>
________________________________________________________-->
    <para>
     在订阅者上创建相同的表。
<programlisting>
test_sub=# CREATE TABLE t1(a int, b text, PRIMARY KEY(a));
CREATE TABLE
test_sub=# CREATE TABLE t2(c int, d text, PRIMARY KEY(c));
CREATE TABLE
test_sub=# CREATE TABLE t3(e int, f text, PRIMARY KEY(e));
CREATE TABLE
</programlisting></para>
<!-- pgdoc-cn_end sig_en=8fcba6a8f79d1775cdfd927f351162c8 -->

<!-- pgdoc-cn_start sig_en=c7d0eea3935b657842be0ab1d3001653 sig_cn_org=4a06ca19d87d5aeea720f85630e08232 source=15.7 
    <para>
     Insert data to the tables at the publisher side.
<programlisting>
test_pub=# INSERT INTO t1 VALUES (1, 'one'), (2, 'two'), (3, 'three');
INSERT 0 3
test_pub=# INSERT INTO t2 VALUES (1, 'A'), (2, 'B'), (3, 'C');
INSERT 0 3
test_pub=# INSERT INTO t3 VALUES (1, 'i'), (2, 'ii'), (3, 'iii');
INSERT 0 3
</programlisting></para>
________________________________________________________-->
    <para>
     在发布者端向表中插入数据。
<programlisting>
test_pub=# INSERT INTO t1 VALUES (1, 'one'), (2, 'two'), (3, 'three');
INSERT 0 3
test_pub=# INSERT INTO t2 VALUES (1, 'A'), (2, 'B'), (3, 'C');
INSERT 0 3
test_pub=# INSERT INTO t3 VALUES (1, 'i'), (2, 'ii'), (3, 'iii');
INSERT 0 3
</programlisting></para>
<!-- pgdoc-cn_end sig_en=c7d0eea3935b657842be0ab1d3001653 -->

<!-- pgdoc-cn_start sig_en=67e98c19d4ef58f675e6d00d337ff379 sig_cn_org=e085261852c7e7bb4d5445481dbf78c2 source=15.7 
    <para>
     Create publications for the tables. The publications <literal>pub2</literal>
     and <literal>pub3a</literal> disallow some <literal>publish</literal>
     operations. The publication <literal>pub3b</literal> has a row filter (see
     <xref linkend="logical-replication-row-filter"/>).
<programlisting>
test_pub=# CREATE PUBLICATION pub1 FOR TABLE t1;
CREATE PUBLICATION
test_pub=# CREATE PUBLICATION pub2 FOR TABLE t2 WITH (publish = 'truncate');
CREATE PUBLICATION
test_pub=# CREATE PUBLICATION pub3a FOR TABLE t3 WITH (publish = 'truncate');
CREATE PUBLICATION
test_pub=# CREATE PUBLICATION pub3b FOR TABLE t3 WHERE (e > 5);
CREATE PUBLICATION
</programlisting></para>
________________________________________________________-->
    <para>
     为这些表创建出版物。出版物<literal>pub2</literal>和<literal>pub3a</literal>禁止一些<literal>publish</literal>操作。
     出版物<literal>pub3b</literal>有一行过滤器（参见<xref linkend="logical-replication-row-filter"/>）。
<programlisting>
test_pub=# 为表t1创建出版物pub1;
CREATE PUBLICATION
test_pub=# 为表t2创建出版物pub2，并使用（publish = 'truncate'）;
CREATE PUBLICATION
test_pub=# 为表t3创建出版物pub3a，并使用（publish = 'truncate'）;
CREATE PUBLICATION
test_pub=# 为表t3创建出版物pub3b，其中（e > 5）;
CREATE PUBLICATION
</programlisting></para>
<!-- pgdoc-cn_end sig_en=67e98c19d4ef58f675e6d00d337ff379 -->

<!-- pgdoc-cn_start sig_en=8022727be2ec07eb2ac86ce454a4d027 sig_cn_org=486dbdb685f195d6bf405cbf6821b270 source=15.7 
    <para>
     Create subscriptions for the publications. The subscription
     <literal>sub3</literal> subscribes to both <literal>pub3a</literal> and
     <literal>pub3b</literal>. All subscriptions will copy initial data by default.
<programlisting>
test_sub=# CREATE SUBSCRIPTION sub1
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=sub1'
test_sub-# PUBLICATION pub1;
CREATE SUBSCRIPTION
test_sub=# CREATE SUBSCRIPTION sub2
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=sub2'
test_sub-# PUBLICATION pub2;
CREATE SUBSCRIPTION
test_sub=# CREATE SUBSCRIPTION sub3
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=sub3'
test_sub-# PUBLICATION pub3a, pub3b;
CREATE SUBSCRIPTION
</programlisting></para>
________________________________________________________-->
    <para>
     为这些出版物创建订阅。订阅<literal>sub3</literal>订阅了<literal>pub3a</literal>和<literal>pub3b</literal>。
     所有订阅将默认复制初始数据。
<programlisting>
test_sub=# 创建订阅 sub1
test_sub-# 连接 'host=localhost dbname=test_pub application_name=sub1'
test_sub-# 出版 pub1;
创建订阅
test_sub=# 创建订阅 sub2
test_sub-# 连接 'host=localhost dbname=test_pub application_name=sub2'
test_sub-# 出版 pub2;
创建订阅
test_sub=# 创建订阅 sub3
test_sub-# 连接 'host=localhost dbname=test_pub application_name=sub3'
test_sub-# 出版 pub3a, pub3b;
创建订阅
</programlisting></para>
<!-- pgdoc-cn_end sig_en=8022727be2ec07eb2ac86ce454a4d027 -->

<!-- pgdoc-cn_start sig_en=7d26e10cd50771f2171f12a9c70c8c3d sig_cn_org=2a3071a98a99935b8e1fb8787ea51584 source=15.7 
    <para>
     Observe that initial table data is copied, regardless of the
     <literal>publish</literal> operation of the publication.
<programlisting>
test_sub=# SELECT * FROM t1;
 a |   b
-&minus;-+-&minus;-&minus;-&minus;-
 1 | one
 2 | two
 3 | three
(3 rows)

test_sub=# SELECT * FROM t2;
 c | d
-&minus;-+-&minus;-
 1 | A
 2 | B
 3 | C
(3 rows)
</programlisting></para>
________________________________________________________-->
    <para>
     注意，初始表数据会被复制，无论对发布执行<literal>publish</literal>操作。
<programlisting>
test_sub=# 从t1表中选择*;
 a |   b
---+-------
 1 | one
 2 | two
 3 | three
(3 行)

test_sub=# 从t2表中选择*;
 c | d
---+---
 1 | A
 2 | B
 3 | C
(3 行)
</programlisting></para>
<!-- pgdoc-cn_end sig_en=7d26e10cd50771f2171f12a9c70c8c3d -->

<!-- pgdoc-cn_start sig_en=dcaf9f1a2977514cd93d426f82057030 sig_cn_org=2291a387f087d482dc1697b6e2d1463b source=15.7 
    <para>
     Furthermore, because the initial data copy ignores the <literal>publish</literal>
     operation, and because publication <literal>pub3a</literal> has no row filter,
     it means the copied table <literal>t3</literal> contains all rows even when
     they do not match the row filter of publication <literal>pub3b</literal>.
<programlisting>
test_sub=# SELECT * FROM t3;
 e |  f
-&minus;-+-&minus;-&minus;-
 1 | i
 2 | ii
 3 | iii
(3 rows)
</programlisting></para>
________________________________________________________-->
    <para>
     此外，由于初始数据复制忽略了<literal>publish</literal>操作，并且因为发布<literal>pub3a</literal>没有行过滤器，
     这意味着复制的表<literal>t3</literal>包含所有行，即使它们不匹配发布<literal>pub3b</literal>的行过滤器。
<programlisting>
test_sub=# SELECT * FROM t3;
 e |  f
---+-----
 1 | i
 2 | ii
 3 | iii
(3 rows)
</programlisting></para>
<!-- pgdoc-cn_end sig_en=dcaf9f1a2977514cd93d426f82057030 -->

<!-- pgdoc-cn_start sig_en=e285f39c1d4272fd4486fba28a6e0748 sig_cn_org=3f8c9a6916fb3abf2c1a21e61f77dd4b source=15.7 
   <para>
    Insert more data to the tables at the publisher side.
<programlisting>
test_pub=# INSERT INTO t1 VALUES (4, 'four'), (5, 'five'), (6, 'six');
INSERT 0 3
test_pub=# INSERT INTO t2 VALUES (4, 'D'), (5, 'E'), (6, 'F');
INSERT 0 3
test_pub=# INSERT INTO t3 VALUES (4, 'iv'), (5, 'v'), (6, 'vi');
INSERT 0 3
</programlisting></para>
________________________________________________________-->
   <para>
    在发布方面向表格中插入更多数据。
<programlisting>
test_pub=# INSERT INTO t1 VALUES (4, 'four'), (5, 'five'), (6, 'six');
INSERT 0 3
test_pub=# INSERT INTO t2 VALUES (4, 'D'), (5, 'E'), (6, 'F');
INSERT 0 3
test_pub=# INSERT INTO t3 VALUES (4, 'iv'), (5, 'v'), (6, 'vi');
INSERT 0 3
</programlisting></para>
<!-- pgdoc-cn_end sig_en=e285f39c1d4272fd4486fba28a6e0748 -->

<!-- pgdoc-cn_start sig_en=df497d62cf7543428855d7b2809a4192 sig_cn_org=064eb6714254c30e820c0ec09abd7c50 source=15.7 
   <para>
    Now the publisher side data looks like:
<programlisting>
test_pub=# SELECT * FROM t1;
 a |   b
-&minus;-+-&minus;-&minus;-&minus;-
 1 | one
 2 | two
 3 | three
 4 | four
 5 | five
 6 | six
(6 rows)

test_pub=# SELECT * FROM t2;
 c | d
-&minus;-+-&minus;-
 1 | A
 2 | B
 3 | C
 4 | D
 5 | E
 6 | F
(6 rows)

test_pub=# SELECT * FROM t3;
 e |  f
-&minus;-+-&minus;-&minus;-
 1 | i
 2 | ii
 3 | iii
 4 | iv
 5 | v
 6 | vi
(6 rows)
</programlisting></para>
________________________________________________________-->
   <para>
    现在出版商端的数据如下：
<programlisting>
test_pub=# 从 t1 表中选择 *;
 a |   b
---+-------
 1 | one
 2 | two
 3 | three
 4 | four
 5 | five
 6 | six
(6 行)

test_pub=# 从 t2 表中选择 *;
 c | d
---+---
 1 | A
 2 | B
 3 | C
 4 | D
 5 | E
 6 | F
(6 行)

test_pub=# 从 t3 表中选择 *;
 e |  f
---+-----
 1 | i
 2 | ii
 3 | iii
 4 | iv
 5 | v
 6 | vi
(6 行)
</programlisting></para>
<!-- pgdoc-cn_end sig_en=df497d62cf7543428855d7b2809a4192 -->

<!-- pgdoc-cn_start sig_en=823e59b8abc24f4315245b5ab3ac704f sig_cn_org=b897a0a03f64e5ccaae5dc44dbad5238 source=15.7 
   <para>
    Observe that during normal replication the appropriate
    <literal>publish</literal> operations are used. This means publications
    <literal>pub2</literal> and <literal>pub3a</literal> will not replicate the
    <literal>INSERT</literal>. Also, publication <literal>pub3b</literal> will
    only replicate data that matches the row filter of <literal>pub3b</literal>.
    Now the subscriber side data looks like:
<programlisting>
test_sub=# SELECT * FROM t1;
 a |   b
-&minus;-+-&minus;-&minus;-&minus;-
 1 | one
 2 | two
 3 | three
 4 | four
 5 | five
 6 | six
(6 rows)

test_sub=# SELECT * FROM t2;
 c | d
-&minus;-+-&minus;-
 1 | A
 2 | B
 3 | C
(3 rows)

test_sub=# SELECT * FROM t3;
 e |  f
-&minus;-+-&minus;-&minus;-
 1 | i
 2 | ii
 3 | iii
 6 | vi
(4 rows)
</programlisting></para>
________________________________________________________-->
   <para>
    观察到在正常复制过程中，适当的<literal>publish</literal>操作被使用。这意味着发布物<literal>pub2</literal>和<literal>pub3a</literal>不会复制<literal>INSERT</literal>。
    另外，发布物<literal>pub3b</literal>只会复制与<literal>pub3b</literal>的行过滤器匹配的数据。现在订阅方的数据如下：
<programlisting>
test_sub=# SELECT * FROM t1;
 a |   b
---+-------
 1 | one
 2 | two
 3 | three
 4 | four
 5 | five
 6 | six
(6 行)

test_sub=# SELECT * FROM t2;
 c | d
---+---
 1 | A
 2 | B
 3 | C
(3 行)

test_sub=# SELECT * FROM t3;
 e |  f
---+-----
 1 | i
 2 | ii
 3 | iii
 6 | vi
(4 行)
</programlisting></para>
<!-- pgdoc-cn_end sig_en=823e59b8abc24f4315245b5ab3ac704f -->
  </sect2>

 </sect1>

 <sect1 id="logical-replication-row-filter">
<!-- pgdoc-cn_start sig_en=35e6b5fb60094303951c679af9dedb65 sig_cn_org=fc454c8b1bfcbcbf3729667c5c1aa0a0 source=15.7 
  <title>Row Filters</title>
________________________________________________________-->
  <title>行过滤器</title>
<!-- pgdoc-cn_end sig_en=35e6b5fb60094303951c679af9dedb65 -->

<!-- pgdoc-cn_start sig_en=742ec1f08b2b209ada4751a77b9baafe sig_cn_org=52f6b82088d8918a3fe7e6649e736878 source=15.7 
  <para>
   By default, all data from all published tables will be replicated to the
   appropriate subscribers. The replicated data can be reduced by using a
   <firstterm>row filter</firstterm>. A user might choose to use row filters
   for behavioral, security or performance reasons. If a published table sets a
   row filter, a row is replicated only if its data satisfies the row filter
   expression. This allows a set of tables to be partially replicated. The row
   filter is defined per table. Use a <literal>WHERE</literal> clause after the
   table name for each published table that requires data to be filtered out.
   The <literal>WHERE</literal> clause must be enclosed by parentheses. See
   <xref linkend="sql-createpublication"/> for details.
  </para>
________________________________________________________-->
  <para>
   默认情况下，所有已发布表中的所有数据都将被复制到相应的订阅者。可以通过使用<firstterm>行过滤器</firstterm>来减少复制的数据。
   用户可能出于行为、安全或性能原因选择使用行过滤器。如果已发布表设置了行过滤器，则仅当其数据满足行过滤器表达式时才复制一行。
   这允许部分复制一组表。行过滤器是针对每个表定义的。对于需要过滤数据的每个已发布表，在表名后使用<literal>WHERE</literal>子句。
   <literal>WHERE</literal>子句必须用括号括起来。有关详细信息，请参见<xref linkend="sql-createpublication"/>。
</para>
<!-- pgdoc-cn_end sig_en=742ec1f08b2b209ada4751a77b9baafe -->

  <sect2 id="logical-replication-row-filter-rules">
<!-- pgdoc-cn_start sig_en=79eb7e3cd296e3d323dae5d7c4ba8d2d sig_cn_org=854c47ce9f9adeb3a1eff79d3964b54e source=15.7 
   <title>Row Filter Rules</title>
________________________________________________________-->
   <title>行过滤规则</title>
<!-- pgdoc-cn_end sig_en=79eb7e3cd296e3d323dae5d7c4ba8d2d -->

<!-- pgdoc-cn_start sig_en=d43c696e487ec1fe8d0883e59921de53 sig_cn_org=a7c5c69c67f0fbdacf9c3c65c2dc603d source=15.7 
   <para>
    Row filters are applied <emphasis>before</emphasis> publishing the changes.
    If the row filter evaluates to <literal>false</literal> or <literal>NULL</literal>
    then the row is not replicated. The <literal>WHERE</literal> clause expression
    is evaluated with the same role used for the replication connection (i.e.
    the role specified in the <literal>CONNECTION</literal> clause of the
    <xref linkend="sql-createsubscription"/>). Row filters have no effect for
    <command>TRUNCATE</command> command.
   </para>
________________________________________________________-->
   <para>
    行过滤器在发布更改之前<emphasis>应用</emphasis>。如果行过滤器评估为<literal>false</literal>或<literal>NULL</literal>，
    则该行不会被复制。<literal>WHERE</literal>子句表达式将使用与复制连接相同的角色进行评估（即在
    <literal>CONNECTION</literal>子句中指定的角色<xref linkend="sql-createsubscription"/>）。行过滤器对
    <command>TRUNCATE</command>命令无效。
</para>
<!-- pgdoc-cn_end sig_en=d43c696e487ec1fe8d0883e59921de53 -->

  </sect2>

  <sect2 id="logical-replication-row-filter-restrictions">
<!-- pgdoc-cn_start sig_en=cf7dbef283a67c934d8eb84cb4c3b059 sig_cn_org=8e26fb40e8675b6ac83b7ed3f453d477 source=15.7 
   <title>Expression Restrictions</title>
________________________________________________________-->
   <title>表达式限制</title>
<!-- pgdoc-cn_end sig_en=cf7dbef283a67c934d8eb84cb4c3b059 -->

<!-- pgdoc-cn_start sig_en=53f90d96043980f4fe3d733737e926ef sig_cn_org=2e64e39ea63808b64546e712d223133a source=15.7 
   <para>
    The <literal>WHERE</literal> clause allows only simple expressions. It
    cannot contain user-defined functions, operators, types, and collations,
    system column references or non-immutable built-in functions.
   </para>
________________________________________________________-->
   <para>
    <literal>WHERE</literal>子句只允许简单表达式。它不能包含用户定义的函数、操作符、类型和排序规则、系统列引用或非不可变内置函数。
   </para>
<!-- pgdoc-cn_end sig_en=53f90d96043980f4fe3d733737e926ef -->

<!-- pgdoc-cn_start sig_en=1fc26922be03896abdd53385c150f705 sig_cn_org=4961964b726fcf1a02642c55c7af20f8 source=15.7 
   <para>
    If a publication publishes <command>UPDATE</command> or
    <command>DELETE</command> operations, the row filter <literal>WHERE</literal>
    clause must contain only columns that are covered by the replica identity
    (see <xref linkend="sql-altertable-replica-identity"/>). If a publication
    publishes only <command>INSERT</command> operations, the row filter
    <literal>WHERE</literal> clause can use any column.
   </para>
________________________________________________________-->
   <para>
    如果一个发布包含<command>UPDATE</command>或<command>DELETE</command>操作的出版物，
    行过滤器<literal>WHERE</literal>子句必须只包含副本标识覆盖的列
    (参见<xref linkend="sql-altertable-replica-identity"/>)。如果一个发布仅发布
    <command>INSERT</command>操作，行过滤器<literal>WHERE</literal>子句可以使用任何列。
</para>
<!-- pgdoc-cn_end sig_en=1fc26922be03896abdd53385c150f705 -->

  </sect2>

  <sect2 id="logical-replication-row-filter-transformations">
<!-- pgdoc-cn_start sig_en=45b05795566a06c6e2ad255df8b5b37e sig_cn_org=fe0f3658db2e75b478531199d4f59a8e source=15.7 
   <title>UPDATE Transformations</title>
________________________________________________________-->
   <title>更新转换</title>
<!-- pgdoc-cn_end sig_en=45b05795566a06c6e2ad255df8b5b37e -->

<!-- pgdoc-cn_start sig_en=37821aab21521b5840e51c9074964f22 sig_cn_org=4e580686b7929346acc728c3bba53057 source=15.7 
   <para>
    Whenever an <command>UPDATE</command> is processed, the row filter
    expression is evaluated for both the old and new row (i.e. using the data
    before and after the update). If both evaluations are <literal>true</literal>,
    it replicates the <command>UPDATE</command> change. If both evaluations are
    <literal>false</literal>, it doesn't replicate the change. If only one of
    the old/new rows matches the row filter expression, the <command>UPDATE</command>
    is transformed to <command>INSERT</command> or <command>DELETE</command>, to
    avoid any data inconsistency. The row on the subscriber should reflect what
    is defined by the row filter expression on the publisher.
   </para>
________________________________________________________-->
   <para>
    每当处理<command>UPDATE</command>时，都会对旧行和新行的行过滤表达式进行评估（即使用更新前和更新后的数据）。
    如果两次评估都为<literal>true</literal>，则复制<command>UPDATE</command>更改。
    如果两次评估都为<literal>false</literal>，则不复制更改。
    如果旧行/新行中只有一个与行过滤表达式匹配，则将<command>UPDATE</command>转换为<command>INSERT</command>或<command>DELETE</command>，
    以避免任何数据不一致。订阅者上的行应反映发布者上行过滤表达式定义的内容。
</para>
<!-- pgdoc-cn_end sig_en=37821aab21521b5840e51c9074964f22 -->

<!-- pgdoc-cn_start sig_en=4fc8403d4bc31f950dddc9c8a5f72087 sig_cn_org=1c14bae6a07fba89a1187a33624ee599 source=15.7 
   <para>
    If the old row satisfies the row filter expression (it was sent to the
    subscriber) but the new row doesn't, then, from a data consistency
    perspective the old row should be removed from the subscriber.
    So the <command>UPDATE</command> is transformed into a <command>DELETE</command>.
   </para>
________________________________________________________-->
   <para>
    如果旧行满足行过滤表达式（已发送给订阅者），但新行不满足，则从数据一致性的角度来看，
    应该从订阅者中删除旧行。因此<command>UPDATE</command>被转换为<command>DELETE</command>。
</para>
<!-- pgdoc-cn_end sig_en=4fc8403d4bc31f950dddc9c8a5f72087 -->

<!-- pgdoc-cn_start sig_en=f504b96bdd4643ff573ac5b57c08fa1f sig_cn_org=af97d3c74f8f54a16db39be760da79b2 source=15.7 
   <para>
    If the old row doesn't satisfy the row filter expression (it wasn't sent
    to the subscriber) but the new row does, then, from a data consistency
    perspective the new row should be added to the subscriber.
    So the <command>UPDATE</command> is transformed into an <command>INSERT</command>.
   </para>
________________________________________________________-->
   <para>
    如果旧行不满足行过滤表达式（它没有发送给订阅者），但新行满足，则从数据一致性的角度来看，
    应将新行添加到订阅者。
    因此，<command>UPDATE</command>被转换为<command>INSERT</command>。
</para>
<!-- pgdoc-cn_end sig_en=f504b96bdd4643ff573ac5b57c08fa1f -->

<!-- pgdoc-cn_start sig_en=7e9ef116ee33295a9cfb9c7e4590a331 sig_cn_org=d7f342314bd7d699622d55d632da004e source=15.7 
   <para>
    <xref linkend="logical-replication-row-filter-transformations-summary"/>
    summarizes the applied transformations.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="logical-replication-row-filter-transformations-summary"/>
    总结了应用的转换。
   </para>
<!-- pgdoc-cn_end sig_en=7e9ef116ee33295a9cfb9c7e4590a331 -->

   <table id="logical-replication-row-filter-transformations-summary">
<!-- pgdoc-cn_start sig_en=7476b2a01fe1d7107ccf5495e54ba935 sig_cn_org=23ed2dd66a716e48ede850c28b6637bf source=15.7 
    <title><command>UPDATE</command> Transformation Summary</title>
________________________________________________________-->
    <title><command>UPDATE</command> 转换摘要</title>
<!-- pgdoc-cn_end sig_en=7476b2a01fe1d7107ccf5495e54ba935 -->
    <tgroup cols="3">
    <thead>
<!-- pgdoc-cn_start sig_en=87cb87ed561c7c835168e05c55aba121 sig_cn_org=6de5061357e6918a80f6556200fac3c0 source=15.7 
     <row>
      <entry>Old row</entry><entry>New row</entry><entry>Transformation</entry>
     </row>
________________________________________________________-->
     <row>
      <entry>旧行</entry><entry>新行</entry><entry>转换</entry>
     </row>
<!-- pgdoc-cn_end sig_en=87cb87ed561c7c835168e05c55aba121 -->
    </thead>
    <tbody>
<!-- pgdoc-cn_start sig_en=2f58470726d4efc209848b85f1b747b9 sig_cn_org=400bfab3b7ce045c8979c50e149ff913 source=15.7 
     <row>
      <entry>no match</entry><entry>no match</entry><entry>don't replicate</entry>
     </row>
________________________________________________________-->
     <row>
      <entry>无匹配</entry><entry>无匹配</entry><entry>不复制</entry>
     </row>
<!-- pgdoc-cn_end sig_en=2f58470726d4efc209848b85f1b747b9 -->
<!-- pgdoc-cn_start sig_en=3198f3097675d4643df0711f8ba24310 sig_cn_org=5c3899fadf340083462c649b4b9666d6 source=15.7 
     <row>
      <entry>no match</entry><entry>match</entry><entry><literal>INSERT</literal></entry>
     </row>
________________________________________________________-->
     <row>
      <entry>不匹配</entry><entry>匹配</entry><entry><literal>INSERT</literal></entry>
     </row>
<!-- pgdoc-cn_end sig_en=3198f3097675d4643df0711f8ba24310 -->
<!-- pgdoc-cn_start sig_en=774e024da70461389bf77fe2df071f55 sig_cn_org=e9bfa051a06ebde0dd137be0b78b91ea source=15.7 
     <row>
      <entry>match</entry><entry>no match</entry><entry><literal>DELETE</literal></entry>
     </row>
________________________________________________________-->
     <row>
      <entry>匹配</entry><entry>不匹配</entry><entry><literal>DELETE</literal></entry>
     </row>
<!-- pgdoc-cn_end sig_en=774e024da70461389bf77fe2df071f55 -->
<!-- pgdoc-cn_start sig_en=96b9ccd2d67c3ae7081f1dcee9fa2b4d sig_cn_org=9e1bc7f0a53611d4920cefb62e50daaa source=15.7 
     <row>
      <entry>match</entry><entry>match</entry><entry><literal>UPDATE</literal></entry>
     </row>
________________________________________________________-->
     <row>
      <entry>匹配</entry><entry>匹配</entry><entry><literal>更新</literal></entry>
     </row>
<!-- pgdoc-cn_end sig_en=96b9ccd2d67c3ae7081f1dcee9fa2b4d -->
    </tbody>
   </tgroup>
   </table>

  </sect2>

  <sect2 id="logical-replication-row-filter-partitioned-table">
<!-- pgdoc-cn_start sig_en=2c718250dacf7e3cfbbe022e9a447deb sig_cn_org=25dd7b22c8c8987a8a82e4740e909cb5 source=15.7 
   <title>Partitioned Tables</title>
________________________________________________________-->
   <title>分区表</title>
<!-- pgdoc-cn_end sig_en=2c718250dacf7e3cfbbe022e9a447deb -->

<!-- pgdoc-cn_start sig_en=6c8331de5a1d005b478623665d61cc67 sig_cn_org=4aa612a9fcde90df4716302a8dfc2c7d source=15.7 
   <para>
    If the publication contains a partitioned table, the publication parameter
    <literal>publish_via_partition_root</literal> determines which row filter
    is used. If <literal>publish_via_partition_root</literal> is <literal>true</literal>,
    the <emphasis>root partitioned table's</emphasis> row filter is used. Otherwise,
    if <literal>publish_via_partition_root</literal> is <literal>false</literal>
    (default), each <emphasis>partition's</emphasis> row filter is used.
   </para>
________________________________________________________-->
   <para>
    如果出版物包含分区表，则出版参数<literal>publish_via_partition_root</literal>确定使用哪个行过滤器。
    如果<literal>publish_via_partition_root</literal>为<literal>true</literal>，则使用<emphasis>根分区表</emphasis>的行过滤器。
    否则，如果<literal>publish_via_partition_root</literal>为<literal>false</literal>（默认情况下），则使用每个<emphasis>分区</emphasis>的行过滤器。
</para>
<!-- pgdoc-cn_end sig_en=6c8331de5a1d005b478623665d61cc67 -->

  </sect2>

  <sect2 id="logical-replication-row-filter-initial-data-sync">
<!-- pgdoc-cn_start sig_en=856bd74abc1295d9f1102808c7be6bd6 sig_cn_org=5dafc6317a3036d9b15a1d74291654f0 source=15.7 
   <title>Initial Data Synchronization</title>
________________________________________________________-->
   <title>初始数据同步</title>
<!-- pgdoc-cn_end sig_en=856bd74abc1295d9f1102808c7be6bd6 -->

<!-- pgdoc-cn_start sig_en=da605d1e119b7abfb780de312f5576a6 sig_cn_org=02a5920ff1cba7d8903b07c841923162 source=15.7 
   <para>
    If the subscription requires copying pre-existing table data
    and a publication contains <literal>WHERE</literal> clauses, only data that
    satisfies the row filter expressions is copied to the subscriber.
   </para>
________________________________________________________-->
   <para>
    如果订阅需要复制预先存在的表数据，并且发布包含<literal>WHERE</literal>子句，
    则只有满足行过滤表达式的数据才会被复制到订阅者。
</para>
<!-- pgdoc-cn_end sig_en=da605d1e119b7abfb780de312f5576a6 -->

<!-- pgdoc-cn_start sig_en=10e32cecc59b5d4c4d9861b7bceb4eb9 sig_cn_org=28420f5baaf9f108f94796d3fd9573cf source=15.7 
   <para>
    If the subscription has several publications in which a table has been
    published with different <literal>WHERE</literal> clauses, rows that satisfy
    <emphasis>any</emphasis> of the expressions will be copied. See
    <xref linkend="logical-replication-row-filter-combining"/> for details.
   </para>
________________________________________________________-->
   <para>
    如果订阅中有几个出版物发布了带有不同<literal>WHERE</literal>子句的表，满足<emphasis>任何</emphasis>表达式的行将被复制。
    有关详细信息，请参见<xref linkend="logical-replication-row-filter-combining"/>。
</para>
<!-- pgdoc-cn_end sig_en=10e32cecc59b5d4c4d9861b7bceb4eb9 -->

   <warning>
<!-- pgdoc-cn_start sig_en=fee2eeeb1b4ec37e838b1b58563ac24f sig_cn_org=220ff6858c885c03fb8cb4e1dc9588d2 source=15.7 
    <para>
     Because initial data synchronization does not take into account the
     <literal>publish</literal> parameter when copying existing table data,
     some rows may be copied that would not be replicated using DML. Refer to
     <xref linkend="logical-replication-snapshot"/>, and see
     <xref linkend="logical-replication-subscription-examples"/> for examples.
    </para>
________________________________________________________-->
    <para>
     由于初始数据同步在复制现有表数据时不考虑<literal>publish</literal>参数，
     可能会复制一些不使用DML进行复制的行。参考<xref linkend="logical-replication-snapshot"/>，
     并查看<xref linkend="logical-replication-subscription-examples"/>中的示例。
</para>
<!-- pgdoc-cn_end sig_en=fee2eeeb1b4ec37e838b1b58563ac24f -->
   </warning>

   <note>
<!-- pgdoc-cn_start sig_en=6baa8fe1440af7af3500681c89321a17 sig_cn_org=00bbad5bc9200262928750f5e06a3cb9 source=15.7 
    <para>
     If the subscriber is in a release prior to 15, copy pre-existing data
     doesn't use row filters even if they are defined in the publication.
     This is because old releases can only copy the entire table data.
    </para>
________________________________________________________-->
    <para>
     如果订阅者使用的是早于15版本的发布版，即使在发布中定义了行过滤器，复制预先存在的数据也不会使用行过滤器。
     这是因为旧版本只能复制整个表的数据。
</para>
<!-- pgdoc-cn_end sig_en=6baa8fe1440af7af3500681c89321a17 -->
   </note>

  </sect2>

  <sect2 id="logical-replication-row-filter-combining">
<!-- pgdoc-cn_start sig_en=5a6eb774f3cc81d59ced038742cc096f sig_cn_org=cf66f2756ce9dc72b1cd522451b85b75 source=15.7 
   <title>Combining Multiple Row Filters</title>
________________________________________________________-->
   <title>组合多行过滤器</title>
<!-- pgdoc-cn_end sig_en=5a6eb774f3cc81d59ced038742cc096f -->

<!-- pgdoc-cn_start sig_en=3f6f1ddde672deb8e6b1a8c74d4608c0 sig_cn_org=a2771e68436d01b8a0c3eb4b0e7b5d14 source=15.7 
   <para>
    If the subscription has several publications in which the same table has
    been published with different row filters (for the same <literal>publish</literal>
    operation), those expressions get ORed together, so that rows satisfying
    <emphasis>any</emphasis> of the expressions will be replicated. This means all
    the other row filters for the same table become redundant if:
    <itemizedlist>
     <listitem>
      <para>
       One of the publications has no row filter.
      </para>
     </listitem>
     <listitem>
      <para>
       One of the publications was created using <literal>FOR ALL TABLES</literal>.
       This clause does not allow row filters.
      </para>
     </listitem>
     <listitem>
      <para>
       One of the publications was created using
       <literal>FOR TABLES IN SCHEMA</literal> and the table belongs to
       the referred schema. This clause does not allow row filters.
      </para>
     </listitem>
    </itemizedlist></para>
________________________________________________________-->
   <para>
    如果订阅中有几个出版物在其中相同的表以不同的行过滤器（对于相同的<literal>publish</literal>操作）中发布，
    那些表达式将被OR在一起，这样满足<emphasis>任何</emphasis>表达式的行将被复制。这意味着如果同一表的所有其他行过滤器变得多余，那么：
    <itemizedlist>
     <listitem>
      <para>
       其中一个出版物没有行过滤器。
      </para>
     </listitem>
     <listitem>
      <para>
       其中一个出版物是使用<literal>FOR ALL TABLES</literal>创建的。此子句不允许行过滤器。
      </para>
     </listitem>
     <listitem>
      <para>
       其中一个出版物是使用<literal>FOR TABLES IN SCHEMA</literal>创建的，并且该表属于引用的模式。此子句不允许行过滤器。
      </para>
     </listitem>
    </itemizedlist>
</para>
<!-- pgdoc-cn_end sig_en=3f6f1ddde672deb8e6b1a8c74d4608c0 -->

  </sect2>

  <sect2 id="logical-replication-row-filter-examples">
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
   <title>Examples</title>
________________________________________________________-->
   <title>例子</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=c43318879562fb1d427474df2ffaeb58 sig_cn_org=17daa5483c8a4c69629d574d65f8057e source=15.7 
   <para>
    Create some tables to be used in the following examples.
<programlisting>
test_pub=# CREATE TABLE t1(a int, b int, c text, PRIMARY KEY(a,c));
CREATE TABLE
test_pub=# CREATE TABLE t2(d int, e int, f int, PRIMARY KEY(d));
CREATE TABLE
test_pub=# CREATE TABLE t3(g int, h int, i int, PRIMARY KEY(g));
CREATE TABLE
</programlisting></para>
________________________________________________________-->
   <para>
    创建一些表，用于后续的示例。
<programlisting>
test_pub=# 创建表 t1(a int, b int, c text, PRIMARY KEY(a,c));
CREATE TABLE
test_pub=# 创建表 t2(d int, e int, f int, PRIMARY KEY(d));
CREATE TABLE
test_pub=# 创建表 t3(g int, h int, i int, PRIMARY KEY(g));
CREATE TABLE
</programlisting></para>
<!-- pgdoc-cn_end sig_en=c43318879562fb1d427474df2ffaeb58 -->

<!-- pgdoc-cn_start sig_en=6d6fb1ef3abe6b4f0ca8131e2bcf4e81 sig_cn_org=d0e7767ec0f28d4f85717bb61439ccd3 source=15.7 
   <para>
    Create some publications. Publication <literal>p1</literal> has one table
    (<literal>t1</literal>) and that table has a row filter. Publication
    <literal>p2</literal> has two tables. Table <literal>t1</literal> has no row
    filter, and table <literal>t2</literal> has a row filter. Publication
    <literal>p3</literal> has two tables, and both of them have a row filter.
<programlisting>
test_pub=# CREATE PUBLICATION p1 FOR TABLE t1 WHERE (a > 5 AND c = 'NSW');
CREATE PUBLICATION
test_pub=# CREATE PUBLICATION p2 FOR TABLE t1, t2 WHERE (e = 99);
CREATE PUBLICATION
test_pub=# CREATE PUBLICATION p3 FOR TABLE t2 WHERE (d = 10), t3 WHERE (g = 10);
CREATE PUBLICATION
</programlisting></para>
________________________________________________________-->
   <para>
    创建一些出版物。出版物<literal>p1</literal>有一个表(<literal>t1</literal>)，该表有一个行过滤器。
    出版物<literal>p2</literal>有两个表。表<literal>t1</literal>没有行过滤器，表<literal>t2</literal>有一个行过滤器。
    出版物<literal>p3</literal>有两个表，它们都有一个行过滤器。
<programlisting>
test_pub=# 为表t1创建出版物p1，条件为(a > 5 AND c = 'NSW');
CREATE PUBLICATION
test_pub=# 为表t1、t2创建出版物p2，条件为(e = 99);
CREATE PUBLICATION
test_pub=# 为表t2创建出版物p3，条件为(d = 10)，为表t3创建出版物，条件为(g = 10);
CREATE PUBLICATION
</programlisting></para>
<!-- pgdoc-cn_end sig_en=6d6fb1ef3abe6b4f0ca8131e2bcf4e81 -->

<!-- pgdoc-cn_start sig_en=db07371c15f5a98ccce22114efecc16f sig_cn_org=456e6d9e8a4319a0325ecd5d585803de source=15.7 
   <para>
    <command>psql</command> can be used to show the row filter expressions (if
    defined) for each publication.
<programlisting>
test_pub=# \dRp+
                               Publication p1
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.t1" WHERE ((a > 5) AND (c = 'NSW'::text))

                               Publication p2
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.t1"
    "public.t2" WHERE (e = 99)

                               Publication p3
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.t2" WHERE (d = 10)
    "public.t3" WHERE (g = 10)
</programlisting></para>
________________________________________________________-->
   <para>
    <command>psql</command>可以用来显示每个发布的行过滤表达式（如果已定义）。
<programlisting>
test_pub=# \dRp+
                               发布 p1
  所有者   | 所有表 | 插入 | 更新 | 删除 | 截断 | 通过根
----------+--------+-----+-----+-----+-----+------
 postgres | f      | t   | t   | t   | t   | f
表:
    "public.t1" WHERE ((a > 5) AND (c = 'NSW'::text))

                               发布 p2
  所有者   | 所有表 | 插入 | 更新 | 删除 | 截断 | 通过根
----------+--------+-----+-----+-----+-----+------
 postgres | f      | t   | t   | t   | t   | f
表:
    "public.t1"
    "public.t2" WHERE (e = 99)

                               发布 p3
  所有者   | 所有表 | 插入 | 更新 | 删除 | 截断 | 通过根
----------+--------+-----+-----+-----+-----+------
 postgres | f      | t   | t   | t   | t   | f
表:
    "public.t2" WHERE (d = 10)
    "public.t3" WHERE (g = 10)
</programlisting></para>
<!-- pgdoc-cn_end sig_en=db07371c15f5a98ccce22114efecc16f -->

<!-- pgdoc-cn_start sig_en=ef8a874b35c09515d9726204aa84e0a6 sig_cn_org=86b763d556525a6de63ef17637223a3b source=15.7 
   <para>
    <command>psql</command> can be used to show the row filter expressions (if
    defined) for each table. See that table <literal>t1</literal> is a member
    of two publications, but has a row filter only in <literal>p1</literal>.
    See that table <literal>t2</literal> is a member of two publications, and
    has a different row filter in each of them.
<programlisting>
test_pub=# \d t1
                 Table "public.t1"
 Column |  Type   | Collation | Nullable | Default
-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-
 a      | integer |           | not null |
 b      | integer |           |          |
 c      | text    |           | not null |
Indexes:
    "t1_pkey" PRIMARY KEY, btree (a, c)
Publications:
    "p1" WHERE ((a > 5) AND (c = 'NSW'::text))
    "p2"

test_pub=# \d t2
                 Table "public.t2"
 Column |  Type   | Collation | Nullable | Default
-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-
 d      | integer |           | not null |
 e      | integer |           |          |
 f      | integer |           |          |
Indexes:
    "t2_pkey" PRIMARY KEY, btree (d)
Publications:
    "p2" WHERE (e = 99)
    "p3" WHERE (d = 10)

test_pub=# \d t3
                 Table "public.t3"
 Column |  Type   | Collation | Nullable | Default
-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-
 g      | integer |           | not null |
 h      | integer |           |          |
 i      | integer |           |          |
Indexes:
    "t3_pkey" PRIMARY KEY, btree (g)
Publications:
    "p3" WHERE (g = 10)
</programlisting></para>
________________________________________________________-->
   <para>
    <command>psql</command>可以用来显示每个表的行过滤表达式（如果定义了）。查看表<literal>t1</literal>是两个发布物的成员，
    但只在<literal>p1</literal>中有行过滤。查看表<literal>t2</literal>是两个发布物的成员，并且在每个发布物中有不同的行过滤。
<programlisting>
test_pub=# \d t1
                 Table "public.t1"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 a      | integer |           | not null |
 b      | integer |           |          |
 c      | text    |           | not null |
Indexes:
    "t1_pkey" PRIMARY KEY, btree (a, c)
Publications:
    "p1" WHERE ((a > 5) AND (c = 'NSW'::text))
    "p2"

test_pub=# \d t2
                 Table "public.t2"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 d      | integer |           | not null |
 e      | integer |           |          |
 f      | integer |           |          |
Indexes:
    "t2_pkey" PRIMARY KEY, btree (d)
Publications:
    "p2" WHERE (e = 99)
    "p3" WHERE (d = 10)

test_pub=# \d t3
                 Table "public.t3"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 g      | integer |           | not null |
 h      | integer |           |          |
 i      | integer |           |          |
Indexes:
    "t3_pkey" PRIMARY KEY, btree (g)
Publications:
    "p3" WHERE (g = 10)
</programlisting></para>
<!-- pgdoc-cn_end sig_en=ef8a874b35c09515d9726204aa84e0a6 -->

<!-- pgdoc-cn_start sig_en=2da77790201efb91602c1033c4df0c0e sig_cn_org=f328398df97ce6c4deb736ed0ffd0050 source=15.7 
   <para>
    On the subscriber node, create a table <literal>t1</literal> with the same
    definition as the one on the publisher, and also create the subscription
    <literal>s1</literal> that subscribes to the publication <literal>p1</literal>.
<programlisting>
test_sub=# CREATE TABLE t1(a int, b int, c text, PRIMARY KEY(a,c));
CREATE TABLE
test_sub=# CREATE SUBSCRIPTION s1
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=s1'
test_sub-# PUBLICATION p1;
CREATE SUBSCRIPTION
</programlisting></para>
________________________________________________________-->
   <para>
    在订阅节点上，创建一个与发布者上相同定义的表<literal>t1</literal>，并创建订阅<literal>s1</literal>，
    该订阅订阅了发布<literal>p1</literal>。
<programlisting>
test_sub=# CREATE TABLE t1(a int, b int, c text, PRIMARY KEY(a,c));
CREATE TABLE
test_sub=# CREATE SUBSCRIPTION s1
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=s1'
test_sub-# PUBLICATION p1;
CREATE SUBSCRIPTION
</programlisting></para>
<!-- pgdoc-cn_end sig_en=2da77790201efb91602c1033c4df0c0e -->

<!-- pgdoc-cn_start sig_en=4edac74f92416a8d26fbf0f9f3b7e1d8 sig_cn_org=443ae7a158098b7f38e88c3a586703ea source=15.7 
   <para>
    Insert some rows. Only the rows satisfying the <literal>t1 WHERE</literal>
    clause of publication <literal>p1</literal> are replicated.
<programlisting>
test_pub=# INSERT INTO t1 VALUES (2, 102, 'NSW');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (3, 103, 'QLD');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (4, 104, 'VIC');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (5, 105, 'ACT');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (6, 106, 'NSW');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (7, 107, 'NT');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (8, 108, 'QLD');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (9, 109, 'NSW');
INSERT 0 1

test_pub=# SELECT * FROM t1;
 a |  b  |  c
-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-
 2 | 102 | NSW
 3 | 103 | QLD
 4 | 104 | VIC
 5 | 105 | ACT
 6 | 106 | NSW
 7 | 107 | NT
 8 | 108 | QLD
 9 | 109 | NSW
(8 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM t1;
 a |  b  |  c
-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-
 6 | 106 | NSW
 9 | 109 | NSW
(2 rows)
</programlisting></para>
________________________________________________________-->
   <para>
    插入一些行。只有满足<literal>p1</literal>出版物的<literal>t1 WHERE</literal>子句的行会被复制。
<programlisting>
test_pub=# INSERT INTO t1 VALUES (2, 102, 'NSW');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (3, 103, 'QLD');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (4, 104, 'VIC');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (5, 105, 'ACT');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (6, 106, 'NSW');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (7, 107, 'NT');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (8, 108, 'QLD');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES (9, 109, 'NSW');
INSERT 0 1

test_pub=# SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 2 | 102 | NSW
 3 | 103 | QLD
 4 | 104 | VIC
 5 | 105 | ACT
 6 | 106 | NSW
 7 | 107 | NT
 8 | 108 | QLD
 9 | 109 | NSW
(8 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 6 | 106 | NSW
 9 | 109 | NSW
(2 rows)
</programlisting></para>
<!-- pgdoc-cn_end sig_en=4edac74f92416a8d26fbf0f9f3b7e1d8 -->

<!-- pgdoc-cn_start sig_en=e64a9ceb968833df56d1f07fc8fccd08 sig_cn_org=15e29edc72e38ca96e09cadb7ae0acee source=15.7 
   <para>
    Update some data, where the old and new row values both
    satisfy the <literal>t1 WHERE</literal> clause of publication
    <literal>p1</literal>. The <command>UPDATE</command> replicates
    the change as normal.
<programlisting>
test_pub=# UPDATE t1 SET b = 999 WHERE a = 6;
UPDATE 1

test_pub=# SELECT * FROM t1;
 a |  b  |  c
-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-
 2 | 102 | NSW
 3 | 103 | QLD
 4 | 104 | VIC
 5 | 105 | ACT
 7 | 107 | NT
 8 | 108 | QLD
 9 | 109 | NSW
 6 | 999 | NSW
(8 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM t1;
 a |  b  |  c
-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-
 9 | 109 | NSW
 6 | 999 | NSW
(2 rows)
</programlisting></para>
________________________________________________________-->
   <para>
    更新一些数据，其中旧行和新行的值都满足发布<literal>p1</literal>的<literal>t1 WHERE</literal>子句。
    <command>UPDATE</command>会像平常一样复制更改。
<programlisting>
test_pub=# UPDATE t1 SET b = 999 WHERE a = 6;
UPDATE 1

test_pub=# SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 2 | 102 | NSW
 3 | 103 | QLD
 4 | 104 | VIC
 5 | 105 | ACT
 7 | 107 | NT
 8 | 108 | QLD
 9 | 109 | NSW
 6 | 999 | NSW
(8 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM t1;
 a |  b  |  c
---+-----+-----
 9 | 109 | NSW
 6 | 999 | NSW
(2 rows)
</programlisting></para>
<!-- pgdoc-cn_end sig_en=e64a9ceb968833df56d1f07fc8fccd08 -->

<!-- pgdoc-cn_start sig_en=34c168ec72931826c95acd8ca90851d9 sig_cn_org=a5d1178aad9efeaeaee725fcc527e7c8 source=15.7 
   <para>
    Update some data, where the old row values did not satisfy
    the <literal>t1 WHERE</literal> clause of publication <literal>p1</literal>,
    but the new row values do satisfy it. The <command>UPDATE</command> is
    transformed into an <command>INSERT</command> and the change is replicated.
    See the new row on the subscriber.
<programlisting>
test_pub=# UPDATE t1 SET a = 555 WHERE a = 2;
UPDATE 1

test_pub=# SELECT * FROM t1;
  a  |  b  |  c
-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-
   3 | 103 | QLD
   4 | 104 | VIC
   5 | 105 | ACT
   7 | 107 | NT
   8 | 108 | QLD
   9 | 109 | NSW
   6 | 999 | NSW
 555 | 102 | NSW
(8 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM t1;
  a  |  b  |  c
-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-
   9 | 109 | NSW
   6 | 999 | NSW
 555 | 102 | NSW
(3 rows)
</programlisting></para>
________________________________________________________-->
   <para>
    更新一些数据，其中旧行的值不满足发布<literal>p1</literal>的<literal>t1 WHERE</literal>子句的条件，
    但新行的值确实满足。 <command>UPDATE</command> 被转换为 <command>INSERT</command> 并进行复制。
    在订阅者处查看新行。
<programlisting>
test_pub=# UPDATE t1 SET a = 555 WHERE a = 2;
UPDATE 1

test_pub=# SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   3 | 103 | QLD
   4 | 104 | VIC
   5 | 105 | ACT
   7 | 107 | NT
   8 | 108 | QLD
   9 | 109 | NSW
   6 | 999 | NSW
 555 | 102 | NSW
(8 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   9 | 109 | NSW
   6 | 999 | NSW
 555 | 102 | NSW
(3 rows)
</programlisting></para>
<!-- pgdoc-cn_end sig_en=34c168ec72931826c95acd8ca90851d9 -->

<!-- pgdoc-cn_start sig_en=8e067bd5cd182cf61b6319146fab8647 sig_cn_org=f9da4da7b2382aecc1b7afd1c31ad1ce source=15.7 
   <para>
    Update some data, where the old row values satisfied
    the <literal>t1 WHERE</literal> clause of publication <literal>p1</literal>,
    but the new row values do not satisfy it. The <command>UPDATE</command> is
    transformed into a <command>DELETE</command> and the change is replicated.
    See that the row is removed from the subscriber.
<programlisting>
test_pub=# UPDATE t1 SET c = 'VIC' WHERE a = 9;
UPDATE 1

test_pub=# SELECT * FROM t1;
  a  |  b  |  c
-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-
   3 | 103 | QLD
   4 | 104 | VIC
   5 | 105 | ACT
   7 | 107 | NT
   8 | 108 | QLD
   6 | 999 | NSW
 555 | 102 | NSW
   9 | 109 | VIC
(8 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM t1;
  a  |  b  |  c
-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-
   6 | 999 | NSW
 555 | 102 | NSW
(2 rows)
</programlisting></para>
________________________________________________________-->
   <para>
    更新一些数据，其中旧行的值满足<literal>t1 WHERE</literal>子句的发布<literal>p1</literal>，
    但新行的值不满足。 <command>UPDATE</command> 转换为 <command>DELETE</command> 并进行复制。
    确保行从订阅者中删除。
<programlisting>
test_pub=# UPDATE t1 SET c = 'VIC' WHERE a = 9;
UPDATE 1

test_pub=# SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   3 | 103 | QLD
   4 | 104 | VIC
   5 | 105 | ACT
   7 | 107 | NT
   8 | 108 | QLD
   6 | 999 | NSW
 555 | 102 | NSW
   9 | 109 | VIC
(8 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM t1;
  a  |  b  |  c
-----+-----+-----
   6 | 999 | NSW
 555 | 102 | NSW
(2 rows)
</programlisting></para>
<!-- pgdoc-cn_end sig_en=8e067bd5cd182cf61b6319146fab8647 -->

<!-- pgdoc-cn_start sig_en=1dfbac49e6207fc13c91f9ddeae64f66 sig_cn_org=7e5d576c5aa21a17d1e7c6692b367cf5 source=15.7 
   <para>
    The following examples show how the publication parameter
    <literal>publish_via_partition_root</literal> determines whether the row
    filter of the parent or child table will be used in the case of partitioned
    tables.
   </para>
________________________________________________________-->
   <para>
    以下示例显示了发布参数<literal>publish_via_partition_root</literal>如何确定在分区表的情况下父表或子表的行过滤器将被使用。
   </para>
<!-- pgdoc-cn_end sig_en=1dfbac49e6207fc13c91f9ddeae64f66 -->

<!-- pgdoc-cn_start sig_en=2988bc1014aba69ce96bc7832d597c85 sig_cn_org=e2809ffab078b4a1bc854cf6af7e8199 source=15.7 
   <para>
    Create a partitioned table on the publisher.
<programlisting>
test_pub=# CREATE TABLE parent(a int PRIMARY KEY) PARTITION BY RANGE(a);
CREATE TABLE
test_pub=# CREATE TABLE child PARTITION OF parent DEFAULT;
CREATE TABLE
</programlisting>
   Create the same tables on the subscriber.
<programlisting>
test_sub=# CREATE TABLE parent(a int PRIMARY KEY) PARTITION BY RANGE(a);
CREATE TABLE
test_sub=# CREATE TABLE child PARTITION OF parent DEFAULT;
CREATE TABLE
</programlisting></para>
________________________________________________________-->
   <para>
    在发布者上创建一个分区表。
<programlisting>
test_pub=# CREATE TABLE parent(a int PRIMARY KEY) PARTITION BY RANGE(a);
CREATE TABLE
test_pub=# CREATE TABLE child PARTITION OF parent DEFAULT;
CREATE TABLE
</programlisting>
   在订阅者上创建相同的表。
<programlisting>
test_sub=# CREATE TABLE parent(a int PRIMARY KEY) PARTITION BY RANGE(a);
CREATE TABLE
test_sub=# CREATE TABLE child PARTITION OF parent DEFAULT;
CREATE TABLE
</programlisting></para>
<!-- pgdoc-cn_end sig_en=2988bc1014aba69ce96bc7832d597c85 -->

<!-- pgdoc-cn_start sig_en=1c09d33e2e73357536a00727df10ded1 sig_cn_org=05b9bffcf5624b6517c13fe57b85c470 source=15.7 
   <para>
    Create a publication <literal>p4</literal>, and then subscribe to it. The
    publication parameter <literal>publish_via_partition_root</literal> is set
    as true. There are row filters defined on both the partitioned table
    (<literal>parent</literal>), and on the partition (<literal>child</literal>).
<programlisting>
test_pub=# CREATE PUBLICATION p4 FOR TABLE parent WHERE (a &lt; 5), child WHERE (a >= 5)
test_pub-# WITH (publish_via_partition_root=true);
CREATE PUBLICATION
</programlisting>
<programlisting>
test_sub=# CREATE SUBSCRIPTION s4
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=s4'
test_sub-# PUBLICATION p4;
CREATE SUBSCRIPTION
</programlisting></para>
________________________________________________________-->
   <para>
    创建一个出版物<literal>p4</literal>，然后订阅它。出版物参数<literal>publish_via_partition_root</literal>设置为true。
    在分区表(<literal>parent</literal>)和分区(<literal>child</literal>)上都定义了行过滤器。
<programlisting>
test_pub=# CREATE PUBLICATION p4 FOR TABLE parent WHERE (a &lt; 5), child WHERE (a >= 5)
test_pub-# WITH (publish_via_partition_root=true);
CREATE PUBLICATION
</programlisting>
<programlisting>
test_sub=# CREATE SUBSCRIPTION s4
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=s4'
test_sub-# PUBLICATION p4;
CREATE SUBSCRIPTION
</programlisting></para>
<!-- pgdoc-cn_end sig_en=1c09d33e2e73357536a00727df10ded1 -->

<!-- pgdoc-cn_start sig_en=ecda18670021c38e0cc5b064ad0ab5ec sig_cn_org=8a405966c637205ad53c10ade5ddfe04 source=15.7 
   <para>
    Insert some values directly into the <literal>parent</literal> and
    <literal>child</literal> tables. They replicate using the row filter of
    <literal>parent</literal> (because <literal>publish_via_partition_root</literal>
    is true).
<programlisting>
test_pub=# INSERT INTO parent VALUES (2), (4), (6);
INSERT 0 3
test_pub=# INSERT INTO child VALUES (3), (5), (7);
INSERT 0 3

test_pub=# SELECT * FROM parent ORDER BY a;
 a
-&minus;-
 2
 3
 4
 5
 6
 7
(6 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM parent ORDER BY a;
 a
-&minus;-
 2
 3
 4
(3 rows)
</programlisting></para>
________________________________________________________-->
   <para>
    直接将一些值插入<literal>parent</literal>和<literal>child</literal>表中。它们使用<literal>parent</literal>的行过滤器进行复制（因为<literal>publish_via_partition_root</literal>为true）。
<programlisting>
test_pub=# INSERT INTO parent VALUES (2), (4), (6);
INSERT 0 3
test_pub=# INSERT INTO child VALUES (3), (5), (7);
INSERT 0 3

test_pub=# SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
 5
 6
 7
(6 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
(3 rows)
</programlisting></para>
<!-- pgdoc-cn_end sig_en=ecda18670021c38e0cc5b064ad0ab5ec -->

<!-- pgdoc-cn_start sig_en=6dc8b788dcef38ab4cef9447440f3556 sig_cn_org=1ec06926909ea48bcb6ecdd13b784f2e source=15.7 
   <para>
    Repeat the same test, but with a different value for <literal>publish_via_partition_root</literal>.
    The publication parameter <literal>publish_via_partition_root</literal> is
    set as false. A row filter is defined on the partition (<literal>child</literal>).
<programlisting>
test_pub=# DROP PUBLICATION p4;
DROP PUBLICATION
test_pub=# CREATE PUBLICATION p4 FOR TABLE parent, child WHERE (a >= 5)
test_pub-# WITH (publish_via_partition_root=false);
CREATE PUBLICATION
</programlisting>
<programlisting>
test_sub=# ALTER SUBSCRIPTION s4 REFRESH PUBLICATION;
ALTER SUBSCRIPTION
</programlisting></para>
________________________________________________________-->
   <para>
    重复相同的测试，但使用不同的值<literal>publish_via_partition_root</literal>。
    发布参数<literal>publish_via_partition_root</literal>设置为false。在分区上定义了行过滤器（<literal>child</literal>）。
<programlisting>
test_pub=# DROP PUBLICATION p4;
DROP PUBLICATION
test_pub=# CREATE PUBLICATION p4 FOR TABLE parent, child WHERE (a >= 5)
test_pub-# WITH (publish_via_partition_root=false);
CREATE PUBLICATION
</programlisting>
<programlisting>
test_sub=# ALTER SUBSCRIPTION s4 REFRESH PUBLICATION;
ALTER SUBSCRIPTION
</programlisting></para>
<!-- pgdoc-cn_end sig_en=6dc8b788dcef38ab4cef9447440f3556 -->

<!-- pgdoc-cn_start sig_en=24ebf31e1857f8d352f36bca1037bceb sig_cn_org=156e5cc532515cdaf00f381b8025c955 source=15.7 
   <para>
    Do the inserts on the publisher same as before. They replicate using the
    row filter of <literal>child</literal> (because
    <literal>publish_via_partition_root</literal> is false).
<programlisting>
test_pub=# TRUNCATE parent;
TRUNCATE TABLE
test_pub=# INSERT INTO parent VALUES (2), (4), (6);
INSERT 0 3
test_pub=# INSERT INTO child VALUES (3), (5), (7);
INSERT 0 3

test_pub=# SELECT * FROM parent ORDER BY a;
 a
-&minus;-
 2
 3
 4
 5
 6
 7
(6 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM child ORDER BY a;
 a
-&minus;-
 5
 6
 7
(3 rows)
</programlisting></para>
________________________________________________________-->
   <para>
    在发布者上执行与之前相同的插入操作。它们使用<literal>child</literal>的行过滤器（因为<literal>publish_via_partition_root</literal>为false）。
<programlisting>
test_pub=# TRUNCATE parent;
TRUNCATE TABLE
test_pub=# INSERT INTO parent VALUES (2), (4), (6);
INSERT 0 3
test_pub=# INSERT INTO child VALUES (3), (5), (7);
INSERT 0 3

test_pub=# SELECT * FROM parent ORDER BY a;
 a
---
 2
 3
 4
 5
 6
 7
(6 rows)
</programlisting>
<programlisting>
test_sub=# SELECT * FROM child ORDER BY a;
 a
---
 5
 6
 7
(3 rows)
</programlisting></para>
<!-- pgdoc-cn_end sig_en=24ebf31e1857f8d352f36bca1037bceb -->

  </sect2>

 </sect1>

 <sect1 id="logical-replication-col-lists">
<!-- pgdoc-cn_start sig_en=44fb4636b62a6b929e55db4dd5d3087c sig_cn_org=4d9009f6fee51b2088b5b03fe1e5d4ee source=15.7 
  <title>Column Lists</title>
________________________________________________________-->
  <title>列列表</title>
<!-- pgdoc-cn_end sig_en=44fb4636b62a6b929e55db4dd5d3087c -->

<!-- pgdoc-cn_start sig_en=8697b7a20fa193eb09cdd7a5c53b6fc8 sig_cn_org=8f6e0f4ccee8355ca6c42a6c4db9f675 source=15.7 
  <para>
   Each publication can optionally specify which columns of each table are
   replicated to subscribers. The table on the subscriber side must have at
   least all the columns that are published. If no column list is specified,
   then all columns on the publisher are replicated.
   See <xref linkend="sql-createpublication"/> for details on the syntax.
  </para>
________________________________________________________-->
  <para>
   每个发布可以选择性地指定每个表的哪些列被复制给订阅者。订阅者端的表必须至少包含所有发布的列。
   如果未指定列列表，则发布者上的所有列都会被复制。
   有关语法详细信息，请参见<xref linkend="sql-createpublication"/>。
</para>
<!-- pgdoc-cn_end sig_en=8697b7a20fa193eb09cdd7a5c53b6fc8 -->

<!-- pgdoc-cn_start sig_en=f22a6d1cf581ecf7c6aa65cc03661ca4 sig_cn_org=e5978e4c75b43acfb37cbf662cb5a16a source=15.7 
  <para>
   The choice of columns can be based on behavioral or performance reasons.
   However, do not rely on this feature for security: a malicious subscriber
   is able to obtain data from columns that are not specifically
   published.  If security is a consideration, protections can be applied
   at the publisher side.
  </para>
________________________________________________________-->
  <para>
   列的选择可以基于行为或性能原因。然而，不要依赖此功能来确保安全性：
   恶意订阅者可以从未明确发布的列中获取数据。如果安全性是一个考虑因素，
   可以在发布者端应用保护措施。
</para>
<!-- pgdoc-cn_end sig_en=f22a6d1cf581ecf7c6aa65cc03661ca4 -->

<!-- pgdoc-cn_start sig_en=ffa9b37a34d1fac781cb1348e36507d4 sig_cn_org=6d73e8f77575dc551d27ae7430fcdeaf source=15.7 
  <para>
   If no column list is specified, any columns added later are automatically
   replicated. This means that having a column list which names all columns
   is not the same as having no column list at all.
  </para>
________________________________________________________-->
  <para>
   如果没有指定列列表，则后续添加的任何列都会自动复制。这意味着列出所有列的列列表
   与根本没有列列表是不同的。
</para>
<!-- pgdoc-cn_end sig_en=ffa9b37a34d1fac781cb1348e36507d4 -->

<!-- pgdoc-cn_start sig_en=8b9e50b66b705df6ec81a9407a782d14 sig_cn_org=88afad47442d2028e7630d2ff540899a source=15.7 
  <para>
   A column list can contain only simple column references.  The order
   of columns in the list is not preserved.
  </para>
________________________________________________________-->
  <para>
   列表中只能包含简单的列引用。列表中列的顺序不会被保留。
</para>
<!-- pgdoc-cn_end sig_en=8b9e50b66b705df6ec81a9407a782d14 -->

<!-- pgdoc-cn_start sig_en=aafb04869a5abe1edcf73670993f3f9b sig_cn_org=71723faeb3dc7f7f41ddd9356265a3e1 source=15.7 
  <para>
   Specifying a column list when the publication also publishes
   <literal>FOR TABLES IN SCHEMA</literal> is not supported.
  </para>
________________________________________________________-->
  <para>
   当出版物同时发布<literal>SCHEMA中的表</literal>时，不支持指定列列表。
</para>
<!-- pgdoc-cn_end sig_en=aafb04869a5abe1edcf73670993f3f9b -->

<!-- pgdoc-cn_start sig_en=945cd7a3389c621ea47d631e680b75e3 sig_cn_org=7bb050a990036c62c8af08d7ecb0099e source=15.7 
  <para>
   For partitioned tables, the publication parameter
   <literal>publish_via_partition_root</literal> determines which column list
   is used. If <literal>publish_via_partition_root</literal> is
   <literal>true</literal>, the root partitioned table's column list is used.
   Otherwise, if <literal>publish_via_partition_root</literal> is
   <literal>false</literal> (the default), each partition's column list is used.
  </para>
________________________________________________________-->
  <para>
   对于分区表，发布参数<literal>publish_via_partition_root</literal>确定使用哪个列列表。
   如果<literal>publish_via_partition_root</literal>为<literal>true</literal>，则使用根分区表的列列表。
   否则，如果<literal>publish_via_partition_root</literal>为<literal>false</literal>（默认值），
   则使用每个分区的列列表。
</para>
<!-- pgdoc-cn_end sig_en=945cd7a3389c621ea47d631e680b75e3 -->

<!-- pgdoc-cn_start sig_en=19eecb5057ec74dd4ad818ed16ff7258 sig_cn_org=fef6ec4eea066b11541942f01f4f06be source=15.7 
  <para>
   If a publication publishes <command>UPDATE</command> or
   <command>DELETE</command> operations, any column list must include the
   table's replica identity columns (see
   <xref linkend="sql-altertable-replica-identity"/>).
   If a publication publishes only <command>INSERT</command> operations, then
   the column list may omit replica identity columns.
  </para>
________________________________________________________-->
  <para>
   如果一个发布物发布<command>UPDATE</command>或<command>DELETE</command>操作，
   任何列清单必须包括表的复制标识列（参见<xref linkend="sql-altertable-replica-identity"/>）。
   如果一个发布物只发布<command>INSERT</command>操作，那么列清单可以省略复制标识列。
</para>
<!-- pgdoc-cn_end sig_en=19eecb5057ec74dd4ad818ed16ff7258 -->

<!-- pgdoc-cn_start sig_en=6df83b4871b56a5bf62e247e5cdcaaef sig_cn_org=5ea20343b0a4bbe2fc58b1e24516c057 source=15.7 
  <para>
   Column lists have no effect for the <literal>TRUNCATE</literal> command.
  </para>
________________________________________________________-->
  <para>
   列表对<literal>TRUNCATE</literal>命令没有影响。
</para>
<!-- pgdoc-cn_end sig_en=6df83b4871b56a5bf62e247e5cdcaaef -->

<!-- pgdoc-cn_start sig_en=2b63eaf185c42c7cdbb837f1fa0d0cf3 sig_cn_org=277aed3b51a9d0c0fc8f1c534bcb26ee source=15.7 
  <para>
   During initial data synchronization, only the published columns are
   copied.  However, if the subscriber is from a release prior to 15, then
   all the columns in the table are copied during initial data synchronization,
   ignoring any column lists.
  </para>
________________________________________________________-->
  <para>
   在初始数据同步期间，只复制已发布的列。然而，如果订阅者来自15之前的版本，
   则在初始数据同步期间将复制表中的所有列，忽略任何列列表。
</para>
<!-- pgdoc-cn_end sig_en=2b63eaf185c42c7cdbb837f1fa0d0cf3 -->

   <warning id="logical-replication-col-list-combining">
<!-- pgdoc-cn_start sig_en=622e7e7482f048bd2ffb74947ad51c60 sig_cn_org=8f96343128818b2c8c88bd6da42ad067 source=15.7 
    <title>Warning: Combining Column Lists from Multiple Publications</title>
________________________________________________________-->
    <title>警告：合并来自多个出版物的列列表</title>
<!-- pgdoc-cn_end sig_en=622e7e7482f048bd2ffb74947ad51c60 -->
<!-- pgdoc-cn_start sig_en=1ea4d472e574faf596dbe8eeb99400bb sig_cn_org=ea779466702df1ada6dc705ea2958368 source=15.7 
    <para>
     There's currently no support for subscriptions comprising several
     publications where the same table has been published with different
     column lists.  <xref linkend="sql-createsubscription"/> disallows
     creating such subscriptions, but it is still possible to get into
     that situation by adding or altering column lists on the publication
     side after a subscription has been created.
    </para>
________________________________________________________-->
    <para>
     目前不支持包含多个出版物的订阅，其中同一表已使用不同列列表发布。
     <xref linkend="sql-createsubscription"/> 禁止创建这种订阅，但在创建订阅后，
     仍然可以通过在出版物端添加或更改列列表来进入该情况。
</para>
<!-- pgdoc-cn_end sig_en=1ea4d472e574faf596dbe8eeb99400bb -->
<!-- pgdoc-cn_start sig_en=7e737dd2285c5e3b1620de7ba19e2abe sig_cn_org=c456dbb7dd2fbf9c28c924cc5f2e0ac2 source=15.7 
    <para>
     This means changing the column lists of tables on publications that are
     already subscribed could lead to errors being thrown on the subscriber
     side.
    </para>
________________________________________________________-->
    <para>
     这意味着更改已经订阅的出版物上的表格列列表可能会导致订阅方出现错误。
    </para>
<!-- pgdoc-cn_end sig_en=7e737dd2285c5e3b1620de7ba19e2abe -->
<!-- pgdoc-cn_start sig_en=e17c47230c70d1528fd3c3e3d491f12e sig_cn_org=a1893feb382b4ae72645889232e8c1bb source=15.7 
    <para>
     If a subscription is affected by this problem, the only way to resume
     replication is to adjust one of the column lists on the publication
     side so that they all match; and then either recreate the subscription,
     or use <literal>ALTER SUBSCRIPTION ... DROP PUBLICATION</literal> to
     remove one of the offending publications and add it again.
    </para>
________________________________________________________-->
    <para>
     如果一个订阅受到这个问题的影响，恢复复制的唯一方法是调整出版方的一个列列表，使它们全部匹配；
     然后要么重新创建订阅，要么使用<literal>ALTER SUBSCRIPTION ... DROP PUBLICATION</literal>来
     删除一个有问题的出版物，然后再添加它。
</para>
<!-- pgdoc-cn_end sig_en=e17c47230c70d1528fd3c3e3d491f12e -->
   </warning>

  <sect2 id="logical-replication-col-list-examples">
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
   <title>Examples</title>
________________________________________________________-->
   <title>例子</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=73554dd9aeb45d4007d1dd6520481a1b sig_cn_org=051bbfddefbd693243dffc8a47b8c13d source=15.7 
   <para>
    Create a table <literal>t1</literal> to be used in the following example.
<programlisting>
test_pub=# CREATE TABLE t1(id int, a text, b text, c text, d text, e text, PRIMARY KEY(id));
CREATE TABLE
</programlisting></para>
________________________________________________________-->
   <para>
    创建一个表<literal>t1</literal>，用于以下示例。
<programlisting>
test_pub=# 创建表 t1(id int, a text, b text, c text, d text, e text, PRIMARY KEY(id));
CREATE TABLE
</programlisting></para>
<!-- pgdoc-cn_end sig_en=73554dd9aeb45d4007d1dd6520481a1b -->

<!-- pgdoc-cn_start sig_en=d8142d22803dab0688e7fe069a220993 sig_cn_org=b6fd78445cf716883b816d2fb7599ffd source=15.7 
   <para>
    Create a publication <literal>p1</literal>. A column list is defined for
    table <literal>t1</literal> to reduce the number of columns that will be
    replicated. Notice that the order of column names in the column list does
    not matter.
<programlisting>
test_pub=# CREATE PUBLICATION p1 FOR TABLE t1 (id, b, a, d);
CREATE PUBLICATION
</programlisting></para>
________________________________________________________-->
   <para>
    创建一个出版物<literal>p1</literal>。为表<literal>t1</literal>定义了一个列列表，以减少将被复制的列数。请注意，列列表中列名的顺序并不重要。
<programlisting>
test_pub=# CREATE PUBLICATION p1 FOR TABLE t1 (id, b, a, d);
CREATE PUBLICATION
</programlisting></para>
<!-- pgdoc-cn_end sig_en=d8142d22803dab0688e7fe069a220993 -->

<!-- pgdoc-cn_start sig_en=9f00bb8c58a01e26cceeb516df3a9458 sig_cn_org=49f18617ad03779c26a53d201bffc793 source=15.7 
    <para>
     <literal>psql</literal> can be used to show the column lists (if defined)
     for each publication.
<programlisting>
test_pub=# \dRp+
                               Publication p1
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.t1" (id, a, b, d)
</programlisting></para>
________________________________________________________-->
    <para>
     <literal>psql</literal>可以用来显示每个发布的列列表（如果已定义）。
<programlisting>
test_pub=# \dRp+
                               Publication p1
  Owner   | All tables | Inserts | Updates | Deletes | Truncates | Via root
----------+------------+---------+---------+---------+-----------+----------
 postgres | f          | t       | t       | t       | t         | f
Tables:
    "public.t1" (id, a, b, d)
</programlisting></para>
<!-- pgdoc-cn_end sig_en=9f00bb8c58a01e26cceeb516df3a9458 -->

<!-- pgdoc-cn_start sig_en=6d756b609add8cf1d114a5b4a328bc0f sig_cn_org=a5f62a5146ffb460b3418696fd246eec source=15.7 
    <para>
     <literal>psql</literal> can be used to show the column lists (if defined)
     for each table.
<programlisting>
test_pub=# \d t1
                 Table "public.t1"
 Column |  Type   | Collation | Nullable | Default
-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-
 id     | integer |           | not null |
 a      | text    |           |          |
 b      | text    |           |          |
 c      | text    |           |          |
 d      | text    |           |          |
 e      | text    |           |          |
Indexes:
    "t1_pkey" PRIMARY KEY, btree (id)
Publications:
    "p1" (id, a, b, d)
</programlisting></para>
________________________________________________________-->
    <para>
     <literal>psql</literal>可以用来显示每个表的列列表（如果已定义）。
<programlisting>
test_pub=# \d t1
                 表 "public.t1"
 列    |  类型   | 校对   | 可空   | 默认值
--------+---------+-----------+----------+---------
 id     | integer |           | not null |
 a      | text    |           |          |
 b      | text    |           |          |
 c      | text    |           |          |
 d      | text    |           |          |
 e      | text    |           |          |
索引:
    "t1_pkey" 主键, btree (id)
发布:
    "p1" (id, a, b, d)
</programlisting></para>
<!-- pgdoc-cn_end sig_en=6d756b609add8cf1d114a5b4a328bc0f -->

<!-- pgdoc-cn_start sig_en=51ab7de04ac6a7db0a01dc1b1e2c891a sig_cn_org=ebf096c0acd16bb39d6fc3b79d699a8b source=15.7 
    <para>
     On the subscriber node, create a table <literal>t1</literal> which now
     only needs a subset of the columns that were on the publisher table
     <literal>t1</literal>, and also create the subscription
     <literal>s1</literal> that subscribes to the publication
     <literal>p1</literal>.
<programlisting>
test_sub=# CREATE TABLE t1(id int, b text, a text, d text, PRIMARY KEY(id));
CREATE TABLE
test_sub=# CREATE SUBSCRIPTION s1
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=s1'
test_sub-# PUBLICATION p1;
CREATE SUBSCRIPTION
</programlisting></para>
________________________________________________________-->
    <para>
     在订阅节点上，创建一个名为<literal>t1</literal>的表，该表现在只需要发布者表<literal>t1</literal>上的部分列，并创建订阅<literal>s1</literal>，订阅发布<literal>p1</literal>。
<programlisting>
test_sub=# CREATE TABLE t1(id int, b text, a text, d text, PRIMARY KEY(id));
CREATE TABLE
test_sub=# CREATE SUBSCRIPTION s1
test_sub-# CONNECTION 'host=localhost dbname=test_pub application_name=s1'
test_sub-# PUBLICATION p1;
CREATE SUBSCRIPTION
</programlisting></para>
<!-- pgdoc-cn_end sig_en=51ab7de04ac6a7db0a01dc1b1e2c891a -->

<!-- pgdoc-cn_start sig_en=441a461fed7ed5c2d8a22cbdd8a8ebb1 sig_cn_org=10bc6aa9162db15e1dbfaeb4ddafe795 source=15.7 
    <para>
     On the publisher node, insert some rows to table <literal>t1</literal>.
<programlisting>
test_pub=# INSERT INTO t1 VALUES(1, 'a-1', 'b-1', 'c-1', 'd-1', 'e-1');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES(2, 'a-2', 'b-2', 'c-2', 'd-2', 'e-2');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES(3, 'a-3', 'b-3', 'c-3', 'd-3', 'e-3');
INSERT 0 1
test_pub=# SELECT * FROM t1 ORDER BY id;
 id |  a  |  b  |  c  |  d  |  e
-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-
  1 | a-1 | b-1 | c-1 | d-1 | e-1
  2 | a-2 | b-2 | c-2 | d-2 | e-2
  3 | a-3 | b-3 | c-3 | d-3 | e-3
(3 rows)
</programlisting></para>
________________________________________________________-->
    <para>
     在发布者节点上，向表<literal>t1</literal>插入一些行。
<programlisting>
test_pub=# INSERT INTO t1 VALUES(1, 'a-1', 'b-1', 'c-1', 'd-1', 'e-1');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES(2, 'a-2', 'b-2', 'c-2', 'd-2', 'e-2');
INSERT 0 1
test_pub=# INSERT INTO t1 VALUES(3, 'a-3', 'b-3', 'c-3', 'd-3', 'e-3');
INSERT 0 1
test_pub=# SELECT * FROM t1 ORDER BY id;
 id |  a  |  b  |  c  |  d  |  e
----+-----+-----+-----+-----+-----
  1 | a-1 | b-1 | c-1 | d-1 | e-1
  2 | a-2 | b-2 | c-2 | d-2 | e-2
  3 | a-3 | b-3 | c-3 | d-3 | e-3
(3 rows)
</programlisting></para>
<!-- pgdoc-cn_end sig_en=441a461fed7ed5c2d8a22cbdd8a8ebb1 -->

<!-- pgdoc-cn_start sig_en=c408c4ce9d629ae2a2d4fcad7348ecab sig_cn_org=f16c1c4ab9756a1458be942383ba3d8d source=15.7 
    <para>
     Only data from the column list of publication <literal>p1</literal> is
     replicated.
<programlisting>
test_sub=# SELECT * FROM t1 ORDER BY id;
 id |  b  |  a  |  d
-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-
  1 | b-1 | a-1 | d-1
  2 | b-2 | a-2 | d-2
  3 | b-3 | a-3 | d-3
(3 rows)
</programlisting></para>
________________________________________________________-->
    <para>
     只有来自出版物<literal>p1</literal>的列列表数据被复制。
<programlisting>
test_sub=# 从t1表按id排序选择*;
 id |  b  |  a  |  d
----+-----+-----+-----
  1 | b-1 | a-1 | d-1
  2 | b-2 | a-2 | d-2
  3 | b-3 | a-3 | d-3
(3 行)
</programlisting></para>
<!-- pgdoc-cn_end sig_en=c408c4ce9d629ae2a2d4fcad7348ecab -->

  </sect2>

 </sect1>

 <sect1 id="logical-replication-conflicts">
<!-- pgdoc-cn_start sig_en=e591fd6909facbe4e1a913e2e370e750 sig_cn_org=None source=14.1 
  <title>Conflicts</title>
________________________________________________________-->
  <title>冲突</title>
<!-- pgdoc-cn_end sig_en=e591fd6909facbe4e1a913e2e370e750 -->

<!-- pgdoc-cn_start sig_en=d33e198a0c0a1c7cb51db6074e6932b5 sig_cn_org=None source=14.1 
  <para>
   Logical replication behaves similarly to normal DML operations in that
   the data will be updated even if it was changed locally on the subscriber
   node.  If incoming data violates any constraints the replication will
   stop.  This is referred to as a <firstterm>conflict</firstterm>.  When
   replicating <command>UPDATE</command> or <command>DELETE</command>
   operations, missing data will not produce a conflict and such operations
   will simply be skipped.
  </para>
________________________________________________________-->
  <para>
   逻辑复制的行为类似于正常的DML操作，即便数据在订阅者节点本地被修改，逻辑复制也会根据收到的更改来更新数据。如果流入的数据违背了任何约束，复制将停止。这种情况被称为一个<firstterm>冲突</firstterm>。在复制<command>UPDATE</command>或<command>DELETE</command>操作时，缺失的数据将不会产生冲突并且这类操作将被简单地跳过。
  </para>
<!-- pgdoc-cn_end sig_en=d33e198a0c0a1c7cb51db6074e6932b5 -->

<!-- pgdoc-cn_start sig_en=7865d5113916cf3d93014099d0fc6071 sig_cn_org=c78e1ddb2664e0d6a975a554f17945a9 source=15.7 
  <para>
   Logical replication operations are performed with the privileges of the role
   which owns the subscription.  Permissions failures on target tables will
   cause replication conflicts, as will enabled
   <link linkend="ddl-rowsecurity">row-level security</link> on target tables
   that the subscription owner is subject to, without regard to whether any
   policy would ordinarily reject the <command>INSERT</command>,
   <command>UPDATE</command>, <command>DELETE</command> or
   <command>TRUNCATE</command> which is being replicated.  This restriction on
   row-level security may be lifted in a future version of
   <productname>PostgreSQL</productname>.
  </para>
________________________________________________________-->
  <para>
   逻辑复制操作是以拥有订阅的角色的权限执行的。目标表上的权限失败将导致复制冲突，
   同样，目标表上启用的<link linkend="ddl-rowsecurity">行级安全性</link>也会导致冲突，
   而不考虑订阅所有者是否受到任何策略通常会拒绝正在复制的<command>INSERT</command>、
   <command>UPDATE</command>、<command>DELETE</command>或<command>TRUNCATE</command>。
   对行级安全性的这种限制可能在未来版本的<productname>PostgreSQL</productname>中取消。
</para>
<!-- pgdoc-cn_end sig_en=7865d5113916cf3d93014099d0fc6071 -->

<!-- pgdoc-cn_start sig_en=c936a5a5f6fbc6308f87c8ed9308cb9a sig_cn_org=None source=14.1 
  <para>
   A conflict will produce an error and will stop the replication; it must be
   resolved manually by the user.  Details about the conflict can be found in
   the subscriber's server log.
  </para>
________________________________________________________-->
  <para>
   冲突将会产生错误并且停止复制，它必须由用户手工解决。在订阅者的服务器日志中可以找到有关冲突的详细情况。
  </para>
<!-- pgdoc-cn_end sig_en=c936a5a5f6fbc6308f87c8ed9308cb9a -->

<!-- pgdoc-cn_start sig_en=d66825112de66e251f66283fb05db3f7 sig_cn_org=38d85fbacc6abc15d940da51d75b1057 source=15.7 
  <para>
   The resolution can be done either by changing data or permissions on the subscriber so
   that it does not conflict with the incoming change or by skipping the
   transaction that conflicts with the existing data.  When a conflict produces
   an error, the replication won't proceed, and the logical replication worker will
   emit the following kind of message to the subscriber's server log:
<screen>
ERROR:  duplicate key value violates unique constraint "test_pkey"
DETAIL:  Key (c)=(1) already exists.
CONTEXT:  processing remote data for replication origin "pg_16395" during "INSERT" for replication target relation "public.test" in transaction 725 finished at 0/14C0378
</screen>
   The LSN of the transaction that contains the change violating the constraint and
   the replication origin name can be found from the server log (LSN 0/14C0378 and
   replication origin <literal>pg_16395</literal> in the above case).  The
   transaction that produced the conflict can be skipped by using
   <command>ALTER SUBSCRIPTION ... SKIP</command> with the finish LSN
   (i.e., LSN 0/14C0378).  The finish LSN could be an LSN at which the transaction
   is committed or prepared on the publisher.  Alternatively, the transaction can
   also be skipped by calling the <link linkend="pg-replication-origin-advance">
   <function>pg_replication_origin_advance()</function></link> function.
   Before using this function, the subscription needs to be disabled temporarily
   either by <command>ALTER SUBSCRIPTION ... DISABLE</command> or, the
   subscription can be used with the <literal>disable_on_error</literal> option.
   Then, you can use <function>pg_replication_origin_advance()</function> function
   with the <parameter>node_name</parameter> (i.e., <literal>pg_16395</literal>)
   and the next LSN of the finish LSN (i.e., 0/14C0379).  The current position of
   origins can be seen in the <link linkend="view-pg-replication-origin-status">
   <structname>pg_replication_origin_status</structname></link> system view.
   Please note that skipping the whole transaction includes skipping changes that
   might not violate any constraint.  This can easily make the subscriber
   inconsistent.
  </para>
________________________________________________________-->
  <para>
   解决方案可以通过更改订阅者上的数据或权限，使其与传入的更改不冲突，或者跳过与现有数据冲突的事务来完成。
   当冲突导致错误时，复制将不会继续进行，逻辑复制工作者将向订阅者的服务器日志发出以下类型的消息：
<screen>
ERROR:  duplicate key value violates unique constraint "test_pkey"
DETAIL:  Key (c)=(1) already exists.
CONTEXT:  processing remote data for replication origin "pg_16395" during "INSERT" for replication target relation "public.test" in transaction 725 finished at 0/14C0378
</screen>
   包含违反约束的更改的事务的LSN和复制源名称可以从服务器日志中找到（在上述情况中为LSN 0/14C0378和复制源<literal>pg_16395</literal>）。
   可以通过使用<command>ALTER SUBSCRIPTION ... SKIP</command>和完成LSN（即LSN 0/14C0378）来跳过产生冲突的事务。
   完成LSN可以是发布者上提交或准备的事务的LSN。另外，也可以通过调用<link linkend="pg-replication-origin-advance">
   <function>pg_replication_origin_advance()</function></link>函数来跳过事务。
   在使用此函数之前，订阅需要暂时禁用，可以通过<command>ALTER SUBSCRIPTION ... DISABLE</command>或者使用<literal>disable_on_error</literal>选项来使用订阅。
   然后，您可以使用<function>pg_replication_origin_advance()</function>函数和完成LSN的下一个LSN（即0/14C0379）来使用<parameter>node_name</parameter>（即<literal>pg_16395</literal>）。
   可以在<link linkend="view-pg-replication-origin-status">
   <structname>pg_replication_origin_status</structname></link>系统视图中查看源的当前位置。
   请注意，跳过整个事务包括跳过可能不违反任何约束的更改。这可能会使订阅者不一致。
</para>
<!-- pgdoc-cn_end sig_en=d66825112de66e251f66283fb05db3f7 -->
 </sect1>

 <sect1 id="logical-replication-restrictions">
<!-- pgdoc-cn_start sig_en=8135725c4e3bd10f6564598b2293d792 sig_cn_org=None source=14.1 
  <title>Restrictions</title>
________________________________________________________-->
  <title>限制</title>
<!-- pgdoc-cn_end sig_en=8135725c4e3bd10f6564598b2293d792 -->

<!-- pgdoc-cn_start sig_en=5bb6cb2f632907fe555e980cd58252d2 sig_cn_org=None source=14.1 
  <para>
   Logical replication currently has the following restrictions or missing
   functionality.  These might be addressed in future releases.
  </para>
________________________________________________________-->
  <para>
   逻辑复制当前有下列限制或者缺失的功能。这些可能在未来的发行中解决。
  </para>
<!-- pgdoc-cn_end sig_en=5bb6cb2f632907fe555e980cd58252d2 -->

  <itemizedlist>
   <listitem>
<!-- pgdoc-cn_start sig_en=6bde1cc1a63a70154e2ea97c037b28a0 sig_cn_org=None source=14.1 
    <para>
     The database schema and DDL commands are not replicated.  The initial
     schema can be copied by hand using <literal>pg_dump
     -&minus;schema-only</literal>.  Subsequent schema changes would need to be kept
     in sync manually.  (Note, however, that there is no need for the schemas
     to be absolutely the same on both sides.)  Logical replication is robust
     when schema definitions change in a live database: When the schema is
     changed on the publisher and replicated data starts arriving at the
     subscriber but does not fit into the table schema, replication will error
     until the schema is updated.  In many cases, intermittent errors can be
     avoided by applying additive schema changes to the subscriber first.
    </para>
________________________________________________________-->
    <para>
     数据库模式和DDL命令不会被复制。初始模式可以手工使用<literal>pg_dump --schema-only</literal>进行拷贝。后续的模式改变需要手工保持同步（不过值得注意的是，模式其实不需要在两端保持绝对相同）。当一个活跃的数据库中模式定义改变时，逻辑复制是鲁棒的：当模式在发布者上发生改变并且被复制的数据开始到达订阅者但却不适合表模式时，复制将报错，直至模式被更新。在很多情况下，可以通过先对订阅者应用额外的模式更改来避免间歇性的错误。
    </para>
<!-- pgdoc-cn_end sig_en=6bde1cc1a63a70154e2ea97c037b28a0 -->
   </listitem>

   <listitem>
<!-- pgdoc-cn_start sig_en=00617a8ee7655631e29fdf097e468a92 sig_cn_org=None source=14.1 
    <para>
     Sequence data is not replicated.  The data in serial or identity columns
     backed by sequences will of course be replicated as part of the table,
     but the sequence itself would still show the start value on the
     subscriber.  If the subscriber is used as a read-only database, then this
     should typically not be a problem.  If, however, some kind of switchover
     or failover to the subscriber database is intended, then the sequences
     would need to be updated to the latest values, either by copying the
     current data from the publisher (perhaps
     using <command>pg_dump</command>) or by determining a sufficiently high
     value from the tables themselves.
    </para>
________________________________________________________-->
    <para>
     序列数据不被复制。后台由序列支撑的serial或者标识列中的数据当然将被作为表的一部分复制，但是序列本身在订阅者上仍将显示开始值。如果订阅者被用作一个只读数据库，那么这通常不会是什么问题。不过，如果订阅者数据库预期有某种转换或者容错，那么序列需要被更新到最后的值，要么通过从发布者拷贝当前数据的防范（也许使用<command>pg_dump</command>），要么从表本身决定一个足够高的值。
    </para>
<!-- pgdoc-cn_end sig_en=00617a8ee7655631e29fdf097e468a92 -->
   </listitem>

   <listitem>
<!-- pgdoc-cn_start sig_en=bfe380582d6531e5297948a15a42b259 sig_cn_org=None source=14.1 
    <para>
     Replication of <command>TRUNCATE</command> commands is supported, but
     some care must be taken when truncating groups of tables connected by
     foreign keys.  When replicating a truncate action, the subscriber will
     truncate the same group of tables that was truncated on the publisher,
     either explicitly specified or implicitly collected via
     <literal>CASCADE</literal>, minus tables that are not part of the
     subscription.  This will work correctly if all affected tables are part
     of the same subscription.  But if some tables to be truncated on the
     subscriber have foreign-key links to tables that are not part of the same
     (or any) subscription, then the application of the truncate action on the
     subscriber will fail.
    </para>
________________________________________________________-->
    <para>
     支持<command>TRUNCATE</command>命令的复制，但是在截断由外键连接在一起的表群体时必须要小心。在复制截断动作时，订阅者将截断与发布者上被截断的相同的表群体，这些表或者被明确指定或者通过<literal>CASCADE</literal>隐含地收集而来，然后还要减去不属于该订阅的表。如果所有受影响的表都属于同一个订阅，这会正确地工作。但是如果订阅者上要被截断的某些表有外键链接到不属于同一订阅的表，那么在订阅者上该截断动作的应用将会失败。
    </para>
<!-- pgdoc-cn_end sig_en=bfe380582d6531e5297948a15a42b259 -->
   </listitem>

   <listitem>
<!-- pgdoc-cn_start sig_en=a22459427e4fdd0e575afa39df2db57f sig_cn_org=None source=14.1 
    <para>
     Large objects (see <xref linkend="largeobjects"/>) are not replicated.
     There is no workaround for that, other than storing data in normal
     tables.
    </para>
________________________________________________________-->
    <para>
     大对象（见<xref linkend="largeobjects"/>）不会被复制。没有办法可以解决这个问题，除非把数据存储在普通表中。
    </para>
<!-- pgdoc-cn_end sig_en=a22459427e4fdd0e575afa39df2db57f -->
   </listitem>

   <listitem>
<!-- pgdoc-cn_start sig_en=8c07409de332c7228e5f4f7f78ad090f sig_cn_org=None source=14.1 
    <para>
     Replication is only supported by tables, including partitioned tables.
     Attempts to replicate other types of relations, such as views, materialized
     views, or foreign tables, will result in an error.
    </para>
________________________________________________________-->
    <para>
     只有表支持复制，包括分区表。试图复制其他类型的关系，例如视图、物化视图或外部表，将会导致错误。
    </para>
<!-- pgdoc-cn_end sig_en=8c07409de332c7228e5f4f7f78ad090f -->
   </listitem>

   <listitem>
<!-- pgdoc-cn_start sig_en=b2752921fc60344f9e95a6486051f825 sig_cn_org=None source=14.1 
    <para>
     When replicating between partitioned tables, the actual replication
     originates, by default, from the leaf partitions on the publisher, so
     partitions on the publisher must also exist on the subscriber as valid
     target tables. (They could either be leaf partitions themselves, or they
     could be further subpartitioned, or they could even be independent
     tables.)  Publications can also specify that changes are to be replicated
     using the identity and schema of the partitioned root table instead of
     that of the individual leaf partitions in which the changes actually
     originate (see <link linkend="sql-createpublication"><command>CREATE PUBLICATION</command></link>).
    </para>
________________________________________________________-->
    <para>
     在分区表之间进行复制时，实际的复制来源，缺省情况下，源自发布者上的叶子分区，因此发布者上的分区也必须作为有效的目标表存在于订阅者上。
     (它们可以是叶分区本身，也可以是进一步子分区段，甚至可以是独立的表。)
     发布还可以指定使用已分区根表的标识和模式来复制更改，而不是使用实际产生更改的各个叶分区的标识和模式(参见<link linkend="sql-createpublication"><command>CREATE PUBLICATION</command></link>)。
    </para>
<!-- pgdoc-cn_end sig_en=b2752921fc60344f9e95a6486051f825 -->
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="logical-replication-architecture">
<!-- pgdoc-cn_start sig_en=2cc96edd169206f7dddea3e5152c7b30 sig_cn_org=None source=14.1 
  <title>Architecture</title>
________________________________________________________-->
  <title>架构</title>
<!-- pgdoc-cn_end sig_en=2cc96edd169206f7dddea3e5152c7b30 -->

<!-- pgdoc-cn_start sig_en=779d53ae2b1aca972104076b68fa8476 sig_cn_org=None source=14.1 
  <para>
   Logical replication starts by copying a snapshot of the data on the
   publisher database.  Once that is done, changes on the publisher are sent
   to the subscriber as they occur in real time.  The subscriber applies data
   in the order in which commits were made on the publisher so that
   transactional consistency is guaranteed for the publications within any
   single subscription.
  </para>
________________________________________________________-->
  <para>
   逻辑复制从拷贝发布者数据库上的数据库快照开始。拷贝一旦完成，发布者上的更改会在它们发生时实时传送给订阅者。订阅者按照数据在发布者上被提交的顺序应用数据，这样任意单一订阅中的发布的事务一致性才能得到保证。
  </para>
<!-- pgdoc-cn_end sig_en=779d53ae2b1aca972104076b68fa8476 -->

<!-- pgdoc-cn_start sig_en=ab77a98963810d0dc7181dcfe7cb33d6 sig_cn_org=ce8f2fa654b0971ba72cc5ac245557d5 source=15.7 
  <para>
   Logical replication is built with an architecture similar to physical
   streaming replication (see <xref linkend="streaming-replication"/>).  It is
   implemented by <quote>walsender</quote> and <quote>apply</quote>
   processes.  The walsender process starts logical decoding (described
   in <xref linkend="logicaldecoding"/>) of the WAL and loads the standard
   logical decoding output plugin (<literal>pgoutput</literal>).  The plugin
   transforms the changes read
   from WAL to the logical replication protocol
   (see <xref linkend="protocol-logical-replication"/>) and filters the data
   according to the publication specification.  The data is then continuously
   transferred using the streaming replication protocol to the apply worker,
   which maps the data to local tables and applies the individual changes as
   they are received, in correct transactional order.
  </para>
________________________________________________________-->
  <para>
   逻辑复制的架构类似于物理流复制（参见<xref linkend="streaming-replication"/>）。
   它由<quote>walsender</quote>和<quote>apply</quote>进程实现。
   walsender进程开始逻辑解码（在<xref linkend="logicaldecoding"/>中描述）WAL并加载标准逻辑解码输出插件（<literal>pgoutput</literal>）。
   插件将从WAL读取的更改转换为逻辑复制协议（参见<xref linkend="protocol-logical-replication"/>）并根据发布规范过滤数据。
   然后使用流复制协议连续传输数据到应用工作者，应用工作者将数据映射到本地表并按正确的事务顺序应用接收到的各个更改。
</para>
<!-- pgdoc-cn_end sig_en=ab77a98963810d0dc7181dcfe7cb33d6 -->

<!-- pgdoc-cn_start sig_en=1559ba678fdfc87431cbc64396b044c2 sig_cn_org=19c50bf7f90f0b62a54960da90291d60 source=15.7 
  <para>
   The apply process on the subscriber database always runs with
   <link linkend="guc-session-replication-role"><varname>session_replication_role</varname></link>
   set to <literal>replica</literal>. This means that, by default,
   triggers and rules will not fire on a subscriber. Users can optionally choose to
   enable triggers and rules on a table using the
   <link linkend="sql-altertable"><command>ALTER TABLE</command></link> command
   and the <literal>ENABLE TRIGGER</literal> and <literal>ENABLE RULE</literal>
   clauses.
  </para>
________________________________________________________-->
  <para>
   在订阅者数据库上应用过程始终以
   <link linkend="guc-session-replication-role"><varname>session_replication_role</varname></link>设置为<literal>replica</literal>运行。
   这意味着，默认情况下，触发器和规则不会在订阅者上触发。用户可以选择使用<link linkend="sql-altertable"><command>ALTER TABLE</command></link>
   命令和<literal>ENABLE TRIGGER</literal>和<literal>ENABLE RULE</literal>子句在表上启用触发器和规则。
  </para>
<!-- pgdoc-cn_end sig_en=1559ba678fdfc87431cbc64396b044c2 -->

<!-- pgdoc-cn_start sig_en=41f31788b53c512986a6003bb218cb07 sig_cn_org=None source=14.1 
  <para>
   The logical replication apply process currently only fires row triggers,
   not statement triggers.  The initial table synchronization, however, is
   implemented like a <command>COPY</command> command and thus fires both row
   and statement triggers for <command>INSERT</command>.
  </para>
________________________________________________________-->
  <para>
   逻辑复制应用进程当前仅会引发行触发器，而不会引发语句触发器。不过，初始的表同步是以类似一个<command>COPY</command>命令的方式实现的，因此会引发<command>INSERT</command>的行触发器和语句触发器。
  </para>
<!-- pgdoc-cn_end sig_en=41f31788b53c512986a6003bb218cb07 -->

  <sect2 id="logical-replication-snapshot">
<!-- pgdoc-cn_start sig_en=4369a47d4adac9dcdc3327b2cc2f440d sig_cn_org=None source=14.1 
    <title>Initial Snapshot</title>
________________________________________________________-->
    <title>初始快照</title>
<!-- pgdoc-cn_end sig_en=4369a47d4adac9dcdc3327b2cc2f440d -->
<!-- pgdoc-cn_start sig_en=c7d87bed44db3d64b439e10acd1e0530 sig_cn_org=None source=14.1 
    <para>
     The initial data in existing subscribed tables are snapshotted and
     copied in a parallel instance of a special kind of apply process.
     This process will create its own replication slot and copy the existing
     data.  As soon as the copy is finished the table contents will become
     visible to other backends.  Once existing data is copied, the worker
     enters synchronization mode, which ensures that the table is brought
     up to a synchronized state with the main apply process by streaming
     any changes that happened during the initial data copy using standard
     logical replication.  During this synchronization phase, the changes
     are applied and committed in the same order as they happened on the
     publisher.  Once synchronization is done, control of the
     replication of the table is given back to the main apply process where
     replication continues as normal.
    </para>
________________________________________________________-->
    <para>
      获取现有订阅表中初始数据的快照并且以一种特殊类型的应用进程的并行实例进行拷贝。这种进程将创建自己的复制槽并且拷贝现有的数据。复制完成后，表内容对其他后端可见。一旦现有的数据被拷贝完，worker进程会进入到同步模式，主应用进程会流式更新在使用标准逻辑复制拷贝初始数据期间发生的任意改变，这会确保表变为已同步的状态。在此同步阶段，应用和提交更改的顺序与它们在发布者发生的顺序相同。一旦同步完成，该表的复制的控制权会被交回给主应用进程，其中复制会照常继续。
    </para>
<!-- pgdoc-cn_end sig_en=c7d87bed44db3d64b439e10acd1e0530 -->
    <note>
<!-- pgdoc-cn_start sig_en=583f787e7e37c27ff50af979bca5c159 sig_cn_org=129e92e62d8b68f6d5a816c0c5fce696 source=15.7 
     <para>
      The publication <literal>publish</literal> parameter only affects what
      DML operations will be replicated. The initial data synchronization does
      not take this parameter into account when copying the existing table data.
     </para>
________________________________________________________-->
     <para>
      发布<literal>publish</literal>参数仅影响哪些DML操作将被复制。初始数据同步在复制现有表数据时不考虑此参数。
     </para>
<!-- pgdoc-cn_end sig_en=583f787e7e37c27ff50af979bca5c159 -->
    </note>
  </sect2>
 </sect1>

 <sect1 id="logical-replication-monitoring">
<!-- pgdoc-cn_start sig_en=7f79d68fa5a8c3bc9aedb664a23056cd sig_cn_org=None source=14.1 
  <title>Monitoring</title>
________________________________________________________-->
  <title>监控</title>
<!-- pgdoc-cn_end sig_en=7f79d68fa5a8c3bc9aedb664a23056cd -->

<!-- pgdoc-cn_start sig_en=adf8cdd41bd68437a1aec055d5b93667 sig_cn_org=None source=14.1 
  <para>
   Because logical replication is based on a similar architecture as
   <link linkend="streaming-replication">physical streaming replication</link>,
   the monitoring on a publication node is similar to monitoring of a
   physical replication primary
   (see <xref linkend="streaming-replication-monitoring"/>).
  </para>
________________________________________________________-->
  <para>
   因为逻辑复制是基于与<link linkend="streaming-replication">物理流复制</link>相似的架构的，一个发布节点上的监控也类似于对物理复制主节点（见<xref linkend="streaming-replication-monitoring"/>）的监控。
  </para>
<!-- pgdoc-cn_end sig_en=adf8cdd41bd68437a1aec055d5b93667 -->

<!-- pgdoc-cn_start sig_en=69fa56daebde942ba273fd87fb96e6ea sig_cn_org=None source=14.1 
  <para>
   The monitoring information about subscription is visible in
   <link linkend="monitoring-pg-stat-subscription">
   <structname>pg_stat_subscription</structname></link>.
   This view contains one row for every subscription worker.  A subscription
   can have zero or more active subscription workers depending on its state.
  </para>
________________________________________________________-->
  <para>
   有关订阅的监控信息在<link linkend="monitoring-pg-stat-subscription"><structname>pg_stat_subscription</structname></link>中可以看到。
   每一个订阅工作者在这个视图都有一行。一个订阅能有零个或者多个活跃订阅工作者取决于它的状态。
  </para>
<!-- pgdoc-cn_end sig_en=69fa56daebde942ba273fd87fb96e6ea -->

<!-- pgdoc-cn_start sig_en=164342d9140fd8dffc584c4530b3c038 sig_cn_org=None source=14.1 
  <para>
   Normally, there is a single apply process running for an enabled
   subscription.  A disabled subscription or a crashed subscription will have
   zero rows in this view.  If the initial data synchronization of any
   table is in progress, there will be additional workers for the tables
   being synchronized.
  </para>
________________________________________________________-->
  <para>
   通常，对于一个已启用的订阅会有单一的应用进程运行。一个被禁用的订阅或者崩溃的订阅在这个视图中不会有行存在。如果有任何表的数据同步正在进行，对正在被同步的表会有额外的工作者。
  </para>
<!-- pgdoc-cn_end sig_en=164342d9140fd8dffc584c4530b3c038 -->
 </sect1>

 <sect1 id="logical-replication-security">
<!-- pgdoc-cn_start sig_en=c4f18396591d7bddfd8956518da6052b sig_cn_org=None source=14.1 
  <title>Security</title>
________________________________________________________-->
  <title>安全性</title>
<!-- pgdoc-cn_end sig_en=c4f18396591d7bddfd8956518da6052b -->

<!-- pgdoc-cn_start sig_en=02bc27c5e04dd44ef1f79998a9f15636 sig_cn_org=167348a12ce7bdc1c52d6af8596068f9 source=15.7 
  <para>
   A user able to modify the schema of subscriber-side tables can execute
   arbitrary code as the role which owns any subscription which modifies those tables.  Limit ownership
   and <literal>TRIGGER</literal> privilege on such tables to trusted roles.
   Moreover, if untrusted users can create tables, use only
   publications that list tables explicitly.  That is to say, create a
   subscription <literal>FOR ALL TABLES</literal> or
   <literal>FOR TABLES IN SCHEMA</literal> only when superusers trust
   every user permitted to create a non-temp table on the publisher or the
   subscriber.
  </para>
________________________________________________________-->
  <para>
   能够修改订阅端表结构的用户可以作为拥有修改这些表的订阅的角色执行任意代码。限制这些表的所有权和<literal>TRIGGER</literal>权限只给受信任的角色。
   此外，如果不受信任的用户可以创建表，请仅使用明确列出表的发布物。也就是说，在超级用户信任每个被允许在发布者或订阅者上创建非临时表的用户时，才创建<literal>FOR ALL TABLES</literal>或<literal>FOR TABLES IN SCHEMA</literal>的订阅。
  </para>
<!-- pgdoc-cn_end sig_en=02bc27c5e04dd44ef1f79998a9f15636 -->

<!-- pgdoc-cn_start sig_en=d1253bed000523a30910725554feccdf sig_cn_org=None source=14.1 
  <para>
   The role used for the replication connection must have
   the <literal>REPLICATION</literal> attribute (or be a superuser).  If the
   role lacks <literal>SUPERUSER</literal> and <literal>BYPASSRLS</literal>,
   publisher row security policies can execute.  If the role does not trust
   all table owners, include <literal>options=-crow_security=off</literal> in
   the connection string; if a table owner then adds a row security policy,
   that setting will cause replication to halt rather than execute the policy.
   Access for the role must be configured in <filename>pg_hba.conf</filename>
   and it must have the <literal>LOGIN</literal> attribute.
  </para>
________________________________________________________-->
  <para>
   用于复制连接的角色必须具有<literal>REPLICATION</literal>属性(或者是超级用户)。
   如果角色缺少<literal>SUPERUSER</literal> 和 <literal>BYPASSRLS</literal>，发布者的行安全策略可以执行。
   如果角色不信任全部表所有者，则在连接字符串中包含<literal>options=-crow_security=off</literal>;如果表所有者随后添加行安全策略，则该设置将导致复制中断，而不是执行该策略。
   角色的访问权限必须在<filename>pg_hba.conf</filename>中配置，并且必须具有<literal>LOGIN</literal>属性。
  </para>
<!-- pgdoc-cn_end sig_en=d1253bed000523a30910725554feccdf -->

<!-- pgdoc-cn_start sig_en=579af0ff679e2bab98dbbdef192f9284 sig_cn_org=None source=14.1 
  <para>
   In order to be able to copy the initial table data, the role used for the
   replication connection must have the <literal>SELECT</literal> privilege on
   a published table (or be a superuser).
  </para>
________________________________________________________-->
  <para>
   为了能够拷贝初始表数据，用于复制连接的角色必须在被发布的表上具有<literal>SELECT</literal>特权（或者是一个超级用户）。
  </para>
<!-- pgdoc-cn_end sig_en=579af0ff679e2bab98dbbdef192f9284 -->

<!-- pgdoc-cn_start sig_en=f077ec3d964f61f627b71686f2b20255 sig_cn_org=None source=14.1 
  <para>
   To create a publication, the user must have the <literal>CREATE</literal>
   privilege in the database.
  </para>
________________________________________________________-->
  <para>
   要创建发布，用户必须在数据库中有<literal>CREATE</literal>特权。
  </para>
<!-- pgdoc-cn_end sig_en=f077ec3d964f61f627b71686f2b20255 -->

<!-- pgdoc-cn_start sig_en=946815f696b01e22d24ba7c90e73b1de sig_cn_org=3c6b816bd23f27168c40ef01eba49166 source=15.7 
  <para>
   To add tables to a publication, the user must have ownership rights on the
   table. To add all tables in schema to a publication, the user must be a
   superuser. To create a publication that publishes all tables or all tables in
   schema automatically, the user must be a superuser.
  </para>
________________________________________________________-->
  <para>
   要向出版物添加表格，用户必须对表格拥有所有权。要向出版物添加模式中的所有表格，
   用户必须是超级用户。要创建一个自动发布所有表格或模式中所有表格的出版物，
   用户必须是超级用户。
</para>
<!-- pgdoc-cn_end sig_en=946815f696b01e22d24ba7c90e73b1de -->

<!-- pgdoc-cn_start sig_en=a090f25e90892b95b502736172bf8246 sig_cn_org=None source=14.1 
  <para>
   To create a subscription, the user must be a superuser.
  </para>
________________________________________________________-->
  <para>
   要创建订阅，用户必须是一个超级用户。
  </para>
<!-- pgdoc-cn_end sig_en=a090f25e90892b95b502736172bf8246 -->

<!-- pgdoc-cn_start sig_en=1ca2ee9ea0e319537e28ecee03fbd69d sig_cn_org=7c07d38bccd482f6a0b68f612c5b2f45 source=15.7 
  <para>
   The subscription apply process will run in the local database with the
   privileges of the subscription owner.
  </para>
________________________________________________________-->
  <para>
   订阅申请流程将在本地数据库中以订阅所有者的权限运行。
  </para>
<!-- pgdoc-cn_end sig_en=1ca2ee9ea0e319537e28ecee03fbd69d -->

<!-- pgdoc-cn_start sig_en=119ed2e8569849d40f17a2117ec3712a sig_cn_org=9bc8ca248bfa36e263b643dc0ea71e32 source=15.7 
  <para>
   On the publisher, privileges are only checked once at the start of a
   replication connection and are not re-checked as each change record is read.
  </para>
________________________________________________________-->
  <para>
   在发布者端，权限仅在复制连接开始时检查一次，并且在读取每个更改记录时不会重新检查。
  </para>
<!-- pgdoc-cn_end sig_en=119ed2e8569849d40f17a2117ec3712a -->

<!-- pgdoc-cn_start sig_en=332b9d8b74d407a1e798bc76c8b3315f sig_cn_org=d94658b5b8a0477f73cdc04b2edbe551 source=15.7 
  <para>
   On the subscriber, the subscription owner's privileges are re-checked for
   each transaction when applied. If a worker is in the process of applying a
   transaction when the ownership of the subscription is changed by a
   concurrent transaction, the application of the current transaction will
   continue under the old owner's privileges.
  </para>
________________________________________________________-->
  <para>
   在订阅者端，每次应用时都会重新检查订阅所有者的特权。如果一个工作者正在应用事务时，
   订阅的所有权被并发事务更改，当前事务的应用将在旧所有者的特权下继续。
</para>
<!-- pgdoc-cn_end sig_en=332b9d8b74d407a1e798bc76c8b3315f -->
 </sect1>

 <sect1 id="logical-replication-config">
<!-- pgdoc-cn_start sig_en=50c3b58935b49643e63c4fe0dbed8087 sig_cn_org=None source=14.1 
  <title>Configuration Settings</title>
________________________________________________________-->
  <title>配置设置</title>
<!-- pgdoc-cn_end sig_en=50c3b58935b49643e63c4fe0dbed8087 -->

<!-- pgdoc-cn_start sig_en=c260f041b69e5fd56343d1b8eace551f sig_cn_org=None source=14.1 
  <para>
   Logical replication requires several configuration options to be set.
  </para>
________________________________________________________-->
  <para>
   逻辑复制要求设置一些配置选项。
  </para>
<!-- pgdoc-cn_end sig_en=c260f041b69e5fd56343d1b8eace551f -->

<!-- pgdoc-cn_start sig_en=92919d13646035148016c89f51c60bc3 sig_cn_org=None source=14.1 
  <para>
   On the publisher side, <varname>wal_level</varname> must be set to
   <literal>logical</literal>, and <varname>max_replication_slots</varname>
   must be set to at least the number of subscriptions expected to connect,
   plus some reserve for table synchronization.  And
   <varname>max_wal_senders</varname> should be set to at least the same as
   <varname>max_replication_slots</varname> plus the number of physical
   replicas that are connected at the same time.
  </para>
________________________________________________________-->
  <para>
   在发布者端，<varname>wal_level</varname>必须被设置为<literal>logical</literal>，而<varname>max_replication_slots</varname>中设置的值必须至少是预期要连接的订阅数加上保留给表同步的连接数。<varname>max_wal_senders</varname>应该至少被设置为<varname>max_replication_slots</varname>加上同时连接的物理复制体的数量。
  </para>
<!-- pgdoc-cn_end sig_en=92919d13646035148016c89f51c60bc3 -->

<!-- pgdoc-cn_start sig_en=6da6ba01f9579dc658a21526665b0c30 sig_cn_org=None source=14.1 
  <para>
   <varname>max_replication_slots</varname> must also be set on the subscriber.
   It should be set to at least the number of subscriptions that will be added
   to the subscriber, plus some reserve for table synchronization.
   <varname>max_logical_replication_workers</varname> must be set to at least
   the number of subscriptions, again plus some reserve for the table
   synchronization.  Additionally the <varname>max_worker_processes</varname>
   may need to be adjusted to accommodate for replication workers, at least
   (<varname>max_logical_replication_workers</varname>
   + <literal>1</literal>).  Note that some extensions and parallel queries
   also take worker slots from <varname>max_worker_processes</varname>.
  </para>
________________________________________________________-->
  <para>
   订阅者必须配置<varname>max_replication_slots</varname>。它必须设置为至少是订阅者数，加上一些用于表同步的预留。<varname>max_logical_replication_workers</varname>必须至少被设置为订阅数加上保留给表同步的连接数。此外，可能需要调整<varname>max_worker_processes</varname>以容纳复制工作者，至少为(<varname>max_logical_replication_workers</varname> + <literal>1</literal>)。注意，一些扩展和并行查询也会从<varname>max_worker_processes</varname>中取得工作者槽。
  </para>
<!-- pgdoc-cn_end sig_en=6da6ba01f9579dc658a21526665b0c30 -->
 </sect1>

 <sect1 id="logical-replication-quick-setup">
<!-- pgdoc-cn_start sig_en=9fe5ac626e51b2a705003f04e28961f8 sig_cn_org=None source=14.1 
  <title>Quick Setup</title>
________________________________________________________-->
  <title>快速设置</title>
<!-- pgdoc-cn_end sig_en=9fe5ac626e51b2a705003f04e28961f8 -->

<!-- pgdoc-cn_start sig_en=ea592b305e680a647c80108eec9115a0 sig_cn_org=None source=14.1 
  <para>
   First set the configuration options in <filename>postgresql.conf</filename>:
<programlisting>
wal_level = logical
</programlisting>
   The other required settings have default values that are sufficient for a
   basic setup.
  </para>
________________________________________________________-->
  <para>
   首先在<filename>postgresql.conf</filename>中设置配置选项：
<programlisting>
wal_level = logical
</programlisting>
   对于一个基础设置来说，其他所需的设置使用默认值就足够了。
  </para>
<!-- pgdoc-cn_end sig_en=ea592b305e680a647c80108eec9115a0 -->

<!-- pgdoc-cn_start sig_en=a3679a487cb1f035502436db51fa8938 sig_cn_org=None source=14.1 
  <para>
   <filename>pg_hba.conf</filename> needs to be adjusted to allow replication
   (the values here depend on your actual network configuration and user you
   want to use for connecting):
<programlisting>
host     all     repuser     0.0.0.0/0     md5
</programlisting>
  </para>
________________________________________________________-->
  <para>
   需要调整<filename>pg_hba.conf</filename>以允许复制（这里的值取决于实际的网络配置以及用于连接的用户）：
<programlisting>
host     all     repuser     0.0.0.0/0     md5
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=a3679a487cb1f035502436db51fa8938 -->

<!-- pgdoc-cn_start sig_en=567fd3bccb45ee6552b7230315f02b14 sig_cn_org=None source=14.1 
  <para>
   Then on the publisher database:
<programlisting>
CREATE PUBLICATION mypub FOR TABLE users, departments;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   然后在发布者数据库上：
<programlisting>
CREATE PUBLICATION mypub FOR TABLE users, departments;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=567fd3bccb45ee6552b7230315f02b14 -->

<!-- pgdoc-cn_start sig_en=2c1522f0ee240d84cf3d2e80777c3b8b sig_cn_org=None source=14.1 
  <para>
   And on the subscriber database:
<programlisting>
CREATE SUBSCRIPTION mysub CONNECTION 'dbname=foo host=bar user=repuser' PUBLICATION mypub;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   并且在订阅者数据库上：
<programlisting>
CREATE SUBSCRIPTION mysub CONNECTION 'dbname=foo host=bar user=repuser' PUBLICATION mypub;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=2c1522f0ee240d84cf3d2e80777c3b8b -->

<!-- pgdoc-cn_start sig_en=da80565612d32c319f8e58f6e2810ca4 sig_cn_org=None source=14.1 
  <para>
   The above will start the replication process, which synchronizes the
   initial table contents of the tables <literal>users</literal> and
   <literal>departments</literal> and then starts replicating
   incremental changes to those tables.
  </para>
________________________________________________________-->
  <para>
   上面的语句将开始复制过程，它会同步表<literal>users</literal>以及<literal>departments</literal>的初始表内容，然后开始复制对那些表的增量更改。
  </para>
<!-- pgdoc-cn_end sig_en=da80565612d32c319f8e58f6e2810ca4 -->
 </sect1>
</chapter>
