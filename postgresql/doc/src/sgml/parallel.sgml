<!-- doc/src/sgml/parallel.sgml -->

 <chapter id="parallel-query">
<!-- pgdoc-cn_start sig_en=257cb25ec656d669fc1e43cd4926da9c sig_cn_org=None source=14.1 
  <title>Parallel Query</title>
________________________________________________________-->
  <title>并行查询</title>
<!-- pgdoc-cn_end sig_en=257cb25ec656d669fc1e43cd4926da9c -->

<!-- pgdoc-cn_start sig_en=af90a5c4522708400d355d371c5f4ad5 sig_cn_org=None source=14.1 
  <indexterm zone="parallel-query">
   <primary>parallel query</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="parallel-query">
   <primary>并行查询</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=af90a5c4522708400d355d371c5f4ad5 -->

<!-- pgdoc-cn_start sig_en=51e24db21753ec85a58e21b6c9dd6d88 sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> can devise query plans that can leverage
   multiple CPUs in order to answer queries faster.  This feature is known
   as parallel query.  Many queries cannot benefit from parallel query, either
   due to limitations of the current implementation or because there is no
   imaginable query plan that is any faster than the serial query plan.
   However, for queries that can benefit, the speedup from parallel query
   is often very significant.  Many queries can run more than twice as fast
   when using parallel query, and some queries can run four times faster or
   even more.  Queries that touch a large amount of data but return only a
   few rows to the user will typically benefit most.  This chapter explains
   some details of how parallel query works and in which situations it can be
   used so that users who wish to make use of it can understand what to expect.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>能设计出利用多 CPU 让查询更快的查询计划。这种特性被称为并行查询。由于现有实现的限制或者因为没有比连续查询计划更快的查询计划存在，很多查询并不能从并行查询获益。不过，对于那些可以从并行查询获益的查询来说，并行查询带来的速度提升是显著的。很多查询在使用并行查询时比之前快了超过两倍，有些查询是以前的四倍甚至更多的倍数。那些访问大量数据但只返回其中少数行给用户的查询最能从并行查询中获益。这一章介绍一些并行查询如何工作的细节以及哪些情况下可以使用并行查询，这样希望充分利用并行查询的用户可以理解他们能从并行查询得到什么。
  </para>
<!-- pgdoc-cn_end sig_en=51e24db21753ec85a58e21b6c9dd6d88 -->

 <sect1 id="how-parallel-query-works">
<!-- pgdoc-cn_start sig_en=84c16b68a49231d0849bc210317a4c16 sig_cn_org=None source=14.1 
  <title>How Parallel Query Works</title>
________________________________________________________-->
  <title>并行查询如何工作</title>
<!-- pgdoc-cn_end sig_en=84c16b68a49231d0849bc210317a4c16 -->

<!-- pgdoc-cn_start sig_en=3228a53d4b94b759626c778e6b01e747 sig_cn_org=7a79d7c8b64c476103bba77b5e6453b9 source=15.7 
   <para>
    When the optimizer determines that parallel query is the fastest execution
    strategy for a particular query, it will create a query plan that includes
    a <firstterm>Gather</firstterm> or <firstterm>Gather Merge</firstterm>
    node.  Here is a simple example:

<screen>
EXPLAIN SELECT * FROM pgbench_accounts WHERE filler LIKE '%x%';
                                     QUERY PLAN
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&zwsp;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Gather  (cost=1000.00..217018.43 rows=1 width=97)
   Workers Planned: 2
   ->  Parallel Seq Scan on pgbench_accounts  (cost=0.00..216018.33 rows=1 width=97)
         Filter: (filler ~~ '%x%'::text)
(4 rows)
</screen>
   </para>
________________________________________________________-->
   <para>
    当优化器确定并行查询是特定查询的最快执行策略时，它将创建一个包含<firstterm>Gather</firstterm>或<firstterm>Gather Merge</firstterm>节点的查询计划。这里是一个简单的示例：

<screen>
EXPLAIN SELECT * FROM pgbench_accounts WHERE filler LIKE '%x%';
                                     QUERY PLAN
-------------------------------------------------------------------&zwsp;------------------
 Gather  (cost=1000.00..217018.43 rows=1 width=97)
   Workers Planned: 2
   ->  Parallel Seq Scan on pgbench_accounts  (cost=0.00..216018.33 rows=1 width=97)
         Filter: (filler ~~ '%x%'::text)
(4 rows)
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=3228a53d4b94b759626c778e6b01e747 -->

<!-- pgdoc-cn_start sig_en=e37d68961a728479c77d478ea85f30f7 sig_cn_org=None source=14.1 
   <para>
    In all cases, the <literal>Gather</literal> or
    <literal>Gather Merge</literal> node will have exactly one
    child plan, which is the portion of the plan that will be executed in
    parallel.  If the <literal>Gather</literal> or <literal>Gather Merge</literal> node is
    at the very top of the plan tree, then the entire query will execute in
    parallel.  If it is somewhere else in the plan tree, then only the portion
    of the plan below it will run in parallel.  In the example above, the
    query accesses only one table, so there is only one plan node other than
    the <literal>Gather</literal> node itself; since that plan node is a child of the
    <literal>Gather</literal> node, it will run in parallel.
   </para>
________________________________________________________-->
   <para>
    在所有的情形下，<literal>Gather</literal>或<firstterm>Gather Merge</firstterm>节点都只有一个子计划，它是将被并行执行的计划的一部分。如果<literal>Gather</literal>或<firstterm>Gather Merge</firstterm>节点位于计划树的最顶层，那么整个查询将并行执行。如果它位于计划树的其他位置，那么只有查询中在它之下的那一部分会并行执行。在上面的例子中，查询只访问了一个表，因此除<literal>Gather</literal>节点本身之外只有一个计划节点。因为该计划节点是<literal>Gather</literal>节点的孩子节点，所以它会并行执行。
   </para>
<!-- pgdoc-cn_end sig_en=e37d68961a728479c77d478ea85f30f7 -->

<!-- pgdoc-cn_start sig_en=ce2ec6a659560adc838bc25dbee0e0a1 sig_cn_org=None source=14.1 
   <para>
    <link linkend="using-explain">Using EXPLAIN</link>, you can see the number of
    workers chosen by the planner.  When the <literal>Gather</literal> node is reached
    during query execution, the process that is implementing the user's
    session will request a number of <link linkend="bgworker">background
    worker processes</link> equal to the number
    of workers chosen by the planner.  The number of background workers that
    the planner will consider using is limited to at most
    <xref linkend="guc-max-parallel-workers-per-gather"/>.  The total number
    of background workers that can exist at any one time is limited by both
    <xref linkend="guc-max-worker-processes"/> and
    <xref linkend="guc-max-parallel-workers"/>.  Therefore, it is possible for a
    parallel query to run with fewer workers than planned, or even with
    no workers at all.  The optimal plan may depend on the number of workers
    that are available, so this can result in poor query performance.  If this
    occurrence is frequent, consider increasing
    <varname>max_worker_processes</varname> and <varname>max_parallel_workers</varname>
    so that more workers can be run simultaneously or alternatively reducing
    <varname>max_parallel_workers_per_gather</varname> so that the planner
    requests fewer workers.
   </para>
________________________________________________________-->
   <para>
    <link linkend="using-explain">使用 EXPLAIN</link>命令, 你能看到规划器选择的工作者数量。当查询执行期间到达<literal>Gather</literal>节点时，实现用户会话的进程将会请求和规划器选中的工作者数量一样多的<link linkend="bgworker">后台工作者进程</link> 。规划器将考虑使用的后台工作者的数量被限制为最多<xref linkend="guc-max-parallel-workers-per-gather"/>个。任何时候能够存在的后台工作者进程的总数由<xref linkend="guc-max-worker-processes"/>和<xref linkend="guc-max-parallel-workers"/>限制。因此，一个并行查询可能会使用比规划中少的工作者来运行，甚至有可能根本不使用工作者。最优的计划可能取决于可用的工作者的数量，因此这可能会导致不好的查询性能。如果这种情况经常发生，那么就应当考虑一下提高<varname>max_worker_processes</varname>和<varname>max_parallel_workers</varname>的值，这样更多的工作者可以同时运行；或者降低<varname>max_parallel_workers_per_gather</varname>，这样规划器会要求少一些的工作者。
   </para>
<!-- pgdoc-cn_end sig_en=ce2ec6a659560adc838bc25dbee0e0a1 -->

<!-- pgdoc-cn_start sig_en=9d573422c9ceb7c557f93e72f9153b40 sig_cn_org=None source=14.1 
   <para>
    Every background worker process that is successfully started for a given
    parallel query will execute the parallel portion of the plan.  The leader
    will also execute that portion of the plan, but it has an additional
    responsibility: it must also read all of the tuples generated by the
    workers.  When the parallel portion of the plan generates only a small
    number of tuples, the leader will often behave very much like an additional
    worker, speeding up query execution.  Conversely, when the parallel portion
    of the plan generates a large number of tuples, the leader may be almost
    entirely occupied with reading the tuples generated by the workers and
    performing any further processing steps that are required by plan nodes
    above the level of the <literal>Gather</literal> node or
    <literal>Gather Merge</literal> node.  In such cases, the leader will
    do very little of the work of executing the parallel portion of the plan.
   </para>
________________________________________________________-->
   <para>
    为一个给定并行查询成功启动的后台工作者进程都将会执行计划的并行部分。这些工作者的领导者也将执行该计划，不过它还有一个额外的任务：它还必须读取所有由工作者产生的元组。当整个计划的并行部分只产生了少量元组时，领导者通常将表现为一个额外的加速查询执行的工作者。反过来，当计划的并行部分产生大量的元组时，领导者将几乎全用来读取由工作者产生的元组并且执行<literal>Gather</literal>或<literal>Gather Merge</literal>节点上层计划节点所要求的任何进一步处理。在这些情况下，领导者所作的执行并行部分的工作将会很少。
   </para>
<!-- pgdoc-cn_end sig_en=9d573422c9ceb7c557f93e72f9153b40 -->

<!-- pgdoc-cn_start sig_en=b1841afaf98edd268c7dfa4b1a954fa8 sig_cn_org=None source=14.1 
   <para>
    When the node at the top of the parallel portion of the plan is
    <literal>Gather Merge</literal> rather than <literal>Gather</literal>, it indicates that
    each process executing the parallel portion of the plan is producing
    tuples in sorted order, and that the leader is performing an
    order-preserving merge.  In contrast, <literal>Gather</literal> reads tuples
    from the workers in whatever order is convenient, destroying any sort
    order that may have existed.
   </para>
________________________________________________________-->
   <para>
    当计划的并行部分的顶层节点是<literal>Gather Merge</literal>而不是<literal>Gather</literal>时，它表示每个执行计划并行部分的进程会产生有序的元组，并且领导者执行一种保持顺序的合并。相反，<literal>Gather</literal>会以任何方便的顺序从工作者读取元组，这会破坏可能已经存在的排序顺序。
   </para>
<!-- pgdoc-cn_end sig_en=b1841afaf98edd268c7dfa4b1a954fa8 -->
 </sect1>

 <sect1 id="when-can-parallel-query-be-used">
<!-- pgdoc-cn_start sig_en=3f4541af625878a74bd4d83ddbb44012 sig_cn_org=None source=14.1 
  <title>When Can Parallel Query Be Used?</title>
________________________________________________________-->
  <title>何时会用到并行查询？</title>
<!-- pgdoc-cn_end sig_en=3f4541af625878a74bd4d83ddbb44012 -->

<!-- pgdoc-cn_start sig_en=6358e71a827bc191c786ac86661e3a47 sig_cn_org=None source=14.1 
  <para>
    There are several settings that can cause the query planner not to
    generate a parallel query plan under any circumstances.  In order for
    any parallel query plans whatsoever to be generated, the following
    settings must be configured as indicated.
  </para>
________________________________________________________-->
  <para>
    有几种设置会导致查询规划器在任何情况下都不生成并行查询计划。为了让并行查询计划能够被生成，必须配置好下列设置。
  </para>
<!-- pgdoc-cn_end sig_en=6358e71a827bc191c786ac86661e3a47 -->

  <itemizedlist>
    <listitem>
<!-- pgdoc-cn_start sig_en=3c3b93460ecffa124d8190ee6a376218 sig_cn_org=None source=14.1 
      <para>
        <xref linkend="guc-max-parallel-workers-per-gather"/> must be set to a
        value that is greater than zero. This is a special case of the more
        general principle that no more workers should be used than the number
        configured via <varname>max_parallel_workers_per_gather</varname>.
      </para>
________________________________________________________-->
      <para>
        <xref linkend="guc-max-parallel-workers-per-gather"/>必须被设置为大于零的值。这是一种特殊情况，更加普遍的原则是所用的工作者数量不能超过<varname>max_parallel_workers_per_gather</varname>所配置的数量。
      </para>
<!-- pgdoc-cn_end sig_en=3c3b93460ecffa124d8190ee6a376218 -->
    </listitem>
  </itemizedlist>

<!-- pgdoc-cn_start sig_en=73df928935cacb209bd367a860b21be0 sig_cn_org=a403b20139346a23a3020fd2e41f3695 source=15.7 
  <para>
    In addition, the system must not be running in single-user mode.  Since
    the entire database system is running as a single process in this situation,
    no background workers will be available.
  </para>
________________________________________________________-->
  <para>
    另外，系统不能在单用户模式下运行。由于在这种情况下整个数据库系统作为一个单一进程运行，因此没有后台工作进程可用。
  </para>
<!-- pgdoc-cn_end sig_en=73df928935cacb209bd367a860b21be0 -->

<!-- pgdoc-cn_start sig_en=996e36f689c475404ea694ed73a1d42f sig_cn_org=None source=14.1 
  <para>
    Even when it is in general possible for parallel query plans to be
    generated, the planner will not generate them for a given query
    if any of the following are true:
  </para>
________________________________________________________-->
  <para>
    如果下面的任一条件为真，即便对一个给定查询通常可以产生并行查询计划，规划器都不会为它产生并行查询计划：
  </para>
<!-- pgdoc-cn_end sig_en=996e36f689c475404ea694ed73a1d42f -->

  <itemizedlist>
    <listitem>
<!-- pgdoc-cn_start sig_en=34073ef460968cec55c9ffb39cbf4dd0 sig_cn_org=None source=14.1 
      <para>
        The query writes any data or locks any database rows. If a query
        contains a data-modifying operation either at the top level or within
        a CTE, no parallel plans for that query will be generated.  As an
        exception, the following commands, which create a new table and populate
        it, can use a parallel plan for the underlying <literal>SELECT</literal>
        part of the query:

        <itemizedlist>
          <listitem>
            <para><command>CREATE TABLE ... AS</command></para>
          </listitem>
          <listitem>
            <para><command>SELECT INTO</command></para>
          </listitem>
          <listitem>
            <para><command>CREATE MATERIALIZED VIEW</command></para>
          </listitem>
          <listitem>
            <para><command>REFRESH MATERIALIZED VIEW</command></para>
          </listitem>
        </itemizedlist>
      </para>
________________________________________________________-->
      <para> 
        查询要写任何数据或者锁定任何数据库行。如果一个查询在顶层或者 CTE 中包含了数据修改操作，那么不会为该查询产生并行计划。作为例外，以下创建新表并更新数据的命令，可以对查询的<literal>SELECT</literal>部分使用并行计划。

        <itemizedlist>
                <listitem>
                  <para><command>CREATE TABLE ... AS</command></para>
                </listitem>
                <listitem>
                  <para><command>SELECT INTO</command></para>
                </listitem>
                <listitem>
                  <para><command>CREATE MATERIALIZED VIEW</command></para>
                </listitem>
                <listitem>
                  <para><command>REFRESH MATERIALIZED VIEW</command></para>
                </listitem>
        </itemizedlist>
      </para>
<!-- pgdoc-cn_end sig_en=34073ef460968cec55c9ffb39cbf4dd0 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=a8d30bb835c9843f9711ba2c1d7e703b sig_cn_org=None source=14.1 
      <para>
        The query might be suspended during execution. In any situation in
        which the system thinks that partial or incremental execution might
        occur, no parallel plan is generated. For example, a cursor created
        using <link linkend="sql-declare">DECLARE CURSOR</link> will never use
        a parallel plan. Similarly, a PL/pgSQL loop of the form
        <literal>FOR x IN query LOOP .. END LOOP</literal> will never use a
        parallel plan, because the parallel query system is unable to verify
        that the code in the loop is safe to execute while parallel query is
        active.
      </para>
________________________________________________________-->
      <para>
        查询可能在执行过程中被暂停。只要在系统认为可能发生部分或者增量式执行，就不会产生并行计划。例如：用<link linkend="sql-declare">DECLARE CURSOR</link>创建的游标将永远不会使用并行计划。类似地，一个<literal>FOR x IN query LOOP .. END LOOP</literal>形式的 PL/pgSQL 循环也永远不会使用并行计划，因为当并行查询进行时，并行查询系统无法验证循环中的代码执行起来是安全的。
      </para>
<!-- pgdoc-cn_end sig_en=a8d30bb835c9843f9711ba2c1d7e703b -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=e5f7cdc976c8512f0671b17aa8298897 sig_cn_org=None source=14.1 
      <para>
        The query uses any function marked <literal>PARALLEL UNSAFE</literal>.
        Most system-defined functions are <literal>PARALLEL SAFE</literal>,
        but user-defined functions are marked <literal>PARALLEL
        UNSAFE</literal> by default. See the discussion of
        <xref linkend="parallel-safety"/>.
      </para>
________________________________________________________-->
      <para>
        使用了任何被标记为<literal>PARALLEL UNSAFE</literal>的函数的查询。大多数系统定义的函数都被标记为<literal>PARALLEL SAFE</literal>，但是用户定义的函数默认被标记为<literal>PARALLEL UNSAFE</literal>。参见<xref linkend="parallel-safety"/>中的讨论。
      </para>
<!-- pgdoc-cn_end sig_en=e5f7cdc976c8512f0671b17aa8298897 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=2d9382756580a98be1c8d6cd70072554 sig_cn_org=None source=14.1 
      <para>
        The query is running inside of another query that is already parallel.
        For example, if a function called by a parallel query issues an SQL
        query itself, that query will never use a parallel plan. This is a
        limitation of the current implementation, but it may not be desirable
        to remove this limitation, since it could result in a single query
        using a very large number of processes.
      </para>
________________________________________________________-->
      <para>
        该查询运行在另一个已经存在的并行查询内部。例如，如果一个被并行查询调用的函数自己发出一个 SQL 查询，那么该查询将不会使用并行计划。这是当前实现的一个限制，但是或许不值得移除这个限制，因为它会导致单个查询使用大量的进程。
      </para>
<!-- pgdoc-cn_end sig_en=2d9382756580a98be1c8d6cd70072554 -->
    </listitem>
  </itemizedlist>

<!-- pgdoc-cn_start sig_en=ef2722cf15fa6d351efabf7a8a4281a4 sig_cn_org=None source=14.1 
  <para>
    Even when parallel query plan is generated for a particular query, there
    are several circumstances under which it will be impossible to execute
    that plan in parallel at execution time.  If this occurs, the leader
    will execute the portion of the plan below the <literal>Gather</literal>
    node entirely by itself, almost as if the <literal>Gather</literal> node were
    not present.  This will happen if any of the following conditions are met:
  </para>
________________________________________________________-->
  <para>
    即使对于一个特定的查询已经产生了并行查询计划，在一些情况下执行时也不会并行执行该计划。如果发生这种情况，那么领导者将会自己执行该计划在<literal>Gather</literal>节点之下的部分，就好像<literal>Gather</literal>节点不存在一样。上述情况将在满足下面的任一条件时发生：
  </para>
<!-- pgdoc-cn_end sig_en=ef2722cf15fa6d351efabf7a8a4281a4 -->

  <itemizedlist>
    <listitem>
<!-- pgdoc-cn_start sig_en=53354504b0fcd030e23e71da0d6b9290 sig_cn_org=None source=14.1 
      <para>
        No background workers can be obtained because of the limitation that
        the total number of background workers cannot exceed
        <xref linkend="guc-max-worker-processes"/>.
      </para>
________________________________________________________-->
      <para> 
        因为后台工作者进程的总数不能超过<xref linkend="guc-max-worker-processes"/>，导致不能得到后台工作者进程。
      </para>
<!-- pgdoc-cn_end sig_en=53354504b0fcd030e23e71da0d6b9290 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=de6835e61c40eb35e093a0e95be166d0 sig_cn_org=None source=14.1 
      <para>
        No background workers can be obtained because of the limitation that
        the total number of background workers launched for purposes of
        parallel query cannot exceed <xref linkend="guc-max-parallel-workers"/>.
      </para>
________________________________________________________-->
      <para>
        由于为并行查询目的启动的后台工作者数量不能超过<xref linkend="guc-max-parallel-workers"/>这一限制而不能得到后台工作者。
      </para>
<!-- pgdoc-cn_end sig_en=de6835e61c40eb35e093a0e95be166d0 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=4334df76791d034f84abe09a54fa5c98 sig_cn_org=None source=14.1 
      <para>
        The client sends an Execute message with a non-zero fetch count.
        See the discussion of the
        <link linkend="protocol-flow-ext-query">extended query protocol</link>.
        Since <link linkend="libpq">libpq</link> currently provides no way to
        send such a message, this can only occur when using a client that
        does not rely on libpq.  If this is a frequent
        occurrence, it may be a good idea to set
        <xref linkend="guc-max-parallel-workers-per-gather"/> to zero in
        sessions where it is likely, so as to avoid generating query plans
        that may be suboptimal when run serially.
      </para>
________________________________________________________-->
      <para> 
        客户端发送了一个执行消息，并且消息中要求取元组的数量不为零。执行消息可见<link linkend="protocol-flow-ext-query">扩展查询协议</link>中的讨论。因为<link linkend="libpq">libpq</link>当前没有提供方法来发送这种消息，所以这种情况只可能发生在不依赖 libpq 的客户端中。如果这种情况经常发生，那在它可能发生的会话中设置 <xref linkend="guc-max-parallel-workers-per-gather"/>为零是一个很好的主意，这样可以避免产生连续运行时次优的查询计划。
      </para>
<!-- pgdoc-cn_end sig_en=4334df76791d034f84abe09a54fa5c98 -->
    </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="parallel-plans">
<!-- pgdoc-cn_start sig_en=4ac10433c36a443c5738fc3014009d7a sig_cn_org=None source=14.1 
  <title>Parallel Plans</title>
________________________________________________________-->
  <title>并行计划</title>
<!-- pgdoc-cn_end sig_en=4ac10433c36a443c5738fc3014009d7a -->

<!-- pgdoc-cn_start sig_en=8ac0a8c773ee8664e1b265cc9716a7ae sig_cn_org=None source=14.1 
  <para>
    Because each worker executes the parallel portion of the plan to
    completion, it is not possible to simply take an ordinary query plan
    and run it using multiple workers.  Each worker would produce a full
    copy of the output result set, so the query would not run any faster
    than normal but would produce incorrect results.  Instead, the parallel
    portion of the plan must be what is known internally to the query
    optimizer as a <firstterm>partial plan</firstterm>; that is, it must be constructed
    so that each process that executes the plan will generate only a
    subset of the output rows in such a way that each required output row
    is guaranteed to be generated by exactly one of the cooperating processes.
    Generally, this means that the scan on the driving table of the query
    must be a parallel-aware scan.
  </para>
________________________________________________________-->
  <para>
    因为每个工作者只执行完成计划的并行部分，所以不可能简单地产生一个普通查询计划并使用多个工作者运行它。每个工作者都会产生输出结果集的一个完全拷贝，因而查询并不会比普通查询运行得更快甚至还会产生不正确的结果。相反，计划的并行部分一定被查询优化器在内部当作一个<firstterm>部分计划</firstterm>，即它必须被构建出来，这样每一个执行该计划的进程将以无重复地方式产生输出行的一个子集，即保证每一个所需要的输出行正好只被一个合作进程生成。通常，这意味着该查询的驱动表上的扫描必须是一种可并行的扫描。
  </para>
<!-- pgdoc-cn_end sig_en=8ac0a8c773ee8664e1b265cc9716a7ae -->

 <sect2 id="parallel-scans">
<!-- pgdoc-cn_start sig_en=402eb92ce6e5279dcdb7821a1e5967c8 sig_cn_org=None source=14.1 
  <title>Parallel Scans</title>
________________________________________________________-->
  <title>并行扫描</title>
<!-- pgdoc-cn_end sig_en=402eb92ce6e5279dcdb7821a1e5967c8 -->

<!-- pgdoc-cn_start sig_en=9e0ffb1d5073dea9bc3d12ba8d6b1c69 sig_cn_org=8ac2bbdbf9b381ba5ff8db3f0a9435d6 source=15.7 
  <para>
    The following types of parallel-aware table scans are currently supported.

  <itemizedlist>
    <listitem>
      <para>
        In a <emphasis>parallel sequential scan</emphasis>, the table's blocks will
        be divided into ranges and shared among the cooperating processes.  Each
        worker process will complete the scanning of its given range of blocks before
        requesting an additional range of blocks.
      </para>
    </listitem>
    <listitem>
      <para>
        In a <emphasis>parallel bitmap heap scan</emphasis>, one process is chosen
        as the leader.  That process performs a scan of one or more indexes
        and builds a bitmap indicating which table blocks need to be visited.
        These blocks are then divided among the cooperating processes as in
        a parallel sequential scan.  In other words, the heap scan is performed
        in parallel, but the underlying index scan is not.
      </para>
    </listitem>
    <listitem>
      <para>
        In a <emphasis>parallel index scan</emphasis> or <emphasis>parallel index-only
        scan</emphasis>, the cooperating processes take turns reading data from the
        index.  Currently, parallel index scans are supported only for
        btree indexes.  Each process will claim a single index block and will
        scan and return all tuples referenced by that block; other processes can
        at the same time be returning tuples from a different index block.
        The results of a parallel btree scan are returned in sorted order
        within each worker process.
      </para>
    </listitem>
  </itemizedlist>

    Other scan types, such as scans of non-btree indexes, may support
    parallel scans in the future.
  </para>
________________________________________________________-->
  <para>
    目前支持以下类型的并行感知表扫描。

  <itemizedlist>
    <listitem>
      <para>
        在<emphasis>并行顺序扫描</emphasis>中，表的块将被分成范围并在合作进程之间共享。
        每个工作进程将在请求额外的块范围之前完成其给定范围的扫描。
      </para>
    </listitem>
    <listitem>
      <para>
        在<emphasis>并行位图堆扫描</emphasis>中，选择一个进程作为领导者。
        该进程执行一个或多个索引的扫描，并构建一个位图，指示需要访问哪些表块。
        然后将这些块分配给合作进程，就像在并行顺序扫描中一样。
        换句话说，堆扫描是并行执行的，但底层索引扫描不是。
      </para>
    </listitem>
    <listitem>
      <para>
        在<emphasis>并行索引扫描</emphasis>或<emphasis>并行索引唯一扫描</emphasis>中，
        合作进程轮流从索引中读取数据。
        目前，仅支持btree索引的并行索引扫描。
        每个进程将声明一个单个索引块，并扫描并返回该块引用的所有元组；
        其他进程同时可以从不同的索引块返回元组。
        并行btree扫描的结果将在每个工作进程内按排序顺序返回。
      </para>
    </listitem>
  </itemizedlist>

    其他扫描类型，如非btree索引的扫描，可能在将来支持并行扫描。
  </para>
<!-- pgdoc-cn_end sig_en=9e0ffb1d5073dea9bc3d12ba8d6b1c69 -->
 </sect2>

 <sect2 id="parallel-joins">
<!-- pgdoc-cn_start sig_en=546bb725dbb004c843214ce47d128dd8 sig_cn_org=None source=14.1 
  <title>Parallel Joins</title>
________________________________________________________-->
  <title>并行连接</title>
<!-- pgdoc-cn_end sig_en=546bb725dbb004c843214ce47d128dd8 -->

<!-- pgdoc-cn_start sig_en=17ebc99f78bfeb56544b74d9a25148ee sig_cn_org=None source=14.1 
  <para>
    Just as in a non-parallel plan, the driving table may be joined to one or
    more other tables using a nested loop, hash join, or merge join.  The
    inner side of the join may be any kind of non-parallel plan that is
    otherwise supported by the planner provided that it is safe to run within
    a parallel worker.  Depending on the join type, the inner side may also be
    a parallel plan.
  </para>
________________________________________________________-->
  <para>
    正如在非并行计划中那样，驱动表可能被使用嵌套循环、哈希连接或者归并连接连接到一个或者多个其他表。连接的内侧可以是任何类型的被规划器支持的非并行计划，假设它能够安全地在并行工作者中运行。根据连接类型，内侧还可以是一种并行计划。
  </para>
<!-- pgdoc-cn_end sig_en=17ebc99f78bfeb56544b74d9a25148ee -->

  <itemizedlist>
    <listitem>
<!-- pgdoc-cn_start sig_en=6c4b37b6833112fc68f638d26e4f6ddf sig_cn_org=None source=14.1 
      <para>
        In a <emphasis>nested loop join</emphasis>, the inner side is always
        non-parallel.  Although it is executed in full, this is efficient if
        the inner side is an index scan, because the outer tuples and thus
        the loops that look up values in the index are divided over the
        cooperating processes.
      </para>
________________________________________________________-->
      <para>
        在一个<emphasis>嵌套循环连接</emphasis>中，内侧总是非并行的。尽管它会被完全执行，如果内侧是一个索引扫描也会很高效，因为外侧元组以及在索引中查找值的循环会被划分到多个合作进程。
      </para>
<!-- pgdoc-cn_end sig_en=6c4b37b6833112fc68f638d26e4f6ddf -->
    </listitem>
    <listitem>
<!-- pgdoc-cn_start sig_en=028bd6826bf3bb3799c1770699df025b sig_cn_org=None source=14.1 
      <para>
        In a <emphasis>merge join</emphasis>, the inner side is always
        a non-parallel plan and therefore executed in full.  This may be
        inefficient, especially if a sort must be performed, because the work
        and resulting data are duplicated in every cooperating process.
      </para>
________________________________________________________-->
      <para>
        在一个<emphasis>归并连接</emphasis>中，内侧总是一个非并行计划并且因此会被完全执行。这可能是不太高效的，特别是在排序必须被执行时，因为在每一个合作进程中工作数据和结果数据是重复的。
      </para>
<!-- pgdoc-cn_end sig_en=028bd6826bf3bb3799c1770699df025b -->
    </listitem>
    <listitem>
<!-- pgdoc-cn_start sig_en=d136ed8bdfd1a19474b2bafe1142354e sig_cn_org=None source=14.1 
      <para>
        In a <emphasis>hash join</emphasis> (without the "parallel" prefix),
        the inner side is executed in full by every cooperating process
        to build identical copies of the hash table.  This may be inefficient
        if the hash table is large or the plan is expensive.  In a
        <emphasis>parallel hash join</emphasis>, the inner side is a
        <emphasis>parallel hash</emphasis> that divides the work of building
        a shared hash table over the cooperating processes.
      </para>
________________________________________________________-->
      <para>
        在一个<emphasis>哈希连接</emphasis>（没有“并行”前缀）中，每个合作进程都会完全执行内侧以构建哈希表的相同拷贝。如果哈希表很大或者该计划开销很大，这种方式就很低效。在一个<emphasis>并行哈希连接</emphasis>中，内侧是一个<emphasis>并行哈希</emphasis>，它把构建共享哈希表的工作划分到多个合作进程。
      </para>
<!-- pgdoc-cn_end sig_en=d136ed8bdfd1a19474b2bafe1142354e -->
    </listitem>
  </itemizedlist>
 </sect2>

 <sect2 id="parallel-aggregation">
<!-- pgdoc-cn_start sig_en=4c8d813b1a19c97f64a419875aa96b75 sig_cn_org=None source=14.1 
  <title>Parallel Aggregation</title>
________________________________________________________-->
  <title>并行聚集</title>
<!-- pgdoc-cn_end sig_en=4c8d813b1a19c97f64a419875aa96b75 -->
<!-- pgdoc-cn_start sig_en=7b397ca1cd6702c1eae7a48fc401278d sig_cn_org=None source=14.1 
  <para>
    <productname>PostgreSQL</productname> supports parallel aggregation by aggregating in
    two stages.  First, each process participating in the parallel portion of
    the query performs an aggregation step, producing a partial result for
    each group of which that process is aware.  This is reflected in the plan
    as a <literal>Partial Aggregate</literal> node.  Second, the partial results are
    transferred to the leader via <literal>Gather</literal> or <literal>Gather
    Merge</literal>.  Finally, the leader re-aggregates the results across all
    workers in order to produce the final result.  This is reflected in the
    plan as a <literal>Finalize Aggregate</literal> node.
  </para>
________________________________________________________-->
  <para>
    <productname>PostgreSQL</productname>通过按两个阶段进行聚集来支持并行聚集。首先，每个参与到查询并行部分的进程执行一个聚集步骤，为该进程注意到的每个分组产生一个部分结果。这在计划中反映为一个<literal>Partial Aggregate</literal>节点。然后，部分结果通过<literal>Gather</literal>或者<literal>Gather Merge</literal>被传输到领导者。最后，领导者对来自所有工作者的结果进行重新聚集得到最终的结果。这在计划中反映为一个<literal>Finalize Aggregate</literal>节点。
  </para>
<!-- pgdoc-cn_end sig_en=7b397ca1cd6702c1eae7a48fc401278d -->

<!-- pgdoc-cn_start sig_en=322513f6aee5702f44842aeafe9cc6de sig_cn_org=None source=14.1 
  <para>
    Because the <literal>Finalize Aggregate</literal> node runs on the leader
    process, queries that produce a relatively large number of groups in
    comparison to the number of input rows will appear less favorable to the
    query planner. For example, in the worst-case scenario the number of
    groups seen by the <literal>Finalize Aggregate</literal> node could be as many as
    the number of input rows that were seen by all worker processes in the
    <literal>Partial Aggregate</literal> stage. For such cases, there is clearly
    going to be no performance benefit to using parallel aggregation. The
    query planner takes this into account during the planning process and is
    unlikely to choose parallel aggregate in this scenario.
  </para>
________________________________________________________-->
  <para>
    因为<literal>Finalize Aggregate</literal>节点运行在领导者进程上，如果查询产生的分组数相对于其输入行数来说比较大，则查询规划器不会喜欢它。例如，在最坏的情况下，<literal>Finalize Aggregate</literal>节点看到的分组数可能与所有工作者进程在<literal>Partial Aggregate</literal>阶段看到的输入行数一样多。对于这类情况，使用并行聚集显然得不到性能收益。查询规划器会在规划过程中考虑这一点并且不太会在这种情况下选择并行聚集。
  </para>
<!-- pgdoc-cn_end sig_en=322513f6aee5702f44842aeafe9cc6de -->

<!-- pgdoc-cn_start sig_en=7c10b16eb6ba7200cf281379de1b9368 sig_cn_org=None source=14.1 
  <para>
    Parallel aggregation is not supported in all situations.  Each aggregate
    must be <link linkend="parallel-safety">safe</link> for parallelism and must
    have a combine function.  If the aggregate has a transition state of type
    <literal>internal</literal>, it must have serialization and deserialization
    functions.  See <xref linkend="sql-createaggregate"/> for more details.
    Parallel aggregation is not supported if any aggregate function call
    contains <literal>DISTINCT</literal> or <literal>ORDER BY</literal> clause and is also
    not supported for ordered set aggregates or when  the query involves
    <literal>GROUPING SETS</literal>.  It can only be used when all joins involved in
    the query are also part of the parallel portion of the plan.
  </para>
________________________________________________________-->
  <para>
    并行聚集并非在所有情况下都被支持。每一个聚集都必须是对并行<link linkend="parallel-safety">安全的</link>并且必须有一个组合函数。如果该聚集有一个类型为<literal>internal</literal>的转移状态，它必须有序列化和反序列化函数。更多细节请参考<xref linkend="sql-createaggregate"/>。如果任何聚集函数调用包含<literal>DISTINCT</literal>或<literal>ORDER BY</literal>子句，则不支持并行聚集。对于有序集聚集或者当查询涉及<literal>GROUPING SETS</literal>时，也不支持并行聚集。只有在查询中涉及的所有连接也是该计划并行部分的组成部分时，才能使用并行聚集。
  </para>
<!-- pgdoc-cn_end sig_en=7c10b16eb6ba7200cf281379de1b9368 -->

 </sect2>

 <sect2 id="parallel-append">
<!-- pgdoc-cn_start sig_en=2ded69d0684b9bcdc28abe39014bb985 sig_cn_org=None source=14.1 
  <title>Parallel Append</title>
________________________________________________________-->
  <title>并行Append</title>
<!-- pgdoc-cn_end sig_en=2ded69d0684b9bcdc28abe39014bb985 -->

<!-- pgdoc-cn_start sig_en=ef133fc22892f1dce13fa077d51cdd33 sig_cn_org=None source=14.1 
  <para>
    Whenever <productname>PostgreSQL</productname> needs to combine rows
    from multiple sources into a single result set, it uses an
    <literal>Append</literal> or <literal>MergeAppend</literal> plan node.
    This commonly happens when implementing <literal>UNION ALL</literal> or
    when scanning a partitioned table.  Such nodes can be used in parallel
    plans just as they can in any other plan.  However, in a parallel plan,
    the planner may instead use a <literal>Parallel Append</literal> node.
  </para>
________________________________________________________-->
  <para>
    只要当<productname>PostgreSQL</productname>需要从多个源中整合行到一个单一结果集时，它会使用<literal>Append</literal>或<literal>MergeAppend</literal>计划节点。在实现<literal>UNION ALL</literal>或扫描分区表时常常会发生这种情况。就像这些节点可以被用在任何其他计划中一样，它们可以被用在并行计划中。不过，在并行计划中，规划器使用的是<literal>Parallel Append</literal>节点。
  </para>
<!-- pgdoc-cn_end sig_en=ef133fc22892f1dce13fa077d51cdd33 -->

<!-- pgdoc-cn_start sig_en=43bd4c3263755064d643089be2a3bbae sig_cn_org=None source=14.1 
  <para>
    When an <literal>Append</literal> node is used in a parallel plan, each
    process will execute the child plans in the order in which they appear,
    so that all participating processes cooperate to execute the first child
    plan until it is complete and then move to the second plan at around the
    same time.  When a <literal>Parallel Append</literal> is used instead, the
    executor will instead spread out the participating processes as evenly as
    possible across its child plans, so that multiple child plans are executed
    simultaneously.  This avoids contention, and also avoids paying the startup
    cost of a child plan in those processes that never execute it.
  </para>
________________________________________________________-->
  <para>
    当一个<literal>Append</literal>节点被用在并行计划中时，每个进程将按照子计划出现的顺序执行子计划，这样所有的参与进程会合作执行第一个子计划直到它被完成，然后同时移动到第二个计划。而在使用<literal>Parallel Append</literal>时，执行器将把它的子计划尽可能均匀地散布在参与进程中，这样多个子计划会被同时执行。这避免了竞争，也避免了子计划在那些不执行它的进程中产生启动代价。
  </para>
<!-- pgdoc-cn_end sig_en=43bd4c3263755064d643089be2a3bbae -->

<!-- pgdoc-cn_start sig_en=b014cc6cc625a4e9f834f13c3661fe01 sig_cn_org=None source=14.1 
  <para>
    Also, unlike a regular <literal>Append</literal> node, which can only have
    partial children when used within a parallel plan, a <literal>Parallel
    Append</literal> node can have both partial and non-partial child plans.
    Non-partial children will be scanned by only a single process, since
    scanning them more than once would produce duplicate results.  Plans that
    involve appending multiple results sets can therefore achieve
    coarse-grained parallelism even when efficient partial plans are not
    available.  For example, consider a query against a partitioned table
    that can only be implemented efficiently by using an index that does
    not support parallel scans.  The planner might choose a <literal>Parallel
    Append</literal> of regular <literal>Index Scan</literal> plans; each
    individual index scan would have to be executed to completion by a single
    process, but different scans could be performed at the same time by
    different processes.
  </para>
________________________________________________________-->
  <para>
    此外，和常规的<literal>Append</literal>节点不同（在并行计划中使用时仅有部分子计划），<literal>Parallel Append</literal>节点既可以有部分子计划也可以有非部分子计划。非部分子计划将仅被单个进程扫描，因为扫描它们不止一次会产生重复的结果。因此涉及到追加多个结果集的计划即使在没有有效的部分计划可用时，也能实现粗粒度的并行。例如，考虑一个针对分区表的查询，它只能通过使用一个不支持并行扫描的索引来实现。规划器可能会选择常规<literal>Index Scan</literal>计划的<literal>Parallel Append</literal>。每个索引扫描必须被单一的进程执行完，但不同的扫描可以由不同的进程同时执行。
  </para>
<!-- pgdoc-cn_end sig_en=b014cc6cc625a4e9f834f13c3661fe01 -->

<!-- pgdoc-cn_start sig_en=043c96ccff0b232cf1bdadf823f0fd59 sig_cn_org=None source=14.1 
  <para>
    <xref linkend="guc-enable-parallel-append" /> can be used to disable
    this feature.
  </para>
________________________________________________________-->
  <para>
    <xref linkend="guc-enable-parallel-append" />可以被用来禁用这种特性。
  </para>
<!-- pgdoc-cn_end sig_en=043c96ccff0b232cf1bdadf823f0fd59 -->
 </sect2>

 <sect2 id="parallel-plan-tips">
<!-- pgdoc-cn_start sig_en=444887369169ca649dc6af4ea0f7674e sig_cn_org=None source=14.1 
  <title>Parallel Plan Tips</title>
________________________________________________________-->
  <title>并行计划小贴士</title>
<!-- pgdoc-cn_end sig_en=444887369169ca649dc6af4ea0f7674e -->

<!-- pgdoc-cn_start sig_en=f821c08137ef20507755d42945d849ef sig_cn_org=None source=14.1 
  <para>
    If a query that is expected to do so does not produce a parallel plan,
    you can try reducing <xref linkend="guc-parallel-setup-cost"/> or
    <xref linkend="guc-parallel-tuple-cost"/>.  Of course, this plan may turn
    out to be slower than the serial plan that the planner preferred, but
    this will not always be the case.  If you don't get a parallel
    plan even with very small values of these settings (e.g., after setting
    them both to zero), there may be some reason why the query planner is
    unable to generate a parallel plan for your query.  See
    <xref linkend="when-can-parallel-query-be-used"/> and
    <xref linkend="parallel-safety"/> for information on why this may be
    the case.
  </para>
________________________________________________________-->
  <para>
    如果我们想要一个查询能产生并行计划但事实上又没有产生，可以尝试减小<xref linkend="guc-parallel-setup-cost"/>或者<xref linkend="guc-parallel-tuple-cost"/>。当然，这个计划可能比规划器优先产生的顺序计划还要慢，但也不总是如此。如果将这些设置为很小的值（例如把它们设置为零）也不能得到并行计划，那就可能是有某种原因导致查询规划器无法为你的查询产生并行计划。可能的原因可见<xref linkend="when-can-parallel-query-be-used"/>和<xref linkend="parallel-safety"/>。
  </para>
<!-- pgdoc-cn_end sig_en=f821c08137ef20507755d42945d849ef -->

<!-- pgdoc-cn_start sig_en=a2275e27dd3fed2755f75263fb2d3ea5 sig_cn_org=None source=14.1 
  <para>
    When executing a parallel plan, you can use <literal>EXPLAIN (ANALYZE,
    VERBOSE)</literal> to display per-worker statistics for each plan node.
    This may be useful in determining whether the work is being evenly
    distributed between all plan nodes and more generally in understanding the
    performance characteristics of the plan.
  </para>
________________________________________________________-->
  <para>
    在执行一个并行计划时，可以用<literal>EXPLAIN (ANALYZE,VERBOSE)</literal>来显示每个计划节点在每个工作者上的统计信息。这些信息有助于确定是否所有的工作被均匀地分发到所有计划节点以及从总体上理解计划的性能特点。
  </para>
<!-- pgdoc-cn_end sig_en=a2275e27dd3fed2755f75263fb2d3ea5 -->

 </sect2>
 </sect1>

 <sect1 id="parallel-safety">
<!-- pgdoc-cn_start sig_en=f7eaf5bef7d75486511c6bc9f13aaea1 sig_cn_org=None source=14.1 
  <title>Parallel Safety</title>
________________________________________________________-->
  <title>并行安全性</title>
<!-- pgdoc-cn_end sig_en=f7eaf5bef7d75486511c6bc9f13aaea1 -->

<!-- pgdoc-cn_start sig_en=ab06e46b9c6c9d2cefd7244d99a261b7 sig_cn_org=None source=14.1 
  <para>
    The planner classifies operations involved in a query as either
    <firstterm>parallel safe</firstterm>, <firstterm>parallel restricted</firstterm>,
    or <firstterm>parallel unsafe</firstterm>.  A parallel safe operation is one that
    does not conflict with the use of parallel query.  A parallel restricted
    operation is one that cannot be performed in a parallel worker, but that
    can be performed in the leader while parallel query is in use.  Therefore,
    parallel restricted operations can never occur below a <literal>Gather</literal>
    or <literal>Gather Merge</literal> node, but can occur elsewhere in a plan that
    contains such a node.  A parallel unsafe operation is one that cannot
    be performed while parallel query is in use, not even in the leader.
    When a query contains anything that is parallel unsafe, parallel query
    is completely disabled for that query.
  </para>
________________________________________________________-->
  <para>
    规划器把查询中涉及的操作分类成<firstterm>并行安全</firstterm>、<firstterm>并行受限</firstterm>或者<firstterm>并行不安全</firstterm>。并行安全的操作不会与并行查询的使用产生冲突。并行受限的操作不能在并行工作者中执行，但是能够在并行查询的领导者中执行。因此，并行受限的操作不能出现在<literal>Gather</literal>或者<literal>Gather Merge</literal>节点之下，但是能够出现在包含这类节点的计划的其他位置。并行不安全的操作不能在并行查询中执行，甚至不能在领导者中执行。当一个查询包含任何并行不安全操作时，并行查询对这个查询是完全被禁用的。
  </para>
<!-- pgdoc-cn_end sig_en=ab06e46b9c6c9d2cefd7244d99a261b7 -->

<!-- pgdoc-cn_start sig_en=e9b1a502e8abb2f9a9513b2f4e06e418 sig_cn_org=None source=14.1 
  <para>
    The following operations are always parallel restricted:
  </para>
________________________________________________________-->
  <para>
    下面的操作总是并行受限的。
  </para>
<!-- pgdoc-cn_end sig_en=e9b1a502e8abb2f9a9513b2f4e06e418 -->

  <itemizedlist>
    <listitem>
<!-- pgdoc-cn_start sig_en=00f82d95bf1321e8c487fae23737c562 sig_cn_org=None source=14.1 
      <para>
        Scans of common table expressions (CTEs).
      </para>
________________________________________________________-->
      <para>
        公共表表达式（CTE）的扫描。
      </para>
<!-- pgdoc-cn_end sig_en=00f82d95bf1321e8c487fae23737c562 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=4425241f3936dc17bc3506fa8ba5b88e sig_cn_org=None source=14.1 
      <para>
        Scans of temporary tables.
      </para>
________________________________________________________-->
      <para>
        临时表的扫描。
      </para>
<!-- pgdoc-cn_end sig_en=4425241f3936dc17bc3506fa8ba5b88e -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=a2e70ff47094dd54699ad6070b634f63 sig_cn_org=None source=14.1 
      <para>
        Scans of foreign tables, unless the foreign data wrapper has
        an <literal>IsForeignScanParallelSafe</literal> API that indicates otherwise.
      </para>
________________________________________________________-->
      <para>
        外部表的扫描，除非外部数据包装器有一个<literal>IsForeignScanParallelSafe</literal> API。
      </para>
<!-- pgdoc-cn_end sig_en=a2e70ff47094dd54699ad6070b634f63 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=5f0e450c84ac7c34186ff35bdc505256 sig_cn_org=None source=14.1 
      <para>
        Plan nodes to which an <literal>InitPlan</literal> is attached.
      </para>
________________________________________________________-->
      <para>
        <literal>InitPlan</literal>所挂接到的计划节点。
      </para>
<!-- pgdoc-cn_end sig_en=5f0e450c84ac7c34186ff35bdc505256 -->
    </listitem>

    <listitem>
<!-- pgdoc-cn_start sig_en=0e13e7b9e12521df011d04681b77760f sig_cn_org=None source=14.1 
      <para>
        Plan nodes that reference a correlated <literal>SubPlan</literal>.
      </para>
________________________________________________________-->
      <para>
        引用一个相关的<literal>SubPlan</literal>的计划节点。
      </para>
<!-- pgdoc-cn_end sig_en=0e13e7b9e12521df011d04681b77760f -->
    </listitem>
  </itemizedlist>

 <sect2 id="parallel-labeling">
<!-- pgdoc-cn_start sig_en=47295e52c15e27a66651a50dca9b3825 sig_cn_org=None source=14.1 
  <title>Parallel Labeling for Functions and Aggregates</title>
________________________________________________________-->
  <title>为函数和聚集加并行标签</title>
<!-- pgdoc-cn_end sig_en=47295e52c15e27a66651a50dca9b3825 -->

<!-- pgdoc-cn_start sig_en=4ccb9a6c434d51035cb3f589f1163a96 sig_cn_org=None source=14.1 
  <para>
    The planner cannot automatically determine whether a user-defined
    function or aggregate is parallel safe, parallel restricted, or parallel
    unsafe, because this would require predicting every operation that the
    function could possibly perform.  In general, this is equivalent to the
    Halting Problem and therefore impossible.  Even for simple functions
    where it could conceivably be done, we do not try, since this would be expensive
    and error-prone.  Instead, all user-defined functions are assumed to
    be parallel unsafe unless otherwise marked.  When using
    <xref linkend="sql-createfunction"/> or
    <xref linkend="sql-alterfunction"/>, markings can be set by specifying
    <literal>PARALLEL SAFE</literal>, <literal>PARALLEL RESTRICTED</literal>, or
    <literal>PARALLEL UNSAFE</literal> as appropriate.  When using
    <xref linkend="sql-createaggregate"/>, the
    <literal>PARALLEL</literal> option can be specified with <literal>SAFE</literal>,
    <literal>RESTRICTED</literal>, or <literal>UNSAFE</literal> as the corresponding value.
  </para>
________________________________________________________-->
  <para>
    规划器无法自动判定一个用户定义的函数或者聚集是并行安全、并行受限还是并行不安全，因为这需要预测函数可能执行的每一个操作。一般而言，这就相当于一个停机问题，因此是不可能的。甚至对于可以做到判定的简单函数我们也不会尝试，因为那会非常昂贵而且容易出错。相反，除非是被标记出来，所有用户定义的函数都被认为是并行不安全的。在使用<xref linkend="sql-createfunction"/>或者<xref linkend="sql-alterfunction"/>时，可以通过指定<literal>PARALLEL SAFE</literal>、<literal>PARALLEL RESTRICTED</literal>或者<literal>PARALLEL UNSAFE</literal>来设置标记 。在使用<xref linkend="sql-createaggregate"/>时，<literal>PARALLEL</literal>选项可以被指定为<literal>SAFE</literal>、<literal>RESTRICTED</literal>或者 <literal>UNSAFE</literal>。
  </para>
<!-- pgdoc-cn_end sig_en=4ccb9a6c434d51035cb3f589f1163a96 -->

<!-- pgdoc-cn_start sig_en=9d5dc38cf8aa0a6e2c0b25b1fd652ae3 sig_cn_org=None source=14.1 
  <para>
    Functions and aggregates must be marked <literal>PARALLEL UNSAFE</literal> if
    they write to the database, access sequences, change the transaction state
    even temporarily (e.g., a PL/pgSQL function that establishes an
    <literal>EXCEPTION</literal> block to catch errors), or make persistent changes to
    settings.  Similarly, functions must be marked <literal>PARALLEL
    RESTRICTED</literal> if they access temporary tables, client connection state,
    cursors, prepared statements, or miscellaneous backend-local state that
    the system cannot synchronize across workers. For example,
    <literal>setseed</literal> and <literal>random</literal> are parallel restricted for
    this last reason.
  </para>
________________________________________________________-->
  <para>
    如果函数和聚集会写数据库、访问序列、改变事务状态（即便是临时改变，例如建立一个<literal>EXCEPTION</literal>块来捕捉错误的 PL/pgsql）或者对设置做持久化的更改，它们一定要被标记为<literal>PARALLEL UNSAFE</literal>。类似地，如果函数会访问临时表、客户端连接状态、游标、预备语句或者系统无法在工作者之间同步的后端本地状态，它们必须被标记为<literal>PARALLEL RESTRICTED</literal>。例如，<literal>setseed</literal>和 <literal>random</literal>由于后一种原因而是并行受限的。
  </para>
<!-- pgdoc-cn_end sig_en=9d5dc38cf8aa0a6e2c0b25b1fd652ae3 -->

<!-- pgdoc-cn_start sig_en=d7d7771714c53cd224f1717374b037f4 sig_cn_org=None source=14.1 
  <para>
    In general, if a function is labeled as being safe when it is restricted or
    unsafe, or if it is labeled as being restricted when it is in fact unsafe,
    it may throw errors or produce wrong answers when used in a parallel query.
    C-language functions could in theory exhibit totally undefined behavior if
    mislabeled, since there is no way for the system to protect itself against
    arbitrary C code, but in most likely cases the result will be no worse than
    for any other function. If in doubt, it is probably best to label functions
    as <literal>UNSAFE</literal>.
  </para>
________________________________________________________-->
  <para>
    一般而言，如果一个函数是受限或者不安全的却被标记为安全，或者它实际是不安全的却被标记为受限，把它用在并行查询中时可能会抛出错误或者产生错误的回答。如果 C 语言函数被错误标记，理论上它会展现出完全不明确的行为，因为系统中无法保护自身不受任意 C 代码的影响。但是，在最有可能的情况下，结果不会比其他任何函数更糟糕。如果有疑虑，最好还是标记函数为<literal>UNSAFE</literal>。
  </para>
<!-- pgdoc-cn_end sig_en=d7d7771714c53cd224f1717374b037f4 -->

<!-- pgdoc-cn_start sig_en=6c0e84770eaab317d756949126fd0396 sig_cn_org=None source=14.1 
  <para>
    If a function executed within a parallel worker acquires locks that are
    not held by the leader, for example by querying a table not referenced in
    the query, those locks will be released at worker exit, not end of
    transaction. If you write a function that does this, and this behavior
    difference is important to you, mark such functions as
    <literal>PARALLEL RESTRICTED</literal>
    to ensure that they execute only in the leader.
  </para>
________________________________________________________-->
  <para>
    如果在并行工作者中执行的函数要求领导者没有持有的锁，例如读该查询中没有引用的表，那么工作者退出时会释放那些锁（而不是在事务结束时释放）。如果你写了一个这样做的函数并且这种不同的行为对你很重要，把这类函数标记为<literal>PARALLEL RESTRICTED</literal>以确保它们只在领导者中执行。
  </para>
<!-- pgdoc-cn_end sig_en=6c0e84770eaab317d756949126fd0396 -->

<!-- pgdoc-cn_start sig_en=ecb7bfdbbdd3a395ab19bfecca42ee2a sig_cn_org=None source=14.1 
  <para>
    Note that the query planner does not consider deferring the evaluation of
    parallel-restricted functions or aggregates involved in the query in
    order to obtain a superior plan.  So, for example, if a <literal>WHERE</literal>
    clause applied to a particular table is parallel restricted, the query
    planner will not consider performing a scan of that table in the parallel
    portion of a plan.  In some cases, it would be
    possible (and perhaps even efficient) to include the scan of that table in
    the parallel portion of the query and defer the evaluation of the
    <literal>WHERE</literal> clause so that it happens above the <literal>Gather</literal>
    node.  However, the planner does not do this.
  </para>
________________________________________________________-->
  <para>
    注意查询规划器不会为了获取一个更好的计划而考虑延迟计算并行受限的函数或者聚集。所以，如果一个被应用到特定表的<literal>WHERE</literal>子句是并行受限的，查询规划器就不会考虑对处于计划并行部分的表执行一次扫描。在一些情况中，可以（甚至效率更高）把对表的扫描包括在查询的并行部分并且延迟对<literal>WHERE</literal>子句的计算，这样它会出现在<literal>Gather</literal>节点之上。不过，规划器不会这样做。
  </para>
<!-- pgdoc-cn_end sig_en=ecb7bfdbbdd3a395ab19bfecca42ee2a -->

 </sect2>

 </sect1>

 </chapter>
