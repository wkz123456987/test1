<!-- doc/src/sgml/ddl.sgml -->

<chapter id="ddl">
<!-- pgdoc-cn_start sig_en=8945b9735f5357191ddc2eb932e4f74e sig_cn_org=None source=14.1 
 <title>Data Definition</title>
________________________________________________________-->
 <title>数据定义</title>
<!-- pgdoc-cn_end sig_en=8945b9735f5357191ddc2eb932e4f74e -->

<!-- pgdoc-cn_start sig_en=b35e108180242fcc79d73d0812b66ac8 sig_cn_org=None source=14.1 
 <para>
  This chapter covers how one creates the database structures that
  will hold one's data.  In a relational database, the raw data is
  stored in tables, so the majority of this chapter is devoted to
  explaining how tables are created and modified and what features are
  available to control what data is stored in the tables.
  Subsequently, we discuss how tables can be organized into
  schemas, and how privileges can be assigned to tables.  Finally,
  we will briefly look at other features that affect the data storage,
  such as inheritance, table partitioning, views, functions, and
  triggers.
 </para>
________________________________________________________-->
 <para>
  本章包含了如何创建用来保存数据的数据库结构。在一个关系型数据库中，原始数据被存储在表中，因此本章的主要工作就是解释如何创建和修改表，以及哪些特性可以控制何种数据会被存储在表中。接着，我们讨论表如何被组织成模式，以及如何将权限分配给表。最后，我们将将简短地介绍其他一些影响数据存储的特性，例如继承、表分区、视图、函数和触发器。
 </para>
<!-- pgdoc-cn_end sig_en=b35e108180242fcc79d73d0812b66ac8 -->

 <sect1 id="ddl-basics">
<!-- pgdoc-cn_start sig_en=af6749d5857620d3d20b76799797eba2 sig_cn_org=None source=14.1 
  <title>Table Basics</title>
________________________________________________________-->
  <title>表基础</title>
<!-- pgdoc-cn_end sig_en=af6749d5857620d3d20b76799797eba2 -->

<!-- pgdoc-cn_start sig_en=4f6025dad8b6ed94f5e468844cd015e1 sig_cn_org=None source=14.1 
  <indexterm zone="ddl-basics">
   <primary>table</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="ddl-basics">
   <primary>table</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=4f6025dad8b6ed94f5e468844cd015e1 -->

<!-- pgdoc-cn_start sig_en=2223a7d48296dd52deca6fb5423d3d3c sig_cn_org=None source=14.1 
  <indexterm>
   <primary>row</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>row</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=2223a7d48296dd52deca6fb5423d3d3c -->

<!-- pgdoc-cn_start sig_en=2e4ffb8f82e5907f5a40a1f215bbfa9f sig_cn_org=None source=14.1 
  <indexterm>
   <primary>column</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>column</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=2e4ffb8f82e5907f5a40a1f215bbfa9f -->

<!-- pgdoc-cn_start sig_en=33bb1aa7bddfe3b2988372dfbc5d430a sig_cn_org=None source=14.1 
  <para>
   A table in a relational database is much like a table on paper: It
   consists of rows and columns.  The number and order of the columns
   is fixed, and each column has a name.  The number of rows is
   variable &mdash; it reflects how much data is stored at a given moment.
   SQL does not make any guarantees about the order of the rows in a
   table.  When a table is read, the rows will appear in an unspecified order,
   unless sorting is explicitly requested.  This is covered in <xref
   linkend="queries"/>.  Furthermore, SQL does not assign unique
   identifiers to rows, so it is possible to have several completely
   identical rows in a table.  This is a consequence of the
   mathematical model that underlies SQL but is usually not desirable.
   Later in this chapter we will see how to deal with this issue.
  </para>
________________________________________________________-->
  <para>
   关系型数据库中的一个表非常像纸上的一张表：它由行和列组成。列的数量和顺序是固定的，并且每一列拥有一个名字。行的数目是变化的，它反映了在一个给定时刻表中存储的数据量。SQL并不保证表中行的顺序。当一个表被读取时，表中的行将以非特定顺序出现，除非明确地指定需要排序。这些将在<xref linkend="queries"/>介绍。此外，SQL不会为行分配唯一的标识符，因此在一个表中可能会存在一些完全相同的行。这是SQL之下的数学模型导致的结果，但并不是所期望的。稍后在本章中我们将看到如何处理这种问题。
  </para>
<!-- pgdoc-cn_end sig_en=33bb1aa7bddfe3b2988372dfbc5d430a -->

<!-- pgdoc-cn_start sig_en=3ba2d369190442f08a0103886360c329 sig_cn_org=None source=14.1 
  <para>
   Each column has a data type.  The data type constrains the set of
   possible values that can be assigned to a column and assigns
   semantics to the data stored in the column so that it can be used
   for computations.  For instance, a column declared to be of a
   numerical type will not accept arbitrary text strings, and the data
   stored in such a column can be used for mathematical computations.
   By contrast, a column declared to be of a character string type
   will accept almost any kind of data but it does not lend itself to
   mathematical calculations, although other operations such as string
   concatenation are available.
  </para>
________________________________________________________-->
  <para>
   每一列都有一个数据类型。数据类型约束着一组可以分配给列的可能值，并且它为列中存储的数据赋予了语义，这样它可以用于计算。例如，一个被声明为数字类型的列将不会接受任何文本串，而存储在这样一列中的数据可以用来进行数学计算。反过来，一个被声明为字符串类型的列将接受几乎任何一种的数据，它可以进行如字符串连接的操作但不允许进行数学计算。
  </para>
<!-- pgdoc-cn_end sig_en=3ba2d369190442f08a0103886360c329 -->

<!-- pgdoc-cn_start sig_en=4bfb4e043fb6d71b5c2921dff9617ecf sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> includes a sizable set of
   built-in data types that fit many applications.  Users can also
   define their own data types.  Most built-in data types have obvious
   names and semantics, so we defer a detailed explanation to <xref
   linkend="datatype"/>.  Some of the frequently used data types are
   <type>integer</type> for whole numbers, <type>numeric</type> for
   possibly fractional numbers, <type>text</type> for character
   strings, <type>date</type> for dates, <type>time</type> for
   time-of-day values, and <type>timestamp</type> for values
   containing both date and time.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>包括了相当多的内建数据类型，可以适用于很多应用。用户也可以定义他们自己的数据类型。大部分内建数据类型有着显而易见的名称和语义，所以我们将它们的详细解释放在<xref linkend="datatype"/>中。一些常用的数据类型是：用于整数的<type>integer</type>；可以用于分数的<type>numeric</type>；用于字符串的<type>text</type>，用于日期的<type>date</type>，用于一天内时间的<type>time</type>以及可以同时包含日期和时间的<type>timestamp</type>。
  </para>
<!-- pgdoc-cn_end sig_en=4bfb4e043fb6d71b5c2921dff9617ecf -->

<!-- pgdoc-cn_start sig_en=467c80cf52ed8301a78828e10422ee35 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>table</primary>
   <secondary>creating</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>table</primary>
   <secondary>creating</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=467c80cf52ed8301a78828e10422ee35 -->

<!-- pgdoc-cn_start sig_en=ae9f73349d52dd195311642480c52b4d sig_cn_org=None source=14.1 
  <para>
   To create a table, you use the aptly named <xref
   linkend="sql-createtable"/> command.
   In this command you specify at least a name for the new table, the
   names of the columns and the data type of each column.  For
   example:
<programlisting>
CREATE TABLE my_first_table (
    first_column text,
    second_column integer
);
</programlisting>
   This creates a table named <literal>my_first_table</literal> with
   two columns.  The first column is named
   <literal>first_column</literal> and has a data type of
   <type>text</type>; the second column has the name
   <literal>second_column</literal> and the type <type>integer</type>.
   The table and column names follow the identifier syntax explained
   in <xref linkend="sql-syntax-identifiers"/>.  The type names are
   usually also identifiers, but there are some exceptions.  Note that the
   column list is comma-separated and surrounded by parentheses.
  </para>
________________________________________________________-->
  <para>
   要创建一个表，我们要用到<xref linkend="sql-createtable"/>命令。在这个命令中 我们需要为新表至少指定一个名字、列的名字及数据类型。例如：
<programlisting>
CREATE TABLE my_first_table (
    first_column text,
    second_column integer
);
</programlisting>
   这将创建一个名为<literal>my_first_table</literal>的表，它拥有两个列。第一个列名为<literal>first_column</literal>且数据类型为<type>text</type>；第二个列名为<literal>second_column</literal>且数据类型为<type>integer</type>。表和列的名字遵循<xref linkend="sql-syntax-identifiers"/>中解释的标识符语法。类型名称通常也是标识符，但是也有些例外。注意列的列表由逗号分隔并被圆括号包围。
  </para>
<!-- pgdoc-cn_end sig_en=ae9f73349d52dd195311642480c52b4d -->

<!-- pgdoc-cn_start sig_en=b6c2f8e448d5822ce2794be4b4c08270 sig_cn_org=None source=14.1 
  <para>
   Of course, the previous example was heavily contrived.  Normally,
   you would give names to your tables and columns that convey what
   kind of data they store.  So let's look at a more realistic
   example:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric
);
</programlisting>
   (The <type>numeric</type> type can store fractional components, as
   would be typical of monetary amounts.)
  </para>
________________________________________________________-->
  <para>
   当然，前面的例子是非常不自然的。通常，我们为表和列赋予的名称都会表明它们存储着什么类别的数据。因此让我们再看一个更现实的例子：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric
);
</programlisting>
   （<type>numeric</type>类型能够存储小数部分，典型的例子是金额。）
  </para>
<!-- pgdoc-cn_end sig_en=b6c2f8e448d5822ce2794be4b4c08270 -->

  <tip>
<!-- pgdoc-cn_start sig_en=90103fec8d40eb30d299d2637ddd4687 sig_cn_org=None source=14.1 
   <para>
    When you create many interrelated tables it is wise to choose a
    consistent naming pattern for the tables and columns.  For
    instance, there is a choice of using singular or plural nouns for
    table names, both of which are favored by some theorist or other.
   </para>
________________________________________________________-->
   <para>
    当我们创建很多相关的表时，最好为表和列选择一致的命名模式。例如，一种选择是用单数或复数名词作为表名，每一种都受到一些理论家支持。
   </para>
<!-- pgdoc-cn_end sig_en=90103fec8d40eb30d299d2637ddd4687 -->
  </tip>

<!-- pgdoc-cn_start sig_en=c8380139a137e26f63c5431e05e120cd sig_cn_org=None source=14.1 
  <para>
   There is a limit on how many columns a table can contain.
   Depending on the column types, it is between 250 and 1600.
   However, defining a table with anywhere near this many columns is
   highly unusual and often a questionable design.
  </para>
________________________________________________________-->
  <para>
   一个表能够拥有的列的数据是有限的，根据列的类型，这个限制介于250和1600之间。但是，极少会定义一个接近这个限制的表，即便有也是一个值的商榷的设计。
  </para>
<!-- pgdoc-cn_end sig_en=c8380139a137e26f63c5431e05e120cd -->

<!-- pgdoc-cn_start sig_en=feac2435c643981804a12f7c849e37db sig_cn_org=None source=14.1 
  <indexterm>
   <primary>table</primary>
   <secondary>removing</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>table</primary>
   <secondary>removing</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=feac2435c643981804a12f7c849e37db -->

<!-- pgdoc-cn_start sig_en=6f35c31487abc93c29b4e43cc76e2ecf sig_cn_org=None source=14.1 
  <para>
   If you no longer need a table, you can remove it using the <xref
   linkend="sql-droptable"/> command.
   For example:
<programlisting>
DROP TABLE my_first_table;
DROP TABLE products;
</programlisting>
   Attempting to drop a table that does not exist is an error.
   Nevertheless, it is common in SQL script files to unconditionally
   try to drop each table before creating it, ignoring any error
   messages, so that the script works whether or not the table exists.
   (If you like, you can use the <literal>DROP TABLE IF EXISTS</literal> variant
   to avoid the error messages, but this is not standard SQL.)
  </para>
________________________________________________________-->
  <para>
   如果我们不再需要一个表，我们可以通过使用<xref
   linkend="sql-droptable"/>命令来移除它。例如：
<programlisting>
DROP TABLE my_first_table;
DROP TABLE products;
</programlisting>
   尝试移除一个不存在的表会引起错误。然而，在SQL脚本中在创建每个表之前无条件地尝试移除它的做法是很常见的，即使发生错误也会忽略之，因此这样的脚本可以在表存在和不存在时都工作得很好（如果你喜欢，可以使用<literal>DROP TABLE IF EXISTS</literal>变体来防止出现错误消息，但这并非标准SQL）。
  </para>
<!-- pgdoc-cn_end sig_en=6f35c31487abc93c29b4e43cc76e2ecf -->

<!-- pgdoc-cn_start sig_en=6593750ebfa815d1ab797513c31095f5 sig_cn_org=None source=14.1 
  <para>
   If you need to modify a table that already exists, see <xref
   linkend="ddl-alter"/> later in this chapter.
  </para>
________________________________________________________-->
  <para>
   如果我们需要修改一个已经存在的表，请参考本章稍后的<xref
   linkend="ddl-alter"/>。
  </para>
<!-- pgdoc-cn_end sig_en=6593750ebfa815d1ab797513c31095f5 -->

<!-- pgdoc-cn_start sig_en=0d015bc913b8a0bf91b892ad8a7321b9 sig_cn_org=None source=14.1 
  <para>
   With the tools discussed so far you can create fully functional
   tables.  The remainder of this chapter is concerned with adding
   features to the table definition to ensure data integrity,
   security, or convenience.  If you are eager to fill your tables with
   data now you can skip ahead to <xref linkend="dml"/> and read the
   rest of this chapter later.
  </para>
________________________________________________________-->
  <para>
   利用到目前为止所讨论的工具，我们可以创建一个全功能的表。本章的后续部分将集中于为表定义增加特性来保证数据完整性、安全性或方便。如果你希望现在就去填充你的表，你可以跳过这些直接去<xref linkend="dml"/>。
  </para>
<!-- pgdoc-cn_end sig_en=0d015bc913b8a0bf91b892ad8a7321b9 -->
 </sect1>

 <sect1 id="ddl-default">
<!-- pgdoc-cn_start sig_en=29a366227e458983cc94a3fa91767d07 sig_cn_org=None source=14.1 
  <title>Default Values</title>
________________________________________________________-->
  <title>默认值</title>
<!-- pgdoc-cn_end sig_en=29a366227e458983cc94a3fa91767d07 -->

<!-- pgdoc-cn_start sig_en=9686fb520ae3c8dc6d7a963000a7a5d8 sig_cn_org=None source=14.1 
  <indexterm zone="ddl-default">
   <primary>default value</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="ddl-default">
   <primary>default value</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=9686fb520ae3c8dc6d7a963000a7a5d8 -->

<!-- pgdoc-cn_start sig_en=052c2d9ef6290d78d4fc30cd67c1716e sig_cn_org=None source=14.1 
  <para>
   A column can be assigned a default value.  When a new row is
   created and no values are specified for some of the columns, those
   columns will be filled with their respective default values.  A
   data manipulation command can also request explicitly that a column
   be set to its default value, without having to know what that value is.
   (Details about data manipulation commands are in <xref linkend="dml"/>.)
  </para>
________________________________________________________-->
  <para>
   一个列可以被分配一个默认值。当一个新行被创建且没有为某些列指定值时，这些列将会被它们相应的默认值填充。一个数据操纵命令也可以显式地要求一个列被置为它的默认值，而不需要知道这个值到底是什么（数据操纵命令详见<xref linkend="dml"/>）。
  </para>
<!-- pgdoc-cn_end sig_en=052c2d9ef6290d78d4fc30cd67c1716e -->

<!-- pgdoc-cn_start sig_en=63381ff12b6aa70189daee50915a11b4 sig_cn_org=None source=14.1 
  <para>
   <indexterm><primary>null value</primary><secondary>default value</secondary></indexterm>
   If no default value is declared explicitly, the default value is the
   null value.  This usually makes sense because a null value can
   be considered to represent unknown data.
  </para>
________________________________________________________-->
  <para>
   <indexterm><primary>null value</primary><secondary>default value</secondary></indexterm>
   如果没有显式指定默认值，则默认值是空值。这是合理的，因为空值表示未知数据。
  </para>
<!-- pgdoc-cn_end sig_en=63381ff12b6aa70189daee50915a11b4 -->

<!-- pgdoc-cn_start sig_en=776c1629f33052f0fcbf2bf9fd025e23 sig_cn_org=None source=14.1 
  <para>
   In a table definition, default values are listed after the column
   data type.  For example:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>DEFAULT 9.99</emphasis>
);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   在一个表定义中，默认值被列在列的数据类型之后。例如：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>DEFAULT 9.99</emphasis>
);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=776c1629f33052f0fcbf2bf9fd025e23 -->

<!-- pgdoc-cn_start sig_en=209b1ee99490419e992aa69f4ab85fd6 sig_cn_org=None source=14.1 
  <para>
   The default value can be an expression, which will be
   evaluated whenever the default value is inserted
   (<emphasis>not</emphasis> when the table is created).  A common example
   is for a <type>timestamp</type> column to have a default of <literal>CURRENT_TIMESTAMP</literal>,
   so that it gets set to the time of row insertion.  Another common
   example is generating a <quote>serial number</quote> for each row.
   In <productname>PostgreSQL</productname> this is typically done by
   something like:
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>DEFAULT nextval('products_product_no_seq')</emphasis>,
    ...
);
</programlisting>
   where the <literal>nextval()</literal> function supplies successive values
   from a <firstterm>sequence object</firstterm> (see <xref
   linkend="functions-sequence"/>). This arrangement is sufficiently common
   that there's a special shorthand for it:
<programlisting>
CREATE TABLE products (
    product_no <emphasis>SERIAL</emphasis>,
    ...
);
</programlisting>
   The <literal>SERIAL</literal> shorthand is discussed further in <xref
   linkend="datatype-serial"/>.
  </para>
________________________________________________________-->
  <para>
   默认值可以是一个表达式，它将在任何需要插入默认值的时候被实时计算（<emphasis>不</emphasis>是表创建时）。一个常见的例子是为一个<type>timestamp</type>列指定默认值为<literal>CURRENT_TIMESTAMP</literal>，这样它将得到行被插入时的时间。另一个常见的例子是为每一行生成一个<quote>序列号</quote> 。这在<productname>PostgreSQL</productname>可以按照如下方式实现：
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>DEFAULT nextval('products_product_no_seq')</emphasis>,
    ...
);
</programlisting>
   这里<literal>nextval()</literal>函数从一个<firstterm>序列对象</firstterm><xref linkend="functions-sequence"/>）。还有一种特别的速写：
<programlisting>
CREATE TABLE products (
    product_no <emphasis>SERIAL</emphasis>,
    ...
);
</programlisting>
   <literal>SERIAL</literal>速写将在<xref
   linkend="datatype-serial"/>进一步讨论。
  </para>
<!-- pgdoc-cn_end sig_en=209b1ee99490419e992aa69f4ab85fd6 -->
 </sect1>

 <sect1 id="ddl-generated-columns">
<!-- pgdoc-cn_start sig_en=a45a8965a5cd9b3db4869bda7f83fb5c sig_cn_org=None source=14.1 
  <title>Generated Columns</title>
________________________________________________________-->
  <title>生成列</title>
<!-- pgdoc-cn_end sig_en=a45a8965a5cd9b3db4869bda7f83fb5c -->

<!-- pgdoc-cn_start sig_en=f487f30fc9dba55b867b07a30d06d85b sig_cn_org=None source=14.1 
  <indexterm zone="ddl-generated-columns">
   <primary>generated column</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="ddl-generated-columns">
   <primary>generated column</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=f487f30fc9dba55b867b07a30d06d85b -->

<!-- pgdoc-cn_start sig_en=4524419db99f4185ea71f04939d9638d sig_cn_org=None source=14.1 
  <para>
   A generated column is a special column that is always computed from other
   columns.  Thus, it is for columns what a view is for tables.  There are two
   kinds of generated columns: stored and virtual.  A stored generated column
   is computed when it is written (inserted or updated) and occupies storage
   as if it were a normal column.  A virtual generated column occupies no
   storage and is computed when it is read.  Thus, a virtual generated column
   is similar to a view and a stored generated column is similar to a
   materialized view (except that it is always updated automatically).
   PostgreSQL currently implements only stored generated columns.
  </para>
________________________________________________________-->
  <para>
   生成的列是一个特殊的列，它总是从其他列计算而来。因此说，它对于列就像视图对于表一样。生成列有两种:存储列和虚拟列。
   存储生成列在写入(插入或更新)时计算，并且像普通列一样占用存储空间。虚拟生成列不占用存储空间并且在读取时进行计算。
   如此看来，虚拟生成列类似于视图，存储生成列类似于物化视图(除了它总是自动更新之外)。
   PostgreSQL目前只实现了存储生成列。
  </para>
<!-- pgdoc-cn_end sig_en=4524419db99f4185ea71f04939d9638d -->

<!-- pgdoc-cn_start sig_en=74a64832522194f9edb90e4f61ecd863 sig_cn_org=None source=14.1 
  <para>
   To create a generated column, use the <literal>GENERATED ALWAYS
   AS</literal> clause in <command>CREATE TABLE</command>, for example:
<programlisting>
CREATE TABLE people (
    ...,
    height_cm numeric,
    height_in numeric <emphasis>GENERATED ALWAYS AS (height_cm / 2.54) STORED</emphasis>
);
</programlisting>
   The keyword <literal>STORED</literal> must be specified to choose the
   stored kind of generated column.  See <xref linkend="sql-createtable"/> for
   more details.
  </para>
________________________________________________________-->
  <para>
   建立一个生成列，在 <command>CREATE TABLE</command>中使用 <literal>GENERATED ALWAYS AS</literal> 子句, 例如:
<programlisting>
CREATE TABLE people (
    ...,
    height_cm numeric,
    height_in numeric <emphasis>GENERATED ALWAYS AS (height_cm / 2.54) STORED</emphasis>
);
</programlisting>
   必须指定关键字 <literal>STORED</literal> 以选择存储类型的生成列。更多细节请参见 <xref linkend="sql-createtable"/> 。
  </para>
<!-- pgdoc-cn_end sig_en=74a64832522194f9edb90e4f61ecd863 -->

<!-- pgdoc-cn_start sig_en=097c7622d223d4347c14b8da211b46b9 sig_cn_org=None source=14.1 
  <para>
   A generated column cannot be written to directly.  In
   <command>INSERT</command> or <command>UPDATE</command> commands, a value
   cannot be specified for a generated column, but the keyword
   <literal>DEFAULT</literal> may be specified.
  </para>
________________________________________________________-->
  <para>
   生成列不能被直接写入.  
   在<command>INSERT</command> 或 <command>UPDATE</command> 命令中, 不能为生成列指定值, 但是可以指定关键字<literal>DEFAULT</literal>。
  </para>
<!-- pgdoc-cn_end sig_en=097c7622d223d4347c14b8da211b46b9 -->

<!-- pgdoc-cn_start sig_en=3606703530341f499112a39723884182 sig_cn_org=None source=14.1 
  <para>
   Consider the differences between a column with a default and a generated
   column.  The column default is evaluated once when the row is first
   inserted if no other value was provided; a generated column is updated
   whenever the row changes and cannot be overridden.  A column default may
   not refer to other columns of the table; a generation expression would
   normally do so.  A column default can use volatile functions, for example
   <literal>random()</literal> or functions referring to the current time;
   this is not allowed for generated columns.
  </para>
________________________________________________________-->
  <para>
   考虑列缺省情况和生成列之间的差异。
   如果没有提供其他值，列缺省情况下在行被首次插入时计算一次;生成列则在行每次改变时进行更新，并且不能被取代。
   列缺省情况下不能引用表的其他列；生成表达式通常会这样做。
   列缺省情况下可以使用易失性函数，例如<literal>random()</literal>或引用当前时间函数; 而对于生成列这是不允许的。
  </para>
<!-- pgdoc-cn_end sig_en=3606703530341f499112a39723884182 -->

<!-- pgdoc-cn_start sig_en=0d180a9517e31baba024afab5707bf80 sig_cn_org=None source=14.1 
  <para>
   Several restrictions apply to the definition of generated columns and
   tables involving generated columns:

   <itemizedlist>
    <listitem>
     <para>
      The generation expression can only use immutable functions and cannot
      use subqueries or reference anything other than the current row in any
      way.
     </para>
    </listitem>
    <listitem>
     <para>
      A generation expression cannot reference another generated column.
     </para>
    </listitem>
    <listitem>
     <para>
      A generation expression cannot reference a system column, except
      <varname>tableoid</varname>.
     </para>
    </listitem>
    <listitem>
     <para>
      A generated column cannot have a column default or an identity definition.
     </para>
    </listitem>
    <listitem>
     <para>
      A generated column cannot be part of a partition key.
     </para>
    </listitem>
    <listitem>
     <para>
      Foreign tables can have generated columns.  See <xref
      linkend="sql-createforeigntable"/> for details.
     </para>
    </listitem>
    <listitem>
     <para>For inheritance:</para>
     <itemizedlist>
      <listitem>
       <para>
        If a parent column is a generated column, a child column must also be
        a generated column using the same expression.  In the definition of
        the child column, leave off the <literal>GENERATED</literal> clause,
        as it will be copied from the parent.
       </para>
      </listitem>
      <listitem>
       <para>
        In case of multiple inheritance, if one parent column is a generated
        column, then all parent columns must be generated columns and with the
        same expression.
       </para>
      </listitem>
      <listitem>
       <para>
        If a parent column is not a generated column, a child column may be
        defined to be a generated column or not.
       </para>
      </listitem>
     </itemizedlist>
    </listitem>
   </itemizedlist>
  </para>
________________________________________________________-->
  <para>
   生成列和涉及生成列的表的定义有几个限制:

   <itemizedlist>
    <listitem>
     <para>
      生成表达式只能使用不可变函数，并且不能使用子查询或以任何方式引用当前行以外的任何内容。
     </para>
    </listitem>
    <listitem>
     <para>
      生成表达式不能引用另一个生成列。
     </para>
    </listitem>
    <listitem>
     <para>
      生成表达式不能引用系统表，除了 <varname>tableoid</varname>。
     </para>
    </listitem>
    <listitem>
     <para>
      生成列不能具有列默认或标识定义。
     </para>
    </listitem>
    <listitem>
     <para>
      生成列不能是分区键的一部分。
     </para>
    </listitem>
    <listitem>
     <para>
      外部表可以有生成列.  更多细节请参见 <xref linkend="sql-createforeigntable"/> .
     </para>
    </listitem>
    <listitem>
     <para>对于继承:</para>
     <itemizedlist>
      <listitem>
       <para>
        如果父列是生成的列，则子列也必须也是使用相同的表达式生成的列。 
        在子列的定义中，不再使用<literal>GENERATED</literal>子句，因为它将从父列复制过来。
       </para>
      </listitem>
      <listitem>
       <para>
        在进行多重继承的情况下，如果一个父列是生成的列，那么所有父列都必须是生成的列，并且具有相同的表达式。
       </para>
      </listitem>
      <listitem>
       <para>
        如果父列不是生成的列，子列可以定义是否为生成的列。
       </para>
      </listitem>
     </itemizedlist>
    </listitem>
   </itemizedlist>
  </para>
<!-- pgdoc-cn_end sig_en=0d180a9517e31baba024afab5707bf80 -->

<!-- pgdoc-cn_start sig_en=c0e350c24e10a2fa81977afc84ad559d sig_cn_org=None source=14.1 
  <para>
   Additional considerations apply to the use of generated columns.
   <itemizedlist>
    <listitem>
     <para>
      Generated columns maintain access privileges separately from their
      underlying base columns.  So, it is possible to arrange it so that a
      particular role can read from a generated column but not from the
      underlying base columns.
     </para>
    </listitem>
    <listitem>
     <para>
      Generated columns are, conceptually, updated after
      <literal>BEFORE</literal> triggers have run.  Therefore, changes made to
      base columns in a <literal>BEFORE</literal> trigger will be reflected in
      generated columns.  But conversely, it is not allowed to access
      generated columns in <literal>BEFORE</literal> triggers.
     </para>
    </listitem>
   </itemizedlist>
  </para>
________________________________________________________-->
  <para>
   使用生成列的其他注意事项。
   <itemizedlist>
    <listitem>
     <para>
      生成列保留着有别于其下层的基础列的访问权限。因此，可以对其进行排列以便于从生成列中读取特定的角色，而不是从下层基础列。
     </para>
    </listitem>
    <listitem>
     <para>
      从概念上讲，生成列在<literal>BEFORE</literal> 触发器运行后更新。
      因此，<literal>BEFORE</literal> 触发器中的基础列所做的变更将反映在生成列中。 
      但相反，不允许访问<literal>BEFORE</literal> 触发器中的生成列。
     </para>
    </listitem>
   </itemizedlist>
  </para>
<!-- pgdoc-cn_end sig_en=c0e350c24e10a2fa81977afc84ad559d -->
 </sect1>

 <sect1 id="ddl-constraints">
<!-- pgdoc-cn_start sig_en=2f63aa5168dcf4462debecac72647617 sig_cn_org=None source=14.1 
  <title>Constraints</title>
________________________________________________________-->
  <title>约束</title>
<!-- pgdoc-cn_end sig_en=2f63aa5168dcf4462debecac72647617 -->

<!-- pgdoc-cn_start sig_en=d2fabf656f774a3e29e3134a68259a51 sig_cn_org=None source=14.1 
  <indexterm zone="ddl-constraints">
   <primary>constraint</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="ddl-constraints">
   <primary>constraint</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=d2fabf656f774a3e29e3134a68259a51 -->

<!-- pgdoc-cn_start sig_en=f7efbf15fa6814dd13194f3e0fe2b026 sig_cn_org=None source=14.1 
  <para>
   Data types are a way to limit the kind of data that can be stored
   in a table.  For many applications, however, the constraint they
   provide is too coarse.  For example, a column containing a product
   price should probably only accept positive values.  But there is no
   standard data type that accepts only positive numbers.  Another issue is
   that you might want to constrain column data with respect to other
   columns or rows.  For example, in a table containing product
   information, there should be only one row for each product number.
  </para>
________________________________________________________-->
  <para>
   数据类型是一种限制能够存储在表中数据类别的方法。但是对于很多应用来说，它们提供的约束太粗糙。例如，一个包含产品价格的列应该只接受正值。但是没有任何一种标准数据类型只接受正值。另一个问题是我们可能需要根据其他列或行来约束一个列中的数据。例如，在一个包含产品信息的表中，对于每个产品编号应该只有一行。
  </para>
<!-- pgdoc-cn_end sig_en=f7efbf15fa6814dd13194f3e0fe2b026 -->

<!-- pgdoc-cn_start sig_en=ddd9522943f4c3a83da0b1dbf6a57528 sig_cn_org=None source=14.1 
  <para>
   To that end, SQL allows you to define constraints on columns and
   tables.  Constraints give you as much control over the data in your
   tables as you wish.  If a user attempts to store data in a column
   that would violate a constraint, an error is raised.  This applies
   even if the value came from the default value definition.
  </para>
________________________________________________________-->
  <para>
   到目前为止，SQL允许我们在列和表上定义约束。约束让我们能够根据我们的愿望来控制表中的数据。如果一个用户试图在一个列中保存违反一个约束的数据，一个错误会被抛出。即便是这个值来自于默认值定义，这个规则也同样适用。
  </para>
<!-- pgdoc-cn_end sig_en=ddd9522943f4c3a83da0b1dbf6a57528 -->

  <sect2 id="ddl-constraints-check-constraints">
<!-- pgdoc-cn_start sig_en=1640f5a5029fbd060434a0c6cb27b37d sig_cn_org=None source=14.1 
   <title>Check Constraints</title>
________________________________________________________-->
   <title>检查约束</title>
<!-- pgdoc-cn_end sig_en=1640f5a5029fbd060434a0c6cb27b37d -->

<!-- pgdoc-cn_start sig_en=ca50f940c5f2ac8e6d325a2a7e2a074d sig_cn_org=None source=14.1 
   <indexterm>
    <primary>check constraint</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>check constraint</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=ca50f940c5f2ac8e6d325a2a7e2a074d -->

<!-- pgdoc-cn_start sig_en=0ac968a12ca49096dc1e966eaf720508 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>constraint</primary>
    <secondary>check</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>constraint</primary>
    <secondary>check</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=0ac968a12ca49096dc1e966eaf720508 -->

<!-- pgdoc-cn_start sig_en=709659d80cc0111725ba7a2a7d25a19a sig_cn_org=None source=14.1 
   <para>
    A check constraint is the most generic constraint type.  It allows
    you to specify that the value in a certain column must satisfy a
    Boolean (truth-value) expression.  For instance, to require positive
    product prices, you could use:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>CHECK (price &gt; 0)</emphasis>
);
</programlisting>
   </para>
________________________________________________________-->
   <para>
    一个检查约束是最普通的约束类型。它允许我们指定一个特定列中的值必须要满足一个布尔表达式。例如，为了要求正值的产品价格，我们可以使用：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>CHECK (price &gt; 0)</emphasis>
);
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=709659d80cc0111725ba7a2a7d25a19a -->

<!-- pgdoc-cn_start sig_en=5bc76bd3ce16fcb443a6b6cc6a862b5c sig_cn_org=None source=14.1 
   <para>
    As you see, the constraint definition comes after the data type,
    just like default value definitions.  Default values and
    constraints can be listed in any order.  A check constraint
    consists of the key word <literal>CHECK</literal> followed by an
    expression in parentheses.  The check constraint expression should
    involve the column thus constrained, otherwise the constraint
    would not make too much sense.
   </para>
________________________________________________________-->
   <para>
    如你所见，约束定义就和默认值定义一样跟在数据类型之后。默认值和约束之间的顺序没有影响。一个检查约束有关键字<literal>CHECK</literal>以及其后的包围在圆括号中的表达式组成。检查约束表达式应该涉及到被约束的列，否则该约束也没什么实际意义。
   </para>
<!-- pgdoc-cn_end sig_en=5bc76bd3ce16fcb443a6b6cc6a862b5c -->

<!-- pgdoc-cn_start sig_en=ac7e364d47f8066131814c94b0d24176 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>constraint</primary>
    <secondary>name</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>constraint</primary>
    <secondary>name</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=ac7e364d47f8066131814c94b0d24176 -->

<!-- pgdoc-cn_start sig_en=7e3e6a408b3b9d8036f5cd7ebceb5b1b sig_cn_org=None source=14.1 
   <para>
    You can also give the constraint a separate name.  This clarifies
    error messages and allows you to refer to the constraint when you
    need to change it.  The syntax is:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>CONSTRAINT positive_price</emphasis> CHECK (price &gt; 0)
);
</programlisting>
    So, to specify a named constraint, use the key word
    <literal>CONSTRAINT</literal> followed by an identifier followed
    by the constraint definition.  (If you don't specify a constraint
    name in this way, the system chooses a name for you.)
   </para>
________________________________________________________-->
   <para>
    我们也可以给与约束一个独立的名称。这会使得错误消息更为清晰，同时也允许我们在需要更改约束时能引用它。语法为：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric <emphasis>CONSTRAINT positive_price</emphasis> CHECK (price &gt; 0)
);
</programlisting>
    要指定一个命名的约束，请在约束名称标识符前使用关键词<literal>CONSTRAINT</literal>，然后把约束定义放在标识符之后（如果没有以这种方式指定一个约束名称，系统将会为我们选择一个）。
   </para>
<!-- pgdoc-cn_end sig_en=7e3e6a408b3b9d8036f5cd7ebceb5b1b -->

<!-- pgdoc-cn_start sig_en=d67972d1c990f6f438a992e97e2ce917 sig_cn_org=None source=14.1 
   <para>
    A check constraint can also refer to several columns.  Say you
    store a regular price and a discounted price, and you want to
    ensure that the discounted price is lower than the regular price:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric CHECK (discounted_price &gt; 0),
    <emphasis>CHECK (price &gt; discounted_price)</emphasis>
);
</programlisting>
   </para>
________________________________________________________-->
   <para>
    一个检查约束也可以引用多个列。例如我们存储一个普通价格和一个打折后的价格，而我们希望保证打折后的价格低于普通价格：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric CHECK (discounted_price &gt; 0),
    <emphasis>CHECK (price &gt; discounted_price)</emphasis>
);
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=d67972d1c990f6f438a992e97e2ce917 -->

<!-- pgdoc-cn_start sig_en=e284a795e2f995cbc84fd1b3d37f5446 sig_cn_org=None source=14.1 
   <para>
    The first two constraints should look familiar.  The third one
    uses a new syntax.  It is not attached to a particular column,
    instead it appears as a separate item in the comma-separated
    column list.  Column definitions and these constraint
    definitions can be listed in mixed order.
   </para>
________________________________________________________-->
   <para>
    前两个约束看起来很相似。第三个则使用了一种新语法。它并没有依附在一个特定的列，而是作为一个独立的项出现在逗号分隔的列列表中。列定义和这种约束定义可以以混合的顺序出现在列表中。
   </para>
<!-- pgdoc-cn_end sig_en=e284a795e2f995cbc84fd1b3d37f5446 -->

<!-- pgdoc-cn_start sig_en=26782e16c0986b0402244665849f5d7f sig_cn_org=None source=14.1 
   <para>
    We say that the first two constraints are column constraints, whereas the
    third one is a table constraint because it is written separately
    from any one column definition.  Column constraints can also be
    written as table constraints, while the reverse is not necessarily
    possible, since a column constraint is supposed to refer to only the
    column it is attached to.  (<productname>PostgreSQL</productname> doesn't
    enforce that rule, but you should follow it if you want your table
    definitions to work with other database systems.)  The above example could
    also be written as:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    CHECK (price &gt; discounted_price)
);
</programlisting>
    or even:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0 AND price &gt; discounted_price)
);
</programlisting>
    It's a matter of taste.
   </para>
________________________________________________________-->
   <para>
    我们将前两个约束称为列约束，而第三个约束为表约束，因为它独立于任何一个列定义。列约束也可以写成表约束，但反过来不行，因为一个列约束只能引用它所依附的那一个列（<productname>PostgreSQL</productname>并不强制要求这个规则，但是如果我们希望表定义能够在其他数据库系统中工作，那就应该遵循它）。上述例子也可以写成：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    CHECK (price &gt; discounted_price)
);
</programlisting>
    甚至是：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0 AND price &gt; discounted_price)
);
</programlisting>
    这只是口味的问题。
   </para>
<!-- pgdoc-cn_end sig_en=26782e16c0986b0402244665849f5d7f -->

<!-- pgdoc-cn_start sig_en=0ad4042da143ad9bb8cfc26f17097f28 sig_cn_org=None source=14.1 
   <para>
    Names can be assigned to table constraints in the same way as
    column constraints:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    <emphasis>CONSTRAINT valid_discount</emphasis> CHECK (price &gt; discounted_price)
);
</programlisting>
   </para>
________________________________________________________-->
   <para>
    表约束也可以用列约束相同的方法来指定名称：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    CHECK (price &gt; 0),
    discounted_price numeric,
    CHECK (discounted_price &gt; 0),
    <emphasis>CONSTRAINT valid_discount</emphasis> CHECK (price &gt; discounted_price)
);
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=0ad4042da143ad9bb8cfc26f17097f28 -->

<!-- pgdoc-cn_start sig_en=e2df0d5afe8c8c97ac279a9e31e7c38b sig_cn_org=None source=14.1 
   <indexterm>
    <primary>null value</primary>
    <secondary sortas="check constraints">with check constraints</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>null value</primary>
    <secondary sortas="check constraints">with check constraints</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=e2df0d5afe8c8c97ac279a9e31e7c38b -->

<!-- pgdoc-cn_start sig_en=2d5bb885cc268de8703a865b9ed39faf sig_cn_org=None source=14.1 
   <para>
    It should be noted that a check constraint is satisfied if the
    check expression evaluates to true or the null value.  Since most
    expressions will evaluate to the null value if any operand is null,
    they will not prevent null values in the constrained columns.  To
    ensure that a column does not contain null values, the not-null
    constraint described in the next section can be used.
   </para>
________________________________________________________-->
   <para>
    需要注意的是，一个检查约束在其检查表达式值为真或空值时被满足。因为当任何操作数为空时大部分表达式将计算为空值，所以它们不会阻止被约束列中的空值。为了保证一个列不包含空值，可以使用下一节中的非空约束。
   </para>
<!-- pgdoc-cn_end sig_en=2d5bb885cc268de8703a865b9ed39faf -->

   <note>
<!-- pgdoc-cn_start sig_en=66cb8357ce1bec4363da85859061a4c1 sig_cn_org=fbb8655e4eab25c51d31dd0aed44ef6c source=15.7 
    <para>
     <productname>PostgreSQL</productname> does not support
     <literal>CHECK</literal> constraints that reference table data other than
     the new or updated row being checked.  While a <literal>CHECK</literal>
     constraint that violates this rule may appear to work in simple
     tests, it cannot guarantee that the database will not reach a state
     in which the constraint condition is false (due to subsequent changes
     of the other row(s) involved).  This would cause a database dump and
     restore to fail.  The restore could fail even when the complete
     database state is consistent with the constraint, due to rows not
     being loaded in an order that will satisfy the constraint.  If
     possible, use <literal>UNIQUE</literal>, <literal>EXCLUDE</literal>,
     or <literal>FOREIGN KEY</literal> constraints to express
     cross-row and cross-table restrictions.
    </para>
________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>不支持引用除了正在检查的新行或更新行之外的表数据的<literal>CHECK</literal>约束。
     虽然违反此规则的<literal>CHECK</literal>约束在简单测试中可能有效，但无法保证数据库不会达到约束条件为假的状态
     （由于其他行的后续更改）。这将导致数据库转储和恢复失败。即使完整的数据库状态与约束一致，恢复也可能失败，
     因为行未按满足约束的顺序加载。如果可能的话，使用<literal>UNIQUE</literal>、<literal>EXCLUDE</literal>或
     <literal>FOREIGN KEY</literal>约束来表示跨行和跨表的限制。
</para>
<!-- pgdoc-cn_end sig_en=66cb8357ce1bec4363da85859061a4c1 -->

<!-- pgdoc-cn_start sig_en=458710570ef56be2ae32ba2875102d37 sig_cn_org=bcaf7a860a078fcc262acb6c24efc650 source=15.7 
    <para>
     If what you desire is a one-time check against other rows at row
     insertion, rather than a continuously-maintained consistency
     guarantee, a custom <link linkend="triggers">trigger</link> can be used
     to implement that.  (This approach avoids the dump/restore problem because
     <application>pg_dump</application> does not reinstall triggers until after
     restoring data, so that the check will not be enforced during a
     dump/restore.)
    </para>
________________________________________________________-->
    <para>
     如果您想要的是在插入行时对其他行进行一次性检查，而不是持续维护一致性保证，
     可以使用自定义<link linkend="triggers">触发器（trigger）</link>来实现。 （这种方法避免了
     转储/恢复问题，因为<application>pg_dump</application>在恢复数据之后才重新安装触发器，
     因此在转储/恢复期间不会强制执行检查。）
    </para>
<!-- pgdoc-cn_end sig_en=458710570ef56be2ae32ba2875102d37 -->
   </note>

   <note>
<!-- pgdoc-cn_start sig_en=ab4be2a2a4101bda6f24bea99c72be67 sig_cn_org=None source=14.1 
    <para>
     <productname>PostgreSQL</productname> assumes that
     <literal>CHECK</literal> constraints' conditions are immutable, that
     is, they will always give the same result for the same input row.
     This assumption is what justifies examining <literal>CHECK</literal>
     constraints only when rows are inserted or updated, and not at other
     times.  (The warning above about not referencing other table data is
     really a special case of this restriction.)
    </para>
________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>假定<literal>CHECK</literal>约束的条件是不可变的，也就是说，它们始终为同一输入行提供相同的结果。
     这个假设是仅在插入或更新行时,而不是在其他时间检查<literal>CHECK</literal>约束的原因。 
     （上面关于不引用其他表数据的警告实际上是此限制的特殊情况。）
    </para>
<!-- pgdoc-cn_end sig_en=ab4be2a2a4101bda6f24bea99c72be67 -->

<!-- pgdoc-cn_start sig_en=c778884b37869bc3073de83c3bfe2e40 sig_cn_org=9ff0d6179c2e0f4bc8f3be103382fa10 source=15.7 
    <para>
     An example of a common way to break this assumption is to reference a
     user-defined function in a <literal>CHECK</literal> expression, and
     then change the behavior of that
     function.  <productname>PostgreSQL</productname> does not disallow
     that, but it will not notice if there are rows in the table that now
     violate the <literal>CHECK</literal> constraint. That would cause a
     subsequent database dump and restore to fail.
     The recommended way to handle such a change is to drop the constraint
     (using <command>ALTER TABLE</command>), adjust the function definition,
     and re-add the constraint, thereby rechecking it against all table rows.
    </para>
________________________________________________________-->
    <para>
     一个常见的打破这种假设的例子是在<literal>CHECK</literal>表达式中引用一个用户定义的函数，
     然后改变该函数的行为。<productname>PostgreSQL</productname>不会禁止这样做，
     但它不会注意到表中是否有行现在违反了<literal>CHECK</literal>约束。
     这将导致后续的数据库转储和恢复操作失败。
     处理这种变化的推荐方法是删除约束（使用<command>ALTER TABLE</command>），
     调整函数定义，然后重新添加约束，从而重新检查所有表行。
</para>
<!-- pgdoc-cn_end sig_en=c778884b37869bc3073de83c3bfe2e40 -->
   </note>
  </sect2>

  <sect2>
<!-- pgdoc-cn_start sig_en=0c7e9205b2662e906cce9b260a9b02e7 sig_cn_org=None source=14.1 
   <title>Not-Null Constraints</title>
________________________________________________________-->
   <title>非空约束</title>
<!-- pgdoc-cn_end sig_en=0c7e9205b2662e906cce9b260a9b02e7 -->

<!-- pgdoc-cn_start sig_en=e246af12aeb0b45f8e4dbdb336df3031 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>not-null constraint</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>not-null constraint</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=e246af12aeb0b45f8e4dbdb336df3031 -->

<!-- pgdoc-cn_start sig_en=ae6eda045333cdbac42da0f9d9b4f864 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>constraint</primary>
    <secondary>NOT NULL</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>constraint</primary>
    <secondary>NOT NULL</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=ae6eda045333cdbac42da0f9d9b4f864 -->

<!-- pgdoc-cn_start sig_en=316a6023b95ca6dad696d2c52f22626e sig_cn_org=None source=14.1 
   <para>
    A not-null constraint simply specifies that a column must not
    assume the null value.  A syntax example:
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>NOT NULL</emphasis>,
    name text <emphasis>NOT NULL</emphasis>,
    price numeric
);
</programlisting>
   </para>
________________________________________________________-->
   <para>
    一个非空约束仅仅指定一个列中不会有空值。语法例子：
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>NOT NULL</emphasis>,
    name text <emphasis>NOT NULL</emphasis>,
    price numeric
);
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=316a6023b95ca6dad696d2c52f22626e -->

<!-- pgdoc-cn_start sig_en=31f126a7b2764c43e4f65b7e3e2185ba sig_cn_org=None source=14.1 
   <para>
    A not-null constraint is always written as a column constraint.  A
    not-null constraint is functionally equivalent to creating a check
    constraint <literal>CHECK (<replaceable>column_name</replaceable>
    IS NOT NULL)</literal>, but in
    <productname>PostgreSQL</productname> creating an explicit
    not-null constraint is more efficient.  The drawback is that you
    cannot give explicit names to not-null constraints created this
    way.
   </para>
________________________________________________________-->
   <para>
    一个非空约束总是被写成一个列约束。一个非空约束等价于创建一个检查约束<literal>CHECK (<replaceable>column_name</replaceable>
    IS NOT NULL)</literal>，但在<productname>PostgreSQL</productname>中创建一个显式的非空约束更高效。这种方式创建的非空约束的缺点是我们无法为它给予一个显式的名称。
   </para>
<!-- pgdoc-cn_end sig_en=31f126a7b2764c43e4f65b7e3e2185ba -->

<!-- pgdoc-cn_start sig_en=5b3a874a190f5227bb57e0aac8fb3ec0 sig_cn_org=None source=14.1 
   <para>
    Of course, a column can have more than one constraint.  Just write
    the constraints one after another:
<programlisting>
CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric NOT NULL CHECK (price &gt; 0)
);
</programlisting>
    The order doesn't matter.  It does not necessarily determine in which
    order the constraints are checked.
   </para>
________________________________________________________-->
   <para>
    当然，一个列可以有多于一个的约束，只需要将这些约束一个接一个写出：
<programlisting>
CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric NOT NULL CHECK (price &gt; 0)
);
</programlisting>
    约束的顺序没有关系，因为并不需要决定约束被检查的顺序。
   </para>
<!-- pgdoc-cn_end sig_en=5b3a874a190f5227bb57e0aac8fb3ec0 -->

<!-- pgdoc-cn_start sig_en=2c7dd33e2dcf1d8476fa710db5a0aaa9 sig_cn_org=None source=14.1 
   <para>
    The <literal>NOT NULL</literal> constraint has an inverse: the
    <literal>NULL</literal> constraint.  This does not mean that the
    column must be null, which would surely be useless.  Instead, this
    simply selects the default behavior that the column might be null.
    The <literal>NULL</literal> constraint is not present in the SQL
    standard and should not be used in portable applications.  (It was
    only added to <productname>PostgreSQL</productname> to be
    compatible with some other database systems.)  Some users, however,
    like it because it makes it easy to toggle the constraint in a
    script file.  For example, you could start with:
<programlisting>
CREATE TABLE products (
    product_no integer NULL,
    name text NULL,
    price numeric NULL
);
</programlisting>
    and then insert the <literal>NOT</literal> key word where desired.
   </para>
________________________________________________________-->
   <para>
    <literal>NOT NULL</literal>约束有一个相反的情况：<literal>NULL</literal>约束。这并不意味着该列必须为空，进而肯定是无用的。相反，它仅仅选择了列可能为空的默认行为。SQL标准中并不存在<literal>NULL</literal>约束，因此它不能被用于可移植的应用中（<productname>PostgreSQL</productname>中加入它是为了和某些其他数据库系统兼容）。但是某些用户喜欢它，因为它使得在一个脚本文件中可以很容易的进行约束切换。例如，初始时我们可以：
<programlisting>
CREATE TABLE products (
    product_no integer NULL,
    name text NULL,
    price numeric NULL
);
</programlisting>
    然后可以在需要的地方插入<literal>NOT</literal>关键词。
   </para>
<!-- pgdoc-cn_end sig_en=2c7dd33e2dcf1d8476fa710db5a0aaa9 -->

   <tip>
<!-- pgdoc-cn_start sig_en=51cb176e901aff5bd62ab65405ac7389 sig_cn_org=None source=14.1 
    <para>
     In most database designs the majority of columns should be marked
     not null.
    </para>
________________________________________________________-->
    <para>
     在大部分数据库中多数列应该被标记为非空。
    </para>
<!-- pgdoc-cn_end sig_en=51cb176e901aff5bd62ab65405ac7389 -->
   </tip>
  </sect2>

  <sect2 id="ddl-constraints-unique-constraints">
<!-- pgdoc-cn_start sig_en=a7950e747bb9f4dc507f078b2cf11931 sig_cn_org=None source=14.1 
   <title>Unique Constraints</title>
________________________________________________________-->
   <title>唯一约束</title>
<!-- pgdoc-cn_end sig_en=a7950e747bb9f4dc507f078b2cf11931 -->

<!-- pgdoc-cn_start sig_en=cf382164ae2e534e3b1214a05e78c2d1 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>unique constraint</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>unique constraint</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=cf382164ae2e534e3b1214a05e78c2d1 -->

<!-- pgdoc-cn_start sig_en=13a1cf1a4cc13442c6c9c8f99bda5b42 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>constraint</primary>
    <secondary>unique</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>constraint</primary>
    <secondary>unique</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=13a1cf1a4cc13442c6c9c8f99bda5b42 -->

<!-- pgdoc-cn_start sig_en=368aba39cefc815d857decaa633163a5 sig_cn_org=None source=14.1 
   <para>
    Unique constraints ensure that the data contained in a column, or a
    group of columns, is unique among all the rows in the
    table.  The syntax is:
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>UNIQUE</emphasis>,
    name text,
    price numeric
);
</programlisting>
    when written as a column constraint, and:
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    <emphasis>UNIQUE (product_no)</emphasis>
);
</programlisting>
    when written as a table constraint.
   </para>
________________________________________________________-->
   <para>
    唯一约束保证\在一列中或者一组列中保存的数据在表中所有行间是唯一的。写成一个列约束的语法是：
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>UNIQUE</emphasis>,
    name text,
    price numeric
);
</programlisting>
    写成一个表约束的语法是：
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    <emphasis>UNIQUE (product_no)</emphasis>
);
</programlisting>
    当写入表约束时。
   </para>
<!-- pgdoc-cn_end sig_en=368aba39cefc815d857decaa633163a5 -->

<!-- pgdoc-cn_start sig_en=0a08ad85fe34eb6887c02183063e1b7f sig_cn_org=None source=14.1 
   <para>
    To define a unique constraint for a group of columns, write it as a
    table constraint with the column names separated by commas:
<programlisting>
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    <emphasis>UNIQUE (a, c)</emphasis>
);
</programlisting>
    This specifies that the combination of values in the indicated columns
    is unique across the whole table, though any one of the columns
    need not be (and ordinarily isn't) unique.
   </para>
________________________________________________________-->
   <para>
    要为一组列定义一个唯一约束，把它写作一个表级约束，列名用逗号分隔：
<programlisting>
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    <emphasis>UNIQUE (a, c)</emphasis>
);
</programlisting>
    这指定这些列的组合值在整个表的范围内是唯一的，但其中任意一列的值并不需要是（一般也不是）唯一的。
   </para>
<!-- pgdoc-cn_end sig_en=0a08ad85fe34eb6887c02183063e1b7f -->

<!-- pgdoc-cn_start sig_en=7aec56cb33014aa531d2754268ec6351 sig_cn_org=None source=14.1 
   <para>
    You can assign your own name for a unique constraint, in the usual way:
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>CONSTRAINT must_be_different</emphasis> UNIQUE,
    name text,
    price numeric
);
</programlisting>
   </para>
________________________________________________________-->
   <para>
    我们可以通常的方式为一个唯一索引命名：
<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>CONSTRAINT must_be_different</emphasis> UNIQUE,
    name text,
    price numeric
);
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=7aec56cb33014aa531d2754268ec6351 -->

<!-- pgdoc-cn_start sig_en=39ab2397c16a7bb2a28b12ae0f7f15e1 sig_cn_org=None source=14.1 
   <para>
    Adding a unique constraint will automatically create a unique B-tree
    index on the column or group of columns listed in the constraint.
    A uniqueness restriction covering only some rows cannot be written as
    a unique constraint, but it is possible to enforce such a restriction by
    creating a unique <link linkend="indexes-partial">partial index</link>.
   </para>
________________________________________________________-->
   <para>
    增加一个唯一约束会在约束中列出的列或列组上自动创建一个唯一B-tree索引。只覆盖某些行的唯一性限制不能被写为一个唯一约束，但可以通过创建一个唯一的<link linkend="indexes-partial">部分索引</link>来强制这种限制。
   </para>
<!-- pgdoc-cn_end sig_en=39ab2397c16a7bb2a28b12ae0f7f15e1 -->

<!-- pgdoc-cn_start sig_en=a9b03a1ed7db2118bffe3a396d26b7c7 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>null value</primary>
    <secondary sortas="unique constraints">with unique constraints</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>null value</primary>
    <secondary sortas="unique constraints">with unique constraints</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=a9b03a1ed7db2118bffe3a396d26b7c7 -->

<!-- pgdoc-cn_start sig_en=cdc619e35b39ca4a0e5b60543a88dc92 sig_cn_org=f7f89910d0e7a655fd684d918d8ce4a6 source=15.7 
   <para>
    In general, a unique constraint is violated if there is more than
    one row in the table where the values of all of the
    columns included in the constraint are equal.
    By default, two null values are not considered equal in this
    comparison.  That means even in the presence of a
    unique constraint it is possible to store duplicate
    rows that contain a null value in at least one of the constrained
    columns.  This behavior can be changed by adding the clause <literal>NULLS
    NOT DISTINCT</literal>, like
<programlisting>
CREATE TABLE products (
    product_no integer UNIQUE <emphasis>NULLS NOT DISTINCT</emphasis>,
    name text,
    price numeric
);
</programlisting>
    or
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    UNIQUE <emphasis>NULLS NOT DISTINCT</emphasis> (product_no)
);
</programlisting>
    The default behavior can be specified explicitly using <literal>NULLS
    DISTINCT</literal>.  The default null treatment in unique constraints is
    implementation-defined according to the SQL standard, and other
    implementations have a different behavior.  So be careful when developing
    applications that are intended to be portable.
   </para>
________________________________________________________-->
   <para>
    通常情况下，如果表中有多行，其中包含约束中包含的所有列的值相等，则违反了唯一约束。
    默认情况下，在此比较中，两个空值不被视为相等。这意味着即使存在唯一约束，也可以存储包含至少一个受约束列中的空值的重复行。
    可以通过添加子句<literal>NULLS NOT DISTINCT</literal>来更改此行为，例如
<programlisting>
CREATE TABLE products (
    product_no integer UNIQUE <emphasis>NULLS NOT DISTINCT</emphasis>,
    name text,
    price numeric
);
</programlisting>
    或者
<programlisting>
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    UNIQUE <emphasis>NULLS NOT DISTINCT</emphasis> (product_no)
);
</programlisting>
    可以使用<literal>NULLS DISTINCT</literal>明确指定默认行为。唯一约束中的默认空值处理是根据SQL标准的实现定义的，其他实现具有不同的行为。因此，在开发旨在可移植的应用程序时要小心。
   </para>
<!-- pgdoc-cn_end sig_en=cdc619e35b39ca4a0e5b60543a88dc92 -->
  </sect2>

  <sect2 id="ddl-constraints-primary-keys">
<!-- pgdoc-cn_start sig_en=82a7c9da0e2dda47e5ca00641553aea1 sig_cn_org=None source=14.1 
   <title>Primary Keys</title>
________________________________________________________-->
   <title>主键</title>
<!-- pgdoc-cn_end sig_en=82a7c9da0e2dda47e5ca00641553aea1 -->

<!-- pgdoc-cn_start sig_en=82302445861aa40358555fbf1c34fb2b sig_cn_org=None source=14.1 
   <indexterm>
    <primary>primary key</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>primary key</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=82302445861aa40358555fbf1c34fb2b -->

<!-- pgdoc-cn_start sig_en=575b1336519f9919211563ce40146144 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>constraint</primary>
    <secondary>primary key</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>constraint</primary>
    <secondary>primary key</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=575b1336519f9919211563ce40146144 -->

<!-- pgdoc-cn_start sig_en=955fd2abf726762a7119e319842ab7d3 sig_cn_org=None source=14.1 
   <para>
    A primary key constraint indicates that a column, or group of columns,
    can be used as a unique identifier for rows in the table.  This
    requires that the values be both unique and not null.  So, the following
    two table definitions accept the same data:
<programlisting>
CREATE TABLE products (
    product_no integer UNIQUE NOT NULL,
    name text,
    price numeric
);
</programlisting>

<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>PRIMARY KEY</emphasis>,
    name text,
    price numeric
);
</programlisting>
   </para>
________________________________________________________-->
   <para>
    一个主键约束表示可以用作表中行的唯一标识符的一个列或者一组列。这要求那些值都是唯一的并且非空。因此，下面的两个表定义接受相同的数据：
<programlisting>
CREATE TABLE products (
    product_no integer UNIQUE NOT NULL,
    name text,
    price numeric
);
</programlisting>

<programlisting>
CREATE TABLE products (
    product_no integer <emphasis>PRIMARY KEY</emphasis>,
    name text,
    price numeric
);
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=955fd2abf726762a7119e319842ab7d3 -->

<!-- pgdoc-cn_start sig_en=bab1686f2f6509c8d1fcc5cc1da7ad32 sig_cn_org=None source=14.1 
   <para>
    Primary keys can span more than one column; the syntax
    is similar to unique constraints:
<programlisting>
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    <emphasis>PRIMARY KEY (a, c)</emphasis>
);
</programlisting>
   </para>
________________________________________________________-->
   <para>
    主键也可以包含多于一个列，其语法和唯一约束相似：
<programlisting>
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    <emphasis>PRIMARY KEY (a, c)</emphasis>
);
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=bab1686f2f6509c8d1fcc5cc1da7ad32 -->

<!-- pgdoc-cn_start sig_en=f31a434a156a51a5315cb8d22ecb349b sig_cn_org=None source=14.1 
   <para>
    Adding a primary key will automatically create a unique B-tree index
    on the column or group of columns listed in the primary key, and will
    force the column(s) to be marked <literal>NOT NULL</literal>.
   </para>
________________________________________________________-->
   <para>
    增加一个主键将自动在主键中列出的列或列组上创建一个唯一B-tree索引。并且会强制这些列被标记为<literal>NOT NULL</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=f31a434a156a51a5315cb8d22ecb349b -->

<!-- pgdoc-cn_start sig_en=c0563c2b4826e12c53ae43d1953cd051 sig_cn_org=None source=14.1 
   <para>
    A table can have at most one primary key.  (There can be any number
    of unique and not-null constraints, which are functionally almost the
    same thing, but only one can be identified as the primary key.)
    Relational database theory
    dictates that every table must have a primary key.  This rule is
    not enforced by <productname>PostgreSQL</productname>, but it is
    usually best to follow it.
   </para>
________________________________________________________-->
   <para>
    一个表最多只能有一个主键（可以有任意数量的唯一和非空约束，它们可以达到和主键几乎一样的功能，但只能有一个被标识为主键）。关系数据库理论要求每一个表都要有一个主键。但<productname>PostgreSQL</productname>中并未强制要求这一点，但是最好能够遵循它。
   </para>
<!-- pgdoc-cn_end sig_en=c0563c2b4826e12c53ae43d1953cd051 -->

<!-- pgdoc-cn_start sig_en=37b536188ca20da56279ec671ca403b9 sig_cn_org=None source=14.1 
   <para>
    Primary keys are useful both for
    documentation purposes and for client applications.  For example,
    a GUI application that allows modifying row values probably needs
    to know the primary key of a table to be able to identify rows
    uniquely.  There are also various ways in which the database system
    makes use of a primary key if one has been declared; for example,
    the primary key defines the default target column(s) for foreign keys
    referencing its table.
   </para>
________________________________________________________-->
   <para>
    主键对于文档和客户端应用都是有用的。例如，一个允许修改行值的 GUI 应用可能需要知道一个表的主键，以便能唯一地标识行。如果定义了主键，数据库系统也有多种方法来利用主键。例如，主键定义了外键要引用的默认目标列。
   </para>
<!-- pgdoc-cn_end sig_en=37b536188ca20da56279ec671ca403b9 -->
  </sect2>

  <sect2 id="ddl-constraints-fk">
<!-- pgdoc-cn_start sig_en=2e1bee7418a81d4028f47ffa09044a6f sig_cn_org=None source=14.1 
   <title>Foreign Keys</title>
________________________________________________________-->
   <title>外键</title>
<!-- pgdoc-cn_end sig_en=2e1bee7418a81d4028f47ffa09044a6f -->

<!-- pgdoc-cn_start sig_en=506b2f0a1c728ab9623ee286fc3b79cc sig_cn_org=None source=14.1 
   <indexterm>
    <primary>foreign key</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>foreign key</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=506b2f0a1c728ab9623ee286fc3b79cc -->

<!-- pgdoc-cn_start sig_en=87c2f5d9e2508fd61997e7a75f2a5ef6 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>constraint</primary>
    <secondary>foreign key</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>constraint</primary>
    <secondary>foreign key</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=87c2f5d9e2508fd61997e7a75f2a5ef6 -->

<!-- pgdoc-cn_start sig_en=b57b4b9e8378b21e66f8325174224afb sig_cn_org=None source=14.1 
   <indexterm>
    <primary>referential integrity</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>referential integrity</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=b57b4b9e8378b21e66f8325174224afb -->

<!-- pgdoc-cn_start sig_en=4cbf819771bf9da2969c5410011dfe51 sig_cn_org=None source=14.1 
   <para>
    A foreign key constraint specifies that the values in a column (or
    a group of columns) must match the values appearing in some row
    of another table.
    We say this maintains the <firstterm>referential
    integrity</firstterm> between two related tables.
   </para>
________________________________________________________-->
   <para>
    一个外键约束指定一列（或一组列）中的值必须匹配出现在另一个表中某些行的值。我们说这维持了两个关联表之间的<firstterm>引用完整性</firstterm>。
   </para>
<!-- pgdoc-cn_end sig_en=4cbf819771bf9da2969c5410011dfe51 -->

<!-- pgdoc-cn_start sig_en=869e71c0d22412a05221183b1b25064a sig_cn_org=None source=14.1 
   <para>
    Say you have the product table that we have used several times already:
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);
</programlisting>
    Let's also assume you have a table storing orders of those
    products.  We want to ensure that the orders table only contains
    orders of products that actually exist.  So we define a foreign
    key constraint in the orders table that references the products
    table:
<programlisting>
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer <emphasis>REFERENCES products (product_no)</emphasis>,
    quantity integer
);
</programlisting>
    Now it is impossible to create orders with non-NULL
    <structfield>product_no</structfield> entries that do not appear in the
    products table.
   </para>
________________________________________________________-->
   <para>
    例如我们有一个使用过多次的产品表：
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);
</programlisting>
    让我们假设我们还有一个存储这些产品订单的表。我们希望保证订单表中只包含真正存在的产品的订单。因此我们在订单表中定义一个引用产品表的外键约束：
<programlisting>
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer <emphasis>REFERENCES products (product_no)</emphasis>,
    quantity integer
);
</programlisting>
    现在就不可能创建包含不存在于产品表中的<structfield>product_no</structfield>值（非空）的订单。
   </para>
<!-- pgdoc-cn_end sig_en=869e71c0d22412a05221183b1b25064a -->

<!-- pgdoc-cn_start sig_en=b16327332a5243c81dee19ecce6b2b6c sig_cn_org=None source=14.1 
   <para>
    We say that in this situation the orders table is the
    <firstterm>referencing</firstterm> table and the products table is
    the <firstterm>referenced</firstterm> table.  Similarly, there are
    referencing and referenced columns.
   </para>
________________________________________________________-->
   <para>
    我们说在这种情况下，订单表是<firstterm>引用</firstterm>表而产品表是<firstterm>被引用</firstterm>表。相应地，也有引用和被引用列的说法。
   </para>
<!-- pgdoc-cn_end sig_en=b16327332a5243c81dee19ecce6b2b6c -->

<!-- pgdoc-cn_start sig_en=9107d37a3528cdc8db3c844b42b5f6ea sig_cn_org=None source=14.1 
   <para>
    You can also shorten the above command to:
<programlisting>
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer <emphasis>REFERENCES products</emphasis>,
    quantity integer
);
</programlisting>
    because in absence of a column list the primary key of the
    referenced table is used as the referenced column(s).
   </para>
________________________________________________________-->
   <para>
    我们也可以把上述命令简写为：
<programlisting>
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_no integer <emphasis>REFERENCES products</emphasis>,
    quantity integer
);
</programlisting>
    因为如果缺少列的列表，则被引用表的主键将被用作被引用列。
   </para>
<!-- pgdoc-cn_end sig_en=9107d37a3528cdc8db3c844b42b5f6ea -->

<!-- pgdoc-cn_start sig_en=4e81fd555b7279bf6675dc6344414999 sig_cn_org=None source=14.1 
   <para>
    You can assign your own name for a foreign key constraint,
    in the usual way.
   </para>
________________________________________________________-->
   <para>
    你可以按常规方式为外键约束指定自己的名称。
   </para>
<!-- pgdoc-cn_end sig_en=4e81fd555b7279bf6675dc6344414999 -->

<!-- pgdoc-cn_start sig_en=65df68e512138d38fac503e761b9f32c sig_cn_org=None source=14.1 
   <para>
    A foreign key can also constrain and reference a group of columns.
    As usual, it then needs to be written in table constraint form.
    Here is a contrived syntax example:
<programlisting>
CREATE TABLE t1 (
  a integer PRIMARY KEY,
  b integer,
  c integer,
  <emphasis>FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)</emphasis>
);
</programlisting>
    Of course, the number and type of the constrained columns need to
    match the number and type of the referenced columns.
   </para>
________________________________________________________-->
   <para>
    一个外键也可以约束和引用一组列。照例，它需要被写成表约束的形式。下面是一个例子：
<programlisting>
CREATE TABLE t1 (
  a integer PRIMARY KEY,
  b integer,
  c integer,
  <emphasis>FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)</emphasis>
);
</programlisting>
    当然，被约束列的数量和类型应该匹配被引用列的数量和类型。
   </para>
<!-- pgdoc-cn_end sig_en=65df68e512138d38fac503e761b9f32c -->

<!-- pgdoc-cn_start sig_en=c8a16a41937edbf43409c9b57ef7856b sig_cn_org=None source=14.1 
   <indexterm>
    <primary>foreign key</primary>
    <secondary>self-referential</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>外键</primary>
    <secondary>自引用</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=c8a16a41937edbf43409c9b57ef7856b -->

<!-- pgdoc-cn_start sig_en=6db2199547f6b14040aeb76d27d94f8d sig_cn_org=None source=14.1 
   <para>
    Sometimes it is useful for the <quote>other table</quote> of a
    foreign key constraint to be the same table; this is called
    a <firstterm>self-referential</firstterm> foreign key.  For
    example, if you want rows of a table to represent nodes of a tree
    structure, you could write
<programlisting>
CREATE TABLE tree (
    node_id integer PRIMARY KEY,
    parent_id integer REFERENCES tree,
    name text,
    ...
);
</programlisting>
    A top-level node would have NULL <structfield>parent_id</structfield>,
    while non-NULL <structfield>parent_id</structfield> entries would be
    constrained to reference valid rows of the table.
   </para>
________________________________________________________-->
   <para>
    有时，外键约束的<quote>其它表</quote>是同一个表也是有用的；这称为<firstterm>自引用</firstterm> 外键。例如，如果希望表中的行表示树结构的节点，可以编写
<programlisting>
CREATE TABLE tree (
    node_id integer PRIMARY KEY,
    parent_id integer REFERENCES tree,
    name text,
    ...
);
</programlisting>
    顶级节点的<structfield>parent_id</structfield>可以为NULL，而非NULL的<structfield>parent_id</structfield>条目将被约束为引用表中的有效行。
   </para>
<!-- pgdoc-cn_end sig_en=6db2199547f6b14040aeb76d27d94f8d -->

<!-- pgdoc-cn_start sig_en=b33a4d72f50045779caee082a890817c sig_cn_org=None source=14.1 
   <para>
    A table can have more than one foreign key constraint.  This is
    used to implement many-to-many relationships between tables.  Say
    you have tables about products and orders, but now you want to
    allow one order to contain possibly many products (which the
    structure above did not allow).  You could use this table structure:
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products,
    order_id integer REFERENCES orders,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
</programlisting>
    Notice that the primary key overlaps with the foreign keys in
    the last table.
   </para>
________________________________________________________-->
   <para>
    一个表可以有超过一个的外键约束。这被用于实现表之间的多对多关系。例如我们有关于产品和订单的表，但我们现在希望一个订单能包含多种产品（这在上面的结构中是不允许的）。我们可以使用这种表结构：
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products,
    order_id integer REFERENCES orders,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
</programlisting>
    注意在最后一个表中主键和外键之间有重叠。
   </para>
<!-- pgdoc-cn_end sig_en=b33a4d72f50045779caee082a890817c -->

<!-- pgdoc-cn_start sig_en=69a5eaa10925e28aa05f4d50439f7961 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>CASCADE</primary>
    <secondary>foreign key action</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>CASCADE</primary>
    <secondary>foreign key action</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=69a5eaa10925e28aa05f4d50439f7961 -->

<!-- pgdoc-cn_start sig_en=8c77123cc9c76fcafc244346d540a712 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>RESTRICT</primary>
    <secondary>foreign key action</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>RESTRICT</primary>
    <secondary>foreign key action</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=8c77123cc9c76fcafc244346d540a712 -->

<!-- pgdoc-cn_start sig_en=747b684d4fecdd1d0c9a0afa016440a1 sig_cn_org=None source=14.1 
   <para>
    We know that the foreign keys disallow creation of orders that
    do not relate to any products.  But what if a product is removed
    after an order is created that references it?  SQL allows you to
    handle that as well.  Intuitively, we have a few options:
    <itemizedlist spacing="compact">
     <listitem><para>Disallow deleting a referenced product</para></listitem>
     <listitem><para>Delete the orders as well</para></listitem>
     <listitem><para>Something else?</para></listitem>
    </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    我们知道外键不允许创建与任何产品都不相关的订单。但如果一个产品在一个引用它的订单创建之后被移除会发生什么？SQL允许我们处理这种情况。直观上，我们有几种选项：
    <itemizedlist spacing="compact">
     <listitem><para>不允许删除一个被引用的产品</para></listitem>
     <listitem><para>同时也删除引用产品的订单</para></listitem>
     <listitem><para>其他？</para></listitem>
    </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=747b684d4fecdd1d0c9a0afa016440a1 -->

<!-- pgdoc-cn_start sig_en=a5e4470df42a2b9d154748028926726d sig_cn_org=None source=14.1 
   <para>
    To illustrate this, let's implement the following policy on the
    many-to-many relationship example above: when someone wants to
    remove a product that is still referenced by an order (via
    <literal>order_items</literal>), we disallow it.  If someone
    removes an order, the order items are removed as well:
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products <emphasis>ON DELETE RESTRICT</emphasis>,
    order_id integer REFERENCES orders <emphasis>ON DELETE CASCADE</emphasis>,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
</programlisting>
   </para>
________________________________________________________-->
   <para>
    为了说明这些，让我们在上面的多对多关系例子中实现下面的策略：当某人希望移除一个仍然被一个订单引用（通过<literal>order_items</literal>）的产品时 ，我们阻止它。如果某人移除一个订单，订单项也同时被移除：
<programlisting>
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);

CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    shipping_address text,
    ...
);

CREATE TABLE order_items (
    product_no integer REFERENCES products <emphasis>ON DELETE RESTRICT</emphasis>,
    order_id integer REFERENCES orders <emphasis>ON DELETE CASCADE</emphasis>,
    quantity integer,
    PRIMARY KEY (product_no, order_id)
);
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=a5e4470df42a2b9d154748028926726d -->

<!-- pgdoc-cn_start sig_en=11f287efa8f35f969f9818f26b7e463a sig_cn_org=None source=14.1 
   <para>
    Restricting and cascading deletes are the two most common options.
    <literal>RESTRICT</literal> prevents deletion of a
    referenced row. <literal>NO ACTION</literal> means that if any
    referencing rows still exist when the constraint is checked, an error
    is raised; this is the default behavior if you do not specify anything.
    (The essential difference between these two choices is that
    <literal>NO ACTION</literal> allows the check to be deferred until
    later in the transaction, whereas <literal>RESTRICT</literal> does not.)
    <literal>CASCADE</literal> specifies that when a referenced row is deleted,
    row(s) referencing it should be automatically deleted as well.
    There are two other options:
    <literal>SET NULL</literal> and <literal>SET DEFAULT</literal>.
    These cause the referencing column(s) in the referencing row(s)
    to be set to nulls or their default
    values, respectively, when the referenced row is deleted.
    Note that these do not excuse you from observing any constraints.
    For example, if an action specifies <literal>SET DEFAULT</literal>
    but the default value would not satisfy the foreign key constraint, the
    operation will fail.
   </para>
________________________________________________________-->
   <para>
    限制删除或者级联删除是两种最常见的选项。<literal>RESTRICT</literal>阻止删除一个被引用的行。<literal>NO ACTION</literal>表示在约束被检查时如果有任何引用行存在，则会抛出一个错误，这是我们没有指定任何东西时的默认行为（这两种选择的本质不同在于<literal>NO ACTION</literal>允许检查被推迟到事务的最后，而<literal>RESTRICT</literal>则不会）。<literal>CASCADE</literal>指定当一个被引用行被删除后，引用它的行也应该被自动删除。还有其他两种选项：<literal>SET NULL</literal>和<literal>SET DEFAULT</literal>。这些将导致在被引用行被删除后，引用行中的引用列被置为空值或它们的默认值。注意这些并不会是我们免于遵守任何约束。例如，如果一个动作指定了<literal>SET DEFAULT</literal>，但是默认值不满足外键约束，操作将会失败。
   </para>
<!-- pgdoc-cn_end sig_en=11f287efa8f35f969f9818f26b7e463a -->

<!-- pgdoc-cn_start sig_en=edf3df42beb7a223fe10c0d6874edd5d sig_cn_org=b6abdcd0f8affba654ce540a3e90489d source=15.7 
   <para>
    The appropriate choice of <literal>ON DELETE</literal> action depends on
    what kinds of objects the related tables represent.  When the referencing
    table represents something that is a component of what is represented by
    the referenced table and cannot exist independently, then
    <literal>CASCADE</literal> could be appropriate.  If the two tables
    represent independent objects, then <literal>RESTRICT</literal> or
    <literal>NO ACTION</literal> is more appropriate; an application that
    actually wants to delete both objects would then have to be explicit about
    this and run two delete commands.  In the above example, order items are
    part of an order, and it is convenient if they are deleted automatically
    if an order is deleted.  But products and orders are different things, and
    so making a deletion of a product automatically cause the deletion of some
    order items could be considered problematic.  The actions <literal>SET
    NULL</literal> or <literal>SET DEFAULT</literal> can be appropriate if a
    foreign-key relationship represents optional information.  For example, if
    the products table contained a reference to a product manager, and the
    product manager entry gets deleted, then setting the product's product
    manager to null or a default might be useful.
   </para>
________________________________________________________-->
   <para>
    适当选择<literal>ON DELETE</literal>操作取决于相关表所代表的对象类型。当引用表代表被引用表所代表的组件，并且不能独立存在时，<literal>CASCADE</literal>可能是合适的选择。
    如果这两个表代表独立的对象，则<literal>RESTRICT</literal>或<literal>NO ACTION</literal>更合适；实际上想要删除这两个对象的应用程序必须明确这一点，并运行两个删除命令。
    在上面的例子中，订单项目是订单的一部分，如果删除订单，则自动删除它们是方便的。但产品和订单是不同的东西，因此使产品的删除自动导致某些订单项目的删除可能被认为是有问题的。
    当外键关系表示可选信息时，<literal>SET NULL</literal>或<literal>SET DEFAULT</literal>操作可能是合适的。例如，如果产品表包含对产品经理的引用，并且产品经理条目被删除，则将产品的产品经理设置为null或默认值可能是有用的。
</para>
<!-- pgdoc-cn_end sig_en=edf3df42beb7a223fe10c0d6874edd5d -->

<!-- pgdoc-cn_start sig_en=439f0c5a89c4750bb247814dd1d67aef sig_cn_org=e54ffa9a1e4a6d49da73b3de85e029ce source=15.7 
   <para>
    The actions <literal>SET NULL</literal> and <literal>SET DEFAULT</literal>
    can take a column list to specify which columns to set.  Normally, all
    columns of the foreign-key constraint are set; setting only a subset is
    useful in some special cases.  Consider the following example:
<programlisting>
CREATE TABLE tenants (
    tenant_id integer PRIMARY KEY
);

CREATE TABLE users (
    tenant_id integer REFERENCES tenants ON DELETE CASCADE,
    user_id integer NOT NULL,
    PRIMARY KEY (tenant_id, user_id)
);

CREATE TABLE posts (
    tenant_id integer REFERENCES tenants ON DELETE CASCADE,
    post_id integer NOT NULL,
    author_id integer,
    PRIMARY KEY (tenant_id, post_id),
    FOREIGN KEY (tenant_id, author_id) REFERENCES users ON DELETE SET NULL <emphasis>(author_id)</emphasis>
);
</programlisting>
    Without the specification of the column, the foreign key would also set
    the column <literal>tenant_id</literal> to null, but that column is still
    required as part of the primary key.
   </para>
________________________________________________________-->
   <para>
    操作<literal>SET NULL</literal>和<literal>SET DEFAULT</literal>可以接受一个列列表来指定要设置的列。
    通常，外键约束的所有列都会被设置；仅设置子集在某些特殊情况下很有用。考虑以下示例：
<programlisting>
CREATE TABLE tenants (
    tenant_id integer PRIMARY KEY
);

CREATE TABLE users (
    tenant_id integer REFERENCES tenants ON DELETE CASCADE,
    user_id integer NOT NULL,
    PRIMARY KEY (tenant_id, user_id)
);

CREATE TABLE posts (
    tenant_id integer REFERENCES tenants ON DELETE CASCADE,
    post_id integer NOT NULL,
    author_id integer,
    PRIMARY KEY (tenant_id, post_id),
    FOREIGN KEY (tenant_id, author_id) REFERENCES users ON DELETE SET NULL <emphasis>(author_id)</emphasis>
);
</programlisting>
    如果没有指定列，外键也会将列<literal>tenant_id</literal>设置为null，但该列仍然是主键的一部分。
   </para>
<!-- pgdoc-cn_end sig_en=439f0c5a89c4750bb247814dd1d67aef -->

<!-- pgdoc-cn_start sig_en=378879e84bbcb8757a8f9304dca36191 sig_cn_org=06c762afa20317428b9733ebb2cf65bd source=15.7 
   <para>
    Analogous to <literal>ON DELETE</literal> there is also
    <literal>ON UPDATE</literal> which is invoked when a referenced
    column is changed (updated).  The possible actions are the same,
    except that column lists cannot be specified for <literal>SET
    NULL</literal> and <literal>SET DEFAULT</literal>.
    In this case, <literal>CASCADE</literal> means that the updated values of the
    referenced column(s) should be copied into the referencing row(s).
   </para>
________________________________________________________-->
   <para>
    与<literal>ON DELETE</literal>类似，还有<literal>ON UPDATE</literal>，当引用列被更改（更新）时调用。
    可能的操作相同，只是不能为<literal>SET NULL</literal>和<literal>SET DEFAULT</literal>指定列列表。
    在这种情况下，<literal>CASCADE</literal>表示引用列的更新值应复制到引用行中。
</para>
<!-- pgdoc-cn_end sig_en=378879e84bbcb8757a8f9304dca36191 -->

<!-- pgdoc-cn_start sig_en=4e28f03841c49f864903fceaf635de50 sig_cn_org=None source=14.1 
   <para>
    Normally, a referencing row need not satisfy the foreign key constraint
    if any of its referencing columns are null.  If <literal>MATCH FULL</literal>
    is added to the foreign key declaration, a referencing row escapes
    satisfying the constraint only if all its referencing columns are null
    (so a mix of null and non-null values is guaranteed to fail a
    <literal>MATCH FULL</literal> constraint).  If you don't want referencing rows
    to be able to avoid satisfying the foreign key constraint, declare the
    referencing column(s) as <literal>NOT NULL</literal>.
   </para>
________________________________________________________-->
   <para>
    正常情况下，如果一个引用行的任意一个引用列都为空，则它不需要满足外键约束。如果在外键定义中加入了<literal>MATCH FULL</literal>，一个引用行只有在它的所有引用列为空时才不需要满足外键约束（因此空和非空值的混合肯定会导致<literal>MATCH FULL</literal>约束失败）。如果不希望引用行能够避开外键约束，将引用行声明为<literal>NOT NULL</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=4e28f03841c49f864903fceaf635de50 -->

<!-- pgdoc-cn_start sig_en=5500c8faf5263073ab75b1ae1d5738cf sig_cn_org=8be08c7cd3995b7f30ddd778353528b0 source=15.7 
   <para>
    A foreign key must reference columns that either are a primary key or
    form a unique constraint, or are columns from a non-partial unique index.
    This means that the referenced columns always have an index to allow
    efficient lookups on whether a referencing row has a match.  Since a
    <command>DELETE</command> of a row from the referenced table or an
    <command>UPDATE</command> of a referenced column will require a scan of
    the referencing table for rows matching the old value, it is often a good
    idea to index the referencing columns too.  Because this is not always
    needed, and there are many choices available on how to index, the
    declaration of a foreign key constraint does not automatically create an
    index on the referencing columns.
   </para>
________________________________________________________-->
   <para>
    外键必须引用列，这些列要么是主键，要么形成唯一约束，要么是非部分唯一索引的列。
    这意味着引用列始终具有索引，以便有效地查找引用行是否有匹配项。
    由于从引用表中删除行或更新引用列将需要扫描引用表以查找与旧值匹配的行，
    因此通常也建议对引用列建立索引。因为这并不总是需要的，并且有许多可用的索引方式，
    所以外键约束的声明不会自动在引用列上创建索引。
   </para>
<!-- pgdoc-cn_end sig_en=5500c8faf5263073ab75b1ae1d5738cf -->

<!-- pgdoc-cn_start sig_en=47463c614a5c66a1a69b88e35df5e672 sig_cn_org=None source=14.1 
   <para>
    More information about updating and deleting data is in <xref
    linkend="dml"/>.  Also see the description of foreign key constraint
    syntax in the reference documentation for
    <xref linkend="sql-createtable"/>.
   </para>
________________________________________________________-->
   <para>
    更多关于更新和删除数据的信息请见<xref linkend="dml"/>。外键约束的语法描述请参考<xref linkend="sql-createtable"/>。
   </para>
<!-- pgdoc-cn_end sig_en=47463c614a5c66a1a69b88e35df5e672 -->
  </sect2>

  <sect2 id="ddl-constraints-exclusion">
<!-- pgdoc-cn_start sig_en=a7921baf3b1e0512cbc3e4b3ed918a01 sig_cn_org=None source=14.1 
   <title>Exclusion Constraints</title>
________________________________________________________-->
   <title>排他约束</title>
<!-- pgdoc-cn_end sig_en=a7921baf3b1e0512cbc3e4b3ed918a01 -->

<!-- pgdoc-cn_start sig_en=b726a86a30c6dc13c371d78b93a53d11 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>exclusion constraint</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>exclusion constraint</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=b726a86a30c6dc13c371d78b93a53d11 -->

<!-- pgdoc-cn_start sig_en=9a4db7ca093e2a677b41ecf5802456d8 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>constraint</primary>
    <secondary>exclusion</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>constraint</primary>
    <secondary>exclusion</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=9a4db7ca093e2a677b41ecf5802456d8 -->

<!-- pgdoc-cn_start sig_en=059804126bc71ff320b8e7c8404312f2 sig_cn_org=None source=14.1 
   <para>
    Exclusion constraints ensure that if any two rows are compared on
    the specified columns or expressions using the specified operators,
    at least one of these operator comparisons will return false or null.
    The syntax is:
<programlisting>
CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);
</programlisting>
   </para>
________________________________________________________-->
   <para>
    排他约束保证如果将任何两行的指定列或表达式使用指定操作符进行比较，至少其中一个操作符比较将会返回否或空值。语法是：
<programlisting>
CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=059804126bc71ff320b8e7c8404312f2 -->

<!-- pgdoc-cn_start sig_en=e0add66bf5d4eb6a357eb81de80ddff5 sig_cn_org=None source=14.1 
   <para>
    See also <link linkend="sql-createtable-exclude"><command>CREATE
    TABLE ... CONSTRAINT ... EXCLUDE</command></link> for details.
   </para>
________________________________________________________-->
   <para>
    详见<link linkend="sql-createtable-exclude"><command>CREATE
    TABLE ... CONSTRAINT ... EXCLUDE</command></link>。
   </para>
<!-- pgdoc-cn_end sig_en=e0add66bf5d4eb6a357eb81de80ddff5 -->

<!-- pgdoc-cn_start sig_en=313980a60064b1bdaf2b8042da64d9e3 sig_cn_org=None source=14.1 
   <para>
    Adding an exclusion constraint will automatically create an index
    of the type specified in the constraint declaration.
   </para>
________________________________________________________-->
   <para>
    增加一个排他约束将在约束声明所指定的类型上自动创建索引。
   </para>
<!-- pgdoc-cn_end sig_en=313980a60064b1bdaf2b8042da64d9e3 -->
  </sect2>
 </sect1>

 <sect1 id="ddl-system-columns">
<!-- pgdoc-cn_start sig_en=60f03d718091d8389d50bb8fe25cf786 sig_cn_org=None source=14.1 
  <title>System Columns</title>
________________________________________________________-->
  <title>系统列</title>
<!-- pgdoc-cn_end sig_en=60f03d718091d8389d50bb8fe25cf786 -->

<!-- pgdoc-cn_start sig_en=4b2bc0db5707c127b9604a7002470b2f sig_cn_org=None source=14.1 
  <para>
   Every table has several <firstterm>system columns</firstterm> that are
   implicitly defined by the system.  Therefore, these names cannot be
   used as names of user-defined columns.  (Note that these
   restrictions are separate from whether the name is a key word or
   not; quoting a name will not allow you to escape these
   restrictions.)  You do not really need to be concerned about these
   columns; just know they exist.
  </para>
________________________________________________________-->
  <para>
   每一个表都拥有一些由系统隐式定义的<firstterm>system columns</firstterm>。因此，这些列的名字不能像用户定义的列一样使用（注意这种限制与名称是否为关键词没有关系，即便用引号限定一个名称也无法绕过这种限制）。 事实上用户不需要关心这些列，只需要知道它们存在即可。
  </para>
<!-- pgdoc-cn_end sig_en=4b2bc0db5707c127b9604a7002470b2f -->

<!-- pgdoc-cn_start sig_en=28944219fa6a5561ed9ff5a3f2bb1293 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>column</primary>
   <secondary>system column</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>column</primary>
   <secondary>system column</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=28944219fa6a5561ed9ff5a3f2bb1293 -->

  <variablelist>
   <varlistentry>
<!-- pgdoc-cn_start sig_en=c60beea1b7b02f33c95a1155de2c905c sig_cn_org=None source=14.1 
    <term><structfield>tableoid</structfield></term>
________________________________________________________-->
    <term><structfield>tableoid</structfield></term>
<!-- pgdoc-cn_end sig_en=c60beea1b7b02f33c95a1155de2c905c -->
    <listitem>
<!-- pgdoc-cn_start sig_en=41f45d6087b932cc48ac9bdad03a5c5f sig_cn_org=None source=14.1 
     <indexterm>
      <primary>tableoid</primary>
     </indexterm>
________________________________________________________-->
     <indexterm>
      <primary>tableoid</primary>
     </indexterm>
<!-- pgdoc-cn_end sig_en=41f45d6087b932cc48ac9bdad03a5c5f -->

<!-- pgdoc-cn_start sig_en=0a4a1cdb72931fd0f5761cac7ea8f163 sig_cn_org=None source=14.1 
     <para>
      The OID of the table containing this row.  This column is
      particularly handy for queries that select from partitioned
      tables (see <xref linkend="ddl-partitioning"/>) or inheritance
      hierarchies (see <xref linkend="ddl-inherit"/>), since without it,
      it's difficult to tell which individual table a row came from.  The
      <structfield>tableoid</structfield> can be joined against the
      <structfield>oid</structfield> column of
      <structname>pg_class</structname> to obtain the table name.
     </para>
________________________________________________________-->
     <para>
      包含这一行的表的OID。该列是特别为从分区的表(见<xref linkend="ddl-partitioning"/>)或继承层次（见<xref linkend="ddl-inherit"/>）中选择的查询而准备，因为如果没有它将很难知道一行来自于哪个表。<structfield>tableoid</structfield>可以与<structname>pg_class</structname>的<structfield>oid</structfield>列进行连接来获得表的名称。
     </para>
<!-- pgdoc-cn_end sig_en=0a4a1cdb72931fd0f5761cac7ea8f163 -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=6ee0365eedb8d47008b6c7d1c58a6ae2 sig_cn_org=None source=14.1 
    <term><structfield>xmin</structfield></term>
________________________________________________________-->
    <term><structfield>xmin</structfield></term>
<!-- pgdoc-cn_end sig_en=6ee0365eedb8d47008b6c7d1c58a6ae2 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=766e5bc9447809fac71a27f16e880e2f sig_cn_org=None source=14.1 
     <indexterm>
      <primary>xmin</primary>
     </indexterm>
________________________________________________________-->
     <indexterm>
      <primary>xmin</primary>
     </indexterm>
<!-- pgdoc-cn_end sig_en=766e5bc9447809fac71a27f16e880e2f -->

<!-- pgdoc-cn_start sig_en=aba1dfcc40fdac9be90488d0c7068e65 sig_cn_org=None source=14.1 
     <para>
      The identity (transaction ID) of the inserting transaction for
      this row version.  (A row version is an individual state of a
      row; each update of a row creates a new row version for the same
      logical row.)
     </para>
________________________________________________________-->
     <para>
      插入该行版本的事务身份（事务ID）。一个行版本是一个行的一个特别版本，对一个逻辑行的每一次更新都将创建一个新的行版本。
     </para>
<!-- pgdoc-cn_end sig_en=aba1dfcc40fdac9be90488d0c7068e65 -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=02667d9bb1547c3eacf4c195cf8fc7a6 sig_cn_org=None source=14.1 
    <term><structfield>cmin</structfield></term>
________________________________________________________-->
    <term><structfield>cmin</structfield></term>
<!-- pgdoc-cn_end sig_en=02667d9bb1547c3eacf4c195cf8fc7a6 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=53d8d83b52bb8e5d2c1cbf69fad974e1 sig_cn_org=None source=14.1 
     <indexterm>
      <primary>cmin</primary>
     </indexterm>
________________________________________________________-->
     <indexterm>
      <primary>cmin</primary>
     </indexterm>
<!-- pgdoc-cn_end sig_en=53d8d83b52bb8e5d2c1cbf69fad974e1 -->

<!-- pgdoc-cn_start sig_en=9d2f7230990efdec83695e7758552465 sig_cn_org=None source=14.1 
     <para>
      The command identifier (starting at zero) within the inserting
      transaction.
     </para>
________________________________________________________-->
     <para>
      插入事务中的命令标识符（从0开始）。
     </para>
<!-- pgdoc-cn_end sig_en=9d2f7230990efdec83695e7758552465 -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=14ccd403e9aedf32d4ee5d76971bf258 sig_cn_org=None source=14.1 
    <term><structfield>xmax</structfield></term>
________________________________________________________-->
    <term><structfield>xmax</structfield></term>
<!-- pgdoc-cn_end sig_en=14ccd403e9aedf32d4ee5d76971bf258 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=278b526b844e97086510090c16284f92 sig_cn_org=None source=14.1 
     <indexterm>
      <primary>xmax</primary>
     </indexterm>
________________________________________________________-->
     <indexterm>
      <primary>xmax</primary>
     </indexterm>
<!-- pgdoc-cn_end sig_en=278b526b844e97086510090c16284f92 -->

<!-- pgdoc-cn_start sig_en=7700c4a819503c8b58ef82d5549dde3e sig_cn_org=None source=14.1 
     <para>
      The identity (transaction ID) of the deleting transaction, or
      zero for an undeleted row version.  It is possible for this column to
      be nonzero in a visible row version. That usually indicates that the
      deleting transaction hasn't committed yet, or that an attempted
      deletion was rolled back.
     </para>
________________________________________________________-->
     <para>
      删除事务的身份（事务ID），对于未删除的行版本为0。对于一个可见的行版本，该列值也可能为非零。这通常表示删除事务还没有提交，或者一个删除尝试被回滚。
     </para>
<!-- pgdoc-cn_end sig_en=7700c4a819503c8b58ef82d5549dde3e -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=7067c80e6bd4f5c1b2a7f41fc489d391 sig_cn_org=None source=14.1 
    <term><structfield>cmax</structfield></term>
________________________________________________________-->
    <term><structfield>cmax</structfield></term>
<!-- pgdoc-cn_end sig_en=7067c80e6bd4f5c1b2a7f41fc489d391 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=d569a7f23a26627b4e9b920b0a47b286 sig_cn_org=None source=14.1 
     <indexterm>
      <primary>cmax</primary>
     </indexterm>
________________________________________________________-->
     <indexterm>
      <primary>cmax</primary>
     </indexterm>
<!-- pgdoc-cn_end sig_en=d569a7f23a26627b4e9b920b0a47b286 -->

<!-- pgdoc-cn_start sig_en=d2b863c6b703e34b67c18d015282a9ed sig_cn_org=None source=14.1 
     <para>
      The command identifier within the deleting transaction, or zero.
     </para>
________________________________________________________-->
     <para>
      删除事务中的命令标识符，或者为0。
     </para>
<!-- pgdoc-cn_end sig_en=d2b863c6b703e34b67c18d015282a9ed -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=fd2d36ceb24a209a26c456be0a3890b7 sig_cn_org=None source=14.1 
    <term><structfield>ctid</structfield></term>
________________________________________________________-->
    <term><structfield>ctid</structfield></term>
<!-- pgdoc-cn_end sig_en=fd2d36ceb24a209a26c456be0a3890b7 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=3f0554eca27f51efd6e1c925d390db4c sig_cn_org=None source=14.1 
     <indexterm>
      <primary>ctid</primary>
     </indexterm>
________________________________________________________-->
     <indexterm>
      <primary>ctid</primary>
     </indexterm>
<!-- pgdoc-cn_end sig_en=3f0554eca27f51efd6e1c925d390db4c -->

<!-- pgdoc-cn_start sig_en=6f4dba58f6f8066d530e72efe1b48f95 sig_cn_org=None source=14.1 
     <para>
      The physical location of the row version within its table.  Note that
      although the <structfield>ctid</structfield> can be used to
      locate the row version very quickly, a row's
      <structfield>ctid</structfield> will change if it is
      updated or moved by <command>VACUUM FULL</command>.  Therefore
      <structfield>ctid</structfield> is useless as a long-term row
      identifier.  A primary key should be used to identify logical rows.
     </para>
________________________________________________________-->
     <para>
      行版本在其表中的物理位置。注意尽管<structfield>ctid</structfield>可以被用来非常快速地定位行版本，但是一个行的<structfield>ctid</structfield>会在被更新或者被<command>VACUUM FULL</command>移动时改变。因此，<structfield>ctid</structfield>不能作为一个长期行标识符。
      应使用主键来标识逻辑行。
     </para>
<!-- pgdoc-cn_end sig_en=6f4dba58f6f8066d530e72efe1b48f95 -->
    </listitem>
   </varlistentry>
  </variablelist>

<!-- pgdoc-cn_start sig_en=29f2bbc4c605f54bbebabfb0e361766f sig_cn_org=None source=14.1 
   <para>
    Transaction identifiers are also 32-bit quantities.  In a
    long-lived database it is possible for transaction IDs to wrap
    around.  This is not a fatal problem given appropriate maintenance
    procedures; see <xref linkend="maintenance"/> for details.  It is
    unwise, however, to depend on the uniqueness of transaction IDs
    over the long term (more than one billion transactions).
   </para>
________________________________________________________-->
   <para>
    事务标识符也是32位量。在一个历时长久的数据库中事务ID同样会绕回。但如果采取适当的维护过程，这不会是一个致命的问题，详见<xref linkend="maintenance"/>。但是，长期（超过10亿个事务）依赖事务ID的唯一性是不明智的。
   </para>
<!-- pgdoc-cn_end sig_en=29f2bbc4c605f54bbebabfb0e361766f -->

<!-- pgdoc-cn_start sig_en=33995f6783f2135f17827714d1f02b04 sig_cn_org=None source=14.1 
   <para>
    Command identifiers are also 32-bit quantities.  This creates a hard limit
    of 2<superscript>32</superscript> (4 billion) <acronym>SQL</acronym> commands
    within a single transaction.  In practice this limit is not a
    problem &mdash; note that the limit is on the number of
    <acronym>SQL</acronym> commands, not the number of rows processed.
    Also, only commands that actually modify the database contents will
    consume a command identifier.
   </para>
________________________________________________________-->
   <para>
    命令标识符也是32位量。这对一个事务中包含的<acronym>SQL</acronym>命令设置了一个硬极限：
    2<superscript>32</superscript>（40亿）。在实践中，该限制并不是问题 &mdash; 注意该限制只是针对<acronym>SQL</acronym>命令的数目而不是被处理的行数。同样，只有真正
    修改了数据库内容的命令才会消耗一个命令标识符。
   </para>
<!-- pgdoc-cn_end sig_en=33995f6783f2135f17827714d1f02b04 -->
 </sect1>

 <sect1 id="ddl-alter">
<!-- pgdoc-cn_start sig_en=5684e977f19614274d65e32828d6b499 sig_cn_org=None source=14.1 
  <title>Modifying Tables</title>
________________________________________________________-->
  <title>修改表</title>
<!-- pgdoc-cn_end sig_en=5684e977f19614274d65e32828d6b499 -->

<!-- pgdoc-cn_start sig_en=ecd9ab6cc1c46d469384aa80cea0022a sig_cn_org=None source=14.1 
  <indexterm zone="ddl-alter">
   <primary>table</primary>
   <secondary>modifying</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="ddl-alter">
   <primary>table</primary>
   <secondary>modifying</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=ecd9ab6cc1c46d469384aa80cea0022a -->

<!-- pgdoc-cn_start sig_en=4fc78dd9c4255ba02df1f45517be57e2 sig_cn_org=None source=14.1 
  <para>
   When you create a table and you realize that you made a mistake, or
   the requirements of the application change, you can drop the
   table and create it again.  But this is not a convenient option if
   the table is already filled with data, or if the table is
   referenced by other database objects (for instance a foreign key
   constraint).  Therefore <productname>PostgreSQL</productname>
   provides a family of commands to make modifications to existing
   tables.  Note that this is conceptually distinct from altering
   the data contained in the table: here we are interested in altering
   the definition, or structure, of the table.
  </para>
________________________________________________________-->
  <para>
   当我们已经创建了一个表并意识到犯了一个错误或者应用需求发生改变时，我们可以移除表并重新创建它。但如果表中已经被填充数据或者被其他数据库对象引用（例如有一个外键约束），这种做法就显得很不方便。因此，<productname>PostgreSQL</productname>提供了一族命令来对已有的表进行修改。注意这和修改表中所包含的数据是不同的，这里要做的是对表的定义或者说结构进行修改。
  </para>
<!-- pgdoc-cn_end sig_en=4fc78dd9c4255ba02df1f45517be57e2 -->

<!-- pgdoc-cn_start sig_en=ade6926ee0a3226d03dec19b0caf66a4 sig_cn_org=None source=14.1 
  <para>
   You can:
   <itemizedlist spacing="compact">
    <listitem>
     <para>Add columns</para>
    </listitem>
    <listitem>
     <para>Remove columns</para>
    </listitem>
    <listitem>
     <para>Add constraints</para>
    </listitem>
    <listitem>
     <para>Remove constraints</para>
    </listitem>
    <listitem>
     <para>Change default values</para>
    </listitem>
    <listitem>
     <para>Change column data types</para>
    </listitem>
    <listitem>
     <para>Rename columns</para>
    </listitem>
    <listitem>
     <para>Rename tables</para>
    </listitem>
   </itemizedlist>

   All these actions are performed using the
   <xref linkend="sql-altertable"/>
   command, whose reference page contains details beyond those given
   here.
  </para>
________________________________________________________-->
  <para>
   利用这些命令，我们可以：
   <itemizedlist spacing="compact">
    <listitem>
     <para>增加列</para>
    </listitem>
    <listitem>
     <para>移除列</para>
    </listitem>
    <listitem>
     <para>增加约束</para>
    </listitem>
    <listitem>
     <para>移除约束</para>
    </listitem>
    <listitem>
     <para>修改默认值</para>
    </listitem>
    <listitem>
     <para>修改列数据类型</para>
    </listitem>
    <listitem>
     <para>重命名列</para>
    </listitem>
    <listitem>
     <para>重命名表</para>
    </listitem>
   </itemizedlist>

   所有这些动作都由<xref linkend="sql-altertable"/>命令执行，其参考页面中包含更详细的信息。
  </para>
<!-- pgdoc-cn_end sig_en=ade6926ee0a3226d03dec19b0caf66a4 -->

  <sect2 id="ddl-alter-adding-a-column">
<!-- pgdoc-cn_start sig_en=027c9ce913a73924a98ced8cee3306f8 sig_cn_org=None source=14.1 
   <title>Adding a Column</title>
________________________________________________________-->
   <title>增加列</title>
<!-- pgdoc-cn_end sig_en=027c9ce913a73924a98ced8cee3306f8 -->

<!-- pgdoc-cn_start sig_en=f8805502847834edc5de6eb9632ea121 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>column</primary>
    <secondary>adding</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>column</primary>
    <secondary>adding</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=f8805502847834edc5de6eb9632ea121 -->

<!-- pgdoc-cn_start sig_en=0f8256d24c93442bf733ec02b3c4f528 sig_cn_org=None source=14.1 
   <para>
    To add a column, use a command like:
<programlisting>
ALTER TABLE products ADD COLUMN description text;
</programlisting>
    The new column is initially filled with whatever default
    value is given (null if you don't specify a <literal>DEFAULT</literal> clause).
   </para>
________________________________________________________-->
   <para>
    要增加一个列，可以使用这样的命令：
<programlisting>
ALTER TABLE products ADD COLUMN description text;
</programlisting>
    新列将被默认值所填充（如果没有指定<literal>DEFAULT</literal>子句，则会填充空值）。
   </para>
<!-- pgdoc-cn_end sig_en=0f8256d24c93442bf733ec02b3c4f528 -->

   <tip>
<!-- pgdoc-cn_start sig_en=1a2e90a2a70a62e9a272274e5c052db8 sig_cn_org=None source=14.1 
    <para>
     From <productname>PostgreSQL</productname> 11, adding a column with
     a constant default value no longer means that each row of the table
     needs to be updated when the <command>ALTER TABLE</command> statement
     is executed. Instead, the default value will be returned the next time
     the row is accessed, and applied when the table is rewritten, making
     the <command>ALTER TABLE</command> very fast even on large tables.
    </para>
________________________________________________________-->
    <para>
     从 <productname>PostgreSQL</productname> 11开始，添加一个具有常量默认值的列不再意味着在执行<command>ALTER TABLE</command> 语句时需要更新表的每一行。
     相反，默认值将在下次访问该行时返回，并在表被重写时应用，从而使得<command>ALTER TABLE</command>即使在大表上也非常快。
    </para>
<!-- pgdoc-cn_end sig_en=1a2e90a2a70a62e9a272274e5c052db8 -->

<!-- pgdoc-cn_start sig_en=7cd9e57d5310c7319599a934fcaa8281 sig_cn_org=None source=14.1 
    <para>
     However, if the default value is volatile (e.g.,
     <function>clock_timestamp()</function>)
     each row will need to be updated with the value calculated at the time
     <command>ALTER TABLE</command> is executed. To avoid a potentially
     lengthy update operation, particularly if you intend to fill the column
     with mostly nondefault values anyway, it may be preferable to add the
     column with no default, insert the correct values using
     <command>UPDATE</command>, and then add any desired default as described
     below.
    </para>
________________________________________________________-->
    <para>
     但是，如果默认值是可变的（例如<function>clock_timestamp()</function>），则每一行需要被<command>ALTER TABLE</command>被执行时计算的值更新。
     为避免潜在的长时间的更新操作，特别是如果你想要用大多数非默认值填充列，那么最好添加没有默认值的列，再用 <command>UPDATE</command>插入正确的值，然后按照下面所述添加任何期望的默认值。
    </para>
<!-- pgdoc-cn_end sig_en=7cd9e57d5310c7319599a934fcaa8281 -->
   </tip>

<!-- pgdoc-cn_start sig_en=7a86b3f75fb5c142abf74f976128e819 sig_cn_org=None source=14.1 
   <para>
    You can also define constraints on the column at the same time,
    using the usual syntax:
<programlisting>
ALTER TABLE products ADD COLUMN description text CHECK (description &lt;&gt; '');
</programlisting>
    In fact all the options that can be applied to a column description
    in <command>CREATE TABLE</command> can be used here.  Keep in mind however
    that the default value must satisfy the given constraints, or the
    <literal>ADD</literal> will fail.  Alternatively, you can add
    constraints later (see below) after you've filled in the new column
    correctly.
   </para>
________________________________________________________-->
   <para>
    也可以同时为列定义约束，语法：
<programlisting>
ALTER TABLE products ADD COLUMN description text CHECK (description &lt;&gt; '');
</programlisting>
    事实上<command>CREATE TABLE</command>中关于一列的描述都可以应用在这里。记住不管怎样，默认值必须满足给定的约束，否则<literal>ADD</literal>将会失败。也可以先将新列正确地填充好，然后再增加约束（见后文）。
   </para>
<!-- pgdoc-cn_end sig_en=7a86b3f75fb5c142abf74f976128e819 -->

  </sect2>

  <sect2 id="ddl-alter-removing-a-column">
<!-- pgdoc-cn_start sig_en=99700e29fbeebfd4ecde074216305423 sig_cn_org=None source=14.1 
   <title>Removing a Column</title>
________________________________________________________-->
   <title>移除列</title>
<!-- pgdoc-cn_end sig_en=99700e29fbeebfd4ecde074216305423 -->

<!-- pgdoc-cn_start sig_en=ec1b944f42edd2c979a555ed930d9d3a sig_cn_org=None source=14.1 
   <indexterm>
    <primary>column</primary>
    <secondary>removing</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>column</primary>
    <secondary>removing</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=ec1b944f42edd2c979a555ed930d9d3a -->

<!-- pgdoc-cn_start sig_en=cce4776402e0794731272a914d7ac237 sig_cn_org=None source=14.1 
   <para>
    To remove a column, use a command like:
<programlisting>
ALTER TABLE products DROP COLUMN description;
</programlisting>
    Whatever data was in the column disappears.  Table constraints involving
    the column are dropped, too.  However, if the column is referenced by a
    foreign key constraint of another table,
    <productname>PostgreSQL</productname> will not silently drop that
    constraint.  You can authorize dropping everything that depends on
    the column by adding <literal>CASCADE</literal>:
<programlisting>
ALTER TABLE products DROP COLUMN description CASCADE;
</programlisting>
    See <xref linkend="ddl-depend"/> for a description of the general
    mechanism behind this.
   </para>
________________________________________________________-->
   <para>
    为了移除一个列，使用如下的命令：
<programlisting>
ALTER TABLE products DROP COLUMN description;
</programlisting>
    列中的数据将会消失。涉及到该列的表约束也会被移除。然而，如果该列被另一个表的外键所引用，<productname>PostgreSQL</productname>不会安静地移除该约束。我们可以通过增加<literal>CASCADE</literal>来授权移除任何依赖于被删除列的所有东西：
<programlisting>
ALTER TABLE products DROP COLUMN description CASCADE;
</programlisting>
    关于这个操作背后的一般性机制请见<xref linkend="ddl-depend"/>。
   </para>
<!-- pgdoc-cn_end sig_en=cce4776402e0794731272a914d7ac237 -->
  </sect2>

  <sect2 id="ddl-alter-adding-a-constraint">
<!-- pgdoc-cn_start sig_en=f26ddc67b8a648f09684d159c4174fca sig_cn_org=None source=14.1 
   <title>Adding a Constraint</title>
________________________________________________________-->
   <title>增加约束</title>
<!-- pgdoc-cn_end sig_en=f26ddc67b8a648f09684d159c4174fca -->

<!-- pgdoc-cn_start sig_en=ae60f108fdbb6f34594e0546cb7b291c sig_cn_org=None source=14.1 
   <indexterm>
    <primary>constraint</primary>
    <secondary>adding</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>constraint</primary>
    <secondary>adding</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=ae60f108fdbb6f34594e0546cb7b291c -->

<!-- pgdoc-cn_start sig_en=27b15db5c71e93f7a89b7a5750c62cb5 sig_cn_org=None source=14.1 
   <para>
    To add a constraint, the table constraint syntax is used.  For example:
<programlisting>
ALTER TABLE products ADD CHECK (name &lt;&gt; '');
ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);
ALTER TABLE products ADD FOREIGN KEY (product_group_id) REFERENCES product_groups;
</programlisting>
    To add a not-null constraint, which cannot be written as a table
    constraint, use this syntax:
<programlisting>
ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    为了增加一个约束，可以使用表约束的语法，例如：
<programlisting>
ALTER TABLE products ADD CHECK (name &lt;&gt; '');
ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);
ALTER TABLE products ADD FOREIGN KEY (product_group_id) REFERENCES product_groups;
</programlisting>
    要增加一个不能写成表约束的非空约束，可使用语法：
<programlisting>
ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=27b15db5c71e93f7a89b7a5750c62cb5 -->

<!-- pgdoc-cn_start sig_en=33d149cdf7ca344d5d3a3d79675b581b sig_cn_org=None source=14.1 
   <para>
    The constraint will be checked immediately, so the table data must
    satisfy the constraint before it can be added.
   </para>
________________________________________________________-->
   <para>
    该约束会立即被检查，所以表中的数据必须在约束被增加之前就已经符合约束。
   </para>
<!-- pgdoc-cn_end sig_en=33d149cdf7ca344d5d3a3d79675b581b -->
  </sect2>

  <sect2 id="ddl-alter-removing-a-constraint">
<!-- pgdoc-cn_start sig_en=fbf6d83f8475652f423206a1af1f5abb sig_cn_org=None source=14.1 
   <title>Removing a Constraint</title>
________________________________________________________-->
   <title>移除约束</title>
<!-- pgdoc-cn_end sig_en=fbf6d83f8475652f423206a1af1f5abb -->

<!-- pgdoc-cn_start sig_en=ab560c06c185f171ae5b78fab7e2026e sig_cn_org=None source=14.1 
   <indexterm>
    <primary>constraint</primary>
    <secondary>removing</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>constraint</primary>
    <secondary>removing</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=ab560c06c185f171ae5b78fab7e2026e -->

<!-- pgdoc-cn_start sig_en=590e3a86c68452d467f40856183add52 sig_cn_org=None source=14.1 
   <para>
    To remove a constraint you need to know its name.  If you gave it
    a name then that's easy.  Otherwise the system assigned a
    generated name, which you need to find out.  The
    <application>psql</application> command <literal>\d
    <replaceable>tablename</replaceable></literal> can be helpful
    here; other interfaces might also provide a way to inspect table
    details.  Then the command is:
<programlisting>
ALTER TABLE products DROP CONSTRAINT some_name;
</programlisting>
    (If you are dealing with a generated constraint name like <literal>$2</literal>,
    don't forget that you'll need to double-quote it to make it a valid
    identifier.)
   </para>
________________________________________________________-->
   <para>
    为了移除一个约束首先需要知道它的名称。如果在创建时已经给它指定了名称，那么事情就变得很容易。否则约束的名称是由系统生成的，我们必须先找出这个名称。<application>psql</application>的命令<literal>\d
    <replaceable>表名</replaceable></literal>将会对此有所帮助，其他接口也会提供方法来查看表的细节。因此命令是：
<programlisting>
ALTER TABLE products DROP CONSTRAINT some_name;
</programlisting>
    （如果处理的是自动生成的约束名称，如<literal>$2</literal>，别忘了用双引号使它变成一个合法的标识符。）
   </para>
<!-- pgdoc-cn_end sig_en=590e3a86c68452d467f40856183add52 -->

<!-- pgdoc-cn_start sig_en=c7ff795fa72c6920d3d8bb7ef062e77b sig_cn_org=None source=14.1 
   <para>
    As with dropping a column, you need to add <literal>CASCADE</literal> if you
    want to drop a constraint that something else depends on.  An example
    is that a foreign key constraint depends on a unique or primary key
    constraint on the referenced column(s).
   </para>
________________________________________________________-->
   <para>
    和移除一个列相似，如果需要移除一个被某些别的东西依赖的约束，也需要加上<literal>CASCADE</literal>。一个例子是一个外键约束依赖于被引用列上的一个唯一或者主键约束。
   </para>
<!-- pgdoc-cn_end sig_en=c7ff795fa72c6920d3d8bb7ef062e77b -->

<!-- pgdoc-cn_start sig_en=dfd5c8b5720d99290d59a12020cd1daa sig_cn_org=None source=14.1 
   <para>
    This works the same for all constraint types except not-null
    constraints. To drop a not null constraint use:
<programlisting>
ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;
</programlisting>
    (Recall that not-null constraints do not have names.)
   </para>
________________________________________________________-->
   <para>
    这对除了非空约束之外的所有约束类型都一样有效。为了移除一个非空约束可以用：
<programlisting>
ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;
</programlisting>
    （回忆一下，非空约束是没有名称的，所以不能用第一种方式。）
   </para>
<!-- pgdoc-cn_end sig_en=dfd5c8b5720d99290d59a12020cd1daa -->
  </sect2>

  <sect2>
<!-- pgdoc-cn_start sig_en=d54d3483d08bd2232abc20fbc257b57a sig_cn_org=None source=14.1 
   <title>Changing a Column's Default Value</title>
________________________________________________________-->
   <title>更改列的默认值</title>
<!-- pgdoc-cn_end sig_en=d54d3483d08bd2232abc20fbc257b57a -->

<!-- pgdoc-cn_start sig_en=40d3551a579d53aafd6cdcfff8c9bb3e sig_cn_org=None source=14.1 
   <indexterm>
    <primary>default value</primary>
    <secondary>changing</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>default value</primary>
    <secondary>changing</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=40d3551a579d53aafd6cdcfff8c9bb3e -->

<!-- pgdoc-cn_start sig_en=6fa3b1751bfd0e15dc51a53464e2f152 sig_cn_org=None source=14.1 
   <para>
    To set a new default for a column, use a command like:
<programlisting>
ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;
</programlisting>
    Note that this doesn't affect any existing rows in the table, it
    just changes the default for future <command>INSERT</command> commands.
   </para>
________________________________________________________-->
   <para>
    要为一个列设置一个新默认值，使用命令：
<programlisting>
ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;
</programlisting>
    注意这不会影响任何表中已经存在的行，它只是为未来的<command>INSERT</command>命令改变了默认值。
   </para>
<!-- pgdoc-cn_end sig_en=6fa3b1751bfd0e15dc51a53464e2f152 -->

<!-- pgdoc-cn_start sig_en=5945832e4cfd1c2050f54ff4d9d07b68 sig_cn_org=None source=14.1 
   <para>
    To remove any default value, use:
<programlisting>
ALTER TABLE products ALTER COLUMN price DROP DEFAULT;
</programlisting>
    This is effectively the same as setting the default to null.
    As a consequence, it is not an error
    to drop a default where one hadn't been defined, because the
    default is implicitly the null value.
   </para>
________________________________________________________-->
   <para>
    要移除任何默认值，使用：
<programlisting>
ALTER TABLE products ALTER COLUMN price DROP DEFAULT;
</programlisting>
    这等同于将默认值设置为空值。相应的，试图删除一个未被定义的默认值并不会引发错误，因为默认值已经被隐式地设置为空值。
   </para>
<!-- pgdoc-cn_end sig_en=5945832e4cfd1c2050f54ff4d9d07b68 -->
  </sect2>

  <sect2>
<!-- pgdoc-cn_start sig_en=40227326e9e9c6ea562a4170b34d00cf sig_cn_org=None source=14.1 
   <title>Changing a Column's Data Type</title>
________________________________________________________-->
   <title>修改列的数据类型</title>
<!-- pgdoc-cn_end sig_en=40227326e9e9c6ea562a4170b34d00cf -->

<!-- pgdoc-cn_start sig_en=6a41f73567986e23b2da5786bee9f687 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>column data type</primary>
    <secondary>changing</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>column data type</primary>
    <secondary>changing</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=6a41f73567986e23b2da5786bee9f687 -->

<!-- pgdoc-cn_start sig_en=668f165c6be95eee086aa0228b5b388b sig_cn_org=None source=14.1 
   <para>
    To convert a column to a different data type, use a command like:
<programlisting>
ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);
</programlisting>
    This will succeed only if each existing entry in the column can be
    converted to the new type by an implicit cast.  If a more complex
    conversion is needed, you can add a <literal>USING</literal> clause that
    specifies how to compute the new values from the old.
   </para>
________________________________________________________-->
   <para>
    为了将一个列转换为一种不同的数据类型，使用如下命令：
<programlisting>
ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);
</programlisting>
    只有当列中的每一个项都能通过一个隐式造型转换为新的类型时该操作才能成功。如果需要一种更复杂的转换，应该加上一个<literal>USING</literal>子句来指定应该如何把旧值转换为新值。
   </para>
<!-- pgdoc-cn_end sig_en=668f165c6be95eee086aa0228b5b388b -->

<!-- pgdoc-cn_start sig_en=ff00a50cfcba5f7c99414e5b7d7ff78b sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> will attempt to convert the column's
    default value (if any) to the new type, as well as any constraints
    that involve the column.  But these conversions might fail, or might
    produce surprising results.  It's often best to drop any constraints
    on the column before altering its type, and then add back suitably
    modified constraints afterwards.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>将尝试把列的默认值转换为新类型，其他涉及到该列的任何约束也是一样。但是这些转换可能失败或者产生奇特的结果。因此最好在修改类型之前先删除该列上所有的约束，然后在修改完类型后重新加上相应修改过的约束。
   </para>
<!-- pgdoc-cn_end sig_en=ff00a50cfcba5f7c99414e5b7d7ff78b -->
  </sect2>

  <sect2>
<!-- pgdoc-cn_start sig_en=2eddda4a2ec30e26064c5ed249010c2f sig_cn_org=None source=14.1 
   <title>Renaming a Column</title>
________________________________________________________-->
   <title>重命名列</title>
<!-- pgdoc-cn_end sig_en=2eddda4a2ec30e26064c5ed249010c2f -->

<!-- pgdoc-cn_start sig_en=9ef7271b558608257afae876fb8a573c sig_cn_org=None source=14.1 
   <indexterm>
    <primary>column</primary>
    <secondary>renaming</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>column</primary>
    <secondary>renaming</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=9ef7271b558608257afae876fb8a573c -->

<!-- pgdoc-cn_start sig_en=8bc544679ef5257ac614c404e25f1523 sig_cn_org=None source=14.1 
   <para>
    To rename a column:
<programlisting>
ALTER TABLE products RENAME COLUMN product_no TO product_number;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    要重命名一个列：
<programlisting>
ALTER TABLE products RENAME COLUMN product_no TO product_number;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=8bc544679ef5257ac614c404e25f1523 -->
  </sect2>

  <sect2>
<!-- pgdoc-cn_start sig_en=6dd2cb65e42c1169e681539be3c258d9 sig_cn_org=None source=14.1 
   <title>Renaming a Table</title>
________________________________________________________-->
   <title>重命名表</title>
<!-- pgdoc-cn_end sig_en=6dd2cb65e42c1169e681539be3c258d9 -->

<!-- pgdoc-cn_start sig_en=6ab74815eb3b9a9bcd2530e214379b63 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>table</primary>
    <secondary>renaming</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>table</primary>
    <secondary>renaming</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=6ab74815eb3b9a9bcd2530e214379b63 -->

<!-- pgdoc-cn_start sig_en=fa464f94aba73e9f581fccdd2a414305 sig_cn_org=None source=14.1 
   <para>
    To rename a table:
<programlisting>
ALTER TABLE products RENAME TO items;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    要重命名一个表：
<programlisting>
ALTER TABLE products RENAME TO items;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=fa464f94aba73e9f581fccdd2a414305 -->
  </sect2>
 </sect1>

 <sect1 id="ddl-priv">
<!-- pgdoc-cn_start sig_en=13cba4791f3b1778f8daa6f35b4036f4 sig_cn_org=None source=14.1 
  <title>Privileges</title>
________________________________________________________-->
  <title>权限</title>
<!-- pgdoc-cn_end sig_en=13cba4791f3b1778f8daa6f35b4036f4 -->

<!-- pgdoc-cn_start sig_en=148cf7e2b975274ba3115b1e8f3dbd21 sig_cn_org=None source=14.1 
  <indexterm zone="ddl-priv">
   <primary>privilege</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="ddl-priv">
   <primary>privilege</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=148cf7e2b975274ba3115b1e8f3dbd21 -->

<!-- pgdoc-cn_start sig_en=0b12630ddcffaf0095b096e0033ee1b4 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>permission</primary>
   <see>privilege</see>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>permission</primary>
   <see>privilege</see>
  </indexterm>
<!-- pgdoc-cn_end sig_en=0b12630ddcffaf0095b096e0033ee1b4 -->

<!-- pgdoc-cn_start sig_en=6bb2e632cf53c3a2e175d2a8e60a0b05 sig_cn_org=None source=14.1 
  <indexterm zone="ddl-priv">
   <primary>owner</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="ddl-priv">
   <primary>owner</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=6bb2e632cf53c3a2e175d2a8e60a0b05 -->

<!-- pgdoc-cn_start sig_en=b74d4b604e51e9655c2b2ebae002b621 sig_cn_org=None source=14.1 
  <indexterm zone="ddl-priv">
   <primary>GRANT</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="ddl-priv">
   <primary>GRANT</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=b74d4b604e51e9655c2b2ebae002b621 -->

<!-- pgdoc-cn_start sig_en=554c6f8431e993835c752e602eaac122 sig_cn_org=None source=14.1 
  <indexterm zone="ddl-priv">
   <primary>REVOKE</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="ddl-priv">
   <primary>REVOKE</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=554c6f8431e993835c752e602eaac122 -->

<!-- pgdoc-cn_start sig_en=a761bd342730ad34d5bb3f6caa92ce44 sig_cn_org=None source=14.1 
  <indexterm zone="ddl-priv">
   <primary>ACL</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="ddl-priv">
   <primary>ACL</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=a761bd342730ad34d5bb3f6caa92ce44 -->

<!-- pgdoc-cn_start sig_en=6effdcf33e8a347ffe40380150ff8675 sig_cn_org=None source=14.1 
  <para>
   When an object is created, it is assigned an owner. The
   owner is normally the role that executed the creation statement.
   For most kinds of objects, the initial state is that only the owner
   (or a superuser) can do anything with the object. To allow
   other roles to use it, <firstterm>privileges</firstterm> must be
   granted.
  </para>
________________________________________________________-->
  <para>
   一旦一个对象被创建，它会被分配一个所有者。所有者通常是执行创建语句的角色。对于大部分类型的对象，初始状态下只有所有者（或者超级用户）能够对该对象做任何事情。为了允许其他角色使用它，必须分配<firstterm>权限</firstterm>。
  </para>
<!-- pgdoc-cn_end sig_en=6effdcf33e8a347ffe40380150ff8675 -->

<!-- pgdoc-cn_start sig_en=cf23e42e72119eee361b97b885344ce5 sig_cn_org=cdec3e286e840ebce1e5c14c5a2ea5ba source=15.7 
  <para>
   There are different kinds of privileges: <literal>SELECT</literal>,
   <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>,
   <literal>TRUNCATE</literal>, <literal>REFERENCES</literal>, <literal>TRIGGER</literal>,
   <literal>CREATE</literal>, <literal>CONNECT</literal>, <literal>TEMPORARY</literal>,
   <literal>EXECUTE</literal>, <literal>USAGE</literal>, <literal>SET</literal>
   and <literal>ALTER SYSTEM</literal>.
   The privileges applicable to a particular
   object vary depending on the object's type (table, function, etc.).
   More detail about the meanings of these privileges appears below.
   The following sections and chapters will also show you how
   these privileges are used.
  </para>
________________________________________________________-->
  <para>
   有不同种类的权限：<literal>SELECT</literal>、<literal>INSERT</literal>、<literal>UPDATE</literal>、
   <literal>DELETE</literal>、<literal>TRUNCATE</literal>、<literal>REFERENCES</literal>、
   <literal>TRIGGER</literal>、<literal>CREATE</literal>、<literal>CONNECT</literal>、
   <literal>TEMPORARY</literal>、<literal>EXECUTE</literal>、<literal>USAGE</literal>、
   <literal>SET</literal>和<literal>ALTER SYSTEM</literal>。
   适用于特定对象的权限取决于对象的类型（表、函数等）。
   有关这些权限含义的更多详细信息如下所示。
   接下来的章节将向您展示这些权限如何使用。
</para>
<!-- pgdoc-cn_end sig_en=cf23e42e72119eee361b97b885344ce5 -->

<!-- pgdoc-cn_start sig_en=00ef58dd8ea3c415a01d4e499a1735af sig_cn_org=None source=14.1 
  <para>
   The right to modify or destroy an object is inherent in being the
   object's owner, and cannot be granted or revoked in itself.
   (However, like all privileges, that right can be inherited by
   members of the owning role; see <xref linkend="role-membership"/>.)
  </para>
________________________________________________________-->
  <para>
   修改或销毁一个对象的权利是作为该对象的所有者所固有的，不能授予或撤销其本身。
   （但是，与所有特权一样，该权利可以由拥有角色的成员继承;请参阅<xref linkend="role-membership"/>。）
  </para>
<!-- pgdoc-cn_end sig_en=00ef58dd8ea3c415a01d4e499a1735af -->

<!-- pgdoc-cn_start sig_en=920772440417e931a1a6f7ad5722abee sig_cn_org=None source=14.1 
  <para>
   An object can be assigned to a new owner with an <command>ALTER</command>
   command of the appropriate kind for the object, for example
<programlisting>
ALTER TABLE <replaceable>table_name</replaceable> OWNER TO <replaceable>new_owner</replaceable>;
</programlisting>
   Superusers can always do this; ordinary roles can only do it if they are
   both the current owner of the object (or a member of the owning role) and
   a member of the new owning role.
  </para>
________________________________________________________-->
  <para>
   一个对象可以通过该对象类型相应的<command>ALTER</command>命令来重新分配所有者，例如
<programlisting>
ALTER TABLE <replaceable>table_name</replaceable> OWNER TO <replaceable>new_owner</replaceable>;
</programlisting>
   超级用户总是可以做到这点，普通角色只有同时是对象的当前所有者（或者是拥有角色的一个成员）以及新拥有角色的一个成员时才能做同样的事。
  </para>
<!-- pgdoc-cn_end sig_en=920772440417e931a1a6f7ad5722abee -->

<!-- pgdoc-cn_start sig_en=6000449da192abe47ba6033adc8a3cbd sig_cn_org=None source=14.1 
  <para>
   To assign privileges, the <xref linkend="sql-grant"/> command is
   used. For example, if <literal>joe</literal> is an existing role, and
   <literal>accounts</literal> is an existing table, the privilege to
   update the table can be granted with:
<programlisting>
GRANT UPDATE ON accounts TO joe;
</programlisting>
   Writing <literal>ALL</literal> in place of a specific privilege grants all
   privileges that are relevant for the object type.
  </para>
________________________________________________________-->
  <para>
   要分配权限，可以使用<xref linkend="sql-grant"/>命令。例如，如果<literal>joe</literal>是一个已有角色，而<literal>accounts</literal>是一个已有表，更新该表的权限可以按如下方式授权：
<programlisting>
GRANT UPDATE ON accounts TO joe;
</programlisting>
   用<literal>ALL</literal>取代特定权限会把与对象类型相关的所有权限全部授权。
  </para>
<!-- pgdoc-cn_end sig_en=6000449da192abe47ba6033adc8a3cbd -->

<!-- pgdoc-cn_start sig_en=bce0b79d09a24f1e402a962c97ac489d sig_cn_org=None source=14.1 
  <para>
   The special <quote>role</quote> name <literal>PUBLIC</literal> can
   be used to grant a privilege to every role on the system.  Also,
   <quote>group</quote> roles can be set up to help manage privileges when
   there are many users of a database &mdash; for details see
   <xref linkend="user-manag"/>.
  </para>
________________________________________________________-->
  <para>
   一个特殊的名为<literal>PUBLIC</literal>的<quote>角色</quote>可以用来向系统中的每一个角色授予一个权限。同时，在数据库中有很多用户时可以设置<quote>组</quote>角色来帮助管理权限。详见<xref linkend="user-manag"/>。
  </para>
<!-- pgdoc-cn_end sig_en=bce0b79d09a24f1e402a962c97ac489d -->

<!-- pgdoc-cn_start sig_en=1aaade9c7c860bdf251b5e13452454e4 sig_cn_org=None source=14.1 
  <para>
   To revoke a previously-granted privilege, use the fittingly named
   <xref linkend="sql-revoke"/> command:
<programlisting>
REVOKE ALL ON accounts FROM PUBLIC;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   要撤销以前授予的特权，请使用恰当命名的<xref linkend="sql-revoke"/>命令:
<programlisting>
REVOKE ALL ON accounts FROM PUBLIC;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=1aaade9c7c860bdf251b5e13452454e4 -->

<!-- pgdoc-cn_start sig_en=fe6b63429f6dbf98fddb8938b76d6794 sig_cn_org=None source=14.1 
  <para>
   Ordinarily, only the object's owner (or a superuser) can grant or
   revoke privileges on an object.  However, it is possible to grant a
   privilege <quote>with grant option</quote>, which gives the recipient
   the right to grant it in turn to others.  If the grant option is
   subsequently revoked then all who received the privilege from that
   recipient (directly or through a chain of grants) will lose the
   privilege.  For details see the <xref linkend="sql-grant"/> and
   <xref linkend="sql-revoke"/> reference pages.
  </para>
________________________________________________________-->
  <para>
   一般情况下，只有对象拥有者（或者超级用户）可以授予或撤销一个对象上的权限。但是可以在授予权限时使用<quote>with grant option</quote>来允许接收人将权限转授给其他人。如果后来授予选项被撤销，则所有从接收人那里获得的权限（直接或者通过授权链获得）都将被撤销。更多详情请见<xref linkend="sql-grant"/>和<xref linkend="sql-revoke"/>参考页。
  </para>
<!-- pgdoc-cn_end sig_en=fe6b63429f6dbf98fddb8938b76d6794 -->

<!-- pgdoc-cn_start sig_en=e448cba275f958cf787222ed8cb9fdbe sig_cn_org=None source=14.1 
  <para>
   An object's owner can choose to revoke their own ordinary privileges,
   for example to make a table read-only for themselves as well as others.
   But owners are always treated as holding all grant options, so they
   can always re-grant their own privileges.
  </para>
________________________________________________________-->
  <para>
   对象的所有者可以选择撤销自己的普通特权，例如，令表对于自己和其他人只读。
   但是所有者总是被视为拥有所有的授予选项，所以他们总是可以重新授予自己的特权。
  </para>
<!-- pgdoc-cn_end sig_en=e448cba275f958cf787222ed8cb9fdbe -->

<!-- pgdoc-cn_start sig_en=68959b06522cc77437dd306e4385c5c0 sig_cn_org=81630a02233688b81edb35e03d9c93e0 source=15.7 
  <para>
   The available privileges are:

   <variablelist>
    <varlistentry>
________________________________________________________-->
  <para>
   可用的权限包括：

   <variablelist>
    <varlistentry>
<!-- pgdoc-cn_end sig_en=68959b06522cc77437dd306e4385c5c0 -->
     <term><literal>SELECT</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=986751f882c03dab13bbae94d6f38ca1 sig_cn_org=35cb717c3f0ecee9d52ac5e2477ccc99 source=15.7 
      <para>
       Allows <command>SELECT</command> from
       any column, or specific column(s), of a table, view, materialized
       view, or other table-like object.
       Also allows use of <command>COPY TO</command>.
       This privilege is also needed to reference existing column values in
       <command>UPDATE</command>, <command>DELETE</command>,
       or <command>MERGE</command>.
       For sequences, this privilege also allows use of the
       <function>currval</function> function.
       For large objects, this privilege allows the object to be read.
      </para>
________________________________________________________-->
      <para>
       允许从表、视图、物化视图或其他类似表的对象的任何列或特定列进行<command>SELECT</command>。
       还允许使用<command>COPY TO</command>。
       这个权限还需要用于引用<command>UPDATE</command>、<command>DELETE</command>或<command>MERGE</command>中的现有列值。
       对于序列，这个权限还允许使用<function>currval</function>函数。
       对于大对象，这个权限允许读取对象。
      </para>
<!-- pgdoc-cn_end sig_en=986751f882c03dab13bbae94d6f38ca1 -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>INSERT</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=b2c4e38d852fe6a18fca8c2c889e7d63 sig_cn_org=d947a9a265cad8825a5d2a2ff54002f8 source=15.7 
      <para>
       Allows <command>INSERT</command> of a new row into a table, view,
       etc.  Can be granted on specific column(s), in which case
       only those columns may be assigned to in the <command>INSERT</command>
       command (other columns will therefore receive default values).
       Also allows use of <command>COPY FROM</command>.
      </para>
________________________________________________________-->
      <para>
       允许在表、视图等中插入新行，可以授予对特定列的权限，这样只有这些列可以在<command>INSERT</command>命令中赋值（其他列将接收默认值）。
       还允许使用<command>COPY FROM</command>。
      </para>
<!-- pgdoc-cn_end sig_en=b2c4e38d852fe6a18fca8c2c889e7d63 -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>UPDATE</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=3fa46c774cf568de22df8bb723306890 sig_cn_org=a9f245a74d6acddb09c0ffef053e7ad6 source=15.7 
      <para>
       Allows <command>UPDATE</command> of any
       column, or specific column(s), of a table, view, etc.
       (In practice, any nontrivial <command>UPDATE</command> command will
       require <literal>SELECT</literal> privilege as well, since it must
       reference table columns to determine which rows to update, and/or to
       compute new values for columns.)
       <literal>SELECT ... FOR UPDATE</literal>
       and <literal>SELECT ... FOR SHARE</literal>
       also require this privilege on at least one column, in addition to the
       <literal>SELECT</literal> privilege.  For sequences, this
       privilege allows use of the <function>nextval</function> and
       <function>setval</function> functions.
       For large objects, this privilege allows writing or truncating the
       object.
      </para>
________________________________________________________-->
      <para>
       允许对表、视图等的任何列或特定列进行<command>UPDATE</command>操作。
       （实际上，任何非平凡的<command>UPDATE</command>命令都需要<literal>SELECT</literal>权限，
       因为它必须引用表列来确定要更新的行，和/或为列计算新值。）
       <literal>SELECT ... FOR UPDATE</literal>
       和<literal>SELECT ... FOR SHARE</literal>
       还需要在至少一个列上具有此权限，除了<literal>SELECT</literal>权限之外。
       对于序列，此权限允许使用<function>nextval</function>和
       <function>setval</function>函数。
       对于大对象，此权限允许写入或截断该对象。
      </para>
<!-- pgdoc-cn_end sig_en=3fa46c774cf568de22df8bb723306890 -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>DELETE</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=9bbd57033a4ff7424bd80708ec3a0a52 sig_cn_org=454f1df63cfdaa58650e82ea6984fa91 source=15.7 
      <para>
       Allows <command>DELETE</command> of a row from a table, view, etc.
       (In practice, any nontrivial <command>DELETE</command> command will
       require <literal>SELECT</literal> privilege as well, since it must
       reference table columns to determine which rows to delete.)
      </para>
________________________________________________________-->
      <para>
       允许从表、视图等中<command>DELETE</command>一行，（实际上，任何非平凡的<command>DELETE</command>命令都需要<literal>SELECT</literal>权限，
	   因为它必须引用表列来确定要删除的行。）
      </para>
<!-- pgdoc-cn_end sig_en=9bbd57033a4ff7424bd80708ec3a0a52 -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TRUNCATE</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=f4eca232e8d6ae4569732860a59cf911 sig_cn_org=352a4736cf1f4e691f7e35815670a5b5 source=15.7 
      <para>
       Allows <command>TRUNCATE</command> on a table.
      </para>
________________________________________________________-->
      <para>
       允许在表上使用<command>TRUNCATE</command>。
      </para>
<!-- pgdoc-cn_end sig_en=f4eca232e8d6ae4569732860a59cf911 -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>REFERENCES</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=895e182ca459db022ca1a8a46281c0f6 sig_cn_org=85e47a4b3979658d8b963962eb9604ab source=15.7 
      <para>
       Allows creation of a foreign key constraint referencing a
       table, or specific column(s) of a table.
      </para>
________________________________________________________-->
      <para>
       允许创建引用表或表的特定列的外键约束。
      </para>
<!-- pgdoc-cn_end sig_en=895e182ca459db022ca1a8a46281c0f6 -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TRIGGER</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=d7158d8cfb4ac00b25904288d3f590a1 sig_cn_org=e74c018354555928e6c28eb4f51ed01d source=15.7 
      <para>
       Allows creation of a trigger on a table, view, etc.
      </para>
________________________________________________________-->
      <para>
       允许在表、视图等上创建触发器。
      </para>
<!-- pgdoc-cn_end sig_en=d7158d8cfb4ac00b25904288d3f590a1 -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>CREATE</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=c012d7c37a2ecc84423c1b375de78e03 sig_cn_org=ccfe187023bc352de899fd8a61ed6dda source=15.7 
      <para>
       For databases, allows new schemas and publications to be created within
       the database, and allows trusted extensions to be installed within
       the database.
      </para>
________________________________________________________-->
      <para>
       对于数据库，允许在数据库中创建新的模式和发布，并允许在数据库中安装受信任的扩展。
      </para>
<!-- pgdoc-cn_end sig_en=c012d7c37a2ecc84423c1b375de78e03 -->
<!-- pgdoc-cn_start sig_en=d2865c5194e43130981d0070114bc8a0 sig_cn_org=5e39e42654e3d82e6e25a1bdb7b4cb47 source=15.7 
      <para>
       For schemas, allows new objects to be created within the schema.
       To rename an existing object, you must own the
       object <emphasis>and</emphasis> have this privilege for the containing
       schema.
      </para>
________________________________________________________-->
      <para>
       对于模式，允许在该模式内创建新对象。要重命名现有对象，您必须拥有该对象的所有权<emphasis>并且</emphasis>对该包含的模式具有此特权。
      </para>
<!-- pgdoc-cn_end sig_en=d2865c5194e43130981d0070114bc8a0 -->
<!-- pgdoc-cn_start sig_en=53f0c6cda49ca7a8d827c9df15c8b807 sig_cn_org=9e3e03a1a97f6c09a230c802f83fbac3 source=15.7 
      <para>
       For tablespaces, allows tables, indexes, and temporary files to be
       created within the tablespace, and allows databases to be created that
       have the tablespace as their default tablespace.
      </para>
________________________________________________________-->
      <para>
       对于表空间，允许在表空间内创建表、索引和临时文件，并允许创建将该表空间作为默认表空间的数据库。
      </para>
<!-- pgdoc-cn_end sig_en=53f0c6cda49ca7a8d827c9df15c8b807 -->
<!-- pgdoc-cn_start sig_en=06146e78a3cfc8eb552ea3e9539c7a54 sig_cn_org=2248d3b3fbbc6b2a868ad5f6f3905496 source=15.7 
      <para>
       Note that revoking this privilege will not alter the existence or
       location of existing objects.
      </para>
________________________________________________________-->
      <para>
       请注意，撤销此权限不会改变现有对象的存在或位置。
      </para>
<!-- pgdoc-cn_end sig_en=06146e78a3cfc8eb552ea3e9539c7a54 -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>CONNECT</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=db6fc0a0ba628983198b4bd789ab062d sig_cn_org=13c642bc69faf27c2b2d2a6396ef500a source=15.7 
      <para>
       Allows the grantee to connect to the database.  This
       privilege is checked at connection startup (in addition to checking
       any restrictions imposed by <filename>pg_hba.conf</filename>).
      </para>
________________________________________________________-->
      <para>
       允许受让人连接到数据库。此权限在连接启动时进行检查（除了检查<filename>pg_hba.conf</filename>强加的任何限制）。
      </para>
<!-- pgdoc-cn_end sig_en=db6fc0a0ba628983198b4bd789ab062d -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>TEMPORARY</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=d4e801ee98d024c34d93ac66b6b573d4 sig_cn_org=b5b2a9523e555cef20da226ad8dbbb34 source=15.7 
      <para>
       Allows temporary tables to be created while using the database.
      </para>
________________________________________________________-->
      <para>
       允许在使用数据库时创建临时表。
      </para>
<!-- pgdoc-cn_end sig_en=d4e801ee98d024c34d93ac66b6b573d4 -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXECUTE</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=f844df0b856925bcf62552ae8b68b4b0 sig_cn_org=6846fac4fbc775f936d83646beed1037 source=15.7 
      <para>
       Allows calling a function or procedure, including use of
       any operators that are implemented on top of the function.  This is the
       only type of privilege that is applicable to functions and procedures.
      </para>
________________________________________________________-->
      <para>
       允许调用函数或过程，包括使用在函数之上实现的任何运算符。这是唯一适用于函数和过程的特权类型。
      </para>
<!-- pgdoc-cn_end sig_en=f844df0b856925bcf62552ae8b68b4b0 -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>USAGE</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=a0ab6b1c182b2fc250fed6ded08934df sig_cn_org=5050047b55bf34d8debc56569fcf14c7 source=15.7 
      <para>
       For procedural languages, allows use of the language for
       the creation of functions in that language.  This is the only type
       of privilege that is applicable to procedural languages.
      </para>
________________________________________________________-->
      <para>
       对于过程性语言，允许在该语言中创建函数。这是唯一适用于过程性语言的特权类型。
      </para>
<!-- pgdoc-cn_end sig_en=a0ab6b1c182b2fc250fed6ded08934df -->
<!-- pgdoc-cn_start sig_en=73a1e0224e88e28e0d865da08b8b8e0e sig_cn_org=a6c8bb5b0820fca4594410b578afabbd source=15.7 
      <para>
       For schemas, allows access to objects contained in the
       schema (assuming that the objects' own privilege requirements are
       also met).  Essentially this allows the grantee to <quote>look up</quote>
       objects within the schema.  Without this permission, it is still
       possible to see the object names, e.g., by querying system catalogs.
       Also, after revoking this permission, existing sessions might have
       statements that have previously performed this lookup, so this is not
       a completely secure way to prevent object access.
      </para>
________________________________________________________-->
      <para>
       对于模式，允许访问包含在模式中的对象（假设对象自身的特权要求也得到满足）。
       本质上，这允许受让人<quote>查找</quote>模式中的对象。
       没有这个权限，仍然可以看到对象名称，例如，通过查询系统目录。
       此外，在撤销此权限后，现有会话可能有先前执行此查找的语句，因此这不是
       完全安全的防止对象访问的方式。
      </para>
<!-- pgdoc-cn_end sig_en=73a1e0224e88e28e0d865da08b8b8e0e -->
<!-- pgdoc-cn_start sig_en=862dbeb718f942a69ce499cc62d4c764 sig_cn_org=9e34085fd6e74adb345cb11c1c69f875 source=15.7 
      <para>
       For sequences, allows use of the
       <function>currval</function> and <function>nextval</function> functions.
      </para>
________________________________________________________-->
      <para>
       对于序列，允许使用<function>currval</function>和<function>nextval</function>函数。
      </para>
<!-- pgdoc-cn_end sig_en=862dbeb718f942a69ce499cc62d4c764 -->
<!-- pgdoc-cn_start sig_en=694c712ea78aa9b4c58499c8a1975e54 sig_cn_org=9e6e8c5d293eb7cd9ce7a1ed21272a5c source=15.7 
      <para>
       For types and domains, allows use of the type or domain in the
       creation of tables, functions, and other schema objects.  (Note that
       this privilege does not control all <quote>usage</quote> of the
       type, such as values of the type appearing in queries.  It only
       prevents objects from being created that depend on the type.  The
       main purpose of this privilege is controlling which users can create
       dependencies on a type, which could prevent the owner from changing
       the type later.)
      </para>
________________________________________________________-->
      <para>
       对于类型和域，允许在表格、函数和其他模式对象的创建中使用该类型或域。
       （请注意，此权限并不控制类型的所有<quote>使用</quote>，比如类型值出现在查询中。
       它只是防止依赖于该类型的对象被创建。此权限的主要目的是控制哪些用户可以创建
       对类型的依赖，这可以防止所有者以后更改类型。）
      </para>
<!-- pgdoc-cn_end sig_en=694c712ea78aa9b4c58499c8a1975e54 -->
<!-- pgdoc-cn_start sig_en=4b45d3aa7dd621e39ca5d300a8d7aa6b sig_cn_org=247a7ede7d163c861cb1deedf07f840c source=15.7 
      <para>
       For foreign-data wrappers, allows creation of new servers using the
       foreign-data wrapper.
      </para>
________________________________________________________-->
      <para>
       对于外部数据包装器，允许使用外部数据包装器创建新的服务器。
      </para>
<!-- pgdoc-cn_end sig_en=4b45d3aa7dd621e39ca5d300a8d7aa6b -->
<!-- pgdoc-cn_start sig_en=c3baa22cf9d4bddf1f9a3d083cd3fdc1 sig_cn_org=a91851091dd038cad43bab83460eba1c source=15.7 
      <para>
       For foreign servers, allows creation of foreign tables using the
       server.  Grantees may also create, alter, or drop their own user
       mappings associated with that server.
      </para>
________________________________________________________-->
      <para>
       对于外部服务器，允许使用该服务器创建外部表。受让人还可以创建、修改或删除与该服务器关联的自己的用户映射。
      </para>
<!-- pgdoc-cn_end sig_en=c3baa22cf9d4bddf1f9a3d083cd3fdc1 -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>SET</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=ab00552e27aea54bc4ead9ec9e870652 sig_cn_org=2d64cee132ebf4ab06723547ccf735da source=15.7 
      <para>
       Allows a server configuration parameter to be set to a new value
       within the current session.  (While this privilege can be granted
       on any parameter, it is meaningless except for parameters that would
       normally require superuser privilege to set.)
      </para>
________________________________________________________-->
      <para>
       允许在当前会话中将服务器配置参数设置为新值。
       （虽然可以授予此权限在任何参数上，但除了通常需要超级用户权限设置的参数外，这是没有意义的。）
      </para>
<!-- pgdoc-cn_end sig_en=ab00552e27aea54bc4ead9ec9e870652 -->
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>ALTER SYSTEM</literal></term>
     <listitem>
<!-- pgdoc-cn_start sig_en=2f31cebb76d4aa4338b54dca873dc059 sig_cn_org=0db9f9f59357815c9762e2f9dca13e56 source=15.7 
      <para>
       Allows a server configuration parameter to be configured to a new
       value using the <xref linkend="sql-altersystem"/> command.
      </para>
________________________________________________________-->
      <para>
       允许使用<xref linkend="sql-altersystem"/>命令将服务器配置参数配置为新值。
      </para>
<!-- pgdoc-cn_end sig_en=2f31cebb76d4aa4338b54dca873dc059 -->
<!-- pgdoc-cn_start sig_en=fd834e693470b757f8c8bfe66f8843ee sig_cn_org=9482718bbf0d9295c923da3f2ee6bfe8 source=15.7 
     </listitem>
    </varlistentry>
   </variablelist>

   The privileges required by other commands are listed on the
   reference page of the respective command.
  </para>
________________________________________________________-->
     </listitem>
    </varlistentry>
   </variablelist>

   其他命令所需的权限列在各自命令的参考页面上。
  </para>
<!-- pgdoc-cn_end sig_en=fd834e693470b757f8c8bfe66f8843ee -->

<!-- pgdoc-cn_start sig_en=93ed1726ab4560c3ed7bf8b0ca78fc5f sig_cn_org=65e555c9138338831cd5210a9a4eff19 source=15.7 
  <para>
   PostgreSQL grants privileges on some types of objects to
   <literal>PUBLIC</literal> by default when the objects are created.
   No privileges are granted to <literal>PUBLIC</literal> by default on
   tables,
   table columns,
   sequences,
   foreign data wrappers,
   foreign servers,
   large objects,
   schemas,
   tablespaces,
   or configuration parameters.
   For other types of objects, the default privileges
   granted to <literal>PUBLIC</literal> are as follows:
   <literal>CONNECT</literal> and <literal>TEMPORARY</literal> (create
   temporary tables) privileges for databases;
   <literal>EXECUTE</literal> privilege for functions and procedures; and
   <literal>USAGE</literal> privilege for languages and data types
   (including domains).
   The object owner can, of course, <command>REVOKE</command>
   both default and expressly granted privileges. (For maximum
   security, issue the <command>REVOKE</command> in the same transaction that
   creates the object; then there is no window in which another user
   can use the object.)
   Also, these default privilege settings can be overridden using the
   <xref linkend="sql-alterdefaultprivileges"/> command.
  </para>
________________________________________________________-->
  <para>
   PostgreSQL在创建对象时，默认情况下将某些类型的对象的权限授予<literal>PUBLIC</literal>。
   默认情况下，表、表列、序列、外部数据包装器、外部服务器、大对象、模式、表空间或配置参数不授予<literal>PUBLIC</literal>任何权限。
   对于其他类型的对象，默认授予<literal>PUBLIC</literal>的权限如下：
   数据库的<literal>CONNECT</literal>和<literal>TEMPORARY</literal>（创建临时表）权限；
   函数和存储过程的<literal>EXECUTE</literal>权限；以及
   语言和数据类型（包括域）的<literal>USAGE</literal>权限。
   对象所有者当然可以<command>REVOKE</command>默认和明确授予的权限。（为了最大安全性，在创建对象的同时发出<command>REVOKE</command>；
   这样就没有其他用户可以在其中使用对象的窗口。）
   此外，可以使用<xref linkend="sql-alterdefaultprivileges"/>命令覆盖这些默认权限设置。
</para>
<!-- pgdoc-cn_end sig_en=93ed1726ab4560c3ed7bf8b0ca78fc5f -->

<!-- pgdoc-cn_start sig_en=c4898d520a2c2eda17f35db86e1f0d57 sig_cn_org=None source=14.1 
  <para>
   <xref linkend="privilege-abbrevs-table"/> shows the one-letter
   abbreviations that are used for these privilege types in
   <firstterm>ACL</firstterm> (Access Control List) values.
   You will see these letters in the output of the <xref linkend="app-psql"/>
   commands listed below, or when looking at ACL columns of system catalogs.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="privilege-abbrevs-table"/>显示了<firstterm>ACL</firstterm>（访问控制列表）值中用于这些权限类型的单字母缩写。
   你将在下面列出的 <xref linkend="app-psql"/> 命令的输出中，或者在查看系统目录的 ACL 列时看到这些字母。
  </para>
<!-- pgdoc-cn_end sig_en=c4898d520a2c2eda17f35db86e1f0d57 -->

  <table id="privilege-abbrevs-table">
<!-- pgdoc-cn_start sig_en=65c57a5c580a302226cc2dc868482b71 sig_cn_org=None source=14.1 
   <title>ACL Privilege Abbreviations</title>
________________________________________________________-->
   <title>ACL 权限缩写</title>
<!-- pgdoc-cn_end sig_en=65c57a5c580a302226cc2dc868482b71 -->
   <tgroup cols="3">
    <colspec colname="col1" colwidth="1*"/>
    <colspec colname="col2" colwidth="1*"/>
    <colspec colname="col3" colwidth="2*"/>
    <thead>
<!-- pgdoc-cn_start sig_en=2d31848a5f8e3d7ed6ecb8d33f594d24 sig_cn_org=None source=14.1 
     <row>
      <entry>Privilege</entry>
      <entry>Abbreviation</entry>
      <entry>Applicable Object Types</entry>
     </row>
________________________________________________________-->
     <row>
      <entry>权限</entry>
      <entry>缩写</entry>
      <entry>适用对象类型</entry>
     </row>
<!-- pgdoc-cn_end sig_en=2d31848a5f8e3d7ed6ecb8d33f594d24 -->
    </thead>
    <tbody>
<!-- pgdoc-cn_start sig_en=e830dac6654daedbd052a559570bdff5 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SELECT</literal></entry>
      <entry><literal>r</literal> (<quote>read</quote>)</entry>
      <entry>
       <literal>LARGE OBJECT</literal>,
       <literal>SEQUENCE</literal>,
       <literal>TABLE</literal> (and table-like objects),
       table column
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SELECT</literal></entry>
      <entry><literal>r</literal> (<quote>读</quote>)</entry>
      <entry>
       <literal>LARGE OBJECT</literal>,
       <literal>SEQUENCE</literal>,
       <literal>TABLE</literal> (and table-like objects),
       table column
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=e830dac6654daedbd052a559570bdff5 -->
<!-- pgdoc-cn_start sig_en=182320bb1ba9f1409e9f4633efc00af1 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>INSERT</literal></entry>
      <entry><literal>a</literal> (<quote>append</quote>)</entry>
      <entry><literal>TABLE</literal>, table column</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>INSERT</literal></entry>
      <entry><literal>a</literal> (<quote>增补</quote>)</entry>
      <entry><literal>TABLE</literal>, table column</entry>
     </row>
<!-- pgdoc-cn_end sig_en=182320bb1ba9f1409e9f4633efc00af1 -->
<!-- pgdoc-cn_start sig_en=6a176519b11971ece252931386a9d010 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>UPDATE</literal></entry>
      <entry><literal>w</literal> (<quote>write</quote>)</entry>
      <entry>
       <literal>LARGE OBJECT</literal>,
       <literal>SEQUENCE</literal>,
       <literal>TABLE</literal>,
       table column
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>UPDATE</literal></entry>
      <entry><literal>w</literal> (<quote>写</quote>)</entry>
      <entry>
       <literal>LARGE OBJECT</literal>,
       <literal>SEQUENCE</literal>,
       <literal>TABLE</literal>,
       table column
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=6a176519b11971ece252931386a9d010 -->
     <row>
      <entry><literal>DELETE</literal></entry>
      <entry><literal>d</literal></entry>
      <entry><literal>TABLE</literal></entry>
     </row>
     <row>
      <entry><literal>TRUNCATE</literal></entry>
      <entry><literal>D</literal></entry>
      <entry><literal>TABLE</literal></entry>
     </row>
<!-- pgdoc-cn_start sig_en=f88aea22ffc925dd407af4be5703befe sig_cn_org=None source=14.1 
     <row>
      <entry><literal>REFERENCES</literal></entry>
      <entry><literal>x</literal></entry>
      <entry><literal>TABLE</literal>, table column</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>REFERENCES</literal></entry>
      <entry><literal>x</literal></entry>
      <entry><literal>TABLE</literal>, table column</entry>
     </row>
<!-- pgdoc-cn_end sig_en=f88aea22ffc925dd407af4be5703befe -->
     <row>
      <entry><literal>TRIGGER</literal></entry>
      <entry><literal>t</literal></entry>
      <entry><literal>TABLE</literal></entry>
     </row>
<!-- pgdoc-cn_start sig_en=75a801230de1b75542a162fc836d47fc sig_cn_org=None source=14.1 
     <row>
      <entry><literal>CREATE</literal></entry>
      <entry><literal>C</literal></entry>
      <entry>
       <literal>DATABASE</literal>,
       <literal>SCHEMA</literal>,
       <literal>TABLESPACE</literal>
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>CREATE</literal></entry>
      <entry><literal>C</literal></entry>
      <entry>
       <literal>DATABASE</literal>,
       <literal>SCHEMA</literal>,
       <literal>TABLESPACE</literal>
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=75a801230de1b75542a162fc836d47fc -->
     <row>
      <entry><literal>CONNECT</literal></entry>
      <entry><literal>c</literal></entry>
      <entry><literal>DATABASE</literal></entry>
     </row>
     <row>
      <entry><literal>TEMPORARY</literal></entry>
      <entry><literal>T</literal></entry>
      <entry><literal>DATABASE</literal></entry>
     </row>
<!-- pgdoc-cn_start sig_en=4d7da7db62976e09e396ddb71014bb8d sig_cn_org=None source=14.1 
     <row>
      <entry><literal>EXECUTE</literal></entry>
      <entry><literal>X</literal></entry>
      <entry><literal>FUNCTION</literal>, <literal>PROCEDURE</literal></entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>EXECUTE</literal></entry>
      <entry><literal>X</literal></entry>
      <entry><literal>FUNCTION</literal>, <literal>PROCEDURE</literal></entry>
     </row>
<!-- pgdoc-cn_end sig_en=4d7da7db62976e09e396ddb71014bb8d -->
<!-- pgdoc-cn_start sig_en=a83f4253d1507735fcd566d9e0a1b31c sig_cn_org=None source=14.1 
     <row>
      <entry><literal>USAGE</literal></entry>
      <entry><literal>U</literal></entry>
      <entry>
       <literal>DOMAIN</literal>,
       <literal>FOREIGN DATA WRAPPER</literal>,
       <literal>FOREIGN SERVER</literal>,
       <literal>LANGUAGE</literal>,
       <literal>SCHEMA</literal>,
       <literal>SEQUENCE</literal>,
       <literal>TYPE</literal>
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>USAGE</literal></entry>
      <entry><literal>U</literal></entry>
      <entry>
       <literal>DOMAIN</literal>,
       <literal>FOREIGN DATA WRAPPER</literal>,
       <literal>FOREIGN SERVER</literal>,
       <literal>LANGUAGE</literal>,
       <literal>SCHEMA</literal>,
       <literal>SEQUENCE</literal>,
       <literal>TYPE</literal>
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=a83f4253d1507735fcd566d9e0a1b31c -->
     <row>
      <entry><literal>SET</literal></entry>
      <entry><literal>s</literal></entry>
      <entry><literal>PARAMETER</literal></entry>
     </row>
     <row>
      <entry><literal>ALTER SYSTEM</literal></entry>
      <entry><literal>A</literal></entry>
      <entry><literal>PARAMETER</literal></entry>
     </row>
     </tbody>
   </tgroup>
  </table>

<!-- pgdoc-cn_start sig_en=d2148ebbbfa8c11074f2b9ea8c786c94 sig_cn_org=None source=14.1 
  <para>
   <xref linkend="privileges-summary-table"/> summarizes the privileges
   available for each type of SQL object, using the abbreviations shown
   above.
   It also shows the <application>psql</application> command
   that can be used to examine privilege settings for each object type.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="privileges-summary-table"/> 使用上面所示的缩写总结了每种类型 SQL 对象可用的权限.
   它还显示可用于检查每种对象类型的特权设置的 <application>psql</application> 命令。
  </para>
<!-- pgdoc-cn_end sig_en=d2148ebbbfa8c11074f2b9ea8c786c94 -->

  <table id="privileges-summary-table">
<!-- pgdoc-cn_start sig_en=b78d3cf93479212cf0369d381519bd45 sig_cn_org=None source=14.1 
   <title>Summary of Access Privileges</title>
________________________________________________________-->
   <title>访问权限摘要</title>
<!-- pgdoc-cn_end sig_en=b78d3cf93479212cf0369d381519bd45 -->
   <tgroup cols="4">
    <colspec colname="col1" colwidth="2*"/>
    <colspec colname="col2" colwidth="1*"/>
    <colspec colname="col3" colwidth="1*"/>
    <colspec colname="col4" colwidth="1*"/>
    <thead>
<!-- pgdoc-cn_start sig_en=5340563cb87b23217f0424db5c7a0d6b sig_cn_org=None source=14.1 
     <row>
      <entry>Object Type</entry>
      <entry>All Privileges</entry>
      <entry>Default <literal>PUBLIC</literal> Privileges</entry>
      <entry><application>psql</application> Command</entry>
     </row>
________________________________________________________-->
     <row>
      <entry>对象类型</entry>
      <entry>所有权限</entry>
      <entry>默认 <literal>PUBLIC</literal> 权限</entry>
      <entry><application>psql</application> 命令</entry>
     </row>
<!-- pgdoc-cn_end sig_en=5340563cb87b23217f0424db5c7a0d6b -->
    </thead>
    <tbody>
     <row>
      <entry><literal>DATABASE</literal></entry>
      <entry><literal>CTc</literal></entry>
      <entry><literal>Tc</literal></entry>
      <entry><literal>\l</literal></entry>
     </row>
     <row>
      <entry><literal>DOMAIN</literal></entry>
      <entry><literal>U</literal></entry>
      <entry><literal>U</literal></entry>
      <entry><literal>\dD+</literal></entry>
     </row>
<!-- pgdoc-cn_start sig_en=a8135e6bb6af8d972fd7cfb92ffa21a7 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>FUNCTION</literal> or <literal>PROCEDURE</literal></entry>
      <entry><literal>X</literal></entry>
      <entry><literal>X</literal></entry>
      <entry><literal>\df+</literal></entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>FUNCTION</literal> or <literal>PROCEDURE</literal></entry>
      <entry><literal>X</literal></entry>
      <entry><literal>X</literal></entry>
      <entry><literal>\df+</literal></entry>
     </row>
<!-- pgdoc-cn_end sig_en=a8135e6bb6af8d972fd7cfb92ffa21a7 -->
<!-- pgdoc-cn_start sig_en=6683624c882d27624c5253c9679b958e sig_cn_org=None source=14.1 
     <row>
      <entry><literal>FOREIGN DATA WRAPPER</literal></entry>
      <entry><literal>U</literal></entry>
      <entry>none</entry>
      <entry><literal>\dew+</literal></entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>FOREIGN DATA WRAPPER</literal></entry>
      <entry><literal>U</literal></entry>
      <entry>none</entry>
      <entry><literal>\dew+</literal></entry>
     </row>
<!-- pgdoc-cn_end sig_en=6683624c882d27624c5253c9679b958e -->
<!-- pgdoc-cn_start sig_en=903f87f49b1af0ef7c65aaed7823cdc5 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>FOREIGN SERVER</literal></entry>
      <entry><literal>U</literal></entry>
      <entry>none</entry>
      <entry><literal>\des+</literal></entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>FOREIGN SERVER</literal></entry>
      <entry><literal>U</literal></entry>
      <entry>none</entry>
      <entry><literal>\des+</literal></entry>
     </row>
<!-- pgdoc-cn_end sig_en=903f87f49b1af0ef7c65aaed7823cdc5 -->
     <row>
      <entry><literal>LANGUAGE</literal></entry>
      <entry><literal>U</literal></entry>
      <entry><literal>U</literal></entry>
      <entry><literal>\dL+</literal></entry>
     </row>
<!-- pgdoc-cn_start sig_en=3adbcb05e6cdd326eef06daa2d19b5b7 sig_cn_org=a65323997ce4e9bbebde3bfe06948060 source=15.7 
     <row>
      <entry><literal>LARGE OBJECT</literal></entry>
      <entry><literal>rw</literal></entry>
      <entry>none</entry>
      <entry><literal>\dl+</literal></entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>大对象</literal></entry>
      <entry><literal>rw</literal></entry>
      <entry>none</entry>
      <entry><literal>\dl+</literal></entry>
     </row>
<!-- pgdoc-cn_end sig_en=3adbcb05e6cdd326eef06daa2d19b5b7 -->
<!-- pgdoc-cn_start sig_en=885fc866eb7d5248d7c21a458dda9b30 sig_cn_org=3c584db8ef5e93e4ea34e3fdd8ab7d1b source=15.7 
     <row>
      <entry><literal>PARAMETER</literal></entry>
      <entry><literal>sA</literal></entry>
      <entry>none</entry>
      <entry><literal>\dconfig+</literal></entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>PARAMETER</literal></entry>
      <entry><literal>sA</literal></entry>
      <entry>none</entry>
      <entry><literal>\dconfig+</literal></entry>
</row>
<!-- pgdoc-cn_end sig_en=885fc866eb7d5248d7c21a458dda9b30 -->
<!-- pgdoc-cn_start sig_en=59c6a121655338e5c5c9f5604a2b341d sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SCHEMA</literal></entry>
      <entry><literal>UC</literal></entry>
      <entry>none</entry>
      <entry><literal>\dn+</literal></entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SCHEMA</literal></entry>
      <entry><literal>UC</literal></entry>
      <entry>none</entry>
      <entry><literal>\dn+</literal></entry>
     </row>
<!-- pgdoc-cn_end sig_en=59c6a121655338e5c5c9f5604a2b341d -->
<!-- pgdoc-cn_start sig_en=c4e1a33e1e06d75768bdb66f182885d0 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>SEQUENCE</literal></entry>
      <entry><literal>rwU</literal></entry>
      <entry>none</entry>
      <entry><literal>\dp</literal></entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>SEQUENCE</literal></entry>
      <entry><literal>rwU</literal></entry>
      <entry>none</entry>
      <entry><literal>\dp</literal></entry>
     </row>
<!-- pgdoc-cn_end sig_en=c4e1a33e1e06d75768bdb66f182885d0 -->
<!-- pgdoc-cn_start sig_en=d2f226c063fe0741410aea07f74da4f3 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>TABLE</literal> (and table-like objects)</entry>
      <entry><literal>arwdDxt</literal></entry>
      <entry>none</entry>
      <entry><literal>\dp</literal></entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>TABLE</literal> (and table-like objects)</entry>
      <entry><literal>arwdDxt</literal></entry>
      <entry>none</entry>
      <entry><literal>\dp</literal></entry>
     </row>
<!-- pgdoc-cn_end sig_en=d2f226c063fe0741410aea07f74da4f3 -->
<!-- pgdoc-cn_start sig_en=2cebab693e4f4d36bd56a3eb84dd71c4 sig_cn_org=None source=14.1 
     <row>
      <entry>Table column</entry>
      <entry><literal>arwx</literal></entry>
      <entry>none</entry>
      <entry><literal>\dp</literal></entry>
     </row>
________________________________________________________-->
     <row>
      <entry>Table column</entry>
      <entry><literal>arwx</literal></entry>
      <entry>none</entry>
      <entry><literal>\dp</literal></entry>
     </row>
<!-- pgdoc-cn_end sig_en=2cebab693e4f4d36bd56a3eb84dd71c4 -->
<!-- pgdoc-cn_start sig_en=b0ec884fd665eb197424b0aef8bec4da sig_cn_org=None source=14.1 
     <row>
      <entry><literal>TABLESPACE</literal></entry>
      <entry><literal>C</literal></entry>
      <entry>none</entry>
      <entry><literal>\db+</literal></entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>TABLESPACE</literal></entry>
      <entry><literal>C</literal></entry>
      <entry>none</entry>
      <entry><literal>\db+</literal></entry>
     </row>
<!-- pgdoc-cn_end sig_en=b0ec884fd665eb197424b0aef8bec4da -->
     <row>
      <entry><literal>TYPE</literal></entry>
      <entry><literal>U</literal></entry>
      <entry><literal>U</literal></entry>
      <entry><literal>\dT+</literal></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!-- pgdoc-cn_start sig_en=bd221c3d090f189e67a9498152652f75 sig_cn_org=55c9744f2356f333377aec633d482d87 source=15.7 
  <para>
   <indexterm>
    <primary><type>aclitem</type></primary>
   </indexterm>
   The privileges that have been granted for a particular object are
   displayed as a list of <type>aclitem</type> entries, each having the
   format:
<synopsis>
<replaceable>grantee</replaceable><literal>=</literal><replaceable>privilege-abbreviation</replaceable><optional><literal>*</literal></optional>...<literal>/</literal><replaceable>grantor</replaceable>
</synopsis>
   Each <type>aclitem</type> lists all the permissions of one grantee that
   have been granted by a particular grantor.  Specific privileges are
   represented by one-letter abbreviations from
   <xref linkend="privilege-abbrevs-table"/>, with <literal>*</literal>
   appended if the privilege was granted with grant option.  For example,
   <literal>calvin=r*w/hobbes</literal> specifies that the role
   <literal>calvin</literal> has the privilege
   <literal>SELECT</literal> (<literal>r</literal>) with grant option
   (<literal>*</literal>) as well as the non-grantable
   privilege <literal>UPDATE</literal> (<literal>w</literal>), both granted
   by the role <literal>hobbes</literal>.  If <literal>calvin</literal>
   also has some privileges on the same object granted by a different
   grantor, those would appear as a separate <type>aclitem</type> entry.
   An empty grantee field in an <type>aclitem</type> stands
   for <literal>PUBLIC</literal>.
  </para>
________________________________________________________-->
  <para>
   <indexterm>
    <primary><type>aclitem</type></primary>
   </indexterm>
   已授予特定对象的权限显示为<type>aclitem</type>条目列表，每个条目的格式如下：
<synopsis>
<replaceable>grantee</replaceable><literal>=</literal><replaceable>privilege-abbreviation</replaceable><optional><literal>*</literal></optional>...<literal>/</literal><replaceable>grantor</replaceable>
</synopsis>
   每个<type>aclitem</type>列出了由特定授权者授予的一个受让人的所有权限。具体权限由<xref linkend="privilege-abbrevs-table"/>中的单字母缩写表示，如果权限是通过授予权限选项授予的，则附加<literal>*</literal>。例如，<literal>calvin=r*w/hobbes</literal>指定角色<literal>calvin</literal>具有权限<literal>SELECT</literal>（<literal>r</literal>）以及不可授予权限<literal>UPDATE</literal>（<literal>w</literal>），两者均由角色<literal>hobbes</literal>授予。如果<literal>calvin</literal>还具有由不同授权者授予的同一对象的某些权限，则这些权限将显示为单独的<type>aclitem</type>条目。在<type>aclitem</type>中的空受让人字段代表<literal>PUBLIC</literal>。
  </para>
<!-- pgdoc-cn_end sig_en=bd221c3d090f189e67a9498152652f75 -->

<!-- pgdoc-cn_start sig_en=23ef01b8fe1c1ac491e0a7167cb1d10f sig_cn_org=None source=14.1 
  <para>
   As an example, suppose that user <literal>miriam</literal> creates
   table <literal>mytable</literal> and does:
<programlisting>
GRANT SELECT ON mytable TO PUBLIC;
GRANT SELECT, UPDATE, INSERT ON mytable TO admin;
GRANT SELECT (col1), UPDATE (col1) ON mytable TO miriam_rw;
</programlisting>
   Then <application>psql</application>'s <literal>\dp</literal> command
   would show:
<programlisting>
=&gt; \dp mytable
                                  Access privileges
 Schema |  Name   | Type  |   Access privileges   |   Column privileges   | Policies
-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;
 public | mytable | table | miriam=arwdDxt/miriam+| col1:                +|
        |         |       | =r/miriam            +|   miriam_rw=rw/miriam |
        |         |       | admin=arw/miriam      |                       |
(1 row)
</programlisting>
  </para>
________________________________________________________-->
  <para>
   例如，假设用户<literal>miriam</literal>创建了表<literal>mytable</literal>并且:
<programlisting>
GRANT SELECT ON mytable TO PUBLIC;
GRANT SELECT, UPDATE, INSERT ON mytable TO admin;
GRANT SELECT (col1), UPDATE (col1) ON mytable TO miriam_rw;
</programlisting>
   则 <application>psql</application>的 <literal>\dp</literal> 命令将显示:
<programlisting>
=&gt; \dp mytable
                                  Access privileges
 Schema |  Name   | Type  |   Access privileges   |   Column privileges   | Policies
--------+---------+-------+-----------------------+-----------------------+----------
 public | mytable | table | miriam=arwdDxt/miriam+| col1:                +|
        |         |       | =r/miriam            +|   miriam_rw=rw/miriam |
        |         |       | admin=arw/miriam      |                       |
(1 row)
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=23ef01b8fe1c1ac491e0a7167cb1d10f -->

<!-- pgdoc-cn_start sig_en=27e87511287587e7223fcfbab2c269b3 sig_cn_org=None source=14.1 
  <para>
   If the <quote>Access privileges</quote> column is empty for a given
   object, it means the object has default privileges (that is, its
   privileges entry in the relevant system catalog is null).  Default
   privileges always include all privileges for the owner, and can include
   some privileges for <literal>PUBLIC</literal> depending on the object
   type, as explained above.  The first <command>GRANT</command>
   or <command>REVOKE</command> on an object will instantiate the default
   privileges (producing, for
   example, <literal>miriam=arwdDxt/miriam</literal>) and then modify them
   per the specified request.  Similarly, entries are shown in <quote>Column
   privileges</quote> only for columns with nondefault privileges.
   (Note: for this purpose, <quote>default privileges</quote> always means
   the built-in default privileges for the object's type.  An object whose
   privileges have been affected by an <command>ALTER DEFAULT
   PRIVILEGES</command> command will always be shown with an explicit
   privilege entry that includes the effects of
   the <command>ALTER</command>.)
  </para>
________________________________________________________-->
  <para>
   如果<quote>Access privileges</quote>列对于给定对象为空，则表示该对象具有默认权限（也就是说，它在相关系统目录中的权限条目为空）。 
   默认权限始终包含所有者的所有权限，并且可以包括 <literal>PUBLIC</literal> 的一些权限，具体取决于对象类型，如上所述。 
   对象上的第一个<command>GRANT</command>或<command>REVOKE</command>将实例化默认权限（例如，生成<literal>miriam_arwdDxt/miriam</literal>），然后根据指定的请求修改它们。 
   类似的，只有具有非默认特权的列的条目才显示在<quote>Column privileges</quote>中。（注意：为此目的，<quote>default privileges</quote>始终表示对象类型的内置缺省权限。其权限受<command>ALTER DEFAULT PRIVILEGES</command> 命令影响的对象将始终显示一个显式权限条目，其中包含 <command>ALTER</command>。）
  </para>
<!-- pgdoc-cn_end sig_en=27e87511287587e7223fcfbab2c269b3 -->

<!-- pgdoc-cn_start sig_en=2e344a75dd531eb15a2e534533fbc709 sig_cn_org=None source=14.1 
  <para>
   Notice that the owner's implicit grant options are not marked in the
   access privileges display.  A <literal>*</literal> will appear only when
   grant options have been explicitly granted to someone.
  </para>
________________________________________________________-->
  <para>
   注意所有者的隐式授予选项没有在访问权限显示中标记。仅当授予选项被显式授予给某人时才会出现<literal>*</literal>。
  </para>
<!-- pgdoc-cn_end sig_en=2e344a75dd531eb15a2e534533fbc709 -->
 </sect1>

 <sect1 id="ddl-rowsecurity">
<!-- pgdoc-cn_start sig_en=a6ef209dfad705f6e652123abb462d30 sig_cn_org=None source=14.1 
  <title>Row Security Policies</title>
________________________________________________________-->
  <title>行安全性策略</title>
<!-- pgdoc-cn_end sig_en=a6ef209dfad705f6e652123abb462d30 -->

<!-- pgdoc-cn_start sig_en=fc2717018b81a08944319ee247f4faff sig_cn_org=None source=14.1 
  <indexterm zone="ddl-rowsecurity">
   <primary>row-level security</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="ddl-rowsecurity">
   <primary>row-level security</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=fc2717018b81a08944319ee247f4faff -->

<!-- pgdoc-cn_start sig_en=35882c6fb8516dc3f6fbddfed323407b sig_cn_org=None source=14.1 
  <indexterm zone="ddl-rowsecurity">
   <primary>policy</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="ddl-rowsecurity">
   <primary>policy</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=35882c6fb8516dc3f6fbddfed323407b -->

<!-- pgdoc-cn_start sig_en=8193ce51c9429ad8159db3779b7357e7 sig_cn_org=None source=14.1 
  <para>
   In addition to the SQL-standard <link linkend="ddl-priv">privilege
   system</link> available through <xref linkend="sql-grant"/>,
   tables can have <firstterm>row security policies</firstterm> that restrict,
   on a per-user basis, which rows can be returned by normal queries
   or inserted, updated, or deleted by data modification commands.
   This feature is also known as <firstterm>Row-Level Security</firstterm>.
   By default, tables do not have any policies, so that if a user has
   access privileges to a table according to the SQL privilege system,
   all rows within it are equally available for querying or updating.
  </para>
________________________________________________________-->
  <para>
   除可以通过<xref linkend="sql-grant"/>使用 SQL 标准的
   <link linkend="ddl-priv">特权系统</link>之外，表还可以具有
   <firstterm>行安全性策略</firstterm>，它针对每一个用户限制哪些行可以
   被普通的查询返回或者可以被数据修改命令插入、更新或删除。这种
   特性也被称为<firstterm>行级安全性</firstterm>。默认情况下，表不具有
   任何策略，这样用户根据 SQL 特权系统具有对表的访问特权，对于
   查询或更新来说其中所有的行都是平等的。
  </para>
<!-- pgdoc-cn_end sig_en=8193ce51c9429ad8159db3779b7357e7 -->

<!-- pgdoc-cn_start sig_en=712486a52bf581413e643f088fe0013c sig_cn_org=None source=14.1 
  <para>
   When row security is enabled on a table (with
   <link linkend="sql-altertable">ALTER TABLE ... ENABLE ROW LEVEL
   SECURITY</link>), all normal access to the table for selecting rows or
   modifying rows must be allowed by a row security policy.  (However, the
   table's owner is typically not subject to row security policies.)  If no
   policy exists for the table, a default-deny policy is used, meaning that
   no rows are visible or can be modified.  Operations that apply to the
   whole table, such as <command>TRUNCATE</command> and <literal>REFERENCES</literal>,
   are not subject to row security.
  </para>
________________________________________________________-->
  <para>
   当在一个表上启用行安全性时（使用
   <link linkend="sql-altertable">ALTER TABLE ... ENABLE ROW LEVEL
   SECURITY</link>），所有对该表选择行或者修改行的普通访问都必须被一条
   行安全性策略所允许（不过，表的拥有者通常不服从行安全性策略）。如果
   表上不存在策略，将使用一条默认的否定策略，即所有的行都不可见或者不能
   被修改。应用在整个表上的操作不服从行安全性，例如<command>TRUNCATE</command>和
   <literal>REFERENCES</literal>。
  </para>
<!-- pgdoc-cn_end sig_en=712486a52bf581413e643f088fe0013c -->

<!-- pgdoc-cn_start sig_en=f1d11f04096fd0450cef4700c90d6281 sig_cn_org=None source=14.1 
  <para>
   Row security policies can be specific to commands, or to roles, or to
   both.  A policy can be specified to apply to <literal>ALL</literal>
   commands, or to <literal>SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</literal>,
   or <literal>DELETE</literal>.  Multiple roles can be assigned to a given
   policy, and normal role membership and inheritance rules apply.
  </para>
________________________________________________________-->
  <para>
   行安全性策略可以针对特定的命令、角色或者两者。一条策略可以被指定为
   适用于<literal>ALL</literal>命令，或者<literal>SELECT</literal>、
   <literal>INSERT</literal>、<literal>UPDATE</literal>、或者<literal>DELETE</literal>。
   可以为一条给定策略分配多个角色，并且通常的角色成员关系和继承规则也适用。
  </para>
<!-- pgdoc-cn_end sig_en=f1d11f04096fd0450cef4700c90d6281 -->

<!-- pgdoc-cn_start sig_en=afdb3a0b0b9de4fc176c86855be71476 sig_cn_org=None source=14.1 
  <para>
   To specify which rows are visible or modifiable according to a policy,
   an expression is required that returns a Boolean result.  This
   expression will be evaluated for each row prior to any conditions or
   functions coming from the user's query.  (The only exceptions to this
   rule are <literal>leakproof</literal> functions, which are guaranteed to
   not leak information; the optimizer may choose to apply such functions
   ahead of the row-security check.)  Rows for which the expression does
   not return <literal>true</literal> will not be processed.  Separate expressions
   may be specified to provide independent control over the rows which are
   visible and the rows which are allowed to be modified.  Policy
   expressions are run as part of the query and with the privileges of the
   user running the query, although security-definer functions can be used
   to access data not available to the calling user.
  </para>
________________________________________________________-->
  <para>
   要指定哪些行根据一条策略是可见的或者是可修改的，需要一个返回布尔结果
   的表达式。对于每一行，在计算任何来自用户查询的条件或函数之前，先会计
   算这个表达式（这条规则的唯一例外是<literal>leakproof</literal>函数，
   它们被保证不会泄露信息，优化器可能会选择在行安全性检查之前应用这类
   函数）。使该表达式不返回<literal>true</literal>的行将不会被处理。可以指定
   独立的表达式来单独控制哪些行可见以及哪些行被允许修改。策略表达式会作
   为查询的一部分运行并且带有运行该查询的用户的特权，但是安全性定义者函数
   可以被用来访问对调用用户不可用的数据。
  </para>
<!-- pgdoc-cn_end sig_en=afdb3a0b0b9de4fc176c86855be71476 -->

<!-- pgdoc-cn_start sig_en=c56a2d0b966ddde93f443e513f8560a8 sig_cn_org=None source=14.1 
  <para>
   Superusers and roles with the <literal>BYPASSRLS</literal> attribute always
   bypass the row security system when accessing a table.  Table owners
   normally bypass row security as well, though a table owner can choose to
   be subject to row security with <link linkend="sql-altertable">ALTER
   TABLE ... FORCE ROW LEVEL SECURITY</link>.
  </para>
________________________________________________________-->
  <para>
   具有<literal>BYPASSRLS</literal>属性的超级用户和角色在访问一个表时总是
   可以绕过行安全性系统。表拥有者通常也能绕过行安全性，不过表拥有者
   可以选择用<link linkend="sql-altertable">ALTER
   TABLE ... FORCE ROW LEVEL SECURITY</link>来服从行安全性。
  </para>
<!-- pgdoc-cn_end sig_en=c56a2d0b966ddde93f443e513f8560a8 -->

<!-- pgdoc-cn_start sig_en=ab7a80ac30988b6c66a5d303f7072f1a sig_cn_org=None source=14.1 
  <para>
   Enabling and disabling row security, as well as adding policies to a
   table, is always the privilege of the table owner only.
  </para>
________________________________________________________-->
  <para>
   启用和禁用行安全性以及向表增加策略是只有表拥有者具有的特权。
  </para>
<!-- pgdoc-cn_end sig_en=ab7a80ac30988b6c66a5d303f7072f1a -->

<!-- pgdoc-cn_start sig_en=d09c93922c5f9d27dc50046e072acf52 sig_cn_org=None source=14.1 
  <para>
   Policies are created using the <xref linkend="sql-createpolicy"/>
   command, altered using the <xref linkend="sql-alterpolicy"/> command,
   and dropped using the <xref linkend="sql-droppolicy"/> command.  To
   enable and disable row security for a given table, use the
   <xref linkend="sql-altertable"/> command.
  </para>
________________________________________________________-->
  <para>
   策略的创建可以使用<xref linkend="sql-createpolicy"/>命令，策略的修改
   可以使用<xref linkend="sql-alterpolicy"/>命令，而策略的删除可以使用
   <xref linkend="sql-droppolicy"/>命令。要为一个给定表启用或者禁用行
   安全性，可以使用<xref linkend="sql-altertable"/>命令。
  </para>
<!-- pgdoc-cn_end sig_en=d09c93922c5f9d27dc50046e072acf52 -->

<!-- pgdoc-cn_start sig_en=54d094a4fffe24c093126625f4cf5776 sig_cn_org=None source=14.1 
  <para>
   Each policy has a name and multiple policies can be defined for a
   table.  As policies are table-specific, each policy for a table must
   have a unique name.  Different tables may have policies with the
   same name.
  </para>
________________________________________________________-->
  <para>
   每一条策略都有名称并且可以为一个表定义多条策略。由于策略是表相
   关的，一个表的每一条策略都必须有一个唯一的名称。不同的表可以拥有
   相同名称的策略。
  </para>
<!-- pgdoc-cn_end sig_en=54d094a4fffe24c093126625f4cf5776 -->

<!-- pgdoc-cn_start sig_en=23732629e032de9f62c887c3402be954 sig_cn_org=None source=14.1 
  <para>
   When multiple policies apply to a given query, they are combined using
   either <literal>OR</literal> (for permissive policies, which are the
   default) or using <literal>AND</literal> (for restrictive policies).
   This is similar to the rule that a given role has the privileges
   of all roles that they are a member of.  Permissive vs. restrictive
   policies are discussed further below.
  </para>
________________________________________________________-->
  <para>
   当多条策略适用于一个给定的查询时，会把它们用<literal>OR</literal>（对宽容性策略，默认的策略类型）或者<literal>AND</literal>（对限制性策略）组合在一起。这和给定角色拥有它作为成员的所有角色的特权的规则类似。宽容性策略和限制性策略在下文将会进一步讨论。
  </para>
<!-- pgdoc-cn_end sig_en=23732629e032de9f62c887c3402be954 -->

<!-- pgdoc-cn_start sig_en=cebeb35e94b1617e8404edf65ffd3786 sig_cn_org=None source=14.1 
  <para>
   As a simple example, here is how to create a policy on
   the <literal>account</literal> relation to allow only members of
   the <literal>managers</literal> role to access rows, and only rows of their
   accounts:
  </para>
________________________________________________________-->
  <para>
   作为一个简单的例子，这里是如何在<literal>account</literal>关系上
   创建一条策略以允许只有<literal>managers</literal>角色的成员能访问行，
   并且只能访问它们账户的行：
  </para>
<!-- pgdoc-cn_end sig_en=cebeb35e94b1617e8404edf65ffd3786 -->

<!-- pgdoc-cn_start sig_en=06f1b3b09826453169b4a59a580551e6 sig_cn_org=None source=14.1 
<programlisting>
CREATE TABLE accounts (manager text, company text, contact_email text);

ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;

CREATE POLICY account_managers ON accounts TO managers
    USING (manager = current_user);
</programlisting>
________________________________________________________-->
<programlisting>
CREATE TABLE accounts (manager text, company text, contact_email text);

ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;

CREATE POLICY account_managers ON accounts TO managers
    USING (manager = current_user);
</programlisting>
<!-- pgdoc-cn_end sig_en=06f1b3b09826453169b4a59a580551e6 -->

<!-- pgdoc-cn_start sig_en=a43babb486ce2b2161317220717ee8db sig_cn_org=None source=14.1 
  <para>
   The policy above implicitly provides a <literal>WITH CHECK</literal>
   clause identical to its <literal>USING</literal> clause, so that the
   constraint applies both to rows selected by a command (so a manager
   cannot <command>SELECT</command>, <command>UPDATE</command>,
   or <command>DELETE</command> existing rows belonging to a different
   manager) and to rows modified by a command (so rows belonging to a
   different manager cannot be created via <command>INSERT</command>
   or <command>UPDATE</command>).
  </para>
________________________________________________________-->
  <para>
   上面的策略隐含地提供了一个与其该约束适用于被一个命令选择的行（这样一个经理不能<command>SELECT</command>、<command>UPDATE</command>或者<command>DELETE</command>属于其他经理的已有行）以及被一个命令修改的行（这样属于其他经理的行不能通过<command>INSERT</command>或者<command>UPDATE</command>创建）。
  </para>
<!-- pgdoc-cn_end sig_en=a43babb486ce2b2161317220717ee8db -->

<!-- pgdoc-cn_start sig_en=8b575f3b8da05b9189c9f880d6df87bb sig_cn_org=None source=14.1 
  <para>
   If no role is specified, or the special user name
   <literal>PUBLIC</literal> is used, then the policy applies to all
   users on the system.  To allow all users to access only their own row in
   a <literal>users</literal> table, a simple policy can be used:
  </para>
________________________________________________________-->
  <para>
   如果没有指定角色或者使用了特殊的用户名<literal>PUBLIC</literal>，
   则该策略适用于系统上所有的用户。要允许所有用户访问<literal>users</literal>
   表中属于他们自己的行，可以使用一条简单的策略：
  </para>
<!-- pgdoc-cn_end sig_en=8b575f3b8da05b9189c9f880d6df87bb -->

<!-- pgdoc-cn_start sig_en=55ab8096d6bc52169ee29e5ce933bb68 sig_cn_org=None source=14.1 
<programlisting>
CREATE POLICY user_policy ON users
    USING (user_name = current_user);
</programlisting>
________________________________________________________-->
<programlisting>
CREATE POLICY user_policy ON users
    USING (user_name = current_user);
</programlisting>
<!-- pgdoc-cn_end sig_en=55ab8096d6bc52169ee29e5ce933bb68 -->

<!-- pgdoc-cn_start sig_en=8dde9d18bece3bea209d0c371cbcb95e sig_cn_org=None source=14.1 
  <para>
   This works similarly to the previous example.
  </para>
________________________________________________________-->
  <para>
   这个例子的效果和前一个类似。
  </para>
<!-- pgdoc-cn_end sig_en=8dde9d18bece3bea209d0c371cbcb95e -->

<!-- pgdoc-cn_start sig_en=abd09219c1b3227b5876f8baebf5c8b9 sig_cn_org=None source=14.1 
  <para>
   To use a different policy for rows that are being added to the table
   compared to those rows that are visible, multiple policies can be
   combined.  This pair of policies would allow all users to view all rows
   in the <literal>users</literal> table, but only modify their own:
  </para>
________________________________________________________-->
  <para>
   为了对增加到表中的行使用与可见行不同的策略，可以组合多条策略。这一对策略将允许所有用户查看<literal>users</literal>表中的所有行，但只能修改他们自己的行：
  </para>
<!-- pgdoc-cn_end sig_en=abd09219c1b3227b5876f8baebf5c8b9 -->

<!-- pgdoc-cn_start sig_en=7395bf547edbdf260ff0692bb019ebe8 sig_cn_org=None source=14.1 
<programlisting>
CREATE POLICY user_sel_policy ON users
    FOR SELECT
    USING (true);
CREATE POLICY user_mod_policy ON users
    USING (user_name = current_user);
</programlisting>
________________________________________________________-->
<programlisting>
CREATE POLICY user_sel_policy ON users
    FOR SELECT
    USING (true);
CREATE POLICY user_mod_policy ON users
    USING (user_name = current_user);
</programlisting>
<!-- pgdoc-cn_end sig_en=7395bf547edbdf260ff0692bb019ebe8 -->

<!-- pgdoc-cn_start sig_en=a518df33c1f51e05f147782e3ad73c6c sig_cn_org=None source=14.1 
  <para>
   In a <command>SELECT</command> command, these two policies are combined
   using <literal>OR</literal>, with the net effect being that all rows
   can be selected.  In other command types, only the second policy applies,
   so that the effects are the same as before.
  </para>
________________________________________________________-->
  <para>
   在一个<command>SELECT</command>命令中，这两条规则被用<literal>OR</literal>组合在一起，最终的效应就是所有的行都能被选择。在其他命令类型中，只有第二条策略适用，这样其效果就和以前相同。
  </para>
<!-- pgdoc-cn_end sig_en=a518df33c1f51e05f147782e3ad73c6c -->

<!-- pgdoc-cn_start sig_en=08547023ea042a053ef11e7411c18d9f sig_cn_org=None source=14.1 
  <para>
   Row security can also be disabled with the <command>ALTER TABLE</command>
   command.  Disabling row security does not remove any policies that are
   defined on the table; they are simply ignored.  Then all rows in the
   table are visible and modifiable, subject to the standard SQL privileges
   system.
  </para>
________________________________________________________-->
  <para>
   也可以用<command>ALTER TABLE</command>命令禁用行安全性。禁用行安全性
   不会移除定义在表上的任何策略，它们只是被简单地忽略。然后该表中的所有
   行都是可见的并且可修改，服从于标准的 SQL 特权系统。
  </para>
<!-- pgdoc-cn_end sig_en=08547023ea042a053ef11e7411c18d9f -->

<!-- pgdoc-cn_start sig_en=fa66a3ad1019e08748063b9c793abd11 sig_cn_org=None source=14.1 
  <para>
   Below is a larger example of how this feature can be used in production
   environments.  The table <literal>passwd</literal> emulates a Unix password
   file:
  </para>
________________________________________________________-->
  <para>
   下面是一个较大的例子，它展示了这种特性如何被用于生产环境。表
   <literal>passwd</literal>模拟了一个 Unix 口令文件：
  </para>
<!-- pgdoc-cn_end sig_en=fa66a3ad1019e08748063b9c793abd11 -->

<!-- pgdoc-cn_start sig_en=acfa0f7c9d1882b5248250577419e188 sig_cn_org=None source=14.1 
<programlisting>
-&minus; Simple passwd-file based example
CREATE TABLE passwd (
  user_name             text UNIQUE NOT NULL,
  pwhash                text,
  uid                   int  PRIMARY KEY,
  gid                   int  NOT NULL,
  real_name             text NOT NULL,
  home_phone            text,
  extra_info            text,
  home_dir              text NOT NULL,
  shell                 text NOT NULL
);

CREATE ROLE admin;  -&minus; Administrator
CREATE ROLE bob;    -&minus; Normal user
CREATE ROLE alice;  -&minus; Normal user

-&minus; Populate the table
INSERT INTO passwd VALUES
  ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');
INSERT INTO passwd VALUES
  ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');
INSERT INTO passwd VALUES
  ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');

-&minus; Be sure to enable row-level security on the table
ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;

-&minus; Create policies
-&minus; Administrator can see all rows and add any rows
CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);
-&minus; Normal users can view all rows
CREATE POLICY all_view ON passwd FOR SELECT USING (true);
-&minus; Normal users can update their own records, but
-&minus; limit which shells a normal user is allowed to set
CREATE POLICY user_mod ON passwd FOR UPDATE
  USING (current_user = user_name)
  WITH CHECK (
    current_user = user_name AND
    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')
  );

-&minus; Allow admin all normal rights
GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;
-&minus; Users only get select access on public columns
GRANT SELECT
  (user_name, uid, gid, real_name, home_phone, extra_info, home_dir, shell)
  ON passwd TO public;
-&minus; Allow users to update certain columns
GRANT UPDATE
  (pwhash, real_name, home_phone, extra_info, shell)
  ON passwd TO public;
</programlisting>
________________________________________________________-->
<programlisting>
-&minus; 简单的口令文件例子
CREATE TABLE passwd (
  user_name             text UNIQUE NOT NULL,
  pwhash                text,
  uid                   int  PRIMARY KEY,
  gid                   int  NOT NULL,
  real_name             text NOT NULL,
  home_phone            text,
  extra_info            text,
  home_dir              text NOT NULL,
  shell                 text NOT NULL
);

CREATE ROLE admin;  -&minus; 管理员
CREATE ROLE bob;    -&minus; 普通用户
CREATE ROLE alice;  -&minus; 普通用户

-&minus; 填充表
INSERT INTO passwd VALUES
  ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');
INSERT INTO passwd VALUES
  ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');
INSERT INTO passwd VALUES
  ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');

-&minus; 确保在表上启用行级安全性
ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;

-&minus; 创建策略
-&minus; 管理员能看见所有行并且增加任意行
CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);
-&minus; 普通用户可以看见所有行
CREATE POLICY all_view ON passwd FOR SELECT USING (true);
-&minus; 普通用户可以更新它们自己的记录，但是限制普通用户可用的 shell
CREATE POLICY user_mod ON passwd FOR UPDATE
  USING (current_user = user_name)
  WITH CHECK (
    current_user = user_name AND
    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')
  );

-&minus; 允许管理员有所有普通权限
GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;
-&minus; 用户只在公共列上得到选择访问
GRANT SELECT
  (user_name, uid, gid, real_name, home_phone, extra_info, home_dir, shell)
  ON passwd TO public;
-&minus; 允许用户更新特定行
GRANT UPDATE
  (pwhash, real_name, home_phone, extra_info, shell)
  ON passwd TO public;
</programlisting>
<!-- pgdoc-cn_end sig_en=acfa0f7c9d1882b5248250577419e188 -->

<!-- pgdoc-cn_start sig_en=ef118c36db9a37c1917995c843722701 sig_cn_org=None source=14.1 
  <para>
   As with any security settings, it's important to test and ensure that
   the system is behaving as expected.  Using the example above, this
   demonstrates that the permission system is working properly.
  </para>
________________________________________________________-->
  <para>
   对于任意安全性设置来说，重要的是测试并确保系统的行为符合预期。
   使用上述的例子，下面展示了权限系统工作正确：
  </para>
<!-- pgdoc-cn_end sig_en=ef118c36db9a37c1917995c843722701 -->

<!-- pgdoc-cn_start sig_en=b5a25f17772826a2a7e70ba450c638cb sig_cn_org=b5a25f17772826a2a7e70ba450c638cb source=15.7 
<programlisting>
-&minus; admin can view all rows and fields
postgres=&gt; set role admin;
SET
postgres=&gt; table passwd;
 user_name | pwhash | uid | gid | real_name |  home_phone  | extra_info | home_dir    |   shell
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-
 admin     | xxx    |   0 |   0 | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | xxx    |   1 |   1 | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | xxx    |   2 |   1 | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

-&minus; Test what Alice is able to do
postgres=&gt; set role alice;
SET
postgres=&gt; table passwd;
ERROR:  permission denied for table passwd
postgres=&gt; select user_name,real_name,home_phone,extra_info,home_dir,shell from passwd;
 user_name | real_name |  home_phone  | extra_info | home_dir    |   shell
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-
 admin     | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

postgres=&gt; update passwd set user_name = 'joe';
ERROR:  permission denied for table passwd
-&minus; Alice is allowed to change her own real_name, but no others
postgres=&gt; update passwd set real_name = 'Alice Doe';
UPDATE 1
postgres=&gt; update passwd set real_name = 'John Doe' where user_name = 'admin';
UPDATE 0
postgres=&gt; update passwd set shell = '/bin/xx';
ERROR:  new row violates WITH CHECK OPTION for "passwd"
postgres=&gt; delete from passwd;
ERROR:  permission denied for table passwd
postgres=&gt; insert into passwd (user_name) values ('xxx');
ERROR:  permission denied for table passwd
-&minus; Alice can change her own password; RLS silently prevents updating other rows
postgres=&gt; update passwd set pwhash = 'abc';
UPDATE 1
</programlisting>
________________________________________________________-->
<programlisting>
-- admin can view all rows and fields
postgres=&gt; set role admin;
SET
postgres=&gt; table passwd;
 user_name | pwhash | uid | gid | real_name |  home_phone  | extra_info | home_dir    |   shell
-----------+--------+-----+-----+-----------+--------------+------------+-------------+-----------
 admin     | xxx    |   0 |   0 | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | xxx    |   1 |   1 | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | xxx    |   2 |   1 | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

-- Test what Alice is able to do
postgres=&gt; set role alice;
SET
postgres=&gt; table passwd;
ERROR:  permission denied for table passwd
postgres=&gt; select user_name,real_name,home_phone,extra_info,home_dir,shell from passwd;
 user_name | real_name |  home_phone  | extra_info | home_dir    |   shell
-----------+-----------+--------------+------------+-------------+-----------
 admin     | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

postgres=&gt; update passwd set user_name = 'joe';
ERROR:  permission denied for table passwd
-- Alice is allowed to change her own real_name, but no others
postgres=&gt; update passwd set real_name = 'Alice Doe';
UPDATE 1
postgres=&gt; update passwd set real_name = 'John Doe' where user_name = 'admin';
UPDATE 0
postgres=&gt; update passwd set shell = '/bin/xx';
ERROR:  new row violates WITH CHECK OPTION for "passwd"
postgres=&gt; delete from passwd;
ERROR:  permission denied for table passwd
postgres=&gt; insert into passwd (user_name) values ('xxx');
ERROR:  permission denied for table passwd
-- Alice can change her own password; RLS silently prevents updating other rows
postgres=&gt; update passwd set pwhash = 'abc';
UPDATE 1
</programlisting>
<!-- pgdoc-cn_end sig_en=b5a25f17772826a2a7e70ba450c638cb -->

<!-- pgdoc-cn_start sig_en=d0438b1d0a284f370cf622feb14410b7 sig_cn_org=None source=14.1 
  <para>
   All of the policies constructed thus far have been permissive policies,
   meaning that when multiple policies are applied they are combined using
   the <quote>OR</quote> Boolean operator.  While permissive policies can be constructed
   to only allow access to rows in the intended cases, it can be simpler to
   combine permissive policies with restrictive policies (which the records
   must pass and which are combined using the <quote>AND</quote> Boolean operator).
   Building on the example above, we add a restrictive policy to require
   the administrator to be connected over a local Unix socket to access the
   records of the <literal>passwd</literal> table:
  </para>
________________________________________________________-->
  <para>
   目前为止所有构建的策略都是宽容性策略，也就是当多条策略都适用时会被适用<quote>OR</quote>布尔操作符组合在一起。而宽容性策略可以被用来仅允许在预计情况中对行的访问，这比将宽容性策略与限制性策略（记录必须通过这类策略并且它们会被<quote>AND</quote>布尔操作符组合起来）组合在一起更简单。在上面的例子之上，我们增加一条限制性策略要求通过一个本地Unix套接字连接过来的管理员访问<literal>passwd</literal>表的记录：
  </para>
<!-- pgdoc-cn_end sig_en=d0438b1d0a284f370cf622feb14410b7 -->

<!-- pgdoc-cn_start sig_en=d462424c4242fd1ef2cefd67db4e5e16 sig_cn_org=None source=14.1 
<programlisting>
CREATE POLICY admin_local_only ON passwd AS RESTRICTIVE TO admin
    USING (pg_catalog.inet_client_addr() IS NULL);
</programlisting>
________________________________________________________-->
<programlisting>
CREATE POLICY admin_local_only ON passwd AS RESTRICTIVE TO admin
    USING (pg_catalog.inet_client_addr() IS NULL);
</programlisting>
<!-- pgdoc-cn_end sig_en=d462424c4242fd1ef2cefd67db4e5e16 -->

<!-- pgdoc-cn_start sig_en=6b73f2b9f2c0560473318ef60517f30f sig_cn_org=None source=14.1 
  <para>
   We can then see that an administrator connecting over a network will not
   see any records, due to the restrictive policy:
  </para>
________________________________________________________-->
  <para>
   然后，由于这条限制性规则的存在，我们可以看到从网络连接进来的管理员将无法看到任何记录：
  </para>
<!-- pgdoc-cn_end sig_en=6b73f2b9f2c0560473318ef60517f30f -->

<!-- pgdoc-cn_start sig_en=f1dfc626447b21e21d6a99ce490c9133 sig_cn_org=f1dfc626447b21e21d6a99ce490c9133 source=15.7 
<programlisting>
=&gt; SELECT current_user;
 current_user
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 admin
(1 row)

=&gt; select inet_client_addr();
 inet_client_addr
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 127.0.0.1
(1 row)

=&gt; TABLE passwd;
 user_name | pwhash | uid | gid | real_name | home_phone | extra_info | home_dir | shell
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
(0 rows)

=&gt; UPDATE passwd set pwhash = NULL;
UPDATE 0
</programlisting>
________________________________________________________-->
<programlisting>
=&gt; SELECT current_user;
 current_user
--------------
 admin
(1 row)

=&gt; select inet_client_addr();
 inet_client_addr
------------------
 127.0.0.1
(1 row)

=&gt; TABLE passwd;
 user_name | pwhash | uid | gid | real_name | home_phone | extra_info | home_dir | shell
-----------+--------+-----+-----+-----------+------------+------------+----------+-------
(0 rows)

=&gt; UPDATE passwd set pwhash = NULL;
UPDATE 0
</programlisting>
<!-- pgdoc-cn_end sig_en=f1dfc626447b21e21d6a99ce490c9133 -->

<!-- pgdoc-cn_start sig_en=26a5c69be64d139c1c9ee717ced6e221 sig_cn_org=None source=14.1 
  <para>
   Referential integrity checks, such as unique or primary key constraints
   and foreign key references, always bypass row security to ensure that
   data integrity is maintained.  Care must be taken when developing
   schemas and row level policies to avoid <quote>covert channel</quote> leaks of
   information through such referential integrity checks.
  </para>
________________________________________________________-->
  <para>
   参照完整性检查（例如唯一或逐渐约束和外键引用）总是会绕过行级安全性以
   保证数据完整性得到维护。在开发模式和行级安全性时必须小心避免
   <quote>隐通道</quote>通过这类参照完整性检查泄露信息。
  </para>
<!-- pgdoc-cn_end sig_en=26a5c69be64d139c1c9ee717ced6e221 -->

<!-- pgdoc-cn_start sig_en=a7f86ec4da6a6aa1f7408a4d4e2b7e58 sig_cn_org=None source=14.1 
  <para>
   In some contexts it is important to be sure that row security is
   not being applied.  For example, when taking a backup, it could be
   disastrous if row security silently caused some rows to be omitted
   from the backup.  In such a situation, you can set the
   <xref linkend="guc-row-security"/> configuration parameter
   to <literal>off</literal>.  This does not in itself bypass row security;
   what it does is throw an error if any query's results would get filtered
   by a policy.  The reason for the error can then be investigated and
   fixed.
  </para>
________________________________________________________-->
  <para>
   在某些环境中确保行安全性没有被应用很重要。例如，在做备份时，如果
   行安全性悄悄地导致某些行被从备份中忽略掉，这会是灾难性的。在这类
   情况下，你可以设置<xref linkend="guc-row-security"/>配置参数为
   <literal>off</literal>。这本身不会绕过行安全性，它所做的是如果任何结果会
   被一条策略过滤掉，就会抛出一个错误。然后错误的原因就可以被找到并且
   修复。
  </para>
<!-- pgdoc-cn_end sig_en=a7f86ec4da6a6aa1f7408a4d4e2b7e58 -->

<!-- pgdoc-cn_start sig_en=0b2f3bae9dd2c893fed096bf7c4d61df sig_cn_org=None source=14.1 
  <para>
   In the examples above, the policy expressions consider only the current
   values in the row to be accessed or updated.  This is the simplest and
   best-performing case; when possible, it's best to design row security
   applications to work this way.  If it is necessary to consult other rows
   or other tables to make a policy decision, that can be accomplished using
   sub-<command>SELECT</command>s, or functions that contain <command>SELECT</command>s,
   in the policy expressions.  Be aware however that such accesses can
   create race conditions that could allow information leakage if care is
   not taken.  As an example, consider the following table design:
  </para>
________________________________________________________-->
  <para>
   在上面的例子中，策略表达式只考虑了要被访问的行中的当前值。这是最简
   单并且表现最好的情况。如果可能，最好设计行安全性应用以这种方式工作。
   如果需要参考其他行或者其他表来做出策略的决定，可以在策略表达式中通过
   使用子-<command>SELECT</command>或者包含<command>SELECT</command>的函数
   来实现。不过要注意这类访问可能会导致竞争条件，在不小心的情况下这可能
   会导致信息泄露。作为一个例子，考虑下面的表设计：
  </para>
<!-- pgdoc-cn_end sig_en=0b2f3bae9dd2c893fed096bf7c4d61df -->

<!-- pgdoc-cn_start sig_en=d1cdfbac51f777e94ed32b34448a3179 sig_cn_org=None source=14.1 
<programlisting>
-&minus; definition of privilege groups
CREATE TABLE groups (group_id int PRIMARY KEY,
                     group_name text NOT NULL);

INSERT INTO groups VALUES
  (1, 'low'),
  (2, 'medium'),
  (5, 'high');

GRANT ALL ON groups TO alice;  -&minus; alice is the administrator
GRANT SELECT ON groups TO public;

-&minus; definition of users' privilege levels
CREATE TABLE users (user_name text PRIMARY KEY,
                    group_id int NOT NULL REFERENCES groups);

INSERT INTO users VALUES
  ('alice', 5),
  ('bob', 2),
  ('mallory', 2);

GRANT ALL ON users TO alice;
GRANT SELECT ON users TO public;

-&minus; table holding the information to be protected
CREATE TABLE information (info text,
                          group_id int NOT NULL REFERENCES groups);

INSERT INTO information VALUES
  ('barely secret', 1),
  ('slightly secret', 2),
  ('very secret', 5);

ALTER TABLE information ENABLE ROW LEVEL SECURITY;

-&minus; a row should be visible to/updatable by users whose security group_id is
-&minus; greater than or equal to the row's group_id
CREATE POLICY fp_s ON information FOR SELECT
  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));
CREATE POLICY fp_u ON information FOR UPDATE
  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));

-&minus; we rely only on RLS to protect the information table
GRANT ALL ON information TO public;
</programlisting>
________________________________________________________-->
<programlisting>
-&minus; 特权组的定义
CREATE TABLE groups (group_id int PRIMARY KEY,
                     group_name text NOT NULL);

INSERT INTO groups VALUES
  (1, 'low'),
  (2, 'medium'),
  (5, 'high');

GRANT ALL ON groups TO alice;  -&minus; alice 是管理员
GRANT SELECT ON groups TO public;

-&minus; 用户的特权级别的定义
CREATE TABLE users (user_name text PRIMARY KEY,
                    group_id int NOT NULL REFERENCES groups);

INSERT INTO users VALUES
  ('alice', 5),
  ('bob', 2),
  ('mallory', 2);

GRANT ALL ON users TO alice;
GRANT SELECT ON users TO public;

-&minus; 保存要被保护的信息的表
CREATE TABLE information (info text,
                          group_id int NOT NULL REFERENCES groups);

INSERT INTO information VALUES
  ('barely secret', 1),
  ('slightly secret', 2),
  ('very secret', 5);

ALTER TABLE information ENABLE ROW LEVEL SECURITY;

-&minus; 对于安全性 group_id 大于等于一行的 group_id 的用户，
-&minus; 这一行应该是可见的/可更新的
CREATE POLICY fp_s ON information FOR SELECT
  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));
CREATE POLICY fp_u ON information FOR UPDATE
  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));

-&minus; 我们只依赖于行级安全性来保护信息表
GRANT ALL ON information TO public;
</programlisting>
<!-- pgdoc-cn_end sig_en=d1cdfbac51f777e94ed32b34448a3179 -->

<!-- pgdoc-cn_start sig_en=b39c02dead20079fdb4f172787e4a931 sig_cn_org=None source=14.1 
  <para>
   Now suppose that <literal>alice</literal> wishes to change the <quote>slightly
   secret</quote> information, but decides that <literal>mallory</literal> should not
   be trusted with the new content of that row, so she does:
  </para>
________________________________________________________-->
  <para>
   现在假设<literal>alice</literal>希望更改<quote>有一点点秘密</quote>
   的信息，但是觉得<literal>mallory</literal>不应该看到该行中的新
   内容，因此她这样做：
  </para>
<!-- pgdoc-cn_end sig_en=b39c02dead20079fdb4f172787e4a931 -->

<!-- pgdoc-cn_start sig_en=7e91e8250732c7a5128028a4f294edc5 sig_cn_org=None source=14.1 
<programlisting>
BEGIN;
UPDATE users SET group_id = 1 WHERE user_name = 'mallory';
UPDATE information SET info = 'secret from mallory' WHERE group_id = 2;
COMMIT;
</programlisting>
________________________________________________________-->
<programlisting>
BEGIN;
UPDATE users SET group_id = 1 WHERE user_name = 'mallory';
UPDATE information SET info = 'secret from mallory' WHERE group_id = 2;
COMMIT;
</programlisting>
<!-- pgdoc-cn_end sig_en=7e91e8250732c7a5128028a4f294edc5 -->

<!-- pgdoc-cn_start sig_en=233ad85eae41c213800a549300f74d5a sig_cn_org=None source=14.1 
  <para>
   That looks safe; there is no window wherein <literal>mallory</literal> should be
   able to see the <quote>secret from mallory</quote> string.  However, there is
   a race condition here.  If <literal>mallory</literal> is concurrently doing,
   say,
<programlisting>
SELECT * FROM information WHERE group_id = 2 FOR UPDATE;
</programlisting>
   and her transaction is in <literal>READ COMMITTED</literal> mode, it is possible
   for her to see <quote>secret from mallory</quote>.  That happens if her
   transaction reaches the <structname>information</structname> row just
   after <literal>alice</literal>'s does.  It blocks waiting
   for <literal>alice</literal>'s transaction to commit, then fetches the updated
   row contents thanks to the <literal>FOR UPDATE</literal> clause.  However, it
   does <emphasis>not</emphasis> fetch an updated row for the
   implicit <command>SELECT</command> from <structname>users</structname>, because that
   sub-<command>SELECT</command> did not have <literal>FOR UPDATE</literal>; instead
   the <structname>users</structname> row is read with the snapshot taken at the start
   of the query.  Therefore, the policy expression tests the old value
   of <literal>mallory</literal>'s privilege level and allows her to see the
   updated row.
  </para>
________________________________________________________-->
  <para>
   这看起来是安全的，没有窗口可供<literal>mallory</literal>看到
   <quote>对 mallory 保密</quote>的字符串。不过，这里有一种
   竞争条件。如果<literal>mallory</literal>正在并行地做：
<programlisting>
SELECT * FROM information WHERE group_id = 2 FOR UPDATE;
</programlisting>
   并且她的事务处于<literal>READ COMMITTED</literal>模式，她就可能看到
   <quote>s对 mallory 保密</quote>的东西。如果她的事务在<literal>alice</literal>
   做完之后就到达<structname>信息</structname>行，这就会发生。它会阻塞等待
   <literal>alice</literal>的事务提交，然后拜<literal>FOR UPDATE</literal>子句所赐
   取得更新后的行内容。不过，对于来自<structname>users</structname>的隐式
   <command>SELECT</command>，它<emphasis>不会</emphasis>取得一个已更新的行，
   因为子-<command>SELECT</command>没有<literal>FOR UPDATE</literal>，相反
   会使用查询开始时取得的快照读取<structname>users</structname>行。因此，
   策略表达式会测试<literal>mallory</literal>的特权级别的旧值并且允许她看到
   被更新的行。
  </para>
<!-- pgdoc-cn_end sig_en=233ad85eae41c213800a549300f74d5a -->

<!-- pgdoc-cn_start sig_en=17a69e7cc936c78e279bdc2d68f4148d sig_cn_org=None source=14.1 
  <para>
   There are several ways around this problem.  One simple answer is to use
   <literal>SELECT ... FOR SHARE</literal> in sub-<command>SELECT</command>s in row
   security policies.  However, that requires granting <literal>UPDATE</literal>
   privilege on the referenced table (here <structname>users</structname>) to the
   affected users, which might be undesirable.  (But another row security
   policy could be applied to prevent them from actually exercising that
   privilege; or the sub-<command>SELECT</command> could be embedded into a security
   definer function.)  Also, heavy concurrent use of row share locks on the
   referenced table could pose a performance problem, especially if updates
   of it are frequent.  Another solution, practical if updates of the
   referenced table are infrequent, is to take an
   <literal>ACCESS EXCLUSIVE</literal> lock on the
   referenced table when updating it, so that no concurrent transactions
   could be examining old row values.  Or one could just wait for all
   concurrent transactions to end after committing an update of the
   referenced table and before making changes that rely on the new security
   situation.
  </para>
________________________________________________________-->
  <para>
   有多种方法能解决这个问题。一种简单的答案是在行安全性策略中的
   子-<command>SELECT</command>里使用<literal>SELECT ... FOR SHARE</literal>。
   不过，这要求在被引用表（这里是<structname>users</structname>）上授予
   <literal>UPDATE</literal>特权给受影响的用户，这可能不是我们想要的（
   但是另一条行安全性策略可能被应用来阻止它们实际使用这个特权，或者
   子-<command>SELECT</command>可能被嵌入到一个安全性定义者函数中）。
   还有，在被引用的表上过多并发地使用行共享锁可能会导致性能问题，
   特别是表更新比较频繁时。另一种解决方案（如果被引用表上的更新
   不频繁就可行）是在更新被引用表时对它取一个<literal>ACCESS EXCLUSIVE</literal>锁，
   这样就没有并发事务能够检查旧的行值了。或者我们可以在提交对被引用表的更新
   之后、在做依赖于新安全性情况的更改之前等待所有并发事务结束。
  </para>
<!-- pgdoc-cn_end sig_en=17a69e7cc936c78e279bdc2d68f4148d -->

<!-- pgdoc-cn_start sig_en=07af39506d50383a8338894c41502908 sig_cn_org=None source=14.1 
  <para>
   For additional details see <xref linkend="sql-createpolicy"/>
   and <xref linkend="sql-altertable"/>.
  </para>
________________________________________________________-->
  <para>
   更多细节请见<xref linkend="sql-createpolicy"/>
   和<xref linkend="sql-altertable"/>。
  </para>
<!-- pgdoc-cn_end sig_en=07af39506d50383a8338894c41502908 -->

 </sect1>

 <sect1 id="ddl-schemas">
<!-- pgdoc-cn_start sig_en=6ec069ee20bc258ceb1abac1f8edfd91 sig_cn_org=None source=14.1 
  <title>Schemas</title>
________________________________________________________-->
  <title>模式</title>
<!-- pgdoc-cn_end sig_en=6ec069ee20bc258ceb1abac1f8edfd91 -->

<!-- pgdoc-cn_start sig_en=d482f2cbe5c06ee146ee08a06f0fb002 sig_cn_org=None source=14.1 
  <indexterm zone="ddl-schemas">
   <primary>schema</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="ddl-schemas">
   <primary>schema</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=d482f2cbe5c06ee146ee08a06f0fb002 -->

<!-- pgdoc-cn_start sig_en=1103b7c47c350b9cfa5e02ddc25631a0 sig_cn_org=None source=14.1 
  <para>
   A <productname>PostgreSQL</productname> database cluster contains
   one or more named databases.  Roles and a few other object types are
   shared across the entire cluster.  A client connection to the server
   can only access data in a single database, the one specified in the
   connection request.
  </para>
________________________________________________________-->
  <para>
   一个<productname>PostgreSQL</productname>数据库集簇中包含一个或更多命名的数据库。
   角色和一些其他对象类型被整个集簇共享，连接到服务器的客户端只能访问单个数据库中的数据，在连接请求中指定的那一个。
  </para>
<!-- pgdoc-cn_end sig_en=1103b7c47c350b9cfa5e02ddc25631a0 -->

  <note>
<!-- pgdoc-cn_start sig_en=8aed66e38eed543cd63ab4d63d31319f sig_cn_org=None source=14.1 
   <para>
    Users of a cluster do not necessarily have the privilege to access every
    database in the cluster.  Sharing of role names means that there
    cannot be different roles named, say, <literal>joe</literal> in two databases
    in the same cluster; but the system can be configured to allow
    <literal>joe</literal> access to only some of the databases.
   </para>
________________________________________________________-->
   <para>
    一个集簇的用户并不必拥有访问集簇中每一个数据库的权限。
    角色名的共享意味着不可能在同一个集簇中出现重名的不同角色，例如两个数据库中都有叫<literal>joe</literal>的用户。
    但系统可以被配置为只允许<literal>joe</literal>访问某些数据库。
   </para>
<!-- pgdoc-cn_end sig_en=8aed66e38eed543cd63ab4d63d31319f -->
  </note>

<!-- pgdoc-cn_start sig_en=85001a5b27e5867e2c112e025b1e6387 sig_cn_org=None source=14.1 
  <para>
   A database contains one or more named <firstterm>schemas</firstterm>, which
   in turn contain tables.  Schemas also contain other kinds of named
   objects, including data types, functions, and operators.  The same
   object name can be used in different schemas without conflict; for
   example, both <literal>schema1</literal> and <literal>myschema</literal> can
   contain tables named <literal>mytable</literal>.  Unlike databases,
   schemas are not rigidly separated: a user can access objects in any
   of the schemas in the database they are connected to, if they have
   privileges to do so.
  </para>
________________________________________________________-->
  <para>
   一个数据库包含一个或多个命名<firstterm>模式</firstterm>，模式中包含着表。模式还包含其他类型的命名对象，包括数据类型、函数和操作符。相同的对象名称可以被用于不同的模式中而不会出现冲突，例如<literal>schema1</literal>和<literal>myschema</literal>都可以包含名为<literal>mytable</literal>的表。和数据库不同，模式并不是被严格地隔离：一个用户可以访问他们所连接的数据库中的所有模式内的对象，只要他们有足够的权限。
  </para>
<!-- pgdoc-cn_end sig_en=85001a5b27e5867e2c112e025b1e6387 -->

<!-- pgdoc-cn_start sig_en=fe404c696f52640352b63ad1a1f3177d sig_cn_org=None source=14.1 
  <para>
   There are several reasons why one might want to use schemas:

   <itemizedlist>
    <listitem>
     <para>
      To allow many users to use one database without interfering with
      each other.
     </para>
    </listitem>

    <listitem>
     <para>
      To organize database objects into logical groups to make them
      more manageable.
     </para>
    </listitem>

    <listitem>
     <para>
      Third-party applications can be put into separate schemas so
      they do not collide with the names of other objects.
     </para>
    </listitem>
   </itemizedlist>

   Schemas are analogous to directories at the operating system level,
   except that schemas cannot be nested.
  </para>
________________________________________________________-->
  <para>
   下面是一些使用模式的原因：

   <itemizedlist>
    <listitem>
     <para>
      允许多个用户使用一个数据库并且不会互相干扰。
     </para>
    </listitem>

    <listitem>
     <para>
      将数据库对象组织成逻辑组以便更容易管理。
     </para>
    </listitem>

    <listitem>
     <para>
      第三方应用的对象可以放在独立的模式中，这样它们就不会与其他对象的名称发生冲突。     </para>
    </listitem>
   </itemizedlist>

   模式类似于操作系统层的目录，但是模式不能嵌套。
  </para>
<!-- pgdoc-cn_end sig_en=fe404c696f52640352b63ad1a1f3177d -->

  <sect2 id="ddl-schemas-create">
<!-- pgdoc-cn_start sig_en=6793c2dd5e02da335d934ff27f3f970d sig_cn_org=None source=14.1 
   <title>Creating a Schema</title>
________________________________________________________-->
   <title>创建模式</title>
<!-- pgdoc-cn_end sig_en=6793c2dd5e02da335d934ff27f3f970d -->

<!-- pgdoc-cn_start sig_en=e8e46f85fc1d8bed48ec23f0ccad99c9 sig_cn_org=None source=14.1 
   <indexterm zone="ddl-schemas-create">
    <primary>schema</primary>
    <secondary>creating</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="ddl-schemas-create">
    <primary>schema</primary>
    <secondary>creating</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=e8e46f85fc1d8bed48ec23f0ccad99c9 -->

<!-- pgdoc-cn_start sig_en=7f609c88108f9371d9b9122c95188ba0 sig_cn_org=None source=14.1 
   <para>
    To create a schema, use the <xref linkend="sql-createschema"/>
    command.  Give the schema a name
    of your choice.  For example:
<programlisting>
CREATE SCHEMA myschema;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    要创建一个模式，可使用<xref linkend="sql-createschema"/>命令，并且给出选择的模式名称。例如：
<programlisting>
CREATE SCHEMA myschema;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=7f609c88108f9371d9b9122c95188ba0 -->

<!-- pgdoc-cn_start sig_en=6d968efcc397dbfc31828796bc0ee865 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>qualified name</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>qualified name</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=6d968efcc397dbfc31828796bc0ee865 -->

<!-- pgdoc-cn_start sig_en=7cd78a48fd406abda212a88adeb4c439 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>name</primary>
    <secondary>qualified</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>name</primary>
    <secondary>qualified</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=7cd78a48fd406abda212a88adeb4c439 -->

<!-- pgdoc-cn_start sig_en=65aafd4d6558c477cfa5f974c58733b4 sig_cn_org=None source=14.1 
   <para>
    To create or access objects in a schema, write a
    <firstterm>qualified name</firstterm> consisting of the schema name and
    table name separated by a dot:
<synopsis>
<replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable>
</synopsis>
    This works anywhere a table name is expected, including the table
    modification commands and the data access commands discussed in
    the following chapters.
    (For brevity we will speak of tables only, but the same ideas apply
    to other kinds of named objects, such as types and functions.)
   </para>
________________________________________________________-->
   <para>
    在一个模式中创建或访问对象，需要使用由模式名和表名构成的<firstterm>限定名</firstterm>，模式名和表名之间以点号分隔：
<synopsis>
<replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable>
</synopsis>
    在任何需要一个表名的地方都可以这样用，包括表修改命令和后续章节要讨论的数据访问命令（为了简洁我们在这里只谈到表，但是这种方式对其他类型的命名对象同样有效，例如类型和函数）。
   </para>
<!-- pgdoc-cn_end sig_en=65aafd4d6558c477cfa5f974c58733b4 -->

<!-- pgdoc-cn_start sig_en=60badfc64fcf18b3e32f5b47d5217639 sig_cn_org=None source=14.1 
   <para>
    Actually, the even more general syntax
<synopsis>
<replaceable>database</replaceable><literal>.</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable>
</synopsis>
    can be used too, but at present this is just for pro forma
    compliance with the SQL standard.  If you write a database name,
    it must be the same as the database you are connected to.
   </para>
________________________________________________________-->
   <para>
    事实上，还有更加通用的语法：
<synopsis>
<replaceable>database</replaceable><literal>.</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>table</replaceable>
</synopsis>
    也可以使用，但是目前它只是在形式上与SQL标准兼容。如果我们写一个数据库名称，它必须是我们正在连接的数据库。
   </para>
<!-- pgdoc-cn_end sig_en=60badfc64fcf18b3e32f5b47d5217639 -->

<!-- pgdoc-cn_start sig_en=188e6faac0a9ec9fa92e0d27b439933e sig_cn_org=None source=14.1 
   <para>
    So to create a table in the new schema, use:
<programlisting>
CREATE TABLE myschema.mytable (
 ...
);
</programlisting>
   </para>
________________________________________________________-->
   <para>
    因此，如果要在一个新模式中创建一个表，可用：
<programlisting>
CREATE TABLE myschema.mytable (
 ...
);
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=188e6faac0a9ec9fa92e0d27b439933e -->

<!-- pgdoc-cn_start sig_en=657e104a4ed3391b969d2b584b274aa4 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>schema</primary>
    <secondary>removing</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>schema</primary>
    <secondary>removing</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=657e104a4ed3391b969d2b584b274aa4 -->

<!-- pgdoc-cn_start sig_en=6bfb46bb2b016ba7cc051b60b47f25a9 sig_cn_org=None source=14.1 
   <para>
    To drop a schema if it's empty (all objects in it have been
    dropped), use:
<programlisting>
DROP SCHEMA myschema;
</programlisting>
    To drop a schema including all contained objects, use:
<programlisting>
DROP SCHEMA myschema CASCADE;
</programlisting>
    See <xref linkend="ddl-depend"/> for a description of the general
    mechanism behind this.
   </para>
________________________________________________________-->
   <para>
    要删除一个为空的模式（其中的所有对象已经被删除），可用：
<programlisting>
DROP SCHEMA myschema;
</programlisting>
    要删除一个模式以及其中包含的所有对象，可用：
<programlisting>
DROP SCHEMA myschema CASCADE;
</programlisting>
    有关于此的更一般的机制请参见<xref linkend="ddl-depend"/>。
   </para>
<!-- pgdoc-cn_end sig_en=6bfb46bb2b016ba7cc051b60b47f25a9 -->

<!-- pgdoc-cn_start sig_en=367267ba5385ba1cb6310aef9ce067ab sig_cn_org=None source=14.1 
   <para>
    Often you will want to create a schema owned by someone else
    (since this is one of the ways to restrict the activities of your
    users to well-defined namespaces).  The syntax for that is:
<programlisting>
CREATE SCHEMA <replaceable>schema_name</replaceable> AUTHORIZATION <replaceable>user_name</replaceable>;
</programlisting>
    You can even omit the schema name, in which case the schema name
    will be the same as the user name.  See <xref
    linkend="ddl-schemas-patterns"/> for how this can be useful.
   </para>
________________________________________________________-->
   <para>
    我们常常希望创建一个由其他人所拥有的模式（因为这是将用户动作限制在良定义的名字空间中的方法之一）。其语法是：
<programlisting>
CREATE SCHEMA <replaceable>schema_name</replaceable> AUTHORIZATION <replaceable>user_name</replaceable>;
</programlisting>
    我们甚至可以省略模式名称，在此种情况下模式名称将会使用用户名，参见<xref linkend="ddl-schemas-patterns"/>。
   </para>
<!-- pgdoc-cn_end sig_en=367267ba5385ba1cb6310aef9ce067ab -->

<!-- pgdoc-cn_start sig_en=bd6132186eb0423eded9d0b21170b076 sig_cn_org=None source=14.1 
   <para>
    Schema names beginning with <literal>pg_</literal> are reserved for
    system purposes and cannot be created by users.
   </para>
________________________________________________________-->
   <para>
    以<literal>pg_</literal>开头的模式名被保留用于系统目的，所以不能被用户所创建。
   </para>
<!-- pgdoc-cn_end sig_en=bd6132186eb0423eded9d0b21170b076 -->
  </sect2>

  <sect2 id="ddl-schemas-public">
<!-- pgdoc-cn_start sig_en=c73e459d2c7a7d55cb30531aba199542 sig_cn_org=None source=14.1 
   <title>The Public Schema</title>
________________________________________________________-->
   <title>公共模式</title>
<!-- pgdoc-cn_end sig_en=c73e459d2c7a7d55cb30531aba199542 -->

<!-- pgdoc-cn_start sig_en=bd8cbeef00ffc78de814dcce114fee29 sig_cn_org=None source=14.1 
   <indexterm zone="ddl-schemas-public">
    <primary>schema</primary>
    <secondary>public</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="ddl-schemas-public">
    <primary>schema</primary>
    <secondary>public</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=bd8cbeef00ffc78de814dcce114fee29 -->

<!-- pgdoc-cn_start sig_en=4ef8c89be07b3d72d908650df1b9bf47 sig_cn_org=None source=14.1 
   <para>
    In the previous sections we created tables without specifying any
    schema names.  By default such tables (and other objects) are
    automatically put into a schema named <quote>public</quote>.  Every new
    database contains such a schema.  Thus, the following are equivalent:
<programlisting>
CREATE TABLE products ( ... );
</programlisting>
    and:
<programlisting>
CREATE TABLE public.products ( ... );
</programlisting>
   </para>
________________________________________________________-->
   <para>
    在前面的小节中，我们创建的表都没有指定任何模式名称。默认情况下这些表（以及其他对象）会自动的被放入一个名为<quote>public</quote>的模式中。任何新数据库都包含这样一个模式。因此，下面的命令是等效的：
<programlisting>
CREATE TABLE products ( ... );
</programlisting>
    以及：
<programlisting>
CREATE TABLE public.products ( ... );
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=4ef8c89be07b3d72d908650df1b9bf47 -->
  </sect2>

  <sect2 id="ddl-schemas-path">
<!-- pgdoc-cn_start sig_en=f4b98c1b2d19a43b35f405b623a7c141 sig_cn_org=None source=14.1 
   <title>The Schema Search Path</title>
________________________________________________________-->
   <title>模式搜索路径</title>
<!-- pgdoc-cn_end sig_en=f4b98c1b2d19a43b35f405b623a7c141 -->

<!-- pgdoc-cn_start sig_en=523b2282990cbeb71d5ee895f1439a17 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>search path</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>search path</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=523b2282990cbeb71d5ee895f1439a17 -->

<!-- pgdoc-cn_start sig_en=6a4abd11874e5a550bfad7437faad206 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>unqualified name</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>unqualified name</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=6a4abd11874e5a550bfad7437faad206 -->

<!-- pgdoc-cn_start sig_en=a0fd41beaa1c833c6ca4890a4db87d39 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>name</primary>
    <secondary>unqualified</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>name</primary>
    <secondary>unqualified</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=a0fd41beaa1c833c6ca4890a4db87d39 -->

<!-- pgdoc-cn_start sig_en=7d30ecd9be3957495ac7ffd80414083a sig_cn_org=None source=14.1 
   <para>
    Qualified names are tedious to write, and it's often best not to
    wire a particular schema name into applications anyway.  Therefore
    tables are often referred to by <firstterm>unqualified names</firstterm>,
    which consist of just the table name.  The system determines which table
    is meant by following a <firstterm>search path</firstterm>, which is a list
    of schemas to look in.  The first matching table in the search path
    is taken to be the one wanted.  If there is no match in the search
    path, an error is reported, even if matching table names exist
    in other schemas in the database.
   </para>
________________________________________________________-->
   <para>
    限定名写起来很冗长，通常最好不要把一个特定模式名拉到应用中。因此，表名通常被使用<firstterm>非限定名</firstterm>来引用，它只由表名构成。系统将沿着一条<firstterm>搜索路径</firstterm>来决定该名称指的是哪个表，搜索路径是一个进行查看的模式列表。 搜索路径中第一个匹配的表将被认为是所需要的。如果在搜索路径中没有任何匹配，即使在数据库的其他模式中存在匹配的表名也将会报告一个错误。
   </para>
<!-- pgdoc-cn_end sig_en=7d30ecd9be3957495ac7ffd80414083a -->

<!-- pgdoc-cn_start sig_en=4ac57d47de6cfb56568807d9732d2bb6 sig_cn_org=None source=14.1 
  <para>
    The ability to create like-named objects in different schemas complicates
    writing a query that references precisely the same objects every time.  It
    also opens up the potential for users to change the behavior of other
    users' queries, maliciously or accidentally.  Due to the prevalence of
    unqualified names in queries and their use
    in <productname>PostgreSQL</productname> internals, adding a schema
    to <varname>search_path</varname> effectively trusts all users having
    <literal>CREATE</literal> privilege on that schema.  When you run an
    ordinary query, a malicious user able to create objects in a schema of
    your search path can take control and execute arbitrary SQL functions as
    though you executed them.
   </para>
________________________________________________________-->
  <para>
    在不同模式中创建命名相同的对象的能力使得编写每次都准确引用相同对象的查询变得复杂。这也使得用户有可能更改其他用户查询的行为，不管是出于恶意还是无意。由于未经限定的名称在查询中以及在<productname>PostgreSQL</productname>内部的广泛使用，在<varname>search_path</varname>中增加一个模式实际上是信任所有在该模式中具有<literal>CREATE</literal>特权的用户。在你运行一个普通查询时，如果恶意用户可以在搜索路径的模式中创建对象，那么他们将能够控制并执行任意SQL函数的对象，而这些事情就像是你在执行一样。
   </para>
<!-- pgdoc-cn_end sig_en=4ac57d47de6cfb56568807d9732d2bb6 -->

<!-- pgdoc-cn_start sig_en=0be1889819e8c8b5690a4a52a8b19da3 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>schema</primary>
    <secondary>current</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>schema</primary>
    <secondary>current</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=0be1889819e8c8b5690a4a52a8b19da3 -->

<!-- pgdoc-cn_start sig_en=3002b782aacf77f621578d694ce9e147 sig_cn_org=None source=14.1 
   <para>
    The first schema named in the search path is called the current schema.
    Aside from being the first schema searched, it is also the schema in
    which new tables will be created if the <command>CREATE TABLE</command>
    command does not specify a schema name.
   </para>
________________________________________________________-->
   <para>
    搜索路径中的第一个模式被称为当前模式。除了是第一个被搜索的模式外，如果<command>CREATE TABLE</command>命令没有指定模式名，它将是新创建表所在的模式。
   </para>
<!-- pgdoc-cn_end sig_en=3002b782aacf77f621578d694ce9e147 -->

<!-- pgdoc-cn_start sig_en=109ae7c3fbae63d06123f1fc1b732d7a sig_cn_org=None source=14.1 
   <indexterm>
    <primary><varname>search_path</varname> configuration parameter</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary><varname>search_path</varname>配置参数</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=109ae7c3fbae63d06123f1fc1b732d7a -->

<!-- pgdoc-cn_start sig_en=dbdfad1da18e8984896942103f44a098 sig_cn_org=None source=14.1 
   <para>
    To show the current search path, use the following command:
<programlisting>
SHOW search_path;
</programlisting>
    In the default setup this returns:
<screen>
 search_path
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 "$user", public
</screen>
    The first element specifies that a schema with the same name as
    the current user is to be searched.  If no such schema exists,
    the entry is ignored.  The second element refers to the
    public schema that we have seen already.
   </para>
________________________________________________________-->
   <para>
    要显示当前搜索路径，使用下面的命令：
<programlisting>
SHOW search_path;
</programlisting>
    在默认设置下这将返回：
<screen>
 search_path
--------------
 "$user", public
</screen>
    第一个元素说明一个和当前用户同名的模式会被搜索。如果不存在这个模式，该项将被忽略。第二个元素指向我们已经见过的公共模式。
   </para>
<!-- pgdoc-cn_end sig_en=dbdfad1da18e8984896942103f44a098 -->

<!-- pgdoc-cn_start sig_en=531987e741d8a8719120006407c7ebe8 sig_cn_org=None source=14.1 
   <para>
    The first schema in the search path that exists is the default
    location for creating new objects.  That is the reason that by
    default objects are created in the public schema.  When objects
    are referenced in any other context without schema qualification
    (table modification, data modification, or query commands) the
    search path is traversed until a matching object is found.
    Therefore, in the default configuration, any unqualified access
    again can only refer to the public schema.
   </para>
________________________________________________________-->
   <para>
    搜索路径中的第一个模式是创建新对象的默认存储位置。这就是默认情况下对象会被创建在公共模式中的原因。当对象在任何其他没有模式限定的环境中被引用（表修改、数据修改或查询命令）时，搜索路径将被遍历直到一个匹配对象被找到。因此，在默认配置中，任何非限定访问将只能指向公共模式。
   </para>
<!-- pgdoc-cn_end sig_en=531987e741d8a8719120006407c7ebe8 -->

<!-- pgdoc-cn_start sig_en=744ee7e823e4943e59c011bdee4d9093 sig_cn_org=None source=14.1 
   <para>
    To put our new schema in the path, we use:
<programlisting>
SET search_path TO myschema,public;
</programlisting>
    (We omit the <literal>$user</literal> here because we have no
    immediate need for it.)  And then we can access the table without
    schema qualification:
<programlisting>
DROP TABLE mytable;
</programlisting>
    Also, since <literal>myschema</literal> is the first element in
    the path, new objects would by default be created in it.
   </para>
________________________________________________________-->
   <para>
    要把新模式放在搜索路径中，我们可以使用：
<programlisting>
SET search_path TO myschema,public;
</programlisting>
    （我们在这里省略了<literal>$user</literal>，因为我们并不立即需要它）。然后我们可以删除该表而无需使用模式进行限定：
<programlisting>
DROP TABLE mytable;
</programlisting>
    同样，由于<literal>myschema</literal>是路径中的第一个元素，新对象会被默认创建在其中。
   </para>
<!-- pgdoc-cn_end sig_en=744ee7e823e4943e59c011bdee4d9093 -->

<!-- pgdoc-cn_start sig_en=ed8b4504f3f85517edb74d095e64fdc1 sig_cn_org=None source=14.1 
   <para>
    We could also have written:
<programlisting>
SET search_path TO myschema;
</programlisting>
    Then we no longer have access to the public schema without
    explicit qualification.  There is nothing special about the public
    schema except that it exists by default.  It can be dropped, too.
   </para>
________________________________________________________-->
   <para>
    我们也可以这样写：
<programlisting>
SET search_path TO myschema;
</programlisting>
    这样我们在没有显式限定时再也不必去访问公共模式了。公共模式没有什么特别之处，它只是默认存在而已，它也可以被删除。
   </para>
<!-- pgdoc-cn_end sig_en=ed8b4504f3f85517edb74d095e64fdc1 -->

<!-- pgdoc-cn_start sig_en=270e544c8148e6f3e7b78e11ceb15961 sig_cn_org=None source=14.1 
   <para>
    See also <xref linkend="functions-info"/> for other ways to manipulate
    the schema search path.
   </para>
________________________________________________________-->
   <para>
    其他操作模式搜索路径的方法请见<xref linkend="functions-info"/>。
   </para>
<!-- pgdoc-cn_end sig_en=270e544c8148e6f3e7b78e11ceb15961 -->

<!-- pgdoc-cn_start sig_en=6089d8da2391e4295b7538a18fec75d8 sig_cn_org=None source=14.1 
   <para>
    The search path works in the same way for data type names, function names,
    and operator names as it does for table names.  Data type and function
    names can be qualified in exactly the same way as table names.  If you
    need to write a qualified operator name in an expression, there is a
    special provision: you must write
<synopsis>
<literal>OPERATOR(</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>operator</replaceable><literal>)</literal>
</synopsis>
    This is needed to avoid syntactic ambiguity.  An example is:
<programlisting>
SELECT 3 OPERATOR(pg_catalog.+) 4;
</programlisting>
    In practice one usually relies on the search path for operators,
    so as not to have to write anything so ugly as that.
   </para>
________________________________________________________-->
   <para>
    搜索路径对于数据类型名称、函数名称和操作符名称的作用与表名一样。数据类型和函数名称可以使用和表名完全相同的限定方式。如果我们需要在一个表达式中写一个限定的操作符名称，我们必须写成一种特殊的形式：
<synopsis>
<literal>OPERATOR(</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>operator</replaceable><literal>)</literal>
</synopsis>
    这是为了避免句法歧义。例如：
<programlisting>
SELECT 3 OPERATOR(pg_catalog.+) 4;
</programlisting>
    实际上我们通常都会依赖于搜索路径来查找操作符，因此没有必要去写如此“丑陋”的东西。
   </para>
<!-- pgdoc-cn_end sig_en=6089d8da2391e4295b7538a18fec75d8 -->
  </sect2>

  <sect2 id="ddl-schemas-priv">
<!-- pgdoc-cn_start sig_en=44e6f316c02192c5bbdbfa3d7ed566d3 sig_cn_org=None source=14.1 
   <title>Schemas and Privileges</title>
________________________________________________________-->
   <title>模式和权限</title>
<!-- pgdoc-cn_end sig_en=44e6f316c02192c5bbdbfa3d7ed566d3 -->

<!-- pgdoc-cn_start sig_en=2f4ed7f0cd3b2b9407f95418012dafb3 sig_cn_org=None source=14.1 
   <indexterm zone="ddl-schemas-priv">
    <primary>privilege</primary>
    <secondary sortas="schemas">for schemas</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="ddl-schemas-priv">
    <primary>privilege</primary>
    <secondary sortas="schemas">for schemas</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=2f4ed7f0cd3b2b9407f95418012dafb3 -->

<!-- pgdoc-cn_start sig_en=dc2a33aa1a5aa0347a5aa5e9e03f4007 sig_cn_org=c0ae971b140800b30b2973e2dd51a7f8 source=15.7 
   <para>
    By default, users cannot access any objects in schemas they do not
    own.  To allow that, the owner of the schema must grant the
    <literal>USAGE</literal> privilege on the schema.  By default, everyone
    has that privilege on the schema <literal>public</literal>.  To allow
    users to make use of the objects in a schema, additional privileges might
    need to be granted, as appropriate for the object.
   </para>
________________________________________________________-->
   <para>
    默认情况下，用户无法访问他们不拥有的模式中的任何对象。要允许这样做，模式的所有者必须授予该模式上的<literal>USAGE</literal>权限。
    默认情况下，每个人在模式<literal>public</literal>上都有该权限。要允许用户使用模式中的对象，可能需要授予其他权限，适用于该对象。
</para>
<!-- pgdoc-cn_end sig_en=dc2a33aa1a5aa0347a5aa5e9e03f4007 -->

<!-- pgdoc-cn_start sig_en=1a5563313d9a7726c8281ad6a4a0e16b sig_cn_org=5bb5267b7781a4560d1e2796ea083894 source=15.7 
   <para>
    A user can also be allowed to create objects in someone else's schema.  To
    allow that, the <literal>CREATE</literal> privilege on the schema needs to
    be granted.  In databases upgraded from
    <productname>PostgreSQL</productname> 14 or earlier, everyone has that
    privilege on the schema <literal>public</literal>.
    Some <link linkend="ddl-schemas-patterns">usage patterns</link> call for
    revoking that privilege:
<programlisting>
REVOKE CREATE ON SCHEMA public FROM PUBLIC;
</programlisting>
    (The first <quote>public</quote> is the schema, the second
    <quote>public</quote> means <quote>every user</quote>.  In the
    first sense it is an identifier, in the second sense it is a
    key word, hence the different capitalization; recall the
    guidelines from <xref linkend="sql-syntax-identifiers"/>.)
   </para>
________________________________________________________-->
   <para>
    用户还可以被允许在别人的模式中创建对象。为了允许这样做，需要授予模式上的<literal>CREATE</literal>权限。
    在从<productname>PostgreSQL</productname> 14或更早版本升级的数据库中，每个人都有对模式<literal>public</literal>的权限。
    一些<link linkend="ddl-schemas-patterns">使用模式</link>需要撤销该权限：
<programlisting>
REVOKE CREATE ON SCHEMA public FROM PUBLIC;
</programlisting>
    （第一个<quote>public</quote>是模式，第二个<quote>public</quote>表示<quote>每个用户</quote>。
    在第一个意义上，它是一个标识符，在第二个意义上，它是一个关键字，因此使用了不同的大写形式；
    请回顾<xref linkend="sql-syntax-identifiers"/>中的指南。）
   </para>
<!-- pgdoc-cn_end sig_en=1a5563313d9a7726c8281ad6a4a0e16b -->
  </sect2>

  <sect2 id="ddl-schemas-catalog">
<!-- pgdoc-cn_start sig_en=a0ff71857081ad51a067a01fcd1e5014 sig_cn_org=None source=14.1 
   <title>The System Catalog Schema</title>
________________________________________________________-->
   <title>系统目录模式</title>
<!-- pgdoc-cn_end sig_en=a0ff71857081ad51a067a01fcd1e5014 -->

<!-- pgdoc-cn_start sig_en=c3aee5f054fe4ae1086cf1110b920182 sig_cn_org=None source=14.1 
   <indexterm zone="ddl-schemas-catalog">
    <primary>system catalog</primary>
    <secondary>schema</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="ddl-schemas-catalog">
    <primary>system catalog</primary>
    <secondary>schema</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=c3aee5f054fe4ae1086cf1110b920182 -->

<!-- pgdoc-cn_start sig_en=f0d878133ee6111cc62ecd6fc3bf876e sig_cn_org=None source=14.1 
   <para>
    In addition to <literal>public</literal> and user-created schemas, each
    database contains a <literal>pg_catalog</literal> schema, which contains
    the system tables and all the built-in data types, functions, and
    operators.  <literal>pg_catalog</literal> is always effectively part of
    the search path.  If it is not named explicitly in the path then
    it is implicitly searched <emphasis>before</emphasis> searching the path's
    schemas.  This ensures that built-in names will always be
    findable.  However, you can explicitly place
    <literal>pg_catalog</literal> at the end of your search path if you
    prefer to have user-defined names override built-in names.
   </para>
________________________________________________________-->
   <para>
    除<literal>public</literal>和用户创建的模式之外，每一个数据库还包括一个<literal>pg_catalog</literal>模式，它包含了系统表和所有内建的数据类型、函数以及操作符。<literal>pg_catalog</literal>总是搜索路径的一个有效部分。如果没有在路径中显式地包括该模式，它将在路径中的模式<emphasis>之前</emphasis>被搜索。这保证了内建的名称总是能被找到。然而，如果我们希望用用户定义的名称重载内建的名称，可以显式的将<literal>pg_catalog</literal>放在搜索路径的末尾。
   </para>
<!-- pgdoc-cn_end sig_en=f0d878133ee6111cc62ecd6fc3bf876e -->

<!-- pgdoc-cn_start sig_en=8af9944367b2ad615105fc7271000ebf sig_cn_org=None source=14.1 
   <para>
    Since system table names begin with <literal>pg_</literal>, it is best to
    avoid such names to ensure that you won't suffer a conflict if some
    future version defines a system table named the same as your
    table.  (With the default search path, an unqualified reference to
    your table name would then be resolved as the system table instead.)
    System tables will continue to follow the convention of having
    names beginning with <literal>pg_</literal>, so that they will not
    conflict with unqualified user-table names so long as users avoid
    the <literal>pg_</literal> prefix.
   </para>
________________________________________________________-->
   <para>
    由于系统表名称以<literal>pg_</literal>开头，最好还是避免使用这样的名称，以避免和未来新版本中可能出现的系统表名发生冲突。系统表将继续采用以<literal>pg_</literal>开头的方式，这样它们不会 与非限制的用户表名称冲突。
   </para>
<!-- pgdoc-cn_end sig_en=8af9944367b2ad615105fc7271000ebf -->
  </sect2>

  <sect2 id="ddl-schemas-patterns">
<!-- pgdoc-cn_start sig_en=5b3d40d665c9aa989e26edf5cc8ca34c sig_cn_org=None source=14.1 
   <title>Usage Patterns</title>
________________________________________________________-->
   <title>使用方式</title>
<!-- pgdoc-cn_end sig_en=5b3d40d665c9aa989e26edf5cc8ca34c -->

<!-- pgdoc-cn_start sig_en=958dc1d627c2751798e36692dba00143 sig_cn_org=f193cedc650e24591b6a1fd259539cb7 source=15.7 
   <para>
    Schemas can be used to organize your data in many ways.
    A <firstterm>secure schema usage pattern</firstterm> prevents untrusted
    users from changing the behavior of other users' queries.  When a database
    does not use a secure schema usage pattern, users wishing to securely
    query that database would take protective action at the beginning of each
    session.  Specifically, they would begin each session by
    setting <varname>search_path</varname> to the empty string or otherwise
    removing schemas that are writable by non-superusers
    from <varname>search_path</varname>.  There are a few usage patterns
    easily supported by the default configuration:
    <itemizedlist>
     <listitem>
________________________________________________________-->
   <para>
    模式可用于许多方式来组织数据。
    <firstterm>安全模式使用模式</firstterm>可以防止不受信任的用户更改其他用户查询的行为。
    当数据库不使用安全模式使用模式时，希望安全查询该数据库的用户会在每个会话开始时采取保护措施。
    具体来说，他们会通过将<varname>search_path</varname>设置为空字符串或以其他方式从<varname>search_path</varname>中删除可被非超级用户写入的模式来开始每个会话。
    有一些使用模式在默认配置下很容易支持：
    <itemizedlist>
     <listitem>
<!-- pgdoc-cn_end sig_en=958dc1d627c2751798e36692dba00143 -->
<!-- pgdoc-cn_start sig_en=7781b0f43eb5a72f94208729fb8a26d6 sig_cn_org=75113c3261f142c6a575e8bd6fb0e72b source=15.7 
      <para>
       Constrain ordinary users to user-private schemas.
       To implement this pattern, first ensure that no schemas have
       public <literal>CREATE</literal> privileges.  Then, for every user
       needing to create non-temporary objects, create a schema with the
       same name as that user, for example
       <literal>CREATE SCHEMA alice AUTHORIZATION alice</literal>.
       (Recall that the default search path starts
       with <literal>$user</literal>, which resolves to the user
       name. Therefore, if each user has a separate schema, they access
       their own schemas by default.)  This pattern is a secure schema
       usage pattern unless an untrusted user is the database owner or
       holds the <literal>CREATEROLE</literal> privilege, in which case no
       secure schema usage pattern exists.
      </para>
________________________________________________________-->
      <para>
       将普通用户限制在用户私有模式中。
       要实现这种模式，首先确保没有模式具有公共<literal>CREATE</literal>权限。然后，对于每个需要创建非临时对象的用户，
       创建一个与该用户同名的模式，例如<literal>CREATE SCHEMA alice AUTHORIZATION alice</literal>。
       （请记住，默认搜索路径以<literal>$user</literal>开头，该路径解析为用户名。因此，如果每个用户都有一个单独的模式，
       则默认情况下他们访问自己的模式。）除非不受信任的用户是数据库所有者或持有<literal>CREATEROLE</literal>权限，
       否则此模式是安全的模式使用模式。
      </para>
<!-- pgdoc-cn_end sig_en=7781b0f43eb5a72f94208729fb8a26d6 -->
      <!-- A database owner can attack the database's users via "CREATE SCHEMA
           trojan; ALTER DATABASE $mydb SET search_path = trojan, public;".  A
           CREATEROLE user can issue "GRANT $dbowner TO $me" and then use the
           database owner attack. -->

<!-- pgdoc-cn_start sig_en=81a01e86abb2f53fa8215e7f4746b3af sig_cn_org=b657430f9e2c7a79983742779f31e3d6 source=15.7 
      <para>
       In <productname>PostgreSQL</productname> 15 and later, the default
       configuration supports this usage pattern.  In prior versions, or
       when using a database that has been upgraded from a prior version,
       you will need to remove the public <literal>CREATE</literal>
       privilege from the <literal>public</literal> schema (issue
       <literal>REVOKE CREATE ON SCHEMA public FROM PUBLIC</literal>).
       Then consider auditing the <literal>public</literal> schema for
       objects named like objects in schema <literal>pg_catalog</literal>.
      </para>
________________________________________________________-->
      <para>
       在<productname>PostgreSQL</productname> 15及更高版本中，默认配置支持此使用模式。
       在早期版本中，或者在使用从早期版本升级的数据库时，您需要从<literal>public</literal>模式中移除公共<literal>CREATE</literal>权限（执行<literal>REVOKE CREATE ON SCHEMA public FROM PUBLIC</literal>）。
       然后考虑对<literal>public</literal>模式进行审计，查找与<literal>pg_catalog</literal>模式中对象名称相似的对象。
      </para>
<!-- pgdoc-cn_end sig_en=81a01e86abb2f53fa8215e7f4746b3af -->
      <!-- "DROP SCHEMA public" is inferior to this REVOKE, because pg_dump
           doesn't preserve that DROP. -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=50f1d490816aa7c30029e7a928f36570 sig_cn_org=5e2befdd17c3bcabcd347e7529397de5 source=15.7 
      <para>
       Remove the public schema from the default search path, by modifying
       <link linkend="config-setting-configuration-file"><filename>postgresql.conf</filename></link>
       or by issuing <literal>ALTER ROLE ALL SET search_path =
       "$user"</literal>.  Then, grant privileges to create in the public
       schema.  Only qualified names will choose public schema objects.  While
       qualified table references are fine, calls to functions in the public
       schema <link linkend="typeconv-func">will be unsafe or
       unreliable</link>.  If you create functions or extensions in the public
       schema, use the first pattern instead.  Otherwise, like the first
       pattern, this is secure unless an untrusted user is the database owner
       or holds the <literal>CREATEROLE</literal> privilege.
      </para>
________________________________________________________-->
      <para>
       通过修改<link linkend="config-setting-configuration-file"><filename>postgresql.conf</filename></link>或通过执行<literal>ALTER ROLE ALL SET search_path =
       "$user"</literal>，将公共模式从默认搜索路径中移除。然后，在公共模式中授予权限以创建。只有合格的名称才会选择公共模式对象。虽然合格的表引用是可以的，但对公共模式中函数的调用<link linkend="typeconv-func">可能是不安全或不可靠</link>。如果在公共模式中创建函数或扩展，请使用第一种模式。否则，像第一种模式一样，除非不受信任的用户是数据库所有者或持有<literal>CREATEROLE</literal>权限，否则是安全的。
      </para>
<!-- pgdoc-cn_end sig_en=50f1d490816aa7c30029e7a928f36570 -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=8d14f8ed4706f9bf6e0c4624d89e2875 sig_cn_org=7aeb58f2678d51f6228e8737f7b23116 source=15.7 
      <para>
       Keep the default search path, and grant privileges to create in the
       public schema.  All users access the public schema implicitly.  This
       simulates the situation where schemas are not available at all, giving
       a smooth transition from the non-schema-aware world.  However, this is
       never a secure pattern.  It is acceptable only when the database has a
       single user or a few mutually-trusting users.  In databases upgraded
       from <productname>PostgreSQL</productname> 14 or earlier, this is the
       default.
      </para>
________________________________________________________-->
      <para>
       保持默认搜索路径，并授予在公共模式中创建的权限。所有用户隐式访问公共模式。这模拟了模式根本不可用的情况，从不具备模式意识的世界平稳过渡。然而，这永远不是一个安全的模式。只有在数据库具有单个用户或少数相互信任的用户时才可接受。在从<productname>PostgreSQL</productname> 14或更早版本升级的数据库中，这是默认设置。
      </para>
<!-- pgdoc-cn_end sig_en=8d14f8ed4706f9bf6e0c4624d89e2875 -->
     </listitem>
    </itemizedlist>
   </para>

<!-- pgdoc-cn_start sig_en=ecf881622d15c8108666734609bfbd78 sig_cn_org=None source=14.1 
   <para>
    For any pattern, to install shared applications (tables to be used by
    everyone, additional functions provided by third parties, etc.), put them
    into separate schemas.  Remember to grant appropriate privileges to allow
    the other users to access them.  Users can then refer to these additional
    objects by qualifying the names with a schema name, or they can put the
    additional schemas into their search path, as they choose.
   </para>
________________________________________________________-->
   <para>
    对于任何一种模式，如果要安装共享的应用（所有人都要用的表、第三方提供的额外函数，等等），可把它们放在单独的模式中。记得授予适当的权限以允许其他用户访问它们。然后用户可以通过以模式名限定名称的方式来引用这些额外的对象，或者他们可以把额外的模式放在自己的搜索路径中。
   </para>
<!-- pgdoc-cn_end sig_en=ecf881622d15c8108666734609bfbd78 -->
  </sect2>

  <sect2 id="ddl-schemas-portability">
<!-- pgdoc-cn_start sig_en=5d8eb287ae41e5a0ca5dc99a782f9949 sig_cn_org=None source=14.1 
   <title>Portability</title>
________________________________________________________-->
   <title>可移植性</title>
<!-- pgdoc-cn_end sig_en=5d8eb287ae41e5a0ca5dc99a782f9949 -->

<!-- pgdoc-cn_start sig_en=b08504f786590d9f05bb4b798547554e sig_cn_org=None source=14.1 
   <para>
    In the SQL standard, the notion of objects in the same schema
    being owned by different users does not exist.  Moreover, some
    implementations do not allow you to create schemas that have a
    different name than their owner.  In fact, the concepts of schema
    and user are nearly equivalent in a database system that
    implements only the basic schema support specified in the
    standard.  Therefore, many users consider qualified names to
    really consist of
    <literal><replaceable>user_name</replaceable>.<replaceable>table_name</replaceable></literal>.
    This is how <productname>PostgreSQL</productname> will effectively
    behave if you create a per-user schema for every user.
   </para>
________________________________________________________-->
   <para>
    在SQL标准中，不同用户拥有同一个模式中的对象的概念是不存在的。此外，某些实现不允许创建与拥有者名称不同名的模式。事实上，在那些仅实现了标准中基本模式支持的数据库中，模式和用户的概念是等同的。因此，很多用户认为限定名称实际上是由<literal><replaceable>user_name</replaceable>.<replaceable>table_name</replaceable></literal>组成的。如果我们为每一个用户都创建了一个模式，<productname>PostgreSQL</productname>实际也是这样认为的。
   </para>
<!-- pgdoc-cn_end sig_en=b08504f786590d9f05bb4b798547554e -->

<!-- pgdoc-cn_start sig_en=772b17fbc81b4129ca4f859716146f86 sig_cn_org=None source=14.1 
   <para>
    Also, there is no concept of a <literal>public</literal> schema in the
    SQL standard.  For maximum conformance to the standard, you should
    not use the <literal>public</literal> schema.
   </para>
________________________________________________________-->
   <para>
    同样，在SQL标准中也没有<literal>public</literal>模式的概念。为了最大限度的与标准一致，我们不应使用（甚至是删除）<literal>public</literal>模式。
   </para>
<!-- pgdoc-cn_end sig_en=772b17fbc81b4129ca4f859716146f86 -->

<!-- pgdoc-cn_start sig_en=5cdcae0abc4ba74117a9c0331ee5299f sig_cn_org=None source=14.1 
   <para>
    Of course, some SQL database systems might not implement schemas
    at all, or provide namespace support by allowing (possibly
    limited) cross-database access.  If you need to work with those
    systems, then maximum portability would be achieved by not using
    schemas at all.
   </para>
________________________________________________________-->
   <para>
    当然，某些SQL数据库系统可能根本没有实现模式，或者提供（很可能是有限制地）允许跨数据库访问的命名空间。如果需要使用这样的系统，为了获得最好的可移植性，最好不要使用模式。
   </para>
<!-- pgdoc-cn_end sig_en=5cdcae0abc4ba74117a9c0331ee5299f -->
  </sect2>
 </sect1>

 <sect1 id="ddl-inherit">
<!-- pgdoc-cn_start sig_en=402ce8e5e5c53d3b32e1e9b0026d33d1 sig_cn_org=None source=14.1 
  <title>Inheritance</title>
________________________________________________________-->
  <title>继承</title>
<!-- pgdoc-cn_end sig_en=402ce8e5e5c53d3b32e1e9b0026d33d1 -->

<!-- pgdoc-cn_start sig_en=ed916d8e9d521617374ddf157b2a2fd2 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>inheritance</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>inheritance</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=ed916d8e9d521617374ddf157b2a2fd2 -->

<!-- pgdoc-cn_start sig_en=4cea7c03ed2f19789ec640c96ee48be5 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>table</primary>
   <secondary>inheritance</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>table</primary>
   <secondary>inheritance</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=4cea7c03ed2f19789ec640c96ee48be5 -->

<!-- pgdoc-cn_start sig_en=7530ead6fb6898183a7ffe78a4a71828 sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> implements table inheritance,
   which can be a useful tool for database designers.  (SQL:1999 and
   later define a type inheritance feature, which differs in many
   respects from the features described here.)
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>实现了表继承，这对数据库设计者来说是一种有用的工具（SQL:1999及其后的版本定义了一种类型继承特性，但和这里介绍的继承有很大的不同）。
  </para>
<!-- pgdoc-cn_end sig_en=7530ead6fb6898183a7ffe78a4a71828 -->

<!-- pgdoc-cn_start sig_en=fcd514513974b2a30bf8fbf3d856f4da sig_cn_org=None source=14.1 
  <para>
   Let's start with an example: suppose we are trying to build a data
   model for cities.  Each state has many cities, but only one
   capital. We want to be able to quickly retrieve the capital city
   for any particular state. This can be done by creating two tables,
   one for state capitals and one for cities that are not
   capitals. However, what happens when we want to ask for data about
   a city, regardless of whether it is a capital or not? The
   inheritance feature can help to resolve this problem. We define the
   <structname>capitals</structname> table so that it inherits from
   <structname>cities</structname>:

<programlisting>
CREATE TABLE cities (
    name            text,
    population      float,
    elevation       int     -&minus; in feet
);

CREATE TABLE capitals (
    state           char(2)
) INHERITS (cities);
</programlisting>

   In this case, the <structname>capitals</structname> table <firstterm>inherits</firstterm>
   all the columns of its parent table, <structname>cities</structname>. State
   capitals also have an extra column, <structfield>state</structfield>, that shows
   their state.
  </para>
________________________________________________________-->
  <para>
   让我们从一个例子开始：假设我们要为城市建立一个数据模型。每一个州有很多城市，但是只有一个首府。我们希望能够快速地检索任何特定州的首府城市。这可以通过创建两个表来实现：一个用于州首府，另一个用于不是首府的城市。然而，当我们想要查看一个城市的数据（不管它是不是一个首府）时会发生什么？继承特性将有助于解决这个问题。我们可以将<structname>capitals</structname>表定义为继承自<structname>cities</structname>表：

<programlisting>
CREATE TABLE cities (
    name            text,
    population      float,
    elevation       int     -- in feet
);

CREATE TABLE capitals (
    state           char(2)
) INHERITS (cities);
</programlisting>

   在这种情况下，<structname>capitals</structname>表<firstterm>继承</firstterm>了它的父表<structname>cities</structname>的所有列。州首府还有一个额外的列<structfield>state</structfield>用来表示它所属的州。
  </para>
<!-- pgdoc-cn_end sig_en=fcd514513974b2a30bf8fbf3d856f4da -->

<!-- pgdoc-cn_start sig_en=6a11b5f69980030050dd370e08750af6 sig_cn_org=None source=14.1 
  <para>
   In <productname>PostgreSQL</productname>, a table can inherit from
   zero or more other tables, and a query can reference either all
   rows of a table or all rows of a table plus all of its descendant tables.
   The latter behavior is the default.
   For example, the following query finds the names of all cities,
   including state capitals, that are located at an elevation over
   500 feet:

<programlisting>
SELECT name, elevation
    FROM cities
    WHERE elevation &gt; 500;
</programlisting>

   Given the sample data from the <productname>PostgreSQL</productname>
   tutorial (see <xref linkend="tutorial-sql-intro"/>), this returns:

<programlisting>
   name    | elevation
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-
 Las Vegas |      2174
 Mariposa  |      1953
 Madison   |       845
</programlisting>
  </para>
________________________________________________________-->
  <para>
   在<productname>PostgreSQL</productname>中，一个表可以从0个或者多个其他表继承，而对一个表的查询则可以引用一个表的所有行或者该表的所有行加上它所有的后代表。
   默认情况是后一种行为。例如，下面的查询将查找所有高度高于500尺的城市的名称，包括州首府：

<programlisting>
SELECT name, elevation
    FROM cities
    WHERE elevation &gt; 500;
</programlisting>

   对于来自<productname>PostgreSQL</productname>教程（见<xref linkend="tutorial-sql-intro"/>）的例子数据，它将返回：

<programlisting>
   name    | elevation
-----------+-----------
 Las Vegas |      2174
 Mariposa  |      1953
 Madison   |       845
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=6a11b5f69980030050dd370e08750af6 -->

<!-- pgdoc-cn_start sig_en=934a637a9c470177c9029339c67accf8 sig_cn_org=None source=14.1 
  <para>
   On the other hand, the following query finds all the cities that
   are not state capitals and are situated at an elevation over 500 feet:

<programlisting>
SELECT name, elevation
    FROM ONLY cities
    WHERE elevation &gt; 500;

   name    | elevation
-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-
 Las Vegas |      2174
 Mariposa  |      1953
</programlisting>
  </para>
________________________________________________________-->
  <para>
   在另一方面，下面的查询将找到高度超过500尺且不是州首府的所有城市：

<programlisting>
SELECT name, elevation
    FROM ONLY cities
    WHERE elevation &gt; 500;

   name    | elevation
-----------+-----------
 Las Vegas |      2174
 Mariposa  |      1953
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=934a637a9c470177c9029339c67accf8 -->

<!-- pgdoc-cn_start sig_en=bff3b6b2a09ee42760b66178ad77b613 sig_cn_org=None source=14.1 
  <para>
   Here the <literal>ONLY</literal> keyword indicates that the query
   should apply only to <structname>cities</structname>, and not any tables
   below <structname>cities</structname> in the inheritance hierarchy.  Many
   of the commands that we have already discussed &mdash;
   <command>SELECT</command>, <command>UPDATE</command> and
   <command>DELETE</command> &mdash; support the
   <literal>ONLY</literal> keyword.
  </para>
________________________________________________________-->
  <para>
   这里的<literal>ONLY</literal>关键词指示查询只被应用于<structname>cities</structname>上，而其他在继承层次中位于<structname>cities</structname>之下的其他表都不会被该查询涉及。很多我们已经讨论过的命令（如<command>SELECT</command>、<command>UPDATE</command>和<command>DELETE</command>）都支持<literal>ONLY</literal>关键词。
  </para>
<!-- pgdoc-cn_end sig_en=bff3b6b2a09ee42760b66178ad77b613 -->

<!-- pgdoc-cn_start sig_en=0d6e5e0e540da3c262ae1a08dcc651a1 sig_cn_org=None source=14.1 
  <para>
   You can also write the table name with a trailing <literal>*</literal>
   to explicitly specify that descendant tables are included:

<programlisting>
SELECT name, elevation
    FROM cities*
    WHERE elevation &gt; 500;
</programlisting>

   Writing <literal>*</literal> is not necessary, since this behavior is always
   the default.  However, this syntax is still supported for
   compatibility with older releases where the default could be changed.
  </para>
________________________________________________________-->
  <para>
   我们也可以在表名后写上一个<literal>*</literal>来显式地将后代表包括在查询范围内：

<programlisting>
SELECT name, elevation
    FROM cities*
    WHERE elevation &gt; 500;
</programlisting>

   写<literal>*</literal>不是必需的，因为这种行为总是默认的。不过，为了兼容可以修改默认值的较老版本，现在仍然支持这种语法。
  </para>
<!-- pgdoc-cn_end sig_en=0d6e5e0e540da3c262ae1a08dcc651a1 -->

<!-- pgdoc-cn_start sig_en=6de26bfda3066043e51936d293fecfe9 sig_cn_org=None source=14.1 
  <para>
   In some cases you might wish to know which table a particular row
   originated from. There is a system column called
   <structfield>tableoid</structfield> in each table which can tell you the
   originating table:

<programlisting>
SELECT c.tableoid, c.name, c.elevation
FROM cities c
WHERE c.elevation &gt; 500;
</programlisting>

   which returns:

<programlisting>
 tableoid |   name    | elevation
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-
   139793 | Las Vegas |      2174
   139793 | Mariposa  |      1953
   139798 | Madison   |       845
</programlisting>

   (If you try to reproduce this example, you will probably get
   different numeric OIDs.)  By doing a join with
   <structname>pg_class</structname> you can see the actual table names:

<programlisting>
SELECT p.relname, c.name, c.elevation
FROM cities c, pg_class p
WHERE c.elevation &gt; 500 AND c.tableoid = p.oid;
</programlisting>

   which returns:

<programlisting>
 relname  |   name    | elevation
-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-
 cities   | Las Vegas |      2174
 cities   | Mariposa  |      1953
 capitals | Madison   |       845
</programlisting>
  </para>
________________________________________________________-->
  <para>
   在某些情况下，我们可能希望知道一个特定行来自于哪个表。每个表中的系统列<structfield>tableoid</structfield>可以告诉我们行来自于哪个表：

<programlisting>
SELECT c.tableoid, c.name, c.elevation
FROM cities c
WHERE c.elevation &gt; 500;
</programlisting>

   将会返回：

<programlisting>
 tableoid |   name    | elevation
----------+-----------+-----------
   139793 | Las Vegas |      2174
   139793 | Mariposa  |      1953
   139798 | Madison   |       845
</programlisting>

   （如果重新生成这个结果，可能会得到不同的OID数字。）通过与<structname>pg_class</structname>进行连接可以看到实际的表名：

<programlisting>
SELECT p.relname, c.name, c.elevation
FROM cities c, pg_class p
WHERE c.elevation &gt; 500 AND c.tableoid = p.oid;
</programlisting>

   将会返回：

<programlisting>
 relname  |   name    | elevation
----------+-----------+-----------
 cities   | Las Vegas |      2174
 cities   | Mariposa  |      1953
 capitals | Madison   |       845
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=6de26bfda3066043e51936d293fecfe9 -->

<!-- pgdoc-cn_start sig_en=723a5e516a816a63c1a3e7bf4e95a57a sig_cn_org=None source=14.1 
  <para>
   Another way to get the same effect is to use the <type>regclass</type>
   alias type, which will print the table OID symbolically:

<programlisting>
SELECT c.tableoid::regclass, c.name, c.elevation
FROM cities c
WHERE c.elevation &gt; 500;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   另一种得到同样效果的方法是使用<type>regclass</type>别名类型，
   它将象征性地打印出表的 OID：

<programlisting>
SELECT c.tableoid::regclass, c.name, c.elevation
FROM cities c
WHERE c.elevation &gt; 500;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=723a5e516a816a63c1a3e7bf4e95a57a -->

<!-- pgdoc-cn_start sig_en=37c589482b04b3a53de7830599939db1 sig_cn_org=None source=14.1 
  <para>
   Inheritance does not automatically propagate data from
   <command>INSERT</command> or <command>COPY</command> commands to
   other tables in the inheritance hierarchy. In our example, the
   following <command>INSERT</command> statement will fail:
<programlisting>
INSERT INTO cities (name, population, elevation, state)
VALUES ('Albany', NULL, NULL, 'NY');
</programlisting>
   We might hope that the data would somehow be routed to the
   <structname>capitals</structname> table, but this does not happen:
   <command>INSERT</command> always inserts into exactly the table
   specified.  In some cases it is possible to redirect the insertion
   using a rule (see <xref linkend="rules"/>).  However that does not
   help for the above case because the <structname>cities</structname> table
   does not contain the column <structfield>state</structfield>, and so the
   command will be rejected before the rule can be applied.
  </para>
________________________________________________________-->
  <para>
   继承不会自动地将来自<command>INSERT</command>或<command>COPY</command>命令的数据传播到继承层次中的其他表中。在我们的例子中，下面的<command>INSERT</command>语句将会失败：
<programlisting>
INSERT INTO cities (name, population, elevation, state)
VALUES ('Albany', NULL, NULL, 'NY');
</programlisting>
   我们也许希望数据能被以某种方式被引入到<structname>capitals</structname>表中，但是这不会发生：<command>INSERT</command>总是向指定的表中插入。在某些情况下，可以通过使用一个规则（见<xref linkend="rules"/>）来将插入动作重定向。但是这对上面的情况并没有帮助，因为<structname>cities</structname>表根本就不包含<structfield>state</structfield>列，因而这个命令将在触发规则之前就被拒绝。
  </para>
<!-- pgdoc-cn_end sig_en=37c589482b04b3a53de7830599939db1 -->

<!-- pgdoc-cn_start sig_en=42993ff2cc1d6247e2019dcc9365b704 sig_cn_org=None source=14.1 
  <para>
   All check constraints and not-null constraints on a parent table are
   automatically inherited by its children, unless explicitly specified
   otherwise with <literal>NO INHERIT</literal> clauses.  Other types of constraints
   (unique, primary key, and foreign key constraints) are not inherited.
  </para>
________________________________________________________-->
  <para>
   父表上的所有检查约束和非空约束都将自动被它的后代所继承，除非显式地指定了<literal>NO INHERIT</literal>子句。其他类型的约束（唯一、主键和外键约束）则不会被继承。
  </para>
<!-- pgdoc-cn_end sig_en=42993ff2cc1d6247e2019dcc9365b704 -->

<!-- pgdoc-cn_start sig_en=d9fb6ee2009156d12bd0bf8a6bf103b5 sig_cn_org=None source=14.1 
  <para>
   A table can inherit from more than one parent table, in which case it has
   the union of the columns defined by the parent tables.  Any columns
   declared in the child table's definition are added to these.  If the
   same column name appears in multiple parent tables, or in both a parent
   table and the child's definition, then these columns are <quote>merged</quote>
   so that there is only one such column in the child table.  To be merged,
   columns must have the same data types, else an error is raised.
   Inheritable check constraints and not-null constraints are merged in a
   similar fashion.  Thus, for example, a merged column will be marked
   not-null if any one of the column definitions it came from is marked
   not-null.  Check constraints are merged if they have the same name,
   and the merge will fail if their conditions are different.
  </para>
________________________________________________________-->
  <para>
   一个表可以从超过一个的父表继承，在这种情况下它拥有父表们所定义的列的并集。任何定义在子表上的列也会被加入到其中。如果在这个集合中出现重名列，那么这些列将被<quote>合并</quote>，这样在子表中只会有一个这样的列。重名列能被合并的前提是这些列必须具有相同的数据类型，否则会导致错误。可继承的检查约束和非空约束会以类似的方式被合并。例如，如果合并成一个合并列的任一列定义被标记为非空，则该合并列会被标记为非空。如果检查约束的名称相同，则他们会被合并，但如果它们的条件不同则合并会失败。
  </para>
<!-- pgdoc-cn_end sig_en=d9fb6ee2009156d12bd0bf8a6bf103b5 -->

<!-- pgdoc-cn_start sig_en=bfef1a1c10ea6132937cdf4d3c376245 sig_cn_org=None source=14.1 
  <para>
   Table inheritance is typically established when the child table is
   created, using the <literal>INHERITS</literal> clause of the
   <link linkend="sql-createtable"><command>CREATE TABLE</command></link>
   statement.
   Alternatively, a table which is already defined in a compatible way can
   have a new parent relationship added, using the <literal>INHERIT</literal>
   variant of <link linkend="sql-altertable"><command>ALTER TABLE</command></link>.
   To do this the new child table must already include columns with
   the same names and types as the columns of the parent. It must also include
   check constraints with the same names and check expressions as those of the
   parent. Similarly an inheritance link can be removed from a child using the
   <literal>NO INHERIT</literal> variant of <command>ALTER TABLE</command>.
   Dynamically adding and removing inheritance links like this can be useful
   when the inheritance relationship is being used for table
   partitioning (see <xref linkend="ddl-partitioning"/>).
  </para>
________________________________________________________-->
  <para>
   表继承通常是在子表被创建时建立，使用<link linkend="sql-createtable"><command>CREATE TABLE</command></link>语句的<literal>INHERITS</literal>子句。一个已经被创建的表也可以另外一种方式增加一个新的父亲关系，使用<link linkend="sql-altertable"><command>ALTER TABLE</command></link>的<literal>INHERIT</literal>变体。要这样做，新的子表必须已经包括和父表相同名称和数据类型的列。子表还必须包括和父表相同的检查约束和检查表达式。相似地，一个继承链接也可以使用<command>ALTER TABLE</command>的 <literal>NO INHERIT</literal>变体从一个子表中移除。动态增加和移除继承链接可以用于实现表划分（见<xref linkend="ddl-partitioning"/>）。
  </para>
<!-- pgdoc-cn_end sig_en=bfef1a1c10ea6132937cdf4d3c376245 -->

<!-- pgdoc-cn_start sig_en=b844fdaabd3cb26f01b50da2c221ac04 sig_cn_org=None source=14.1 
  <para>
   One convenient way to create a compatible table that will later be made
   a new child is to use the <literal>LIKE</literal> clause in <command>CREATE
   TABLE</command>. This creates a new table with the same columns as
   the source table. If there are any <literal>CHECK</literal>
   constraints defined on the source table, the <literal>INCLUDING
   CONSTRAINTS</literal> option to <literal>LIKE</literal> should be
   specified, as the new child must have constraints matching the parent
   to be considered compatible.
  </para>
________________________________________________________-->
  <para>
   一种创建一个未来将被用做子女的新表的方法是在<command>CREATE
   TABLE</command>中使用<literal>LIKE</literal>子句。这将创建一个和源表具有相同列的新表。如果源表上定义有任何<literal>CHECK</literal>约束，<literal>LIKE</literal>的<literal>INCLUDING CONSTRAINTS</literal>选项可以用来让新的子表也包含和父表相同的约束。
  </para>
<!-- pgdoc-cn_end sig_en=b844fdaabd3cb26f01b50da2c221ac04 -->

<!-- pgdoc-cn_start sig_en=a684f647a49f138ca976cb037cd28fe6 sig_cn_org=None source=14.1 
  <para>
   A parent table cannot be dropped while any of its children remain. Neither
   can columns or check constraints of child tables be dropped or altered
   if they are inherited
   from any parent tables. If you wish to remove a table and all of its
   descendants, one easy way is to drop the parent table with the
   <literal>CASCADE</literal> option (see <xref linkend="ddl-depend"/>).
  </para>
________________________________________________________-->
  <para>
   当有任何一个子表存在时，父表不能被删除。当子表的列或者检查约束继承于父表时，它们也不能被删除或修改。如果希望移除一个表和它的所有后代，一种简单的方法是使用<literal>CASCADE</literal>选项删除父表（见<xref linkend="ddl-depend"/>）。
  </para>
<!-- pgdoc-cn_end sig_en=a684f647a49f138ca976cb037cd28fe6 -->

<!-- pgdoc-cn_start sig_en=156651887b88729c4589f8b5f7929fab sig_cn_org=None source=14.1 
  <para>
   <command>ALTER TABLE</command> will
   propagate any changes in column data definitions and check
   constraints down the inheritance hierarchy.  Again, dropping
   columns that are depended on by other tables is only possible when using
   the <literal>CASCADE</literal> option. <command>ALTER
   TABLE</command> follows the same rules for duplicate column merging
   and rejection that apply during <command>CREATE TABLE</command>.
  </para>
________________________________________________________-->
  <para>
   <command>ALTER TABLE</command>将会把列的数据定义或检查约束上的任何变化沿着继承层次向下传播。同样，删除被其他表依赖的列只能使用<literal>CASCADE</literal>选项。<command>ALTER TABLE</command>对于重名列的合并和拒绝遵循与<command>CREATE TABLE</command>同样的规则。
  </para>
<!-- pgdoc-cn_end sig_en=156651887b88729c4589f8b5f7929fab -->

<!-- pgdoc-cn_start sig_en=caf18c0d0f90a8da010c829c298bb388 sig_cn_org=None source=14.1 
  <para>
   Inherited queries perform access permission checks on the parent table
   only.  Thus, for example, granting <literal>UPDATE</literal> permission on
   the <structname>cities</structname> table implies permission to update rows in
   the <structname>capitals</structname> table as well, when they are
   accessed through <structname>cities</structname>.  This preserves the appearance
   that the data is (also) in the parent table.  But
   the <structname>capitals</structname> table could not be updated directly
   without an additional grant.  In a similar way, the parent table's row
   security policies (see <xref linkend="ddl-rowsecurity"/>) are applied to
   rows coming from child tables during an inherited query.  A child table's
   policies, if any, are applied only when it is the table explicitly named
   in the query; and in that case, any policies attached to its parent(s) are
   ignored.
  </para>
________________________________________________________-->
  <para>
   继承的查询仅在附表上执行访问权限检查。例如，在<structname>cities</structname>表上授予<literal>UPDATE</literal>权限也隐含着通过<structname>cities</structname>访问时在<structname>capitals</structname>表中更新行的权限。
   这保留了数据（也）在父表中的样子。但是如果没有额外的授权，则不能直接更新<structname>capitals</structname>表。
   以类似的方式，父表的行安全性策略（见<xref linkend="ddl-rowsecurity"/>）适用于继承查询期间来自于子表的行。
   只有当子表在查询中被明确提到时，其策略（如果有）才会被应用，在那种情况下，附着在其父表上的任何策略都会被忽略。
  </para>
<!-- pgdoc-cn_end sig_en=caf18c0d0f90a8da010c829c298bb388 -->

<!-- pgdoc-cn_start sig_en=9877168527e97eee7d8ba3459e08ed6f sig_cn_org=None source=14.1 
  <para>
   Foreign tables (see <xref linkend="ddl-foreign-data"/>) can also
   be part of inheritance hierarchies, either as parent or child
   tables, just as regular tables can be.  If a foreign table is part
   of an inheritance hierarchy then any operations not supported by
   the foreign table are not supported on the whole hierarchy either.
  </para>
________________________________________________________-->
  <para>
   外部表（见<xref linkend="ddl-foreign-data"/>）也可以是继承层次
   中的一部分，即可以作为父表也可以作为子表，就像常规表一样。如果
   一个外部表是继承层次的一部分，那么任何不被该外部表支持的操作也
   不被整个层次所支持。
  </para>
<!-- pgdoc-cn_end sig_en=9877168527e97eee7d8ba3459e08ed6f -->

 <sect2 id="ddl-inherit-caveats">
<!-- pgdoc-cn_start sig_en=6aecf7221ae7403619467c1e1a1a629b sig_cn_org=None source=14.1 
  <title>Caveats</title>
________________________________________________________-->
  <title>警告</title>
<!-- pgdoc-cn_end sig_en=6aecf7221ae7403619467c1e1a1a629b -->

<!-- pgdoc-cn_start sig_en=1a2349bb833dd9689afe952cdb28e1b1 sig_cn_org=None source=14.1 
  <para>
   Note that not all SQL commands are able to work on
   inheritance hierarchies.  Commands that are used for data querying,
   data modification, or schema modification
   (e.g., <literal>SELECT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>,
   most variants of <literal>ALTER TABLE</literal>, but
   not <literal>INSERT</literal> or <literal>ALTER TABLE ...
   RENAME</literal>) typically default to including child tables and
   support the <literal>ONLY</literal> notation to exclude them.
   Commands that do database maintenance and tuning
   (e.g., <literal>REINDEX</literal>, <literal>VACUUM</literal>)
   typically only work on individual, physical tables and do not
   support recursing over inheritance hierarchies.  The respective
   behavior of each individual command is documented in its reference
   page (<xref linkend="sql-commands"/>).
  </para>
________________________________________________________-->
  <para>
   注意并非所有的SQL命令都能工作在继承层次上。用于数据查询、数据修改或模式修改（例如<literal>SELECT</literal>、<literal>UPDATE</literal>、<literal>DELETE</literal>、大部分<literal>ALTER TABLE</literal>的变体，但<literal>INSERT</literal>或<literal>ALTER TABLE ... RENAME</literal>不在此列）的命令会默认将子表包含在内并且支持<literal>ONLY</literal>记号来排除子表。负责数据库维护和调整的命令（如<literal>REINDEX</literal>、<literal>VACUUM</literal>）只工作在独立的、物理的表上并且不支持在继承层次上的递归。每个命令相应的行为请参见它们的参考页（<xref linkend="sql-commands"/>）。
  </para>
<!-- pgdoc-cn_end sig_en=1a2349bb833dd9689afe952cdb28e1b1 -->

<!-- pgdoc-cn_start sig_en=c36ffb1359e6f3bb8ba922731602c3a9 sig_cn_org=None source=14.1 
  <para>
   A serious limitation of the inheritance feature is that indexes (including
   unique constraints) and foreign key constraints only apply to single
   tables, not to their inheritance children. This is true on both the
   referencing and referenced sides of a foreign key constraint. Thus,
   in the terms of the above example:

   <itemizedlist>
    <listitem>
     <para>
      If we declared <structname>cities</structname>.<structfield>name</structfield> to be
      <literal>UNIQUE</literal> or a <literal>PRIMARY KEY</literal>, this would not stop the
      <structname>capitals</structname> table from having rows with names duplicating
      rows in <structname>cities</structname>.  And those duplicate rows would by
      default show up in queries from <structname>cities</structname>.  In fact, by
      default <structname>capitals</structname> would have no unique constraint at all,
      and so could contain multiple rows with the same name.
      You could add a unique constraint to <structname>capitals</structname>, but this
      would not prevent duplication compared to <structname>cities</structname>.
     </para>
    </listitem>

    <listitem>
     <para>
      Similarly, if we were to specify that
      <structname>cities</structname>.<structfield>name</structfield> <literal>REFERENCES</literal> some
      other table, this constraint would not automatically propagate to
      <structname>capitals</structname>.  In this case you could work around it by
      manually adding the same <literal>REFERENCES</literal> constraint to
      <structname>capitals</structname>.
     </para>
    </listitem>

    <listitem>
     <para>
      Specifying that another table's column <literal>REFERENCES
      cities(name)</literal> would allow the other table to contain city names, but
      not capital names.  There is no good workaround for this case.
     </para>
    </listitem>
   </itemizedlist>

   Some functionality not implemented for inheritance hierarchies is
   implemented for declarative partitioning.
   Considerable care is needed in deciding whether partitioning with legacy
   inheritance is useful for your application.
  </para>
________________________________________________________-->
  <para>
   继承特性的一个严肃的限制是索引（包括唯一约束）和外键约束值应用在单个表上而非它们的继承子女。在外键约束的引用端和被引用端都是这样。因此，按照上面的例子：

   <itemizedlist>
    <listitem>
     <para>
      如果我们声明<structname>cities</structname>.<structfield>name</structfield>为<literal>UNIQUE</literal>或者<literal>PRIMARY KEY</literal>，这将不会阻止<structname>capitals</structname>表中拥有和<structname>cities</structname>中城市同名的行。而且这些重复的行将会默认显示在<structname>cities</structname>的查询中。事实上，<structname>capitals</structname>在默认情况下是根本不能拥有唯一约束的，并且因此能够包含多个同名的行。我们可以为<structname>capitals</structname>增加一个唯一约束，但这无法阻止相对于<structname>cities</structname>的重复。
     </para>
    </listitem>

    <listitem>
     <para>
      相似地，如果我们指定<structname>cities</structname>.<structfield>name</structfield> <literal>REFERENCES</literal>某个其他表，该约束不会自动地传播到<structname>capitals</structname>。在此种情况下，我们可以变通地在<structname>capitals</structname>上手工创建一个相同的<literal>REFERENCES</literal>约束。
     </para>
    </listitem>

    <listitem>
     <para>
      指定另一个表的列<literal>REFERENCES cities(name)</literal>将允许其他表包含城市名称，但不会包含首府名称。这对于这个例子不是一个好的变通方案。
     </para>
    </listitem>
   </itemizedlist>

   某些未为继承层次结构实现的功能是为声明性分区实现的。在决定使用旧继承进行分区是否对应用程序有用时，需要非常小心。
  </para>
<!-- pgdoc-cn_end sig_en=c36ffb1359e6f3bb8ba922731602c3a9 -->

   </sect2>
  </sect1>

  <sect1 id="ddl-partitioning">
<!-- pgdoc-cn_start sig_en=1f52dc678179805ed429e419ede5cbbb sig_cn_org=None source=14.1 
   <title>Table Partitioning</title>
________________________________________________________-->
   <title>表分区</title>
<!-- pgdoc-cn_end sig_en=1f52dc678179805ed429e419ede5cbbb -->

<!-- pgdoc-cn_start sig_en=29a86bbad38867acb9b8bd1fecf896b5 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>partitioning</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>partitioning</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=29a86bbad38867acb9b8bd1fecf896b5 -->

<!-- pgdoc-cn_start sig_en=55f6fdab91b43b72dff4f8c21a4b314d sig_cn_org=None source=14.1 
   <indexterm>
    <primary>table</primary>
    <secondary>partitioning</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>table</primary>
    <secondary>partitioning</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=55f6fdab91b43b72dff4f8c21a4b314d -->

<!-- pgdoc-cn_start sig_en=e14762f2f6fe7206752ad22c7933eff1 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>partitioned table</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>partitioned table</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=e14762f2f6fe7206752ad22c7933eff1 -->

<!-- pgdoc-cn_start sig_en=b1778e60a110d0d4f0e99d326e8e10da sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> supports basic table
    partitioning. This section describes why and how to implement
    partitioning as part of your database design.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>支持基本的表划分。本小节介绍为何以及怎样把划分实现为数据库设计的一部分。
   </para>
<!-- pgdoc-cn_end sig_en=b1778e60a110d0d4f0e99d326e8e10da -->

   <sect2 id="ddl-partitioning-overview">
<!-- pgdoc-cn_start sig_en=13508788fd8dee2d1f9c928870e99338 sig_cn_org=None source=14.1 
     <title>Overview</title>
________________________________________________________-->
     <title>概述</title>
<!-- pgdoc-cn_end sig_en=13508788fd8dee2d1f9c928870e99338 -->

<!-- pgdoc-cn_start sig_en=b9547bb97daee7d86b379ef0d9b11667 sig_cn_org=None source=14.1 
    <para>
     Partitioning refers to splitting what is logically one large table into
     smaller physical pieces.  Partitioning can provide several benefits:
    <itemizedlist>
     <listitem>
      <para>
       Query performance can be improved dramatically in certain situations,
       particularly when most of the heavily accessed rows of the table are in a
       single partition or a small number of partitions.  Partitioning
       effectively substitutes for the upper tree levels of indexes,
       making it more likely that the heavily-used parts of the indexes
       fit in memory.
      </para>
     </listitem>

     <listitem>
      <para>
       When queries or updates access a large percentage of a single
       partition, performance can be improved by using a
       sequential scan of that partition instead of using an
       index, which would require random-access reads scattered across the
       whole table.
      </para>
     </listitem>

     <listitem>
      <para>
       Bulk loads and deletes can be accomplished by adding or removing
       partitions, if the usage pattern is accounted for in the
       partitioning design.  Dropping an individual partition
       using <command>DROP TABLE</command>, or doing <command>ALTER TABLE
       DETACH PARTITION</command>, is far faster than a bulk
       operation.  These commands also entirely avoid the
       <command>VACUUM</command> overhead caused by a bulk <command>DELETE</command>.
      </para>
     </listitem>

     <listitem>
      <para>
       Seldom-used data can be migrated to cheaper and slower storage media.
      </para>
     </listitem>
    </itemizedlist>

     These benefits will normally be worthwhile only when a table would
     otherwise be very large. The exact point at which a table will
     benefit from partitioning depends on the application, although a
     rule of thumb is that the size of the table should exceed the physical
     memory of the database server.
    </para>
________________________________________________________-->
    <para>
    划分指的是将逻辑上的一个大表分成一些小的物理上的片。划分有很多益处：
    <itemizedlist>
     <listitem>
      <para>
      在某些情况下查询性能能够显著提升，特别是当那些访问压力大的行在一个分区或者少数几个分区时。分区有效地替代了索引的上层树级别，使得索引中被大量使用的部分更有可能适合内存。
      </para>
     </listitem>

     <listitem>
      <para>
       当查询或更新访问单个分区的很大一部分时，可以通过使用该分区的顺序扫描来提高性能，而不是使用索引，这将需要分散在整个表中的随机访问读取。
      </para>
     </listitem>

     <listitem>
      <para>
       如果分区设计中考虑了使用模式，则可以通过添加或删除分区来完成批量加载和删除。使用<command>DROP TABLE</command>删除单个分区，或执行<command>ALTER TABLE     DETACH PARTITION</command>操作，比批量操作快得多。这些命令还完全避免了批量<command>DELETE</command>所导致的<command>VACUUM</command>开销。
      </para>
     </listitem>

     <listitem>
      <para>
      很少使用的数据可以被迁移到便宜且较慢的存储介质上。
      </para>
     </listitem>
    </itemizedlist>

    当一个表非常大时，划分所带来的好处是非常值得的。一个表何种情况下会从划分获益取决于应用，一个经验法则是当表的尺寸超过了数据库服务器物理内存时，划分会为表带来好处。
    </para>
<!-- pgdoc-cn_end sig_en=b9547bb97daee7d86b379ef0d9b11667 -->

<!-- pgdoc-cn_start sig_en=496fa48f3bb6e0c71595ab3a6194e5b5 sig_cn_org=None source=14.1 
    <para>
     <productname>PostgreSQL</productname> offers built-in support for the
     following forms of partitioning:

     <variablelist>
      <varlistentry>
       <term>Range Partitioning</term>

       <listitem>
        <para>
         The table is partitioned into <quote>ranges</quote> defined
         by a key column or set of columns, with no overlap between
         the ranges of values assigned to different partitions.  For
         example, one might partition by date ranges, or by ranges of
         identifiers for particular business objects.
         Each range's bounds are understood as being inclusive at the
         lower end and exclusive at the upper end.  For example, if one
         partition's range is from <literal>1</literal>
         to <literal>10</literal>, and the next one's range is
         from <literal>10</literal> to <literal>20</literal>, then
         value <literal>10</literal> belongs to the second partition not
         the first.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>List Partitioning</term>

       <listitem>
        <para>
         The table is partitioned by explicitly listing which key value(s)
         appear in each partition.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>Hash Partitioning</term>

       <listitem>
        <para>
         The table is partitioned by specifying a modulus and a remainder for
         each partition. Each partition will hold the rows for which the hash
         value of the partition key divided by the specified modulus will
         produce the specified remainder.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     If your application needs to use other forms of partitioning not listed
     above, alternative methods such as inheritance and
     <literal>UNION ALL</literal> views can be used instead.  Such methods
     offer flexibility but do not have some of the performance benefits
     of built-in declarative partitioning.
    </para>
________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>对下列分区形式提供了内建支持：

     <variablelist>
      <varlistentry>
       <term>范围划分</term>

       <listitem>
        <para>
        表被根据一个关键列或一组列划分为<quote>范围</quote>，不同的分区的范围之间没有重叠。例如，我们可以根据日期范围划分，或者根据特定业务对象的标识符划分。
	每个范围的边界被理解为左边包含并且右边不包含。例如，如果一个分区的范围是从<literal>1</literal>到<literal>10</literal>，而下一个分区是从<literal>10</literal>到<literal>20</literal>，则<literal>10</literal>的值属于第二个分区，而不是第一个分区。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>列表划分</term>

       <listitem>
        <para>
        通过显式地列出每一个分区中出现的键值来划分表。
        </para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>哈希分区</term>

       <listitem>
        <para>
         通过为每个分区指定模数和余数来对表进行分区。每个分区所持有的行都满足：分区键的值除以为其指定的模数将产生为其指定的余数。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

    如果你的应用需要使用上面所列之外的分区形式，可以使用诸如继承和<literal>UNION ALL</literal>视图之类的替代方法。这些方法很灵活，但是却缺少内建声明式分区的一些性能优势。
    </para>
<!-- pgdoc-cn_end sig_en=496fa48f3bb6e0c71595ab3a6194e5b5 -->
   </sect2>

  <sect2 id="ddl-partitioning-declarative">
<!-- pgdoc-cn_start sig_en=6c384e350bf2558f89d182e8f0035f82 sig_cn_org=None source=14.1 
   <title>Declarative Partitioning</title>
________________________________________________________-->
   <title>声明式划分</title>
<!-- pgdoc-cn_end sig_en=6c384e350bf2558f89d182e8f0035f82 -->

<!-- pgdoc-cn_start sig_en=b2ad05127cd74d430c9f6e08b8817a37 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> allows you to declare
    that a table is divided into partitions.  The table that is divided
    is referred to as a <firstterm>partitioned table</firstterm>.  The
    declaration includes the <firstterm>partitioning method</firstterm>
    as described above, plus a list of columns or expressions to be used
    as the <firstterm>partition key</firstterm>.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname> 允许你声明一个表被划分为分区。被分割的表称为<firstterm>分区表</firstterm>。声明包括如上所述的<firstterm>分区方法</firstterm>，以及用作<firstterm>分区键</firstterm>的列或表达式列表。
   </para>
<!-- pgdoc-cn_end sig_en=b2ad05127cd74d430c9f6e08b8817a37 -->

<!-- pgdoc-cn_start sig_en=20c2cf290ac7564e952eb49dfe568fd2 sig_cn_org=None source=14.1 
   <para>
    The partitioned table itself is a <quote>virtual</quote> table having
    no storage of its own.  Instead, the storage belongs
    to <firstterm>partitions</firstterm>, which are otherwise-ordinary
    tables associated with the partitioned table.
    Each partition stores a subset of the data as defined by its
    <firstterm>partition bounds</firstterm>.
    All rows inserted into a partitioned table will be routed to the
    appropriate one of the partitions based on the values of the partition
    key column(s).
    Updating the partition key of a row will cause it to be moved into a
    different partition if it no longer satisfies the partition bounds
    of its original partition.
   </para>
________________________________________________________-->
   <para>
    分区表本身是一个<quote>虚拟</quote>表，没有自己的存储空间。相反，存储属于<firstterm>分区</firstterm>，这些分区是与分区表关联的普通表。每个分区存储由其<firstterm>分区边界</firstterm>定义的数据子集。插入到分区表中的所有行都将根据分区键列的值路由到适当的一个分区。如果一行不再满足其原始分区的分区边界，则更新该行的分区键将导致该行移动到另一个分区中。
   </para>
<!-- pgdoc-cn_end sig_en=20c2cf290ac7564e952eb49dfe568fd2 -->

<!-- pgdoc-cn_start sig_en=a31496490340597dedb2759476822273 sig_cn_org=None source=14.1 
   <para>
    Partitions may themselves be defined as partitioned tables, resulting
    in <firstterm>sub-partitioning</firstterm>.  Although all partitions
    must have the same columns as their partitioned parent, partitions may
    have their
    own indexes, constraints and default values, distinct from those of other
    partitions.  See <xref linkend="sql-createtable"/> for more details on
    creating partitioned tables and partitions.
   </para>
________________________________________________________-->
   <para>
    分区本身可能被定义为分区表，从而导致<firstterm>子分区</firstterm>。尽管所有分区必须具有与其分区父级相同的列，但分区可能具有自己的与其他分区不同的索引、约束以及默认值。创建分区表及分区的更多细节请见<xref linkend="sql-createtable"/>。
   </para>
<!-- pgdoc-cn_end sig_en=a31496490340597dedb2759476822273 -->

<!-- pgdoc-cn_start sig_en=992da700ed16bacafaf1d63dd15f0f92 sig_cn_org=None source=14.1 
   <para>
    It is not possible to turn a regular table into a partitioned table or
    vice versa.  However, it is possible to add an existing regular or
    partitioned table as a partition of a partitioned table, or remove a
    partition from a partitioned table turning it into a standalone table;
    this can simplify and speed up many maintenance processes.
    See <xref linkend="sql-altertable"/> to learn more about the
    <command>ATTACH PARTITION</command> and <command>DETACH PARTITION</command>
    sub-commands.
   </para>
________________________________________________________-->
   <para>
     不可能将常规表转换为分区表，反之亦然。但是，可以将现有的常规或分区表添加为分区表的分区，或从分区表中删除分区，将其转换为独立表；这可以简化和加快许多维护过程。有关<command>ATTACH PARTITION</command> and <command>DETACH PARTITION</command> 子命令的详细信息，请参见<xref linkend="sql-altertable"/>。
   </para>
<!-- pgdoc-cn_end sig_en=992da700ed16bacafaf1d63dd15f0f92 -->

<!-- pgdoc-cn_start sig_en=1eb0e7c42d619a629a59441a88a1960d sig_cn_org=3cbcd00e9be8bcf2697a7f01f5069258 source=15.7 
   <para>
    Partitions can also be <link linkend="ddl-foreign-data">foreign
    tables</link>, although considerable care is needed because it is then
    the user's responsibility that the contents of the foreign table
    satisfy the partitioning rule.  There are some other restrictions as
    well.  See <xref linkend="sql-createforeigntable"/> for more
    information.
   </para>
________________________________________________________-->
   <para>
    分区也可以是<link linkend="ddl-foreign-data">外部表</link>，但是需要非常小心，因为这时用户需要确保外部表的内容符合分区规则。还有一些其他限制。更多信息请参见<xref linkend="sql-createforeigntable"/>。
   </para>
<!-- pgdoc-cn_end sig_en=1eb0e7c42d619a629a59441a88a1960d -->

   <sect3 id="ddl-partitioning-declarative-example">
<!-- pgdoc-cn_start sig_en=6743e90168b15ae7e535b6fe36ceadd5 sig_cn_org=None source=14.1 
    <title>Example</title>
________________________________________________________-->
    <title>例子</title>
<!-- pgdoc-cn_end sig_en=6743e90168b15ae7e535b6fe36ceadd5 -->

<!-- pgdoc-cn_start sig_en=311b934772616134dce34c295b2bd7b1 sig_cn_org=None source=14.1 
   <para>
    Suppose we are constructing a database for a large ice cream company.
    The company measures peak temperatures every day as well as ice cream
    sales in each region. Conceptually, we want a table like:

<programlisting>
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
);
</programlisting>

    We know that most queries will access just the last week's, month's or
    quarter's data, since the main use of this table will be to prepare
    online reports for management.  To reduce the amount of old data that
    needs to be stored, we decide to keep only the most recent 3 years
    worth of data. At the beginning of each month we will remove the oldest
    month's data.  In this situation we can use partitioning to help us meet
    all of our different requirements for the measurements table.
   </para>
________________________________________________________-->
   <para>
    假定我们正在为一个大型的冰激凌公司构建数据库。该公司每天测量最高温度以及每个区域的冰激凌销售情况。概念上，我们想要一个这样的表：

<programlisting>
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
);
</programlisting>

    我们知道大部分查询只会访问上周的、上月的或者上季度的数据，因为这个表的主要用途是为管理层准备在线报告。为了减少需要被存放的旧数据量，我们决定只保留最近3年的数据。在每个月的开始我们将去除掉最早的那个月的数据。在这种情况下我们可以使用分区技术来帮助我们满足对measurement表的所有不同需求。
   </para>
<!-- pgdoc-cn_end sig_en=311b934772616134dce34c295b2bd7b1 -->

<!-- pgdoc-cn_start sig_en=55351bdfd035cee8eb2c8f6994c137be sig_cn_org=None source=14.1 
   <para>
    To use declarative partitioning in this case, use the following steps:

    <orderedlist spacing="compact">
     <listitem>
      <para>
       Create the <structname>measurement</structname> table as a partitioned
       table by specifying the <literal>PARTITION BY</literal> clause, which
       includes the partitioning method (<literal>RANGE</literal> in this
       case) and the list of column(s) to use as the partition key.

<programlisting>
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (logdate);
</programlisting>
      </para>
     </listitem>

     <listitem>
      <para>
       Create partitions.  Each partition's definition must specify bounds
       that correspond to the partitioning method and partition key of the
       parent.  Note that specifying bounds such that the new partition's
       values would overlap with those in one or more existing partitions will
       cause an error.
      </para>

      <para>
       Partitions thus created are in every way normal
       <productname>PostgreSQL</productname>
       tables (or, possibly, foreign tables).  It is possible to specify a
       tablespace and storage parameters for each partition separately.
      </para>

      <para>
       For our example, each partition should hold one month's worth of
       data, to match the requirement of deleting one month's data at a
       time.  So the commands might look like:

<programlisting>
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01');

CREATE TABLE measurement_y2006m03 PARTITION OF measurement
    FOR VALUES FROM ('2006-03-01') TO ('2006-04-01');

...
CREATE TABLE measurement_y2007m11 PARTITION OF measurement
    FOR VALUES FROM ('2007-11-01') TO ('2007-12-01');

CREATE TABLE measurement_y2007m12 PARTITION OF measurement
    FOR VALUES FROM ('2007-12-01') TO ('2008-01-01')
    TABLESPACE fasttablespace;

CREATE TABLE measurement_y2008m01 PARTITION OF measurement
    FOR VALUES FROM ('2008-01-01') TO ('2008-02-01')
    WITH (parallel_workers = 4)
    TABLESPACE fasttablespace;
</programlisting>

       (Recall that adjacent partitions can share a bound value, since
       range upper bounds are treated as exclusive bounds.)
      </para>

      <para>
       If you wish to implement sub-partitioning, again specify the
       <literal>PARTITION BY</literal> clause in the commands used to create
       individual partitions, for example:

<programlisting>
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01')
    PARTITION BY RANGE (peaktemp);
</programlisting>

       After creating partitions of <structname>measurement_y2006m02</structname>,
       any data inserted into <structname>measurement</structname> that is mapped to
       <structname>measurement_y2006m02</structname> (or data that is
       directly inserted into <structname>measurement_y2006m02</structname>,
       which is allowed provided its partition constraint is satisfied)
       will be further redirected to one of its
       partitions based on the <structfield>peaktemp</structfield> column.  The partition
       key specified may overlap with the parent's partition key, although
       care should be taken when specifying the bounds of a sub-partition
       such that the set of data it accepts constitutes a subset of what
       the partition's own bounds allow; the system does not try to check
       whether that's really the case.
      </para>

      <para>
       Inserting data into the parent table that does not map
       to one of the existing partitions will cause an error; an appropriate
       partition must be added manually.
      </para>

      <para>
       It is not necessary to manually create table constraints describing
       the partition boundary conditions for partitions.  Such constraints
       will be created automatically.
      </para>
     </listitem>

     <listitem>
      <para>
       Create an index on the key column(s), as well as any other indexes you
       might want, on the partitioned table. (The key index is not strictly
       necessary, but in most scenarios it is helpful.)
       This automatically creates a matching index on each partition, and
       any partitions you create or attach later will also have such an
       index.
       An index or unique constraint declared on a partitioned table
       is <quote>virtual</quote> in the same way that the partitioned table
       is: the actual data is in child indexes on the individual partition
       tables.

<programlisting>
CREATE INDEX ON measurement (logdate);
</programlisting>
      </para>
     </listitem>

      <listitem>
       <para>
        Ensure that the <xref linkend="guc-enable-partition-pruning"/>
        configuration parameter is not disabled in <filename>postgresql.conf</filename>.
        If it is, queries will not be optimized as desired.
       </para>
      </listitem>
    </orderedlist>
   </para>
________________________________________________________-->
   <para>
    要在这种情况下使用声明式分区，可采用下面的步骤：

    <orderedlist spacing="compact">
     <listitem>
      <para>
       通过指定<literal>PARTITION BY</literal>子句把<structname>measurement</structname>表创建为分区表，该子句包括分区方法（这个例子中是<literal>RANGE</literal>）以及用作分区键的列列表。

<programlisting>
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (logdate);
</programlisting>
      </para>
     </listitem>

     <listitem>
      <para>
       创建分区。每个分区的定义必须指定与父分区的分区方法和分区键对应的边界。请注意，指定边界如果使得新分区的值与一个或多个现有分区中的值重叠将导致错误。
      </para>

      <para>
       分区以普通<productname>PostgreSQL</productname>表（或者可能是外部表）的方式创建。可以为每个分区单独指定表空间和存储参数。
      </para>

      <para>
       在我们的示例中，每个分区应该保存一个月的数据，以满足一次删除一个月数据的要求。因此，这些命令可能看起来像：

<programlisting>
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01');

CREATE TABLE measurement_y2006m03 PARTITION OF measurement
    FOR VALUES FROM ('2006-03-01') TO ('2006-04-01');

...
CREATE TABLE measurement_y2007m11 PARTITION OF measurement
    FOR VALUES FROM ('2007-11-01') TO ('2007-12-01');

CREATE TABLE measurement_y2007m12 PARTITION OF measurement
    FOR VALUES FROM ('2007-12-01') TO ('2008-01-01')
    TABLESPACE fasttablespace;

CREATE TABLE measurement_y2008m01 PARTITION OF measurement
    FOR VALUES FROM ('2008-01-01') TO ('2008-02-01')
    WITH (parallel_workers = 4)
    TABLESPACE fasttablespace;
</programlisting>

       （回想一下，相邻分区可以共享一个边界值，因为范围上限被视为不包含的边界。）
      </para>

      <para>
       如果你打算实现子分区，再次在创建分区的命令中指定<literal>PARTITION BY</literal>子句，例如：

<programlisting>
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01')
    PARTITION BY RANGE (peaktemp);
</programlisting>

       在创建了<structname>measurement_y2006m02</structname>的分区之后，任何被插入到<structname>measurement</structname>中且被映射到<structname>measurement_y2006m02</structname>的数据（或者直接被插入到<structname>measurement_y2006m02</structname>的数据，它被允许来满足这个分区的分区约束）将被基于<structfield>peaktemp</structfield>列进一步重定向到<structname>measurement_y2006m02</structname>的一个分区。指定的分区键可以与父亲的分区键重叠，不过在指定子分区的边界时要注意它接受的数据集合是分区自身边界允许的数据集合的一个子集，系统不会尝试检查事情情况是否如此。

      </para>

      <para>
       将没有映射到任何现有分区的数据插入父表将导致错误；必须手动添加适当的分区。
      </para>

      <para>
       不需要手动创建描述分区边界条件的表约束。此类约束将自动创建。
      </para>
     </listitem>

     <listitem>
      <para>
       在分区表的键列以及任何其它索引上创建索引。（键索引不是严格必需的，但在大多数情况下它是有用的。）会自动在每个分区上创建一个匹配的索引，你稍后创建或附加的任何分区也会有这样的索引。在分区表上声明的索引或唯一约束与分区表的方式相同：实际数据位于各个分区表的子索引中。

<programlisting>
CREATE INDEX ON measurement (logdate);
</programlisting>
      </para>
     </listitem>

      <listitem>
       <para>
        确保<xref linkend="guc-enable-partition-pruning"/>配置参数在<filename>postgresql.conf</filename>中没有被禁用。如果被禁用，查询将不会按照想要的方式被优化。
       </para>
      </listitem>
    </orderedlist>
   </para>
<!-- pgdoc-cn_end sig_en=55351bdfd035cee8eb2c8f6994c137be -->

<!-- pgdoc-cn_start sig_en=05e3a586c321e8dcbf8c75bac66116df sig_cn_org=None source=14.1 
   <para>
    In the above example we would be creating a new partition each month, so
    it might be wise to write a script that generates the required DDL
    automatically.
   </para>
________________________________________________________-->
   <para>
    在上面的例子中，我们会每个月创建一个新分区，因此写一个脚本来自动生成所需的DDL会更好。
   </para>
<!-- pgdoc-cn_end sig_en=05e3a586c321e8dcbf8c75bac66116df -->
   </sect3>

   <sect3 id="ddl-partitioning-declarative-maintenance">
<!-- pgdoc-cn_start sig_en=0bff9b828b9541d6cdf94d0bd336966f sig_cn_org=None source=14.1 
    <title>Partition Maintenance</title>
________________________________________________________-->
    <title>分区维护</title>
<!-- pgdoc-cn_end sig_en=0bff9b828b9541d6cdf94d0bd336966f -->

<!-- pgdoc-cn_start sig_en=2668b2e76ec65fd92c749a96d614b382 sig_cn_org=None source=14.1 
    <para>
      Normally the set of partitions established when initially defining the
      table is not intended to remain static.  It is common to want to
      remove partitions holding old data and periodically add new partitions for
      new data. One of the most important advantages of partitioning is
      precisely that it allows this otherwise painful task to be executed
      nearly instantaneously by manipulating the partition structure, rather
      than physically moving large amounts of data around.
    </para>
________________________________________________________-->
    <para>
      通常在初始定义分区表时建立的分区并非保持静态不变。移除分区持有的旧数据并且为新数据周期性地增加新分区的需求比比皆是。分区的最大好处之一就是可以通过操纵分区结构来近乎瞬时地执行这类让人头痛的任务，而不是物理地去除大量数据。
    </para>
<!-- pgdoc-cn_end sig_en=2668b2e76ec65fd92c749a96d614b382 -->

<!-- pgdoc-cn_start sig_en=631c5be795959c2ed41baca05739ce37 sig_cn_org=None source=14.1 
    <para>
     The simplest option for removing old data is to drop the partition that
     is no longer necessary:
<programlisting>
DROP TABLE measurement_y2006m02;
</programlisting>
     This can very quickly delete millions of records because it doesn't have
     to individually delete every record.  Note however that the above command
     requires taking an <literal>ACCESS EXCLUSIVE</literal> lock on the parent
     table.
    </para>
________________________________________________________-->
    <para>
     移除旧数据最简单的选择是删除掉不再需要的分区：
<programlisting>
DROP TABLE measurement_y2006m02;
</programlisting>
     这可以非常快地删除数百万行记录，因为它不需要逐个删除每个记录。不过要注意上面的命令需要在父表上拿到<literal>ACCESS EXCLUSIVE</literal>锁。
    </para>
<!-- pgdoc-cn_end sig_en=631c5be795959c2ed41baca05739ce37 -->

<!-- pgdoc-cn_start sig_en=452a14c1a0885e36a11045fe8981d677 sig_cn_org=None source=14.1 
   <para>
     Another option that is often preferable is to remove the partition from
     the partitioned table but retain access to it as a table in its own
     right.  This has two forms:

<programlisting>
ALTER TABLE measurement DETACH PARTITION measurement_y2006m02;
ALTER TABLE measurement DETACH PARTITION measurement_y2006m02 CONCURRENTLY;
</programlisting>

     These allow further operations to be performed on the data before
     it is dropped. For example, this is often a useful time to back up
     the data using <command>COPY</command>, <application>pg_dump</application>, or
     similar tools. It might also be a useful time to aggregate data
     into smaller formats, perform other data manipulations, or run
     reports.  The first form of the command requires an
     <literal>ACCESS EXCLUSIVE</literal> lock on the parent table.
     Adding the <literal>CONCURRENTLY</literal> qualifier as in the second
     form allows the detach operation to require only
     <literal>SHARE UPDATE EXCLUSIVE</literal> lock on the parent table, but see
     <link linkend="sql-altertable-detach-partition"><literal>ALTER TABLE ... DETACH PARTITION</literal></link>
     for details on the restrictions.
   </para>
________________________________________________________-->
   <para>
     另一种通常更好的选项是把分区从分区表中移除，但是保留它作为一个表的访问权。有两种形式：

<programlisting>
ALTER TABLE measurement DETACH PARTITION measurement_y2006m02;
ALTER TABLE measurement DETACH PARTITION measurement_y2006m02 CONCURRENTLY;
</programlisting>

     这些允许在数据被丢弃之前对其执行进一步的操作。例如，这通常是使用<command>COPY</command>，<application>pg_dump</application>或类似工具备份数据的好时机。这可能也是将数据聚合为较小格式，执行其它数据操作或运行报告的好时机。命令的第一种形式需要父表上的<literal>ACCESS EXCLUSIVE</literal>锁。在第二种形式中同时添加<literal>CONCURRENTLY</literal> 限定符，允许detach操作只需要父表上的<literal>SHARE UPDATE EXCLUSIVE</literal>锁，不过有关限制的详细信息，请参见<link linkend="sql-altertable-detach-partition"><literal>ALTER TABLE ... DETACH PARTITION</literal></link>。
   </para>
<!-- pgdoc-cn_end sig_en=452a14c1a0885e36a11045fe8981d677 -->

<!-- pgdoc-cn_start sig_en=0e70246a701de4aa2b2ff13841ab73d7 sig_cn_org=b2895fc821ecab1e1257d66c40d4af11 source=15.7 
   <para>
     Similarly we can add a new partition to handle new data. We can create an
     empty partition in the partitioned table just as the original partitions
     were created above:

<programlisting>
CREATE TABLE measurement_y2008m02 PARTITION OF measurement
    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01')
    TABLESPACE fasttablespace;
</programlisting>

     As an alternative, it is sometimes more convenient to create the
     new table outside the partition structure, and attach it as a
     partition later. This allows new data to be loaded, checked, and
     transformed prior to it appearing in the partitioned table.
     Moreover, the <literal>ATTACH PARTITION</literal> operation requires
     only <literal>SHARE UPDATE EXCLUSIVE</literal> lock on the
     partitioned table, as opposed to the <literal>ACCESS
     EXCLUSIVE</literal> lock that is required by <command>CREATE TABLE
     ... PARTITION OF</command>, so it is more friendly to concurrent
     operations on the partitioned table.
     The <literal>CREATE TABLE ... LIKE</literal> option is helpful
     to avoid tediously repeating the parent table's definition:

<programlisting>
CREATE TABLE measurement_y2008m02
  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS)
  TABLESPACE fasttablespace;

ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
   CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );

\copy measurement_y2008m02 from 'measurement_y2008m02'
-&minus; possibly some other data preparation work

ALTER TABLE measurement ATTACH PARTITION measurement_y2008m02
    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01' );
</programlisting>
    </para>
________________________________________________________-->
   <para>
     类似地，我们可以添加一个新的分区来处理新数据。我们可以在分区表中创建一个空分区，就像上面创建原始分区一样：

<programlisting>
CREATE TABLE measurement_y2008m02 PARTITION OF measurement
    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01')
    TABLESPACE fasttablespace;
</programlisting>

     作为一种替代方案，有时更方便的是在分区结构之外创建新表，并稍后将其附加为分区。这允许在新数据出现在分区表中之前加载、检查和转换新数据。
     此外，<literal>ATTACH PARTITION</literal>操作仅需要对分区表进行<literal>SHARE UPDATE EXCLUSIVE</literal>锁定，而不像<command>CREATE TABLE ... PARTITION OF</command>那样需要<literal>ACCESS EXCLUSIVE</literal>锁定，因此对分区表上的并发操作更友好。
     <literal>CREATE TABLE ... LIKE</literal>选项有助于避免重复繁琐地重复父表的定义：

<programlisting>
CREATE TABLE measurement_y2008m02
  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS)
  TABLESPACE fasttablespace;

ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
   CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );

\copy measurement_y2008m02 from 'measurement_y2008m02'
-- 可能还有其他数据准备工作

ALTER TABLE measurement ATTACH PARTITION measurement_y2008m02
    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01' );
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=0e70246a701de4aa2b2ff13841ab73d7 -->

<!-- pgdoc-cn_start sig_en=b3de502b8747b73cbe9ce709f64395c5 sig_cn_org=2304fba86d213e34c1b5051d46a3af4f source=15.7 
    <para>
     Before running the <command>ATTACH PARTITION</command> command, it is
     recommended to create a <literal>CHECK</literal> constraint on the table to
     be attached that matches the expected partition constraint, as
     illustrated above. That way, the system will be able to skip the scan
     which is otherwise needed to validate the implicit
     partition constraint. Without the <literal>CHECK</literal> constraint,
     the table will be scanned to validate the partition constraint while
     holding an <literal>ACCESS EXCLUSIVE</literal> lock on that partition.
     It is recommended to drop the now-redundant <literal>CHECK</literal>
     constraint after the <command>ATTACH PARTITION</command> is complete.  If
     the table being attached is itself a partitioned table, then each of its
     sub-partitions will be recursively locked and scanned until either a
     suitable <literal>CHECK</literal> constraint is encountered or the leaf
     partitions are reached.
    </para>
________________________________________________________-->
    <para>
     在运行<command>ATTACH PARTITION</command>命令之前，建议在要附加的表上创建一个匹配预期分区约束的<literal>CHECK</literal>约束，如上所示。
     这样，系统就能够跳过验证隐式分区约束所需的扫描。没有<literal>CHECK</literal>约束，表将在持有该分区的<literal>ACCESS EXCLUSIVE</literal>锁的情况下进行扫描以验证分区约束。
     建议在<command>ATTACH PARTITION</command>完成后删除现在多余的<literal>CHECK</literal>约束。如果要附加的表本身是一个分区表，则将递归锁定和扫描其每个子分区，直到遇到合适的<literal>CHECK</literal>约束或到达叶子分区为止。
    </para>
<!-- pgdoc-cn_end sig_en=b3de502b8747b73cbe9ce709f64395c5 -->

<!-- pgdoc-cn_start sig_en=d383361a4cd6ca7148937087bff90b79 sig_cn_org=277876db11ff54cfe94ea56e91e5b688 source=15.7 
    <para>
     Similarly, if the partitioned table has a <literal>DEFAULT</literal>
     partition, it is recommended to create a <literal>CHECK</literal>
     constraint which excludes the to-be-attached partition's constraint.  If
     this is not done then the <literal>DEFAULT</literal> partition will be
     scanned to verify that it contains no records which should be located in
     the partition being attached.  This operation will be performed whilst
     holding an <literal>ACCESS EXCLUSIVE</literal> lock on the <literal>
     DEFAULT</literal> partition.  If the <literal>DEFAULT</literal> partition
     is itself a partitioned table, then each of its partitions will be
     recursively checked in the same way as the table being attached, as
     mentioned above.
    </para>
________________________________________________________-->
    <para>
     类似地，如果分区表有一个<literal>DEFAULT</literal>分区，建议创建一个<literal>CHECK</literal>约束，
     排除要附加分区的约束。如果没有这样做，那么将扫描<literal>DEFAULT</literal>分区，
     以验证它不包含应该位于要附加分区中的记录。此操作将在持有<literal>ACCESS EXCLUSIVE</literal>锁的情况下执行，
     该锁位于<literal>DEFAULT</literal>分区上。如果<literal>DEFAULT</literal>分区本身是一个分区表，
     那么将以与附加表相同的方式递归检查其各个分区，如上所述。
    </para>
<!-- pgdoc-cn_end sig_en=d383361a4cd6ca7148937087bff90b79 -->

<!-- pgdoc-cn_start sig_en=a4756ae5fe54c93b63fc2ec252860c6e sig_cn_org=40b0fc0517651b57391d2bf4b27dc616 source=15.7 
    <para>
     As explained above, it is possible to create indexes on partitioned tables
     so that they are applied automatically to the entire hierarchy.
     This is very
     convenient, as not only will the existing partitions become indexed, but
     also any partitions that are created in the future will.  One limitation is
     that it's not possible to use the <literal>CONCURRENTLY</literal>
     qualifier when creating such a partitioned index.  To avoid long lock
     times, it is possible to use <command>CREATE INDEX ON ONLY</command>
     the partitioned table; such an index is marked invalid, and the partitions
     do not get the index applied automatically.  The indexes on partitions can
     be created individually using <literal>CONCURRENTLY</literal>, and then
     <firstterm>attached</firstterm> to the index on the parent using
     <command>ALTER INDEX .. ATTACH PARTITION</command>.  Once indexes for all
     partitions are attached to the parent index, the parent index is marked
     valid automatically.  Example:
<programlisting>
CREATE INDEX measurement_usls_idx ON ONLY measurement (unitsales);

CREATE INDEX CONCURRENTLY measurement_usls_200602_idx
    ON measurement_y2006m02 (unitsales);
ALTER INDEX measurement_usls_idx
    ATTACH PARTITION measurement_usls_200602_idx;
...
</programlisting>

     This technique can be used with <literal>UNIQUE</literal> and
     <literal>PRIMARY KEY</literal> constraints too; the indexes are created
     implicitly when the constraint is created.  Example:
<programlisting>
ALTER TABLE ONLY measurement ADD UNIQUE (city_id, logdate);

ALTER TABLE measurement_y2006m02 ADD UNIQUE (city_id, logdate);
ALTER INDEX measurement_city_id_logdate_key
    ATTACH PARTITION measurement_y2006m02_city_id_logdate_key;
...
</programlisting>
    </para>
________________________________________________________-->
    <para>
     如上所述，可以在分区表上创建索引，以便自动应用于整个层次结构。
     这非常方便，因为不仅现有分区将被索引，而且将来创建的任何分区也将被索引。
     一个限制是在创建这样的分区索引时无法使用<literal>CONCURRENTLY</literal>修饰符。
     为了避免长时间锁定，可以在分区表上使用<command>CREATE INDEX ON ONLY</command>；
     这样的索引被标记为无效，并且分区不会自动应用索引。
     可以分别使用<literal>CONCURRENTLY</literal>在分区上创建索引，然后使用
     <command>ALTER INDEX .. ATTACH PARTITION</command>将其<firstterm>附加</firstterm>到父索引上。
     一旦所有分区的索引都附加到父索引上，父索引将自动标记为有效。示例：
<programlisting>
CREATE INDEX measurement_usls_idx ON ONLY measurement (unitsales);

CREATE INDEX CONCURRENTLY measurement_usls_200602_idx
    ON measurement_y2006m02 (unitsales);
ALTER INDEX measurement_usls_idx
    ATTACH PARTITION measurement_usls_200602_idx;
...
</programlisting>

     这种技术也可以用于<literal>UNIQUE</literal>和<literal>PRIMARY KEY</literal>约束；
     当约束创建时，索引会隐式创建。示例：
<programlisting>
ALTER TABLE ONLY measurement ADD UNIQUE (city_id, logdate);

ALTER TABLE measurement_y2006m02 ADD UNIQUE (city_id, logdate);
ALTER INDEX measurement_city_id_logdate_key
    ATTACH PARTITION measurement_y2006m02_city_id_logdate_key;
...
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=a4756ae5fe54c93b63fc2ec252860c6e -->
   </sect3>

   <sect3 id="ddl-partitioning-declarative-limitations">
<!-- pgdoc-cn_start sig_en=6f5b22a932265c21e464df6dcbb347ec sig_cn_org=None source=14.1 
    <title>Limitations</title>
________________________________________________________-->
    <title>限制</title>
<!-- pgdoc-cn_end sig_en=6f5b22a932265c21e464df6dcbb347ec -->

<!-- pgdoc-cn_start sig_en=cafbf8bf1806a96e282430ebe7bb52c0 sig_cn_org=af8d4d3b4dfeea48ac9c43cde18e3a98 source=15.7 
   <para>
    The following limitations apply to partitioned tables:
    <itemizedlist>
     <listitem>
      <para>
       To create a unique or primary key constraint on a partitioned table,
       the partition keys must not include any expressions or function calls
       and the constraint's columns must include all of the partition key
       columns.  This limitation exists because the individual indexes making
       up the constraint can only directly enforce uniqueness within their own
       partitions; therefore, the partition structure itself must guarantee
       that there are not duplicates in different partitions.
      </para>
     </listitem>

     <listitem>
      <para>
       There is no way to create an exclusion constraint spanning the
       whole partitioned table.  It is only possible to put such a
       constraint on each leaf partition individually.  Again, this
       limitation stems from not being able to enforce cross-partition
       restrictions.
      </para>
     </listitem>

     <listitem>
      <para>
       <literal>BEFORE ROW</literal> triggers on <literal>INSERT</literal>
       cannot change which partition is the final destination for a new row.
      </para>
     </listitem>

     <listitem>
      <para>
       Mixing temporary and permanent relations in the same partition tree is
       not allowed.  Hence, if the partitioned table is permanent, so must be
       its partitions and likewise if the partitioned table is temporary.  When
       using temporary relations, all members of the partition tree have to be
       from the same session.
      </para>
     </listitem>
    </itemizedlist>
    </para>
________________________________________________________-->
   <para>
    对分区表应用以下限制：
    <itemizedlist>
     <listitem>
      <para>
       要在分区表上创建唯一或主键约束，分区键不能包含任何表达式或函数调用，
       约束的列必须包括所有分区键列。存在此限制是因为构成约束的各个索引只能
       直接在各自的分区内强制唯一性；因此，分区结构本身必须保证不同分区中没有
       重复数据。
      </para>
     </listitem>

     <listitem>
      <para>
       无法创建跨整个分区表的排他约束。只能在每个叶分区上放置这样的约束。
       再次，此限制源于无法强制执行跨分区的限制。
      </para>
     </listitem>

     <listitem>
      <para>
       在<literal>INSERT</literal>上的<literal>BEFORE ROW</literal>触发器
       不能更改哪个分区是新行的最终目的地。
      </para>
     </listitem>

     <listitem>
      <para>
       在同一分区树中不允许混合临时和永久关系。因此，如果分区表是永久的，
       那么它的分区也必须是永久的；同样，如果分区表是临时的，那么它的分区
       也必须是临时的。在使用临时关系时，分区树的所有成员必须来自同一个会话。
      </para>
     </listitem>
    </itemizedlist>
    </para>
<!-- pgdoc-cn_end sig_en=cafbf8bf1806a96e282430ebe7bb52c0 -->

<!-- pgdoc-cn_start sig_en=7828a0c240b8e4d3c99c8518e29095a9 sig_cn_org=None source=14.1 
    <para>
     Individual partitions are linked to their partitioned table using
     inheritance behind-the-scenes.  However, it is not possible to use
     all of the generic features of inheritance with declaratively
     partitioned tables or their partitions, as discussed below.  Notably,
     a partition cannot have any parents other than the partitioned table
     it is a partition of, nor can a table inherit from both a partitioned
     table and a regular table.  That means partitioned tables and their
     partitions never share an inheritance hierarchy with regular tables.
    </para>
________________________________________________________-->
    <para>
     各个分区悄悄地使用继承链接到它们的分区表。但是，不可能将继承的所有通用特性用于声明性分区的表或其分区，如下所述。值得注意的是，一个分区除了它所属的分区表之外，不能有任何父级，也不能同时从分区表和常规表继承。这意味着分区表及其分区永远不会与常规表共享继承层次结构。
    </para>
<!-- pgdoc-cn_end sig_en=7828a0c240b8e4d3c99c8518e29095a9 -->

<!-- pgdoc-cn_start sig_en=bf1bcf80a8a504afbe564080ffc2980f sig_cn_org=fe4fc4d85bc3d1c3abbc92463884a639 source=15.7 
    <para>
     Since a partition hierarchy consisting of the partitioned table and its
     partitions is still an inheritance hierarchy,
     <structfield>tableoid</structfield> and all the normal rules of
     inheritance apply as described in <xref linkend="ddl-inherit"/>, with
     a few exceptions:

     <itemizedlist>
      <listitem>
       <para>
        Partitions cannot have columns that are not present in the parent.  It
        is not possible to specify columns when creating partitions with
        <command>CREATE TABLE</command>, nor is it possible to add columns to
        partitions after-the-fact using <command>ALTER TABLE</command>.
        Tables may be added as a partition with <command>ALTER TABLE
        ... ATTACH PARTITION</command> only if their columns exactly match
        the parent.
       </para>
      </listitem>

      <listitem>
       <para>
        Both <literal>CHECK</literal> and <literal>NOT NULL</literal>
        constraints of a partitioned table are always inherited by all its
        partitions.  <literal>CHECK</literal> constraints that are marked
        <literal>NO INHERIT</literal> are not allowed to be created on
        partitioned tables.
        You cannot drop a <literal>NOT NULL</literal> constraint on a
        partition's column if the same constraint is present in the parent
        table.
       </para>
      </listitem>

      <listitem>
       <para>
        Using <literal>ONLY</literal> to add or drop a constraint on only
        the partitioned table is supported as long as there are no
        partitions.  Once partitions exist, using <literal>ONLY</literal>
        will result in an error for any constraints other than
        <literal>UNIQUE</literal> and <literal>PRIMARY KEY</literal>.
        Instead, constraints on the partitions
        themselves can be added and (if they are not present in the parent
        table) dropped.
       </para>
      </listitem>

      <listitem>
       <para>
        As a partitioned table does not have any data itself, attempts to use
        <command>TRUNCATE</command> <literal>ONLY</literal> on a partitioned
        table will always return an error.
       </para>
      </listitem>
     </itemizedlist>
    </para>
________________________________________________________-->
    <para>
     由于由分区表和其分区组成的分区层次仍然是一个继承层次结构，
     <structfield>tableoid</structfield>和所有继承规则都适用，如在<xref linkend="ddl-inherit"/>中描述的那样，但有一些例外：

     <itemizedlist>
      <listitem>
       <para>
        分区不能具有父级中不存在的列。在使用<command>CREATE TABLE</command>创建分区时无法指定列，也无法使用<command>ALTER TABLE</command>在事后添加列到分区。
        只有当表的列与父级完全匹配时，才能使用<command>ALTER TABLE ... ATTACH PARTITION</command>将表添加为分区。
       </para>
      </listitem>

      <listitem>
       <para>
        分区表的<literal>CHECK</literal>和<literal>NOT NULL</literal>约束始终被所有分区继承。在标记为<literal>NO INHERIT</literal>的<literal>CHECK</literal>约束上不允许在分区表上创建。
        如果分区的列上存在与父表中相同的<literal>NOT NULL</literal>约束，则无法删除该约束。
       </para>
      </listitem>

      <listitem>
       <para>
        只有在没有分区存在时，才支持在分区表上使用<literal>ONLY</literal>添加或删除约束。一旦存在分区，使用<literal>ONLY</literal>将导致除<literal>UNIQUE</literal>和<literal>PRIMARY KEY</literal>之外的任何约束都会报错。
        可以在分区上添加约束，并且（如果这些约束在父表中不存在）可以删除它们。
       </para>
      </listitem>

      <listitem>
       <para>
        由于分区表本身没有任何数据，因此尝试在分区表上使用<command>TRUNCATE</command> <literal>ONLY</literal>将始终返回错误。
       </para>
      </listitem>
     </itemizedlist>
    </para>
<!-- pgdoc-cn_end sig_en=bf1bcf80a8a504afbe564080ffc2980f -->
    </sect3>
   </sect2>

   <sect2 id="ddl-partitioning-using-inheritance">
<!-- pgdoc-cn_start sig_en=559306aeb2987f495736d0dbd2f00bd4 sig_cn_org=None source=14.1 
    <title>Partitioning Using Inheritance</title>
________________________________________________________-->
    <title>使用继承的分区</title>
<!-- pgdoc-cn_end sig_en=559306aeb2987f495736d0dbd2f00bd4 -->

<!-- pgdoc-cn_start sig_en=765390d9c259057e8b90a0d06cad0098 sig_cn_org=None source=14.1 
    <para>
     While the built-in declarative partitioning is suitable for most
     common use cases, there are some circumstances where a more flexible
     approach may be useful.  Partitioning can be implemented using table
     inheritance, which allows for several features not supported
     by declarative partitioning, such as:

     <itemizedlist>
      <listitem>
       <para>
        For declarative partitioning, partitions must have exactly the same set
        of columns as the partitioned table, whereas with table inheritance,
        child tables may have extra columns not present in the parent.
       </para>
      </listitem>

      <listitem>
       <para>
        Table inheritance allows for multiple inheritance.
       </para>
      </listitem>

      <listitem>
       <para>
        Declarative partitioning only supports range, list and hash
        partitioning, whereas table inheritance allows data to be divided in a
        manner of the user's choosing.  (Note, however, that if constraint
        exclusion is unable to prune child tables effectively, query performance
        might be poor.)
       </para>
      </listitem>
     </itemizedlist>
    </para>
________________________________________________________-->
    <para>
     虽然内建的声明式分区适合于大部分常见的用例，但还是有一些场景需要更加灵活的方法。分区可以使用表继承来实现，这能够带来一些声明式分区不支持的特性，例如：

     <itemizedlist>
      <listitem>
       <para>
        对声明式分区来说，分区必须具有和分区表正好相同的列集合，而在表继承中，子表可以有父表中没有出现过的额外列。
       </para>
      </listitem>

      <listitem>
       <para>
        表继承允许多继承。
       </para>
      </listitem>

      <listitem>
       <para>
        声明式分区仅支持范围、列表以及哈希分区，而表继承允许数据按照用户的选择来划分（不过注意，如果约束排除不能有效地剪枝子表，查询性能可能会很差）。

       </para>
      </listitem>
     </itemizedlist>
    </para>
<!-- pgdoc-cn_end sig_en=765390d9c259057e8b90a0d06cad0098 -->

    <sect3 id="ddl-partitioning-inheritance-example">
<!-- pgdoc-cn_start sig_en=6743e90168b15ae7e535b6fe36ceadd5 sig_cn_org=None source=14.1 
     <title>Example</title>
________________________________________________________-->
     <title>例子</title>
<!-- pgdoc-cn_end sig_en=6743e90168b15ae7e535b6fe36ceadd5 -->

<!-- pgdoc-cn_start sig_en=32a551c09cb9d2d9c5741ca90b6e38e0 sig_cn_org=None source=14.1 
     <para>
      This example builds a partitioning structure equivalent to the
      declarative partitioning example above.  Use
      the following steps:

      <orderedlist spacing="compact">
       <listitem>
        <para>
         Create the <quote>root</quote> table, from which all of the
         <quote>child</quote> tables will inherit.  This table will contain no data.  Do not
         define any check constraints on this table, unless you intend them
         to be applied equally to all child tables.  There is no point in
         defining any indexes or unique constraints on it, either.  For our
         example, the root table is the <structname>measurement</structname>
         table as originally defined:

<programlisting>
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
);
</programlisting>
        </para>
       </listitem>

       <listitem>
        <para>
         Create several <quote>child</quote> tables that each inherit from
         the root table.  Normally, these tables will not add any columns
         to the set inherited from the root.  Just as with declarative
         partitioning, these tables are in every way normal
         <productname>PostgreSQL</productname> tables (or foreign tables).
        </para>

        <para>
<programlisting>
CREATE TABLE measurement_y2006m02 () INHERITS (measurement);
CREATE TABLE measurement_y2006m03 () INHERITS (measurement);
...
CREATE TABLE measurement_y2007m11 () INHERITS (measurement);
CREATE TABLE measurement_y2007m12 () INHERITS (measurement);
CREATE TABLE measurement_y2008m01 () INHERITS (measurement);
</programlisting>
        </para>
       </listitem>

       <listitem>
        <para>
         Add non-overlapping table constraints to the child tables to
         define the allowed key values in each.
        </para>

        <para>
         Typical examples would be:
<programlisting>
CHECK ( x = 1 )
CHECK ( county IN ( 'Oxfordshire', 'Buckinghamshire', 'Warwickshire' ))
CHECK ( outletID &gt;= 100 AND outletID &lt; 200 )
</programlisting>
         Ensure that the constraints guarantee that there is no overlap
         between the key values permitted in different child tables.  A common
         mistake is to set up range constraints like:
<programlisting>
CHECK ( outletID BETWEEN 100 AND 200 )
CHECK ( outletID BETWEEN 200 AND 300 )
</programlisting>
         This is wrong since it is not clear which child table the key
         value 200 belongs in.
         Instead, ranges should be defined in this style:

<programlisting>
CREATE TABLE measurement_y2006m02 (
    CHECK ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2006m03 (
    CHECK ( logdate &gt;= DATE '2006-03-01' AND logdate &lt; DATE '2006-04-01' )
) INHERITS (measurement);

...
CREATE TABLE measurement_y2007m11 (
    CHECK ( logdate &gt;= DATE '2007-11-01' AND logdate &lt; DATE '2007-12-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2007m12 (
    CHECK ( logdate &gt;= DATE '2007-12-01' AND logdate &lt; DATE '2008-01-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2008m01 (
    CHECK ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )
) INHERITS (measurement);
</programlisting>
        </para>
       </listitem>

       <listitem>
        <para>
         For each child table, create an index on the key column(s),
         as well as any other indexes you might want.
<programlisting>
CREATE INDEX measurement_y2006m02_logdate ON measurement_y2006m02 (logdate);
CREATE INDEX measurement_y2006m03_logdate ON measurement_y2006m03 (logdate);
CREATE INDEX measurement_y2007m11_logdate ON measurement_y2007m11 (logdate);
CREATE INDEX measurement_y2007m12_logdate ON measurement_y2007m12 (logdate);
CREATE INDEX measurement_y2008m01_logdate ON measurement_y2008m01 (logdate);
</programlisting>
        </para>
       </listitem>

       <listitem>
        <para>
         We want our application to be able to say <literal>INSERT INTO
         measurement ...</literal> and have the data be redirected into the
         appropriate child table.  We can arrange that by attaching
         a suitable trigger function to the root table.
         If data will be added only to the latest child, we can
         use a very simple trigger function:

<programlisting>
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;
</programlisting>
        </para>

        <para>
         After creating the function, we create a trigger which
         calls the trigger function:

<programlisting>
CREATE TRIGGER insert_measurement_trigger
    BEFORE INSERT ON measurement
    FOR EACH ROW EXECUTE FUNCTION measurement_insert_trigger();
</programlisting>

         We must redefine the trigger function each month so that it always
         inserts into the current child table.  The trigger definition does
         not need to be updated, however.
        </para>

        <para>
         We might want to insert data and have the server automatically
         locate the child table into which the row should be added. We
         could do this with a more complex trigger function, for example:

<programlisting>
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF ( NEW.logdate &gt;= DATE '2006-02-01' AND
         NEW.logdate &lt; DATE '2006-03-01' ) THEN
        INSERT INTO measurement_y2006m02 VALUES (NEW.*);
    ELSIF ( NEW.logdate &gt;= DATE '2006-03-01' AND
            NEW.logdate &lt; DATE '2006-04-01' ) THEN
        INSERT INTO measurement_y2006m03 VALUES (NEW.*);
    ...
    ELSIF ( NEW.logdate &gt;= DATE '2008-01-01' AND
            NEW.logdate &lt; DATE '2008-02-01' ) THEN
        INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    ELSE
        RAISE EXCEPTION 'Date out of range.  Fix the measurement_insert_trigger() function!';
    END IF;
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;
</programlisting>

         The trigger definition is the same as before.
         Note that each <literal>IF</literal> test must exactly match the
         <literal>CHECK</literal> constraint for its child table.
        </para>

        <para>
         While this function is more complex than the single-month case,
         it doesn't need to be updated as often, since branches can be
         added in advance of being needed.
        </para>

        <note>
         <para>
          In practice, it might be best to check the newest child first,
          if most inserts go into that child.  For simplicity, we have
          shown the trigger's tests in the same order as in other parts
          of this example.
         </para>
        </note>

        <para>
         A different approach to redirecting inserts into the appropriate
         child table is to set up rules, instead of a trigger, on the
         root table.  For example:

<programlisting>
CREATE RULE measurement_insert_y2006m02 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )
DO INSTEAD
    INSERT INTO measurement_y2006m02 VALUES (NEW.*);
...
CREATE RULE measurement_insert_y2008m01 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )
DO INSTEAD
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);
</programlisting>

         A rule has significantly more overhead than a trigger, but the
         overhead is paid once per query rather than once per row, so this
         method might be advantageous for bulk-insert situations.  In most
         cases, however, the trigger method will offer better performance.
        </para>

        <para>
         Be aware that <command>COPY</command> ignores rules.  If you want to
         use <command>COPY</command> to insert data, you'll need to copy into the
         correct child table rather than directly into the root. <command>COPY</command>
         does fire triggers, so you can use it normally if you use the trigger
         approach.
        </para>

        <para>
         Another disadvantage of the rule approach is that there is no simple
         way to force an error if the set of rules doesn't cover the insertion
         date; the data will silently go into the root table instead.
        </para>
       </listitem>

       <listitem>
        <para>
         Ensure that the <xref linkend="guc-constraint-exclusion"/>
         configuration parameter is not disabled in
         <filename>postgresql.conf</filename>; otherwise
         child tables may be accessed unnecessarily.
        </para>
       </listitem>
      </orderedlist>
     </para>
________________________________________________________-->
     <para>
      这个示例构建了一个与上面的声明性分区示例等效的分区结构。使用以下步骤：

      <orderedlist spacing="compact">
       <listitem>
        <para>
         创建<quote>根</quote>表，所有的<quote>子</quote>表都将从它继承。这个表将不包含数据。不要在这个表上定义任何检查约束，除非想让它们应用到所有的子表上。同样，在这个表上定义索引或者唯一约束也没有意义。对于我们的例子来说，根表是最初定义的<structname>measurement</structname>表。
        </para>
       </listitem>

       <listitem>
        <para>
         创建数个<quote>子</quote>表，每一个都从根表继承。通常，这些表将不会在从根表继承的列集合之外增加任何列。正如声明性分区那样，这些表就是普通的<productname>PostgreSQL</productname>表（或者外部表）。
        </para>

        <para>
<programlisting>
CREATE TABLE measurement_y2006m02 () INHERITS (measurement);
CREATE TABLE measurement_y2006m03 () INHERITS (measurement);
...
CREATE TABLE measurement_y2007m11 () INHERITS (measurement);
CREATE TABLE measurement_y2007m12 () INHERITS (measurement);
CREATE TABLE measurement_y2008m01 () INHERITS (measurement);
</programlisting>
        </para>
       </listitem>

       <listitem>
        <para>
         为子表增加不重叠的表约束来定义每个分区允许的键值。
        </para>

        <para>
         典型的例子是：
<programlisting>
CHECK ( x = 1 )
CHECK ( county IN ( 'Oxfordshire', 'Buckinghamshire', 'Warwickshire' ))
CHECK ( outletID &gt;= 100 AND outletID &lt; 200 )
</programlisting>
         确保约束能保证不同子表允许的键值之间没有重叠。设置范围约束的常见错误：
<programlisting>
CHECK ( outletID BETWEEN 100 AND 200 )
CHECK ( outletID BETWEEN 200 AND 300 )
</programlisting>
         这是错误的，因为不清楚键值200属于哪一个子表。
         相反，范围应该以如下样式定义：

<programlisting>
CREATE TABLE measurement_y2006m02 (
    CHECK ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2006m03 (
    CHECK ( logdate &gt;= DATE '2006-03-01' AND logdate &lt; DATE '2006-04-01' )
) INHERITS (measurement);

...
CREATE TABLE measurement_y2007m11 (
    CHECK ( logdate &gt;= DATE '2007-11-01' AND logdate &lt; DATE '2007-12-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2007m12 (
    CHECK ( logdate &gt;= DATE '2007-12-01' AND logdate &lt; DATE '2008-01-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2008m01 (
    CHECK ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )
) INHERITS (measurement);
</programlisting>
        </para>
       </listitem>

       <listitem>
        <para>
         对于每个子表，在键列上创建一个索引，以及任何想要的其他索引。
<programlisting>
CREATE INDEX measurement_y2006m02_logdate ON measurement_y2006m02 (logdate);
CREATE INDEX measurement_y2006m03_logdate ON measurement_y2006m03 (logdate);
CREATE INDEX measurement_y2007m11_logdate ON measurement_y2007m11 (logdate);
CREATE INDEX measurement_y2007m12_logdate ON measurement_y2007m12 (logdate);
CREATE INDEX measurement_y2008m01_logdate ON measurement_y2008m01 (logdate);
</programlisting>
        </para>
       </listitem>

       <listitem>
        <para>
         我们希望我们的应用能够使用<literal>INSERT INTO measurement ...</literal>并且数据将被重定向到合适的分区表。我们可以通过为根表附加一个合适的触发器函数来实现这一点。如果数据将只被增加到最后一个分区，我们可以使用一个非常简单的触发器函数：

<programlisting>
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;
</programlisting>
        </para>

        <para>
         完成函数创建后，我们创建一个调用该触发器函数的触发器：

<programlisting>
CREATE TRIGGER insert_measurement_trigger
    BEFORE INSERT ON measurement
    FOR EACH ROW EXECUTE FUNCTION measurement_insert_trigger();
</programlisting>

         我们必须在每个月重新定义触发器函数，这样它才会总是插入到当前的子表。而触发器的定义则不需要被更新。
        </para>

        <para>
         我们也可能希望插入数据时服务器会自动地定位应该加入数据的子表。我们可以通过一个更复杂的触发器函数来实现之，例如：

<programlisting>
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF ( NEW.logdate &gt;= DATE '2006-02-01' AND
         NEW.logdate &lt; DATE '2006-03-01' ) THEN
        INSERT INTO measurement_y2006m02 VALUES (NEW.*);
    ELSIF ( NEW.logdate &gt;= DATE '2006-03-01' AND
            NEW.logdate &lt; DATE '2006-04-01' ) THEN
        INSERT INTO measurement_y2006m03 VALUES (NEW.*);
    ...
    ELSIF ( NEW.logdate &gt;= DATE '2008-01-01' AND
            NEW.logdate &lt; DATE '2008-02-01' ) THEN
        INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    ELSE
        RAISE EXCEPTION 'Date out of range.  Fix the measurement_insert_trigger() function!';
    END IF;
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;
</programlisting>

         触发器的定义和以前一样。注意每一个<literal>IF</literal>测试必须准确地匹配它的子表的<literal>CHECK</literal>约束。
        </para>

        <para>
         当该函数比单月形式更加复杂时，并不需要频繁地更新它，因为可以在需要的时候提前加入分支。
        </para>

        <note>
         <para>
         在实践中，如果大部分插入都会进入最新的子表，最好先检查它。为了简洁，我们为触发器的检查采用了和本例中其他部分一致的顺序。
         </para>
        </note>

        <para>
         把插入重定向到一个合适的子表中的另一种不同方法是在根表上设置规则而不是触发器。例如：

<programlisting>
CREATE RULE measurement_insert_y2006m02 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )
DO INSTEAD
    INSERT INTO measurement_y2006m02 VALUES (NEW.*);
...
CREATE RULE measurement_insert_y2008m01 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )
DO INSTEAD
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);
</programlisting>

         规则的开销比触发器大很多，但是这种开销是每个查询只有一次，而不是每行一次，因此这种方法可能对批量插入的情况有优势。不过，在大部分情况下，触发器方法将提供更好的性能。
        </para>

        <para>
         注意<command>COPY</command>会忽略规则。如果想要使用<command>COPY</command>插入数据，则需要拷贝到正确的子表而不是直接放在根表中。<command>COPY</command>会引发触发器，因此在使用触发器方法时可以正常使用它。
        </para>

        <para>
         规则方法的另一个缺点是，如果规则集合无法覆盖插入日期，则没有简单的方法能够强制产生错误，数据将会无声无息地进入到根表中。
        </para>
       </listitem>

       <listitem>
        <para>
         确认<xref linkend="guc-constraint-exclusion"/>配置参数在<filename>postgresql.conf</filename>中没有被禁用，否则将会不必要地访问子表。
        </para>
       </listitem>
      </orderedlist>
     </para>
<!-- pgdoc-cn_end sig_en=32a551c09cb9d2d9c5741ca90b6e38e0 -->

<!-- pgdoc-cn_start sig_en=9510ade5653f96c7e031045cafee7cf7 sig_cn_org=None source=14.1 
     <para>
      As we can see, a complex table hierarchy could require a
      substantial amount of DDL.  In the above example we would be creating
      a new child table each month, so it might be wise to write a script that
      generates the required DDL automatically.
     </para>
________________________________________________________-->
     <para>
      如我们所见，一个复杂的表层次可能需要大量的DDL。在上面的例子中，我们可能为每个月创建一个新的子表，因此编写一个脚本来自动生成所需要的DDL可能会更好。
     </para>
<!-- pgdoc-cn_end sig_en=9510ade5653f96c7e031045cafee7cf7 -->
    </sect3>

    <sect3 id="ddl-partitioning-inheritance-maintenance">
<!-- pgdoc-cn_start sig_en=17efd3752c03edfab057a9ace262cf72 sig_cn_org=None source=14.1 
     <title>Maintenance for Inheritance Partitioning</title>
________________________________________________________-->
     <title>继承分区的维护</title>
<!-- pgdoc-cn_end sig_en=17efd3752c03edfab057a9ace262cf72 -->
<!-- pgdoc-cn_start sig_en=acf0a35900b44b934cc61c00160f898e sig_cn_org=None source=14.1 
     <para>
      To remove old data quickly, simply drop the child table that is no longer
      necessary:
<programlisting>
DROP TABLE measurement_y2006m02;
</programlisting>
     </para>
________________________________________________________-->
     <para>
      要快速移除旧数据，只需要简单地去掉不再需要的子表：
<programlisting>
DROP TABLE measurement_y2006m02;
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=acf0a35900b44b934cc61c00160f898e -->

<!-- pgdoc-cn_start sig_en=cabe26ece8017685145fbc9ee1e8d3c6 sig_cn_org=None source=14.1 
    <para>
     To remove the child table from the inheritance hierarchy table but retain access to
     it as a table in its own right:

<programlisting>
ALTER TABLE measurement_y2006m02 NO INHERIT measurement;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     要从继承层次表中去掉子表，但还是把它当做一个表保留：

<programlisting>
ALTER TABLE measurement_y2006m02 NO INHERIT measurement;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=cabe26ece8017685145fbc9ee1e8d3c6 -->

<!-- pgdoc-cn_start sig_en=9674d7a41a3e7b92f8968e495bd42819 sig_cn_org=None source=14.1 
    <para>
     To add a new child table to handle new data, create an empty child table
     just as the original children were created above:

<programlisting>
CREATE TABLE measurement_y2008m02 (
    CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' )
) INHERITS (measurement);
</programlisting>

     Alternatively, one may want to create and populate the new child table
     before adding it to the table hierarchy.  This could allow data to be
     loaded, checked, and transformed before being made visible to queries on
     the parent table.

<programlisting>
CREATE TABLE measurement_y2008m02
  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS);
ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
   CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );
\copy measurement_y2008m02 from 'measurement_y2008m02'
-&minus; possibly some other data preparation work
ALTER TABLE measurement_y2008m02 INHERIT measurement;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     要增加一个新子表来处理新数据，可以像上面创建的原始子表那样创建一个空的子表：

<programlisting>
CREATE TABLE measurement_y2008m02 (
    CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' )
) INHERITS (measurement);
</programlisting>

     或者，用户可能想要创建新子表并且在将它加入到表层次之前填充它。这可以允许数据在被父表上的查询可见之前对数据进行装载、检查以及转换。

<programlisting>
CREATE TABLE measurement_y2008m02
  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS);
ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
   CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );
\copy measurement_y2008m02 from 'measurement_y2008m02'
-&minus; possibly some other data preparation work
ALTER TABLE measurement_y2008m02 INHERIT measurement;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=9674d7a41a3e7b92f8968e495bd42819 -->
   </sect3>

   <sect3 id="ddl-partitioning-inheritance-caveats">
<!-- pgdoc-cn_start sig_en=6aecf7221ae7403619467c1e1a1a629b sig_cn_org=None source=14.1 
    <title>Caveats</title>
________________________________________________________-->
    <title>警告</title>
<!-- pgdoc-cn_end sig_en=6aecf7221ae7403619467c1e1a1a629b -->

<!-- pgdoc-cn_start sig_en=6f0b7c1d7b6760db3d2e9761df8c4152 sig_cn_org=None source=14.1 
    <para>
     The following caveats apply to partitioning implemented using
     inheritance:
     <itemizedlist>
      <listitem>
       <para>
        There is no automatic way to verify that all of the
        <literal>CHECK</literal> constraints are mutually
        exclusive.  It is safer to create code that generates
        child tables and creates and/or modifies associated objects than
        to write each by hand.
       </para>
      </listitem>

      <listitem>
       <para>
        Indexes and foreign key constraints apply to single tables and not
        to their inheritance children, hence they have some
        <link linkend="ddl-inherit-caveats">caveats</link> to be aware of.
       </para>
      </listitem>

      <listitem>
       <para>
        The schemes shown here assume that the values of a row's key column(s)
        never change, or at least do not change enough to require it to move to another partition.
        An <command>UPDATE</command> that attempts
        to do that will fail because of the <literal>CHECK</literal> constraints.
        If you need to handle such cases, you can put suitable update triggers
        on the child tables, but it makes management of the structure
        much more complicated.
       </para>
      </listitem>

      <listitem>
       <para>
        If you are using manual <command>VACUUM</command> or
        <command>ANALYZE</command> commands, don't forget that
        you need to run them on each child table individually. A command like:
<programlisting>
ANALYZE measurement;
</programlisting>
        will only process the root table.
       </para>
      </listitem>

      <listitem>
       <para>
        <command>INSERT</command> statements with <literal>ON CONFLICT</literal>
        clauses are unlikely to work as expected, as the <literal>ON CONFLICT</literal>
        action is only taken in case of unique violations on the specified
        target relation, not its child relations.
       </para>
      </listitem>

      <listitem>
       <para>
        Triggers or rules will be needed to route rows to the desired
        child table, unless the application is explicitly aware of the
        partitioning scheme.  Triggers may be complicated to write, and will
        be much slower than the tuple routing performed internally by
        declarative partitioning.
       </para>
      </listitem>
     </itemizedlist>
    </para>
________________________________________________________-->
    <para>
     下面的提醒适用于用继承实现的分区：
     <itemizedlist>
      <listitem>
       <para>
        没有自动的方法验证所有的<literal>CHECK</literal>约束之间是否互斥。编写代码来产生子表以及创建和修改相关对象比手写命令要更加安全。
       </para>
      </listitem>

      <listitem>
       <para>
        索引和外键约束适用于单个表而不是其继承子级，因此它们有一些<link linkend="ddl-inherit-caveats">caveats</link> 需要注意。
       </para>
      </listitem>

      <listitem>
       <para>	   
        这里展示的模式假定行的键列值从不改变，或者说改变不足以让行移动到另一个分区。由于<literal>CHECK</literal>约束的存在，尝试那样做的<command>UPDATE</command>将会失败。如果需要处理那种情况，可以在子表上放置适当的更新触发器，但是那会使对结构的管理更加复杂。
       </para>
      </listitem>

      <listitem>
       <para>
        如果使用手工的<command>VACUUM</command>或者<command>ANALYZE</command>命令，不要忘记需要在每个子表上单独运行它们。这样的命令：
<programlisting>
ANALYZE measurement;
</programlisting>
        将只会处理根表。
       </para>
      </listitem>

      <listitem>
       <para>
        带有<literal>ON CONFLICT</literal>子句的<command>INSERT</command>语句不太可能按照预期工作，因为只有在指定的目标关系而不是其子关系上发生唯一违背时才会采取<literal>ON CONFLICT</literal>行动。
       </para>
      </listitem>

      <listitem>
       <para>
        将会需要触发器或者规则将行路由到想要的子表中，除非应用明确地知道分区的模式。编写触发器可能会很复杂，并且会比声明式分区在内部执行的元组路由慢很多。
       </para>
      </listitem>
     </itemizedlist>
    </para>
<!-- pgdoc-cn_end sig_en=6f0b7c1d7b6760db3d2e9761df8c4152 -->
   </sect3>
  </sect2>

  <sect2 id="ddl-partition-pruning">
<!-- pgdoc-cn_start sig_en=67077f4e1eac65abacf12c3c3f53ef4b sig_cn_org=None source=14.1 
   <title>Partition Pruning</title>
________________________________________________________-->
   <title>分区剪枝</title>
<!-- pgdoc-cn_end sig_en=67077f4e1eac65abacf12c3c3f53ef4b -->

<!-- pgdoc-cn_start sig_en=7ce2e33a7c8c80b48b62068408e1fca9 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>partition pruning</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>partition pruning</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=7ce2e33a7c8c80b48b62068408e1fca9 -->

<!-- pgdoc-cn_start sig_en=8ae90499321008b71fa365709eb64d83 sig_cn_org=None source=14.1 
   <para>
    <firstterm>Partition pruning</firstterm> is a query optimization technique
    that improves performance for declaratively partitioned tables.
    As an example:

<programlisting>
SET enable_partition_pruning = on;                 -&minus; the default
SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
</programlisting>

    Without partition pruning, the above query would scan each of the
    partitions of the <structname>measurement</structname> table. With
    partition pruning enabled, the planner will examine the definition
    of each partition and prove that the partition need not
    be scanned because it could not contain any rows meeting the query's
    <literal>WHERE</literal> clause.  When the planner can prove this, it
    excludes (<firstterm>prunes</firstterm>) the partition from the query
    plan.
   </para>
________________________________________________________-->
   <para>
    <firstterm>分区剪枝</firstterm>是一种提升声明式分区表性能的查询优化技术。例如：

<programlisting>
SET enable_partition_pruning = on;                 -&minus; the default
SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
</programlisting>

    如果没有分区剪枝，上面的查询将会扫描<structname>measurement</structname>表的每一个分区。如果启用了分区剪枝，规划器将会检查每个分区的定义并且检验该分区是否因为不包含符合查询<literal>WHERE</literal>子句的行而无需扫描。当规划器可以证实这一点时，它会把分区从查询计划中排除（<firstterm>剪枝</firstterm>）。
   </para>
<!-- pgdoc-cn_end sig_en=8ae90499321008b71fa365709eb64d83 -->

<!-- pgdoc-cn_start sig_en=0726f9cafa01ff748832173a3e04895d sig_cn_org=None source=14.1 
   <para>
    By using the EXPLAIN command and the <xref
    linkend="guc-enable-partition-pruning"/> configuration parameter, it's
    possible to show the difference between a plan for which partitions have
    been pruned and one for which they have not.  A typical unoptimized
    plan for this type of table setup is:
<programlisting>
SET enable_partition_pruning = off;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
                                    QUERY PLAN
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&zwsp;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Aggregate  (cost=188.76..188.77 rows=1 width=8)
   -&gt;  Append  (cost=0.00..181.05 rows=3085 width=0)
         -&gt;  Seq Scan on measurement_y2006m02  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2006m03  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
...
         -&gt;  Seq Scan on measurement_y2007m11  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2007m12  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2008m01  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
</programlisting>

    Some or all of the partitions might use index scans instead of
    full-table sequential scans, but the point here is that there
    is no need to scan the older partitions at all to answer this query.
    When we enable partition pruning, we get a significantly
    cheaper plan that will deliver the same answer:
<programlisting>
SET enable_partition_pruning = on;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
                                    QUERY PLAN
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&zwsp;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Aggregate  (cost=37.75..37.76 rows=1 width=8)
   -&gt;  Seq Scan on measurement_y2008m01  (cost=0.00..33.12 rows=617 width=0)
         Filter: (logdate &gt;= '2008-01-01'::date)
</programlisting>
   </para>
________________________________________________________-->
   <para>
    通过使用EXPLAIN命令和<xref linkend="guc-enable-partition-pruning"/>配置参数，可以展示剪枝掉分区的计划与没有剪枝的计划之间的差别。对这种类型的表设置，一种典型的未优化计划是：
<programlisting>
SET enable_partition_pruning = off;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
                                    QUERY PLAN
-------------------------------------------------------------------&zwsp;----------------
 Aggregate  (cost=188.76..188.77 rows=1 width=8)
   -&gt;  Append  (cost=0.00..181.05 rows=3085 width=0)
         -&gt;  Seq Scan on measurement_y2006m02  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2006m03  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
...
         -&gt;  Seq Scan on measurement_y2007m11  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2007m12  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2008m01  (cost=0.00..33.12 rows=617 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
</programlisting>

    某些或者全部的分区可能会使用索引扫描取代全表顺序扫描，但是这里的重点是根本不需要扫描较老的分区来回答这个查询。当我们启用分区剪枝时，我们会得到一个便宜很多的计划，而它能给出相同的答案：
<programlisting>
SET enable_partition_pruning = on;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
                                    QUERY PLAN
-------------------------------------------------------------------&zwsp;----------------
 Aggregate  (cost=37.75..37.76 rows=1 width=8)
   -&gt;  Seq Scan on measurement_y2008m01  (cost=0.00..33.12 rows=617 width=0)
         Filter: (logdate &gt;= '2008-01-01'::date)
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=0726f9cafa01ff748832173a3e04895d -->

<!-- pgdoc-cn_start sig_en=0180211b7d56997a5144b4f6e1b6f8b3 sig_cn_org=None source=14.1 
   <para>
    Note that partition pruning is driven only by the constraints defined
    implicitly by the partition keys, not by the presence of indexes.
    Therefore it isn't necessary to define indexes on the key columns.
    Whether an index needs to be created for a given partition depends on
    whether you expect that queries that scan the partition will
    generally scan a large part of the partition or just a small part.
    An index will be helpful in the latter case but not the former.
   </para>
________________________________________________________-->
   <para>
    注意，分区剪枝仅由分区键隐式定义的约束所驱动，而不是由索引的存在驱动。因此，没有必要在键列上定义索引。是否需要为一个给定分区创建索引取决于预期的查询扫描该分区时会扫描大部分还是小部分。后一种情况下索引的帮助会比前者大。
   </para>
<!-- pgdoc-cn_end sig_en=0180211b7d56997a5144b4f6e1b6f8b3 -->

<!-- pgdoc-cn_start sig_en=834231ae99c9c148125312015936319d sig_cn_org=None source=14.1 
   <para>
    Partition pruning can be performed not only during the planning of a
    given query, but also during its execution.  This is useful as it can
    allow more partitions to be pruned when clauses contain expressions
    whose values are not known at query planning time, for example,
    parameters defined in a <command>PREPARE</command> statement, using a
    value obtained from a subquery, or using a parameterized value on the
    inner side of a nested loop join.  Partition pruning during execution
    can be performed at any of the following times:

    <itemizedlist>
     <listitem>
      <para>
       During initialization of the query plan.  Partition pruning can be
       performed here for parameter values which are known during the
       initialization phase of execution.  Partitions which are pruned
       during this stage will not show up in the query's
       <command>EXPLAIN</command> or <command>EXPLAIN ANALYZE</command>.
       It is possible to determine the number of partitions which were
       removed during this phase by observing the
       <quote>Subplans Removed</quote> property in the
       <command>EXPLAIN</command> output.
      </para>
     </listitem>

     <listitem>
      <para>
       During actual execution of the query plan.  Partition pruning may
       also be performed here to remove partitions using values which are
       only known during actual query execution.  This includes values
       from subqueries and values from execution-time parameters such as
       those from parameterized nested loop joins.  Since the value of
       these parameters may change many times during the execution of the
       query, partition pruning is performed whenever one of the
       execution parameters being used by partition pruning changes.
       Determining if partitions were pruned during this phase requires
       careful inspection of the <literal>loops</literal> property in
       the <command>EXPLAIN ANALYZE</command> output.  Subplans
       corresponding to different partitions may have different values
       for it depending on how many times each of them was pruned during
       execution.  Some may be shown as <literal>(never executed)</literal>
       if they were pruned every time.
      </para>
     </listitem>
    </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    不仅在给定查询的规划期间可以执行分区剪枝，在其执行期间也能执行分区剪枝。
    这非常有用，因为如果子句中包含查询规划时值未知的表达式时，这可以剪枝掉更多的分区；
    例如在<command>PREPARE</command>语句中定义的参数会使用从子查询拿到的值，或者嵌套循环连接内侧关系上的参数化值。
    执行期间的分区剪枝可能在下列任何时刻执行：

    <itemizedlist>
     <listitem>
      <para>
       在查询计划的初始化期间。对于执行的初始化阶段就已知值的参数，可以在这里执行分区剪枝。这个阶段中被剪枝掉的分区将不会显示在查询的<command>EXPLAIN</command>或<command>EXPLAIN ANALYZE</command>结果中。通过观察<command>EXPLAIN</command>输出的<quote>Subplans Removed</quote>属性，可以确定被剪枝掉的分区数。
      </para>
     </listitem>

     <listitem>
      <para>
       在查询计划的实际执行期间。这里可以使用只有在实际查询执行时才能知道的值执行分区剪枝。这包括来自子查询的值以及来自执行时参数的值（例如来自于参数化嵌套循环连接的参数）。由于在查询执行期间这些参数的值可能会改变多次，所以只要分区剪枝使用到的执行参数发生改变，就会执行一次分区剪枝。要判断分区是否在这个阶段被剪枝，需要仔细地观察<command>EXPLAIN ANALYZE</command>输出中的<literal>loops</literal>属性。
      对应于不同分区的子计划可以具有不同的值，这取决于在执行期间每个分区被修剪的次数。 
      如果每次都被剪枝，有些分区可能会显示为<literal>(never executed)</literal>。
      </para>
     </listitem>
    </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=834231ae99c9c148125312015936319d -->

<!-- pgdoc-cn_start sig_en=eb8eff072104fac7c0d6af9c2827d0f0 sig_cn_org=None source=14.1 
   <para>
    Partition pruning can be disabled using the
    <xref linkend="guc-enable-partition-pruning"/> setting.
   </para>
________________________________________________________-->
   <para>
    可以使用<xref linkend="guc-enable-partition-pruning"/>设置禁用分区剪枝。
   </para>
<!-- pgdoc-cn_end sig_en=eb8eff072104fac7c0d6af9c2827d0f0 -->
  </sect2>

  <sect2 id="ddl-partitioning-constraint-exclusion">
<!-- pgdoc-cn_start sig_en=0cd58f5c04da5e7406e5491b20f0a360 sig_cn_org=None source=14.1 
   <title>Partitioning and Constraint Exclusion</title>
________________________________________________________-->
   <title>分区和约束排除</title>
<!-- pgdoc-cn_end sig_en=0cd58f5c04da5e7406e5491b20f0a360 -->

<!-- pgdoc-cn_start sig_en=a5e9de0750b84f3c0e0dccd15541d426 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>constraint exclusion</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>constraint exclusion</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=a5e9de0750b84f3c0e0dccd15541d426 -->

<!-- pgdoc-cn_start sig_en=999bfe60c6ef571f4c15984ee64e4b5f sig_cn_org=None source=14.1 
   <para>
    <firstterm>Constraint exclusion</firstterm> is a query optimization
    technique similar to partition pruning.  While it is primarily used
    for partitioning implemented using the legacy inheritance method, it can be
    used for other purposes, including with declarative partitioning.
   </para>
________________________________________________________-->
   <para>
    <firstterm>约束排除</firstterm>是一种与分区剪枝类似的查询优化技术。虽然它主要被用于使用传统继承方法实现的分区上，但它也可以被用于其他目的，包括用于声明式分区。
   </para>
<!-- pgdoc-cn_end sig_en=999bfe60c6ef571f4c15984ee64e4b5f -->

<!-- pgdoc-cn_start sig_en=169277107e50bc0e8e1a24fa10b0d41a sig_cn_org=None source=14.1 
   <para>
    Constraint exclusion works in a very similar way to partition
    pruning, except that it uses each table's <literal>CHECK</literal>
    constraints &mdash; which gives it its name &mdash; whereas partition
    pruning uses the table's partition bounds, which exist only in the
    case of declarative partitioning.  Another difference is that
    constraint exclusion is only applied at plan time; there is no attempt
    to remove partitions at execution time.
   </para>
________________________________________________________-->
   <para>
    约束排除以非常类似于分区剪枝的方式工作，不过它使用每个表的<literal>CHECK</literal>约束 &mdash; 这也是它得名的原因 &mdash; 而分区剪枝使用表的分区边界，分区边界仅存在于声明式分区的情况中。另一点不同之处是约束排除仅在规划时应用，在执行时不会尝试移除分区。
   </para>
<!-- pgdoc-cn_end sig_en=169277107e50bc0e8e1a24fa10b0d41a -->

<!-- pgdoc-cn_start sig_en=fc296717b9fe0e2112f76e65df23c9db sig_cn_org=None source=14.1 
   <para>
    The fact that constraint exclusion uses <literal>CHECK</literal>
    constraints, which makes it slow compared to partition pruning, can
    sometimes be used as an advantage: because constraints can be defined
    even on declaratively-partitioned tables, in addition to their internal
    partition bounds, constraint exclusion may be able
    to elide additional partitions from the query plan.
   </para>
________________________________________________________-->
   <para>
    由于约束排除使用<literal>CHECK</literal>约束，这导致它比分区剪枝要慢，但有时候可以被当作一种优点加以利用：因为甚至可以在声明式分区的表上（在分区边界之外）定义约束，约束排除可能可以从查询计划中消去额外的分区。
   </para>
<!-- pgdoc-cn_end sig_en=fc296717b9fe0e2112f76e65df23c9db -->

<!-- pgdoc-cn_start sig_en=dae9309f29d4ae681c41b69bf637ca14 sig_cn_org=None source=14.1 
   <para>
    The default (and recommended) setting of
    <xref linkend="guc-constraint-exclusion"/> is neither
    <literal>on</literal> nor <literal>off</literal>, but an intermediate setting
    called <literal>partition</literal>, which causes the technique to be
    applied only to queries that are likely to be working on inheritance partitioned
    tables.  The <literal>on</literal> setting causes the planner to examine
    <literal>CHECK</literal> constraints in all queries, even simple ones that
    are unlikely to benefit.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="guc-constraint-exclusion"/>的默认（也是推荐的）设置不是<literal>on</literal>也不是<literal>off</literal>，而是一种被称为<literal>partition</literal>的中间设置，这会导致该技术仅被应用于可能工作在继承分区表上的查询。<literal>on</literal>设置导致规划器检查所有查询中的<literal>CHECK</literal>约束，甚至是那些不太可能受益的简单查询。
   </para>
<!-- pgdoc-cn_end sig_en=dae9309f29d4ae681c41b69bf637ca14 -->

<!-- pgdoc-cn_start sig_en=300de0f485de09d65bd8156bbe2b935c sig_cn_org=None source=14.1 
   <para>
    The following caveats apply to constraint exclusion:

   <itemizedlist>
    <listitem>
     <para>
      Constraint exclusion is only applied during query planning, unlike
      partition pruning, which can also be applied during query execution.
     </para>
    </listitem>

    <listitem>
     <para>
      Constraint exclusion only works when the query's <literal>WHERE</literal>
      clause contains constants (or externally supplied parameters).
      For example, a comparison against a non-immutable function such as
      <function>CURRENT_TIMESTAMP</function> cannot be optimized, since the
      planner cannot know which child table the function's value might fall
      into at run time.
     </para>
    </listitem>

    <listitem>
     <para>
      Keep the partitioning constraints simple, else the planner may not be
      able to prove that child tables might not need to be visited.  Use simple
      equality conditions for list partitioning, or simple
      range tests for range partitioning, as illustrated in the preceding
      examples.  A good rule of thumb is that partitioning constraints should
      contain only comparisons of the partitioning column(s) to constants
      using B-tree-indexable operators, because only B-tree-indexable
      column(s) are allowed in the partition key.
     </para>
    </listitem>

    <listitem>
     <para>
      All constraints on all children of the parent table are examined
      during constraint exclusion, so large numbers of children are likely
      to increase query planning time considerably.  So the legacy
      inheritance based partitioning will work well with up to perhaps a
      hundred child tables; don't try to use many thousands of children.
     </para>
    </listitem>

   </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    下列提醒适用于约束排除：

   <itemizedlist>
    <listitem>
     <para>
      约束排除仅适用于查询规划期间，和分区裁剪不同，在查询执行期间也可以应用。
     </para>
    </listitem>

    <listitem>
     <para>
      只有查询的<literal>WHERE</literal>子句包含常量（或者外部提供的参数）时，约束排除才能有效果。例如，针对一个非不变函数（如<function>CURRENT_TIMESTAMP</function>）的比较不能被优化，因为规划器不知道该函数的值在运行时会落到哪个子表中。
     </para>
    </listitem>

    <listitem>
     <para>
      保持分区约束简单化，否则规划器可能无法验证哪些子表可能不需要被访问。如前面的例子所示，对列表分区使用简单的等值条件，对范围分区使用简单的范围测试。一种好的经验规则是分区约束应该仅包含分区列与常量使用B-树的可索引操作符的比较，因为只有B-树的可索引列才允许出现在分区键中。
     </para>
    </listitem>

    <listitem>
     <para>
      约束排除期间会检查父表的所有子表上的所有约束，因此大量的子表很可能明显地增加查询规划时间。因此，传统的基于继承的分区可以很好地处理上百个子表，不要尝试使用上千个子表。
     </para>
    </listitem>

   </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=300de0f485de09d65bd8156bbe2b935c -->
  </sect2>

  <sect2 id="ddl-partitioning-declarative-best-practices">
<!-- pgdoc-cn_start sig_en=cd0183acad48a9d8d2fd2cd5fc363bfd sig_cn_org=None source=14.1 
   <title>Best Practices for Declarative Partitioning</title>
________________________________________________________-->
   <title>声明分区最佳实践</title>
<!-- pgdoc-cn_end sig_en=cd0183acad48a9d8d2fd2cd5fc363bfd -->

<!-- pgdoc-cn_start sig_en=4aec4c43c2b41b6e412b85641ed17835 sig_cn_org=None source=14.1 
   <para>
    The choice of how to partition a table should be made carefully, as the
    performance of query planning and execution can be negatively affected by
    poor design.
   </para>
________________________________________________________-->
   <para>
    应该谨慎地选择如何划分表，因为查询规划和执行的性能可能会受到不良设计的负面影响。
   </para>
<!-- pgdoc-cn_end sig_en=4aec4c43c2b41b6e412b85641ed17835 -->

<!-- pgdoc-cn_start sig_en=3f588b0e51bc8e6e2c2b2deeb7e31dbb sig_cn_org=None source=14.1 
   <para>
    One of the most critical design decisions will be the column or columns
    by which you partition your data.  Often the best choice will be to
    partition by the column or set of columns which most commonly appear in
    <literal>WHERE</literal> clauses of queries being executed on the
    partitioned table.  <literal>WHERE</literal> clauses that are compatible
    with the partition bound constraints can be used to prune unneeded
    partitions.  However, you may be forced into making other decisions by
    requirements for the <literal>PRIMARY KEY</literal> or a
    <literal>UNIQUE</literal> constraint.  Removal of unwanted data is also a
    factor to consider when planning your partitioning strategy.  An entire
    partition can be detached fairly quickly, so it may be beneficial to
    design the partition strategy in such a way that all data to be removed
    at once is located in a single partition.
   </para>
________________________________________________________-->
   <para>
    最重要的设计决策之一是选择对数据进行分区的列或者列的组合。
    通常最佳选择是按最常出现在分区表上执行的查询的 <literal>WHERE</literal>子句中的列或列集合进行分区。
    与分区键匹配并兼容的<literal>WHERE</literal>子句项可用于裁剪不需要的分区。
    但是，你可能会被迫根据<literal>PRIMARY KEY</literal>或<literal>UNIQUE</literal>约束的要求做出其他决策。 
    在规划分区策略时，删除不需要的数据也是需要考虑的一个因素。
    可以相当快地分离整个分区，因此采用这样方式设计分区策略可能是有益的，既把一次删除的所有数据都放在单个分区中。
   </para>
<!-- pgdoc-cn_end sig_en=3f588b0e51bc8e6e2c2b2deeb7e31dbb -->

<!-- pgdoc-cn_start sig_en=32686724bd80d07f54fe68583172a17c sig_cn_org=None source=14.1 
   <para>
    Choosing the target number of partitions that the table should be divided
    into is also a critical decision to make.  Not having enough partitions
    may mean that indexes remain too large and that data locality remains poor
    which could result in low cache hit ratios.  However, dividing the table
    into too many partitions can also cause issues.  Too many partitions can
    mean longer query planning times and higher memory consumption during both
    query planning and execution, as further described below.
    When choosing how to partition your table,
    it's also important to consider what changes may occur in the future.  For
    example, if you choose to have one partition per customer and you
    currently have a small number of large customers, consider the
    implications if in several years you instead find yourself with a large
    number of small customers.  In this case, it may be better to choose to
    partition by <literal>HASH</literal> and choose a reasonable number of
    partitions rather than trying to partition by <literal>LIST</literal> and
    hoping that the number of customers does not increase beyond what it is
    practical to partition the data by.
   </para>
________________________________________________________-->
   <para>
    选择表应该划分的分区的目标数量也是一个重要的决策。
    没有足够的分区可能意味着索引仍然太大，数据位置仍然较差，这可能导致缓存命中率很低。
    但是，将表划分为太多的分区也会导致问题。 在查询规划和执行期间，过多的分区可能意味着查询计划时间较长，内存消耗也更高，见下面进一步的描述。
    在选择如何划分表时，考虑将来可能发生的更改也很重要。
    例如，如果您选择为每个客户提供一个分区，而您目前只有少量的大客户，那么，如果几年后您发现自己有大量的小客户，那么就要考虑这种影响。
    在这种情况下，最好选择按<literal>HASH</literal>分区并且选择合理数量的分区，而不是尝试按 <literal>LIST</literal> 进行分区，并希望客户数量的增长不会超出按数据分区的实际范围。
   </para>
<!-- pgdoc-cn_end sig_en=32686724bd80d07f54fe68583172a17c -->

<!-- pgdoc-cn_start sig_en=2f1a35615d812e03e565d3a69ea4c061 sig_cn_org=None source=14.1 
   <para>
    Sub-partitioning can be useful to further divide partitions that are
    expected to become larger than other partitions.
    Another option is to use range partitioning with multiple columns in
    the partition key.
    Either of these can easily lead to excessive numbers of partitions,
    so restraint is advisable.
   </para>
________________________________________________________-->
   <para>
    子分区有助于进一步划分那些预计会比其他分区更大的分区。另一种选择是使用分区键中有多列的范围分区。这两种情况都很容易导致分区数量过多，因此建议进行限制。
   </para>
<!-- pgdoc-cn_end sig_en=2f1a35615d812e03e565d3a69ea4c061 -->

<!-- pgdoc-cn_start sig_en=14871983aaed772d9d80f1c0c8968a5e sig_cn_org=None source=14.1 
   <para>
    It is important to consider the overhead of partitioning during
    query planning and execution.  The query planner is generally able to
    handle partition hierarchies with up to a few thousand partitions fairly
    well, provided that typical queries allow the query planner to prune all
    but a small number of partitions.  Planning times become longer and memory
    consumption becomes higher when more partitions remain after the planner
    performs partition pruning.  Another
    reason to be concerned about having a large number of partitions is that
    the server's memory consumption may grow significantly over
    time, especially if many sessions touch large numbers of partitions.
    That's because each partition requires its metadata to be loaded into the
    local memory of each session that touches it.
   </para>
________________________________________________________-->
   <para>
    考虑查询计划和执行期间的分区开销也很重要。
    查询规划器通常能够很好地处理多达几千个分区的分区层次结构，前提是典型的查询允许查询规划器裁剪除了少量分区之外的所有分区。
    规划器执行分区修剪后保留更多分区时，规划时间会变长，内存消耗会更高。
    担心拥有大量分区的另一个原因是，服务器的内存消耗可能会随着时间的推移而显著增加，特别是如果许多会话接触大量分区。
    这是因为每个分区都需要将其元数据加载到接触它的每个会话的本地内存中。
   </para>
<!-- pgdoc-cn_end sig_en=14871983aaed772d9d80f1c0c8968a5e -->

<!-- pgdoc-cn_start sig_en=552f27b66ace681a48e4ee4677d4c72f sig_cn_org=None source=14.1 
   <para>
    With data warehouse type workloads, it can make sense to use a larger
    number of partitions than with an <acronym>OLTP</acronym> type workload.
    Generally, in data warehouses, query planning time is less of a concern as
    the majority of processing time is spent during query execution.  With
    either of these two types of workload, it is important to make the right
    decisions early, as re-partitioning large quantities of data can be
    painfully slow.  Simulations of the intended workload are often beneficial
    for optimizing the partitioning strategy.  Never just assume that more
    partitions are better than fewer partitions, nor vice-versa.
   </para>
________________________________________________________-->
   <para>
    对于数据仓库类型工作负载，使用比 <acronym>OLTP</acronym> 类型工作负载更多的分区数量很有意义。
    通常，在数据仓库中，查询计划时间不太值得关注，因为大多数处理时间都花在查询执行期间。
    对于这两种类型的工作负载，尽早做出正确的决策非常重要，因为重新分区大量数据可能会非常缓慢。
    模拟预期工作负载通常有利于优化分区策略。永远不要只是假设更多的分区比更少的分区更好，反之亦然。
   </para>
<!-- pgdoc-cn_end sig_en=552f27b66ace681a48e4ee4677d4c72f -->
  </sect2>

 </sect1>

 <sect1 id="ddl-foreign-data">
<!-- pgdoc-cn_start sig_en=a96025440bc3c898446cbb5c696d0ee2 sig_cn_org=None source=14.1 
  <title>Foreign Data</title>
________________________________________________________-->
  <title>外部数据</title>
<!-- pgdoc-cn_end sig_en=a96025440bc3c898446cbb5c696d0ee2 -->

<!-- pgdoc-cn_start sig_en=e27f648545b3bb24cbb2821dbba5d6fa sig_cn_org=None source=14.1 
   <indexterm>
    <primary>foreign data</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>foreign data</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=e27f648545b3bb24cbb2821dbba5d6fa -->
<!-- pgdoc-cn_start sig_en=f446eebf88653dccd0bfc37e3f6e8f4b sig_cn_org=None source=14.1 
   <indexterm>
    <primary>foreign table</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>foreign table</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=f446eebf88653dccd0bfc37e3f6e8f4b -->
<!-- pgdoc-cn_start sig_en=b58629c4281dbf80a7923fedae4da571 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>user mapping</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>user mapping</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=b58629c4281dbf80a7923fedae4da571 -->

<!-- pgdoc-cn_start sig_en=cd6f2b5c35d5511e629d44a1c07d1318 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> implements portions of the SQL/MED
    specification, allowing you to access data that resides outside
    PostgreSQL using regular SQL queries.  Such data is referred to as
    <firstterm>foreign data</firstterm>.  (Note that this usage is not to be confused
    with foreign keys, which are a type of constraint within the database.)
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>实现了部分的SQL/MED规定，允许我们使用普通SQL查询来访问位于PostgreSQL之外的数据。这种数据被称为<firstterm>外部数据</firstterm>（注意这种用法不要和外键混淆，后者是数据库中的一种约束）。
   </para>
<!-- pgdoc-cn_end sig_en=cd6f2b5c35d5511e629d44a1c07d1318 -->

<!-- pgdoc-cn_start sig_en=2cb893fcd1ec83573dfdf04fb9e07080 sig_cn_org=None source=14.1 
   <para>
    Foreign data is accessed with help from a
    <firstterm>foreign data wrapper</firstterm>. A foreign data wrapper is a
    library that can communicate with an external data source, hiding the
    details of connecting to the data source and obtaining data from it.
    There are some foreign data wrappers available as <filename>contrib</filename>
    modules; see <xref linkend="contrib"/>.  Other kinds of foreign data
    wrappers might be found as third party products.  If none of the existing
    foreign data wrappers suit your needs, you can write your own; see <xref
    linkend="fdwhandler"/>.
   </para>
________________________________________________________-->
   <para>
    外部数据可以在一个<firstterm>外部数据包装器</firstterm>的帮助下被访问。一个外部数据包装器是一个库，它可以与一个外部数据源通讯，并隐藏连接到数据源和从它获取数据的细节。在<filename>contrib</filename>模块中有一些外部数据包装器，参见<xref linkend="contrib"/>。其他类型的外部数据包装器可以在第三方产品中找到。如果这些现有的外部数据包装器都不能满足你的需要，可以自己编写一个，参见<xref linkend="fdwhandler"/>。
   </para>
<!-- pgdoc-cn_end sig_en=2cb893fcd1ec83573dfdf04fb9e07080 -->

<!-- pgdoc-cn_start sig_en=3bbeb0ff1c7cddf6076f6c864ddf97e8 sig_cn_org=None source=14.1 
   <para>
    To access foreign data, you need to create a <firstterm>foreign server</firstterm>
    object, which defines how to connect to a particular external data source
    according to the set of options used by its supporting foreign data
    wrapper. Then you need to create one or more <firstterm>foreign
    tables</firstterm>, which define the structure of the remote data. A
    foreign table can be used in queries just like a normal table, but a
    foreign table has no storage in the PostgreSQL server.  Whenever it is
    used, <productname>PostgreSQL</productname> asks the foreign data wrapper
    to fetch data from the external source, or transmit data to the external
    source in the case of update commands.
   </para>
________________________________________________________-->
   <para>
    要访问外部数据，我们需要建立一个<firstterm>外部服务器</firstterm>对象，它根据它所支持的外部数据包装器所使用的一组选项定义了如何连接到一个特定的外部数据源。接着我们需要创建一个或多个<firstterm>外部表</firstterm>，它们定义了外部数据的结构。一个外部表可以在查询中像一个普通表一样地使用，但是在PostgreSQL服务器中外部表没有存储数据。不管使用什么外部数据包装器，<productname>PostgreSQL</productname>会要求外部数据包装器从外部数据源获取数据，或者在更新命令的情况下传送数据到外部数据源。
   </para>
<!-- pgdoc-cn_end sig_en=3bbeb0ff1c7cddf6076f6c864ddf97e8 -->

<!-- pgdoc-cn_start sig_en=eb2c18adda86024af8e8ea797e697229 sig_cn_org=None source=14.1 
   <para>
    Accessing remote data may require authenticating to the external
    data source.  This information can be provided by a
    <firstterm>user mapping</firstterm>, which can provide additional data
    such as user names and passwords based
    on the current <productname>PostgreSQL</productname> role.
   </para>
________________________________________________________-->
   <para>
    访问远程数据可能需要在外部数据源的授权。这些信息通过一个<firstterm>用户映射</firstterm>提供，它基于当前的<productname>PostgreSQL</productname>角色提供了附加的数据例如用户名和密码。
   </para>
<!-- pgdoc-cn_end sig_en=eb2c18adda86024af8e8ea797e697229 -->

<!-- pgdoc-cn_start sig_en=614f74ddbe5658b0c16f97c82c706805 sig_cn_org=None source=14.1 
   <para>
    For additional information, see
    <xref linkend="sql-createforeigndatawrapper"/>,
    <xref linkend="sql-createserver"/>,
    <xref linkend="sql-createusermapping"/>,
    <xref linkend="sql-createforeigntable"/>, and
    <xref linkend="sql-importforeignschema"/>.
   </para>
________________________________________________________-->
   <para>
    更多信息请见
    <xref linkend="sql-createforeigndatawrapper"/>、
    <xref linkend="sql-createserver"/>、
    <xref linkend="sql-createusermapping"/>、
    <xref linkend="sql-createforeigntable"/>、以及
    <xref linkend="sql-importforeignschema"/>。
   </para>
<!-- pgdoc-cn_end sig_en=614f74ddbe5658b0c16f97c82c706805 -->
 </sect1>

 <sect1 id="ddl-others">
<!-- pgdoc-cn_start sig_en=d5297515894f1194261a4fbe1ceae8bd sig_cn_org=None source=14.1 
  <title>Other Database Objects</title>
________________________________________________________-->
  <title>其他数据库对象</title>
<!-- pgdoc-cn_end sig_en=d5297515894f1194261a4fbe1ceae8bd -->

<!-- pgdoc-cn_start sig_en=b7ab444aeba621712f534cd04ca6df67 sig_cn_org=None source=14.1 
  <para>
   Tables are the central objects in a relational database structure,
   because they hold your data.  But they are not the only objects
   that exist in a database.  Many other kinds of objects can be
   created to make the use and management of the data more efficient
   or convenient.  They are not discussed in this chapter, but we give
   you a list here so that you are aware of what is possible:
  </para>
________________________________________________________-->
  <para>
   表是一个关系型数据库结构中的核心对象，因为它们承载了我们的数据。但是它们并不是数据库中的唯一一种对象。有很多其他种类的对象可以被创建来使得数据的使用和刮泥更加方便或高效。在本章中不会讨论它们，但是我们在会给出一个列表：
  </para>
<!-- pgdoc-cn_end sig_en=b7ab444aeba621712f534cd04ca6df67 -->

  <itemizedlist>
   <listitem>
<!-- pgdoc-cn_start sig_en=60cc71aaf39b4d9ce47f687d448dc726 sig_cn_org=None source=14.1 
    <para>
     Views
    </para>
________________________________________________________-->
    <para>
     视图
    </para>
<!-- pgdoc-cn_end sig_en=60cc71aaf39b4d9ce47f687d448dc726 -->
   </listitem>

   <listitem>
<!-- pgdoc-cn_start sig_en=79c24bb2068c093c05cc54f58d6f14e3 sig_cn_org=None source=14.1 
    <para>
     Functions, procedures, and operators
    </para>
________________________________________________________-->
    <para>
     函数、过程和操作符
    </para>
<!-- pgdoc-cn_end sig_en=79c24bb2068c093c05cc54f58d6f14e3 -->
   </listitem>

   <listitem>
<!-- pgdoc-cn_start sig_en=9cda80ed78049332da47d62c4ebb1c17 sig_cn_org=None source=14.1 
    <para>
     Data types and domains
    </para>
________________________________________________________-->
    <para>
     数据类型和域
    </para>
<!-- pgdoc-cn_end sig_en=9cda80ed78049332da47d62c4ebb1c17 -->
   </listitem>

   <listitem>
<!-- pgdoc-cn_start sig_en=f8b5e2433617101881c9466e6e16655d sig_cn_org=None source=14.1 
    <para>
     Triggers and rewrite rules
    </para>
________________________________________________________-->
    <para>
     触发器和重写规则
    </para>
<!-- pgdoc-cn_end sig_en=f8b5e2433617101881c9466e6e16655d -->
   </listitem>
  </itemizedlist>

<!-- pgdoc-cn_start sig_en=78203ed982d143fa6c21270725504dd5 sig_cn_org=None source=14.1 
  <para>
   Detailed information on
   these topics appears in <xref linkend="server-programming"/>.
  </para>
________________________________________________________-->
  <para>
   这些主题的详细信息请见<xref linkend="server-programming"/>。
  </para>
<!-- pgdoc-cn_end sig_en=78203ed982d143fa6c21270725504dd5 -->
 </sect1>

 <sect1 id="ddl-depend">
<!-- pgdoc-cn_start sig_en=106ff37612b7c4d8f2ae787ba1bcb27c sig_cn_org=None source=14.1 
  <title>Dependency Tracking</title>
________________________________________________________-->
  <title>依赖跟踪</title>
<!-- pgdoc-cn_end sig_en=106ff37612b7c4d8f2ae787ba1bcb27c -->

<!-- pgdoc-cn_start sig_en=2106f03ed9f3c234b816693dc12b1273 sig_cn_org=None source=14.1 
  <indexterm zone="ddl-depend">
   <primary>CASCADE</primary>
   <secondary sortas="DROP">with DROP</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="ddl-depend">
   <primary>CASCADE</primary>
   <secondary sortas="DROP">with DROP</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=2106f03ed9f3c234b816693dc12b1273 -->

<!-- pgdoc-cn_start sig_en=b4ed8a32d415a921655588f4a341bd63 sig_cn_org=None source=14.1 
  <indexterm zone="ddl-depend">
   <primary>RESTRICT</primary>
   <secondary sortas="DROP">with DROP</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="ddl-depend">
   <primary>RESTRICT</primary>
   <secondary sortas="DROP">with DROP</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=b4ed8a32d415a921655588f4a341bd63 -->

<!-- pgdoc-cn_start sig_en=672000084cee06429faab1fe00018788 sig_cn_org=None source=14.1 
  <para>
   When you create complex database structures involving many tables
   with foreign key constraints, views, triggers, functions, etc. you
   implicitly create a net of dependencies between the objects.
   For instance, a table with a foreign key constraint depends on the
   table it references.
  </para>
________________________________________________________-->
  <para>
   当我们创建一个涉及到很多具有外键约束、视图、触发器、函数等的表的复杂数据库结构时，我们隐式地创建了一张对象之间的依赖关系网。例如，具有一个外键约束的表依赖于它所引用的表。
  </para>
<!-- pgdoc-cn_end sig_en=672000084cee06429faab1fe00018788 -->

<!-- pgdoc-cn_start sig_en=357d3b223e7031ecc804a815a3d827f0 sig_cn_org=None source=14.1 
  <para>
   To ensure the integrity of the entire database structure,
   <productname>PostgreSQL</productname> makes sure that you cannot
   drop objects that other objects still depend on.  For example,
   attempting to drop the products table we considered in <xref
   linkend="ddl-constraints-fk"/>, with the orders table depending on
   it, would result in an error message like this:
<screen>
DROP TABLE products;

ERROR:  cannot drop table products because other objects depend on it
DETAIL:  constraint orders_product_no_fkey on table orders depends on table products
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
</screen>
   The error message contains a useful hint: if you do not want to
   bother deleting all the dependent objects individually, you can run:
<screen>
DROP TABLE products CASCADE;
</screen>
   and all the dependent objects will be removed, as will any objects
   that depend on them, recursively.  In this case, it doesn't remove
   the orders table, it only removes the foreign key constraint.
   It stops there because nothing depends on the foreign key constraint.
   (If you want to check what <command>DROP ... CASCADE</command> will do,
   run <command>DROP</command> without <literal>CASCADE</literal> and read the
   <literal>DETAIL</literal> output.)
  </para>
________________________________________________________-->
  <para>
   为了保证整个数据库结构的完整性，<productname>PostgreSQL</productname>确保我们无法删除仍然被其他对象依赖的对象。例如，尝试删除<xref linkend="ddl-constraints-fk"/>中的产品表会导致一个如下的错误消息，因为有订单表依赖于产品表：
<screen>
DROP TABLE products;

ERROR:  cannot drop table products because other objects depend on it
DETAIL:  constraint orders_product_no_fkey on table orders depends on table products
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
</screen>
   该错误消息包含了一个有用的提示：如果我们不想一个一个去删除所有的依赖对象，我们可以执行：
<screen>
DROP TABLE products CASCADE;
</screen>
   这样所有的依赖对象将被移除，同样依赖于它们的任何对象也会被递归删除。在这种情况下，订单表不会被移除，但是它的外键约束会被移除。之所以在这里会停下，是因为没有什么依赖着外键约束（如果希望检查<command>DROP ... CASCADE</command>会干什么，运行不带<literal>CASCADE</literal>的<command>DROP</command>并阅读<literal>DETAIL</literal>输出）。
  </para>
<!-- pgdoc-cn_end sig_en=357d3b223e7031ecc804a815a3d827f0 -->

<!-- pgdoc-cn_start sig_en=c054e9e707cb562494a96b0a701aa1dc sig_cn_org=None source=14.1 
  <para>
   Almost all <command>DROP</command> commands in <productname>PostgreSQL</productname> support
   specifying <literal>CASCADE</literal>.  Of course, the nature of
   the possible dependencies varies with the type of the object.  You
   can also write <literal>RESTRICT</literal> instead of
   <literal>CASCADE</literal> to get the default behavior, which is to
   prevent dropping objects that any other objects depend on.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>中的几乎所有<command>DROP</command>命令都支持<literal>CASCADE</literal>。当然，其本质的区别随着对象的类型而不同。我们也可以用<literal>RESTRICT</literal>代替<literal>CASCADE</literal>来获得默认行为，它将阻止删除任何被其他对象依赖的对象。
  </para>
<!-- pgdoc-cn_end sig_en=c054e9e707cb562494a96b0a701aa1dc -->

  <note>
<!-- pgdoc-cn_start sig_en=f44751dc4f5cbe539e7c42a5fac3c330 sig_cn_org=None source=14.1 
   <para>
    According to the SQL standard, specifying either
    <literal>RESTRICT</literal> or <literal>CASCADE</literal> is
    required in a <command>DROP</command> command.  No database system actually
    enforces that rule, but whether the default behavior
    is <literal>RESTRICT</literal> or <literal>CASCADE</literal> varies
    across systems.
   </para>
________________________________________________________-->
   <para>
    根据SQL标准，在<command>DROP</command>命令中指定<literal>RESTRICT</literal>或<literal>CASCADE</literal>是被要求的。但没有哪个数据库系统真正强制了这个规则，但是不同的系统中两种默认行为都是可能的。
   </para>
<!-- pgdoc-cn_end sig_en=f44751dc4f5cbe539e7c42a5fac3c330 -->
  </note>

<!-- pgdoc-cn_start sig_en=04ea1f8ca7b358dfd16cea709ddf09b5 sig_cn_org=None source=14.1 
  <para>
   If a <command>DROP</command> command lists multiple
   objects, <literal>CASCADE</literal> is only required when there are
   dependencies outside the specified group.  For example, when saying
   <literal>DROP TABLE tab1, tab2</literal> the existence of a foreign
   key referencing <literal>tab1</literal> from <literal>tab2</literal> would not mean
   that <literal>CASCADE</literal> is needed to succeed.
  </para>
________________________________________________________-->
  <para>
   如果一个<command>DROP</command>命令列出了多个对象，只有在存在指定对象构成的组之外的依赖关系时才需要<literal>CASCADE</literal>。例如，如果发出命令<literal>DROP TABLE tab1, tab2</literal>且存在从<literal>tab2</literal>到<literal>tab1</literal>的外键引用，那么就不需要<literal>CASCADE</literal>即可成功执行。
  </para>
<!-- pgdoc-cn_end sig_en=04ea1f8ca7b358dfd16cea709ddf09b5 -->

<!-- pgdoc-cn_start sig_en=4baebd2975ef00c53deed03e09f0509f sig_cn_org=db6456247e95f188812b62f5880e1d00 source=15.7 
  <para>
   For a user-defined function or procedure whose body is defined as a string
   literal, <productname>PostgreSQL</productname> tracks
   dependencies associated with the function's externally-visible properties,
   such as its argument and result types, but <emphasis>not</emphasis> dependencies
   that could only be known by examining the function body.  As an example,
   consider this situation:

<programlisting>
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow',
                             'green', 'blue', 'purple');

CREATE TABLE my_colors (color rainbow, note text);

CREATE FUNCTION get_color_note (rainbow) RETURNS text AS
  'SELECT note FROM my_colors WHERE color = $1'
  LANGUAGE SQL;
</programlisting>

   (See <xref linkend="xfunc-sql"/> for an explanation of SQL-language
   functions.)  <productname>PostgreSQL</productname> will be aware that
   the <function>get_color_note</function> function depends on the <type>rainbow</type>
   type: dropping the type would force dropping the function, because its
   argument type would no longer be defined.  But <productname>PostgreSQL</productname>
   will not consider <function>get_color_note</function> to depend on
   the <structname>my_colors</structname> table, and so will not drop the function if
   the table is dropped.  While there are disadvantages to this approach,
   there are also benefits.  The function is still valid in some sense if the
   table is missing, though executing it would cause an error; creating a new
   table of the same name would allow the function to work again.
  </para>
________________________________________________________-->
  <para>
   对于一个将其主体定义为字符串文字的用户定义函数或过程，<productname>PostgreSQL</productname>会跟踪与函数的外部可见属性相关的依赖关系，例如其参数和结果类型，但<emphasis>不会</emphasis>跟踪只有通过检查函数主体才能知道的依赖关系。例如，考虑以下情况：

<programlisting>
CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow',
                             'green', 'blue', 'purple');

CREATE TABLE my_colors (color rainbow, note text);

CREATE FUNCTION get_color_note (rainbow) RETURNS text AS
  'SELECT note FROM my_colors WHERE color = $1'
  LANGUAGE SQL;
</programlisting>

   （请参阅<xref linkend="xfunc-sql"/>以了解SQL语言函数的解释。）<productname>PostgreSQL</productname>将意识到<function>get_color_note</function>函数依赖于<type>rainbow</type>类型：删除该类型将导致删除该函数，因为其参数类型将不再被定义。但<productname>PostgreSQL</productname>不会认为<function>get_color_note</function>依赖于<structname>my_colors</structname>表，因此如果删除表，将不会删除该函数。虽然这种方法有缺点，但也有好处。如果表丢失，该函数在某种意义上仍然有效，尽管执行它会导致错误；创建一个同名的新表将使函数再次正常工作。
  </para>
<!-- pgdoc-cn_end sig_en=4baebd2975ef00c53deed03e09f0509f -->

<!-- pgdoc-cn_start sig_en=5893c7b367409d8e00caff47176a04a6 sig_cn_org=dfac016b2a4e0b823ae9b8cc45344b05 source=15.7 
  <para>
   On the other hand, for a SQL-language function or procedure whose body
   is written in SQL-standard style, the body is parsed at function
   definition time and all dependencies recognized by the parser are
   stored.  Thus, if we write the function above as

<programlisting>
CREATE FUNCTION get_color_note (rainbow) RETURNS text
BEGIN ATOMIC
  SELECT note FROM my_colors WHERE color = $1;
END;
</programlisting>

   then the function's dependency on the <structname>my_colors</structname>
   table will be known and enforced by <command>DROP</command>.
  </para>
________________________________________________________-->
  <para>
   另一方面，对于一个使用SQL标准风格编写的SQL语言函数或过程，其主体在函数定义时被解析，解析器识别的所有依赖关系都被存储。
   因此，如果我们将上面的函数编写为

<programlisting>
CREATE FUNCTION get_color_note (rainbow) RETURNS text
BEGIN ATOMIC
  SELECT note FROM my_colors WHERE color = $1;
END;
</programlisting>

   那么函数对<structname>my_colors</structname>表的依赖关系将被知晓，并由<command>DROP</command>强制执行。
</para>
<!-- pgdoc-cn_end sig_en=5893c7b367409d8e00caff47176a04a6 -->
 </sect1>

</chapter>
