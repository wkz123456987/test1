<!-- doc/src/sgml/features.sgml -->

<appendix id="features">
<!-- pgdoc-cn_start sig_en=daa33911e60da867dd4552545ea177e1 sig_cn_org=None source=14.1 
 <title>SQL Conformance</title>
________________________________________________________-->
 <title>SQL 符合性</title>
<!-- pgdoc-cn_end sig_en=daa33911e60da867dd4552545ea177e1 -->

<!-- pgdoc-cn_start sig_en=6d82021de76a5a6ce6a0642cc692a057 sig_cn_org=None source=14.1 
 <para>
  This section attempts to outline to what extent
  <productname>PostgreSQL</productname> conforms to the current SQL
  standard.  The following information is not a full statement of
  conformance, but it presents the main topics in as much detail as is
  both reasonable and useful for users.
 </para>
________________________________________________________-->
 <para>
  这一节尝试勾勒出<productname>PostgreSQL</productname>与当前 SQL 标准相符合的范围。下面的信息并不是符合性的完整说明，但是它尽可能详细地表达了对用户合理且有用的主要主题。
 </para>
<!-- pgdoc-cn_end sig_en=6d82021de76a5a6ce6a0642cc692a057 -->

<!-- pgdoc-cn_start sig_en=60e45efd3d953915e74bc6ec909c9d54 sig_cn_org=None source=14.1 
 <para>
  The formal name of the SQL standard is ISO/IEC 9075 <quote>Database
  Language SQL</quote>.  A revised version of the standard is released
  from time to time; the most recent update appearing in 2016.
  The 2016 version is referred to as ISO/IEC 9075:2016, or simply as SQL:2016.
  The versions prior to that were SQL:2011, SQL:2008, SQL:2006, SQL:2003,
  SQL:1999, and SQL-92.  Each version
  replaces the previous one, so claims of conformance to earlier
  versions have no official merit.
  <productname>PostgreSQL</productname> development aims for
  conformance with the latest official version of the standard where
  such conformance does not contradict traditional features or common
  sense.  Many of the features required by the SQL
  standard are supported, though sometimes with slightly differing
  syntax or function.  Further moves towards conformance can be
  expected over time.
 </para>
________________________________________________________-->
 <para>
  SQL 标准的正式名称是 ISO/IEC 9075 <quote>数据库语言 SQL</quote>。该标准会不时地发布一个修改的版本，最近一次更新出现在 2016 年。2016年的版本被称为 ISO/IEC 9075:2016，或者简单地为 SQL:2016。之前的版本是 SQL:2011，SQL:2008，SQL:2006，SQL:2003，SQL:1999 和 SQL-92。每一个版本会替换之前的一个版本，因此声称与早前的版本相符合没有意义。<productname>PostgreSQL</productname>的开发希望与该标准的最新官方版本相符，并且这种符合不会与额外特性或尝试相冲突。很多 SQL 标准所要求的特性都被支持，不过有时在语法或函数上有所不同。随着时间的推移，符合性会得到进一步的提高。
 </para>
<!-- pgdoc-cn_end sig_en=60e45efd3d953915e74bc6ec909c9d54 -->

<!-- pgdoc-cn_start sig_en=f681a51a979c1df5fdd9844dc4ba3577 sig_cn_org=None source=14.1 
 <para>
  <acronym>SQL-92</acronym> defined three feature sets for
  conformance: Entry, Intermediate, and Full.  Most database
  management systems claiming <acronym>SQL</acronym> standard
  conformance were conforming at only the Entry level, since the
  entire set of features in the Intermediate and Full levels was
  either too voluminous or in conflict with legacy behaviors.
 </para>
________________________________________________________-->
 <para>
  <acronym>SQL-92</acronym>为符合性定义了三个特性集：入口、中间和完整。大部分号称<acronym>SQL</acronym>标准符合的数据库管理系统只是在入口级别上的符合，因为中间和完整级别的整个特性集合要么太多要么与遗留行为冲突。
 </para>
<!-- pgdoc-cn_end sig_en=f681a51a979c1df5fdd9844dc4ba3577 -->

<!-- pgdoc-cn_start sig_en=2ec7ebbe6bf2cda11b70e3be7f97c035 sig_cn_org=None source=14.1 
 <para>
  Starting with <acronym>SQL:1999</acronym>, the SQL standard defines
  a large set of individual features rather than the ineffectively
  broad three levels found in <acronym>SQL-92</acronym>.  A large
  subset of these features represents the <quote>Core</quote>
  features, which every conforming SQL implementation must supply.
  The rest of the features are purely optional.
 </para>
________________________________________________________-->
 <para>
  从<acronym>SQL:1999</acronym>开始，SQL 标准定义了一个大型的个体特性集合，而没有无用地拓宽<acronym>SQL-92</acronym>中的三个级别。
  这些特性中的一个大型子集代表<quote>核心</quote>特性，每一个符合 SQL 的实现都必须提供。剩下的特性纯粹是可选的。
 </para>
<!-- pgdoc-cn_end sig_en=2ec7ebbe6bf2cda11b70e3be7f97c035 -->

<!-- pgdoc-cn_start sig_en=6767481fa7d6a50752c7c60ecded041e sig_cn_org=None source=14.1 
 <para>
  The standard versions beginning with <acronym>SQL:2003</acronym>
  are also split into a number
  of parts.  Each is known by a shorthand name.  Note that these parts
  are not consecutively numbered.

  <itemizedlist>
   <listitem><para>ISO/IEC 9075-1 Framework (SQL/Framework)</para><indexterm><primary>SQL/Framework</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-2 Foundation (SQL/Foundation)</para><indexterm><primary>SQL/Foundation</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-3 Call Level Interface (SQL/CLI)</para><indexterm><primary>SQL/CLI</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-4 Persistent Stored Modules (SQL/PSM)</para><indexterm><primary>SQL/PSM</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-9 Management of External Data (SQL/MED)</para><indexterm><primary>SQL/MED</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-10 Object Language Bindings (SQL/OLB)</para><indexterm><primary>SQL/OLB</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-11 Information and Definition Schemas (SQL/Schemata)</para><indexterm><primary>SQL/Schemata</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-13 Routines and Types using the Java Language (SQL/JRT)</para><indexterm><primary>SQL/JRT</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-14 XML-related specifications (SQL/XML)</para><indexterm><primary>SQL/XML</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-15 Multi-dimensional arrays (SQL/MDA)</para><indexterm><primary>SQL/MDA</primary></indexterm></listitem>
  </itemizedlist>
 </para>
________________________________________________________-->
 <para>
  从<acronym>SQL:2003</acronym>开始的标准版本也被划分成数个部分。每一个部分有一个速记名。注意这些部分不是连续编号。

  <itemizedlist>
   <listitem><para>ISO/IEC 9075-1 Framework (SQL/Framework)</para><indexterm><primary>SQL/Framework</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-2 Foundation (SQL/Foundation)</para><indexterm><primary>SQL/Foundation</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-3 Call Level Interface (SQL/CLI)</para><indexterm><primary>SQL/CLI</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-4 Persistent Stored Modules (SQL/PSM)</para><indexterm><primary>SQL/PSM</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-9 Management of External Data (SQL/MED)</para><indexterm><primary>SQL/MED</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-10 Object Language Bindings (SQL/OLB)</para><indexterm><primary>SQL/OLB</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-11 Information and Definition Schemas (SQL/Schemata)</para><indexterm><primary>SQL/Schemata</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-13 Routines and Types using the Java Language (SQL/JRT)</para><indexterm><primary>SQL/JRT</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-14 XML-related specifications (SQL/XML)</para><indexterm><primary>SQL/XML</primary></indexterm></listitem>
   <listitem><para>ISO/IEC 9075-15 Multi-dimensional arrays (SQL/MDA)</para><indexterm><primary>SQL/MDA</primary></indexterm></listitem>
  </itemizedlist>
 </para>
<!-- pgdoc-cn_end sig_en=6767481fa7d6a50752c7c60ecded041e -->

<!-- pgdoc-cn_start sig_en=a9fb3fd651c91a2b7bd552b43c20ab56 sig_cn_org=None source=14.1 
 <para>
  The <productname>PostgreSQL</productname> core covers parts 1, 2, 9,
  11, and 14.  Part 3 is covered by the ODBC driver, and part 13 is
  covered by the PL/Java plug-in, but exact conformance is currently
  not being verified for these components.  There are currently no
  implementations of parts 4, 10, and 15
  for <productname>PostgreSQL</productname>.
 </para>
________________________________________________________-->
 <para>
  <productname>PostgreSQL</productname>核心覆盖了部分 1、2、9、11 和 14。
  部分 3 被 ODBC 驱动所覆盖，并且部分 13 被 PL/Java 插件所覆盖，但是目前准确的符合性还没有在这些组件上被验证。
  目前对于<productname>PostgreSQL</productname>没有4、10和15部分的实现。
 </para>
<!-- pgdoc-cn_end sig_en=a9fb3fd651c91a2b7bd552b43c20ab56 -->

<!-- pgdoc-cn_start sig_en=7e94ea4dc0da25e3f9eead4bea05304c sig_cn_org=None source=14.1 
 <para>
  PostgreSQL supports most of the major features of SQL:2016.  Out of
  177 mandatory features required for full Core conformance,
  PostgreSQL conforms to at least 170.  In addition, there is a long
  list of supported optional features.  It might be worth noting that at
  the time of writing, no current version of any database management
  system claims full conformance to Core SQL:2016.
 </para>
________________________________________________________-->
 <para>
  PostgreSQL 支持 SQL:2016 的大部分主要特性。在 177 个完整核心符合所要求的强制特性中，PostgreSQL 至少符合 170 个。
  另外，还有一个受支持的可选特性的长长的列表。值得注意的是，在编写此文档时，还没有任何数据库管理系统的当前版本声称完全符合核心的 SQL:2016。
 </para>
<!-- pgdoc-cn_end sig_en=7e94ea4dc0da25e3f9eead4bea05304c -->

<!-- pgdoc-cn_start sig_en=63be6adc61961221dd9f0d8d9f099580 sig_cn_org=None source=14.1 
 <para>
  In the following two sections, we provide a list of those features
  that <productname>PostgreSQL</productname> supports, followed by a
  list of the features defined in <acronym>SQL:2016</acronym> which
  are not yet supported in <productname>PostgreSQL</productname>.
  Both of these lists are approximate: There might be minor details that
  are nonconforming for a feature that is listed as supported, and
  large parts of an unsupported feature might in fact be implemented.
  The main body of the documentation always contains the most accurate
  information about what does and does not work.
 </para>
________________________________________________________-->
 <para>
  在下面的两节中，我们提供了一个<productname>PostgreSQL</productname>所支持特性的列表，以及一个在<acronym>SQL:2016</acronym>中定义却还未被<productname>PostgreSQL</productname>支持的特性的列表。这两个列表都是大概的：对于被列为支持的一个特性可能会有少量的细节不符合，而且大部分未被支持的特性可能事实上已经被实现。本文档的主体部分包含了哪些能用哪些不能用的准确信息。
 </para>
<!-- pgdoc-cn_end sig_en=63be6adc61961221dd9f0d8d9f099580 -->

 <note>
<!-- pgdoc-cn_start sig_en=bcb38dcd52d8ae657e9d97baddff81a2 sig_cn_org=None source=14.1 
  <para>
   Feature codes containing a hyphen are subfeatures.  Therefore, if a
   particular subfeature is not supported, the main feature is listed
   as unsupported even if some other subfeatures are supported.
  </para>
________________________________________________________-->
  <para>
   包含一个连字符的特性编码是子特性。因此，如果一个特定的子特性没有被支持，其主特性被列为未支持，即使其他的子特性都已被支持。
  </para>
<!-- pgdoc-cn_end sig_en=bcb38dcd52d8ae657e9d97baddff81a2 -->
 </note>

  <sect1 id="features-sql-standard">
<!-- pgdoc-cn_start sig_en=5440d789c19b53462b7ae7c791f73403 sig_cn_org=None source=14.1 
   <title>Supported Features</title>
________________________________________________________-->
   <title>已支持特性</title>
<!-- pgdoc-cn_end sig_en=5440d789c19b53462b7ae7c791f73403 -->

<!-- pgdoc-cn_start sig_en=958c9ee572e6062258a84faed671baf2 sig_cn_org=None source=14.1 
   <para>
    <informaltable>
     <tgroup cols="4">
      <colspec colname="col1" colwidth="1.5*"/>
      <colspec colname="col2" colwidth="1*"/>
      <colspec colname="col3" colwidth="7*"/>
      <colspec colname="col4" colwidth="3*"/>
      <thead>
       <row>
        <entry>Identifier</entry>
        <entry>Core?</entry>
        <entry>Description</entry>
        <entry>Comment</entry>
       </row>
      </thead>

      &features-supported;

     </tgroup>
    </informaltable>
   </para>
________________________________________________________-->
   <para>
    <informaltable>
     <tgroup cols="4">
      <colspec colname="col1" colwidth="1.5*"/>
      <colspec colname="col2" colwidth="1*"/>
      <colspec colname="col3" colwidth="7*"/>
      <colspec colname="col4" colwidth="3*"/>
      <thead>
       <row>
        <entry>标识符</entry>
        <entry>核心？</entry>
        <entry>描述</entry>
        <entry>注释</entry>
       </row>
      </thead>

      &features-supported;

     </tgroup>
    </informaltable>
   </para>
<!-- pgdoc-cn_end sig_en=958c9ee572e6062258a84faed671baf2 -->
  </sect1>

  <sect1 id="unsupported-features-sql-standard">
<!-- pgdoc-cn_start sig_en=dcb7c9169c4a1ae76597ca4d1577f023 sig_cn_org=None source=14.1 
   <title>Unsupported Features</title>
________________________________________________________-->
   <title>未支持特性</title>
<!-- pgdoc-cn_end sig_en=dcb7c9169c4a1ae76597ca4d1577f023 -->

<!-- pgdoc-cn_start sig_en=8d6d09169c151e85975f9cf9cb09f972 sig_cn_org=None source=14.1 
   <para>
    The following features defined in <acronym>SQL:2016</acronym> are not
    implemented in this release of
    <productname>PostgreSQL</productname>. In a few cases, equivalent
    functionality is available.

    <informaltable>
     <tgroup cols="4">
      <colspec colname="col1" colwidth="1.5*"/>
      <colspec colname="col2" colwidth="1*"/>
      <colspec colname="col3" colwidth="7*"/>
      <colspec colname="col4" colwidth="3*"/>
      <thead>
       <row>
        <entry>Identifier</entry>
        <entry>Core?</entry>
        <entry>Description</entry>
        <entry>Comment</entry>
       </row>
      </thead>

      &features-unsupported;

     </tgroup>
    </informaltable>
   </para>
________________________________________________________-->
   <para>
    下列定义在<acronym>SQL:2016</acronym>中的特性还没有在这个<productname>PostgreSQL</productname>发行中被实现。在一些情况中，有等效的功能可用。

    <informaltable>
     <tgroup cols="4">
      <colspec colname="col1" colwidth="1.5*"/>
      <colspec colname="col2" colwidth="1*"/>
      <colspec colname="col3" colwidth="7*"/>
      <colspec colname="col4" colwidth="3*"/>
      <thead>
       <row>
        <entry>标识符</entry>
        <entry>核心？</entry>
        <entry>描述</entry>
        <entry>注释</entry>
       </row>
      </thead>

      &features-unsupported;

     </tgroup>
    </informaltable>
   </para>
<!-- pgdoc-cn_end sig_en=8d6d09169c151e85975f9cf9cb09f972 -->
  </sect1>

  <sect1 id="xml-limits-conformance">
<!-- pgdoc-cn_start sig_en=efb17f55b867f9c0d649d36920fd7247 sig_cn_org=None source=14.1 
   <title>XML Limits and Conformance to SQL/XML</title>
________________________________________________________-->
   <title>XML对于SQL的限制和符合性/XML</title>
<!-- pgdoc-cn_end sig_en=efb17f55b867f9c0d649d36920fd7247 -->

<!-- pgdoc-cn_start sig_en=44bc3b338bc410098eae76959a9e8863 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>SQL/XML</primary>
    <secondary>limits and conformance</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>SQL/XML</primary>
    <secondary>限制和符合性</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=44bc3b338bc410098eae76959a9e8863 -->

<!-- pgdoc-cn_start sig_en=584c7882150aeb7a864f073baca9d738 sig_cn_org=None source=14.1 
   <para>
    Significant revisions to the XML-related specifications in ISO/IEC 9075-14
    (SQL/XML) were introduced with SQL:2006.
    <productname>PostgreSQL</productname>'s implementation of the XML data
    type and related functions largely follows the earlier 2003 edition,
    with some borrowing from later editions.  In particular:
    <itemizedlist>
     <listitem>
      <para>
       Where the current standard provides a family of XML data types
       to hold <quote>document</quote> or <quote>content</quote> in
       untyped or XML Schema-typed variants, and a type
       <type>XML(SEQUENCE)</type> to hold arbitrary pieces of XML content,
       <productname>PostgreSQL</productname> provides the single
       <type>xml</type> type, which can hold <quote>document</quote> or
       <quote>content</quote>.  There is no equivalent of the
       standard's <quote>sequence</quote> type.
      </para>
     </listitem>

     <listitem>
      <para>
       <productname>PostgreSQL</productname> provides two functions
       introduced in SQL:2006, but in variants that use the XPath 1.0
       language, rather than XML Query as specified for them in the
       standard.
      </para>
     </listitem>
    </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    ISO/IEC 9075-14中与XML相关的规范进行了重大修订
    (SQL/XML)与SQL:2006一起被引入.
    <productname>PostgreSQL</productname>'s 的XML数据类型和相关函数的实现基本上沿用了2003年的早期版本。有一些借鉴了后来的版本。 特别是:
    <itemizedlist>
     <listitem>
      <para>现行标准提供了一系列可扩展标记语言数据类型，其中将<quote>文档</quote>或<quote>内容</quote>保存在非类型或XML Schema类型的变体，以及类型<type>XML(SEQUENCE)</type>用于保存任意的XML内容片段。
       <productname>PostgreSQL</productname>提供了一个单一的<type>xml</type>类型，可以容纳<quote>文档</quote>或<quote>内容</quote>。 没有相应的标准的<quote>序列</quote>类型。
      </para>
     </listitem>

     <listitem>
      <para>
       <productname>PostgreSQL</productname>提供了两个函数在SQL:2006中引入的，但是在变体中，使用的是XPath 1.0语言，而不是在标准中为其指定的XML查询。
      </para>
     </listitem>
    </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=584c7882150aeb7a864f073baca9d738 -->

<!-- pgdoc-cn_start sig_en=56414129b113939a43984f61f9d2732f sig_cn_org=None source=14.1 
   <para>
    This section presents some of the resulting differences you may encounter.
   </para>
________________________________________________________-->
   <para>    本节介绍了一些你可能会遇到的差异。
   </para>
<!-- pgdoc-cn_end sig_en=56414129b113939a43984f61f9d2732f -->

   <sect2 id="functions-xml-limits-xpath1">
<!-- pgdoc-cn_start sig_en=d916da459b40e1d0478f97fab0d05d2c sig_cn_org=None source=14.1 
    <title>Queries Are Restricted to XPath 1.0</title>
________________________________________________________-->
    <title>查询只限于XPath 1.0</title>
<!-- pgdoc-cn_end sig_en=d916da459b40e1d0478f97fab0d05d2c -->

<!-- pgdoc-cn_start sig_en=4a1a2923fe909bb260ce1781d2195f9f sig_cn_org=None source=14.1 
    <para>
     The <productname>PostgreSQL</productname>-specific functions
     <function>xpath()</function> and <function>xpath_exists()</function>
     query XML documents using the XPath language.
     <productname>PostgreSQL</productname> also provides XPath-only variants
     of the standard functions <function>XMLEXISTS</function> and
     <function>XMLTABLE</function>, which officially use
     the XQuery language. For all of these functions,
     <productname>PostgreSQL</productname> relies on the
     <application>libxml2</application> library, which provides only XPath 1.0.
    </para>
________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>-指定的函数
     <function>xpath()</function> 和 <function>xpath_exists()</function>使用XPath语言查询XML文档。
     <productname>PostgreSQL</productname>也提供了标准函数中的XPath-only变体<function>XMLEXISTS</function>和
     <function>XMLTABLE</function>, 其中正式采用XQuery语言。所有这些函数
     <productname>PostgreSQL</productname>都依赖于<application>libxml2</application> 库，而这个库仅在XPath 1.0中提供。
    </para>
<!-- pgdoc-cn_end sig_en=4a1a2923fe909bb260ce1781d2195f9f -->

<!-- pgdoc-cn_start sig_en=90cfff65c93547fd47ba453f44138e69 sig_cn_org=None source=14.1 
    <para>
     There is a strong connection between the XQuery language and XPath
     versions 2.0 and later: any expression that is syntactically valid and
     executes successfully in both produces the same result (with a minor
     exception for expressions containing numeric character references or
     predefined entity references, which XQuery replaces with the
     corresponding character while XPath leaves them alone).  But there is
     no such connection between these languages and XPath 1.0; it was an
     earlier language and differs in many respects.
    </para>
________________________________________________________-->
    <para>在XQuery语言和XPath 2.0及以后的版本之间有很强的联系：任何语法上有效的表达式，在这两个版本中都能成功地执行，都会产生相同的结果（对于包含数字字符引用或预定义的实体引用的表达式会略有不同，
XQuery会用相应的字符替换，而 XPath则不会。)  但这些语言和XPath 1.0之间没有这种联系，它是一种较早的语言，在很多方面都有区别。
    </para>
<!-- pgdoc-cn_end sig_en=90cfff65c93547fd47ba453f44138e69 -->

<!-- pgdoc-cn_start sig_en=e2b78eafe310aa32425fab7f59c1915c sig_cn_org=None source=14.1 
    <para>
     There are two categories of limitation to keep in mind: the restriction
     from XQuery to XPath for the functions specified in the SQL standard, and
     the restriction of XPath to version 1.0 for both the standard and the
     <productname>PostgreSQL</productname>-specific functions.
    </para>
________________________________________________________-->
    <para>有两类限制需要记住：一是对SQL标准中指定的函数从XQuery到XPath的限制，二是对标准和<productname>PostgreSQL</productname>特定函数XPath的限制是1.0版本 。
    </para>
<!-- pgdoc-cn_end sig_en=e2b78eafe310aa32425fab7f59c1915c -->

    <sect3>
<!-- pgdoc-cn_start sig_en=63e9f1fd0760a9bb3d0ff948ac170f48 sig_cn_org=None source=14.1 
     <title>Restriction of XQuery to XPath</title>
________________________________________________________-->
     <title>XQuery到XPath的限制</title>
<!-- pgdoc-cn_end sig_en=63e9f1fd0760a9bb3d0ff948ac170f48 -->

<!-- pgdoc-cn_start sig_en=67aa656acb827a67d89c3a5b810a3dcc sig_cn_org=None source=14.1 
     <para>
      Features of XQuery beyond those of XPath include:

      <itemizedlist>
       <listitem>
        <para>
         XQuery expressions can construct and return new XML nodes, in
         addition to all possible XPath values.  XPath can create and return
         values of the atomic types (numbers, strings, and so on) but can
         only return XML nodes that were already present in documents
         supplied as input to the expression.
        </para>
       </listitem>

       <listitem>
        <para>
         XQuery has control constructs for iteration, sorting, and grouping.
        </para>
       </listitem>

       <listitem>
        <para>
         XQuery allows declaration and use of local functions.
        </para>
       </listitem>
      </itemizedlist>
     </para>
________________________________________________________-->
     <para>
      除了XPath的特性之外，XQuery的特性还包括:
      <itemizedlist>
       <listitem>
        <para>
         除了所有可能的XPath值之外，XQuery表达式还可以构造和返回新的XML节点。 XPath 可以创建和返回原子类型（数字、字符串等）的值，但只能返回作为表达式输入的文档中已经存在的XML节点。
        </para>
       </listitem>

       <listitem>
        <para>
         XQuery有用于迭代、排序和分组的控制结构。
        </para>
       </listitem>

       <listitem>
        <para>
         XQuery允许声明和使用局部函数。
        </para>
       </listitem>
      </itemizedlist>
     </para>
<!-- pgdoc-cn_end sig_en=67aa656acb827a67d89c3a5b810a3dcc -->

<!-- pgdoc-cn_start sig_en=2061aa54ffd59893052376ab12e3b6b1 sig_cn_org=None source=14.1 
     <para>
      Recent XPath versions begin to offer capabilities overlapping with
      these (such as functional-style <function>for-each</function> and
      <function>sort</function>, anonymous functions, and
      <function>parse-xml</function> to create a node from a string),
      but such features were not available before XPath 3.0.
     </para>
________________________________________________________-->
     <para>
      最近的 XPath 版本开始提供与这些功能重叠的功能（例如函数式的 <function>for-each</function>和<function>sort</function>，匿名函数，以及 <function>parse-xml</function>从字符串中创建节点的<function>parse-xml</function>），但这些功能在 XPath 3.0 之前是不具备的。
     </para>
<!-- pgdoc-cn_end sig_en=2061aa54ffd59893052376ab12e3b6b1 -->
    </sect3>

    <sect3 id="xml-xpath-1-specifics">
<!-- pgdoc-cn_start sig_en=340ef456c3569f90f7918921510cf5a4 sig_cn_org=None source=14.1 
     <title>Restriction of XPath to 1.0</title>
________________________________________________________-->
     <title>对XPath的限制为1.0</title>
<!-- pgdoc-cn_end sig_en=340ef456c3569f90f7918921510cf5a4 -->

<!-- pgdoc-cn_start sig_en=b8a07205b84bc1ba58f95fd3e5b1838d sig_cn_org=None source=14.1 
     <para>
      For developers familiar with XQuery and XPath 2.0 or later, XPath 1.0
      presents a number of differences to contend with:

      <itemizedlist>
       <listitem>
        <para>
         The fundamental type of an XQuery/XPath expression, the
         <type>sequence</type>, which can contain XML nodes, atomic values,
         or both, does not exist in XPath 1.0. A 1.0 expression can only
         produce a node-set (containing zero or more XML nodes), or a single
         atomic value.
        </para>
       </listitem>

       <listitem>
        <para>
          Unlike an XQuery/XPath sequence, which can contain any desired
          items in any desired order, an XPath 1.0 node-set has no
          guaranteed order and, like any set, does not allow multiple
          appearances of the same item.
         <note>
          <para>
           The <application>libxml2</application> library does seem to
           always return node-sets to <productname>PostgreSQL</productname>
           with their members in the same relative order they had in the
           input document.  Its documentation does not commit to this
           behavior, and an XPath 1.0 expression cannot control it.
          </para>
         </note>
        </para>
       </listitem>

       <listitem>
        <para>
         While XQuery/XPath provides all of the types defined in XML Schema
         and many operators and functions over those types, XPath 1.0 has only
         node-sets and the three atomic types <type>boolean</type>,
         <type>double</type>, and <type>string</type>.
        </para>
       </listitem>

       <listitem>
        <para>
         XPath 1.0 has no conditional operator. An XQuery/XPath expression
         such as <literal>if ( hat ) then hat/@size else "no hat"</literal>
         has no XPath 1.0 equivalent.
        </para>
       </listitem>

       <listitem>
        <para>
         XPath 1.0 has no ordering comparison operator for strings. Both
         <literal>"cat" &lt; "dog"</literal> and
         <literal>"cat" &gt; "dog"</literal> are false, because each is a
         numeric comparison of two <literal>NaN</literal>s. In contrast,
         <literal>=</literal> and <literal>!=</literal> do compare the strings
         as strings.
        </para>
       </listitem>

       <listitem>
        <para>
         XPath 1.0 blurs the distinction between
         <firstterm>value comparisons</firstterm> and
         <firstterm>general comparisons</firstterm> as XQuery/XPath define
         them.  Both <literal>sale/@hatsize = 7</literal> and
         <literal>sale/@customer = "alice"</literal> are existentially
         quantified comparisons, true if there is
         any <literal>sale</literal> with the given value for the
         attribute, but <literal>sale/@taxable = false()</literal> is a
         value comparison to the
         <firstterm>effective boolean value</firstterm> of a whole node-set.
         It is true only if no <literal>sale</literal> has
         a <literal>taxable</literal> attribute at all.
        </para>
       </listitem>

       <listitem>
        <para>
         In the XQuery/XPath data model, a <firstterm>document
         node</firstterm> can have either document form (i.e., exactly one
         top-level element, with only comments and processing instructions
         outside of it) or content form (with those constraints
         relaxed). Its equivalent in XPath 1.0, the
         <firstterm>root node</firstterm>, can only be in document form.
         This is part of the reason an <type>xml</type> value passed as the
         context item to any <productname>PostgreSQL</productname>
         XPath-based function must be in document form.
        </para>
       </listitem>
      </itemizedlist>
     </para>
________________________________________________________-->
     <para>
      对于熟悉XQuery和XPath 2.0或更高版本的开发人员来说，XPath 1.0带来了许多不同的地方，需要解决的是:

      <itemizedlist>
       <listitem>
        <para>
         一个XQuery/XPath表达式的基本类型，即 <type>sequence</type>，它可以包含XML节点、原子值或两者，在XPath 1.0中不存在。一个1.0表达式只能产生一个节点集（包含0个或更多的XML节点），或者一个原子值。
        </para>
       </listitem>

       <listitem>
        <para>
          与XQuery/XPath序列不同的是，XPath 1.0节点集没有保证顺序，和任何集一样，不允许同一个项目多次出现。
         <note>
          <para>
           <application>libxml2</application>库似乎总是将节点集返回到<productname>PostgreSQL</productname>的节点集，其成员在输入文档中的相对顺序是一样的。 它的文档并没有承诺这种行为，而且XPath 1.0表达式不能控制它。
          </para>
         </note>
        </para>
       </listitem>

       <listitem>
        <para>
         虽然XQuery/XPath提供了XML Schema中定义的所有类型和许多操作符和函数，但XPath 1.0只有节点集和三种原子类型<type>boolean</type>、<type>double</type>和<type>string</type>。
        </para>
       </listitem>

       <listitem>
        <para>
         XPath 1.0没有条件运算符。一个XQuery/XPath表达式，如<literal>if ( hat ) then hat/@size else "no hat"</literal>没有XPath 1.0的等价物。
        </para>
       </listitem>

       <listitem>
        <para>
         XPath 1.0没有对字符串进行排序比较运算符。<literal>"cat" &lt; "dog"</literal>和<literal>"cat" &gt; "dog"</literal>都是假的，因为每一个都是两个<literal>NaN</literal>的数值比较。相比之下，<literal>=</literal>和<literal>!!=</literal>确实将字符串作为字符串进行比较。
        </para>
       </listitem>

       <listitem>
        <para>
         XPath 1.0模糊了XQuery/XPath定义的<firstterm>值比较</firstterm>和<firstterm>一般比较</firstterm>之间的区别。 <literal>sale/@hatsize = 7</literal>和<literal>sale/@customer = "alice"</literal>都是存在的量化比较，如果有任何<literal>sale</literal>属性的给定值，则为真。但<literal>sale/@taxable = false()</literal>是与整个节点集的<firstterm>有效布尔值</firstterm>的值比较。只有当没有<literal>sale</literal>有一个<literal>taxable</literal>属性时，它才是真值。
        </para>
       </listitem>

       <listitem>
        <para>
         在XQuery/XPath数据模型中，一个<firstterm>文档节点</firstterm>既可以有文档形式（即正好有一个顶层元素，只有注释和处理指令以外的注释和处理指令），也可以有内容形式（放宽了这些限制）。在XPath 1.0中，它的等价物是<firstterm>根节点</firstterm>，只能是文档形式。这也是<type>xml</type>的值被作为 上下文项到任何 <productname>PostgreSQL</productname>的上下文项 基于XPath的函数必须是以文档形式出现。
        </para>
       </listitem>
      </itemizedlist>
     </para>
<!-- pgdoc-cn_end sig_en=b8a07205b84bc1ba58f95fd3e5b1838d -->

<!-- pgdoc-cn_start sig_en=85aef43f77baf37da1e4eb79e5fbbb5a sig_cn_org=None source=14.1 
     <para>
      The differences highlighted here are not all of them. In XQuery and
      the 2.0 and later versions of XPath, there is an XPath 1.0 compatibility
      mode, and the W3C lists of
      <ulink url='https://www.w3.org/TR/2010/REC-xpath-functions-20101214/#xpath1-compatibility'>function library changes</ulink>
      and
      <ulink url='https://www.w3.org/TR/xpath20/#id-backwards-compatibility'>language changes</ulink>
      applied in that mode offer a more complete (but still not exhaustive)
      account of the differences.  The compatibility mode cannot make the
      later languages exactly equivalent to XPath 1.0.
     </para>
________________________________________________________-->
     <para>
      这里强调的区别并不是全部。在XQuery和XPath的2.0及以后的版本中，有一个XPath 1.0的兼容性模式，W3C列出的 <ulink url='https://www.w3.org/TR/2010/REC-xpath-functions-20101214/#xpath1-compatibility'>函数库变化</ulink>和<ulink url='https://www.w3.org/TR/xpath20/#id-backwards-compatibility'>语言变化</ulink>在该模式下应用的列表提供了一个更完整（但仍然不是详尽的）的差异说明。 兼容性模式不能使后来的语言与XPath 1.0完全等同。
     </para>
<!-- pgdoc-cn_end sig_en=85aef43f77baf37da1e4eb79e5fbbb5a -->
    </sect3>

    <sect3 id="functions-xml-limits-casts">
<!-- pgdoc-cn_start sig_en=57c7c5f82a5c4e24d7137353ce0d2459 sig_cn_org=None source=14.1 
     <title>Mappings between SQL and XML Data Types and Values</title>
________________________________________________________-->
     <title>SQL和XML数据类型和值之间的映射</title>
<!-- pgdoc-cn_end sig_en=57c7c5f82a5c4e24d7137353ce0d2459 -->

<!-- pgdoc-cn_start sig_en=1f8a35a3b12b12c098df87956c14ee40 sig_cn_org=None source=14.1 
     <para>
      In SQL:2006 and later, both directions of conversion between standard SQL
      data types and the XML Schema types are specified precisely. However, the
      rules are expressed using the types and semantics of XQuery/XPath, and
      have no direct application to the different data model of XPath 1.0.
     </para>
________________________________________________________-->
     <para>
      在SQL:2006及以后的版本中，标准SQL数据类型和XML Schema类型之间的转换方向都被精确地指定了。但是，这些规则都是用XQuery/XPath的类型和语义来表示的，对于XPath 1.0的不同数据模型没有直接应用。
     </para>
<!-- pgdoc-cn_end sig_en=1f8a35a3b12b12c098df87956c14ee40 -->

<!-- pgdoc-cn_start sig_en=bee847210a0aeedde973d7529906505f sig_cn_org=None source=14.1 
     <para>
      When <productname>PostgreSQL</productname> maps SQL data values to XML
      (as in <function>xmlelement</function>), or XML to SQL (as in the output
      columns of <function>xmltable</function>), except for a few cases
      treated specially, <productname>PostgreSQL</productname> simply assumes
      that the XML data type's XPath 1.0 string form will be valid as the
      text-input form of the SQL datatype, and conversely. This rule has the
      virtue of simplicity while producing, for many data types, results similar
      to the mappings specified in the standard.
     </para>
________________________________________________________-->
     <para>
      当<productname>PostgreSQL</productname>将SQL数据值映射到XML（如<function>xmlelement</function>），或XML映射到SQL（如输出 <function>xmltable</function>的列)，除了少数情况下的  特殊处理，<productname>PostgreSQL</productname>只需假定 XML 数据类型的 XPath 1.0 字符串形式将被视为有效的文本输入形式的SQL数据类型，反之。 该规则的优点是简单，同时对许多数据类型来说，产生的结果与标准中规定的映射类似。
     </para>
<!-- pgdoc-cn_end sig_en=bee847210a0aeedde973d7529906505f -->

<!-- pgdoc-cn_start sig_en=055f79c91d7a055678c3985fe7f986ee sig_cn_org=None source=14.1 
     <para>
      Where interoperability with other systems is a concern, for some data
      types, it may be necessary to use data type formatting functions (such
      as those in <xref linkend="functions-formatting"/>) explicitly to
      produce the standard mappings.
     </para>
________________________________________________________-->
     <para>
      如果与其他系统的互操作性是一个问题，对于某些数据类型，可能需要使用数据类型格式化函数（如<xref linkend="functions-formatting"/>中的函数）来生成标准映射。
     </para>
<!-- pgdoc-cn_end sig_en=055f79c91d7a055678c3985fe7f986ee -->
    </sect3>
   </sect2>

   <sect2 id="functions-xml-limits-postgresql">
<!-- pgdoc-cn_start sig_en=045a741aac65437553572bfe3105be1c sig_cn_org=None source=14.1 
    <title>Incidental Limits of the Implementation</title>
________________________________________________________-->
    <title>实现中的附带限制</title>
<!-- pgdoc-cn_end sig_en=045a741aac65437553572bfe3105be1c -->

<!-- pgdoc-cn_start sig_en=212316e4d41b6e92633b7c8b7b1aaf7f sig_cn_org=None source=14.1 
    <para>
     This section concerns limits that are not inherent in the
     <application>libxml2</application> library, but apply to the current
     implementation in <productname>PostgreSQL</productname>.
    </para>
________________________________________________________-->
    <para>
     本节涉及的限制并不是<application>libxml2</application>库所固有的，而是适用于<productname>PostgreSQL</productname>中的当前实现。
    </para>
<!-- pgdoc-cn_end sig_en=212316e4d41b6e92633b7c8b7b1aaf7f -->

    <sect3>
<!-- pgdoc-cn_start sig_en=eddc43484434fa4870e7408a4da51a15 sig_cn_org=None source=14.1 
     <title>Only <literal>BY VALUE</literal> Passing Mechanism Is Supported</title>
________________________________________________________-->
     <title>仅支持<literal>by VALUE</literal>传递机制</title>
<!-- pgdoc-cn_end sig_en=eddc43484434fa4870e7408a4da51a15 -->

<!-- pgdoc-cn_start sig_en=2518645361070c47331b82c9043dc0f0 sig_cn_org=None source=14.1 
     <para>
      The SQL standard defines two <firstterm>passing mechanisms</firstterm>
      that apply when passing an XML argument from SQL to an XML function or
      receiving a result: <literal>BY REF</literal>, in which a particular XML
      value retains its node identity, and <literal>BY VALUE</literal>, in which
      the content of the XML is passed but node identity is not preserved. A
      mechanism can be specified before a list of parameters, as the default
      mechanism for all of them, or after any parameter, to override the
      default.
     </para>
________________________________________________________-->
     <para>
      SQL标准定义了两种<firstterm>传递机制</firstterm>，适用于从SQL向XML函数传递XML参数或接收结果时。<literal>BY REF</literal>，其中一个特定的XML
值保留其节点身份，以及<literal>BY VALUE</literal>，其中传递XML的内容，但不保留节点身份。可以在参数列表之前指定，作为所有参数的默认机制，也可以在任何参数之后指定，以覆盖默认机制。
     </para>
<!-- pgdoc-cn_end sig_en=2518645361070c47331b82c9043dc0f0 -->

<!-- pgdoc-cn_start sig_en=deb31f78a2911d28163548be05fe063e sig_cn_org=None source=14.1 
     <para>
      To illustrate the difference, if
      <replaceable>x</replaceable> is an XML value, these two queries in
      an SQL:2006 environment would produce true and false, respectively:

<programlisting>
SELECT XMLQUERY('$a is $b' PASSING BY REF <replaceable>x</replaceable> AS a, <replaceable>x</replaceable> AS b NULL ON EMPTY);
SELECT XMLQUERY('$a is $b' PASSING BY VALUE <replaceable>x</replaceable> AS a, <replaceable>x</replaceable> AS b NULL ON EMPTY);
</programlisting>
     </para>
________________________________________________________-->
     <para>
      为了说明区别，如果<replaceable>x</replaceable>是一个XML值，那么在SQL:2006环境下的这两个查询将分别产生true和false。

<programlisting>
SELECT XMLQUERY('$a is $b' PASSING BY REF <replaceable>x</replaceable> AS a, <replaceable>x</replaceable> AS b NULL ON EMPTY);
SELECT XMLQUERY('$a is $b' PASSING BY VALUE <replaceable>x</replaceable> AS a, <replaceable>x</replaceable> AS b NULL ON EMPTY);
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=deb31f78a2911d28163548be05fe063e -->

<!-- pgdoc-cn_start sig_en=4fc03d79c01be66b9cbff862390de0ad sig_cn_org=None source=14.1 
     <para>
      <productname>PostgreSQL</productname> will accept
      <literal>BY VALUE</literal> or <literal>BY REF</literal> in an
      <function>XMLEXISTS</function> or <function>XMLTABLE</function>
      construct, but it ignores them.  The <type>xml</type> data type holds
      a character-string serialized representation, so there is no node
      identity to preserve, and passing is always effectively <literal>BY
      VALUE</literal>.
     </para>
________________________________________________________-->
     <para>
      <productname>PostgreSQL</productname>将在<function>XMLEXISTS</function>或<function>XMLTABLE</function>构造中接受<literal>BY VALUE</literal>或<literal>BY REF</literal>，但它会忽略它们。 <type>xml</type>数据类型持有一个字符串的序列化表示，因此没有节点标识需要保留，并且传递总是有效的<literal>BY VALUE</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=4fc03d79c01be66b9cbff862390de0ad -->
    </sect3>

    <sect3>
<!-- pgdoc-cn_start sig_en=90cf8dcec7c27b04612a866f1593446e sig_cn_org=None source=14.1 
     <title>Cannot Pass Named Parameters to Queries</title>
________________________________________________________-->
     <title>不能将命名的参数传递到查询中</title>
<!-- pgdoc-cn_end sig_en=90cf8dcec7c27b04612a866f1593446e -->

<!-- pgdoc-cn_start sig_en=85d29cc94e13faa184edcdaf25bfbdbb sig_cn_org=None source=14.1 
     <para>
      The XPath-based functions support passing one parameter to serve as the
      XPath expression's context item, but do not support passing additional
      values to be available to the expression as named parameters.
     </para>
________________________________________________________-->
     <para>
      基于 XPath 的函数支持传递一个参数作为 XPath 表达式的上下文项，但不支持传递额外的值作为命名参数提供给表达式。
     </para>
<!-- pgdoc-cn_end sig_en=85d29cc94e13faa184edcdaf25bfbdbb -->
    </sect3>

    <sect3>
<!-- pgdoc-cn_start sig_en=bf6b95ef9ce48f969bce999a41fde179 sig_cn_org=None source=14.1 
     <title>No <type>XML(SEQUENCE)</type> Type</title>
________________________________________________________-->
     <title>无 <type>XML(SEQUENCE)</type>类型</title>
<!-- pgdoc-cn_end sig_en=bf6b95ef9ce48f969bce999a41fde179 -->

<!-- pgdoc-cn_start sig_en=d4836b9662ceea1deca15430f3cb4f63 sig_cn_org=None source=14.1 
     <para>
      The <productname>PostgreSQL</productname> <type>xml</type> data type
      can only hold a value in <literal>DOCUMENT</literal>
      or <literal>CONTENT</literal> form.  An XQuery/XPath expression
      context item must be a single XML node or atomic value, but XPath 1.0
      further restricts it to be only an XML node, and has no node type
      allowing <literal>CONTENT</literal>.  The upshot is that a
      well-formed <literal>DOCUMENT</literal> is the only form of XML value
      that <productname>PostgreSQL</productname> can supply as an XPath
      context item.
     </para>
________________________________________________________-->
     <para>
      <productname>PostgreSQL</productname> <type>xml</type>数据类型只能保存一个值，在<literal>DOCUMENT</literal>或 <literal>CONTENT</literal>形式。 一个XQuery/XPath表达式上下文项必须是一个单一的XML节点或原子值，但XPath 1.0进一步限制它只能是一个XML节点，并且没有允许<literal>CONTENT</literal>的节点类型。 最终的结果是，一个完善的<literal> DOCUMENT </literal>是<productname> PostgreSQL</productname>可以作为XPath上下文项提供的唯一形式的XML值。
     </para>
<!-- pgdoc-cn_end sig_en=d4836b9662ceea1deca15430f3cb4f63 -->
    </sect3>
   </sect2>
  </sect1>

 </appendix>
