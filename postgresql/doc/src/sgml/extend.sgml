<!-- doc/src/sgml/extend.sgml -->

 <chapter id="extend">
<!-- pgdoc-cn_start sig_en=bc17b51f58a05850d8f296dced6a3b44 sig_cn_org=None source=14.1 
  <title>Extending <acronym>SQL</acronym></title>
________________________________________________________-->
  <title>扩展 <acronym>SQL</acronym></title>
<!-- pgdoc-cn_end sig_en=bc17b51f58a05850d8f296dced6a3b44 -->

<!-- pgdoc-cn_start sig_en=f3252d3136229c53746dbd080bb43717 sig_cn_org=None source=14.1 
  <indexterm zone="extend">
   <primary>extending SQL</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="extend">
   <primary>扩展 SQL</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=f3252d3136229c53746dbd080bb43717 -->

<!-- pgdoc-cn_start sig_en=d0836bc363bffb4ca85d3601951e8d20 sig_cn_org=None source=14.1 
  <para>
   In  the  sections  that follow, we will discuss how you
   can extend the <productname>PostgreSQL</productname>
   <acronym>SQL</acronym> query language by adding:

   <itemizedlist spacing="compact" mark="bullet">
    <listitem>
     <para>
      functions (starting in <xref linkend="xfunc"/>)
     </para>
    </listitem>
    <listitem>
     <para>
      aggregates (starting in <xref linkend="xaggr"/>)
     </para>
    </listitem>
    <listitem>
     <para>
      data types (starting in <xref linkend="xtypes"/>)
     </para>
    </listitem>
    <listitem>
     <para>
      operators (starting in <xref linkend="xoper"/>)
     </para>
    </listitem>
    <listitem>
     <para>
      operator classes for indexes (starting in <xref linkend="xindex"/>)
     </para>
    </listitem>
    <listitem>
     <para>
      packages of related objects (starting in <xref linkend="extend-extensions"/>)
     </para>
    </listitem>
   </itemizedlist>
  </para>
________________________________________________________-->
  <para>
   在下面的小节中，我们将讨论如何通过增加各种元素来扩展<productname>PostgreSQL</productname>
   <acronym>SQL</acronym> 查询语言：

   <itemizedlist spacing="compact" mark="bullet">
    <listitem>
     <para>
      函数（从<xref linkend="xfunc"/>开始）
     </para>
    </listitem>
    <listitem>
     <para>
      聚集（从<xref linkend="xaggr"/>开始）
     </para>
    </listitem>
    <listitem>
     <para>
      数据类型（从<xref linkend="xtypes"/>开始）
     </para>
    </listitem>
    <listitem>
     <para>
      操作符（从<xref linkend="xoper"/>开始）
     </para>
    </listitem>
    <listitem>
     <para>
      用于索引的操作符类（从<xref linkend="xindex"/>开始）
     </para>
    </listitem>
    <listitem>
     <para>
      相关对象的包（从<xref linkend="extend-extensions"/>开始）
     </para>
    </listitem>
   </itemizedlist>
  </para>
<!-- pgdoc-cn_end sig_en=d0836bc363bffb4ca85d3601951e8d20 -->

  <sect1 id="extend-how">
<!-- pgdoc-cn_start sig_en=8af035c92a1316cf6db01ebf8b418143 sig_cn_org=None source=14.1 
   <title>How Extensibility Works</title>
________________________________________________________-->
   <title>扩展性如何工作</title>
<!-- pgdoc-cn_end sig_en=8af035c92a1316cf6db01ebf8b418143 -->

<!-- pgdoc-cn_start sig_en=93b203ea1f2df9a4cce0ed4f512a94fc sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> is extensible because its operation  is
    catalog-driven.   If  you  are familiar with standard
    relational database systems, you know that  they  store  information
    about  databases,  tables,  columns,  etc., in what are
    commonly known as system catalogs.  (Some systems  call
    this  the data dictionary.)  The catalogs appear to the
    user as tables like any other, but  the  <acronym>DBMS</acronym>  stores
    its  internal  bookkeeping in them.  One key difference
    between <productname>PostgreSQL</productname> and  standard  relational database systems  is
    that <productname>PostgreSQL</productname> stores much more information in its
    catalogs: not only information about tables and  columns,
    but also information about data types, functions, access
    methods, and so on.  These tables can be  modified  by
    the  user, and since <productname>PostgreSQL</productname> bases its operation
    on these tables, this means that <productname>PostgreSQL</productname> can  be
    extended   by   users.    By  comparison,  conventional
    database systems can only be extended by changing hardcoded
    procedures in the source code or by loading modules
    specially written by the <acronym>DBMS</acronym> vendor.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>是可扩展的，因为它的操作是目录驱动的。如果你熟悉标准的关系型数据库系统，你会知道它们把有关数据库、表、列等的信息存储在众所周知的系统目录中（某些系统称之为数据目录）。目录对于用户来说好像其他的表一样，但是<acronym>DBMS</acronym>把自己的内部信息记录在其中。<productname>PostgreSQL</productname>和标准关系型数据库系统的一个关键不同是<productname>PostgreSQL</productname>在其目录中存储更多信息：不只是有关表和列的信息，还有关于数据类型、函数、访问方法等等的信息。这些表可以被用户修改，并且因为<productname>PostgreSQL</productname>的操作是基于这些表的，所以<productname>PostgreSQL</productname>可以被用户扩展。通过比较，传统数据库系统只能通过在源代码中改变硬编码的过程或者载入由<acronym>DBMS</acronym>提供者特殊编写的模块进行扩展。
   </para>
<!-- pgdoc-cn_end sig_en=93b203ea1f2df9a4cce0ed4f512a94fc -->

<!-- pgdoc-cn_start sig_en=633d7241ba17e278a645c25c2e87f76f sig_cn_org=None source=14.1 
   <para>
    The <productname>PostgreSQL</productname> server can moreover
    incorporate user-written code into itself through dynamic loading.
    That is, the user can specify an object code file (e.g., a shared
    library) that implements a new type or function, and
    <productname>PostgreSQL</productname> will load it as required.
    Code written in <acronym>SQL</acronym> is even more trivial to add
    to the server.  This ability to modify its operation <quote>on the
    fly</quote> makes <productname>PostgreSQL</productname> uniquely
    suited for rapid prototyping of new applications and storage
    structures.
   </para>
________________________________________________________-->
   <para>
    此外，<productname>PostgreSQL</productname>服务器能够通过动态载入把用户编写的代码结合到它自身中。也就是，用户能够指定一个实现了一个新类型或函数的对象代码文件（例如一个共享库），并且<productname>PostgreSQL</productname>将按照要求载入它。把用<acronym>SQL</acronym>编写的代码加入到服务器会更加轻而易举。这种<quote>即时</quote>修改其操作的能力让<productname>PostgreSQL</productname>独特地适合新应用和存储结构的快速原型设计。
   </para>
<!-- pgdoc-cn_end sig_en=633d7241ba17e278a645c25c2e87f76f -->
  </sect1>

  <sect1 id="extend-type-system">
<!-- pgdoc-cn_start sig_en=cebdc479e9a1549b32af86b7f047e112 sig_cn_org=None source=14.1 
   <title>The <productname>PostgreSQL</productname> Type System</title>
________________________________________________________-->
   <title><productname>PostgreSQL</productname>类型系统</title>
<!-- pgdoc-cn_end sig_en=cebdc479e9a1549b32af86b7f047e112 -->

<!-- pgdoc-cn_start sig_en=8dbdf19e28f9df3fb67d30d1da47e213 sig_cn_org=None source=14.1 
   <indexterm zone="extend-type-system">
    <primary>base type</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="extend-type-system">
    <primary>基础类型</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=8dbdf19e28f9df3fb67d30d1da47e213 -->

<!-- pgdoc-cn_start sig_en=b0cd7bf6a0aa6d22c8efc6a74b763a5e sig_cn_org=None source=14.1 
   <indexterm zone="extend-type-system">
    <primary>data type</primary>
    <secondary>base</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="extend-type-system">
    <primary>数据类型</primary>
    <secondary>基础</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=b0cd7bf6a0aa6d22c8efc6a74b763a5e -->

<!-- pgdoc-cn_start sig_en=7f43a274183be2b26a498f783245997a sig_cn_org=None source=14.1 
   <indexterm zone="extend-type-system">
    <primary>composite type</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="extend-type-system">
    <primary>组合类型</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=7f43a274183be2b26a498f783245997a -->

<!-- pgdoc-cn_start sig_en=add98647ed480489850b8ad22195971f sig_cn_org=None source=14.1 
   <indexterm zone="extend-type-system">
    <primary>data type</primary>
    <secondary>composite</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="extend-type-system">
    <primary>数据类型</primary>
    <secondary>组合</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=add98647ed480489850b8ad22195971f -->

<!-- pgdoc-cn_start sig_en=6b296c4eaf9789cbe7b080c9ea1fc733 sig_cn_org=None source=14.1 
   <indexterm zone="extend-type-system">
    <primary>container type</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="extend-type-system">
    <primary>container type</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=6b296c4eaf9789cbe7b080c9ea1fc733 -->

<!-- pgdoc-cn_start sig_en=ca37d83f4dbe1ea40e410d5c1d379035 sig_cn_org=None source=14.1 
   <indexterm zone="extend-type-system">
    <primary>data type</primary>
    <secondary>container</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="extend-type-system">
    <primary>data type</primary>
    <secondary>container</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=ca37d83f4dbe1ea40e410d5c1d379035 -->

<!-- pgdoc-cn_start sig_en=0c28052617bab8c3e655d105346c58c7 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> data types can be divided into base
    types, container types, domains, and pseudo-types.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>数据类型被划分为基础类型、容器类型、域和伪类型。
   </para>
<!-- pgdoc-cn_end sig_en=0c28052617bab8c3e655d105346c58c7 -->

   <sect2>
<!-- pgdoc-cn_start sig_en=77773dd2eaf752943cfff32899266f7c sig_cn_org=None source=14.1 
    <title>Base Types</title>
________________________________________________________-->
    <title>基础类型</title>
<!-- pgdoc-cn_end sig_en=77773dd2eaf752943cfff32899266f7c -->

<!-- pgdoc-cn_start sig_en=040d2924cfe20641d400e45ad8f14200 sig_cn_org=None source=14.1 
    <para>
     Base types are those, like <type>integer</type>, that are
     implemented below the level of the <acronym>SQL</acronym> language
     (typically in a low-level language such as C).  They generally
     correspond to what are often known as abstract data types.
     <productname>PostgreSQL</productname> can only operate on such
     types through functions provided by the user and only understands
     the behavior of such types to the extent that the user describes
     them.
     The built-in base types are described in <xref linkend="datatype"/>.
    </para>
________________________________________________________-->
    <para>
     基础类型是那些被实现在<acronym>SQL</acronym>语言层面之下的类型（通常用一种底层语言，如 C），例如<type>integer</type>。它们通常对应于常说的抽象数据类型。<productname>PostgreSQL</productname>只能通过由用户提供的函数在这类类型上操作，并且只能理解到用户描述这种类型行为的程度。<xref linkend="datatype"/>中描述了内建的基础类型。
    </para>
<!-- pgdoc-cn_end sig_en=040d2924cfe20641d400e45ad8f14200 -->

<!-- pgdoc-cn_start sig_en=a0535ef8dea08e1b3d6df0c8fc119ad7 sig_cn_org=None source=14.1 
    <para>
     Enumerated (enum) types can be considered as a subcategory of base
     types.  The main difference is that they can be created using
     just <acronym>SQL</acronym> commands, without any low-level programming.
     Refer to <xref linkend="datatype-enum"/> for more information.
    </para>
________________________________________________________-->
    <para>
     枚举（enum）类型可以被认为是基础类型的一个子类。主要区别是它们可以使用<acronym>SQL</acronym>命令创建，不需要用到底层的编程。更多信息请参考<xref linkend="datatype-enum"/>。
    </para>
<!-- pgdoc-cn_end sig_en=a0535ef8dea08e1b3d6df0c8fc119ad7 -->
   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=f7479d98487200d668d01515b0aec453 sig_cn_org=None source=14.1 
    <title>Container Types</title>
________________________________________________________-->
    <title>容器类型</title>
<!-- pgdoc-cn_end sig_en=f7479d98487200d668d01515b0aec453 -->

<!-- pgdoc-cn_start sig_en=9f3897dc3d72a0505077419a159b5aa6 sig_cn_org=None source=14.1 
    <para>
     <productname>PostgreSQL</productname> has three kinds
     of <quote>container</quote> types, which are types that contain multiple
     values of other types.  These are arrays, composites, and ranges.
    </para>
________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>有三种<quote>容器</quote>类型，它们是包含多个其他类型值的类型。它们是数组、组合以及范围。
    </para>
<!-- pgdoc-cn_end sig_en=9f3897dc3d72a0505077419a159b5aa6 -->

<!-- pgdoc-cn_start sig_en=5b939543b08b1bed8cc2435decc7e5fe sig_cn_org=None source=14.1 
    <para>
     Arrays can hold multiple values that are all of the same type.  An array
     type is automatically created for each base type, composite type, range
     type, and domain type.  But there are no arrays of arrays.  So far as
     the type system is concerned, multi-dimensional arrays are the same as
     one-dimensional arrays.  Refer to <xref linkend="arrays"/> for more
     information.
    </para>
________________________________________________________-->
    <para>
     数组可以保存全部是同种类型的多个值。为每一种基本类型、组合类型、范围类型以及域类型都会自动创建一个数组类型。但是没有数组的数组。就类型系统的认知而言，多维数组就和一维数组一样。更多信息请参考<xref linkend="arrays"/>。
    </para>
<!-- pgdoc-cn_end sig_en=5b939543b08b1bed8cc2435decc7e5fe -->

<!-- pgdoc-cn_start sig_en=ee36cbd68cbfb290f701fee83b4c7ff7 sig_cn_org=None source=14.1 
    <para>
     Composite types, or row types, are created whenever the user
     creates a table. It is also possible to use <xref
     linkend="sql-createtype"/> to
     define a <quote>stand-alone</quote> composite type with no associated
     table.  A composite type is simply a list of types with
     associated field names.  A value of a composite type is a row or
     record of field values.  Refer to <xref linkend="rowtypes"/>
     for more information.
    </para>
________________________________________________________-->
    <para>
     只要用户创建一个表，就会创建组合类型或者行类型。也可以使用<xref linkend="sql-createtype"/>来定义一个没有关联表的<quote>stand-alone</quote>组合类型。一个组合类型只是一个具有相关域名称的类型列表。一个组合类型的值是一个行或者域值记录。用户可以访问来自<acronym>SQL</acronym>查询的组成域。更多信息请参考<xref linkend="rowtypes"/>。
    </para>
<!-- pgdoc-cn_end sig_en=ee36cbd68cbfb290f701fee83b4c7ff7 -->

<!-- pgdoc-cn_start sig_en=264039d453523b45361e6170c2dc9dfc sig_cn_org=None source=14.1 
    <para>
     A range type can hold two values of the same type, which are the lower
     and upper bounds of the range.  Range types are user-created, although
     a few built-in ones exist.  Refer to <xref linkend="rangetypes"/>
     for more information.
    </para>
________________________________________________________-->
    <para>
     范围类型可以保存同种类型的两个值，它们是该范围的上下界。范围类型是用户创建的，不过也存在一些内建的范围类型。更多信息请参考<xref linkend="rangetypes"/>。
    </para>
<!-- pgdoc-cn_end sig_en=264039d453523b45361e6170c2dc9dfc -->
   </sect2>

   <sect2 id="extend-type-system-domains">
<!-- pgdoc-cn_start sig_en=ee2eacf7f0323f22fcb77610c9eff971 sig_cn_org=None source=14.1 
    <title>Domains</title>
________________________________________________________-->
    <title>域</title>
<!-- pgdoc-cn_end sig_en=ee2eacf7f0323f22fcb77610c9eff971 -->

<!-- pgdoc-cn_start sig_en=33b0ef3d0cd9a6783e26da140dcc251d sig_cn_org=None source=14.1 
    <para>
     A domain is based on a particular underlying type and for many purposes
     is interchangeable with its underlying type.  However, a domain can have
     constraints that restrict its valid values to a subset of what the
     underlying type would allow.  Domains are created using
     the <acronym>SQL</acronym> command <xref linkend="sql-createdomain"/>.
     Refer to <xref linkend="domains"/> for more information.
    </para>
________________________________________________________-->
    <para>
     一个域是基于一种特定底层类型的，并且出于很多目的它可以与其底层类型互换。不过，一个域能够具有约束来限制它的合法值于其底层基础类型允许值的一个子集。可以使用<acronym>SQL</acronym>命令<xref linkend="sql-createdomain"/>创建域。更多信息请参考<xref linkend="domains"/>。
    </para>
<!-- pgdoc-cn_end sig_en=33b0ef3d0cd9a6783e26da140dcc251d -->
   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=1ff242f3573cca9dfa269ccdd9e2b15b sig_cn_org=None source=14.1 
    <title>Pseudo-Types</title>
________________________________________________________-->
    <title>伪类型</title>
<!-- pgdoc-cn_end sig_en=1ff242f3573cca9dfa269ccdd9e2b15b -->

<!-- pgdoc-cn_start sig_en=373b0af23d5ece7bdde25aedff1aa19f sig_cn_org=None source=14.1 
    <para>
     There are a few <quote>pseudo-types</quote> for special purposes.
     Pseudo-types cannot appear as columns of tables or components of
     container types, but they can be used to declare the argument and
     result types of functions.  This provides a mechanism within the
     type system to identify special classes of functions.  <xref
     linkend="datatype-pseudotypes-table"/> lists the existing
     pseudo-types.
    </para>
________________________________________________________-->
    <para>
     有一些用于特殊目的<quote>伪类型</quote>。伪类型不能作为表列或者容器类型的组件出现，但是它们能被用于声明函数的参数和结果类型。这在类型系统中提供了一种机制来标识函数的特殊分类。<xref linkend="datatype-pseudotypes-table"/>列出了现有的伪类型。
    </para>
<!-- pgdoc-cn_end sig_en=373b0af23d5ece7bdde25aedff1aa19f -->
   </sect2>

   <sect2 id="extend-types-polymorphic">
<!-- pgdoc-cn_start sig_en=4c17af668c3f4cddc8859ac18213bd1c sig_cn_org=None source=14.1 
    <title>Polymorphic Types</title>
________________________________________________________-->
    <title>多态类型</title>
<!-- pgdoc-cn_end sig_en=4c17af668c3f4cddc8859ac18213bd1c -->

<!-- pgdoc-cn_start sig_en=1c1fa3b60423f74ad05f11da15626f93 sig_cn_org=None source=14.1 
   <indexterm zone="extend-types-polymorphic">
    <primary>polymorphic type</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="extend-types-polymorphic">
    <primary>多态类型</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=1c1fa3b60423f74ad05f11da15626f93 -->

<!-- pgdoc-cn_start sig_en=5de3f2c83d64671d93ea0021bd264550 sig_cn_org=None source=14.1 
   <indexterm zone="extend-types-polymorphic">
    <primary>polymorphic function</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="extend-types-polymorphic">
    <primary>多态函数</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=5de3f2c83d64671d93ea0021bd264550 -->

<!-- pgdoc-cn_start sig_en=76bd9dced0eadf1fef1f64398feef393 sig_cn_org=None source=14.1 
   <indexterm zone="extend-types-polymorphic">
    <primary>data type</primary>
    <secondary>polymorphic</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="extend-types-polymorphic">
    <primary>数据类型</primary>
    <secondary>多态</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=76bd9dced0eadf1fef1f64398feef393 -->

<!-- pgdoc-cn_start sig_en=67e93ff88fe1f6c0b395ed9935869156 sig_cn_org=None source=14.1 
   <indexterm zone="extend-types-polymorphic">
    <primary>function</primary>
    <secondary>polymorphic</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="extend-types-polymorphic">
    <primary>函数</primary>
    <secondary>多态</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=67e93ff88fe1f6c0b395ed9935869156 -->

<!-- pgdoc-cn_start sig_en=ec37fdfa39ffea53c6ad3bdf48e24495 sig_cn_org=None source=14.1 
    <para>
     Some pseudo-types of special interest are the <firstterm>polymorphic
     types</firstterm>, which are used to declare <firstterm>polymorphic
     functions</firstterm>.  This powerful feature allows a single function
     definition to operate on many different data types, with the specific
     data type(s) being determined by the data types actually passed to it
     in a particular call.  The polymorphic types are shown in
     <xref linkend="extend-types-polymorphic-table"/>.  Some examples of
     their use appear in <xref linkend="xfunc-sql-polymorphic-functions"/>.
    </para>
________________________________________________________-->
    <para>
     特别让人感兴趣的一些伪类型是<firstterm>polymorphic types</firstterm>，用于声明<firstterm>polymorphic functions</firstterm>。
     这种强大的特性允许单个函数定义对许多不同的数据类型进行操作，具体数据类型由特定调用中实际传递给它的数据类型确定。
     多态类型显示在<xref linkend="extend-types-polymorphic-table"/>中。 它们的一些用例出现在 <xref linkend="xfunc-sql-polymorphic-functions"/>里面。 
    </para>
<!-- pgdoc-cn_end sig_en=ec37fdfa39ffea53c6ad3bdf48e24495 -->

    <table id="extend-types-polymorphic-table">
<!-- pgdoc-cn_start sig_en=4c17af668c3f4cddc8859ac18213bd1c sig_cn_org=None source=14.1 
     <title>Polymorphic Types</title>
________________________________________________________-->
     <title>多态类型</title>
<!-- pgdoc-cn_end sig_en=4c17af668c3f4cddc8859ac18213bd1c -->
     <tgroup cols="3">
      <colspec colname="col1" colwidth="2*"/>
      <colspec colname="col2" colwidth="1*"/>
      <colspec colname="col3" colwidth="2*"/>
      <thead>
<!-- pgdoc-cn_start sig_en=5df71cafa5ba90e2dffe0c9dab783cdc sig_cn_org=None source=14.1 
       <row>
        <entry>Name</entry>
        <entry>Family</entry>
        <entry>Description</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>名称</entry>
        <entry>家族</entry>
        <entry>描述</entry>
       </row>
<!-- pgdoc-cn_end sig_en=5df71cafa5ba90e2dffe0c9dab783cdc -->
      </thead>

      <tbody>
<!-- pgdoc-cn_start sig_en=d35c346e7ba62459df613f97469e911b sig_cn_org=None source=14.1 
       <row>
        <entry><type>anyelement</type></entry>
        <entry>Simple</entry>
        <entry>Indicates that a function accepts any data type</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>anyelement</type></entry>
        <entry>Simple</entry>
        <entry>表示函数接受任何数据类型</entry>
       </row>
<!-- pgdoc-cn_end sig_en=d35c346e7ba62459df613f97469e911b -->

<!-- pgdoc-cn_start sig_en=0de56bbf8b0a7f32d62b9e1129f4ac04 sig_cn_org=None source=14.1 
       <row>
        <entry><type>anyarray</type></entry>
        <entry>Simple</entry>
        <entry>Indicates that a function accepts any array data type</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>anyarray</type></entry>
        <entry>Simple</entry>
        <entry>表示函数接受任何数组数据类型</entry>
       </row>
<!-- pgdoc-cn_end sig_en=0de56bbf8b0a7f32d62b9e1129f4ac04 -->

<!-- pgdoc-cn_start sig_en=a727b68893e0366f9ac6565a222835d3 sig_cn_org=None source=14.1 
       <row>
        <entry><type>anynonarray</type></entry>
        <entry>Simple</entry>
        <entry>Indicates that a function accepts any non-array data type</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>anynonarray</type></entry>
        <entry>Simple</entry>
        <entry>表示函数接受任何非数组数据类型</entry>
       </row>
<!-- pgdoc-cn_end sig_en=a727b68893e0366f9ac6565a222835d3 -->

<!-- pgdoc-cn_start sig_en=cca4ceb523ce145db4e34ba1c496e42d sig_cn_org=None source=14.1 
       <row>
        <entry><type>anyenum</type></entry>
        <entry>Simple</entry>
        <entry>Indicates that a function accepts any enum data type
        (see <xref linkend="datatype-enum"/>)
        </entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>anyenum</type></entry>
        <entry>Simple</entry>
        <entry>表示函数接受任何enum数据类型(参见 <xref linkend="datatype-enum"/>)
        </entry>
       </row>
<!-- pgdoc-cn_end sig_en=cca4ceb523ce145db4e34ba1c496e42d -->

<!-- pgdoc-cn_start sig_en=aecc4e6128ef77ac95f87537dc2f5d1f sig_cn_org=None source=14.1 
       <row>
        <entry><type>anyrange</type></entry>
        <entry>Simple</entry>
        <entry>Indicates that a function accepts any range data type
        (see <xref linkend="rangetypes"/>)
        </entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>anyrange</type></entry>
        <entry>Simple</entry>
        <entry>表示函数接受任何范围数据类型(参见 <xref linkend="rangetypes"/>)
        </entry>
       </row>
<!-- pgdoc-cn_end sig_en=aecc4e6128ef77ac95f87537dc2f5d1f -->

<!-- pgdoc-cn_start sig_en=33107c9dd36d72c9582cd1fd8cc11a4e sig_cn_org=None source=14.1 
       <row>
        <entry><type>anymultirange</type></entry>
        <entry>Simple</entry>
        <entry>Indicates that a function accepts any multirange data type
        (see <xref linkend="rangetypes"/>)
        </entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>anymultirange</type></entry>
        <entry>Simple</entry>
        <entry>表示函数接受任何多范围数据类型(参见 <xref linkend="rangetypes"/>)
        </entry>
       </row>
<!-- pgdoc-cn_end sig_en=33107c9dd36d72c9582cd1fd8cc11a4e -->

<!-- pgdoc-cn_start sig_en=703ad72b5e1fd4045ed320682fe6f76f sig_cn_org=None source=14.1 
       <row>
        <entry><type>anycompatible</type></entry>
        <entry>Common</entry>
        <entry>Indicates that a function accepts any data type,
        with automatic promotion of multiple arguments to a common data type
        </entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>anycompatible</type></entry>
        <entry>Common</entry>
        <entry>表示函数接受任何数据类型，并自动将多个参数提升为公共数据类型
        </entry>
       </row>
<!-- pgdoc-cn_end sig_en=703ad72b5e1fd4045ed320682fe6f76f -->

<!-- pgdoc-cn_start sig_en=2c6d38cd608745554cc638b90409a3c2 sig_cn_org=None source=14.1 
       <row>
        <entry><type>anycompatiblearray</type></entry>
        <entry>Common</entry>
        <entry>Indicates that a function accepts any array data type,
        with automatic promotion of multiple arguments to a common data type
        </entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>anycompatiblearray</type></entry>
        <entry>Common</entry>
        <entry>表示函数接受任何数组数据类型，并自动将多个参数提升为公共数据类型
        </entry>
       </row>
<!-- pgdoc-cn_end sig_en=2c6d38cd608745554cc638b90409a3c2 -->

<!-- pgdoc-cn_start sig_en=c4133445be3978b08803ed949dd7f4fb sig_cn_org=None source=14.1 
       <row>
        <entry><type>anycompatiblenonarray</type></entry>
        <entry>Common</entry>
        <entry>Indicates that a function accepts any non-array data type,
        with automatic promotion of multiple arguments to a common data type
        </entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>anycompatiblenonarray</type></entry>
        <entry>Common</entry>
        <entry>表示函数接受任何非数组数据类型，并自动将多个参数提升为公共数据类型
        </entry>
       </row>
<!-- pgdoc-cn_end sig_en=c4133445be3978b08803ed949dd7f4fb -->

<!-- pgdoc-cn_start sig_en=19c56600b2c2317a240c0028ee382aa1 sig_cn_org=None source=14.1 
       <row>
        <entry><type>anycompatiblerange</type></entry>
        <entry>Common</entry>
        <entry>Indicates that a function accepts any range data type,
        with automatic promotion of multiple arguments to a common data type
        </entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>anycompatiblerange</type></entry>
        <entry>Common</entry>
        <entry>表示函数接受任何范围数据类型，并自动将多个参数提升为公共数据类型
        </entry>
       </row>
<!-- pgdoc-cn_end sig_en=19c56600b2c2317a240c0028ee382aa1 -->

<!-- pgdoc-cn_start sig_en=6d299ede95f2aa6405673b6b6d1acbf4 sig_cn_org=None source=14.1 
       <row>
        <entry><type>anycompatiblemultirange</type></entry>
        <entry>Common</entry>
        <entry>Indicates that a function accepts any multirange data type,
        with automatic promotion of multiple arguments to a common data type
        </entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>anycompatiblemultirange</type></entry>
        <entry>Common</entry>
        <entry>表示函数接受任何多范围数据类型，多个参数自动升级到公用数据类型
        </entry>
       </row>
<!-- pgdoc-cn_end sig_en=6d299ede95f2aa6405673b6b6d1acbf4 -->
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=b42176a0e2d8db76b54b79402e03e3f1 sig_cn_org=None source=14.1 
    <para>
     Polymorphic arguments and results are tied to each other and are resolved
     to specific data types when a query calling a polymorphic function is
     parsed.  When there is more than one polymorphic argument, the actual
     data types of the input values must match up as described below.  If the
     function's result type is polymorphic, or it has output parameters of
     polymorphic types, the types of those results are deduced from the
     actual types of the polymorphic inputs as described below.
    </para>
________________________________________________________-->
    <para>
     多态参数和结果是相互关联的，并且它们在解析调用多态函数的查询时被决定到一种特定的数据类型。
     当存在多个多态参数时，输入值的实际数据类型必须匹配如下所述。
     如果函数的结果类型是多态的，或者它具有多态类型的输出参数，则这些结果的类型是根据下面所描述的多态输入的实际类型推导出来的。
    </para>
<!-- pgdoc-cn_end sig_en=b42176a0e2d8db76b54b79402e03e3f1 -->

<!-- pgdoc-cn_start sig_en=6214ac2533b2a5aad0e5d5394d624437 sig_cn_org=None source=14.1 
    <para>
     For the <quote>simple</quote> family of polymorphic types, the
     matching and deduction rules work like this:
    </para>
________________________________________________________-->
    <para>
     对于多态类型的 <quote>simple</quote> 家族, 匹配和推导规则是这样工作的:
    </para>
<!-- pgdoc-cn_end sig_en=6214ac2533b2a5aad0e5d5394d624437 -->

<!-- pgdoc-cn_start sig_en=82dbed5e99127e0e5afe9ad9624186fd sig_cn_org=None source=14.1 
    <para>
     Each position (either argument or return value) declared as
     <type>anyelement</type> is allowed to have any specific actual
     data type, but in any given call they must all be the
     <emphasis>same</emphasis> actual type. Each
     position declared as <type>anyarray</type> can have any array data type,
     but similarly they must all be the same type.  And similarly,
     positions declared as <type>anyrange</type> must all be the same range
     type.  Likewise for <type>anymultirange</type>.
    </para>
________________________________________________________-->
    <para>
     每一个被声明为<type>anyelement</type>的位置（参数或返回值）被允许具有任意特定的实际数据类型，但是在任何给定的查询中它们必须全部是<emphasis>相同</emphasis>的实际类型。
     每一个被声明为<type>anyarray</type>的位置可以有任意数组数据类型，但是相似地，它们必须全部具有相同类型。
     并且类似地，被声明为<type>anyrange</type>的位置必须是全部是相同的范围类型。
     对于<type>anymultirange</type>也是同样的。
    </para>
<!-- pgdoc-cn_end sig_en=82dbed5e99127e0e5afe9ad9624186fd -->

<!-- pgdoc-cn_start sig_en=559de8a9bd9fdaa4c8892f300b324ba6 sig_cn_org=None source=14.1 
    <para>
     Furthermore, if there are
     positions declared <type>anyarray</type> and others declared
     <type>anyelement</type>, the actual array type in the
     <type>anyarray</type> positions must be an array whose elements are
     the same type appearing in the <type>anyelement</type> positions.
     <type>anynonarray</type> is treated exactly the same as <type>anyelement</type>,
     but adds the additional constraint that the actual type must not be
     an array type.
     <type>anyenum</type> is treated exactly the same as <type>anyelement</type>,
     but adds the additional constraint that the actual type must
     be an enum type.
    </para>
________________________________________________________-->
    <para>
     此外，如果有位置被声明为<type>anyarray</type>并且其他位置被声明为<type>anyelement</type>，<type>anyarray</type>位置中的实际数组类型必须是一个数组，该数组的元素都是出现在<type>anyelement</type>位置的同一种类型。
     <type>anynonarray</type>被当做和<type>anyelement</type>相同，但是增加了额外的约束要求实际类型不能是一种数组类型。
     <type>anyenum</type>被当做和<type>anyelement</type>相同，但是增加了额外的约束要求实际类型必须是一种枚举类型。
    </para>
<!-- pgdoc-cn_end sig_en=559de8a9bd9fdaa4c8892f300b324ba6 -->

<!-- pgdoc-cn_start sig_en=488048b693b80abc80d1ef84df0c7ede sig_cn_org=None source=14.1 
    <para>
     Similarly, if there are positions declared <type>anyrange</type>
     and others declared <type>anyelement</type> or <type>anyarray</type>,
     the actual range type in the <type>anyrange</type> positions must be a
     range whose subtype is the same type appearing in
     the <type>anyelement</type> positions and the same as the element type
     of the <type>anyarray</type> positions.
     If there are positions declared <type>anymultirange</type>,
     their actual multirange type must contain ranges matching parameters declared
     <type>anyrange</type> and base elements matching parameters declared
     <type>anyelement</type> and <type>anyarray</type>.
    </para>
________________________________________________________-->
    <para>
     相似地，如果有位置被声明为<type>anyrange</type>并且其他位置被声明为<type>anyelement</type>或<type>anyarray</type>，<type>anyrange</type>位置的实际范围类型必须是一个范围，该范围的子类型是出现在<type>anyelement</type>位置的同一种类型，并且与 <type>anyarray</type> 位置的元素类型相同。
     如果有位置声明为<type>anymultirange</type>，它们的实际多范围类型必须包含匹配<type>anyrange</type>声明参数的范围，并且基本元素匹配参数声明的<type>anyelement</type> 和 <type>anyarray</type>。
    </para>
<!-- pgdoc-cn_end sig_en=488048b693b80abc80d1ef84df0c7ede -->

<!-- pgdoc-cn_start sig_en=13fab212324acd37f4769fe233b1a8c4 sig_cn_org=None source=14.1 
    <para>
     Thus, when more than one argument position is declared with a polymorphic
     type, the net effect is that only certain combinations of actual argument
     types are allowed.  For example, a function declared as
     <literal>equal(anyelement, anyelement)</literal> will take any two input values,
     so long as they are of the same data type.
    </para>
________________________________________________________-->
    <para>
     因此，当使用一种多态类型声明了多于一个参数位置，有效效果是只有实际参数类型的某些组合才被允许。例如，一个被声明为<literal>equal(anyelement, anyelement)</literal>的函数将要求任意两个输入值，只要它们是同一种数据类型。
    </para>
<!-- pgdoc-cn_end sig_en=13fab212324acd37f4769fe233b1a8c4 -->

<!-- pgdoc-cn_start sig_en=07d2c711bcdd4505bc62ce29c5cace42 sig_cn_org=None source=14.1 
    <para>
     When the return value of a function is declared as a polymorphic type,
     there must be at least one argument position that is also polymorphic,
     and the actual data type(s) supplied for the polymorphic arguments
     determine the actual
     result type for that call.  For example, if there were not already
     an array subscripting mechanism, one could define a function that
     implements subscripting as <literal>subscript(anyarray, integer)
     returns anyelement</literal>.  This declaration constrains the actual first
     argument to be an array type, and allows the parser to infer the correct
     result type from the actual first argument's type.  Another example
     is that a function declared as <literal>f(anyarray) returns anyenum</literal>
     will only accept arrays of enum types.
    </para>
________________________________________________________-->
    <para>
     当一个函数的返回值被声明为多态类型时，必须至少有一个参数位置也是多态的，并且为多态参数提供的实际数据类型确定该调用的实际结果类型。
     例如，如果还没有一种数组下标机制，我们可以定义一个函数来实现下标：<literal>subscript(anyarray, integer) returns anyelement</literal>。这个声明约束了实际的第一个参数是一种数组类型，并且允许解析器从实际的第一个参数类型推断正确的结果类型。
     另一个例子是一个被声明为<literal>f(anyarray) returns anyenum</literal>的函数将只接受枚举类型的数组。
    </para>
<!-- pgdoc-cn_end sig_en=07d2c711bcdd4505bc62ce29c5cace42 -->

<!-- pgdoc-cn_start sig_en=ca92e012f3c395cb2c986133ae947105 sig_cn_org=None source=14.1 
    <para>
     In most cases, the parser can infer the actual data type for a
     polymorphic result type from arguments that are of a different
     polymorphic type in the same family; for example <type>anyarray</type>
     can be deduced from <type>anyelement</type> or vice versa.
     An exception is that a
     polymorphic result of type <type>anyrange</type> requires an argument
     of type <type>anyrange</type>; it cannot be deduced
     from <type>anyarray</type> or <type>anyelement</type> arguments.  This
     is because there could be multiple range types with the same subtype.
    </para>
________________________________________________________-->
    <para>
     在大多数情况下，解析器可以从同一家族中不同多态类型的参数推断出多态结果类型的实际数据类型;
     例如，<type>anyarray</type>可以从<type>anyelement</type>推断出来，反之亦然。
     一个例外是，类型<type>anyrange</type> 的多态结果需要类型<type>anyrange</type>的参数;它不能从<type>anyarray</type>或<type>anyelement</type> 参数中推断出来。 
     这是因为可能有多个范围类型具有相同的子类型。
    </para>
<!-- pgdoc-cn_end sig_en=ca92e012f3c395cb2c986133ae947105 -->

<!-- pgdoc-cn_start sig_en=cf0b6082cdddcc9edfd7a4b1c75089fc sig_cn_org=None source=14.1 
    <para>
     Note that <type>anynonarray</type> and <type>anyenum</type> do not represent
     separate type variables; they are the same type as
     <type>anyelement</type>, just with an additional constraint.  For
     example, declaring a function as <literal>f(anyelement, anyenum)</literal>
     is equivalent to declaring it as <literal>f(anyenum, anyenum)</literal>:
     both actual arguments have to be the same enum type.
    </para>
________________________________________________________-->
    <para>
     注意<type>anynonarray</type>和<type>anyenum</type>并不表示独立的类型变量，它们是和<type>anyelement</type>相同的类型，只是有一个额外的约束。例如，将一个函数声明为<literal>f(anyelement, anyenum)</literal>等效于把它声明为<literal>f(anyenum, anyenum)</literal>：两种实际参数必须是相同的枚举类型。
    </para>
<!-- pgdoc-cn_end sig_en=cf0b6082cdddcc9edfd7a4b1c75089fc -->

<!-- pgdoc-cn_start sig_en=9749b2ae70496893fdde62c7deff71e6 sig_cn_org=None source=14.1 
    <para>
     For the <quote>common</quote> family of polymorphic types, the
     matching and deduction rules work approximately the same as for
     the <quote>simple</quote> family, with one major difference: the
     actual types of the arguments need not be identical, so long as they
     can be implicitly cast to a single common type.  The common type is
     selected following the same rules as for <literal>UNION</literal> and
     related constructs (see <xref linkend="typeconv-union-case"/>).
     Selection of the common type considers the actual types
     of <type>anycompatible</type> and <type>anycompatiblenonarray</type>
     inputs, the array element types of <type>anycompatiblearray</type>
     inputs, the range subtypes of <type>anycompatiblerange</type> inputs,
     and the multirange subtypes of <type>anycompatiblemultirange</type>
     inputs.  If <type>anycompatiblenonarray</type> is present then the
     common type is required to be a non-array type.  Once a common type is
     identified, arguments in <type>anycompatible</type>
     and <type>anycompatiblenonarray</type> positions are automatically
     cast to that type, and arguments in <type>anycompatiblearray</type>
     positions are automatically cast to the array type for that type.
    </para>
________________________________________________________-->
    <para>
     对于多态类型的<quote>common</quote>家族，匹配和推断规则工作与<quote>simple</quote>家族相同，有一个主要区别：
     参数的实际类型不需要相同，只要可以隐式地将它们转换为单一的公共类型即可。
     common类型的选择遵循与<literal>UNION</literal>和相关结构相同的规则（参见 <xref linkend="typeconv-union-case"/>）。
     common类型的选择考虑了<type>anycompatible</type>和<type>anycompatiblenonarray</type>输入的实际类型，<type>anycompatiblearray</type>输入的数组元素类型，以及<type>anycompatiblerange</type>输入中的范围子类型，还有<type>anycompatiblemultirange</type>输入的多范围子类型。	  
     如果存在<type>anycompatiblenonarray</type>，那么通用类型必须是非数组类型。
     一旦识别了common类型，<type>anycompatible</type>和<type>anycompatiblenonarray</type>位置中的参数将自动转换到该类型，并且<type>anycompatiblearray</type>位置的参数将自动转换到该类型的数组类型。
    </para>
<!-- pgdoc-cn_end sig_en=9749b2ae70496893fdde62c7deff71e6 -->

<!-- pgdoc-cn_start sig_en=03f1d8e237b06393d895bea427a5f7f6 sig_cn_org=None source=14.1 
    <para>
     Since there is no way to select a range type knowing only its subtype,
     use of <type>anycompatiblerange</type> and/or
     <type>anycompatiblemultirange</type> requires that all arguments declared
     with that type have the same actual range and/or multirange type, and that
     that type's subtype agree with the selected common type, so that no casting
     of the range values is required.  As with <type>anyrange</type> and
     <type>anymultirange</type>, use of <type>anycompatiblerange</type> and
     <type>anymultirange</type> as a function result type requires that there be
     an <type>anycompatiblerange</type> or <type>anycompatiblemultirange</type>
     argument.
    </para>
________________________________________________________-->
    <para>
     因为不可能选择只知道子类型的范围类型，使用<type>anycompatiblerange</type> 和/或<type>anycompatiblemultirange</type> 需要使用该类型声明的所有参数声明具有相同的实际范围和/或多范围类型，
     这种类型的子类型与所选的公共类型一致，这样就不需要对范围值进行强制转换。
     与<type>anyrange</type>和<type>anymultirange</type>一样，使用<type>anycompatiblerange</type>和<type>anymultirange</type>作为函数结果类型需要有一个<type>anycompatiblerange</type>或<type>anycompatiblemultirange</type>参数。
    </para>
<!-- pgdoc-cn_end sig_en=03f1d8e237b06393d895bea427a5f7f6 -->

<!-- pgdoc-cn_start sig_en=278952fa01e483e7aded07372fe8e67c sig_cn_org=None source=14.1 
    <para>
     Notice that there is no <type>anycompatibleenum</type> type.  Such a
     type would not be very useful, since there normally are not any
     implicit casts to enum types, meaning that there would be no way to
     resolve a common type for dissimilar enum inputs.
    </para>
________________________________________________________-->
    <para>
     注意，没有<type>anycompatibleenum</type>类型。
     这样的类型不是很有用，因为通常没有任何隐式的枚举类型的强制转换，这意味着无法为不同的枚举输入解析通用类型。
    </para>
<!-- pgdoc-cn_end sig_en=278952fa01e483e7aded07372fe8e67c -->

<!-- pgdoc-cn_start sig_en=5d80eec52cd07445c8f9ed6827153549 sig_cn_org=None source=14.1 
    <para>
     The <quote>simple</quote> and <quote>common</quote> polymorphic
     families represent two independent sets of type variables.  Consider
     for example
<programlisting>
CREATE FUNCTION myfunc(a anyelement, b anyelement,
                       c anycompatible, d anycompatible)
RETURNS anycompatible AS ...
</programlisting>
     In an actual call of this function, the first two inputs must have
     exactly the same type.  The last two inputs must be promotable to a
     common type, but this type need not have anything to do with the type
     of the first two inputs.  The result will have the common type of the
     last two inputs.
    </para>
________________________________________________________-->
    <para>
     <quote>simple</quote> 和 <quote>common</quote> 多态家族代表两组独立的类型变量。考虑例如
<programlisting>
CREATE FUNCTION myfunc(a anyelement, b anyelement,
                       c anycompatible, d anycompatible)
RETURNS anycompatible AS ...
</programlisting>
     在此函数的实际调用中，前两个输入必须具有完全相同的类型。
     最后两个输入必须提升为一个通用类型，但是这个类型不需要与前两个输入的类型有任何关系。结果将具有最后两个输入的共同类型。
    </para>
<!-- pgdoc-cn_end sig_en=5d80eec52cd07445c8f9ed6827153549 -->

<!-- pgdoc-cn_start sig_en=78b1ec803bcdf32d489530b133ea6b86 sig_cn_org=None source=14.1 
    <para>
     A variadic function (one taking a variable number of arguments, as in
     <xref linkend="xfunc-sql-variadic-functions"/>) can be
     polymorphic: this is accomplished by declaring its last parameter as
     <literal>VARIADIC</literal> <type>anyarray</type> or
     <literal>VARIADIC</literal> <type>anycompatiblearray</type>.
     For purposes of argument
     matching and determining the actual result type, such a function behaves
     the same as if you had written the appropriate number of
     <type>anynonarray</type> or <type>anycompatiblenonarray</type>
     parameters.
    </para>
________________________________________________________-->
    <para>
     一个可变函数（可以有可变数量的参数，如<xref linkend="xfunc-sql-variadic-functions"/>中所述）能够是多态的：
     这可以通过声明其最后一个参数为<literal>VARIADIC</literal> <type>anyarray</type> 或 <literal>VARIADIC</literal> <type>anycompatiblearray</type>来实现。
     为了匹配和决定实际结果类型的参数，这样一种函数的行为和写了合适数量的<type>anynonarray</type> 或 <type>anycompatiblenonarray</type>参数是一样的。
    </para>
<!-- pgdoc-cn_end sig_en=78b1ec803bcdf32d489530b133ea6b86 -->
   </sect2>
  </sect1>

  &xfunc;
  &xaggr;
  &xtypes;
  &xoper;
  &xindex;


  <sect1 id="extend-extensions">
<!-- pgdoc-cn_start sig_en=296d50b1206ab72160144ca106c15e6a sig_cn_org=None source=14.1 
   <title>Packaging Related Objects into an Extension</title>
________________________________________________________-->
   <title>打包相关对象到一个扩展中</title>
<!-- pgdoc-cn_end sig_en=296d50b1206ab72160144ca106c15e6a -->

<!-- pgdoc-cn_start sig_en=f5b2db143c633cccb27a2800fbdfed49 sig_cn_org=None source=14.1 
   <indexterm zone="extend-extensions">
    <primary>extension</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="extend-extensions">
    <primary>扩展</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=f5b2db143c633cccb27a2800fbdfed49 -->

<!-- pgdoc-cn_start sig_en=5728bb947bc168089c8ac8ed56529a23 sig_cn_org=None source=14.1 
   <para>
    A useful extension to <productname>PostgreSQL</productname> typically includes
    multiple SQL objects; for example, a new data type will require new
    functions, new operators, and probably new index operator classes.
    It is helpful to collect all these objects into a single package
    to simplify database management.  <productname>PostgreSQL</productname> calls
    such a package an <firstterm>extension</firstterm>.  To define an extension,
    you need at least a <firstterm>script file</firstterm> that contains the
    <acronym>SQL</acronym> commands to create the extension's objects, and a
    <firstterm>control file</firstterm> that specifies a few basic properties
    of the extension itself.  If the extension includes C code, there
    will typically also be a shared library file into which the C code
    has been built.  Once you have these files, a simple
    <link linkend="sql-createextension"><command>CREATE EXTENSION</command></link> command loads the objects into
    your database.
   </para>
________________________________________________________-->
   <para>
    一个对<productname>PostgreSQL</productname>有用的扩展通常包括多个 SQL 对象，例如，一种新的数据类型将需要新函数、新操作符以及可能的新索引操作符类。
    将所有这些对象收集到一个单一包中有助于简化数据库管理。<productname>PostgreSQL</productname>称这样一个包为一个<firstterm>扩展</firstterm>。
    要定义一个扩展，你至少需要一个包含创建该扩展的对象的<acronym>SQL</acronym>命令的<firstterm>脚本文件</firstterm>以及一个指定扩展本身的一些基本属性的<firstterm>控制文件</firstterm>。
    如果扩展包括 C 代码，通常还有一个 C 代码编译而成的共享库文件。
    一旦你有了这些文件，一个简单的<link linkend="sql-createextension"><command>CREATE EXTENSION</command></link>命令可以把这些对象载入到你的数据库。
   </para>
<!-- pgdoc-cn_end sig_en=5728bb947bc168089c8ac8ed56529a23 -->

<!-- pgdoc-cn_start sig_en=82fbd114d522e4d4b02aa284f719a800 sig_cn_org=None source=14.1 
   <para>
    The main advantage of using an extension, rather than just running the
    <acronym>SQL</acronym> script to load a bunch of <quote>loose</quote> objects
    into your database, is that <productname>PostgreSQL</productname> will then
    understand that the objects of the extension go together.  You can
    drop all the objects with a single <link linkend="sql-dropextension"><command>DROP EXTENSION</command></link>
    command (no need to maintain a separate <quote>uninstall</quote> script).
    Even more useful, <application>pg_dump</application> knows that it should not
    dump the individual member objects of the extension &mdash; it will
    just include a <command>CREATE EXTENSION</command> command in dumps, instead.
    This vastly simplifies migration to a new version of the extension
    that might contain more or different objects than the old version.
    Note however that you must have the extension's control, script, and
    other files available when loading such a dump into a new database.
   </para>
________________________________________________________-->
   <para>
    使用一个扩展而不是只运行<acronym>SQL</acronym>脚本载入一堆<quote>松散</quote>对象到数据库的主要优点是，<productname>PostgreSQL</productname>将能理解该扩展的对象是一起的。
    你可以用一个单一的<link linkend="sql-dropextension"><command>DROP EXTENSION</command></link>命令删除所有的对象（不用维护一个单独的<quote>卸载</quote>脚本）。 
    甚至更有用的一点是，<application>pg_dump</application>知道它不应该转储该扩展中的个体成员对象 &mdash; 它将只在转储中包括一个<command>CREATE EXTENSION</command>命令。
    这大大简化了迁移到一个包含不同于旧版扩展中对象的新版扩展的工作。不过，注意在把这样一个转储载入到一个新数据库时，该扩展的控制、脚本和其他文件必须可用。
   </para>
<!-- pgdoc-cn_end sig_en=82fbd114d522e4d4b02aa284f719a800 -->

<!-- pgdoc-cn_start sig_en=74a8202e1264194969c0dd98d0aa4260 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> will not let you drop an individual object
    contained in an extension, except by dropping the whole extension.
    Also, while you can change the definition of an extension member object
    (for example, via <command>CREATE OR REPLACE FUNCTION</command> for a
    function), bear in mind that the modified definition will not be dumped
    by <application>pg_dump</application>.  Such a change is usually only sensible if
    you concurrently make the same change in the extension's script file.
    (But there are special provisions for tables containing configuration
    data; see <xref linkend="extend-extensions-config-tables"/>.)
    In production situations, it's generally better to create an extension
    update script to perform changes to extension member objects.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>不会让你删除包含在一个扩展中的个体对象，除非删除整个扩展。还有，虽然你能够改变一个扩展的成员对象的定义（例如，通过<command>CREATE OR REPLACE FUNCTION</command>改变一个函数），记住被修改后的定义将不会被<application>pg_dump</application>转储。这种改变通常只有在你并发地在扩展脚本文件中做出相同更改时才有意义（但是对于包含配置数据的表有特殊的规定，见<xref linkend="extend-extensions-config-tables"/>）。在生产环境中，通常更好的方式是创建一个扩展更新脚本来执行对扩展中成员对象的更改。
   </para>
<!-- pgdoc-cn_end sig_en=74a8202e1264194969c0dd98d0aa4260 -->

<!-- pgdoc-cn_start sig_en=0cacac33930ad68443f1bb338de98461 sig_cn_org=None source=14.1 
   <para>
    The extension script may set privileges on objects that are part of the
    extension, using <command>GRANT</command> and <command>REVOKE</command>
    statements.  The final set of privileges for each object (if any are set)
    will be stored in the
    <link linkend="catalog-pg-init-privs"><structname>pg_init_privs</structname></link>
    system catalog.  When <application>pg_dump</application> is used, the
    <command>CREATE EXTENSION</command> command will be included in the dump, followed
    by the set of <command>GRANT</command> and <command>REVOKE</command>
    statements necessary to set the privileges on the objects to what they were
    at the time the dump was taken.
   </para>
________________________________________________________-->
   <para>
    扩展脚本可能会设置扩展中所含对象的特权，使用<command>GRANT</command>和<command>REVOKE</command>语句。
    每一个对象的最终特权集合（如果设置了任何特权）将被存储在<link linkend="catalog-pg-init-privs"><structname>pg_init_privs</structname></link>系统目录中。
    使用<application>pg_dump</application>时，<command>CREATE EXTENSION</command>命令将被包括在转储中，后面会跟着必要的<command>GRANT</command>和<command>REVOKE</command>语句集合来将对象的特权设置成取得该转储时的样子。
   </para>
<!-- pgdoc-cn_end sig_en=0cacac33930ad68443f1bb338de98461 -->

<!-- pgdoc-cn_start sig_en=5b42a36e11a3dcd0dbd0a1c472a86c7c sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> does not currently support extension scripts
    issuing <command>CREATE POLICY</command> or <command>SECURITY LABEL</command>
    statements.  These are expected to be set after the extension has been
    created.  All RLS policies and security labels on extension objects will be
    included in dumps created by <application>pg_dump</application>.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>当前不支持扩展脚本发出<command>CREATE POLICY</command>或者<command>SECURITY LABEL</command>语句。这些东西的设置应该在扩展被创建好之后来进行。所有在扩展对象上创建的 RLS 策略和安全标签都将被包括在<application>pg_dump</application>创建的转储中。
   </para>
<!-- pgdoc-cn_end sig_en=5b42a36e11a3dcd0dbd0a1c472a86c7c -->

<!-- pgdoc-cn_start sig_en=ab1a9f9ea3c45698fde4671b0a8195bf sig_cn_org=None source=14.1 
   <para>
    The extension mechanism also has provisions for packaging modification
    scripts that adjust the definitions of the SQL objects contained in an
    extension.  For example, if version 1.1 of an extension adds one function
    and changes the body of another function compared to 1.0, the extension
    author can provide an <firstterm>update script</firstterm> that makes just those
    two changes.  The <command>ALTER EXTENSION UPDATE</command> command can then
    be used to apply these changes and track which version of the extension
    is actually installed in a given database.
   </para>
________________________________________________________-->
   <para>
    扩展机制也对打包调整一个扩展中所含 SQL 对象定义的修改脚本有规定。例如，如果一个扩展的 1.1 版本比 1.0 版本增加了一个函数并且更改了另一个函数的函数体，该扩展的作者可以提供一个<firstterm>更新脚本</firstterm>来做这两个更改。那么<command>ALTER EXTENSION UPDATE</command>命令可以被用来应用这些更改并且跟踪在给定数据库中实际安装的是该扩展的哪个版本。
   </para>
<!-- pgdoc-cn_end sig_en=ab1a9f9ea3c45698fde4671b0a8195bf -->

<!-- pgdoc-cn_start sig_en=e5d6a2f37267b08d44e6b05f7a27d5d4 sig_cn_org=None source=14.1 
   <para>
    The kinds of SQL objects that can be members of an extension are shown in
    the description of <link linkend="sql-alterextension"><command>ALTER EXTENSION</command></link>.  Notably, objects
    that are database-cluster-wide, such as databases, roles, and tablespaces,
    cannot be extension members since an extension is only known within one
    database.  (Although an extension script is not prohibited from creating
    such objects, if it does so they will not be tracked as part of the
    extension.)  Also notice that while a table can be a member of an
    extension, its subsidiary objects such as indexes are not directly
    considered members of the extension.
    Another important point is that schemas can belong to extensions, but not
    vice versa: an extension as such has an unqualified name and does not
    exist <quote>within</quote> any schema.  The extension's member objects,
    however, will belong to schemas whenever appropriate for their object
    types.  It may or may not be appropriate for an extension to own the
    schema(s) its member objects are within.
   </para>
________________________________________________________-->
   <para>
    能作为一个扩展的成员的 SQL 对象的种类如<link linkend="sql-alterextension"><command>ALTER EXTENSION</command></link>所示。
    尤其是数据库集簇范围的对象（例如数据库、角色和表空间）不能作为扩展成员，因为一个扩展只在一个数据库范围内可见（尽管一个扩展脚本并没有被禁止创建这些对象，但是这样做将无法把它们作为扩展的一部分来跟踪）。
    还要注意虽然一个表可以是一个扩展的成员，它的扶助对象（例如索引）不会被直接认为是该扩展的成员。
    另一个重点是模式可以属于扩展，但是反过来不行：一个扩展本身有一个不被限定的名称并且不存在于任何模式<quote>中</quote>。
    不过，扩展的成员对象只要对象类型合适就可以属于模式。
    一个扩展拥有包含其成员对象的模式可能合适也可能不合适。
   </para>
<!-- pgdoc-cn_end sig_en=e5d6a2f37267b08d44e6b05f7a27d5d4 -->

<!-- pgdoc-cn_start sig_en=f10dcba1410e681f15efff6abf24e785 sig_cn_org=None source=14.1 
   <para>
    If an extension's script creates any temporary objects (such as temp
    tables), those objects are treated as extension members for the
    remainder of the current session, but are automatically dropped at
    session end, as any temporary object would be.  This is an exception
    to the rule that extension member objects cannot be dropped without
    dropping the whole extension.
   </para>
________________________________________________________-->
   <para>
    如果一个扩展的脚本创建任何临时对象（例如临时表），在当前会话的剩余部分会把它们当作扩展的成员，但是在会话结束会自动删除它们，这和任何其他临时对象是一样的。对于不删除整个扩展就不能删除扩展的成员对象的规则来说，这是一种例外。
   </para>
<!-- pgdoc-cn_end sig_en=f10dcba1410e681f15efff6abf24e785 -->

   <sect2>
<!-- pgdoc-cn_start sig_en=69bd63e0b392246228a9b7d7c9419836 sig_cn_org=None source=14.1 
    <title>Extension Files</title>
________________________________________________________-->
    <title>扩展文件</title>
<!-- pgdoc-cn_end sig_en=69bd63e0b392246228a9b7d7c9419836 -->

<!-- pgdoc-cn_start sig_en=cb5bb7fb6af985aa9b345bc9e2c5d377 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>control file</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>控制文件</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=cb5bb7fb6af985aa9b345bc9e2c5d377 -->

<!-- pgdoc-cn_start sig_en=8668e2916f20bd591b03fb49bff4122f sig_cn_org=None source=14.1 
    <para>
     The <command>CREATE EXTENSION</command> command relies on a control
     file for each extension, which must be named the same as the extension
     with a suffix of <literal>.control</literal>, and must be placed in the
     installation's <literal>SHAREDIR/extension</literal> directory.  There
     must also be at least one <acronym>SQL</acronym> script file, which follows the
     naming pattern
     <literal><replaceable>extension</replaceable>-&minus;<replaceable>version</replaceable>.sql</literal>
     (for example, <literal>foo-&minus;1.0.sql</literal> for version <literal>1.0</literal> of
     extension <literal>foo</literal>).  By default, the script file(s) are also
     placed in the <literal>SHAREDIR/extension</literal> directory; but the
     control file can specify a different directory for the script file(s).
    </para>
________________________________________________________-->
    <para>
     <command>CREATE EXTENSION</command>命令依赖每一个扩展都有的控制文件，控制文件必须被命名为扩展的名称加上一个后缀<literal>.control</literal>，并且必须被放在安装的<literal>SHAREDIR/extension</literal>目录中。
     还必须至少有一个<acronym>SQL</acronym>脚本文件，它遵循命名模式<literal><replaceable>extension</replaceable>--<replaceable>version</replaceable>.sql</literal>（例如，<literal>foo--1.0.sql</literal>表示扩展<literal>foo</literal>的<literal>1.0</literal>版本）。
     默认情况下，脚本文件也被放置在<literal>SHAREDIR/extension</literal>目录中，但是控制文件中可以为脚本文件指定一个不同的目录。
    </para>
<!-- pgdoc-cn_end sig_en=8668e2916f20bd591b03fb49bff4122f -->

<!-- pgdoc-cn_start sig_en=02c611774bbbb117d781c594926399eb sig_cn_org=None source=14.1 
    <para>
     The file format for an extension control file is the same as for the
     <filename>postgresql.conf</filename> file, namely a list of
     <replaceable>parameter_name</replaceable> <literal>=</literal> <replaceable>value</replaceable>
     assignments, one per line.  Blank lines and comments introduced by
     <literal>#</literal> are allowed.  Be sure to quote any value that is not
     a single word or number.
    </para>
________________________________________________________-->
    <para>
     一个扩展控制文件的格式与<filename>postgresql.conf</filename>文件相同，即是一个<replaceable>parameter_name</replaceable> <literal>=</literal> <replaceable>value</replaceable>赋值的列表，每行一个。允许空行和<literal>#</literal>引入的注释。注意对任何不是单一词或数字的值加上引号。
    </para>
<!-- pgdoc-cn_end sig_en=02c611774bbbb117d781c594926399eb -->

<!-- pgdoc-cn_start sig_en=a54911a22ad21b5d1ea369525bff4278 sig_cn_org=None source=14.1 
    <para>
     A control file can set the following parameters:
    </para>
________________________________________________________-->
    <para>
     一个控制文件可以设置下列参数：
    </para>
<!-- pgdoc-cn_end sig_en=a54911a22ad21b5d1ea369525bff4278 -->

    <variablelist>
     <varlistentry>
<!-- pgdoc-cn_start sig_en=a7333b427f44a779c57c5d5042a5c5f5 sig_cn_org=None source=14.1 
      <term><varname>directory</varname> (<type>string</type>)</term>
________________________________________________________-->
      <term><varname>directory</varname> (<type>string</type>)</term>
<!-- pgdoc-cn_end sig_en=a7333b427f44a779c57c5d5042a5c5f5 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=1ae457bcedf0ce11fff4fb99aa990af8 sig_cn_org=None source=14.1 
       <para>
        The directory containing the extension's <acronym>SQL</acronym> script
        file(s).  Unless an absolute path is given, the name is relative to
        the installation's <literal>SHAREDIR</literal> directory.  The
        default behavior is equivalent to specifying
        <literal>directory = 'extension'</literal>.
       </para>
________________________________________________________-->
       <para>
        包含扩展的<acronym>SQL</acronym>脚本文件的目录。除非给出一个绝对路径，这个目录名是相对于安装的<literal>SHAREDIR</literal>目录。默认行为等效于指定<literal>directory = 'extension'</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=1ae457bcedf0ce11fff4fb99aa990af8 -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=07bd5cda58429fc5ff41f184c75910dc sig_cn_org=None source=14.1 
      <term><varname>default_version</varname> (<type>string</type>)</term>
________________________________________________________-->
      <term><varname>default_version</varname> (<type>string</type>)</term>
<!-- pgdoc-cn_end sig_en=07bd5cda58429fc5ff41f184c75910dc -->
      <listitem>
<!-- pgdoc-cn_start sig_en=99a4ec86db32b0fbdb0b9aa2d769919f sig_cn_org=None source=14.1 
       <para>
        The default version of the extension (the one that will be installed
        if no version is specified in <command>CREATE EXTENSION</command>).  Although
        this can be omitted, that will result in <command>CREATE EXTENSION</command>
        failing if no <literal>VERSION</literal> option appears, so you generally
        don't want to do that.
       </para>
________________________________________________________-->
       <para>
        该扩展的默认版本（就是如果在<command>CREATE EXTENSION</command>中没有指定版本时将会被安装的那一个）。尽管可以忽略这个参数，但如果没有出现<literal>VERSION</literal>选项时那将会导致<command>CREATE EXTENSION</command>失败，因此你通常不会希望这样做。
       </para>
<!-- pgdoc-cn_end sig_en=99a4ec86db32b0fbdb0b9aa2d769919f -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=0a7491c3e43061c3f39ebefa96ac990d sig_cn_org=None source=14.1 
      <term><varname>comment</varname> (<type>string</type>)</term>
________________________________________________________-->
      <term><varname>comment</varname> (<type>string</type>)</term>
<!-- pgdoc-cn_end sig_en=0a7491c3e43061c3f39ebefa96ac990d -->
      <listitem>
<!-- pgdoc-cn_start sig_en=2739a4b88428f0b7ec3cf0c2bfdcaed1 sig_cn_org=None source=14.1 
       <para>
        A comment (any string) about the extension.  The comment is applied
        when initially creating an extension, but not during extension updates
        (since that might override user-added comments).  Alternatively,
        the extension's comment can be set by writing
        a <xref linkend="sql-comment"/> command in the script file.
       </para>
________________________________________________________-->
       <para>
        一个关于该扩展的注释（任意字符串）。该注释会在初始创建扩展时应用，但是扩展更新时不会引用该注释（因为可能会覆盖用户增加的注释）。扩展的注释也可以通过在脚本文件中写上<xref linkend="sql-comment"/>命令来设置。
       </para>
<!-- pgdoc-cn_end sig_en=2739a4b88428f0b7ec3cf0c2bfdcaed1 -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=930bab9fb73095e99fdaf34060b36e4b sig_cn_org=None source=14.1 
      <term><varname>encoding</varname> (<type>string</type>)</term>
________________________________________________________-->
      <term><varname>encoding</varname> (<type>string</type>)</term>
<!-- pgdoc-cn_end sig_en=930bab9fb73095e99fdaf34060b36e4b -->
      <listitem>
<!-- pgdoc-cn_start sig_en=9c388f2542c04c40425ca0627211b505 sig_cn_org=None source=14.1 
       <para>
        The character set encoding used by the script file(s).  This should
        be specified if the script files contain any non-ASCII characters.
        Otherwise the files will be assumed to be in the database encoding.
       </para>
________________________________________________________-->
       <para>
        该脚本文件使用的字符集编码。当脚本文件包含任何非 ASCII 字符时，可以指定这个参数。否则文件都会被假定为数据库编码。
       </para>
<!-- pgdoc-cn_end sig_en=9c388f2542c04c40425ca0627211b505 -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=2071f852310213ba9f6e3b200013fe66 sig_cn_org=None source=14.1 
      <term><varname>module_pathname</varname> (<type>string</type>)</term>
________________________________________________________-->
      <term><varname>module_pathname</varname> (<type>string</type>)</term>
<!-- pgdoc-cn_end sig_en=2071f852310213ba9f6e3b200013fe66 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=0919d3e1b460f3813b965d078fa2ecf3 sig_cn_org=None source=14.1 
       <para>
        The value of this parameter will be substituted for each occurrence
        of <literal>MODULE_PATHNAME</literal> in the script file(s).  If it is not
        set, no substitution is made.  Typically, this is set to
        <literal>$libdir/<replaceable>shared_library_name</replaceable></literal> and
        then <literal>MODULE_PATHNAME</literal> is used in <command>CREATE
        FUNCTION</command> commands for C-language functions, so that the script
        files do not need to hard-wire the name of the shared library.
       </para>
________________________________________________________-->
       <para>
        这个参数的值将被用于替换脚本文件中每一次出现的<literal>MODULE_PATHNAME</literal>。如果设置，将不会进行替换。通常，这会被设置为<literal>$libdir/<replaceable>shared_library_name</replaceable></literal>并且接着<literal>MODULE_PATHNAME</literal>被用在<command>CREATE FUNCTION</command>命令中进行 C-语言函数的创建，因此该脚本文件不必把共享库的名称硬编码在其中。
       </para>
<!-- pgdoc-cn_end sig_en=0919d3e1b460f3813b965d078fa2ecf3 -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=4c8dc5862676d105ae921d076282ce4a sig_cn_org=None source=14.1 
      <term><varname>requires</varname> (<type>string</type>)</term>
________________________________________________________-->
      <term><varname>requires</varname> (<type>string</type>)</term>
<!-- pgdoc-cn_end sig_en=4c8dc5862676d105ae921d076282ce4a -->
      <listitem>
<!-- pgdoc-cn_start sig_en=3eef31f8672cfcba397ada55dfdae3e3 sig_cn_org=None source=14.1 
       <para>
        A list of names of extensions that this extension depends on,
        for example <literal>requires = 'foo, bar'</literal>.  Those
        extensions must be installed before this one can be installed.
       </para>
________________________________________________________-->
       <para>
        这个扩展依赖的其他扩展名的一个列表，例如<literal>requires = 'foo, bar'</literal>。被依赖的扩展必须先于这个扩展安装。
       </para>
<!-- pgdoc-cn_end sig_en=3eef31f8672cfcba397ada55dfdae3e3 -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=a743f571c8a71f26de7205355409dcf0 sig_cn_org=None source=14.1 
      <term><varname>superuser</varname> (<type>boolean</type>)</term>
________________________________________________________-->
      <term><varname>superuser</varname> (<type>boolean</type>)</term>
<!-- pgdoc-cn_end sig_en=a743f571c8a71f26de7205355409dcf0 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=39c9b9965a65fda484f7ef109defaa31 sig_cn_org=None source=14.1 
       <para>
        If this parameter is <literal>true</literal> (which is the default),
        only superusers can create the extension or update it to a new
        version (but see also <varname>trusted</varname>, below).
        If it is set to <literal>false</literal>, just the privileges
        required to execute the commands in the installation or update script
        are required.
        This should normally be set to <literal>true</literal> if any of the
        script commands require superuser privileges.  (Such commands would
        fail anyway, but it's more user-friendly to give the error up front.)
       </para>
________________________________________________________-->
       <para>
        如果这个参数为<literal>true</literal>（默认情况），只有超级用户能够创建该扩展或者将它更新到一个新版本。
        (另请参见下面的 <varname>trusted</varname>) 如果被设置为<literal>false</literal>，只需要用来执行安装中命令或者更新脚本的特权。
        如果任何脚本命令需要超级用户权限，这将通常被设置为<literal>true</literal>。
        (这样的命令总之都会失败，但提前给出错误对用户更友好。)
       </para>
<!-- pgdoc-cn_end sig_en=39c9b9965a65fda484f7ef109defaa31 -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=80bb141140ff01f9d9de7f7b536ae38d sig_cn_org=None source=14.1 
      <term><varname>trusted</varname> (<type>boolean</type>)</term>
________________________________________________________-->
      <term><varname>trusted</varname> (<type>boolean</type>)</term>
<!-- pgdoc-cn_end sig_en=80bb141140ff01f9d9de7f7b536ae38d -->
      <listitem>
<!-- pgdoc-cn_start sig_en=5ea720838b226619c88a3bf6d12efc7d sig_cn_org=None source=14.1 
       <para>
        This parameter, if set to <literal>true</literal> (which is not the
        default), allows some non-superusers to install an extension that
        has <varname>superuser</varname> set to <literal>true</literal>.
        Specifically, installation will be permitted for anyone who has
        <literal>CREATE</literal> privilege on the current database.
        When the user executing <command>CREATE EXTENSION</command> is not
        a superuser but is allowed to install by virtue of this parameter,
        then the installation or update script is run as the bootstrap
        superuser, not as the calling user.
        This parameter is irrelevant if <varname>superuser</varname> is
        <literal>false</literal>.
        Generally, this should not be set true for extensions that could
        allow access to otherwise-superuser-only abilities, such as
        file system access.
        Also, marking an extension trusted requires significant extra effort
        to write the extension's installation and update script(s) securely;
        see <xref linkend="extend-extensions-security"/>.
       </para>
________________________________________________________-->
       <para>
        这个参数，如果设置为 <literal>true</literal>（非默认值），则允许某些非超级用户安装<varname>superuser</varname>已设置为 <literal>true</literal> 的扩展。
        具体地说，对于在当前数据库上具有<literal>CREATE</literal>特权的任何人，都允许安装。
        当执行<command>CREATE EXTENSION</command>的用户不是超级用户，但允许通过此参数安装时，则此安装或更新脚本作为引导超级用户运行，而不是作为调用用户。
        这个参数是不相干的，如果 <varname>superuser</varname> 为 <literal>false</literal>。
        通常，对于可能允许访问其他超级用户功能的扩展这将不被设为真(true)，例如文件系统访问。
        此外，标记一个可信的扩展需要大量额外的努力，以安全的编写扩展的安装和更新脚本；参见<xref linkend="extend-extensions-security"/>。
       </para>
<!-- pgdoc-cn_end sig_en=5ea720838b226619c88a3bf6d12efc7d -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=7c7dd6d2de693ef32f9bb6aae55cf010 sig_cn_org=None source=14.1 
      <term><varname>relocatable</varname> (<type>boolean</type>)</term>
________________________________________________________-->
      <term><varname>relocatable</varname> (<type>boolean</type>)</term>
<!-- pgdoc-cn_end sig_en=7c7dd6d2de693ef32f9bb6aae55cf010 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=283ee5926a48ec648f2325b504001563 sig_cn_org=None source=14.1 
       <para>
        An extension is <firstterm>relocatable</firstterm> if it is possible to move
        its contained objects into a different schema after initial creation
        of the extension.  The default is <literal>false</literal>, i.e., the
        extension is not relocatable.
        See <xref linkend="extend-extensions-relocation"/> for more information.
       </para>
________________________________________________________-->
       <para>
        如果一个扩展可能在初始创建之后将其所含的对象移动到一个不同的模式中，它就是<firstterm>relocatable</firstterm>。默认值是<literal>false</literal>，即该扩展是不可重定位的。详见<xref linkend="extend-extensions-relocation"/>。
       </para>
<!-- pgdoc-cn_end sig_en=283ee5926a48ec648f2325b504001563 -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=81204645685cb7b2ac45b308631a92ab sig_cn_org=None source=14.1 
      <term><varname>schema</varname> (<type>string</type>)</term>
________________________________________________________-->
      <term><varname>schema</varname> (<type>string</type>)</term>
<!-- pgdoc-cn_end sig_en=81204645685cb7b2ac45b308631a92ab -->
      <listitem>
<!-- pgdoc-cn_start sig_en=7a40e9a4333b4df3074acc74493c2da8 sig_cn_org=None source=14.1 
       <para>
        This parameter can only be set for non-relocatable extensions.
        It forces the extension to be loaded into exactly the named schema
        and not any other.
        The <varname>schema</varname> parameter is consulted only when
        initially creating an extension, not during extension updates.
        See <xref linkend="extend-extensions-relocation"/> for more information.
       </para>
________________________________________________________-->
       <para>
        这个参数只能为非可重定位扩展设置。它强制扩展被载入到给定的模式中而非其他模式中。只有在初始创建一个扩展时才会参考<varname>schema</varname>参数，扩展更新时则不会参考这个参数。详见<xref linkend="extend-extensions-relocation"/>。
       </para>
<!-- pgdoc-cn_end sig_en=7a40e9a4333b4df3074acc74493c2da8 -->
      </listitem>
     </varlistentry>
    </variablelist>

<!-- pgdoc-cn_start sig_en=a957987283b32bb0f08319ac6540456f sig_cn_org=None source=14.1 
    <para>
     In addition to the primary control file
     <literal><replaceable>extension</replaceable>.control</literal>,
     an extension can have secondary control files named in the style
     <literal><replaceable>extension</replaceable>-&minus;<replaceable>version</replaceable>.control</literal>.
     If supplied, these must be located in the script file directory.
     Secondary control files follow the same format as the primary control
     file.  Any parameters set in a secondary control file override the
     primary control file when installing or updating to that version of
     the extension.  However, the parameters <varname>directory</varname> and
     <varname>default_version</varname> cannot be set in a secondary control file.
    </para>
________________________________________________________-->
    <para>
     除了主要控制文件<literal><replaceable>extension</replaceable>.control</literal>，一个扩展还可以有二级控制文件，它们以<literal><replaceable>extension</replaceable>--<replaceable>version</replaceable>.control</literal>的风格命名。如果提供了二级控制文件，它们必须被放置在脚本文件的目录中。二级控制文件遵循主要控制文件相同的格式。在安装或更新该扩展的版本时，一个二级控制文件中设置的任何参数将覆盖主要控制文件中的设置。不过，参数<varname>directory</varname>以及<varname>default_version</varname>不能在二级控制文件中设置。
    </para>
<!-- pgdoc-cn_end sig_en=a957987283b32bb0f08319ac6540456f -->

<!-- pgdoc-cn_start sig_en=fe7308825b7c66fcd613b3f611298d09 sig_cn_org=0a59fd7c7fab4e81fbea4c1e59fad802 source=15.7 
    <para>
     An extension's <acronym>SQL</acronym> script files can contain any SQL commands,
     except for transaction control commands (<command>BEGIN</command>,
     <command>COMMIT</command>, etc.) and commands that cannot be executed inside a
     transaction block (such as <command>VACUUM</command>).  This is because the
     script files are implicitly executed within a transaction block.
    </para>
________________________________________________________-->
    <para>
     一个扩展的<acronym>SQL</acronym>脚本文件可以包含任何SQL命令，除了事务控制命令
     (<command>BEGIN</command>，<command>COMMIT</command>等)和不能在事务块内执行的命令
     (比如<command>VACUUM</command>)。这是因为脚本文件隐式地在事务块内执行。
    </para>
<!-- pgdoc-cn_end sig_en=fe7308825b7c66fcd613b3f611298d09 -->

<!-- pgdoc-cn_start sig_en=fc7db1d16eb60303d48b5e156f55a03c sig_cn_org=None source=14.1 
    <para>
     An extension's <acronym>SQL</acronym> script files can also contain lines
     beginning with <literal>\echo</literal>, which will be ignored (treated as
     comments) by the extension mechanism.  This provision is commonly used
     to throw an error if the script file is fed to <application>psql</application>
     rather than being loaded via <command>CREATE EXTENSION</command> (see example
     script in <xref linkend="extend-extensions-example"/>).
     Without that, users might accidentally load the
     extension's contents as <quote>loose</quote> objects rather than as an
     extension, a state of affairs that's a bit tedious to recover from.
    </para>
________________________________________________________-->
    <para>
     一个扩展的<acronym>SQL</acronym>脚本文件也能包含以<literal>\echo</literal>开始的行，它将被扩展机制忽略（当作注释）。如果脚本文件被送给<application>psql</application>而不是由<command>CREATE EXTENSION</command>载入（见<xref linkend="extend-extensions-example"/>中的示例脚本），这种机制通常被用来抛出错误。如果没有这种功能，用户可能会意外地把该扩展的内容作为<quote>松散的</quote>对象而不是一整个扩展载入，这样的状态恢复起来比较麻烦。
    </para>
<!-- pgdoc-cn_end sig_en=fc7db1d16eb60303d48b5e156f55a03c -->

<!-- pgdoc-cn_start sig_en=d82f53176f833da7d6d842ae349fd14d sig_cn_org=None source=14.1 
    <para>
     If the extension script contains the
     string <literal>@extowner@</literal>, that string is replaced with the
     (suitably quoted) name of the user calling <command>CREATE
     EXTENSION</command> or <command>ALTER EXTENSION</command>.  Typically
     this feature is used by extensions that are marked trusted to assign
     ownership of selected objects to the calling user rather than the
     bootstrap superuser.  (One should be careful about doing so, however.
     For example, assigning ownership of a C-language function to a
     non-superuser would create a privilege escalation path for that user.)
    </para>
________________________________________________________-->
    <para>
     如果扩展脚本包含字符串 <literal>@extowner@</literal>，该字符串将替换为调用 <command>CREATE EXTENSION</command> or <command>ALTER EXTENSION</command> 的用户的名称（适当引用）。 
     通常，此特性会被标记为受信任的扩展使用，将所选对象的所有权分配给调用用户，而不是引导超级用户。
     （但是，在这样做时应该小心谨慎。例如，将c语言函数的所有权分配给非超级用户将为该用户创建一个权限升级路径。）
    </para>
<!-- pgdoc-cn_end sig_en=d82f53176f833da7d6d842ae349fd14d -->

<!-- pgdoc-cn_start sig_en=1533fc3a08366aed9babd3b3f0b4ca84 sig_cn_org=None source=14.1 
    <para>
     While the script files can contain any characters allowed by the specified
     encoding, control files should contain only plain ASCII, because there
     is no way for <productname>PostgreSQL</productname> to know what encoding a
     control file is in.  In practice this is only an issue if you want to
     use non-ASCII characters in the extension's comment.  Recommended
     practice in that case is to not use the control file <varname>comment</varname>
     parameter, but instead use <command>COMMENT ON EXTENSION</command>
     within a script file to set the comment.
    </para>
________________________________________________________-->
    <para>
     尽管脚本文件可以包含指定编码允许的任何字符，但是控制文件应该只包含纯 ASCII 字符，因为<productname>PostgreSQL</productname>没有办法知道一个控制文件是什么编码。实际上，如果你想在扩展的注释中使用非 ASCII 字符只有一个问题。推荐的方法是不使用控制文件的<varname>comment</varname>参数，而是使用脚本文件中的<command>COMMENT ON EXTENSION</command>来设置注释。
    </para>
<!-- pgdoc-cn_end sig_en=1533fc3a08366aed9babd3b3f0b4ca84 -->

   </sect2>

   <sect2 id="extend-extensions-relocation">
<!-- pgdoc-cn_start sig_en=81a8a3c24165993ec012684f3e72f326 sig_cn_org=None source=14.1 
    <title>Extension Relocatability</title>
________________________________________________________-->
    <title>扩展可再定位性</title>
<!-- pgdoc-cn_end sig_en=81a8a3c24165993ec012684f3e72f326 -->

<!-- pgdoc-cn_start sig_en=79e2f0e44a9eedc02134b8d559d3c5e1 sig_cn_org=None source=14.1 
    <para>
     Users often wish to load the objects contained in an extension into a
     different schema than the extension's author had in mind.  There are
     three supported levels of relocatability:
    </para>
________________________________________________________-->
    <para>
     用户常常希望把扩展中包含的对象载入到一个与扩展的作者所设想的不一样的模式中。对于这种可重定位性，有三种支持的级别：
    </para>
<!-- pgdoc-cn_end sig_en=79e2f0e44a9eedc02134b8d559d3c5e1 -->

    <itemizedlist>
     <listitem>
<!-- pgdoc-cn_start sig_en=397665bc464c400fe9d93d38907f65f0 sig_cn_org=None source=14.1 
      <para>
       A fully relocatable extension can be moved into another schema
       at any time, even after it's been loaded into a database.
       This is done with the <command>ALTER EXTENSION SET SCHEMA</command>
       command, which automatically renames all the member objects into
       the new schema.  Normally, this is only possible if the extension
       contains no internal assumptions about what schema any of its
       objects are in.  Also, the extension's objects must all be in one
       schema to begin with (ignoring objects that do not belong to any
       schema, such as procedural languages).  Mark a fully relocatable
       extension by setting <literal>relocatable = true</literal> in its control
       file.
      </para>
________________________________________________________-->
      <para>
       一个完全可重定位的扩展能在任何时候被移动到另一个模式中，即使在它被载入到一个数据库中之后。这种移动通过<command>ALTER EXTENSION SET SCHEMA</command>命令完成，该命令会自动地把所有成员对象重命名到新的模式中。通常，只有扩展不包含任何对其所在模式的内部假设时才可能这样做。还有，该扩展的对象必须全部在同一个模式中（忽略那些不属于任何模式的对象，例如过程语言）。要让一个扩展变成完全可定位，在它的控制文件中设置<literal>relocatable = true</literal>。
      </para>
<!-- pgdoc-cn_end sig_en=397665bc464c400fe9d93d38907f65f0 -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=cfde20dbe356e1acef8ea43c71c5442a sig_cn_org=None source=14.1 
      <para>
       An extension might be relocatable during installation but not
       afterwards.  This is typically the case if the extension's script
       file needs to reference the target schema explicitly, for example
       in setting <literal>search_path</literal> properties for SQL functions.
       For such an extension, set <literal>relocatable = false</literal> in its
       control file, and use <literal>@extschema@</literal> to refer to the target
       schema in the script file.  All occurrences of this string will be
       replaced by the actual target schema's name before the script is
       executed.  The user can set the target schema using the
       <literal>SCHEMA</literal> option of <command>CREATE EXTENSION</command>.
      </para>
________________________________________________________-->
      <para>
       一个扩展可能在安装过程中是可重定位的，但是安装完后就不再可重定位。典型的情况是扩展的脚本文件需要显式地引用目标模式，例如为 SQL 函数设置<literal>search_path</literal>属性。对于这样一种扩展，在其控制文件中设置<literal>relocatable = false</literal>，并且使用<literal>@extschema@</literal>在脚本文件中引用目标模式。在脚本被执行前，所有这个字符串的出现都将被替换为实际的目标模式名。用户可以使用<command>CREATE EXTENSION</command>的<literal>SCHEMA</literal>选项设置目标模式名。
      </para>
<!-- pgdoc-cn_end sig_en=cfde20dbe356e1acef8ea43c71c5442a -->
     </listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=0d390974cbb92564553b90d2e6984760 sig_cn_org=None source=14.1 
      <para>
       If the extension does not support relocation at all, set
       <literal>relocatable = false</literal> in its control file, and also set
       <literal>schema</literal> to the name of the intended target schema.  This
       will prevent use of the <literal>SCHEMA</literal> option of <command>CREATE
       EXTENSION</command>, unless it specifies the same schema named in the control
       file.  This choice is typically necessary if the extension contains
       internal assumptions about schema names that can't be replaced by
       uses of <literal>@extschema@</literal>.  The <literal>@extschema@</literal>
       substitution mechanism is available in this case too, although it is
       of limited use since the schema name is determined by the control file.
      </para>
________________________________________________________-->
      <para>
       如果扩展根本就不支持重定位，在它的控制文件中设置<literal>relocatable = false</literal>，并且还设置<literal>schema</literal>为想要的目标模式的名称。这将阻止使用<command>CREATE EXTENSION</command>的<literal>SCHEMA</literal>选项修改目标模式，除非它指定的是和控制文件中相同的模式。如果该扩展包括关于模式名的内部假设且模式名不能使用<literal>@extschema@</literal>的方法替换，这种选择通常是必须的。<literal>@extschema@</literal>替换机制在这种情况中也是可用的，不过由于模式名已经被控制文件所决定，它的使用受到了很大的限制。
      </para>
<!-- pgdoc-cn_end sig_en=0d390974cbb92564553b90d2e6984760 -->
     </listitem>
    </itemizedlist>

<!-- pgdoc-cn_start sig_en=f873a4a5d70c08530e0daaea69c09c0c sig_cn_org=None source=14.1 
    <para>
     In all cases, the script file will be executed with
     <xref linkend="guc-search-path"/> initially set to point to the target
     schema; that is, <command>CREATE EXTENSION</command> does the equivalent of
     this:
<programlisting>
SET LOCAL search_path TO @extschema@, pg_temp;
</programlisting>
     This allows the objects created by the script file to go into the target
     schema.  The script file can change <varname>search_path</varname> if it wishes,
     but that is generally undesirable.  <varname>search_path</varname> is restored
     to its previous setting upon completion of <command>CREATE EXTENSION</command>.
    </para>
________________________________________________________-->
    <para>
     在所有情况下，脚本文件将被用<xref linkend="guc-search-path"/>执行，它最初会被设置为指向目标模式，也就是说<command>CREATE EXTENSION</command>做的也是等效的工作：
<programlisting>
SET LOCAL search_path TO @extschema@, pg_temp;
</programlisting>
     这允许由这个脚本文件创建的对象进入到目标模式中。如果脚本文件希望，它可以改变<varname>search_path</varname>，但这种用法通常是不受欢迎的。在<command>CREATE EXTENSION</command>结束后，<varname>search_path</varname>会被恢复到之前的设置。
    </para>
<!-- pgdoc-cn_end sig_en=f873a4a5d70c08530e0daaea69c09c0c -->

<!-- pgdoc-cn_start sig_en=1238ba6cdec16daeef38b610fca8a9ff sig_cn_org=None source=14.1 
    <para>
     The target schema is determined by the <varname>schema</varname> parameter in
     the control file if that is given, otherwise by the <literal>SCHEMA</literal>
     option of <command>CREATE EXTENSION</command> if that is given, otherwise the
     current default object creation schema (the first one in the caller's
     <varname>search_path</varname>).  When the control file <varname>schema</varname>
     parameter is used, the target schema will be created if it doesn't
     already exist, but in the other two cases it must already exist.
    </para>
________________________________________________________-->
    <para>
     如果控制文件中给出了<varname>schema</varname>参数，目标模式就由该参数决定，否则目标模式由<command>CREATE EXTENSION</command>的<literal>SCHEMA</literal>选项给出，如果以上两者都没有给出则会用当前默认的对象创建模式（在调用者<varname>search_path</varname>中的第一个）。当使用扩展文件的<varname>schema</varname>参数时，如果目标模式还不存在将创建它，但是在另外两种情况下它必须已经存在。
    </para>
<!-- pgdoc-cn_end sig_en=1238ba6cdec16daeef38b610fca8a9ff -->

<!-- pgdoc-cn_start sig_en=b88403d92f4421cf3b2435e8f2cccfb9 sig_cn_org=None source=14.1 
    <para>
     If any prerequisite extensions are listed in <varname>requires</varname>
     in the control file, their target schemas are added to the initial
     setting of <varname>search_path</varname>, following the new
     extension's target schema.  This allows their objects to be visible to
     the new extension's script file.
    </para>
________________________________________________________-->
    <para>
     如果在控制文件中的<varname>requires</varname>中列举了任何先导扩展，它们的目标模式会被追加到<varname>search_path</varname>的初始设置中，遵循新扩展的目标模式。
     这允许新扩展的脚本文件能够看到它们的对象。
    </para>
<!-- pgdoc-cn_end sig_en=b88403d92f4421cf3b2435e8f2cccfb9 -->

<!-- pgdoc-cn_start sig_en=6a0fe57dec1f6386679c533367e979c7 sig_cn_org=None source=14.1 
    <para>
     For security, <literal>pg_temp</literal> is automatically appended to
     the end of <varname>search_path</varname> in all cases.
    </para>
________________________________________________________-->
    <para>
     为了安全，<literal>pg_temp</literal> 在所有情况下都会自动添加到 <varname>search_path</varname> 的末尾。
    </para>
<!-- pgdoc-cn_end sig_en=6a0fe57dec1f6386679c533367e979c7 -->

<!-- pgdoc-cn_start sig_en=11f93bfb992dce985015fef5fa1ecb52 sig_cn_org=None source=14.1 
    <para>
     Although a non-relocatable extension can contain objects spread across
     multiple schemas, it is usually desirable to place all the objects meant
     for external use into a single schema, which is considered the extension's
     target schema.  Such an arrangement works conveniently with the default
     setting of <varname>search_path</varname> during creation of dependent
     extensions.
    </para>
________________________________________________________-->
    <para>
     尽管一个不可重定位的扩展能够包含散布在多个模式中的对象，通常还是值得将意图用于外部使用的所有对象放置在一个模式中，这被认为是该扩展的目标模式。这样一种安排可以在依赖的扩展创建过程中方便地与<varname>search_path</varname>的默认设置一起工作。
    </para>
<!-- pgdoc-cn_end sig_en=11f93bfb992dce985015fef5fa1ecb52 -->
   </sect2>

   <sect2 id="extend-extensions-config-tables">
<!-- pgdoc-cn_start sig_en=1d1e7788c490f0e38651c84c927b07e4 sig_cn_org=None source=14.1 
    <title>Extension Configuration Tables</title>
________________________________________________________-->
    <title>扩展配置表</title>
<!-- pgdoc-cn_end sig_en=1d1e7788c490f0e38651c84c927b07e4 -->

<!-- pgdoc-cn_start sig_en=9bd380991775dd6b67797ed6faea32d4 sig_cn_org=9ebe35e5220c45ccfb28481b361fecf8 source=15.7 
    <para>
     Some extensions include configuration tables, which contain data that
     might be added or changed by the user after installation of the
     extension.  Ordinarily, if a table is part of an extension, neither
     the table's definition nor its content will be dumped by
     <application>pg_dump</application>.  But that behavior is undesirable for a
     configuration table; any data changes made by the user need to be
     included in dumps, or the extension will behave differently after a dump
     and restore.
    </para>
________________________________________________________-->
    <para>
     一些扩展包括配置表，其中包含用户在安装扩展后可能添加或更改的数据。
     通常，如果表是扩展的一部分，那么<application>pg_dump</application>不会转储表的定义或内容。
     但是对于配置表，这种行为是不可取的；用户进行的任何数据更改都需要包含在转储中，
     否则在转储和恢复后，扩展的行为将有所不同。
    </para>
<!-- pgdoc-cn_end sig_en=9bd380991775dd6b67797ed6faea32d4 -->

<!-- pgdoc-cn_start sig_en=f133c4b85214126dc97ee47ec6ec4c91 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>pg_extension_config_dump</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>pg_extension_config_dump</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=f133c4b85214126dc97ee47ec6ec4c91 -->

<!-- pgdoc-cn_start sig_en=901b917dbc323cf4cc69b001c2c9b1a3 sig_cn_org=None source=14.1 
    <para>
     To solve this problem, an extension's script file can mark a table
     or a sequence it has created as a configuration relation, which will
     cause <application>pg_dump</application> to include the table's or the sequence's
     contents (not its definition) in dumps.  To do that, call the function
     <function>pg_extension_config_dump(regclass, text)</function> after creating the
     table or the sequence, for example
<programlisting>
CREATE TABLE my_config (key text, value text);
CREATE SEQUENCE my_config_seq;

SELECT pg_catalog.pg_extension_config_dump('my_config', '');
SELECT pg_catalog.pg_extension_config_dump('my_config_seq', '');
</programlisting>
     Any number of tables or sequences can be marked this way. Sequences
     associated with <type>serial</type> or <type>bigserial</type> columns can
     be marked as well.
    </para>
________________________________________________________-->
    <para>
     要解决这个问题，一个扩展的脚本文件可以把一个它创建的表或者序列标记为配置关系，这将导致<application>pg_dump</application>把该表或者序列的内容（而不是它的定义）包括在转储中。要这样做，在创建表或序列之后调用函数<function>pg_extension_config_dump(regclass, text)</function>，例如
<programlisting>
CREATE TABLE my_config (key text, value text);
CREATE SEQUENCE my_config_seq;

SELECT pg_catalog.pg_extension_config_dump('my_config', '');
SELECT pg_catalog.pg_extension_config_dump('my_config_seq', '');
</programlisting>
     可以用这种方法标记任意数量的表或者序列。与<type>serial</type>或者<type>bigserial</type>列相关联的序列也可以被标记。
    </para>
<!-- pgdoc-cn_end sig_en=901b917dbc323cf4cc69b001c2c9b1a3 -->

<!-- pgdoc-cn_start sig_en=44fd188729fde1dd0ab95ff1b23b3979 sig_cn_org=None source=14.1 
    <para>
     When the second argument of <function>pg_extension_config_dump</function> is
     an empty string, the entire contents of the table are dumped by
     <application>pg_dump</application>.  This is usually only correct if the table
     is initially empty as created by the extension script.  If there is
     a mixture of initial data and user-provided data in the table,
     the second argument of <function>pg_extension_config_dump</function> provides
     a <literal>WHERE</literal> condition that selects the data to be dumped.
     For example, you might do
<programlisting>
CREATE TABLE my_config (key text, value text, standard_entry boolean);

SELECT pg_catalog.pg_extension_config_dump('my_config', 'WHERE NOT standard_entry');
</programlisting>
     and then make sure that <structfield>standard_entry</structfield> is true only
     in the rows created by the extension's script.
    </para>
________________________________________________________-->
    <para>
     当<function>pg_extension_config_dump</function>的第二个参数是一个空字符串时，该表的全部内容都会被<application>pg_dump</application>转储。这通常只有在表被扩展脚本创建为初始为空时才正确。如果在表中混合有初始数据和用户提供的数据，<function>pg_extension_config_dump</function>的第二个参数提供了一种<literal>WHERE</literal>条件来选择要被转储的数据。例如，你可能会做
<programlisting>
CREATE TABLE my_config (key text, value text, standard_entry boolean);

SELECT pg_catalog.pg_extension_config_dump('my_config', 'WHERE NOT standard_entry');
</programlisting>
     并且确保只有扩展脚本创建的行中<structfield>standard_entry</structfield>才为真。
    </para>
<!-- pgdoc-cn_end sig_en=44fd188729fde1dd0ab95ff1b23b3979 -->

<!-- pgdoc-cn_start sig_en=aa8f9c6333465191631e87b6dcb93b4c sig_cn_org=None source=14.1 
    <para>
     For sequences, the second argument of <function>pg_extension_config_dump</function>
     has no effect.
    </para>
________________________________________________________-->
    <para>
     对于序列，<function>pg_extension_config_dump</function>的第二个参数没有影响。
    </para>
<!-- pgdoc-cn_end sig_en=aa8f9c6333465191631e87b6dcb93b4c -->

<!-- pgdoc-cn_start sig_en=e3a987ffbb3f860cabf6631832b598da sig_cn_org=None source=14.1 
    <para>
     More complicated situations, such as initially-provided rows that might
     be modified by users, can be handled by creating triggers on the
     configuration table to ensure that modified rows are marked correctly.
    </para>
________________________________________________________-->
    <para>
     更复杂的情况（例如用户可能会修改初始提供的数据）可以通过在配置表上创建触发器来处理，触发器将负责保证被修改的行会被正确地标记。
    </para>
<!-- pgdoc-cn_end sig_en=e3a987ffbb3f860cabf6631832b598da -->

<!-- pgdoc-cn_start sig_en=7891b345c5d8083edb6c531d9b6fd729 sig_cn_org=None source=14.1 
    <para>
     You can alter the filter condition associated with a configuration table
     by calling <function>pg_extension_config_dump</function> again.  (This would
     typically be useful in an extension update script.)  The only way to mark
     a table as no longer a configuration table is to dissociate it from the
     extension with <command>ALTER EXTENSION ... DROP TABLE</command>.
    </para>
________________________________________________________-->
    <para>
     你可通过再次调用<function>pg_extension_config_dump</function>来修改与一个配置表相关的过滤条件（这通常对于一个扩展更新脚本有用）。将一个表标记为不再是一个配置表的方法是用<command>ALTER EXTENSION ... DROP TABLE</command>将它与扩展脱离开。
    </para>
<!-- pgdoc-cn_end sig_en=7891b345c5d8083edb6c531d9b6fd729 -->

<!-- pgdoc-cn_start sig_en=ee8248e31dabeda5b94652f68e0aeac3 sig_cn_org=None source=14.1 
    <para>
     Note that foreign key relationships between these tables will dictate the
     order in which the tables are dumped out by pg_dump.  Specifically, pg_dump
     will attempt to dump the referenced-by table before the referencing table.
     As the foreign key relationships are set up at CREATE EXTENSION time (prior
     to data being loaded into the tables) circular dependencies are not
     supported.  When circular dependencies exist, the data will still be dumped
     out but the dump will not be able to be restored directly and user
     intervention will be required.
    </para>
________________________________________________________-->
    <para>
     注意这些表之间的外键关系将会指导这些表被 pg_dump 转储的顺序。特别地，pg_dump 将尝试
     先转储被引用的表再转储引用表。由于外键关系是在 CREATE EXTENSION 时间（先于数据被载入
     到表中）建立的，环状依赖还没有建立。当环状依赖存在时，数据将仍然被转储，但是该转储无法被
     直接恢复并且必须要用户的介入。
    </para>
<!-- pgdoc-cn_end sig_en=ee8248e31dabeda5b94652f68e0aeac3 -->

<!-- pgdoc-cn_start sig_en=9294f499c244d3aa4367e7d0bbda492a sig_cn_org=None source=14.1 
    <para>
     Sequences associated with <type>serial</type> or <type>bigserial</type> columns
     need to be directly marked to dump their state. Marking their parent
     relation is not enough for this purpose.
    </para>
________________________________________________________-->
    <para>
     与<type>serial</type>或者<type>bigserial</type>列相关联的序列需要被直接标记以转储它们的状态。只标记它们的父关系不足以转储它们的状态。
    </para>
<!-- pgdoc-cn_end sig_en=9294f499c244d3aa4367e7d0bbda492a -->
   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=ba35f24683a82b4564c724781da26695 sig_cn_org=None source=14.1 
    <title>Extension Updates</title>
________________________________________________________-->
    <title>扩展更新</title>
<!-- pgdoc-cn_end sig_en=ba35f24683a82b4564c724781da26695 -->

<!-- pgdoc-cn_start sig_en=737175a2f8493d753c5a7df3a4295872 sig_cn_org=None source=14.1 
    <para>
     One advantage of the extension mechanism is that it provides convenient
     ways to manage updates to the SQL commands that define an extension's
     objects.  This is done by associating a version name or number with
     each released version of the extension's installation script.
     In addition, if you want users to be able to update their databases
     dynamically from one version to the next, you should provide
     <firstterm>update scripts</firstterm> that make the necessary changes to go from
     one version to the next.  Update scripts have names following the pattern
     <literal><replaceable>extension</replaceable>-&minus;<replaceable>old_version</replaceable>-&minus;<replaceable>target_version</replaceable>.sql</literal>
     (for example, <literal>foo-&minus;1.0-&minus;1.1.sql</literal> contains the commands to modify
     version <literal>1.0</literal> of extension <literal>foo</literal> into version
     <literal>1.1</literal>).
    </para>
________________________________________________________-->
    <para>
     扩展机制的一个优点是它提供了方便的方法来管理那些定义扩展中对象的 SQL 命令的更新。
     这是通过为扩展的安装脚本的每一个发行版本关联一个版本名称或者版本号实现的。
     此外，如果你希望用户能够动态地把他们的数据库从一个版本更新到下一个版本，你应该提供<firstterm>更新脚本</firstterm>来做必要的更改。
     更新脚本的名称遵循<literal><replaceable>extension</replaceable>--<replaceable>old_version</replaceable>--<replaceable>target_version</replaceable>.sql</literal>模式
     （例如，<literal>foo--1.0--1.1.sql</literal>包含着把扩展<literal>foo</literal>的版本<literal>1.0</literal>修改成版本<literal>1.1</literal>的命令）。
    </para>
<!-- pgdoc-cn_end sig_en=737175a2f8493d753c5a7df3a4295872 -->

<!-- pgdoc-cn_start sig_en=238f519d9da24c29cc8e50660472d898 sig_cn_org=None source=14.1 
    <para>
     Given that a suitable update script is available, the command
     <command>ALTER EXTENSION UPDATE</command> will update an installed extension
     to the specified new version.  The update script is run in the same
     environment that <command>CREATE EXTENSION</command> provides for installation
     scripts: in particular, <varname>search_path</varname> is set up in the same
     way, and any new objects created by the script are automatically added
     to the extension.  Also, if the script chooses to drop extension member
     objects, they are automatically dissociated from the extension.
    </para>
________________________________________________________-->
    <para>
     假定有一个合适的更新脚本可用，命令<command>ALTER EXTENSION UPDATE</command>将把一个已安装的扩展更新到指定的新版本。更新脚本运行在与<command>CREATE EXTENSION</command>提供给安装脚本相同的环境中：特别是<varname>search_path</varname>会按照相同的方式设置，并且该脚本创建的任何新对象会被自动地加入到扩展中。此外，如果脚本选择删除扩展的成员对象，它们会自动与扩展解除关联。
    </para>
<!-- pgdoc-cn_end sig_en=238f519d9da24c29cc8e50660472d898 -->

<!-- pgdoc-cn_start sig_en=2aaa5af182255047cb808e28377cb1ea sig_cn_org=None source=14.1 
    <para>
     If an extension has secondary control files, the control parameters
     that are used for an update script are those associated with the script's
     target (new) version.
    </para>
________________________________________________________-->
    <para>
     如果一个扩展具有二级控制文件，用于更新脚本的控制参数是那些与新目标版本相关的参数。
    </para>
<!-- pgdoc-cn_end sig_en=2aaa5af182255047cb808e28377cb1ea -->

<!-- pgdoc-cn_start sig_en=acd7afc0c2a3b26a948501c653aa7f1e sig_cn_org=None source=14.1 
    <para>
     <command>ALTER EXTENSION</command> is able to execute sequences of update
     script files to achieve a requested update.  For example, if only
     <literal>foo-&minus;1.0-&minus;1.1.sql</literal> and <literal>foo-&minus;1.1-&minus;2.0.sql</literal> are
     available, <command>ALTER EXTENSION</command> will apply them in sequence if an
     update to version <literal>2.0</literal> is requested when <literal>1.0</literal> is
     currently installed.
    </para>
________________________________________________________-->
    <para>
     <command>ALTER EXTENSION</command>能够执行更新脚本的序列来实现一个要求的更新。例如，如果只有<literal>foo--1.0--1.1.sql</literal>和<literal>foo--1.1--2.0.sql</literal>可用，当前安装了<literal>1.0</literal>版本并且要求更新到版本<literal>2.0</literal>，<command>ALTER EXTENSION</command>将依次应用它们。
    </para>
<!-- pgdoc-cn_end sig_en=acd7afc0c2a3b26a948501c653aa7f1e -->

<!-- pgdoc-cn_start sig_en=27bbffa582e22f4b7ea85a8f4a1077d5 sig_cn_org=None source=14.1 
    <para>
     <productname>PostgreSQL</productname> doesn't assume anything about the properties
     of version names: for example, it does not know whether <literal>1.1</literal>
     follows <literal>1.0</literal>.  It just matches up the available version names
     and follows the path that requires applying the fewest update scripts.
     (A version name can actually be any string that doesn't contain
     <literal>-&minus;</literal> or leading or trailing <literal>-</literal>.)
    </para>
________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>并不假定任何有关版本名称的性质：例如，它不知道<literal>1.1</literal>是否跟在<literal>1.0</literal>后面。它只是匹配可用的版本名称并且遵照要求应用最少更新脚本的路径进行（一个版本名称实际上可以是不含<literal>--</literal>或者前导或后缀<literal>-</literal>的字符串）。
    </para>
<!-- pgdoc-cn_end sig_en=27bbffa582e22f4b7ea85a8f4a1077d5 -->

<!-- pgdoc-cn_start sig_en=5e93ad52c5b8ad8064410587e88c177b sig_cn_org=None source=14.1 
    <para>
     Sometimes it is useful to provide <quote>downgrade</quote> scripts, for
     example <literal>foo-&minus;1.1-&minus;1.0.sql</literal> to allow reverting the changes
     associated with version <literal>1.1</literal>.  If you do that, be careful
     of the possibility that a downgrade script might unexpectedly
     get applied because it yields a shorter path.  The risky case is where
     there is a <quote>fast path</quote> update script that jumps ahead several
     versions as well as a downgrade script to the fast path's start point.
     It might take fewer steps to apply the downgrade and then the fast
     path than to move ahead one version at a time.  If the downgrade script
     drops any irreplaceable objects, this will yield undesirable results.
    </para>
________________________________________________________-->
    <para>
     有时提供<quote>降级</quote>脚本也有用，例如<literal>foo--1.1--1.0.sql</literal>允许把版本<literal>1.1</literal>相关的改变恢复原状。如果你这样做，要当心降级脚本被意外应用的可能性，因为它会得到一个较短的路径。危险的情况是，有一个跳过几个版本的<quote>快速路径</quote>更新脚本还有一个降级到该快速路径开始点的降级脚本。先应用降级然后再应用快速路径可能比一次升级一个版本需要更少的步骤。如果降级版本删除了任何不可替代的对象，这将会得到意想不到的结果。
    </para>
<!-- pgdoc-cn_end sig_en=5e93ad52c5b8ad8064410587e88c177b -->

<!-- pgdoc-cn_start sig_en=3d94d82f5f8f94c36e6a886bddb16d3f sig_cn_org=None source=14.1 
    <para>
     To check for unexpected update paths, use this command:
<programlisting>
SELECT * FROM pg_extension_update_paths('<replaceable>extension_name</replaceable>');
</programlisting>
     This shows each pair of distinct known version names for the specified
     extension, together with the update path sequence that would be taken to
     get from the source version to the target version, or <literal>NULL</literal> if
     there is no available update path.  The path is shown in textual form
     with <literal>-&minus;</literal> separators.  You can use
     <literal>regexp_split_to_array(path,'-&minus;')</literal> if you prefer an array
     format.
    </para>
________________________________________________________-->
    <para>
     要检查意料之外的更新路径，可使用这个命令：
<programlisting>
SELECT * FROM pg_extension_update_paths('<replaceable>extension_name</replaceable>');
</programlisting>
     这会为指定的扩展显示已知的每一个可区分的版本名对，每一个版本名对还带有一个从源版本到目标版本的更新路径序列，如果没有可用的更新路径则这部份信息为<literal>NULL</literal>。该路径显示为用<literal>--</literal>分隔符的文本形式。如果你更喜欢数组格式，可以使用<literal>regexp_split_to_array(path,'--')</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=3d94d82f5f8f94c36e6a886bddb16d3f -->
   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=6c1683f8ff7c3ae62939149548ad59f5 sig_cn_org=None source=14.1 
    <title>Installing Extensions Using Update Scripts</title>
________________________________________________________-->
    <title>用更新脚本安装扩展</title>
<!-- pgdoc-cn_end sig_en=6c1683f8ff7c3ae62939149548ad59f5 -->

<!-- pgdoc-cn_start sig_en=0a7e14c8b2274f12c9c7c872082e8c1c sig_cn_org=None source=14.1 
    <para>
     An extension that has been around for awhile will probably exist in
     several versions, for which the author will need to write update scripts.
     For example, if you have released a <literal>foo</literal> extension in
     versions <literal>1.0</literal>, <literal>1.1</literal>, and <literal>1.2</literal>, there
     should be update scripts <filename>foo-&minus;1.0-&minus;1.1.sql</filename>
     and <filename>foo-&minus;1.1-&minus;1.2.sql</filename>.
     Before <productname>PostgreSQL</productname> 10, it was necessary to also create
     new script files <filename>foo-&minus;1.1.sql</filename> and <filename>foo-&minus;1.2.sql</filename>
     that directly build the newer extension versions, or else the newer
     versions could not be installed directly, only by
     installing <literal>1.0</literal> and then updating.  That was tedious and
     duplicative, but now it's unnecessary, because <command>CREATE
     EXTENSION</command> can follow update chains automatically.
     For example, if only the script
     files <filename>foo-&minus;1.0.sql</filename>, <filename>foo-&minus;1.0-&minus;1.1.sql</filename>,
     and <filename>foo-&minus;1.1-&minus;1.2.sql</filename> are available then a request to
     install version <literal>1.2</literal> is honored by running those three
     scripts in sequence.  The processing is the same as if you'd first
     installed <literal>1.0</literal> and then updated to <literal>1.2</literal>.
     (As with <command>ALTER EXTENSION UPDATE</command>, if multiple pathways are
     available then the shortest is preferred.)  Arranging an extension's
     script files in this style can reduce the amount of maintenance effort
     needed to produce small updates.
    </para>
________________________________________________________-->
    <para>
     一个已经存在一段时间的扩展可能存在多个版本，作者将需要为它们编写更新脚本。例如，如果你已经发布了扩展<literal>foo</literal>的版本<literal>1.0</literal>、<literal>1.1</literal>和<literal>1.2</literal>，就应该有更新脚本<filename>foo--1.0--1.1.sql</filename>和<filename>foo--1.1--1.2.sql</filename>。在<productname>PostgreSQL</productname> 10之前，还有必要创建新的脚本文件<filename>foo--1.1.sql</filename>和<filename>foo--1.2.sql</filename>，它们直接构建比较新的扩展版本，或者新的版本无法被直接安装，而是通过先安装<literal>1.0</literal>然后更新。那种方式是无聊的重复性工作，但是现在它是不必要的了，因为<command>CREATE EXTENSION</command>能够自动遵循更新链。例如，如果只有脚本文件<filename>foo--1.0.sql</filename>、<filename>foo--1.0--1.1.sql</filename>和<filename>foo--1.1--1.2.sql</filename>可用，那么安装版本<literal>1.2</literal>的请求会通过按顺序运行上述三个脚本来实现。这种处理和先安装<literal>1.0</literal>然后更新到<literal>1.2</literal>是一样的（和<command>ALTER EXTENSION UPDATE</command>一样，如果有多条路径可用则优先选择最短的）。按这种风格安排扩展 的脚本文件可以减少生产小更新所需的维护工作量。
    </para>
<!-- pgdoc-cn_end sig_en=0a7e14c8b2274f12c9c7c872082e8c1c -->

<!-- pgdoc-cn_start sig_en=e1701ffa3faf9b76534ff4ea94b702b2 sig_cn_org=None source=14.1 
    <para>
     If you use secondary (version-specific) control files with an extension
     maintained in this style, keep in mind that each version needs a control
     file even if it has no stand-alone installation script, as that control
     file will determine how the implicit update to that version is performed.
     For example, if <filename>foo-&minus;1.0.control</filename> specifies <literal>requires
     = 'bar'</literal> but <literal>foo</literal>'s other control files do not, the
     extension's dependency on <literal>bar</literal> will be dropped when updating
     from <literal>1.0</literal> to another version.
    </para>
________________________________________________________-->
    <para>
     如果以这种风格维护的扩展中使用了二级（版本相关的）控制文件，记住每个版本都需要一个控制文件，即使它没有单独的安装脚本，因为该控制文件将决定如何执行到这个版本的隐式更新。例如，如果<filename>foo--1.0.control</filename>指定有<literal>requires
     = 'bar'</literal>，但<literal>foo</literal>的其他控制文件没有这样做，在从<literal>1.0</literal>更新到另一个版本时，该扩展对<literal>bar</literal>的依赖将被删除。
    </para>
<!-- pgdoc-cn_end sig_en=e1701ffa3faf9b76534ff4ea94b702b2 -->
   </sect2>

   <sect2 id="extend-extensions-security">
<!-- pgdoc-cn_start sig_en=45d6cfab7d4115aad442a686cd91cf6c sig_cn_org=None source=14.1 
    <title>Security Considerations for Extensions</title>
________________________________________________________-->
    <title>Security Considerations for Extensions</title>
<!-- pgdoc-cn_end sig_en=45d6cfab7d4115aad442a686cd91cf6c -->

<!-- pgdoc-cn_start sig_en=c3f8e949ff6908325d17aa00261696ce sig_cn_org=None source=14.1 
    <para>
     Widely-distributed extensions should assume little about the database
     they occupy.  Therefore, it's appropriate to write functions provided
     by an extension in a secure style that cannot be compromised by
     search-path-based attacks.
    </para>
________________________________________________________-->
    <para>
     广泛分布的扩展应该很少考虑它们所占用的数据库。
     因此，以一种不会被基于搜索路径的攻击所破坏的安全风格编写扩展提供的函数是合适的.
    </para>
<!-- pgdoc-cn_end sig_en=c3f8e949ff6908325d17aa00261696ce -->

<!-- pgdoc-cn_start sig_en=bca44000c53b81bb37433193c057aea1 sig_cn_org=None source=14.1 
    <para>
     An extension that has the <varname>superuser</varname> property set to
     true must also consider security hazards for the actions taken within
     its installation and update scripts.  It is not terribly difficult for
     a malicious user to create trojan-horse objects that will compromise
     later execution of a carelessly-written extension script, allowing that
     user to acquire superuser privileges.
    </para>
________________________________________________________-->
    <para>
     将<varname>superuser</varname>设置为真的扩展还必须考虑在其安装和更新脚本中执行的操作的安全危害。
     对于恶意用户来说，创建特洛伊木马对象并不非常困难，这些木马对象会影响到后续粗心编写的扩展脚本的执行，从而允许该用户获得超级用户特权。
    </para>
<!-- pgdoc-cn_end sig_en=bca44000c53b81bb37433193c057aea1 -->

<!-- pgdoc-cn_start sig_en=68f7d6166f13989292fa1000b521faf3 sig_cn_org=None source=14.1 
    <para>
     If an extension is marked <varname>trusted</varname>, then its
     installation schema can be selected by the installing user, who might
     intentionally use an insecure schema in hopes of gaining superuser
     privileges.  Therefore, a trusted extension is extremely exposed from a
     security standpoint, and all its script commands must be carefully
     examined to ensure that no compromise is possible.
    </para>
________________________________________________________-->
    <para>
     如果扩展标记为 <varname>trusted</varname>，则安装用户可以选择其安装模式，安装用户可能会有意使用不安全的模式，希望获得超级用户权限。
     因此，从安全角度来看，受信任的扩展是非常易受攻击的，并且必须仔细检查其所有脚本命令，以确保不会出现危害。
    </para>
<!-- pgdoc-cn_end sig_en=68f7d6166f13989292fa1000b521faf3 -->

<!-- pgdoc-cn_start sig_en=a5153c2b302bf40ba7a7a523d3b3d77b sig_cn_org=None source=14.1 
    <para>
     Advice about writing functions securely is provided in
     <xref linkend="extend-extensions-security-funcs"/> below, and advice
     about writing installation scripts securely is provided in
     <xref linkend="extend-extensions-security-scripts"/>.
    </para>
________________________________________________________-->
    <para>
     关于安全地编写函数的建议在下面的<xref linkend="extend-extensions-security-funcs"/> 中, 
     关于安全编写安装脚本的建议在 <xref linkend="extend-extensions-security-scripts"/>中提供。
    </para>
<!-- pgdoc-cn_end sig_en=a5153c2b302bf40ba7a7a523d3b3d77b -->

    <sect3 id="extend-extensions-security-funcs">
<!-- pgdoc-cn_start sig_en=5444a3706b0cfb6b41aed557b63c0241 sig_cn_org=None source=14.1 
     <title>Security Considerations for Extension Functions</title>
________________________________________________________-->
     <title>Security Considerations for Extension Functions</title>
<!-- pgdoc-cn_end sig_en=5444a3706b0cfb6b41aed557b63c0241 -->

<!-- pgdoc-cn_start sig_en=113bb3dae6dd826508229bf8b42472ae sig_cn_org=None source=14.1 
     <para>
      SQL-language and PL-language functions provided by extensions are at
      risk of search-path-based attacks when they are executed, since
      parsing of these functions occurs at execution time not creation time.
     </para>
________________________________________________________-->
     <para>
      扩展提供的SQL-language和PL-language 函数在执行时面临基于搜索路径的攻击风险，因为解析这些函数发生在执行时，而不是创建时。
     </para>
<!-- pgdoc-cn_end sig_en=113bb3dae6dd826508229bf8b42472ae -->

<!-- pgdoc-cn_start sig_en=4bc0beec462c3d34ec3534921add44af sig_cn_org=None source=14.1 
     <para>
      The <link linkend="sql-createfunction-security"><command>CREATE
      FUNCTION</command></link> reference page contains advice about
      writing <literal>SECURITY DEFINER</literal> functions safely.  It's
      good practice to apply those techniques for any function provided by
      an extension, since the function might be called by a high-privilege
      user.
     </para>
________________________________________________________-->
     <para>
      <link linkend="sql-createfunction-security"><command>CREATE FUNCTION</command></link>参考页包含有关安全地编写<literal>SECURITY DEFINER</literal>函数的建议。
      将这些技术应用于扩展提供的任何函数是一种很好的做法，因为该函数可能由具有高权限的用户调用。
     </para>
<!-- pgdoc-cn_end sig_en=4bc0beec462c3d34ec3534921add44af -->

     <!-- XXX It's not enough to use qualified names, because one might write a
          qualified name to an object that itself uses unqualified names.  Many
          information_schema functions have that defect, for example.  However,
          that's a defect in the referenced object, and relatively few queries
          will be affected.  Also, we direct applications to secure search_path
          when connecting to an untrusted database; if applications do that,
          they are immune to known attacks even if some extension refers to a
          defective object.  Therefore, guide extension authors as though core
          PostgreSQL contained no such defect. -->
<!-- pgdoc-cn_start sig_en=ba6d651545af6489856df425d7a16b69 sig_cn_org=None source=14.1 
     <para>
      If you cannot set the <varname>search_path</varname> to contain only
      secure schemas, assume that each unqualified name could resolve to an
      object that a malicious user has defined.  Beware of constructs that
      depend on <varname>search_path</varname> implicitly; for
      example, <token>IN</token>
      and <literal>CASE <replaceable>expression</replaceable> WHEN</literal>
      always select an operator using the search path.  In their place, use
      <literal>OPERATOR(<replaceable>schema</replaceable>.=) ANY</literal>
      and <literal>CASE WHEN <replaceable>expression</replaceable></literal>.
     </para>
________________________________________________________-->
     <para>
      如果无法将<varname>search_path</varname>设置为仅包含安全模式，假设每个无资格的名称都可以解析为恶意用户定义的对象。 
      小心隐式依赖于<varname>search_path</varname> 的构造;例如，<token>IN</token>和<literal>CASE <replaceable>expression</replaceable> WHEN</literal>总是使用搜索路径选择操作符。 
      在它们的位置，使用<literal>OPERATOR(<replaceable>schema</replaceable>.=) ANY</literal> 和 <literal>CASE WHEN <replaceable>expression</replaceable></literal>。
     </para>
<!-- pgdoc-cn_end sig_en=ba6d651545af6489856df425d7a16b69 -->

<!-- pgdoc-cn_start sig_en=9b991cd02a7deec8b65d86a28dfbe325 sig_cn_org=None source=14.1 
     <para>
      A general-purpose extension usually should not assume that it's been
      installed into a secure schema, which means that even schema-qualified
      references to its own objects are not entirely risk-free.  For
      example, if the extension has defined a
      function <literal>myschema.myfunc(bigint)</literal> then a call such
      as <literal>myschema.myfunc(42)</literal> could be captured by a
      hostile function <literal>myschema.myfunc(integer)</literal>.  Be
      careful that the data types of function and operator parameters exactly
      match the declared argument types, using explicit casts where necessary.
     </para>
________________________________________________________-->
     <para>
      通用扩展通常不应假定它已安装到安全模式中，这意味着即使是对其自身对象的模式限定引用也不是完全无风险的。 
      例如，如果扩展定义了一个函数<literal>myschema.myfunc(bigint)</literal>，则诸如<literal>myschema.myfunc(42)</literal>此类的调用可以被恶意函数<literal>myschema.myfunc(integer)</literal>捕获。 
      请注意，函数和操作符形参的数据类型与声明的实参类型完全匹配，必要时可使用显式强制转换。
     </para>
<!-- pgdoc-cn_end sig_en=9b991cd02a7deec8b65d86a28dfbe325 -->
    </sect3>

    <sect3 id="extend-extensions-security-scripts">
<!-- pgdoc-cn_start sig_en=fea6cabdd02f791582b5ef5c9e667d15 sig_cn_org=None source=14.1 
     <title>Security Considerations for Extension Scripts</title>
________________________________________________________-->
     <title>Security Considerations for Extension Scripts</title>
<!-- pgdoc-cn_end sig_en=fea6cabdd02f791582b5ef5c9e667d15 -->

<!-- pgdoc-cn_start sig_en=c0cccb6b1381f9040fa180381a50ec35 sig_cn_org=None source=14.1 
     <para>
      An extension installation or update script should be written to guard
      against search-path-based attacks occurring when the script executes.
      If an object reference in the script can be made to resolve to some
      other object than the script author intended, then a compromise might
      occur immediately, or later when the mis-defined extension object is
      used.
     </para>
________________________________________________________-->
     <para>
      编写扩展安装或更新脚本以防止脚本执行时发生基于搜索路径的攻击。
      如果脚本中的对象引用可以解析到脚本作者预期之外的其他对，则可能会立即发生妥协，或者在稍后使用错误定义的扩展对象时发生妥协。
     </para>
<!-- pgdoc-cn_end sig_en=c0cccb6b1381f9040fa180381a50ec35 -->

<!-- pgdoc-cn_start sig_en=d518cd2a94af6008683ff061c3dbdd9b sig_cn_org=None source=14.1 
     <para>
      DDL commands such as <command>CREATE FUNCTION</command>
      and <command>CREATE OPERATOR CLASS</command> are generally secure,
      but beware of any command having a general-purpose expression as a
      component.  For example, <command>CREATE VIEW</command> needs to be
      vetted, as does a <literal>DEFAULT</literal> expression
      in <command>CREATE FUNCTION</command>.
     </para>
________________________________________________________-->
     <para>
      DDL 命令例如 <command>CREATE FUNCTION</command> 和 <command>CREATE OPERATOR CLASS</command> 通常是安全的,但要注意任何具有通用表达式作为组件的命令。
      例如, <command>CREATE VIEW</command> 需要经过审查, 就像 <command>CREATE FUNCTION</command>中的 <literal>DEFAULT</literal> 表达式一样。
     </para>
<!-- pgdoc-cn_end sig_en=d518cd2a94af6008683ff061c3dbdd9b -->

<!-- pgdoc-cn_start sig_en=82dc66d9ef4b8c139658eb5a632dae9f sig_cn_org=None source=14.1 
     <para>
      Sometimes an extension script might need to execute general-purpose
      SQL, for example to make catalog adjustments that aren't possible via
      DDL.  Be careful to execute such commands with a
      secure <varname>search_path</varname>; do <emphasis>not</emphasis>
      trust the path provided by <command>CREATE/ALTER EXTENSION</command>
      to be secure.  Best practice is to temporarily
      set <varname>search_path</varname> to <literal>'pg_catalog,
      pg_temp'</literal> and insert references to the extension's
      installation schema explicitly where needed.  (This practice might
      also be helpful for creating views.)  Examples can be found in
      the <filename>contrib</filename> modules in
      the <productname>PostgreSQL</productname> source code distribution.
     </para>
________________________________________________________-->
     <para>
      有时，扩展脚本可能需要执行通用 SQL，例如，通过DDL无法进行目录调整。
      小心地使用安全操作执行此类<varname>search_path</varname>；
      <emphasis>不要</emphasis> 相信由 <command>CREATE/ALTER EXTENSION</command> 提供的路径是安全的。
      最佳做法是暂时设置<varname>search_path</varname> 到 <literal>'pg_catalog, pg_temp'</literal>，并根据需要显式插入对扩展安装架构的引用。
      （这种做法可能也有助于创建视图。）
      示例可以在<productname>PostgreSQL</productname>源代码分发版本的<filename>contrib</filename>模块中找到。
     </para>
<!-- pgdoc-cn_end sig_en=82dc66d9ef4b8c139658eb5a632dae9f -->

<!-- pgdoc-cn_start sig_en=f00c155d69d2b56b631ee0c11edcc4d5 sig_cn_org=None source=14.1 
     <para>
      Cross-extension references are extremely difficult to make fully
      secure, partially because of uncertainty about which schema the other
      extension is in.  The hazards are reduced if both extensions are
      installed in the same schema, because then a hostile object cannot be
      placed ahead of the referenced extension in the installation-time
      <varname>search_path</varname>.  However, no mechanism currently exists
      to require that.  For now, best practice is to not mark an extension
      trusted if it depends on another one, unless that other one is always
      installed in <literal>pg_catalog</literal>.
     </para>
________________________________________________________-->
     <para>
      交叉扩展引用极难做到完全安全，部分由于不确定另一个扩展位于哪个模式中。
      如果两个扩展都安装在同一模式中，则危险会减少，因为在安装时间中无法将恶意对象置于引用的扩展<varname>search_path</varname>。 
      但是，目前没有任何机制要求这样做。
      目前，最佳做法是，如果扩展依赖于另一个扩展，则不要标记它受信任的扩展，除非该扩展始终安装在<literal>pg_catalog</literal>中。
     </para>
<!-- pgdoc-cn_end sig_en=f00c155d69d2b56b631ee0c11edcc4d5 -->
    </sect3>
   </sect2>

   <sect2 id="extend-extensions-example">
<!-- pgdoc-cn_start sig_en=0104767d1b5cbf3c80bc1511b3fc760d sig_cn_org=None source=14.1 
    <title>Extension Example</title>
________________________________________________________-->
    <title>扩展实例</title>
<!-- pgdoc-cn_end sig_en=0104767d1b5cbf3c80bc1511b3fc760d -->

<!-- pgdoc-cn_start sig_en=38e44c90a79407b7cfcfecc2011ec70f sig_cn_org=None source=14.1 
    <para>
     Here is a complete example of an <acronym>SQL</acronym>-only
     extension, a two-element composite type that can store any type of value
     in its slots, which are named <quote>k</quote> and <quote>v</quote>.  Non-text
     values are automatically coerced to text for storage.
    </para>
________________________________________________________-->
    <para>
     这里是一个只用<acronym>SQL</acronym>的扩展的完整例子，一个两个元素的组合类型，它可以在它的槽（命名为<quote>k</quote>和<quote>v</quote>）中存储任何类型的值。非文本值会被自动强制为文本进行存储。
    </para>
<!-- pgdoc-cn_end sig_en=38e44c90a79407b7cfcfecc2011ec70f -->

<!-- pgdoc-cn_start sig_en=5c26aa8c573f2ed27b6b8ec1b2c80543 sig_cn_org=None source=14.1 
    <para>
     The script file <filename>pair-&minus;1.0.sql</filename> looks like this:

<programlisting><![CDATA[
-&minus; complain if script is sourced in psql, rather than via CREATE EXTENSION
\echo Use "CREATE EXTENSION pair" to load this file. \quit

CREATE TYPE pair AS ( k text, v text );

CREATE FUNCTION pair(text, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::@extschema@.pair;';

CREATE OPERATOR ~> (LEFTARG = text, RIGHTARG = text, FUNCTION = pair);

-&minus; "SET search_path" is easy to get right, but qualified names perform better.
CREATE FUNCTION lower(pair)
RETURNS pair LANGUAGE SQL
AS 'SELECT ROW(lower($1.k), lower($1.v))::@extschema@.pair;'
SET search_path = pg_temp;

CREATE FUNCTION pair_concat(pair, pair)
RETURNS pair LANGUAGE SQL
AS 'SELECT ROW($1.k OPERATOR(pg_catalog.||) $2.k,
               $1.v OPERATOR(pg_catalog.||) $2.v)::@extschema@.pair;';
]]>
</programlisting>
    </para>
________________________________________________________-->
    <para>
     脚本文件<filename>pair--1.0.sql</filename>看起来像这样：

<programlisting><![CDATA[
-- 如果脚本是由 psql 而不是 CREATE EXTENSION 执行，则报错
\echo Use "CREATE EXTENSION pair" to load this file. \quit

CREATE TYPE pair AS ( k text, v text );

CREATE FUNCTION pair(text, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::@extschema@.pair;';

CREATE OPERATOR ~> (LEFTARG = text, RIGHTARG = text, FUNCTION = pair);

-- "SET search_path" 容易操作，但限定名称更好。
CREATE FUNCTION lower(pair)
RETURNS pair LANGUAGE SQL
AS 'SELECT ROW(lower($1.k), lower($1.v))::@extschema@.pair;'
SET search_path = pg_temp;

CREATE FUNCTION pair_concat(pair, pair)
RETURNS pair LANGUAGE SQL
AS 'SELECT ROW($1.k OPERATOR(pg_catalog.||) $2.k,
               $1.v OPERATOR(pg_catalog.||) $2.v)::@extschema@.pair;';
]]>
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=5c26aa8c573f2ed27b6b8ec1b2c80543 -->

<!-- pgdoc-cn_start sig_en=9e372d38f3e2dde7fad6fea705222137 sig_cn_org=None source=14.1 
    <para>
     The control file <filename>pair.control</filename> looks like this:

<programlisting>
# pair extension
comment = 'A key/value pair data type'
default_version = '1.0'
# cannot be relocatable because of use of @extschema@
relocatable = false
</programlisting>
    </para>
________________________________________________________-->
    <para>
     控制文件<filename>pair.control</filename>看起来像这样：

<programlisting>
# pair 扩展
comment = 'A key/value pair data type'
default_version = '1.0'
# cannot be relocatable because of use of @extschema@
relocatable = false
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=9e372d38f3e2dde7fad6fea705222137 -->

<!-- pgdoc-cn_start sig_en=ec57e9e81223c437fe207f7e7630c298 sig_cn_org=None source=14.1 
    <para>
     While you hardly need a makefile to install these two files into the
     correct directory, you could use a <filename>Makefile</filename> containing this:

<programlisting>
EXTENSION = pair
DATA = pair-&minus;1.0.sql

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) -&minus;pgxs)
include $(PGXS)
</programlisting>

     This makefile relies on <acronym>PGXS</acronym>, which is described
     in <xref linkend="extend-pgxs"/>.  The command <literal>make install</literal>
     will install the control and script files into the correct
     directory as reported by <application>pg_config</application>.
    </para>
________________________________________________________-->
    <para>
     虽然你几乎不会需要一个 makefile 来安装这两个文件到正确的目录，你还是可以使用一个<filename>Makefile</filename>：

<programlisting>
EXTENSION = pair
DATA = pair--1.0.sql

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
</programlisting>

     这个 makefile 依赖于<acronym>PGXS</acronym>，它在<xref linkend="extend-pgxs"/>中描述。命令<literal>make install</literal>将把控制和脚本文件安装到<application>pg_config</application>报告的正确的目录中。
    </para>
<!-- pgdoc-cn_end sig_en=ec57e9e81223c437fe207f7e7630c298 -->

<!-- pgdoc-cn_start sig_en=2b92ef0e40aa857ce4492946c9971a8c sig_cn_org=None source=14.1 
    <para>
     Once the files are installed, use the
     <command>CREATE EXTENSION</command> command to load the objects into
     any particular database.
    </para>
________________________________________________________-->
    <para>
     一旦文件被安装，使用<command>CREATE EXTENSION</command>命令就可以把对象载入到任何特定的数据库中。
    </para>
<!-- pgdoc-cn_end sig_en=2b92ef0e40aa857ce4492946c9971a8c -->
   </sect2>
  </sect1>

  <sect1 id="extend-pgxs">
<!-- pgdoc-cn_start sig_en=35ba5ff0e85b731335956ede56709441 sig_cn_org=None source=14.1 
   <title>Extension Building Infrastructure</title>
________________________________________________________-->
   <title>扩展的构建基础设施</title>
<!-- pgdoc-cn_end sig_en=35ba5ff0e85b731335956ede56709441 -->

<!-- pgdoc-cn_start sig_en=6bcc1388957daa4800de6628cbcac10a sig_cn_org=None source=14.1 
   <indexterm zone="extend-pgxs">
    <primary>pgxs</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="extend-pgxs">
    <primary>pgxs</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=6bcc1388957daa4800de6628cbcac10a -->

<!-- pgdoc-cn_start sig_en=7478a97364ab7ceabf00136e41854abf sig_cn_org=None source=14.1 
   <para>
    If you are thinking about distributing your
    <productname>PostgreSQL</productname> extension modules, setting up a
    portable build system for them can be fairly difficult.  Therefore
    the <productname>PostgreSQL</productname> installation provides a build
    infrastructure for extensions, called <acronym>PGXS</acronym>, so
    that simple extension modules can be built simply against an
    already installed server.  <acronym>PGXS</acronym> is mainly intended
    for extensions that include C code, although it can be used for
    pure-SQL extensions too.  Note that <acronym>PGXS</acronym> is not
    intended to be a universal build system framework that can be used
    to build any software interfacing to <productname>PostgreSQL</productname>;
    it simply automates common build rules for simple server extension
    modules.  For more complicated packages, you might need to write your
    own build system.
   </para>
________________________________________________________-->
   <para>
    如果你正在考虑发布你的<productname>PostgreSQL</productname>扩展模块，为它们建立一个可移植的构建系统实在是相当困难。因此<productname>PostgreSQL</productname>安装为扩展提供了一种被称为<acronym>PGXS</acronym>构建基础设施，因此简单的扩展模块能够在一个已经安装的服务器上简单地编译。<acronym>PGXS</acronym>主要是为了包括 C 代码的扩展而设计，不过它也能用于纯 SQL 的扩展。注意<acronym>PGXS</acronym>并不想成为一种用于构建任何与<productname>PostgreSQL</productname>交互的软件的通用构建系统框架。它只是简单地把简单服务器扩展模块的公共构建规则自动化。对于更复杂的包，你可能需要编写你自己的构建系统。
   </para>
<!-- pgdoc-cn_end sig_en=7478a97364ab7ceabf00136e41854abf -->

<!-- pgdoc-cn_start sig_en=7488a71c54d1060be28d2cc4800c5645 sig_cn_org=None source=14.1 
   <para>
    To use the <acronym>PGXS</acronym> infrastructure for your extension,
    you must write a simple makefile.
    In the makefile, you need to set some variables
    and include the global <acronym>PGXS</acronym> makefile.
    Here is an example that builds an extension module named
    <literal>isbn_issn</literal>, consisting of a shared library containing
    some C code, an extension control file, an SQL script, an include file
    (only needed if other modules might need to access the extension functions
    without going via SQL), and a documentation text file:
<programlisting>
MODULES = isbn_issn
EXTENSION = isbn_issn
DATA = isbn_issn-&minus;1.0.sql
DOCS = README.isbn_issn
HEADERS_isbn_issn = isbn_issn.h

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) -&minus;pgxs)
include $(PGXS)
</programlisting>
    The last three lines should always be the same.  Earlier in the
    file, you assign variables or add custom
    <application>make</application> rules.
   </para>
________________________________________________________-->
   <para>
    要把<acronym>PGXS</acronym>基础设施用于你的扩展，你必须编写一个简单的 makefile。在这个 makefile 中，你需要设置一些变量并且把它们包括在全局的<acronym>PGXS</acronym> makefile 中。这里有一个例子，它构建一个名为<literal>isbn_issn</literal>的扩展模块，其中包括一个含有 C 代码的共享库、一个扩展控制文件、一个 SQL 脚本、一个包括文件（仅当其他模块可能需要通过调用而不是SQL访问这个扩展的函数时才需要）以及一个文档文件：
<programlisting>
MODULES = isbn_issn
EXTENSION = isbn_issn
DATA = isbn_issn--1.0.sql
DOCS = README.isbn_issn
HEADERS_isbn_issn = isbn_issn.h

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
</programlisting>
    最后三行应该总是相同的。在这个文件的前面部分，你要对变量赋值或者增加自定义的<application>make</application>规则。
   </para>
<!-- pgdoc-cn_end sig_en=7488a71c54d1060be28d2cc4800c5645 -->

<!-- pgdoc-cn_start sig_en=257e9f649ec113458901320707276a66 sig_cn_org=None source=14.1 
   <para>
    Set one of these three variables to specify what is built:

    <variablelist>
     <varlistentry>
      <term><varname>MODULES</varname></term>
      <listitem>
       <para>
        list of shared-library objects to be built from source files with same
        stem (do not include library suffixes in this list)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>MODULE_big</varname></term>
      <listitem>
       <para>
        a shared library to build from multiple source files
        (list object files in <varname>OBJS</varname>)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PROGRAM</varname></term>
      <listitem>
       <para>
        an executable program to build
        (list object files in <varname>OBJS</varname>)
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    The following variables can also be set:

    <variablelist>
     <varlistentry>
      <term><varname>EXTENSION</varname></term>
      <listitem>
       <para>
        extension name(s); for each name you must provide an
        <literal><replaceable>extension</replaceable>.control</literal> file,
        which will be installed into
        <literal><replaceable>prefix</replaceable>/share/extension</literal>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>MODULEDIR</varname></term>
      <listitem>
       <para>
        subdirectory of <literal><replaceable>prefix</replaceable>/share</literal>
        into which DATA and DOCS files should be installed
        (if not set, default is <literal>extension</literal> if
        <varname>EXTENSION</varname> is set,
        or <literal>contrib</literal> if not)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DATA</varname></term>
      <listitem>
       <para>
        random files to install into <literal><replaceable>prefix</replaceable>/share/$MODULEDIR</literal>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DATA_built</varname></term>
      <listitem>
       <para>
        random files to install into
        <literal><replaceable>prefix</replaceable>/share/$MODULEDIR</literal>,
        which need to be built first
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DATA_TSEARCH</varname></term>
      <listitem>
       <para>
        random files to install under
        <literal><replaceable>prefix</replaceable>/share/tsearch_data</literal>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DOCS</varname></term>
      <listitem>
       <para>
        random files to install under
        <literal><replaceable>prefix</replaceable>/doc/$MODULEDIR</literal>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>HEADERS</varname></term>
      <term><varname>HEADERS_built</varname></term>
      <listitem>
       <para>
        Files to (optionally build and) install under
        <literal><replaceable>prefix</replaceable>/include/server/$MODULEDIR/$MODULE_big</literal>.
       </para>
       <para>
        Unlike <literal>DATA_built</literal>, files in <literal>HEADERS_built</literal>
        are not removed by the <literal>clean</literal> target; if you want them removed,
        also add them to <literal>EXTRA_CLEAN</literal> or add your own rules to do it.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>HEADERS_$MODULE</varname></term>
      <term><varname>HEADERS_built_$MODULE</varname></term>
      <listitem>
       <para>
        Files to install (after building if specified) under
        <literal><replaceable>prefix</replaceable>/include/server/$MODULEDIR/$MODULE</literal>,
        where <literal>$MODULE</literal> must be a module name used
        in <literal>MODULES</literal> or <literal>MODULE_big</literal>.
       </para>
       <para>
        Unlike <literal>DATA_built</literal>, files in <literal>HEADERS_built_$MODULE</literal>
        are not removed by the <literal>clean</literal> target; if you want them removed,
        also add them to <literal>EXTRA_CLEAN</literal> or add your own rules to do it.
       </para>
       <para>
        It is legal to use both variables for the same module, or any
        combination, unless you have two module names in the
        <literal>MODULES</literal> list that differ only by the presence of a
        prefix <literal>built_</literal>, which would cause ambiguity. In
        that (hopefully unlikely) case, you should use only the
        <literal>HEADERS_built_$MODULE</literal> variables.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>SCRIPTS</varname></term>
      <listitem>
       <para>
        script files (not binaries) to install into
        <literal><replaceable>prefix</replaceable>/bin</literal>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>SCRIPTS_built</varname></term>
      <listitem>
       <para>
        script files (not binaries) to install into
        <literal><replaceable>prefix</replaceable>/bin</literal>,
        which need to be built first
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>REGRESS</varname></term>
      <listitem>
       <para>
        list of regression test cases (without suffix), see below
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>REGRESS_OPTS</varname></term>
      <listitem>
       <para>
        additional switches to pass to <application>pg_regress</application>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>ISOLATION</varname></term>
      <listitem>
       <para>
        list of isolation test cases, see below for more details
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>ISOLATION_OPTS</varname></term>
      <listitem>
       <para>
        additional switches to pass to
        <application>pg_isolation_regress</application>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>TAP_TESTS</varname></term>
      <listitem>
       <para>
        switch defining if TAP tests need to be run, see below
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>NO_INSTALL</varname></term>
      <listitem>
       <para>
        don't define an <literal>install</literal> target, useful for test
        modules that don't need their build products to be installed
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>NO_INSTALLCHECK</varname></term>
      <listitem>
       <para>
        don't define an <literal>installcheck</literal> target, useful e.g., if tests require special configuration, or don't use <application>pg_regress</application>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>EXTRA_CLEAN</varname></term>
      <listitem>
       <para>
        extra files to remove in <literal>make clean</literal>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_CPPFLAGS</varname></term>
      <listitem>
       <para>
        will be prepended to <varname>CPPFLAGS</varname>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_CFLAGS</varname></term>
      <listitem>
       <para>
        will be appended to <varname>CFLAGS</varname>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_CXXFLAGS</varname></term>
      <listitem>
       <para>
        will be appended to <varname>CXXFLAGS</varname>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_LDFLAGS</varname></term>
      <listitem>
       <para>
        will be prepended to <varname>LDFLAGS</varname>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_LIBS</varname></term>
      <listitem>
       <para>
        will be added to <varname>PROGRAM</varname> link line
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>SHLIB_LINK</varname></term>
      <listitem>
       <para>
        will be added to <varname>MODULE_big</varname> link line
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_CONFIG</varname></term>
      <listitem>
       <para>
        path to <application>pg_config</application> program for the
        <productname>PostgreSQL</productname> installation to build against
        (typically just <literal>pg_config</literal> to use the first one in your
        <varname>PATH</varname>)
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    设置这三个变量之一来指定要构建什么：

    <variablelist>
     <varlistentry>
      <term><varname>MODULES</varname></term>
      <listitem>
       <para>
        要从源文件构建的具有相同词干的共享库对象的列表（不要在这个列表中包括库后缀）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>MODULE_big</varname></term>
      <listitem>
       <para>
        一个要从多个源文件中构建的共享库（在<varname>OBJS</varname>中列出对象文件）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PROGRAM</varname></term>
      <listitem>
       <para>
        一个要构建的可执行程序（在<varname>OBJS</varname>中列出对象文件）
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    还可以设置下列变量：

    <variablelist>
     <varlistentry>
      <term><varname>EXTENSION</varname></term>
      <listitem>
       <para>
        扩展名称；你必须为每一个名称提供一个<literal><replaceable>extension</replaceable>.control</literal>文件，它将被安装到<literal><replaceable>prefix</replaceable>/share/extension</literal>中
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>MODULEDIR</varname></term>
      <listitem>
       <para>
        subdirectory of <literal><replaceable>prefix</replaceable>/share</literal>的子目录，DATA 和 DOCS 文件会被安装到其中（如果没有设置，设置了<varname>EXTENSION</varname>时默认为<literal>extension</literal>，没有设置<varname>EXTENSION</varname>时默认为<literal>contrib</literal>）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DATA</varname></term>
      <listitem>
       <para>
        要安装到<literal><replaceable>prefix</replaceable>/share/$MODULEDIR</literal>中的随机文件
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DATA_built</varname></term>
      <listitem>
       <para>
        要安装到<literal><replaceable>prefix</replaceable>/share/$MODULEDIR</literal>中的随机文件，它们需要先被构建
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DATA_TSEARCH</varname></term>
      <listitem>
       <para>
        要安装到<literal><replaceable>prefix</replaceable>/share/tsearch_data</literal>中的随机文件
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DOCS</varname></term>
      <listitem>
       <para>
        要安装到<literal><replaceable>prefix</replaceable>/doc/$MODULEDIR</literal>中的随机文件
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>HEADERS</varname></term>
      <term><varname>HEADERS_built</varname></term>
      <listitem>
       <para>
        要（构建并且）安装在<literal><replaceable>prefix</replaceable>/include/server/$MODULEDIR/$MODULE_big</literal>下面的文件。
       </para>
       <para>
        和<literal>DATA_built</literal>不同，<literal>HEADERS_built</literal>中的文件不会被<literal>clean</literal>目标移除，如果想要移除它们，把它们也加入到<literal>EXTRA_CLEAN</literal>或者增加自己的规则来做这件事。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>HEADERS_$MODULE</varname></term>
      <term><varname>HEADERS_built_$MODULE</varname></term>
      <listitem>
       <para>
        要安装（如果指定了构建则在构建之后安装）在<literal><replaceable>prefix</replaceable>/include/server/$MODULEDIR/$MODULE</literal>之下的文件，这里<literal>$MODULE</literal>必须是一个在<literal>MODULES</literal> or <literal>MODULE_big</literal>中用到的模块名。
       </para>
       <para>
        和<literal>DATA_built</literal>不同，<literal>HEADERS_built_$MODULE</literal>中的文件不会被<literal>clean</literal>目标移除，如果想要移除它们，把它们也加入到<literal>EXTRA_CLEAN</literal>或者增加自己的规则来做这件事。
       </para>
       <para>
        可以为同一个模块同时使用这两个变量或者两者的任意组合，除非你在<literal>MODULES</literal>列表中有两个模块名称仅有前缀<literal>built_</literal>上的区别，因为那样会导致歧义。在那种情况下（还好不太可能），应该仅使用<literal>HEADERS_built_$MODULE</literal>变量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>SCRIPTS</varname></term>
      <listitem>
       <para>
        要安装到<literal><replaceable>prefix</replaceable>/bin</literal>中的脚本文件（非二进制）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>SCRIPTS_built</varname></term>
      <listitem>
       <para>
        要安装到<literal><replaceable>prefix</replaceable>/bin</literal>中的脚本文件（非二进制），它们需要先被构建
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>REGRESS</varname></term>
      <listitem>
       <para>
        回归测试案例（不带后缀）的列表，见下文
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>REGRESS_OPTS</varname></term>
      <listitem>
       <para>
        要传递给<application>pg_regress</application>的附加开关
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>ISOLATION</varname></term>
      <listitem>
       <para>
        隔离测试用例列表，请参阅下文了解更多详细信息。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>ISOLATION_OPTS</varname></term>
      <listitem>
       <para>
        要传递给<application>pg_isolation_regress</application>的附加开关
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>TAP_TESTS</varname></term>
      <listitem>
       <para>
        是否需要运行 TAP 测试的开关定义，请参阅下文
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>NO_INSTALL</varname></term>
      <listitem>
       <para>
        不定义一个 <literal>install</literal> 目标， 对于不需要它们构建要被安装的产品的测试模块时有用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>NO_INSTALLCHECK</varname></term>
      <listitem>
       <para>
        不定义<literal>installcheck</literal>目标，如果测试要求特殊的配置就会很有用，或者不使用<application>pg_regress</application>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>EXTRA_CLEAN</varname></term>
      <listitem>
       <para>
        要在<literal>make clean</literal>中移除的额外文件
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_CPPFLAGS</varname></term>
      <listitem>
       <para>
        将被加到<varname>CPPFLAGS</varname>前面
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_CFLAGS</varname></term>
      <listitem>
       <para>
        将被加到<varname>CFLAGS</varname>后面
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_CXXFLAGS</varname></term>
      <listitem>
       <para>
        将被加到<varname>CXXFLAGS</varname>后面
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_LDFLAGS</varname></term>
      <listitem>
       <para>
        将被加到<varname>LDFLAGS</varname>前面
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_LIBS</varname></term>
      <listitem>
       <para>
        将被加到<varname>PROGRAM</varname>链接行
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>SHLIB_LINK</varname></term>
      <listitem>
       <para>
        将被加到<varname>MODULE_big</varname>链接行
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_CONFIG</varname></term>
      <listitem>
       <para>
        要在其中构建的<productname>PostgreSQL</productname>安装的<application>pg_config</application>程序的路径（通常只用在你的<varname>PATH</varname>中的第一个<literal>pg_config</literal>）
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=257e9f649ec113458901320707276a66 -->

<!-- pgdoc-cn_start sig_en=6db3aa268b0b2fee98a1159ad813a1e9 sig_cn_org=None source=14.1 
   <para>
    Put this makefile as <literal>Makefile</literal> in the directory
    which holds your extension. Then you can do
    <literal>make</literal> to compile, and then <literal>make
    install</literal> to install your module.  By default, the extension is
    compiled and installed for the
    <productname>PostgreSQL</productname> installation that
    corresponds to the first <command>pg_config</command> program
    found in your <varname>PATH</varname>.  You can use a different installation by
    setting <varname>PG_CONFIG</varname> to point to its
    <command>pg_config</command> program, either within the makefile
    or on the <literal>make</literal> command line.
   </para>
________________________________________________________-->
   <para>
    把这个 makefile 作为<literal>Makefile</literal>放在保存你扩展的目录中。然后你可以执行<literal>make</literal>进行编译，并且接着<literal>make install</literal>来安装你的模块。默认情况下，该模块会为在你的<varname>PATH</varname>中找到的第一个<command>pg_config</command>程序所对应的<productname>PostgreSQL</productname>安装编译和安装。你可以通过在 makefile 中或者<literal>make</literal>命令行中设置<varname>PG_CONFIG</varname>指向另一个<command>pg_config</command>程序来使用一个不同的安装。
   </para>
<!-- pgdoc-cn_end sig_en=6db3aa268b0b2fee98a1159ad813a1e9 -->

<!-- pgdoc-cn_start sig_en=664c159661188b83ecc379ec571b62bc sig_cn_org=None source=14.1 
   <para>
    You can also run <literal>make</literal> in a directory outside the source
    tree of your extension, if you want to keep the build directory separate.
    This procedure is also called a
    <indexterm><primary>VPATH</primary></indexterm><firstterm>VPATH</firstterm>
    build.  Here's how:
<programlisting>
mkdir build_dir
cd build_dir
make -f /path/to/extension/source/tree/Makefile
make -f /path/to/extension/source/tree/Makefile install
</programlisting>
   </para>
________________________________________________________-->
   <para>
    如果你想保持编译目录独立，你也可以在你的扩展所属的源代码树之外的目录中运行
    <literal>make</literal>。 这个过程也被称为一个
    <indexterm><primary>VPATH</primary></indexterm><firstterm>VPATH</firstterm>
    编译。下面是做法：
<programlisting>
mkdir build_dir
cd build_dir
make -f /path/to/extension/source/tree/Makefile
make -f /path/to/extension/source/tree/Makefile install
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=664c159661188b83ecc379ec571b62bc -->

<!-- pgdoc-cn_start sig_en=298e77b572a849ce65f762790c4cb597 sig_cn_org=None source=14.1 
   <para>
    Alternatively, you can set up a directory for a VPATH build in a similar
    way to how it is done for the core code. One way to do this is using the
    core script <filename>config/prep_buildtree</filename>. Once this has been done
    you can build by setting the <literal>make</literal> variable
    <varname>VPATH</varname> like this:
<programlisting>
make VPATH=/path/to/extension/source/tree
make VPATH=/path/to/extension/source/tree install
</programlisting>
    This procedure can work with a greater variety of directory layouts.
   </para>
________________________________________________________-->
   <para>
    此外，你可以以对核心代码所作的方式一样为 VPATH 设置一个目录。一种方式是使用核心脚本
    <filename>config/prep_buildtree</filename>。一旦这样做，你可以这样设置
    <literal>make</literal>变量<varname>VPATH</varname>：
<programlisting>
make VPATH=/path/to/extension/source/tree
make VPATH=/path/to/extension/source/tree install
</programlisting>
    这个过程可以在很多种目录布局下工作。
   </para>
<!-- pgdoc-cn_end sig_en=298e77b572a849ce65f762790c4cb597 -->

<!-- pgdoc-cn_start sig_en=d7d8cbc4997e60e53ae3a9e84ebc40f0 sig_cn_org=None source=14.1 
   <para>
    The scripts listed in the <varname>REGRESS</varname> variable are used for
    regression testing of your module, which can be invoked by <literal>make
    installcheck</literal> after doing <literal>make install</literal>.  For this to
    work you must have a running <productname>PostgreSQL</productname> server.
    The script files listed in <varname>REGRESS</varname> must appear in a
    subdirectory named <literal>sql/</literal> in your extension's directory.
    These files must have extension <literal>.sql</literal>, which must not be
    included in the <varname>REGRESS</varname> list in the makefile.  For each
    test there should also be a file containing the expected output in a
    subdirectory named <literal>expected/</literal>, with the same stem and
    extension <literal>.out</literal>.  <literal>make installcheck</literal>
    executes each test script with <application>psql</application>, and compares the
    resulting output to the matching expected file.  Any differences will be
    written to the file <literal>regression.diffs</literal> in <command>diff
    -c</command> format.  Note that trying to run a test that is missing its
    expected file will be reported as <quote>trouble</quote>, so make sure you
    have all expected files.
   </para>
________________________________________________________-->
   <para>
    列举在<varname>REGRESS</varname>变量中的脚本会被用来对你的扩展进行回归测试，回归测试可以在做完<literal>make install</literal>之后用<literal>make installcheck</literal>调用。要让这能够工作，你必须已经有一个运行着的<productname>PostgreSQL</productname>服务器。列举在<varname>REGRESS</varname>中的脚本文件必须在你扩展目录的名为<literal>sql/</literal>的子目录中出现。这些文件必须带有扩展<literal>.sql</literal>，但扩展不能被包括在 makefile 的<varname>REGRESS</varname>列表中。对每一个测试还应该在名为<literal>expected/</literal>的子目录中有一个包含预期输出的文件，它具有和脚本文件相同的词干并带有扩展<literal>.out</literal>。<literal>make installcheck</literal>会用<application>psql</application>执行每一个测试脚本，并且将得到结果输出与相应的预期输出比较。任何区别都将以<command>diff -c</command>格式写入到文件<literal>regression.diffs</literal>中。注意尝试运行一个不带预期文件的测试将被报告为<quote>故障</quote>，因此确保你拥有所有的预期文件。
   </para>
<!-- pgdoc-cn_end sig_en=d7d8cbc4997e60e53ae3a9e84ebc40f0 -->

<!-- pgdoc-cn_start sig_en=0407f77f67320c8f6381177b80d813b1 sig_cn_org=None source=14.1 
   <para>
    The scripts listed in the <varname>ISOLATION</varname> variable are used
    for tests stressing behavior of concurrent session with your module, which
    can be invoked by <literal>make installcheck</literal> after doing
    <literal>make install</literal>.  For this to work you must have a
    running <productname>PostgreSQL</productname> server.  The script files
    listed in <varname>ISOLATION</varname> must appear in a subdirectory
    named <literal>specs/</literal> in your extension's directory.  These files
    must have extension <literal>.spec</literal>, which must not be included
    in the <varname>ISOLATION</varname> list in the makefile.  For each test
    there should also be a file containing the expected output in a
    subdirectory named <literal>expected/</literal>, with the same stem and
    extension <literal>.out</literal>.  <literal>make installcheck</literal>
    executes each test script, and compares the resulting output to the
    matching expected file.  Any differences will be written to the file
    <literal>output_iso/regression.diffs</literal> in
    <command>diff -c</command> format.  Note that trying to run a test that is
    missing its expected file will be reported as <quote>trouble</quote>, so
    make sure you have all expected files.
   </para>
________________________________________________________-->
   <para>
    <varname>ISOLATION</varname>变量中列出的脚本用于测试强调与模块并发会话的行为，可以在<literal>make install</literal>之后通过<literal>make installcheck</literal> 调用。 
    要实现这个工作，你必须有一个正在运行的<productname>PostgreSQL</productname>服务器。
    <varname>ISOLATION</varname>中列出的脚本文件必须显示在扩展名目录中名为 <literal>specs/</literal>的子目录中。
    这些文件必须具备扩展名<literal>.spec</literal>，并且不得包含在 makefile 中的<varname>ISOLATION</varname>列表中。 
    对于每个测试，在名为<literal>expected/</literal>的子目录中还应该有一个包含预期输出的文件，并且具有相同的词干和扩展名 <literal>.out</literal>。
    <literal>make installcheck</literal>执行每个测试脚本，并将结果输出与匹配的预期文件进行比较。
   任何差异都将以<command>diff -c</command>的格式写入到<literal>output_iso/regression.diffs</literal>文件中。
   请注意，尝试运行缺少其预期文件的测试将会报告<quote>trouble</quote>，因此请确保你具有全部的预期文件。
   </para>
<!-- pgdoc-cn_end sig_en=0407f77f67320c8f6381177b80d813b1 -->

<!-- pgdoc-cn_start sig_en=85d30636ee7bddcb827d2b77dd60b9dc sig_cn_org=None source=14.1 
   <para>
    <literal>TAP_TESTS</literal> enables the use of TAP tests.  Data from each
    run is present in a subdirectory named <literal>tmp_check/</literal>.
    See also <xref linkend="regress-tap"/> for more details.
   </para>
________________________________________________________-->
   <para>
    <literal>TAP_TESTS</literal> 启用TAP测试.
    每个运行中的数据都存在于名为 <literal>tmp_check/</literal>的子目录中。
    更多详细信息，请参阅<xref linkend="regress-tap"/>
   </para>
<!-- pgdoc-cn_end sig_en=85d30636ee7bddcb827d2b77dd60b9dc -->

   <tip>
<!-- pgdoc-cn_start sig_en=63f114fffb8ef5636b9ddb065984afa5 sig_cn_org=None source=14.1 
    <para>
     The easiest way to create the expected files is to create empty files,
     then do a test run (which will of course report differences).  Inspect
     the actual result files found in the <literal>results/</literal>
     directory (for tests in <literal>REGRESS</literal>), or
     <literal>output_iso/results/</literal> directory (for tests in
     <literal>ISOLATION</literal>), then copy them to
     <literal>expected/</literal> if they match what you expect from the test.
    </para>
________________________________________________________-->
    <para>
     创建预期文件最简单的方法是创建空文件，然后做一次测试运行（这当然将报告区别）。
     检查在<literal>results/</literal>目录中找到的实际结果文件 (对于 <literal>REGRESS</literal>中的测试), 或<literal>output_iso/results/</literal> 目录(对于<literal>ISOLATION</literal>)中的测试，如果它们符合你的预期则把它们复制到<literal>expected/</literal>中。
    </para>
<!-- pgdoc-cn_end sig_en=63f114fffb8ef5636b9ddb065984afa5 -->

   </tip>
  </sect1>

 </chapter>
