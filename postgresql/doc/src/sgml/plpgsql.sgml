<!-- doc/src/sgml/plpgsql.sgml -->

<chapter id="plpgsql">
<!-- pgdoc-cn_start sig_en=c43b3be06146358c303de596a8caf0f9 sig_cn_org=None source=14.1 
  <title><application>PL/pgSQL</application> &mdash; <acronym>SQL</acronym> Procedural Language</title>
________________________________________________________-->
  <title><application>PL/pgSQL</application> &mdash; <acronym>SQL</acronym>过程语言</title>
<!-- pgdoc-cn_end sig_en=c43b3be06146358c303de596a8caf0f9 -->

<!-- pgdoc-cn_start sig_en=2d9574f3ddd476c50f5f32972e45fd5f sig_cn_org=None source=14.1 
 <indexterm zone="plpgsql">
  <primary>PL/pgSQL</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="plpgsql">
  <primary>PL/pgSQL</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=2d9574f3ddd476c50f5f32972e45fd5f -->

 <sect1 id="plpgsql-overview">
<!-- pgdoc-cn_start sig_en=13508788fd8dee2d1f9c928870e99338 sig_cn_org=None source=14.1 
  <title>Overview</title>
________________________________________________________-->
  <title>综述</title>
<!-- pgdoc-cn_end sig_en=13508788fd8dee2d1f9c928870e99338 -->

<!-- pgdoc-cn_start sig_en=58c91f9311a43c49a17dcaced5e9420c sig_cn_org=None source=14.1 
 <para>
  <application>PL/pgSQL</application> is a loadable procedural
  language for the <productname>PostgreSQL</productname> database
  system.  The design goals of <application>PL/pgSQL</application> were to create
  a loadable procedural language that

    <itemizedlist>
     <listitem>
      <para>
       can be used to create functions, procedures, and triggers,
      </para>
     </listitem>
     <listitem>
      <para>
       adds control structures to the <acronym>SQL</acronym> language,
      </para>
     </listitem>
     <listitem>
      <para>
       can perform complex computations,
      </para>
     </listitem>
     <listitem>
      <para>
       inherits all user-defined types, functions, procedures, and operators,
      </para>
     </listitem>
     <listitem>
      <para>
       can be defined to be trusted by the server,
      </para>
     </listitem>
     <listitem>
      <para>
       is easy to use.
      </para>
     </listitem>
    </itemizedlist>
   </para>
________________________________________________________-->
 <para>
  <application>PL/pgSQL</application>是一种用于<productname>PostgreSQL</productname>数据库系统的可载入的过程语言。<application>PL/pgSQL</application>的设计目标是创建一种这样的可载入过程语言

    <itemizedlist>
     <listitem>
      <para>
       可以被用来创建函数，存储过程，和触发器过程，
      </para>
     </listitem>
     <listitem>
      <para>
       对<acronym>SQL</acronym>语言增加控制结构，
      </para>
     </listitem>
     <listitem>
      <para>
       可以执行复杂计算，
      </para>
     </listitem>
     <listitem>
      <para>
       继承所有用户定义类型、函数、存储过程和操作符，
      </para>
     </listitem>
     <listitem>
      <para>
       可以被定义为受服务器信任，
      </para>
     </listitem>
     <listitem>
      <para>
       便于使用。
      </para>
     </listitem>
    </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=58c91f9311a43c49a17dcaced5e9420c -->

<!-- pgdoc-cn_start sig_en=384cf5ae605f77411e4e06094257d931 sig_cn_org=None source=14.1 
   <para>
    Functions created with <application>PL/pgSQL</application> can be
    used anywhere that built-in functions could be used.
    For example, it is possible to
    create complex conditional computation functions and later use
    them to define operators or use them in index expressions.
   </para>
________________________________________________________-->
   <para>
    用<application>PL/pgSQL</application>创建的函数可以被用在任何可以使用内建函数的地方。例如，可以创建复杂条件的计算函数并且后面用它们来定义操作符或把它们用于索引表达式。
   </para>
<!-- pgdoc-cn_end sig_en=384cf5ae605f77411e4e06094257d931 -->

<!-- pgdoc-cn_start sig_en=831cf3ad0352c3a06cb2d29781230060 sig_cn_org=None source=14.1 
   <para>
    In <productname>PostgreSQL</productname> 9.0 and later,
    <application>PL/pgSQL</application> is installed by default.
    However it is still a loadable module, so especially security-conscious
    administrators could choose to remove it.
   </para>
________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname> 9.0 和以后的版本中，<application>PL/pgSQL</application>是默认被安装的。但是它仍然是一种可载入模块，因此特别关注安全性的管理员可以选择移除它。
   </para>
<!-- pgdoc-cn_end sig_en=831cf3ad0352c3a06cb2d29781230060 -->

  <sect2 id="plpgsql-advantages">
<!-- pgdoc-cn_start sig_en=de5f475966929cf69d12a05476ef8047 sig_cn_org=None source=14.1 
   <title>Advantages of Using <application>PL/pgSQL</application></title>
________________________________________________________-->
   <title>使用<application>PL/pgSQL</application>的优点</title>
<!-- pgdoc-cn_end sig_en=de5f475966929cf69d12a05476ef8047 -->

<!-- pgdoc-cn_start sig_en=eb2a5af64e43f7571193fb5b6db4f26d sig_cn_org=None source=14.1 
    <para>
     <acronym>SQL</acronym> is the language <productname>PostgreSQL</productname>
     and most other relational databases use as query language. It's
     portable and easy to learn. But every <acronym>SQL</acronym>
     statement must be executed individually by the database server.
    </para>
________________________________________________________-->
    <para>
     <acronym>SQL</acronym>被<productname>PostgreSQL</productname>和大多数其他关系数据库用作查询语言。它是可移植的并且容易学习。但是每一个<acronym>SQL</acronym>语句必须由数据库服务器单独执行。
    </para>
<!-- pgdoc-cn_end sig_en=eb2a5af64e43f7571193fb5b6db4f26d -->

<!-- pgdoc-cn_start sig_en=cdfeb3d748c89c4e5aefb84d33aa6941 sig_cn_org=None source=14.1 
    <para>
     That means that your client application must send each query to
     the database server, wait for it to be processed, receive and
     process the results, do some computation, then send further
     queries to the server.  All this incurs interprocess
     communication and will also incur network overhead if your client
     is on a different machine than the database server.
    </para>
________________________________________________________-->
    <para>
     这意味着你的客户端应用必须发送每一个查询到数据库服务器、等待它被处理、接收并处理结果、做一些计算，然后发送更多查询给服务器。如果你的客户端和数据库服务器不在同一台机器上，所有这些会引起进程间通信并且将带来网络负担。
    </para>
<!-- pgdoc-cn_end sig_en=cdfeb3d748c89c4e5aefb84d33aa6941 -->

<!-- pgdoc-cn_start sig_en=006034b3bf52cc9b95cfe8966634eb65 sig_cn_org=None source=14.1 
    <para>
     With <application>PL/pgSQL</application> you can group a block of
     computation and a series of queries <emphasis>inside</emphasis>
     the database server, thus having the power of a procedural
     language and the ease of use of SQL, but with considerable
     savings of client/server communication overhead.
    </para>
________________________________________________________-->
    <para>
     通过<application>PL/pgSQL</application>，你可以将一整块计算和一系列查询分组在数据库服务器<emphasis>内部</emphasis>，这样就有了一种过程语言的能力并且使 SQL 更易用，但是节省了相当多的客户端/服务器通信开销。
    </para>
<!-- pgdoc-cn_end sig_en=006034b3bf52cc9b95cfe8966634eb65 -->
    <itemizedlist>

     <listitem>
<!-- pgdoc-cn_start sig_en=b3ec1b7364136e723a7a3072f2901e2a sig_cn_org=None source=14.1 
<para> Extra round trips between
     client and server are eliminated </para>
________________________________________________________-->
<para> 客户端和服务器之间的额外往返通信被消除 </para>
<!-- pgdoc-cn_end sig_en=b3ec1b7364136e723a7a3072f2901e2a -->
</listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=b2b20f39485f6ec47d7a0f368f3bdf8c sig_cn_org=None source=14.1 
<para> Intermediate results that the client does not
     need do not have to be marshaled or transferred between server
     and client </para>
________________________________________________________-->
<para> 客户端不需要的中间结果不必被整理或者在服务器和客户端之间传送 </para>
<!-- pgdoc-cn_end sig_en=b2b20f39485f6ec47d7a0f368f3bdf8c -->
</listitem>

     <listitem>
<!-- pgdoc-cn_start sig_en=265ba27b784e9e48295917ab0820e234 sig_cn_org=None source=14.1 
<para> Multiple rounds of query
     parsing can be avoided </para>
________________________________________________________-->
<para> 多轮的查询解析可以被避免 </para>
<!-- pgdoc-cn_end sig_en=265ba27b784e9e48295917ab0820e234 -->
</listitem>

    </itemizedlist>
<!-- pgdoc-cn_start sig_en=3bdc981a0a171fd1baa30018c54c01c6 sig_cn_org=None source=14.1 
    <para> This can result in a considerable performance increase as
    compared to an application that does not use stored functions.
    </para>
________________________________________________________-->
    <para> 与不使用存储函数的应用相比，这能够导致可观的性能提升。
    </para>
<!-- pgdoc-cn_end sig_en=3bdc981a0a171fd1baa30018c54c01c6 -->

<!-- pgdoc-cn_start sig_en=f3f130f2527326498b5e247b84cd63d9 sig_cn_org=None source=14.1 
    <para>
     Also, with <application>PL/pgSQL</application> you can use all
     the data types, operators and functions of SQL.
    </para>
________________________________________________________-->
    <para>
     还有，通过<application>PL/pgSQL</application>你可以使用 SQL 中所有的数据类型、操作符和函数。
    </para>
<!-- pgdoc-cn_end sig_en=f3f130f2527326498b5e247b84cd63d9 -->
  </sect2>

  <sect2 id="plpgsql-args-results">
<!-- pgdoc-cn_start sig_en=6b03a270d87272af152bab941c6adc1d sig_cn_org=None source=14.1 
   <title>Supported Argument and Result Data Types</title>
________________________________________________________-->
   <title>支持的参数和结果数据类型</title>
<!-- pgdoc-cn_end sig_en=6b03a270d87272af152bab941c6adc1d -->

<!-- pgdoc-cn_start sig_en=5f31d35a827b75a9a2f8a2c2b8a98282 sig_cn_org=None source=14.1 
    <para>
     Functions written in <application>PL/pgSQL</application> can accept
     as arguments any scalar or array data type supported by the server,
     and they can return a result of any of these types.  They can also
     accept or return any composite type (row type) specified by name.
     It is also possible to declare a <application>PL/pgSQL</application>
     function as accepting <type>record</type>, which means that any
     composite type will do as input, or
     as returning <type>record</type>, which means that the result
     is a row type whose columns are determined by specification in the
     calling query, as discussed in <xref linkend="queries-tablefunctions"/>.
    </para>
________________________________________________________-->
    <para>
     <application>PL/pgSQL</application>编写的函数可以接受服务器支持的任何标量或数组数据类型作为参数，并且它们能够返回任何这些类型的结果。它们也能接受或返回任何用名称指定的组合类型（行类型）。还可以声明一个<application>PL/pgSQL</application>函数为接受<type>record</type>，这表示任意组合类型都将作为输入，或者声明为返回<type>record</type>，表示结果是一种行类型，它的列由调用查询中的说明确定（如<xref linkend="queries-tablefunctions"/>中所讨论）。
    </para>
<!-- pgdoc-cn_end sig_en=5f31d35a827b75a9a2f8a2c2b8a98282 -->

<!-- pgdoc-cn_start sig_en=c470414835197eb8111e6440222cbe9e sig_cn_org=None source=14.1 
    <para>
     <application>PL/pgSQL</application> functions can be declared to accept a variable
     number of arguments by using the <literal>VARIADIC</literal> marker.  This
     works exactly the same way as for SQL functions, as discussed in
     <xref linkend="xfunc-sql-variadic-functions"/>.
    </para>
________________________________________________________-->
    <para>
     <application>PL/pgSQL</application>函数可以通过使用<literal>VARIADIC</literal>标记被声明为接受数量不定的参数。如<xref linkend="xfunc-sql-variadic-functions"/>中所讨论的，它的工作方式和 SQL 函数一样。
    </para>
<!-- pgdoc-cn_end sig_en=c470414835197eb8111e6440222cbe9e -->

<!-- pgdoc-cn_start sig_en=c356ef91c164a475ead87de852c7aa6c sig_cn_org=None source=14.1 
    <para>
     <application>PL/pgSQL</application> functions can also be declared to
     accept and return the polymorphic types described in
     <xref linkend="extend-types-polymorphic"/>, thus allowing the actual data
     types handled by the function to vary from call to call.
     Examples appear in <xref linkend="plpgsql-declaration-parameters"/>.
    </para>
________________________________________________________-->
    <para>
     <application>PL/pgSQL</application>函数也可以声明为接受和返回
     <xref linkend="extend-types-polymorphic"/>中描述的多态类型，
     从而允许函数处理的实际数据类型发生变化 从呼叫到呼叫。
     示例出现在<xref linkend="plpgsql-declaration-parameters"/>中。
    </para>
<!-- pgdoc-cn_end sig_en=c356ef91c164a475ead87de852c7aa6c -->

<!-- pgdoc-cn_start sig_en=ea137645a382e8b9f0a26e412f0f7879 sig_cn_org=None source=14.1 
    <para>
     <application>PL/pgSQL</application> functions can also be declared to return
     a <quote>set</quote> (or table) of any data type that can be returned as
     a single instance.  Such a function generates its output by executing
     <command>RETURN NEXT</command> for each desired element of the result
     set, or by using <command>RETURN QUERY</command> to output the result of
     evaluating a query.
    </para>
________________________________________________________-->
    <para>
     <application>PL/pgSQL</application>函数还能够被声明为返回一个任意（可作为一个单一实例返回的）数据类型的<quote>集合</quote>（或表）。这样的一个函数通过为结果集的每个期望元素执行<command>RETURN NEXT</command>来产生输出，或者通过使用<command>RETURN QUERY</command>来输出一个查询计算的结果。
    </para>
<!-- pgdoc-cn_end sig_en=ea137645a382e8b9f0a26e412f0f7879 -->

<!-- pgdoc-cn_start sig_en=32ad7d9f22a31a203c10caabc3452d2e sig_cn_org=None source=14.1 
    <para>
     Finally, a <application>PL/pgSQL</application> function can be declared to return
     <type>void</type> if it has no useful return value.  (Alternatively, it
     could be written as a procedure in that case.)
    </para>
________________________________________________________-->
    <para>
     最后，如果一个<application>PL/pgSQL</application>函数没有可用的返回值，它可以被声明为返回<type>void</type>（另外一种选择是，在那种情况下它可以被写作一个过程）。
    </para>
<!-- pgdoc-cn_end sig_en=32ad7d9f22a31a203c10caabc3452d2e -->

<!-- pgdoc-cn_start sig_en=b908386ecdedd5317a7f59a0e5851842 sig_cn_org=None source=14.1 
    <para>
     <application>PL/pgSQL</application> functions can also be declared with output
     parameters in place of an explicit specification of the return type.
     This does not add any fundamental capability to the language, but
     it is often convenient, especially for returning multiple values.
     The <literal>RETURNS TABLE</literal> notation can also be used in place
     of <literal>RETURNS SETOF</literal>.
    </para>
________________________________________________________-->
    <para>
     <application>PL/pgSQL</application>函数也能够被声明为用输出参数代替返回类型的一个显式说明。这没有为该语言增加任何基础功能，但是它常常很方便，特别是对于要返回多个值的情况。<literal>RETURNS TABLE</literal>符号也可以被用来替代<literal>RETURNS SETOF</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=b908386ecdedd5317a7f59a0e5851842 -->

<!-- pgdoc-cn_start sig_en=6bde0f3ad4752b2ebdc27a06ab0cae38 sig_cn_org=None source=14.1 
    <para>
     Specific examples appear in
     <xref linkend="plpgsql-declaration-parameters"/> and
     <xref linkend="plpgsql-statements-returning"/>.
    </para>
________________________________________________________-->
    <para>
     在<xref linkend="plpgsql-declaration-parameters"/>和<xref linkend="plpgsql-statements-returning"/>中有详细的例子。
    </para>
<!-- pgdoc-cn_end sig_en=6bde0f3ad4752b2ebdc27a06ab0cae38 -->
  </sect2>
 </sect1>

 <sect1 id="plpgsql-structure">
<!-- pgdoc-cn_start sig_en=f02f265640635ccacb85bdd7b4816c09 sig_cn_org=None source=14.1 
  <title>Structure of <application>PL/pgSQL</application></title>
________________________________________________________-->
  <title><application>PL/pgSQL</application>的结构</title>
<!-- pgdoc-cn_end sig_en=f02f265640635ccacb85bdd7b4816c09 -->

<!-- pgdoc-cn_start sig_en=af604e7fd603243c70ef11599da92f8b sig_cn_org=None source=14.1 
  <para>
   Functions written in <application>PL/pgSQL</application> are defined
   to the server by executing <xref linkend="sql-createfunction"/> commands.
   Such a command would normally look like, say,
<programlisting>
CREATE FUNCTION somefunc(integer, text) RETURNS integer
AS '<replaceable>function body text</replaceable>'
LANGUAGE plpgsql;
</programlisting>
   The function body is simply a string literal so far as <command>CREATE
   FUNCTION</command> is concerned.  It is often helpful to use dollar quoting
   (see <xref linkend="sql-syntax-dollar-quoting"/>) to write the function
   body, rather than the normal single quote syntax.  Without dollar quoting,
   any single quotes or backslashes in the function body must be escaped by
   doubling them.  Almost all the examples in this chapter use dollar-quoted
   literals for their function bodies.
  </para>
________________________________________________________-->
  <para>
   通过执行<xref linkend="sql-createfunction"/>命令，以<application>PL/pgSQL</application>写成的函数可以被定义到服务器中。这种命令通常看起来是这样：
<programlisting>
CREATE FUNCTION somefunc(integer, text) RETURNS integer
AS '<replaceable>function body text</replaceable>'
LANGUAGE plpgsql;
</programlisting>
   就目前<command>CREATE FUNCTION</command>所关心的来说，函数体就是简单的一个字符串。通常在写函数体时，使用美元符号引用（见<xref linkend="sql-syntax-dollar-quoting"/>）通常比使用普通单引号语法更有帮助。如果没有美元引用，函数体中的任何单引号或者反斜线必须通过双写来转义。这一章中几乎所有的例子都在其函数体中使用美元符号引用。
  </para>
<!-- pgdoc-cn_end sig_en=af604e7fd603243c70ef11599da92f8b -->

<!-- pgdoc-cn_start sig_en=d3abfc6996f765a2c8deb5f75445f14a sig_cn_org=None source=14.1 
  <para>
   <application>PL/pgSQL</application> is a block-structured language.
   The complete text of a function body must be a
   <firstterm>block</firstterm>. A block is defined as:

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
<optional> DECLARE
    <replaceable>declarations</replaceable> </optional>
BEGIN
    <replaceable>statements</replaceable>
END <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
    </para>
________________________________________________________-->
  <para>
   <application>PL/pgSQL</application>是一种块结构的语言。一个函数体的完整文本必须是一个<firstterm>块</firstterm>。一个块被定义为：

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
<optional> DECLARE
    <replaceable>declarations</replaceable> </optional>
BEGIN
    <replaceable>statements</replaceable>
END <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
    </para>
<!-- pgdoc-cn_end sig_en=d3abfc6996f765a2c8deb5f75445f14a -->

<!-- pgdoc-cn_start sig_en=17a331b09983f100d93ab53bbcd191d4 sig_cn_org=None source=14.1 
    <para>
     Each declaration and each statement within a block is terminated
     by a semicolon.  A block that appears within another block must
     have a semicolon after <literal>END</literal>, as shown above;
     however the final <literal>END</literal> that
     concludes a function body does not require a semicolon.
    </para>
________________________________________________________-->
    <para>
     在一个块中的每一个声明和每一个语句都由一个分号终止。如上所示，出现在另一个块中的块必须有一个分号在<literal>END</literal>之后。不过最后一个结束函数体的<literal>END</literal>不需要一个分号。
    </para>
<!-- pgdoc-cn_end sig_en=17a331b09983f100d93ab53bbcd191d4 -->

    <tip>
<!-- pgdoc-cn_start sig_en=b6073e9546433bc7f1be630a4a229284 sig_cn_org=None source=14.1 
     <para>
      A common mistake is to write a semicolon immediately after
      <literal>BEGIN</literal>.  This is incorrect and will result in a syntax error.
     </para>
________________________________________________________-->
     <para>
      一种常见的错误是直接在<literal>BEGIN</literal>之后写一个分号。这是不正确的并且将会导致一个语法错误。
     </para>
<!-- pgdoc-cn_end sig_en=b6073e9546433bc7f1be630a4a229284 -->
    </tip>

<!-- pgdoc-cn_start sig_en=ffd797aedc67d1963532cb86ddc96494 sig_cn_org=None source=14.1 
    <para>
     A <replaceable>label</replaceable> is only needed if you want to
     identify the block for use
     in an <literal>EXIT</literal> statement, or to qualify the names of the
     variables declared in the block.  If a label is given after
     <literal>END</literal>, it must match the label at the block's beginning.
    </para>
________________________________________________________-->
    <para>
     如果你想要标识一个块以便在一个<literal>EXIT</literal>语句中使用或者标识在该块中声明的变量名，那么<replaceable>label</replaceable>是你唯一需要的。如果一个标签在<literal>END</literal>之后被给定，它必须匹配在块开始处的标签。
    </para>
<!-- pgdoc-cn_end sig_en=ffd797aedc67d1963532cb86ddc96494 -->

<!-- pgdoc-cn_start sig_en=a2987b76e3198355a1f00ee71e77e4f1 sig_cn_org=None source=14.1 
    <para>
     All key words are case-insensitive.
     Identifiers are implicitly converted to lower case
     unless double-quoted, just as they are in ordinary SQL commands.
    </para>
________________________________________________________-->
    <para>
     所有的关键词都是大小写无关的。除非被双引号引用，标识符会被隐式地转换为小写形式，就像它们在普通 SQL 命令中。
    </para>
<!-- pgdoc-cn_end sig_en=a2987b76e3198355a1f00ee71e77e4f1 -->

<!-- pgdoc-cn_start sig_en=f21946f3eba9f9c7f17f1ce7e5b4ee52 sig_cn_org=None source=14.1 
    <para>
     Comments work the same way in <application>PL/pgSQL</application> code as in
     ordinary SQL.  A double dash (<literal>-&minus;</literal>) starts a comment
     that extends to the end of the line. A <literal>/*</literal> starts a
     block comment that extends to the matching occurrence of
     <literal>*/</literal>.  Block comments nest.
    </para>
________________________________________________________-->
    <para>
     <application>PL/pgSQL</application>代码中的注释和普通 SQL 中的一样。一个双连字符（<literal>--</literal>）开始一段注释，它延伸到该行的末尾。一个<literal>/*</literal>开始一段块注释，它会延伸到匹配<literal>*/</literal>出现的位置。块注释可以嵌套。
    </para>
<!-- pgdoc-cn_end sig_en=f21946f3eba9f9c7f17f1ce7e5b4ee52 -->

<!-- pgdoc-cn_start sig_en=0ef9fc23468cbb43649108a5cc50cc2f sig_cn_org=None source=14.1 
    <para>
     Any statement in the statement section of a block
     can be a <firstterm>subblock</firstterm>.  Subblocks can be used for
     logical grouping or to localize variables to a small group
     of statements.  Variables declared in a subblock mask any
     similarly-named variables of outer blocks for the duration
     of the subblock; but you can access the outer variables anyway
     if you qualify their names with their block's label. For example:
<programlisting>
CREATE FUNCTION somefunc() RETURNS integer AS $$
&lt;&lt; outerblock &gt;&gt;
DECLARE
    quantity integer := 30;
BEGIN
    RAISE NOTICE 'Quantity here is %', quantity;  -&minus; Prints 30
    quantity := 50;
    -&minus;
    -&minus; Create a subblock
    -&minus;
    DECLARE
        quantity integer := 80;
    BEGIN
        RAISE NOTICE 'Quantity here is %', quantity;  -&minus; Prints 80
        RAISE NOTICE 'Outer quantity here is %', outerblock.quantity;  -&minus; Prints 50
    END;

    RAISE NOTICE 'Quantity here is %', quantity;  -&minus; Prints 50

    RETURN quantity;
END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     一个块的语句节中的任何语句可以是一个<firstterm>子块</firstterm>。子块可以被用来逻辑分组或者将变量局部化为语句的一个小组。在子块的持续期间，在一个子块中声明的变量会掩盖外层块中相同名称的变量。但是如果你用块的标签限定外层变量的名字，你仍然可以访问它们。例如：
<programlisting>
CREATE FUNCTION somefunc() RETURNS integer AS $$
&lt;&lt; outerblock &gt;&gt;
DECLARE
    quantity integer := 30;
BEGIN
    RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 30
    quantity := 50;
    --
    -- 创建一个子块
    --
    DECLARE
        quantity integer := 80;
    BEGIN
        RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 80
        RAISE NOTICE 'Outer quantity here is %', outerblock.quantity;  -- Prints 50
    END;

    RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 50

    RETURN quantity;
END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=0ef9fc23468cbb43649108a5cc50cc2f -->

    <note>
<!-- pgdoc-cn_start sig_en=66654408ae2de22dfa85535e40edda6b sig_cn_org=None source=14.1 
     <para>
      There is actually a hidden <quote>outer block</quote> surrounding the body
      of any <application>PL/pgSQL</application> function.  This block provides the
      declarations of the function's parameters (if any), as well as some
      special variables such as <literal>FOUND</literal> (see
      <xref linkend="plpgsql-statements-diagnostics"/>).  The outer block is
      labeled with the function's name, meaning that parameters and special
      variables can be qualified with the function's name.
     </para>
________________________________________________________-->
     <para>
      在任何<application>PL/pgSQL</application>函数体的外部确实有一个隐藏的<quote>外层块</quote>包围着。这个块提供了该函数参数（如果有）的声明，以及某些诸如<literal>FOUND</literal>之类特殊变量（见<xref linkend="plpgsql-statements-diagnostics"/>）。外层块被标上函数的名称，这意味着参数和特殊变量可以用该函数的名称限定。
     </para>
<!-- pgdoc-cn_end sig_en=66654408ae2de22dfa85535e40edda6b -->
    </note>

<!-- pgdoc-cn_start sig_en=0c4a0a42879c83fb42ce78798e928933 sig_cn_org=None source=14.1 
    <para>
     It is important not to confuse the use of
     <command>BEGIN</command>/<command>END</command> for grouping statements in
     <application>PL/pgSQL</application> with the similarly-named SQL commands
     for transaction
     control.  <application>PL/pgSQL</application>'s <command>BEGIN</command>/<command>END</command>
     are only for grouping; they do not start or end a transaction.
     See <xref linkend="plpgsql-transactions"/> for information on managing
     transactions in <application>PL/pgSQL</application>.
     Also, a block containing an <literal>EXCEPTION</literal> clause effectively
     forms a subtransaction that can be rolled back without affecting the
     outer transaction.  For more about that see <xref
     linkend="plpgsql-error-trapping"/>.
    </para>
________________________________________________________-->
    <para>
     重要的是不要把<application>PL/pgSQL</application>中用来分组语句的<command>BEGIN</command>/<command>END</command>与用于事务控制的同名 SQL 命令弄混。<application>PL/pgSQL</application>的<command>BEGIN</command>/<command>END</command>只用于分组，它们不会开始或结束一个事务。有关<application>PL/pgSQL</application>中管理事务的信息，请参考<xref linkend="plpgsql-transactions"/>。此外，一个包含<literal>EXCEPTION</literal>子句的块实际上会形成一个子事务，它可以被回滚而不影响外层事务。详见<xref linkend="plpgsql-error-trapping"/>。
    </para>
<!-- pgdoc-cn_end sig_en=0c4a0a42879c83fb42ce78798e928933 -->
  </sect1>

  <sect1 id="plpgsql-declarations">
<!-- pgdoc-cn_start sig_en=0eab171156cd291432ac190d6ce0d664 sig_cn_org=None source=14.1 
    <title>Declarations</title>
________________________________________________________-->
    <title>声明</title>
<!-- pgdoc-cn_end sig_en=0eab171156cd291432ac190d6ce0d664 -->

<!-- pgdoc-cn_start sig_en=52106a47a2b49db7a23fc8c71a5a5d96 sig_cn_org=None source=14.1 
    <para>
     All variables used in a block must be declared in the
     declarations section of the block.
     (The only exceptions are that the loop variable of a <literal>FOR</literal> loop
     iterating over a range of integer values is automatically declared as an
     integer variable, and likewise the loop variable of a <literal>FOR</literal> loop
     iterating over a cursor's result is automatically declared as a
     record variable.)
    </para>
________________________________________________________-->
    <para>
     在一个块中使用的所有变量必须在该块的声明小节中声明（唯一的例外是在一个整数范围上迭代的<literal>FOR</literal>循环变量会被自动声明为一个整数变量，并且相似地在一个游标结果上迭代的<literal>FOR</literal>循环变量会被自动地声明为一个记录变量）。
    </para>
<!-- pgdoc-cn_end sig_en=52106a47a2b49db7a23fc8c71a5a5d96 -->

<!-- pgdoc-cn_start sig_en=d7aef94b4e12dee4558bfa6cd9079bf7 sig_cn_org=None source=14.1 
    <para>
     <application>PL/pgSQL</application> variables can have any SQL data type, such as
     <type>integer</type>, <type>varchar</type>, and
     <type>char</type>.
    </para>
________________________________________________________-->
    <para>
     <application>PL/pgSQL</application>变量可以是任意 SQL 数据类型，例如<type>integer</type>、<type>varchar</type>和<type>char</type>。
    </para>
<!-- pgdoc-cn_end sig_en=d7aef94b4e12dee4558bfa6cd9079bf7 -->

<!-- pgdoc-cn_start sig_en=daf77c9dcd91b2d2a1229b71c35b0858 sig_cn_org=None source=14.1 
    <para>
     Here are some examples of variable declarations:
<programlisting>
user_id integer;
quantity numeric(5);
url varchar;
myrow tablename%ROWTYPE;
myfield tablename.columnname%TYPE;
arow RECORD;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     这里是变量声明的一些例子：
<programlisting>
user_id integer;
quantity numeric(5);
url varchar;
myrow tablename%ROWTYPE;
myfield tablename.columnname%TYPE;
arow RECORD;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=daf77c9dcd91b2d2a1229b71c35b0858 -->

<!-- pgdoc-cn_start sig_en=0def34abd71ebeaae0e47eb07a282181 sig_cn_org=None source=14.1 
    <para>
     The general syntax of a variable declaration is:
<synopsis>
<replaceable>name</replaceable> <optional> CONSTANT </optional> <replaceable>type</replaceable> <optional> COLLATE <replaceable>collation_name</replaceable> </optional> <optional> NOT NULL </optional> <optional> { DEFAULT | := | = } <replaceable>expression</replaceable> </optional>;
</synopsis>
      The <literal>DEFAULT</literal> clause, if given, specifies the initial value assigned
      to the variable when the block is entered.  If the <literal>DEFAULT</literal> clause
      is not given then the variable is initialized to the
      <acronym>SQL</acronym> null value.
      The <literal>CONSTANT</literal> option prevents the variable from being
      assigned to after initialization, so that its value will remain constant
      for the duration of the block.
      The <literal>COLLATE</literal> option specifies a collation to use for the
      variable (see <xref linkend="plpgsql-declaration-collation"/>).
      If <literal>NOT NULL</literal>
      is specified, an assignment of a null value results in a run-time
      error. All variables declared as <literal>NOT NULL</literal>
      must have a nonnull default value specified.
      Equal (<literal>=</literal>) can be used instead of PL/SQL-compliant
      <literal>:=</literal>.
     </para>
________________________________________________________-->
    <para>
     一个变量声明的一般语法是：
<synopsis>
<replaceable>name</replaceable> <optional> CONSTANT </optional> <replaceable>type</replaceable> <optional> COLLATE <replaceable>collation_name</replaceable> </optional> <optional> NOT NULL </optional> <optional> { DEFAULT | := | = } <replaceable>expression</replaceable> </optional>;
</synopsis>
      如果给定<literal>DEFAULT</literal>子句，它会指定进入该块时分
      配给该变量的初始值。如果没有给出<literal>DEFAULT</literal>子句，
      则该变量被初始化为<acronym>SQL</acronym>空值。
      <literal>CONSTANT</literal>选项阻止该变量在初始化之后被赋值，
      这样它的值在块的持续期内保持不变。<literal>COLLATE</literal>
      选项指定用于该变量的一个排序规则（见
      <xref linkend="plpgsql-declaration-collation"/>）。如果指
      定了<literal>NOT NULL</literal>，对该变量赋值为空值会导致一个
      运行时错误。所有被声明为<literal>NOT NULL</literal>的变量必须
      被指定一个非空默认值。
      等号（<literal>=</literal>）可以被用来代替 PL/SQL-兼容的
      <literal>:=</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=0def34abd71ebeaae0e47eb07a282181 -->

<!-- pgdoc-cn_start sig_en=5d1a7de10a9a45a1601c6e6e0c9c357d sig_cn_org=None source=14.1 
     <para>
      A variable's default value is evaluated and assigned to the variable
      each time the block is entered (not just once per function call).
      So, for example, assigning <literal>now()</literal> to a variable of type
      <type>timestamp</type> causes the variable to have the
      time of the current function call, not the time when the function was
      precompiled.
     </para>
________________________________________________________-->
     <para>
      一个变量的默认值会在每次进入该块时被计算并且赋值给该变量（不是每次函数调用只计算一次）。因此，例如将<literal>now()</literal>赋值给类型为<type>timestamp</type>的一个变量将会导致该变量具有当前函数调用的时间，而不是该函数被预编译的时间。
     </para>
<!-- pgdoc-cn_end sig_en=5d1a7de10a9a45a1601c6e6e0c9c357d -->

<!-- pgdoc-cn_start sig_en=9d04a448651f5514f66adc18af951ebf sig_cn_org=c23b0429ed257411ec809efd1635c6f5 source=15.7 
     <para>
      Examples:
<programlisting>
quantity integer DEFAULT 32;
url varchar := 'http://mysite.com';
transaction_time CONSTANT timestamp with time zone := now();
</programlisting>
     </para>
________________________________________________________-->
     <para>
      示例:
<programlisting>
quantity integer 默认值为 32;
url varchar := 'http://mysite.com';
transaction_time 常量 时间戳 with 时区 := 现在();
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=9d04a448651f5514f66adc18af951ebf -->

<!-- pgdoc-cn_start sig_en=6767e6aef6345a0b3344c84f866f8ea5 sig_cn_org=fb7ca884540cdbdb0a5d35a95a90ad5f source=15.7 
     <para>
      Once declared, a variable's value can be used in later initialization
      expressions in the same block, for example:
<programlisting>
DECLARE
  x integer := 1;
  y integer := x + 1;
</programlisting>
     </para>
________________________________________________________-->
     <para>
      一旦声明，变量的值可以在同一块中的后续初始化表达式中使用，例如：
<programlisting>
DECLARE
  x integer := 1;
  y integer := x + 1;
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=6767e6aef6345a0b3344c84f866f8ea5 -->

    <sect2 id="plpgsql-declaration-parameters">
<!-- pgdoc-cn_start sig_en=5d88916a326f2065b9f45ba21f3dc7c8 sig_cn_org=None source=14.1 
     <title>Declaring Function Parameters</title>
________________________________________________________-->
     <title>声明函数参数</title>
<!-- pgdoc-cn_end sig_en=5d88916a326f2065b9f45ba21f3dc7c8 -->

<!-- pgdoc-cn_start sig_en=517919c4e5da9ccbffa0ca997bb7988f sig_cn_org=None source=14.1 
     <para>
      Parameters passed to functions are named with the identifiers
      <literal>$1</literal>, <literal>$2</literal>,
      etc.  Optionally, aliases can be declared for
      <literal>$<replaceable>n</replaceable></literal>
      parameter names for increased readability.  Either the alias or the
      numeric identifier can then be used to refer to the parameter value.
     </para>
________________________________________________________-->
     <para>
      传递给函数的参数被命名为标识符<literal>$1</literal>、<literal>$2</literal>等等。可选地，能够为<literal>$<replaceable>n</replaceable></literal>参数名声明别名来增加可读性。不管是别名还是数字标识符都能用来引用参数值。
     </para>
<!-- pgdoc-cn_end sig_en=517919c4e5da9ccbffa0ca997bb7988f -->

<!-- pgdoc-cn_start sig_en=1d11608a996115e485316eae608f9ed0 sig_cn_org=None source=14.1 
     <para>
      There are two ways to create an alias.  The preferred way is to give a
      name to the parameter in the <command>CREATE FUNCTION</command> command,
      for example:
<programlisting>
CREATE FUNCTION sales_tax(subtotal real) RETURNS real AS $$
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>
      The other way is to explicitly declare an alias, using the
      declaration syntax

<synopsis>
<replaceable>name</replaceable> ALIAS FOR $<replaceable>n</replaceable>;
</synopsis>

      The same example in this style looks like:
<programlisting>
CREATE FUNCTION sales_tax(real) RETURNS real AS $$
DECLARE
    subtotal ALIAS FOR $1;
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>
________________________________________________________-->
     <para>
      有两种方式来创建一个别名。比较好的方式是在<command>CREATE FUNCTION</command>命令中为参数给定一个名称。例如：
<programlisting>
CREATE FUNCTION sales_tax(subtotal real) RETURNS real AS $$
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>
      另一种方式是显式地使用声明语法声明一个别名。

<synopsis>
<replaceable>name</replaceable> ALIAS FOR $<replaceable>n</replaceable>;
</synopsis>

      使用这种风格的同一个例子看起来是：
<programlisting>
CREATE FUNCTION sales_tax(real) RETURNS real AS $$
DECLARE
    subtotal ALIAS FOR $1;
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=1d11608a996115e485316eae608f9ed0 -->

    <note>
<!-- pgdoc-cn_start sig_en=61332a54c9faf15ae3fa0d4364ed83dd sig_cn_org=None source=14.1 
     <para>
      These two examples are not perfectly equivalent.  In the first case,
      <literal>subtotal</literal> could be referenced as
      <literal>sales_tax.subtotal</literal>, but in the second case it could not.
      (Had we attached a label to the inner block, <literal>subtotal</literal> could
      be qualified with that label, instead.)
     </para>
________________________________________________________-->
     <para>
      这两个例子并非完全等效。在第一种情况中，<literal>subtotal</literal>可以被引用为<literal>sales_tax.subtotal</literal>，但在第二种情况中它不能这样引用（如果我们为内层块附加了一个标签，<literal>subtotal</literal>则可以用那个标签限定）。
     </para>
<!-- pgdoc-cn_end sig_en=61332a54c9faf15ae3fa0d4364ed83dd -->
    </note>

<!-- pgdoc-cn_start sig_en=14f801cd7832e23b1e76ec925eb969a1 sig_cn_org=None source=14.1 
     <para>
      Some more examples:
<programlisting>
CREATE FUNCTION instr(varchar, integer) RETURNS integer AS $$
DECLARE
    v_string ALIAS FOR $1;
    index ALIAS FOR $2;
BEGIN
    -&minus; some computations using v_string and index here
END;
$$ LANGUAGE plpgsql;


CREATE FUNCTION concat_selected_fields(in_t sometablename) RETURNS text AS $$
BEGIN
    RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>
________________________________________________________-->
     <para>
      更多一些例子：
<programlisting>
CREATE FUNCTION instr(varchar, integer) RETURNS integer AS $$
DECLARE
    v_string ALIAS FOR $1;
    index ALIAS FOR $2;
BEGIN
    -- 这里是一些使用 v_string 和 index 的计算
END;
$$ LANGUAGE plpgsql;


CREATE FUNCTION concat_selected_fields(in_t sometablename) RETURNS text AS $$
BEGIN
    RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=14f801cd7832e23b1e76ec925eb969a1 -->

<!-- pgdoc-cn_start sig_en=6b711411fc090870f4a15110bfdf3d65 sig_cn_org=None source=14.1 
     <para>
      When a <application>PL/pgSQL</application> function is declared
      with output parameters, the output parameters are given
      <literal>$<replaceable>n</replaceable></literal> names and optional
      aliases in just the same way as the normal input parameters.  An
      output parameter is effectively a variable that starts out NULL;
      it should be assigned to during the execution of the function.
      The final value of the parameter is what is returned.  For instance,
      the sales-tax example could also be done this way:

<programlisting>
CREATE FUNCTION sales_tax(subtotal real, OUT tax real) AS $$
BEGIN
    tax := subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>

      Notice that we omitted <literal>RETURNS real</literal> &mdash; we could have
      included it, but it would be redundant.
     </para>
________________________________________________________-->
     <para>
      当一个<application>PL/pgSQL</application>函数被声明为带有输出参数，输出参数可以用普通输入参数相同的方式被给定<literal>$<replaceable>n</replaceable></literal>名称以及可选的别名。一个输出参数实际上是一个最初为 NULL 的变量，它应当在函数的执行期间被赋值。该参数的最终值就是要被返回的东西。例如，sales-tax 例子也可以用这种方式来做：

<programlisting>
CREATE FUNCTION sales_tax(subtotal real, OUT tax real) AS $$
BEGIN
    tax := subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>

      注意我们忽略了<literal>RETURNS real</literal> &mdash; 我们也可以包括它，但是那将是冗余。
     </para>
<!-- pgdoc-cn_end sig_en=6b711411fc090870f4a15110bfdf3d65 -->

<!-- pgdoc-cn_start sig_en=50faefbcea8bb0ea99c169436d0c0ad1 sig_cn_org=None source=14.1 
     <para>
      To call a function with <literal>OUT</literal> parameters, omit the
      output parameter(s) in the function call:
<programlisting>
SELECT sales_tax(100.00);
</programlisting>
     </para>
________________________________________________________-->
     <para>
           调用带有 <literal>OUT</literal> 参数的函数， 在函数调用中省略输出参数：
     <programlisting>
     SELECT sales_tax(100.00);
     </programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=50faefbcea8bb0ea99c169436d0c0ad1 -->

<!-- pgdoc-cn_start sig_en=41d700eee7560ef249ed36e30714ffe8 sig_cn_org=None source=14.1 
     <para>
      Output parameters are most useful when returning multiple values.
      A trivial example is:

<programlisting>
CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$
BEGIN
    sum := x + y;
    prod := x * y;
END;
$$ LANGUAGE plpgsql;

SELECT * FROM sum_n_product(2, 4);
 sum | prod
-&minus;-&minus;-+-&minus;-&minus;-&minus;
   6 |    8
</programlisting>

      As discussed in <xref linkend="xfunc-output-parameters"/>, this
      effectively creates an anonymous record type for the function's
      results.  If a <literal>RETURNS</literal> clause is given, it must say
      <literal>RETURNS record</literal>.
     </para>
________________________________________________________-->
     <para>
      当返回多个值时，输出参数最有用。一个小例子是：

<programlisting>
CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$
BEGIN
    sum := x + y;
    prod := x * y;
END;
$$ LANGUAGE plpgsql;
SELECT * FROM sum_n_product(2, 4);
 sum | prod
-----+------
   6 |    8
</programlisting>

      如<xref linkend="xfunc-output-parameters"/>中所讨论的，这实际上为该函数的结果创建了一个匿名记录类型。如果给定了一个<literal>RETURNS</literal>子句，它必须<literal>RETURNS record</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=41d700eee7560ef249ed36e30714ffe8 -->

<!-- pgdoc-cn_start sig_en=aa3f738cf0fda5616111ebfc38a67181 sig_cn_org=None source=14.1 
     <para>
      This also works with procedures, for example:

<programlisting>
CREATE PROCEDURE sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$
BEGIN
    sum := x + y;
    prod := x * y;
END;
$$ LANGUAGE plpgsql;
</programlisting>

      In a call to a procedure, all the parameters must be specified.  For
      output parameters, <literal>NULL</literal> may be specified when
      calling the procedure from plain SQL:
<programlisting>
CALL sum_n_product(2, 4, NULL, NULL);
 sum | prod
-&minus;-&minus;-+-&minus;-&minus;-&minus;
   6 |    8
</programlisting>

      However, when calling a procedure
      from <application>PL/pgSQL</application>, you should instead write a
      variable for any output parameter; the variable will receive the result
      of the call.  See <xref linkend="plpgsql-statements-calling-procedure"/>
      for details.
     </para>
________________________________________________________-->
     <para>
           对于存储过程同样有效，例如：

     <programlisting>
     CREATE PROCEDURE sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$
     BEGIN
         sum := x + y;
         prod := x * y;
     END;
     $$ LANGUAGE plpgsql;
     </programlisting>

           在一次存储过程调用中，所有参数必须定义申明。对于出参，SQL调用执行存储过程时可指定为<literal>NULL</literal>:
     <programlisting>
     CALL sum_n_product(2, 4, NULL, NULL);
      sum | prod
     -----+------
        6 |    8
     </programlisting>
           但是，当通过 <application>PL/pgSQL</application>调用执行存储过程时, 你应该为任何输出参数写一个变量；该变量将接收调用的结果。 详见 <xref linkend="plpgsql-statements-calling-procedure"/>。
          </para>
<!-- pgdoc-cn_end sig_en=aa3f738cf0fda5616111ebfc38a67181 -->

<!-- pgdoc-cn_start sig_en=d7ebee67468fbbd675129dba9fa78e41 sig_cn_org=None source=14.1 
     <para>
      Another way to declare a <application>PL/pgSQL</application> function
      is with <literal>RETURNS TABLE</literal>, for example:

<programlisting>
CREATE FUNCTION extended_sales(p_itemno int)
RETURNS TABLE(quantity int, total numeric) AS $$
BEGIN
    RETURN QUERY SELECT s.quantity, s.quantity * s.price FROM sales AS s
                 WHERE s.itemno = p_itemno;
END;
$$ LANGUAGE plpgsql;
</programlisting>

      This is exactly equivalent to declaring one or more <literal>OUT</literal>
      parameters and specifying <literal>RETURNS SETOF
      <replaceable>sometype</replaceable></literal>.
     </para>
________________________________________________________-->
     <para>
      声明一个<application>PL/pgSQL</application>函数的另一种方式是用<literal>RETURNS TABLE</literal>，例如：

<programlisting>
CREATE FUNCTION extended_sales(p_itemno int)
RETURNS TABLE(quantity int, total numeric) AS $$
BEGIN
    RETURN QUERY SELECT s.quantity, s.quantity * s.price FROM sales AS s
                 WHERE s.itemno = p_itemno;
END;
$$ LANGUAGE plpgsql;
</programlisting>

      这和声明一个或多个<literal>OUT</literal>参数并且指定<literal>RETURNS SETOF <replaceable>sometype</replaceable></literal>完全等效。
     </para>
<!-- pgdoc-cn_end sig_en=d7ebee67468fbbd675129dba9fa78e41 -->

<!-- pgdoc-cn_start sig_en=d65af2877d4f3a9f61ce9dbb4ed5e6d2 sig_cn_org=None source=14.1 
     <para>
      When the return type of a <application>PL/pgSQL</application> function
      is declared as a polymorphic type (see
      <xref linkend="extend-types-polymorphic"/>), a special
      parameter <literal>$0</literal> is created.  Its data type is the actual
      return type of the function, as deduced from the actual input types.
      This allows the function to access its actual return type
      as shown in <xref linkend="plpgsql-declaration-type"/>.
      <literal>$0</literal> is initialized to null and can be modified by
      the function, so it can be used to hold the return value if desired,
      though that is not required.  <literal>$0</literal> can also be
      given an alias.  For example, this function works on any data type
      that has a <literal>+</literal> operator:

<programlisting>
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement)
RETURNS anyelement AS $$
DECLARE
    result ALIAS FOR $0;
BEGIN
    result := v1 + v2 + v3;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>
________________________________________________________-->
     <para>
      当<application>PL/pgSQL</application>函数的返回类型被声明为多态类型（参见<xref linkend="extend-types-polymorphic"/>）时，
      一个特殊的参数 <literal>$0</literal> 已创建。它的数据类型是函数的实际返回类型，从实际输入类型推导出来。
	  这允许函数访问其实际的返回类型，如<xref linkend="plpgsql-declaration-type"/>所示。
      <literal>$0</literal>被初始化为空并且可以被该函数修改，因此它能够被用来保持可能需要的返回值，不过这不是必须的。
      <literal>$0</literal>也可以被给定一个别名。例如，这个函数工作在任何具有一个<literal>+</literal>操作符的数据类型上： 

<programlisting>
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement)
RETURNS anyelement AS $$
DECLARE
    result ALIAS FOR $0;
BEGIN
    result := v1 + v2 + v3;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=d65af2877d4f3a9f61ce9dbb4ed5e6d2 -->

<!-- pgdoc-cn_start sig_en=9b367cc637bbd80c098df2379c5b6319 sig_cn_org=None source=14.1 
     <para>
      The same effect can be obtained by declaring one or more output parameters as
      polymorphic types.  In this case the
      special <literal>$0</literal> parameter is not used; the output
      parameters themselves serve the same purpose.  For example:

<programlisting>
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement,
                                 OUT sum anyelement)
AS $$
BEGIN
    sum := v1 + v2 + v3;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>
________________________________________________________-->
     <para>
      通过声明一个或多个输出参数为多态类型可以得到同样的效果。在这种情况下，不使用特殊的<literal>$0</literal>参数，输出参数本身就用作相同的目的。例如：

<programlisting>
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement,
                                 OUT sum anyelement)
AS $$
BEGIN
    sum := v1 + v2 + v3;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=9b367cc637bbd80c098df2379c5b6319 -->

<!-- pgdoc-cn_start sig_en=3c3f8b24d8aa24e16c617345bad0a2dd sig_cn_org=None source=14.1 
     <para>
      In practice it might be more useful to declare a polymorphic function
      using the <type>anycompatible</type> family of types, so that automatic
      promotion of the input arguments to a common type will occur.
      For example:

<programlisting>
CREATE FUNCTION add_three_values(v1 anycompatible, v2 anycompatible, v3 anycompatible)
RETURNS anycompatible AS $$
BEGIN
    RETURN v1 + v2 + v3;
END;
$$ LANGUAGE plpgsql;
</programlisting>

      With this example, a call such as

<programlisting>
SELECT add_three_values(1, 2, 4.7);
</programlisting>

      will work, automatically promoting the integer inputs to numeric.
      The function using <type>anyelement</type> would require you to
      cast the three inputs to the same type manually.
     </para>
________________________________________________________-->
     <para>
      在实践中，使用<type>anycompatible</type>类型系列声明多态函数可能更有用，以便将输入参数自动提升为公共类型。例如：

<programlisting>
CREATE FUNCTION add_three_values(v1 anycompatible, v2 anycompatible, v3 anycompatible)
RETURNS anycompatible AS $$
BEGIN
    RETURN v1 + v2 + v3;
END;
$$ LANGUAGE plpgsql;
</programlisting>

      在此示例中，调用如

<programlisting>
SELECT add_three_values(1, 2, 4.7);
</programlisting>

      将工作，自动将整数输入提升为数字。使用<type>anyelement</type>的函数需要您手动将三个输入转换为相同的类型。
     </para>
<!-- pgdoc-cn_end sig_en=3c3f8b24d8aa24e16c617345bad0a2dd -->
    </sect2>

  <sect2 id="plpgsql-declaration-alias">
   <title><literal>ALIAS</literal></title>

<!-- pgdoc-cn_start sig_en=b661c8ffa1a4b19af87044469063c3ab sig_cn_org=None source=14.1 
<synopsis>
<replaceable>newname</replaceable> ALIAS FOR <replaceable>oldname</replaceable>;
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>newname</replaceable> ALIAS FOR <replaceable>oldname</replaceable>;
</synopsis>
<!-- pgdoc-cn_end sig_en=b661c8ffa1a4b19af87044469063c3ab -->

<!-- pgdoc-cn_start sig_en=3960566a7ccb6f37a9a2b5ee0838cd8c sig_cn_org=None source=14.1 
   <para>
    The <literal>ALIAS</literal> syntax is more general than is suggested in the
    previous section: you can declare an alias for any variable, not just
    function parameters.  The main practical use for this is to assign
    a different name for variables with predetermined names, such as
    <varname>NEW</varname> or <varname>OLD</varname> within
    a trigger function.
   </para>
________________________________________________________-->
   <para>
    <literal>ALIAS</literal>语法比前一节中建议的更一般化：你可以为任意变量声明一个别名，而不只是函数参数。其主要实际用途是为预先决定了名称的变量分配一个不同的名称，例如在一个触发器过程中的<varname>NEW</varname>或<varname>OLD</varname>。
   </para>
<!-- pgdoc-cn_end sig_en=3960566a7ccb6f37a9a2b5ee0838cd8c -->

<!-- pgdoc-cn_start sig_en=6fa93bba31617a2e3fd04b917f106a1a sig_cn_org=None source=14.1 
   <para>
    Examples:
<programlisting>
DECLARE
  prior ALIAS FOR old;
  updated ALIAS FOR new;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    例子：
<programlisting>
DECLARE
  prior ALIAS FOR old;
  updated ALIAS FOR new;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=6fa93bba31617a2e3fd04b917f106a1a -->

<!-- pgdoc-cn_start sig_en=96bf2e18871915dea78569348dd968c2 sig_cn_org=None source=14.1 
   <para>
    Since <literal>ALIAS</literal> creates two different ways to name the same
    object, unrestricted use can be confusing.  It's best to use it only
    for the purpose of overriding predetermined names.
   </para>
________________________________________________________-->
   <para>
    因为<literal>ALIAS</literal>创造了两种不同的方式来命名相同的对象，如果对其使用不加限制就会导致混淆。最好只把它用来覆盖预先决定的名称。
   </para>
<!-- pgdoc-cn_end sig_en=96bf2e18871915dea78569348dd968c2 -->
   </sect2>

  <sect2 id="plpgsql-declaration-type">
<!-- pgdoc-cn_start sig_en=5b027942f9d4e0c3e1408fbd8d8a9456 sig_cn_org=None source=14.1 
   <title>Copying Types</title>
________________________________________________________-->
   <title>复制类型</title>
<!-- pgdoc-cn_end sig_en=5b027942f9d4e0c3e1408fbd8d8a9456 -->

<!-- pgdoc-cn_start sig_en=809ece39a2759c5a176e1bb9581c88ea sig_cn_org=None source=14.1 
<synopsis>
<replaceable>variable</replaceable>%TYPE
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>variable</replaceable>%TYPE
</synopsis>
<!-- pgdoc-cn_end sig_en=809ece39a2759c5a176e1bb9581c88ea -->

<!-- pgdoc-cn_start sig_en=bffc12188e7056f821d2d3e4d55ede8a sig_cn_org=None source=14.1 
   <para>
    <literal>%TYPE</literal> provides the data type of a variable or
    table column. You can use this to declare variables that will hold
    database values. For example, let's say you have a column named
    <literal>user_id</literal> in your <literal>users</literal>
    table. To declare a variable with the same data type as
    <literal>users.user_id</literal> you write:
<programlisting>
user_id users.user_id%TYPE;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    <literal>%TYPE</literal>提供了一个变量或表列的数据类型。你可以用它来声明将保持数据库值的变量。例如，如果你在<literal>users</literal>中有一个名为<literal>user_id</literal>的列。要定义一个与<literal>users.user_id</literal>具有相同数据类型的变量：
<programlisting>
user_id users.user_id%TYPE;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=bffc12188e7056f821d2d3e4d55ede8a -->

<!-- pgdoc-cn_start sig_en=c02efe8953e6bd53c7c2a00987227bc8 sig_cn_org=None source=14.1 
   <para>
    By using <literal>%TYPE</literal> you don't need to know the data
    type of the structure you are referencing, and most importantly,
    if the data type of the referenced item changes in the future (for
    instance: you change the type of <literal>user_id</literal>
    from <type>integer</type> to <type>real</type>), you might not need
    to change your function definition.
   </para>
________________________________________________________-->
   <para>
    通过使用<literal>%TYPE</literal>，你不需要知道你要引用的结构的实际数据类型，而且最重要地，如果被引用项的数据类型在未来被改变（例如你把<literal>user_id</literal>的类型从<type>integer</type>改为<type>real</type>），你不需要改变你的函数定义。
   </para>
<!-- pgdoc-cn_end sig_en=c02efe8953e6bd53c7c2a00987227bc8 -->

<!-- pgdoc-cn_start sig_en=289f8687683fe7bfb4e52bba1ffba9fd sig_cn_org=None source=14.1 
   <para>
    <literal>%TYPE</literal> is particularly valuable in polymorphic
    functions, since the data types needed for internal variables can
    change from one call to the next.  Appropriate variables can be
    created by applying <literal>%TYPE</literal> to the function's
    arguments or result placeholders.
   </para>
________________________________________________________-->
   <para>
    <literal>%TYPE</literal>在多态函数中特别有价值，因为内部变量所需的数据类型能在两次调用时改变。可以把<literal>%TYPE</literal>应用在函数的参数或结果占位符上来创建合适的变量。
   </para>
<!-- pgdoc-cn_end sig_en=289f8687683fe7bfb4e52bba1ffba9fd -->

  </sect2>

    <sect2 id="plpgsql-declaration-rowtypes">
<!-- pgdoc-cn_start sig_en=46bf12b1d769286ffe95acb31e6003e9 sig_cn_org=None source=14.1 
     <title>Row Types</title>
________________________________________________________-->
     <title>行类型</title>
<!-- pgdoc-cn_end sig_en=46bf12b1d769286ffe95acb31e6003e9 -->

<!-- pgdoc-cn_start sig_en=825938fc1d84eb327a093f312d94a083 sig_cn_org=None source=14.1 
<synopsis>
<replaceable>name</replaceable> <replaceable>table_name</replaceable><literal>%ROWTYPE</literal>;
<replaceable>name</replaceable> <replaceable>composite_type_name</replaceable>;
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>name</replaceable> <replaceable>table_name</replaceable><literal>%ROWTYPE</literal>;
<replaceable>name</replaceable> <replaceable>composite_type_name</replaceable>;
</synopsis>
<!-- pgdoc-cn_end sig_en=825938fc1d84eb327a093f312d94a083 -->

<!-- pgdoc-cn_start sig_en=4a450368e39488c9406d51cdea9479fa sig_cn_org=None source=14.1 
   <para>
    A variable of a composite type is called a <firstterm>row</firstterm>
    variable (or <firstterm>row-type</firstterm> variable).  Such a variable
    can hold a whole row of a <command>SELECT</command> or <command>FOR</command>
    query result, so long as that query's column set matches the
    declared type of the variable.
    The individual fields of the row value
    are accessed using the usual dot notation, for example
    <literal>rowvar.field</literal>.
   </para>
________________________________________________________-->
   <para>
    一个组合类型的变量被称为一个<firstterm>行</firstterm>变量（或<firstterm>行类型</firstterm>变量）。这样一个变量可以保持一个<command>SELECT</command>或<command>FOR</command>查询结果的一整行，前提是查询的列集合匹配该变量被声明的类型。该行值的各个域可以使用通常的点号标记访问，例如<literal>rowvar.field</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=4a450368e39488c9406d51cdea9479fa -->

<!-- pgdoc-cn_start sig_en=a18b0100349216f8dac2c38042650cb9 sig_cn_org=None source=14.1 
   <para>
    A row variable can be declared to have the same type as the rows of
    an existing table or view, by using the
    <replaceable>table_name</replaceable><literal>%ROWTYPE</literal>
    notation; or it can be declared by giving a composite type's name.
    (Since every table has an associated composite type of the same name,
    it actually does not matter in <productname>PostgreSQL</productname> whether you
    write <literal>%ROWTYPE</literal> or not.  But the form with
    <literal>%ROWTYPE</literal> is more portable.)
   </para>
________________________________________________________-->
   <para>
    通过使用<replaceable>table_name</replaceable><literal>%ROWTYPE</literal>标记，一个行变量可以被声明为具有和一个现有表或视图的行相同的类型。它也可以通过给定一个组合类型名称来声明（因为每一个表都有一个相关联的具有相同名称的组合类型，所以在<productname>PostgreSQL</productname>中实际上写不写<literal>%ROWTYPE</literal>都没有关系。但是带有<literal>%ROWTYPE</literal>的形式可移植性更好）。
   </para>
<!-- pgdoc-cn_end sig_en=a18b0100349216f8dac2c38042650cb9 -->

<!-- pgdoc-cn_start sig_en=3db9baacb55f0b0e0c226adb0aac1b7b sig_cn_org=None source=14.1 
   <para>
    Parameters to a function can be
    composite types (complete table rows). In that case, the
    corresponding identifier <literal>$<replaceable>n</replaceable></literal> will be a row variable, and fields can
    be selected from it, for example <literal>$1.user_id</literal>.
   </para>
________________________________________________________-->
   <para>
    一个函数的参数可以是组合类型（完整的表行）。在这种情况下，相应的标识符<literal>$<replaceable>n</replaceable></literal>将是一个行变量，并且可以从中选择域，例如<literal>$1.user_id</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=3db9baacb55f0b0e0c226adb0aac1b7b -->

<!-- pgdoc-cn_start sig_en=0e45c5874e310662188d76d62c17abf3 sig_cn_org=None source=14.1 
   <para>
    Here is an example of using composite types.  <structname>table1</structname>
    and <structname>table2</structname> are existing tables having at least the
    mentioned fields:

<programlisting>
CREATE FUNCTION merge_fields(t_row table1) RETURNS text AS $$
DECLARE
    t2_row table2%ROWTYPE;
BEGIN
    SELECT * INTO t2_row FROM table2 WHERE ... ;
    RETURN t_row.f1 || t2_row.f3 || t_row.f5 || t2_row.f7;
END;
$$ LANGUAGE plpgsql;

SELECT merge_fields(t.*) FROM table1 t WHERE ... ;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    这里是一个使用组合类型的例子。<structname>table1</structname>和<structname>table2</structname>是已有的表，它们至少有以下提到的域：

<programlisting>
CREATE FUNCTION merge_fields(t_row table1) RETURNS text AS $$
DECLARE
    t2_row table2%ROWTYPE;
BEGIN
    SELECT * INTO t2_row FROM table2 WHERE ... ;
    RETURN t_row.f1 || t2_row.f3 || t_row.f5 || t2_row.f7;
END;
$$ LANGUAGE plpgsql;

SELECT merge_fields(t.*) FROM table1 t WHERE ... ;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=0e45c5874e310662188d76d62c17abf3 -->
  </sect2>

  <sect2 id="plpgsql-declaration-records">
<!-- pgdoc-cn_start sig_en=edc69134fd66a294c0528b2e5cf32eaa sig_cn_org=None source=14.1 
   <title>Record Types</title>
________________________________________________________-->
   <title>记录类型</title>
<!-- pgdoc-cn_end sig_en=edc69134fd66a294c0528b2e5cf32eaa -->

<!-- pgdoc-cn_start sig_en=936a4b8353979f78f66f45477fdb96c1 sig_cn_org=None source=14.1 
<synopsis>
<replaceable>name</replaceable> RECORD;
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>name</replaceable> RECORD;
</synopsis>
<!-- pgdoc-cn_end sig_en=936a4b8353979f78f66f45477fdb96c1 -->

<!-- pgdoc-cn_start sig_en=ffe4828da6996d5b5ceff246223194d4 sig_cn_org=None source=14.1 
   <para>
    Record variables are similar to row-type variables, but they have no
    predefined structure.  They take on the actual row structure of the
    row they are assigned during a <command>SELECT</command> or <command>FOR</command> command.  The substructure
    of a record variable can change each time it is assigned to.
    A consequence of this is that until a record variable is first assigned
    to, it has no substructure, and any attempt to access a
    field in it will draw a run-time error.
   </para>
________________________________________________________-->
   <para>
    记录变量和行类型变量类似，但是它们没有预定义的结构。它们采用在一个<command>SELECT</command>或<command>FOR</command>命令期间为其赋值的行的真实行结构。一个记录变量的子结构能在每次它被赋值时改变。这样的结果是直到一个记录变量第一次被赋值之前，它都没有子结构，并且任何尝试访问其中一个域都会导致一个运行时错误。
   </para>
<!-- pgdoc-cn_end sig_en=ffe4828da6996d5b5ceff246223194d4 -->

<!-- pgdoc-cn_start sig_en=efe12f70554c64afaf45da157bd96213 sig_cn_org=None source=14.1 
   <para>
    Note that <literal>RECORD</literal> is not a true data type, only a placeholder.
    One should also realize that when a <application>PL/pgSQL</application>
    function is declared to return type <type>record</type>, this is not quite the
    same concept as a record variable, even though such a function might
    use a record variable to hold its result.  In both cases the actual row
    structure is unknown when the function is written, but for a function
    returning <type>record</type> the actual structure is determined when the
    calling query is parsed, whereas a record variable can change its row
    structure on-the-fly.
   </para>
________________________________________________________-->
   <para>
    注意<literal>RECORD</literal>并非一个真正的数据类型，只是一个占位符。我们也应该认识到当一个<application>PL/pgSQL</application>函数被声明为返回类型<type>record</type>，这与一个记录变量并不是完全相同的概念，即便这样一个函数可能会用一个记录变量来保持其结果。在两种情况下，编写函数时都不知道真实的行结构，但是对于一个返回<type>record</type>的函数，当调用查询被解析时就已经决定了真正的结构，而一个行变量能够随时改变它的行结构。
   </para>
<!-- pgdoc-cn_end sig_en=efe12f70554c64afaf45da157bd96213 -->
  </sect2>

  <sect2 id="plpgsql-declaration-collation">
<!-- pgdoc-cn_start sig_en=fa4e51c8e012d4d311702a4518e2ea07 sig_cn_org=None source=14.1 
   <title>Collation of <application>PL/pgSQL</application> Variables</title>
________________________________________________________-->
   <title><application>PL/pgSQL</application>变量的排序规则</title>
<!-- pgdoc-cn_end sig_en=fa4e51c8e012d4d311702a4518e2ea07 -->

<!-- pgdoc-cn_start sig_en=2b6d393764f5c005764282063bca3a21 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>collation</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>collation</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=2b6d393764f5c005764282063bca3a21 -->

<!-- pgdoc-cn_start sig_en=4b7f2c2994e6455a1ebac90977902332 sig_cn_org=None source=14.1 
   <para>
    When a <application>PL/pgSQL</application> function has one or more
    parameters of collatable data types, a collation is identified for each
    function call depending on the collations assigned to the actual
    arguments, as described in <xref linkend="collation"/>.  If a collation is
    successfully identified (i.e., there are no conflicts of implicit
    collations among the arguments) then all the collatable parameters are
    treated as having that collation implicitly.  This will affect the
    behavior of collation-sensitive operations within the function.
    For example, consider

<programlisting>
CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b;
END;
$$ LANGUAGE plpgsql;

SELECT less_than(text_field_1, text_field_2) FROM table1;
SELECT less_than(text_field_1, text_field_2 COLLATE "C") FROM table1;
</programlisting>

    The first use of <function>less_than</function> will use the common collation
    of <structfield>text_field_1</structfield> and <structfield>text_field_2</structfield> for
    the comparison, while the second use will use <literal>C</literal> collation.
   </para>
________________________________________________________-->
   <para>
    当一个<application>PL/pgSQL</application>函数有一个或多个可排序数据类型的参数时，为每一次函数调用都会基于赋值给实参的排序规则来确定出一个排序规则，如<xref linkend="collation"/>中所述。如果一个排序规则被成功地确定（即在参数之间隐式排序规则没有冲突），那么所有的可排序参数会被当做隐式具有那个排序规则。这将在函数中影响行为受到排序规则影响的操作。例如，考虑

<programlisting>
CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b;
END;
$$ LANGUAGE plpgsql;

SELECT less_than(text_field_1, text_field_2) FROM table1;
SELECT less_than(text_field_1, text_field_2 COLLATE "C") FROM table1;
</programlisting>

    <function>less_than</function>的第一次使用将会采用<structfield>text_field_1</structfield>和<structfield>text_field_2</structfield>共同的排序规则进行比较，而第二次使用将采用<literal>C</literal>排序规则。
   </para>
<!-- pgdoc-cn_end sig_en=4b7f2c2994e6455a1ebac90977902332 -->

<!-- pgdoc-cn_start sig_en=67a4a128e295a72c6e0a5619f10864d3 sig_cn_org=None source=14.1 
   <para>
    Furthermore, the identified collation is also assumed as the collation of
    any local variables that are of collatable types.  Thus this function
    would not work any differently if it were written as

<programlisting>
CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$
DECLARE
    local_a text := a;
    local_b text := b;
BEGIN
    RETURN local_a &lt; local_b;
END;
$$ LANGUAGE plpgsql;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    此外，被确定的排序规则也被假定为任何可排序数据类型本地变量的排序规则。因此，当这个函数被写为以下形式时，它工作将不会有什么不同

<programlisting>
CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$
DECLARE
    local_a text := a;
    local_b text := b;
BEGIN
    RETURN local_a &lt; local_b;
END;
$$ LANGUAGE plpgsql;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=67a4a128e295a72c6e0a5619f10864d3 -->

<!-- pgdoc-cn_start sig_en=0ca73846a415b0f5acf718788ca80731 sig_cn_org=None source=14.1 
   <para>
    If there are no parameters of collatable data types, or no common
    collation can be identified for them, then parameters and local variables
    use the default collation of their data type (which is usually the
    database's default collation, but could be different for variables of
    domain types).
   </para>
________________________________________________________-->
   <para>
    如果没有可排序数据类型的参数，或者不能为它们确定共同的排序规则，那么参数和本地变量会使用它们数据类型的默认排序规则（通常是数据库的默认排序规则，但是可能不同于域类型的变量）。
   </para>
<!-- pgdoc-cn_end sig_en=0ca73846a415b0f5acf718788ca80731 -->

<!-- pgdoc-cn_start sig_en=1559e9f31a93685a5d9e3e373969dc6e sig_cn_org=None source=14.1 
   <para>
    A local variable of a collatable data type can have a different collation
    associated with it by including the <literal>COLLATE</literal> option in its
    declaration, for example

<programlisting>
DECLARE
    local_a text COLLATE "en_US";
</programlisting>

    This option overrides the collation that would otherwise be
    given to the variable according to the rules above.
   </para>
________________________________________________________-->
   <para>
    通过在一个可排序数据类型的本地变量的声明中包括<literal>COLLATE</literal>选项，可以为它指定一个不同的排序规则，例如

<programlisting>
DECLARE
    local_a text COLLATE "en_US";
</programlisting>

    这个选项会覆盖根据上述规则被给予该变量的排序规则。
   </para>
<!-- pgdoc-cn_end sig_en=1559e9f31a93685a5d9e3e373969dc6e -->

<!-- pgdoc-cn_start sig_en=546f77dc4ff765d0b21f662c7f499251 sig_cn_org=None source=14.1 
   <para>
    Also, of course explicit <literal>COLLATE</literal> clauses can be written inside
    a function if it is desired to force a particular collation to be used in
    a particular operation.  For example,

<programlisting>
CREATE FUNCTION less_than_c(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b COLLATE "C";
END;
$$ LANGUAGE plpgsql;
</programlisting>

    This overrides the collations associated with the table columns,
    parameters, or local variables used in the expression, just as would
    happen in a plain SQL command.
   </para>
________________________________________________________-->
   <para>
    还有，如果一个函数想要强制在一个特定操作中使用一个特定排序规则，当然可以在该函数内部写一个显式的<literal>COLLATE</literal>子句。例如：

<programlisting>
CREATE FUNCTION less_than_c(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b COLLATE "C";
END;
$$ LANGUAGE plpgsql;
</programlisting>

    这会覆盖表达式中使用的表列、参数或本地变量相关的排序规则，就像在纯 SQL 命令中发生的一样。
   </para>
<!-- pgdoc-cn_end sig_en=546f77dc4ff765d0b21f662c7f499251 -->
  </sect2>
  </sect1>

  <sect1 id="plpgsql-expressions">
<!-- pgdoc-cn_start sig_en=71509b98eabe58279b2f521921324448 sig_cn_org=None source=14.1 
  <title>Expressions</title>
________________________________________________________-->
  <title>表达式</title>
<!-- pgdoc-cn_end sig_en=71509b98eabe58279b2f521921324448 -->

<!-- pgdoc-cn_start sig_en=b0f56ded4daddea74ff398d07ef898f5 sig_cn_org=None source=14.1 
    <para>
     All expressions used in <application>PL/pgSQL</application>
     statements are processed using the server's main
     <acronym>SQL</acronym> executor.  For example, when you write
     a <application>PL/pgSQL</application> statement like
<synopsis>
IF <replaceable>expression</replaceable> THEN ...
</synopsis>
     <application>PL/pgSQL</application> will evaluate the expression by
     feeding a query like
<synopsis>
SELECT <replaceable>expression</replaceable>
</synopsis>
     to the main SQL engine.  While forming the <command>SELECT</command> command,
     any occurrences of <application>PL/pgSQL</application> variable names
     are replaced by query parameters, as discussed in detail in
     <xref linkend="plpgsql-var-subst"/>.
     This allows the query plan for the <command>SELECT</command> to
     be prepared just once and then reused for subsequent
     evaluations with different values of the variables.  Thus, what
     really happens on first use of an expression is essentially a
     <command>PREPARE</command> command.  For example, if we have declared
     two integer variables <literal>x</literal> and <literal>y</literal>, and we write
<programlisting>
IF x &lt; y THEN ...
</programlisting>
     what happens behind the scenes is equivalent to
<programlisting>
PREPARE <replaceable>statement_name</replaceable>(integer, integer) AS SELECT $1 &lt; $2;
</programlisting>
     and then this prepared statement is <command>EXECUTE</command>d for each
     execution of the <command>IF</command> statement, with the current values
     of the <application>PL/pgSQL</application> variables supplied as
     parameter values.  Normally these details are
     not important to a <application>PL/pgSQL</application> user, but
     they are useful to know when trying to diagnose a problem.
     More information appears in <xref linkend="plpgsql-plan-caching"/>.
    </para>
________________________________________________________-->
    <para>
     <application>PL/pgSQL</application>语句中用到的所有表达式会被服务器的主<acronym>SQL</acronym>执行器处理。例如，当你写一个这样的<application>PL/pgSQL</application>语句时
<synopsis>
IF <replaceable>expression</replaceable> THEN ...
</synopsis>
     <application>PL/pgSQL</application>将通过给主 SQL 引擎发送一个查询
<synopsis>
SELECT <replaceable>expression</replaceable>
</synopsis>
     来计算该表达式。如<xref linkend="plpgsql-var-subst"/>中所详细讨论的，在构造该<command>SELECT</command>命令时，<application>PL/pgSQL</application>变量名的每一次出现会被查询参数所替换。这允许<command>SELECT</command>的查询计划仅被准备一次并且被重用于之后的对于该变量不同值的计算。因此，在一个表达式第一次被使用时实际发生的本质上是一个<command>PREPARE</command>命令。例如，如果我们已经声明了两个整数变量<literal>x</literal>和<literal>y</literal>，并且我们写了
<programlisting>
IF x &lt; y THEN ...
</programlisting>
     在现象之后发生的等效于
<programlisting>
PREPARE <replaceable>statement_name</replaceable>(integer, integer) AS SELECT $1 &lt; $2;
</programlisting>
     并且然后为每一次<command>IF</command>语句的执行，这个预备语句都会被<command>EXECUTE</command>，执行时使用变量的当前值作为参数值。通常这些细节对于一个<application>PL/pgSQL</application>用户并不重要，但是在尝试诊断一个问题时了解它们很有用。更多信息可见<xref linkend="plpgsql-plan-caching"/>。
    </para>
<!-- pgdoc-cn_end sig_en=b0f56ded4daddea74ff398d07ef898f5 -->

<!-- pgdoc-cn_start sig_en=89d5b724e10685da94adab0549bb026b sig_cn_org=None source=14.1 
    <para>
     Since an <replaceable>expression</replaceable> is converted to a
     <literal>SELECT</literal> command, it can contain the same clauses
     that an ordinary <literal>SELECT</literal> would, except that it
     cannot include a top-level <literal>UNION</literal>,
     <literal>INTERSECT</literal>, or <literal>EXCEPT</literal> clause.
     Thus for example one could test whether a table is non-empty with
<programlisting>
IF count(*) &gt; 0 FROM my_table THEN ...
</programlisting>
     since the <replaceable>expression</replaceable>
     between <literal>IF</literal> and <literal>THEN</literal> is parsed as
     though it were <literal>SELECT count(*) &gt; 0 FROM my_table</literal>.
     The <literal>SELECT</literal> must produce a single column, and not
     more than one row.  (If it produces no rows, the result is taken as
     NULL.)
    </para>
________________________________________________________-->
    <para>
         因为一个 <replaceable>expression</replaceable> 可以被转换成
         <literal>SELECT</literal> 命令，它可以包含与普通<literal>SELECT</literal>命令相同的子句，但是，它不能包含顶级<literal>UNION</literal>，<literal>INTERSECT</literal>， 或者 <literal>EXCEPT</literal>子句。例如，您可以检查表是否非空：
    <programlisting>
    IF count(*) &gt; 0 FROM my_table THEN ...
    </programlisting>
         因为在 <literal>IF</literal> 和 <literal>THEN</literal>之间的<replaceable>expression</replaceable>被解析为  <literal>SELECT count(*) &gt; 0 FROM my_table</literal>。
          <literal>SELECT</literal> 必须生成一个单行列，不能超过一行。 (如果没有行数据返回， 结果为NULL。)
        </para>
<!-- pgdoc-cn_end sig_en=89d5b724e10685da94adab0549bb026b -->
  </sect1>

  <sect1 id="plpgsql-statements">
<!-- pgdoc-cn_start sig_en=cd1a1cb8058f8c192b5688281036a58f sig_cn_org=None source=14.1 
  <title>Basic Statements</title>
________________________________________________________-->
  <title>基本语句</title>
<!-- pgdoc-cn_end sig_en=cd1a1cb8058f8c192b5688281036a58f -->

<!-- pgdoc-cn_start sig_en=30fcebfe38ba7e606f464befcc2ef161 sig_cn_org=None source=14.1 
   <para>
    In this section and the following ones, we describe all the statement
    types that are explicitly understood by
    <application>PL/pgSQL</application>.
    Anything not recognized as one of these statement types is presumed
    to be an SQL command and is sent to the main database engine to execute,
    as described in <xref linkend="plpgsql-statements-general-sql"/>.
   </para>
________________________________________________________-->
   <para>
    在这一节和接下来的小节中，我们会描述<application>PL/pgSQL</application>能明确理解的所有语句类型。任何不被识别为这些语句类型之一的被假定为是一个 SQL 命令，并且会被发送给主数据库引擎执行，具体如<xref linkend="plpgsql-statements-general-sql"/>中所述。
   </para>
<!-- pgdoc-cn_end sig_en=30fcebfe38ba7e606f464befcc2ef161 -->

   <sect2 id="plpgsql-statements-assignment">
<!-- pgdoc-cn_start sig_en=eb079c29eaed7565024d3873e25472b7 sig_cn_org=None source=14.1 
    <title>Assignment</title>
________________________________________________________-->
    <title>赋值</title>
<!-- pgdoc-cn_end sig_en=eb079c29eaed7565024d3873e25472b7 -->

<!-- pgdoc-cn_start sig_en=c68d2aaea00e310022534ce32355ff15 sig_cn_org=None source=14.1 
    <para>
     An assignment of a value to a <application>PL/pgSQL</application>
     variable is written as:
<synopsis>
<replaceable>variable</replaceable> { := | = } <replaceable>expression</replaceable>;
</synopsis>
     As explained previously, the expression in such a statement is evaluated
     by means of an SQL <command>SELECT</command> command sent to the main
     database engine.  The expression must yield a single value (possibly
     a row value, if the variable is a row or record variable).  The target
     variable can be a simple variable (optionally qualified with a block
     name), a field of a row or record target, or an element or slice of
     an array target.  Equal (<literal>=</literal>) can be
     used instead of PL/SQL-compliant <literal>:=</literal>.
    </para>
________________________________________________________-->
    <para>
     为一个<application>PL/pgSQL</application>变量赋一个值可以被写为：
<synopsis>
<replaceable>variable</replaceable> { := | = } <replaceable>expression</replaceable>;
</synopsis>
     正如以前所解释的，这样一个语句中的表达式被以一个 SQL
      <command>SELECT</command>命令被发送到主数据库引擎的方式计算。
      该表达式必须得到一个单一值（如果该变量是一个行或记录变量，
      它可能是一个行值）。该目标变量可以是一个简单变量（
      可以选择用一个块名限定）、一个行或记录变量的域或是一个简单
      变量或域的数组的元素或者数组的切片。
     等号（<literal>=</literal>）可以被用来代替 PL/SQL-兼容的
      <literal>:=</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=c68d2aaea00e310022534ce32355ff15 -->

<!-- pgdoc-cn_start sig_en=fb7d160cd4b935fc6594c2bc86bf1f6a sig_cn_org=None source=14.1 
    <para>
     If the expression's result data type doesn't match the variable's
     data type, the value will be coerced as though by an assignment cast
     (see <xref linkend="typeconv-query"/>).  If no assignment cast is known
     for the pair of data types involved, the <application>PL/pgSQL</application>
     interpreter will attempt to convert the result value textually, that is
     by applying the result type's output function followed by the variable
     type's input function.  Note that this could result in run-time errors
     generated by the input function, if the string form of the result value
     is not acceptable to the input function.
    </para>
________________________________________________________-->
    <para>
     如果该表达式的结果数据类型不匹配变量的数据类型，该值将被强制为变量
     的类型，就好像做了赋值造型一样（见<xref linkend="typeconv-query"/>）。
     如果没有用于所涉及到的数据类型的赋值造型可用，
     <application>PL/pgSQL</application>解释器将尝试以文本的方式转换结果值，也就
     是在应用结果类型的输出函数之后再应用变量类型的输入函数。注意如果结果
     值的字符串形式无法被输入函数所接受，这可能会导致由输入函数产生的运行
     时错误。
    </para>
<!-- pgdoc-cn_end sig_en=fb7d160cd4b935fc6594c2bc86bf1f6a -->

<!-- pgdoc-cn_start sig_en=428d896eff70efd47b4eae05d21e4a2c sig_cn_org=None source=14.1 
    <para>
     Examples:
<programlisting>
tax := subtotal * 0.06;
my_record.user_id := 20;
my_array[j] := 20;
my_array[1:3] := array[1,2,3];
complex_array[n].realpart = 12.3;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     例子：
<programlisting>
tax := subtotal * 0.06;
my_record.user_id := 20;
my_array[j] := 20;
my_array[1:3] := array[1,2,3];
complex_array[n].realpart = 12.3;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=428d896eff70efd47b4eae05d21e4a2c -->
   </sect2>

   <sect2 id="plpgsql-statements-general-sql">
<!-- pgdoc-cn_start sig_en=3c517345456aa485795fc9508dac632d sig_cn_org=None source=14.1 
    <title>Executing SQL Commands</title>
________________________________________________________-->
    <title>执行SQL命令</title>
<!-- pgdoc-cn_end sig_en=3c517345456aa485795fc9508dac632d -->

<!-- pgdoc-cn_start sig_en=94645aaa1a25c0de40336c92d66de667 sig_cn_org=None source=14.1 
    <para>
     In general, any SQL command that does not return rows can be executed
     within a <application>PL/pgSQL</application> function just by writing
     the command.  For example, you could create and fill a table by writing
<programlisting>
CREATE TABLE mytable (id int primary key, data text);
INSERT INTO mytable VALUES (1,'one'), (2,'two');
</programlisting>
    </para>
________________________________________________________-->
    <para>
     通常，任何不返回行的 SQL 命令，你可以通过把该命令直接写在一个 <application>PL/pgSQL</application> 函数中执行它。
     例如，创建和填充表数据，你可以这样写：
     <programlisting>
     CREATE TABLE mytable (id int primary key, data text);
     INSERT INTO mytable VALUES (1,'one'), (2,'two');
     </programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=94645aaa1a25c0de40336c92d66de667 -->

<!-- pgdoc-cn_start sig_en=6b56710be913a628f43d4bf752425de8 sig_cn_org=None source=14.1 
    <para>
     If the command does return rows (for example <command>SELECT</command>,
     or <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>
     with <literal>RETURNING</literal>), there are two ways to proceed.
     When the command will return at most one row, or you only care about
     the first row of output, write the command as usual but add
     an <literal>INTO</literal> clause to capture the output, as described
     in <xref linkend="plpgsql-statements-sql-onerow"/>.
     To process all of the output rows, write the command as the data
     source for a <command>FOR</command> loop, as described in
     <xref linkend="plpgsql-records-iterating"/>.
    </para>
________________________________________________________-->
    <para>
         如果命令返回行 (例如 <command>SELECT</command>，
         或者 <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>
         带有 <literal>RETURNING</literal>的命令)，有两种方式处理。
         当命令最多返回一行，或者你只关心第一行的输出时，像往常一样编写命令，但要添加一个<literal>INTO</literal>子句来捕获输出，如<xref linkend="plpgsql-statements-sql-onerow"/>中所述。为了处理所有的输出行，把命令写成<command>FOR</command>循环的数据源，如 <xref linkend="plpgsql-records-iterating"/>中所述。
        </para>
<!-- pgdoc-cn_end sig_en=6b56710be913a628f43d4bf752425de8 -->

<!-- pgdoc-cn_start sig_en=434e180eb6b12f042bac646a0ddcd34e sig_cn_org=None source=14.1 
    <para>
     Usually it is not sufficient just to execute statically-defined SQL
     commands.  Typically you'll want a command to use varying data values,
     or even to vary in more fundamental ways such as by using different
     table names at different times.  Again, there are two ways to proceed
     depending on the situation.
    </para>
________________________________________________________-->
    <para>
         简单地执行静态定义的 SQL 命令通常是不够的。通常，您会希望使用使用可变数据值的命令，或者甚至以更基本的方式进行更改，例如在不同时间使用不同的表名。同样，有两种方法，视情况而定。
        </para>
<!-- pgdoc-cn_end sig_en=434e180eb6b12f042bac646a0ddcd34e -->

<!-- pgdoc-cn_start sig_en=9cf66a137f906f15d8e0a68b5d171641 sig_cn_org=54995106ef3e4b9cfca1e04915a522cf source=15.7 
    <para>
     <application>PL/pgSQL</application> variable values can be
     automatically inserted into optimizable SQL commands, which
     are <command>SELECT</command>, <command>INSERT</command>,
     <command>UPDATE</command>, <command>DELETE</command>,
     <command>MERGE</command>, and certain
     utility commands that incorporate one of these, such
     as <command>EXPLAIN</command> and <command>CREATE TABLE ... AS
     SELECT</command>.  In these commands,
     any <application>PL/pgSQL</application> variable name appearing
     in the command text is replaced by a query parameter, and then the
     current value of the variable is provided as the parameter value
     at run time.  This is exactly like the processing described earlier
     for expressions; for details see <xref linkend="plpgsql-var-subst"/>.
    </para>
________________________________________________________-->
    <para>
     <application>PL/pgSQL</application>变量值可以自动插入到可优化的SQL命令中，这些命令包括<command>SELECT</command>、<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>、<command>MERGE</command>以及某些包含其中一个的实用命令，比如<command>EXPLAIN</command>和<command>CREATE TABLE ... AS SELECT</command>。在这些命令中，命令文本中出现的任何<application>PL/pgSQL</application>变量名都会被查询参数替换，然后变量的当前值会在运行时作为参数值提供。这与前面描述的表达式处理完全相同；详情请参见<xref linkend="plpgsql-var-subst"/>。
    </para>
<!-- pgdoc-cn_end sig_en=9cf66a137f906f15d8e0a68b5d171641 -->

<!-- pgdoc-cn_start sig_en=d5a0976148fb4bbb57f28fff36df600b sig_cn_org=None source=14.1 
    <para>
     When executing an optimizable SQL command in this way,
     <application>PL/pgSQL</application> may cache and re-use the execution
     plan for the command, as discussed in
     <xref linkend="plpgsql-plan-caching"/>.
    </para>
________________________________________________________-->
    <para>
     当以这种方式执行一个可优化的 SQL 命令时，如<xref linkend="plpgsql-plan-caching"/>中讨论的，<application>PL/pgSQL</application>会为该命令缓存并重用执行计划。
    </para>
<!-- pgdoc-cn_end sig_en=d5a0976148fb4bbb57f28fff36df600b -->

<!-- pgdoc-cn_start sig_en=36cf916f466177990920dbe152cc954d sig_cn_org=None source=14.1 
    <para>
     Non-optimizable SQL commands (also called utility commands) are not
     capable of accepting query parameters.  So automatic substitution
     of <application>PL/pgSQL</application> variables does not work in such
     commands.  To include non-constant text in a utility command executed
     from <application>PL/pgSQL</application>, you must build the utility
     command as a string and then <command>EXECUTE</command> it, as
     discussed in <xref linkend="plpgsql-statements-executing-dyn"/>.
    </para>
________________________________________________________-->
    <para>
        不可优化的SQL命令（也称为实用命令）不能够接受查询参数。 所以自动替换<application>PL/pgSQL</application>的变量在这类命令中不起作用。 要在从<application>PL/pgSQL</application>执行的实用程序命令中包含非常量文本，你必须将实用程序命令构建为一个字符串，然后<command>EXECUTE</command>它，如<xref linkend="plpgsql-statements-executing-dyn"/>中所讨论的。
        </para>
<!-- pgdoc-cn_end sig_en=36cf916f466177990920dbe152cc954d -->

<!-- pgdoc-cn_start sig_en=eedf466a166834e8f3bcd113009ec2fe sig_cn_org=None source=14.1 
    <para>
     <command>EXECUTE</command> must also be used if you want to modify
     the command in some other way than supplying a data value, for example
     by changing a table name.
    </para>
________________________________________________________-->
    <para>
         <command>EXECUTE</command>也必须使用，如果你想以某种其他方式修改命令，而不是提供数据值，例如改变表名。
        </para>
<!-- pgdoc-cn_end sig_en=eedf466a166834e8f3bcd113009ec2fe -->

<!-- pgdoc-cn_start sig_en=9a746182e1f661006c2303264b3d70b0 sig_cn_org=None source=14.1 
    <para>
     Sometimes it is useful to evaluate an expression or <command>SELECT</command>
     query but discard the result, for example when calling a function
     that has side-effects but no useful result value.  To do
     this in <application>PL/pgSQL</application>, use the
     <command>PERFORM</command> statement:

<synopsis>
PERFORM <replaceable>query</replaceable>;
</synopsis>

     This executes <replaceable>query</replaceable> and discards the
     result.  Write the <replaceable>query</replaceable> the same
     way you would write an SQL <command>SELECT</command> command, but replace the
     initial keyword <command>SELECT</command> with <command>PERFORM</command>.
     For <command>WITH</command> queries, use <command>PERFORM</command> and then
     place the query in parentheses.  (In this case, the query can only
     return one row.)
     <application>PL/pgSQL</application> variables will be
     substituted into the query just as described above,
     and the plan is cached in the same way.  Also, the special variable
     <literal>FOUND</literal> is set to true if the query produced at
     least one row, or false if it produced no rows (see
     <xref linkend="plpgsql-statements-diagnostics"/>).
    </para>
________________________________________________________-->
    <para>
     有时候计算一个表达式或<command>SELECT</command>查询但抛弃其结果是有用的，例如调用一个有副作用但是没有有用的结果值的函数。在<application>PL/pgSQL</application>中要这样做，可使用<command>PERFORM</command>语句：

<synopsis>
PERFORM <replaceable>query</replaceable>;
</synopsis>

     这会执行<replaceable>query</replaceable>并且丢弃掉结果。以写一个SQL <command>SELECT</command>命令相同的方式写该<replaceable>query</replaceable>，并且将初始的关键词<command>SELECT</command>替换为<command>PERFORM</command>。对于<command>WITH</command>查询，使用<command>PERFORM</command>并且接着把该查询放在圆括号中（在这种情况中，该查询只能返回一行）。<application>PL/pgSQL</application>变量将被替换到该查询中，正如上面描述的查询，并且计划被以相同的方式被缓存。还有，如果该查询产生至少一行，特殊变量<literal>FOUND</literal>会被设置为真，而如果它不产生行则设置为假（见<xref linkend="plpgsql-statements-diagnostics"/>）。
    </para>
<!-- pgdoc-cn_end sig_en=9a746182e1f661006c2303264b3d70b0 -->

    <note>
<!-- pgdoc-cn_start sig_en=1680a5924a42af6ce6569e7f25c7885d sig_cn_org=None source=14.1 
     <para>
      One might expect that writing <command>SELECT</command> directly
      would accomplish this result, but at
      present the only accepted way to do it is
      <command>PERFORM</command>.  An SQL command that can return rows,
      such as <command>SELECT</command>, will be rejected as an error
      unless it has an <literal>INTO</literal> clause as discussed in the
      next section.
     </para>
________________________________________________________-->
     <para>
      我们可能期望直接写<command>SELECT</command>能实现这个结果，但是当前唯一被接受的方式是<command>PERFORM</command>。一个能返回行的 SQL 命令（例如<command>SELECT</command>）将被当成一个错误拒绝，除非它像下一节中讨论的有一个<literal>INTO</literal>子句。
     </para>
<!-- pgdoc-cn_end sig_en=1680a5924a42af6ce6569e7f25c7885d -->
    </note>

<!-- pgdoc-cn_start sig_en=7264c572ef36472f6b5b6c1822bfd28a sig_cn_org=None source=14.1 
    <para>
     An example:
<programlisting>
PERFORM create_mv('cs_session_page_requests_mv', my_query);
</programlisting>
    </para>
________________________________________________________-->
    <para>
     一个例子：
<programlisting>
PERFORM create_mv('cs_session_page_requests_mv', my_query);
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=7264c572ef36472f6b5b6c1822bfd28a -->
   </sect2>

   <sect2 id="plpgsql-statements-sql-onerow">
<!-- pgdoc-cn_start sig_en=6c995c5542c5b1450923486d7f9d2f2d sig_cn_org=None source=14.1 
    <title>Executing a Command with a Single-Row Result</title>
________________________________________________________-->
    <title>执行一个有单一行结果的命令</title>
<!-- pgdoc-cn_end sig_en=6c995c5542c5b1450923486d7f9d2f2d -->

<!-- pgdoc-cn_start sig_en=4940b4c98e02364b033e5e831be6b914 sig_cn_org=None source=14.1 
    <indexterm zone="plpgsql-statements-sql-onerow">
     <primary>SELECT INTO</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="plpgsql-statements-sql-onerow">
     <primary>SELECT INTO</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=4940b4c98e02364b033e5e831be6b914 -->

<!-- pgdoc-cn_start sig_en=a1f44d7368ec7f7bccab503c9d77dd2d sig_cn_org=None source=14.1 
    <indexterm zone="plpgsql-statements-sql-onerow">
     <primary>RETURNING INTO</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="plpgsql-statements-sql-onerow">
     <primary>RETURNING INTO</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=a1f44d7368ec7f7bccab503c9d77dd2d -->

<!-- pgdoc-cn_start sig_en=1b93be9e45d873ce747bef75e270e41b sig_cn_org=None source=14.1 
    <para>
     The result of an SQL command yielding a single row (possibly of multiple
     columns) can be assigned to a record variable, row-type variable, or list
     of scalar variables.  This is done by writing the base SQL command and
     adding an <literal>INTO</literal> clause.  For example,

<synopsis>
SELECT <replaceable>select_expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable> FROM ...;
INSERT ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
UPDATE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
DELETE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
</synopsis>

     where <replaceable>target</replaceable> can be a record variable, a row
     variable, or a comma-separated list of simple variables and
     record/row fields.
     <application>PL/pgSQL</application> variables will be
     substituted into the rest of the command (that is, everything but the
     <literal>INTO</literal> clause) just as described above,
     and the plan is cached in the same way.
     This works for <command>SELECT</command>,
     <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> with
     <literal>RETURNING</literal>, and certain utility commands
     that return row sets, such as <command>EXPLAIN</command>.
     Except for the <literal>INTO</literal> clause, the SQL command is the same
     as it would be written outside <application>PL/pgSQL</application>.
    </para>
________________________________________________________-->
    <para>
     一个产生单一行（可能有多个列）的 SQL 命令的结果可以被赋值给一个记录变量、行类型变量或标量变量列表。这通过书写基础 SQL 命令并增加一个<literal>INTO</literal>子句来达成。例如：

<synopsis>
SELECT <replaceable>select_expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable> FROM ...;
INSERT ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
UPDATE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
DELETE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
</synopsis>

     其中<replaceable>target</replaceable>可以是一个记录变量、一个行变量或一个有逗号分隔的简单变量和记录/行域列表。<application>PL/pgSQL</application>变量将被替换到该命令的剩余部分中(即除了<literal>INTO</literal> 子句所有的)，正如之前描述的，计划以同样的方式缓存。这对<command>SELECT</command>、带有<literal>RETURNING</literal>的<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>以及返回行集的某些工具命令（例如<command>EXPLAIN</command>）。除了<literal>INTO</literal>子句，SQL 命令和它在<application>PL/pgSQL</application>之外的写法一样。
    </para>
<!-- pgdoc-cn_end sig_en=1b93be9e45d873ce747bef75e270e41b -->

   <tip>
<!-- pgdoc-cn_start sig_en=f6f9b14da4ed3cd1f15f80fd1812d596 sig_cn_org=None source=14.1 
    <para>
     Note that this interpretation of <command>SELECT</command> with <literal>INTO</literal>
     is quite different from <productname>PostgreSQL</productname>'s regular
     <command>SELECT INTO</command> command, wherein the <literal>INTO</literal>
     target is a newly created table.  If you want to create a table from a
     <command>SELECT</command> result inside a
     <application>PL/pgSQL</application> function, use the syntax
     <command>CREATE TABLE ... AS SELECT</command>.
    </para>
________________________________________________________-->
    <para>
     注意带<literal>INTO</literal>的<command>SELECT</command>的这种解释和<productname>PostgreSQL</productname>常规的<command>SELECT INTO</command>命令有很大的不同，后者的<literal>INTO</literal>目标是一个新创建的表。如果你想要在一个<application>PL/pgSQL</application>函数中从一个<command>SELECT</command>的结果创建一个表，请使用语法<command>CREATE TABLE ... AS SELECT</command>。
    </para>
<!-- pgdoc-cn_end sig_en=f6f9b14da4ed3cd1f15f80fd1812d596 -->
   </tip>

<!-- pgdoc-cn_start sig_en=70b58a4df97156e23bd719f12679e9ad sig_cn_org=None source=14.1 
    <para>
     If a row variable or a variable list is used as target,
     the command's result columns
     must exactly match the structure of the target as to number and data
     types, or else a run-time error
     occurs.  When a record variable is the target, it automatically
     configures itself to the row type of the command's result columns.
    </para>
________________________________________________________-->
    <para>
     如果一个行变量或一个变量列表被用作目标，该命令的结果列必须完全匹配该结果的结构，包括数量和数据类型，否则会发生一个运行时错误。当一个记录变量是目标时，它会自动地把自身配置成命令的结果列组成的行类型。
    </para>
<!-- pgdoc-cn_end sig_en=70b58a4df97156e23bd719f12679e9ad -->

<!-- pgdoc-cn_start sig_en=7d3e9fd7b0cd3fc9b4c21d4e18423286 sig_cn_org=None source=14.1 
    <para>
     The <literal>INTO</literal> clause can appear almost anywhere in the SQL
     command.  Customarily it is written either just before or just after
     the list of <replaceable>select_expressions</replaceable> in a
     <command>SELECT</command> command, or at the end of the command for other
     command types.  It is recommended that you follow this convention
     in case the <application>PL/pgSQL</application> parser becomes
     stricter in future versions.
    </para>
________________________________________________________-->
    <para>
     <literal>INTO</literal>子句几乎可以出现在 SQL 命令中的任何位置。通常它被写成刚好在<command>SELECT</command>命令中的<replaceable>select_expressions</replaceable>列表之前或之后，或者在其他命令类型的命令最后。我们推荐你遵循这种惯例，以防<application>PL/pgSQL</application>的解析器在未来的版本中变得更严格。
    </para>
<!-- pgdoc-cn_end sig_en=7d3e9fd7b0cd3fc9b4c21d4e18423286 -->

<!-- pgdoc-cn_start sig_en=a7175ae1e43750f119ddd8714fee4ab4 sig_cn_org=None source=14.1 
    <para>
     If <literal>STRICT</literal> is not specified in the <literal>INTO</literal>
     clause, then <replaceable>target</replaceable> will be set to the first
     row returned by the command, or to nulls if the command returned no rows.
     (Note that <quote>the first row</quote> is not
     well-defined unless you've used <literal>ORDER BY</literal>.)  Any result rows
     after the first row are discarded.
     You can check the special <literal>FOUND</literal> variable (see
     <xref linkend="plpgsql-statements-diagnostics"/>) to
     determine whether a row was returned:

<programlisting>
SELECT * INTO myrec FROM emp WHERE empname = myname;
IF NOT FOUND THEN
    RAISE EXCEPTION 'employee % not found', myname;
END IF;
</programlisting>

     If the <literal>STRICT</literal> option is specified, the command must
     return exactly one row or a run-time error will be reported, either
     <literal>NO_DATA_FOUND</literal> (no rows) or <literal>TOO_MANY_ROWS</literal>
     (more than one row). You can use an exception block if you wish
     to catch the error, for example:

<programlisting>
BEGIN
    SELECT * INTO STRICT myrec FROM emp WHERE empname = myname;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE EXCEPTION 'employee % not found', myname;
        WHEN TOO_MANY_ROWS THEN
            RAISE EXCEPTION 'employee % not unique', myname;
END;
</programlisting>
     Successful execution of a command with <literal>STRICT</literal>
     always sets <literal>FOUND</literal> to true.
    </para>
________________________________________________________-->
    <para>
     如果<literal>STRICT</literal>没有在<literal>INTO</literal>子句中被指定，那么<replaceable>target</replaceable>将被设置为该命令返回的第一个行，或者在该命令不返回行时设置为空（注意除非使用了<literal>ORDER BY</literal>，否则<quote>第一行</quote>的界定并不清楚）。第一行之后的任何结果行都会被抛弃。你可以检查特殊的<literal>FOUND</literal>变量（见<xref linkend="plpgsql-statements-diagnostics"/>）来确定是否返回了一行：

<programlisting>
SELECT * INTO myrec FROM emp WHERE empname = myname;
IF NOT FOUND THEN
    RAISE EXCEPTION 'employee % not found', myname;
END IF;
</programlisting>

     如果指定了<literal>STRICT</literal>选项，该命令必须刚好返回一行或者将会报告一个运行时错误，该错误可能是<literal>NO_DATA_FOUND</literal>（没有行）或<literal>TOO_MANY_ROWS</literal>（多于一行）。如果你希望捕捉该错误，可以使用一个异常块，例如：

<programlisting>
BEGIN
    SELECT * INTO STRICT myrec FROM emp WHERE empname = myname;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE EXCEPTION 'employee % not found', myname;
        WHEN TOO_MANY_ROWS THEN
            RAISE EXCEPTION 'employee % not unique', myname;
END;
</programlisting>
     成功执行一个带<literal>STRICT</literal>的命令总是会将<literal>FOUND</literal>置为真。
    </para>
<!-- pgdoc-cn_end sig_en=a7175ae1e43750f119ddd8714fee4ab4 -->

<!-- pgdoc-cn_start sig_en=7f0a120f50c6350a1813b59757f838c0 sig_cn_org=None source=14.1 
    <para>
     For <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> with
     <literal>RETURNING</literal>, <application>PL/pgSQL</application> reports
     an error for more than one returned row, even when
     <literal>STRICT</literal> is not specified.  This is because there
     is no option such as <literal>ORDER BY</literal> with which to determine
     which affected row should be returned.
    </para>
________________________________________________________-->
    <para>
     对于带有<literal>RETURNING</literal>的<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>，即使没有指定<literal>STRICT</literal>，<application>PL/pgSQL</application>也会针对多于一个返回行的情况报告一个错误。这是因为没有类似于<literal>ORDER BY</literal>的选项可以用来决定应该返回哪个被影响的行。
    </para>
<!-- pgdoc-cn_end sig_en=7f0a120f50c6350a1813b59757f838c0 -->

<!-- pgdoc-cn_start sig_en=f8f73482aeff1f075cfc88a409aaeafd sig_cn_org=None source=14.1 
    <para>
     If <literal>print_strict_params</literal> is enabled for the function,
     then when an error is thrown because the requirements
     of <literal>STRICT</literal> are not met, the <literal>DETAIL</literal> part of
     the error message will include information about the parameters
     passed to the command.
     You can change the <literal>print_strict_params</literal>
     setting for all functions by setting
     <varname>plpgsql.print_strict_params</varname>, though only subsequent
     function compilations will be affected.  You can also enable it
     on a per-function basis by using a compiler option, for example:
<programlisting>
CREATE FUNCTION get_userid(username text) RETURNS int
AS $$
#print_strict_params on
DECLARE
userid int;
BEGIN
    SELECT users.userid INTO STRICT userid
        FROM users WHERE users.username = get_userid.username;
    RETURN userid;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     On failure, this function might produce an error message such as
<programlisting>
ERROR:  query returned no rows
DETAIL:  parameters: $1 = 'nosuchuser'
CONTEXT:  PL/pgSQL function get_userid(text) line 6 at SQL statement
</programlisting>
    </para>
________________________________________________________-->
    <para>
     如果为该函数启用了If <literal>print_strict_params</literal>，那么当因为
     <literal>STRICT</literal>的要求没有被满足而抛出一个错误时，该错误消息
     的<literal>DETAIL</literal>将包括传递给该命令的参数信息。可以通过设置
     <varname>plpgsql.print_strict_params</varname>为所有函数更改
     <literal>print_strict_params</literal>设置，但是只有修改后被编译的函数
     才会生效。也可以使用一个编译器选项来为一个函数启用它，例如：
<programlisting>
CREATE FUNCTION get_userid(username text) RETURNS int
AS $$
#print_strict_params on
DECLARE
userid int;
BEGIN
    SELECT users.userid INTO STRICT userid
        FROM users WHERE users.username = get_userid.username;
    RETURN userid;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     失败时，这个函数会产生一个这样的错误消息
<programlisting>
ERROR:  query returned no rows
DETAIL:  parameters: $1 = 'nosuchuser'
CONTEXT:  PL/pgSQL function get_userid(text) line 6 at SQL statement
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=f8f73482aeff1f075cfc88a409aaeafd -->

    <note>
<!-- pgdoc-cn_start sig_en=6598017e0fc185d41079c1bfcfbbcb57 sig_cn_org=None source=14.1 
     <para>
      The <literal>STRICT</literal> option matches the behavior of
      Oracle PL/SQL's <command>SELECT INTO</command> and related statements.
     </para>
________________________________________________________-->
     <para>
      <literal>STRICT</literal>选项匹配 Oracle PL/SQL 的<command>SELECT INTO</command>和相关语句的行为。
     </para>
<!-- pgdoc-cn_end sig_en=6598017e0fc185d41079c1bfcfbbcb57 -->
    </note>

   </sect2>

   <sect2 id="plpgsql-statements-executing-dyn">
<!-- pgdoc-cn_start sig_en=2927ad32ba2bda0493e70c54af2c27d7 sig_cn_org=None source=14.1 
    <title>Executing Dynamic Commands</title>
________________________________________________________-->
    <title>执行动态命令</title>
<!-- pgdoc-cn_end sig_en=2927ad32ba2bda0493e70c54af2c27d7 -->

<!-- pgdoc-cn_start sig_en=53e7025d2607dfbe0eeaf43fb5e7b530 sig_cn_org=None source=14.1 
    <para>
     Oftentimes you will want to generate dynamic commands inside your
     <application>PL/pgSQL</application> functions, that is, commands
     that will involve different tables or different data types each
     time they are executed.  <application>PL/pgSQL</application>'s
     normal attempts to cache plans for commands (as discussed in
     <xref linkend="plpgsql-plan-caching"/>) will not work in such
     scenarios.  To handle this sort of problem, the
     <command>EXECUTE</command> statement is provided:

<synopsis>
EXECUTE <replaceable class="command">command-string</replaceable> <optional> INTO <optional>STRICT</optional> <replaceable>target</replaceable> </optional> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

     where <replaceable>command-string</replaceable> is an expression
     yielding a string (of type <type>text</type>) containing the
     command to be executed.  The optional <replaceable>target</replaceable>
     is a record variable, a row variable, or a comma-separated list of
     simple variables and record/row fields, into which the results of
     the command will be stored.  The optional <literal>USING</literal> expressions
     supply values to be inserted into the command.
    </para>
________________________________________________________-->
    <para>
     很多时候你将想要在<application>PL/pgSQL</application>函数中产生动态命令，也就是每次执行中会涉及到不同表或不同数据类型的命令。<application>PL/pgSQL</application>通常对于命令所做的缓存计划尝试（如<xref linkend="plpgsql-plan-caching"/>中讨论）在这种情境下无法工作。要处理这一类问题，需要提供<command>EXECUTE</command>语句：

<synopsis>
EXECUTE <replaceable class="command">command-string</replaceable> <optional> INTO <optional>STRICT</optional> <replaceable>target</replaceable> </optional> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

     其中<replaceable>command-string</replaceable>是一个能得到一个包含要被执行命令字符串（类型<type>text</type>）的表达式。可选的<replaceable>target</replaceable>是一个记录变量、一个行变量或者一个逗号分隔的简单变量以及记录/行域的列表，该命令的结果将存储在其中。可选的<literal>USING</literal>表达式提供要被插入到该命令中的值。
    </para>
<!-- pgdoc-cn_end sig_en=53e7025d2607dfbe0eeaf43fb5e7b530 -->

<!-- pgdoc-cn_start sig_en=cacb8a31a784cd973d0ad91d11a15e5a sig_cn_org=None source=14.1 
    <para>
     No substitution of <application>PL/pgSQL</application> variables is done on the
     computed command string.  Any required variable values must be inserted
     in the command string as it is constructed; or you can use parameters
     as described below.
    </para>
________________________________________________________-->
    <para>
     在计算得到的命令字符串中，不会做<application>PL/pgSQL</application>变量的替换。任何所需的变量值必须在命令字符串被构造时被插入其中，或者你可以使用下面描述的参数。
    </para>
<!-- pgdoc-cn_end sig_en=cacb8a31a784cd973d0ad91d11a15e5a -->

<!-- pgdoc-cn_start sig_en=c073f6c72ee2d090953b3897a3bdb7e3 sig_cn_org=None source=14.1 
    <para>
     Also, there is no plan caching for commands executed via
     <command>EXECUTE</command>.  Instead, the command is always planned
     each time the statement is run. Thus the command
     string can be dynamically created within the function to perform
     actions on different tables and columns.
    </para>
________________________________________________________-->
    <para>
     还有，对于通过<command>EXECUTE</command>执行的命令不会有计划被缓存。该命令反而在每次运行时都会被做计划。因此，该命令字符串可以在执行不同表和列上动作的函数中被动态创建。
    </para>
<!-- pgdoc-cn_end sig_en=c073f6c72ee2d090953b3897a3bdb7e3 -->

<!-- pgdoc-cn_start sig_en=8b670091ab541a8060e0303ff3013f5d sig_cn_org=None source=14.1 
    <para>
     The <literal>INTO</literal> clause specifies where the results of
     an SQL command returning rows should be assigned. If a row variable
     or variable list is provided, it must exactly match the structure
     of the command's results; if a
     record variable is provided, it will configure itself to match the
     result structure automatically. If multiple rows are returned,
     only the first will be assigned to the <literal>INTO</literal>
     variable(s). If no rows are returned, NULL is assigned to the
     <literal>INTO</literal> variable(s). If no <literal>INTO</literal>
     clause is specified, the command results are discarded.
    </para>
________________________________________________________-->
    <para>
     <literal>INTO</literal>子句指定一个返回行的 SQL 命令的结果应该被赋值到哪里。如果提供了一个行或变量列表，它必须完全匹配查询命令结果的结构（当一个记录变量被提供时，它会自动把它自己配置为匹配结果结构）。如果返回多个行，只有第一个行会被赋值给<literal>INTO</literal>变量。如果没有返回行，NULL 会被赋值给<literal>INTO</literal>变量。如果没有指定<literal>INTO</literal>变量，该查询结果会被抛弃。
    </para>
<!-- pgdoc-cn_end sig_en=8b670091ab541a8060e0303ff3013f5d -->

<!-- pgdoc-cn_start sig_en=e657ef48e0e5de883a4363188e06f5e1 sig_cn_org=None source=14.1 
    <para>
     If the <literal>STRICT</literal> option is given, an error is reported
     unless the command produces exactly one row.
    </para>
________________________________________________________-->
    <para>
     如果给出了<literal>STRICT</literal>选项，除非该查询刚好产生一行，否则将会报告一个错误。
    </para>
<!-- pgdoc-cn_end sig_en=e657ef48e0e5de883a4363188e06f5e1 -->

<!-- pgdoc-cn_start sig_en=c34aaa73cfade9d885712fdc34d0bc67 sig_cn_org=None source=14.1 
    <para>
     The command string can use parameter values, which are referenced
     in the command as <literal>$1</literal>, <literal>$2</literal>, etc.
     These symbols refer to values supplied in the <literal>USING</literal>
     clause.  This method is often preferable to inserting data values
     into the command string as text: it avoids run-time overhead of
     converting the values to text and back, and it is much less prone
     to SQL-injection attacks since there is no need for quoting or escaping.
     An example is:
<programlisting>
EXECUTE 'SELECT count(*) FROM mytable WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     命令字符串可以使用参数值，它们在命令中用<literal>$1</literal>、<literal>$2</literal>等引用。这些符号引用在<literal>USING</literal>子句中提供的值。这种方法常常更适合于把数据值作为文本插入到命令字符串中：它避免了将该值转换为文本以及转换回来的运行时负荷，并且它更不容易被 SQL 注入攻击，因为不需要引用或转义。一个例子是：
<programlisting>
EXECUTE 'SELECT count(*) FROM mytable WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=c34aaa73cfade9d885712fdc34d0bc67 -->

<!-- pgdoc-cn_start sig_en=8e66916fa73d17b300e41c397a97c899 sig_cn_org=None source=14.1 
    <para>
     Note that parameter symbols can only be used for data values
     &mdash; if you want to use dynamically determined table or column
     names, you must insert them into the command string textually.
     For example, if the preceding query needed to be done against a
     dynamically selected table, you could do this:
<programlisting>
EXECUTE 'SELECT count(*) FROM '
    || quote_ident(tabname)
    || ' WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;
</programlisting>
     A cleaner approach is to use <function>format()</function>'s <literal>%I</literal>
     specification to insert table or column names with automatic quoting:
<programlisting>
EXECUTE format('SELECT count(*) FROM %I '
   'WHERE inserted_by = $1 AND inserted &lt;= $2', tabname)
   INTO c
   USING checked_user, checked_date;
</programlisting>
     (This example relies on the SQL rule that string literals separated by a
     newline are implicitly concatenated.)
    </para>
________________________________________________________-->
    <para>
     需要注意的是，参数符号只能用于数据值 &mdash; 如果想要使用动态决定的表名或列名，你必须将它们以文本形式插入到命令字符串中。例如，如果前面的那个查询需要在一个动态选择的表上执行，你可以这么做：
<programlisting>
EXECUTE 'SELECT count(*) FROM '
    || quote_ident(tabname)
    || ' WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;
</programlisting>
     一种更干净的方法是使用<function>format()</function>的
     <literal>%I</literal>规范，插入自带引号的表名或者列名：
<programlisting>
EXECUTE format('SELECT count(*) FROM %I '
   'WHERE inserted_by = $1 AND inserted &lt;= $2', tabname)
   INTO c
   USING checked_user, checked_date;
</programlisting>
 (此示例依赖于隐式连接由换行符分隔的字符串文字的 SQL 规则)
    </para>
<!-- pgdoc-cn_end sig_en=8e66916fa73d17b300e41c397a97c899 -->

<!-- pgdoc-cn_start sig_en=d8187242f2b1b9b498e30131a005e02b sig_cn_org=4ab86338b358c15b2ca98d04e610de71 source=15.7 
    <para>
     Another restriction on parameter symbols is that they only work in
     optimizable SQL commands
     (<command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command>,
     <command>DELETE</command>, <command>MERGE</command>, and certain commands containing one of these).
     In other statement
     types (generically called utility statements), you must insert
     values textually even if they are just data values.
    </para>
________________________________________________________-->
    <para>
     参数符号的另一个限制是它们仅适用于可优化的SQL命令
     (<command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command>,
     <command>DELETE</command>, <command>MERGE</command>以及包含其中一个的某些命令)。
     在其他语句类型（通称为实用程序语句）中，即使只是数据值，您也必须文本插入值。
    </para>
<!-- pgdoc-cn_end sig_en=d8187242f2b1b9b498e30131a005e02b -->

<!-- pgdoc-cn_start sig_en=3a63405e86b7c874b6ae2d350597c28c sig_cn_org=None source=14.1 
    <para>
     An <command>EXECUTE</command> with a simple constant command string and some
     <literal>USING</literal> parameters, as in the first example above, is
     functionally equivalent to just writing the command directly in
     <application>PL/pgSQL</application> and allowing replacement of
     <application>PL/pgSQL</application> variables to happen automatically.
     The important difference is that <command>EXECUTE</command> will re-plan
     the command on each execution, generating a plan that is specific
     to the current parameter values; whereas
     <application>PL/pgSQL</application> may otherwise create a generic plan
     and cache it for re-use.  In situations where the best plan depends
     strongly on the parameter values, it can be helpful to use
     <command>EXECUTE</command> to positively ensure that a generic plan is not
     selected.
    </para>
________________________________________________________-->
    <para>
     在上面第一个例子中，带有一个简单的常量命令字符串和一些<literal>USING</literal>参数的<command>EXECUTE</command>命令在功能上等效于直接用<application>PL/pgSQL</application>写的命令，并且允许自动发生<application>PL/pgSQL</application>变量替换。重要的不同之处在于，<command>EXECUTE</command>会在每一次执行时根据当前的参数值重新规划该命令，而<application>PL/pgSQL</application>则是创建一个通用计划并且将其缓存以便重用。在最佳计划强依赖于参数值的情况中，使用<command>EXECUTE</command>来明确地保证不会选择一个通用计划是很有帮助的。
    </para>
<!-- pgdoc-cn_end sig_en=3a63405e86b7c874b6ae2d350597c28c -->

<!-- pgdoc-cn_start sig_en=732b548a1ce7d964a3d4165757dd0156 sig_cn_org=None source=14.1 
    <para>
     <command>SELECT INTO</command> is not currently supported within
     <command>EXECUTE</command>; instead, execute a plain <command>SELECT</command>
     command and specify <literal>INTO</literal> as part of the <command>EXECUTE</command>
     itself.
    </para>
________________________________________________________-->
    <para>
     <command>EXECUTE</command>目前不支持<command>SELECT INTO</command>。但是可以执行一个纯的<command>SELECT</command>命令并且指定<literal>INTO</literal>作为<command>EXECUTE</command>本身的一部分。
    </para>
<!-- pgdoc-cn_end sig_en=732b548a1ce7d964a3d4165757dd0156 -->

   <note>
<!-- pgdoc-cn_start sig_en=b38e399fae25bd951a67cdf58ca4b58e sig_cn_org=None source=14.1 
    <para>
     The <application>PL/pgSQL</application>
     <command>EXECUTE</command> statement is not related to the
     <link linkend="sql-execute"><command>EXECUTE</command></link> SQL
     statement supported by the
     <productname>PostgreSQL</productname> server. The server's
     <command>EXECUTE</command> statement cannot be used directly within
     <application>PL/pgSQL</application> functions (and is not needed).
    </para>
________________________________________________________-->
    <para>
     <application>PL/pgSQL</application>中的<command>EXECUTE</command>语句与<link linkend="sql-execute"><command>EXECUTE</command></link> <productname>PostgreSQL</productname>服务器支持的 SQL 语句无关。服务器的<command>EXECUTE</command>语句不能直接在<application>PL/pgSQL</application>函数中使用（并且也没有必要）。
    </para>
<!-- pgdoc-cn_end sig_en=b38e399fae25bd951a67cdf58ca4b58e -->
   </note>

   <example id="plpgsql-quote-literal-example">
<!-- pgdoc-cn_start sig_en=426755da4f1844676b99577d85713334 sig_cn_org=None source=14.1 
   <title>Quoting Values in Dynamic Queries</title>
________________________________________________________-->
   <title>在动态查询中引用值</title>
<!-- pgdoc-cn_end sig_en=426755da4f1844676b99577d85713334 -->

<!-- pgdoc-cn_start sig_en=0400f07511b20c1376bd8081cbfe9209 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>quote_ident</primary>
     <secondary>use in PL/pgSQL</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>quote_ident</primary>
     <secondary>在 PL/pgSQL 中使用</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=0400f07511b20c1376bd8081cbfe9209 -->

<!-- pgdoc-cn_start sig_en=d8b52482ae6db8039aeaf072f72830d5 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>quote_literal</primary>
     <secondary>use in PL/pgSQL</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>quote_literal</primary>
     <secondary>在 PL/pgSQL 中使用</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=d8b52482ae6db8039aeaf072f72830d5 -->

<!-- pgdoc-cn_start sig_en=ebfd4d92fa041141037b5b1ae79d90cc sig_cn_org=None source=14.1 
    <indexterm>
     <primary>quote_nullable</primary>
     <secondary>use in PL/pgSQL</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>quote_nullable</primary>
     <secondary>在 PL/pgSQL 中使用</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=ebfd4d92fa041141037b5b1ae79d90cc -->

<!-- pgdoc-cn_start sig_en=066794917ff1aa895eb6625644fd8723 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>format</primary>
     <secondary>use in PL/pgSQL</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>format</primary>
     <secondary>在 PL/pgSQL 中使用</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=066794917ff1aa895eb6625644fd8723 -->

<!-- pgdoc-cn_start sig_en=35668f02bebeba919245d4cfcaabfe5c sig_cn_org=None source=14.1 
    <para>
     When working with dynamic commands you will often have to handle escaping
     of single quotes.  The recommended method for quoting fixed text in your
     function body is dollar quoting.  (If you have legacy code that does
     not use dollar quoting, please refer to the
     overview in <xref linkend="plpgsql-quote-tips"/>, which can save you
     some effort when translating said code to a more reasonable scheme.)
    </para>
________________________________________________________-->
    <para>
     在使用动态命令时经常不得不处理单引号的转义。我们推荐在函数体中使用美元符号引用来引用固定的文本（如果你有没有使用美元符界定的老代码，请参考<xref linkend="plpgsql-quote-tips"/>中的概述，这样在把上述代码转换成更合理的模式时会省力些）。
    </para>
<!-- pgdoc-cn_end sig_en=35668f02bebeba919245d4cfcaabfe5c -->

<!-- pgdoc-cn_start sig_en=425caced53a54bc7e69588c1fa6994c0 sig_cn_org=None source=14.1 
    <para>
     Dynamic values require careful handling since they might contain
     quote characters.
     An example using <function>format()</function> (this assumes that you are
     dollar quoting the function body so quote marks need not be doubled):
<programlisting>
EXECUTE format('UPDATE tbl SET %I = $1 '
   'WHERE key = $2', colname) USING newvalue, keyvalue;
</programlisting>
     It is also possible to call the quoting functions directly:
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_literal(newvalue)
        || ' WHERE key = '
        || quote_literal(keyvalue);
</programlisting>
    </para>
________________________________________________________-->
    <para>
     动态值需要被小心地处理，因为它们可能包含引号字符。一个使用
     <function>format()</function>的例子（这假设你用美元符号引用了函数
     体，因此引号不需要被双写）：
<programlisting>
EXECUTE format('UPDATE tbl SET %I = $1 '
   'WHERE key = $2', colname) USING newvalue, keyvalue;
</programlisting>
     还可以直接调用引用函数：
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_literal(newvalue)
        || ' WHERE key = '
        || quote_literal(keyvalue);
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=425caced53a54bc7e69588c1fa6994c0 -->

<!-- pgdoc-cn_start sig_en=0b529ad83fe7166ff4b2777de6edae82 sig_cn_org=None source=14.1 
    <para>
     This example demonstrates the use of the
     <function>quote_ident</function> and
     <function>quote_literal</function> functions (see <xref
     linkend="functions-string"/>).  For safety, expressions containing column
     or table identifiers should be passed through
     <function>quote_ident</function> before insertion in a dynamic query.
     Expressions containing values that should be literal strings in the
     constructed command should be passed through <function>quote_literal</function>.
     These functions take the appropriate steps to return the input text
     enclosed in double or single quotes respectively, with any embedded
     special characters properly escaped.
    </para>
________________________________________________________-->
    <para>
     这个例子展示了<function>quote_ident</function>和<function>quote_literal</function>函数的使用（见<xref linkend="functions-string"/>）。为了安全，在进行一个动态查询中的插入之前，包含列或表标识符的表达式应该通过<function>quote_ident</function>被传递。如果表达式包含在被构造出的命令中应该是字符串的值时，它应该通过<function>quote_literal</function>被传递。这些函数采取适当的步骤来分别返回被封闭在双引号或单引号中的文本，其中任何嵌入的特殊字符都会被正确地转义。
    </para>
<!-- pgdoc-cn_end sig_en=0b529ad83fe7166ff4b2777de6edae82 -->

<!-- pgdoc-cn_start sig_en=154c8165a2b75ff0108fb81c348e712a sig_cn_org=None source=14.1 
    <para>
     Because <function>quote_literal</function> is labeled
     <literal>STRICT</literal>, it will always return null when called with a
     null argument.  In the above example, if <literal>newvalue</literal> or
     <literal>keyvalue</literal> were null, the entire dynamic query string would
     become null, leading to an error from <command>EXECUTE</command>.
     You can avoid this problem by using the <function>quote_nullable</function>
     function, which works the same as <function>quote_literal</function> except that
     when called with a null argument it returns the string <literal>NULL</literal>.
     For example,
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_nullable(newvalue)
        || ' WHERE key = '
        || quote_nullable(keyvalue);
</programlisting>
     If you are dealing with values that might be null, you should usually
     use <function>quote_nullable</function> in place of <function>quote_literal</function>.
    </para>
________________________________________________________-->
    <para>
     因为<function>quote_literal</function>被标记为<literal>STRICT</literal>，当用一个空参数调用时，它总是会返回空。在上面的例子中，如果<literal>newvalue</literal>或<literal>keyvalue</literal>为空，整个动态查询字符串会变成空，导致从<command>EXECUTE</command>得到一个错误。可以通过使用<function>quote_nullable</function>函数来避免这种问题，它工作起来和<function>quote_literal</function>相同，除了用空参数调用时会返回一个字符串<literal>NULL</literal>。例如：
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_nullable(newvalue)
        || ' WHERE key = '
        || quote_nullable(keyvalue);
</programlisting>
     如果正在处理的参数值可能为空，那么通常应该用<function>quote_nullable</function>来代替<function>quote_literal</function>。
    </para>
<!-- pgdoc-cn_end sig_en=154c8165a2b75ff0108fb81c348e712a -->

<!-- pgdoc-cn_start sig_en=f52b91013adb5c03a023a90cef1cc184 sig_cn_org=None source=14.1 
    <para>
     As always, care must be taken to ensure that null values in a query do
     not deliver unintended results.  For example the <literal>WHERE</literal> clause
<programlisting>
'WHERE key = ' || quote_nullable(keyvalue)
</programlisting>
     will never succeed if <literal>keyvalue</literal> is null, because the
     result of using the equality operator <literal>=</literal> with a null operand
     is always null.  If you wish null to work like an ordinary key value,
     you would need to rewrite the above as
<programlisting>
'WHERE key IS NOT DISTINCT FROM ' || quote_nullable(keyvalue)
</programlisting>
     (At present, <literal>IS NOT DISTINCT FROM</literal> is handled much less
     efficiently than <literal>=</literal>, so don't do this unless you must.
     See <xref linkend="functions-comparison"/> for
     more information on nulls and <literal>IS DISTINCT</literal>.)
    </para>
________________________________________________________-->
    <para>
     通常，必须小心地确保查询中的空值不会递送意料之外的结果。例如如果<literal>keyvalue</literal>为空，下面的<literal>WHERE</literal>子句
<programlisting>
'WHERE key = ' || quote_nullable(keyvalue)
</programlisting>
     永远不会成功，因为在<literal>=</literal>操作符中使用空操作数得到的结果总是为空。如果想让空和一个普通键值一样工作，你应该将上面的命令重写成
<programlisting>
'WHERE key IS NOT DISTINCT FROM ' || quote_nullable(keyvalue)
</programlisting>
     （目前，<literal>IS NOT DISTINCT FROM</literal>的处理效率不如<literal>=</literal>，因此只有在非常必要时才这样做。关于空和<literal>IS DISTINCT</literal>的详细信息请见<xref linkend="functions-comparison"/>）。
    </para>
<!-- pgdoc-cn_end sig_en=f52b91013adb5c03a023a90cef1cc184 -->

<!-- pgdoc-cn_start sig_en=5ec4faf0f48fd2712835bac2a8960293 sig_cn_org=None source=14.1 
    <para>
     Note that dollar quoting is only useful for quoting fixed text.
     It would be a very bad idea to try to write this example as:
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = $$'
        || newvalue
        || '$$ WHERE key = '
        || quote_literal(keyvalue);
</programlisting>
     because it would break if the contents of <literal>newvalue</literal>
     happened to contain <literal>$$</literal>.  The same objection would
     apply to any other dollar-quoting delimiter you might pick.
     So, to safely quote text that is not known in advance, you
     <emphasis>must</emphasis> use <function>quote_literal</function>,
     <function>quote_nullable</function>, or <function>quote_ident</function>, as appropriate.
    </para>
________________________________________________________-->
    <para>
     请注意美元符号引用只对引用固定文本有用。尝试写出下面这个例子是一个非常糟糕的主意：
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = $$'
        || newvalue
        || '$$ WHERE key = '
        || quote_literal(keyvalue);
</programlisting>
     因为如果<literal>newvalue</literal>的内容碰巧含有<literal>$$</literal>，那么这段代码就会出问题。同样的缺点可能适用于你选择的任何其他美元符号引用定界符。因此，要想安全地引用事先不知道的文本，<emphasis>必须</emphasis>恰当地使用<function>quote_literal</function>、<function>quote_nullable</function>或<function>quote_ident</function>。
    </para>
<!-- pgdoc-cn_end sig_en=5ec4faf0f48fd2712835bac2a8960293 -->

<!-- pgdoc-cn_start sig_en=df920b2a3da141b5e796a687b222b6f5 sig_cn_org=None source=14.1 
    <para>
     Dynamic SQL statements can also be safely constructed using the
     <function>format</function> function (see <xref
     linkend="functions-string-format"/>). For example:
<programlisting>
EXECUTE format('UPDATE tbl SET %I = %L '
   'WHERE key = %L', colname, newvalue, keyvalue);
</programlisting>
     <literal>%I</literal> is equivalent to <function>quote_ident</function>, and
     <literal>%L</literal> is equivalent to <function>quote_nullable</function>.
     The <function>format</function> function can be used in conjunction with
     the <literal>USING</literal> clause:
<programlisting>
EXECUTE format('UPDATE tbl SET %I = $1 WHERE key = $2', colname)
   USING newvalue, keyvalue;
</programlisting>
     This form is better because the variables are handled in their native
     data type format, rather than unconditionally converting them to
     text and quoting them via <literal>%L</literal>.  It is also more efficient.
    </para>
________________________________________________________-->
    <para>
     动态 SQL 语句也可以使用<function>format</function>（见<xref linkend="functions-string-format"/>）函数来安全地构造。例如：
<programlisting>
EXECUTE format('UPDATE tbl SET %I = %L '
   'WHERE key = %L', colname, newvalue, keyvalue);
</programlisting>
     <literal>%I</literal>等效于<function>quote_ident</function>并且
     <literal>%L</literal>等效于<function>quote_nullable</function>。
     <function>format</function>函数可以和
     <literal>USING</literal>子句一起使用：
<programlisting>
EXECUTE format('UPDATE tbl SET %I = $1 WHERE key = $2', colname)
   USING newvalue, keyvalue;
</programlisting>
     这种形式更好，因为变量被以它们天然的数据类型格式处理，而不是无
     条件地把它们转换成文本并且通过<literal>%L</literal>引用它们。这也效率
     更高。
    </para>
<!-- pgdoc-cn_end sig_en=df920b2a3da141b5e796a687b222b6f5 -->
   </example>

<!-- pgdoc-cn_start sig_en=df08be278f443cd1c3edc17c4b53afea sig_cn_org=None source=14.1 
    <para>
     A much larger example of a dynamic command and
     <command>EXECUTE</command> can be seen in <xref
     linkend="plpgsql-porting-ex2"/>, which builds and executes a
     <command>CREATE FUNCTION</command> command to define a new function.
    </para>
________________________________________________________-->
    <para>
     动态命令和<command>EXECUTE</command>的一个更大的例子可以在<xref linkend="plpgsql-porting-ex2"/>中找到，它会构建并且执行一个<command>CREATE FUNCTION</command>命令来定义一个新的函数。
    </para>
<!-- pgdoc-cn_end sig_en=df08be278f443cd1c3edc17c4b53afea -->
   </sect2>

   <sect2 id="plpgsql-statements-diagnostics">
<!-- pgdoc-cn_start sig_en=d04d16c2f0d723e12b418abe1b3eef0f sig_cn_org=None source=14.1 
    <title>Obtaining the Result Status</title>
________________________________________________________-->
    <title>获得结果状态</title>
<!-- pgdoc-cn_end sig_en=d04d16c2f0d723e12b418abe1b3eef0f -->

<!-- pgdoc-cn_start sig_en=415153169bdde8bed136fb0a97198de6 sig_cn_org=None source=14.1 
    <para>
     There are several ways to determine the effect of a command. The
     first method is to use the <command>GET DIAGNOSTICS</command>
     command, which has the form:

<synopsis>
GET <optional> CURRENT </optional> DIAGNOSTICS <replaceable>variable</replaceable> { = | := } <replaceable>item</replaceable> <optional> , ... </optional>;
</synopsis>

     This command allows retrieval of system status indicators.
     <literal>CURRENT</literal> is a noise word (but see also <command>GET STACKED
     DIAGNOSTICS</command> in <xref linkend="plpgsql-exception-diagnostics"/>).
     Each <replaceable>item</replaceable> is a key word identifying a status
     value to be assigned to the specified <replaceable>variable</replaceable>
     (which should be of the right data type to receive it).  The currently
     available status items are shown
     in <xref linkend="plpgsql-current-diagnostics-values"/>.  Colon-equal
     (<literal>:=</literal>) can be used instead of the SQL-standard <literal>=</literal>
     token.  An example:
<programlisting>
GET DIAGNOSTICS integer_var = ROW_COUNT;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     有好几种方法可以判断一条命令的效果。第一种方法是使用<command>GET DIAGNOSTICS</command>命令，其形式如下：

<synopsis>
GET <optional> CURRENT </optional> DIAGNOSTICS <replaceable>variable</replaceable> { = | := } <replaceable>item</replaceable> <optional> , ... </optional>;
</synopsis>

     这条命令允许检索系统状态指示符。<literal>CURRENT</literal>是一个噪声词（另见<xref linkend="plpgsql-exception-diagnostics"/>中的<command>GET STACKED DIAGNOSTICS</command>）。每个<replaceable>item</replaceable>是一个关键字， 它标识一个要被赋予给指定<replaceable>变量</replaceable>的状态值（变量应具有正确的数据类型来接收状态值）。<xref linkend="plpgsql-current-diagnostics-values"/>中展示了当前可用的状态项。冒号等号（<literal>:=</literal>）可以被用来取代 SQL 标准的<literal>=</literal>符号。例如：
<programlisting>
GET DIAGNOSTICS integer_var = ROW_COUNT;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=415153169bdde8bed136fb0a97198de6 -->

     <table id="plpgsql-current-diagnostics-values">
<!-- pgdoc-cn_start sig_en=1ced0922c484f2f302e45575c1654852 sig_cn_org=None source=14.1 
      <title>Available Diagnostics Items</title>
________________________________________________________-->
      <title>可用的诊断项</title>
<!-- pgdoc-cn_end sig_en=1ced0922c484f2f302e45575c1654852 -->
      <tgroup cols="3">
       <colspec colname="col1" colwidth="1*"/>
       <colspec colname="col2" colwidth="1*"/>
       <colspec colname="col3" colwidth="2*"/>
       <thead>
<!-- pgdoc-cn_start sig_en=4b45428ed041b842ea82bb4c6f3a0da5 sig_cn_org=None source=14.1 
        <row>
         <entry>Name</entry>
         <entry>Type</entry>
         <entry>Description</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>名称</entry>
         <entry>类型</entry>
         <entry>描述</entry>
        </row>
<!-- pgdoc-cn_end sig_en=4b45428ed041b842ea82bb4c6f3a0da5 -->
       </thead>
       <tbody>
<!-- pgdoc-cn_start sig_en=9a411f6572c509acb64150c9f8a24ce9 sig_cn_org=None source=14.1 
        <row>
         <entry><varname>ROW_COUNT</varname></entry>
         <entry><type>bigint</type></entry>
         <entry>the number of rows processed by the most
          recent <acronym>SQL</acronym> command</entry>
        </row>
________________________________________________________-->
        <row>
         <entry><varname>ROW_COUNT</varname></entry>
         <entry><type>bigint</type></entry>
         <entry>最近的<acronym>SQL</acronym>命令处理的行数</entry>
        </row>
<!-- pgdoc-cn_end sig_en=9a411f6572c509acb64150c9f8a24ce9 -->
<!-- pgdoc-cn_start sig_en=f3fe64d676e997669c129ccc639550d6 sig_cn_org=None source=14.1 
        <row>
         <entry><literal>PG_CONTEXT</literal></entry>
         <entry><type>text</type></entry>
         <entry>line(s) of text describing the current call stack
          (see <xref linkend="plpgsql-call-stack"/>)</entry>
        </row>
________________________________________________________-->
        <row>
         <entry><literal>PG_CONTEXT</literal></entry>
         <entry><type>text</type></entry>
         <entry>描述当前调用栈的文本行（见<xref linkend="plpgsql-call-stack"/>）</entry>
        </row>
<!-- pgdoc-cn_end sig_en=f3fe64d676e997669c129ccc639550d6 -->
       </tbody>
      </tgroup>
     </table>

<!-- pgdoc-cn_start sig_en=c8fa5d8a1f889f6a4a36600b4bf0d151 sig_cn_org=7573c47a6e7838adc4908dd0f28aa61a source=15.7 
    <para>
     The second method to determine the effects of a command is to check the
     special variable named <literal>FOUND</literal>, which is of
     type <type>boolean</type>.  <literal>FOUND</literal> starts out
     false within each <application>PL/pgSQL</application> function call.
     It is set by each of the following types of statements:

         <itemizedlist>
          <listitem>
           <para>
            A <command>SELECT INTO</command> statement sets
            <literal>FOUND</literal> true if a row is assigned, false if no
            row is returned.
           </para>
          </listitem>
          <listitem>
           <para>
            A <command>PERFORM</command> statement sets <literal>FOUND</literal>
            true if it produces (and discards) one or more rows, false if
            no row is produced.
           </para>
          </listitem>
          <listitem>
           <para>
            <command>UPDATE</command>, <command>INSERT</command>, <command>DELETE</command>,
            and <command>MERGE</command>
            statements set <literal>FOUND</literal> true if at least one
            row is affected, false if no row is affected.
           </para>
          </listitem>
          <listitem>
           <para>
            A <command>FETCH</command> statement sets <literal>FOUND</literal>
            true if it returns a row, false if no row is returned.
           </para>
          </listitem>
          <listitem>
           <para>
            A <command>MOVE</command> statement sets <literal>FOUND</literal>
            true if it successfully repositions the cursor, false otherwise.
           </para>
          </listitem>
          <listitem>
           <para>
            A <command>FOR</command> or <command>FOREACH</command> statement sets
            <literal>FOUND</literal> true
            if it iterates one or more times, else false.
            <literal>FOUND</literal> is set this way when the
            loop exits; inside the execution of the loop,
            <literal>FOUND</literal> is not modified by the
            loop statement, although it might be changed by the
            execution of other statements within the loop body.
           </para>
          </listitem>
          <listitem>
           <para>
            <command>RETURN QUERY</command> and <command>RETURN QUERY
            EXECUTE</command> statements set <literal>FOUND</literal>
            true if the query returns at least one row, false if no row
            is returned.
           </para>
          </listitem>
         </itemizedlist>

     Other <application>PL/pgSQL</application> statements do not change
     the state of <literal>FOUND</literal>.
     Note in particular that <command>EXECUTE</command>
     changes the output of <command>GET DIAGNOSTICS</command>, but
     does not change <literal>FOUND</literal>.
    </para>
________________________________________________________-->
    <para>
     第二种确定命令效果的方法是检查名为<literal>FOUND</literal>的特殊变量，类型为<type>boolean</type>。
     在每次<application>PL/pgSQL</application>函数调用中，<literal>FOUND</literal>初始值为false。
     它由以下类型的语句设置：

         <itemizedlist>
          <listitem>
           <para>
            <command>SELECT INTO</command>语句在分配行时将<literal>FOUND</literal>设置为true，
            如果没有返回行则设置为false。
           </para>
          </listitem>
          <listitem>
           <para>
            <command>PERFORM</command>语句在生成（和丢弃）一个或多个行时将<literal>FOUND</literal>设置为true，
            如果没有生成行则设置为false。
           </para>
          </listitem>
          <listitem>
           <para>
            <command>UPDATE</command>、<command>INSERT</command>、<command>DELETE</command>和<command>MERGE</command>
            语句在至少影响一行时将<literal>FOUND</literal>设置为true，如果没有影响行则设置为false。
           </para>
          </listitem>
          <listitem>
           <para>
            <command>FETCH</command>语句在返回行时将<literal>FOUND</literal>设置为true，
            如果没有返回行则设置为false。
           </para>
          </listitem>
          <listitem>
           <para>
            <command>MOVE</command>语句在成功重新定位游标时将<literal>FOUND</literal>设置为true，
            否则设置为false。
           </para>
          </listitem>
          <listitem>
           <para>
            <command>FOR</command>或<command>FOREACH</command>语句在迭代一次或多次时将
            <literal>FOUND</literal>设置为true，否则设置为false。
            当循环退出时，<literal>FOUND</literal>被设置为这种方式；
            在循环执行过程中，<literal>FOUND</literal>不会被循环语句修改，
            尽管它可能会被循环体内的其他语句执行修改。
           </para>
          </listitem>
          <listitem>
           <para>
            <command>RETURN QUERY</command>和<command>RETURN QUERY
            EXECUTE</command>语句在查询返回至少一行时将<literal>FOUND</literal>设置为true，
            如果没有返回行则设置为false。
           </para>
          </listitem>
         </itemizedlist>

     其他<application>PL/pgSQL</application>语句不会改变<literal>FOUND</literal>的状态。
     特别注意，<command>EXECUTE</command>会改变<command>GET DIAGNOSTICS</command>的输出，
     但不会改变<literal>FOUND</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=c8fa5d8a1f889f6a4a36600b4bf0d151 -->

<!-- pgdoc-cn_start sig_en=32ffe58daad79dc885a0c475293e13df sig_cn_org=None source=14.1 
    <para>
     <literal>FOUND</literal> is a local variable within each
     <application>PL/pgSQL</application> function; any changes to it
     affect only the current function.
    </para>
________________________________________________________-->
    <para>
     <literal>FOUND</literal>是每个<application>PL/pgSQL</application>函数的局部变量；任何对它的修改只影响当前的函数。
    </para>
<!-- pgdoc-cn_end sig_en=32ffe58daad79dc885a0c475293e13df -->

   </sect2>

   <sect2 id="plpgsql-statements-null">
<!-- pgdoc-cn_start sig_en=53d7ace71a7b74b4002d2bf7fd514bcf sig_cn_org=None source=14.1 
    <title>Doing Nothing At All</title>
________________________________________________________-->
    <title>什么也不做</title>
<!-- pgdoc-cn_end sig_en=53d7ace71a7b74b4002d2bf7fd514bcf -->

<!-- pgdoc-cn_start sig_en=3da98da9e01ed822acda0e7ad23ea3ef sig_cn_org=None source=14.1 
    <para>
     Sometimes a placeholder statement that does nothing is useful.
     For example, it can indicate that one arm of an if/then/else
     chain is deliberately empty.  For this purpose, use the
     <command>NULL</command> statement:

<synopsis>
NULL;
</synopsis>
    </para>
________________________________________________________-->
    <para>
     有时一个什么也不做的占位语句也很有用。例如，它能够指示 if/then/else 链中故意留出的空分支。可以使用<command>NULL</command>语句达到这个目的：

<synopsis>
NULL;
</synopsis>
    </para>
<!-- pgdoc-cn_end sig_en=3da98da9e01ed822acda0e7ad23ea3ef -->

<!-- pgdoc-cn_start sig_en=adeaf98b06a1c69996ff3ace9c1ce8ce sig_cn_org=None source=14.1 
    <para>
     For example, the following two fragments of code are equivalent:
<programlisting>
BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        NULL;  -&minus; ignore the error
END;
</programlisting>

<programlisting>
BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN  -&minus; ignore the error
END;
</programlisting>
     Which is preferable is a matter of taste.
    </para>
________________________________________________________-->
    <para>
     例如，下面的两段代码是等价的：
<programlisting>
BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        NULL;  -- 忽略错误
END;
</programlisting>

<programlisting>
BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN  -- 忽略错误
END;
</programlisting>
     究竟使用哪一种取决于各人的喜好。
    </para>
<!-- pgdoc-cn_end sig_en=adeaf98b06a1c69996ff3ace9c1ce8ce -->

    <note>
<!-- pgdoc-cn_start sig_en=4084f0853f6afb33b411d8f181966d8b sig_cn_org=None source=14.1 
     <para>
      In Oracle's PL/SQL, empty statement lists are not allowed, and so
      <command>NULL</command> statements are <emphasis>required</emphasis> for situations
      such as this.  <application>PL/pgSQL</application> allows you to
      just write nothing, instead.
     </para>
________________________________________________________-->
     <para>
      在 Oracle 的 PL/SQL 中，不允许出现空语句列表，并且因此在这种情况下<emphasis>必须</emphasis>使用<command>NULL</command>语句。而<application>PL/pgSQL</application>允许你什么也不写。
     </para>
<!-- pgdoc-cn_end sig_en=4084f0853f6afb33b411d8f181966d8b -->
    </note>

   </sect2>
  </sect1>

  <sect1 id="plpgsql-control-structures">
<!-- pgdoc-cn_start sig_en=bc9c21d4fa24484208d444fc8c37d425 sig_cn_org=None source=14.1 
   <title>Control Structures</title>
________________________________________________________-->
   <title>控制结构</title>
<!-- pgdoc-cn_end sig_en=bc9c21d4fa24484208d444fc8c37d425 -->

<!-- pgdoc-cn_start sig_en=21ae949e44314ff4fa91210c320c86ed sig_cn_org=None source=14.1 
   <para>
    Control structures are probably the most useful (and
    important) part of <application>PL/pgSQL</application>. With
    <application>PL/pgSQL</application>'s control structures,
    you can manipulate <productname>PostgreSQL</productname> data in a very
    flexible and powerful way.
   </para>
________________________________________________________-->
   <para>
    控制结构可能是<application>PL/pgSQL</application>中最有用的（以及最重要）的部分了。利用<application>PL/pgSQL</application>的控制结构，你可以以非常灵活而且强大的方法操纵<productname>PostgreSQL</productname>的数据。
   </para>
<!-- pgdoc-cn_end sig_en=21ae949e44314ff4fa91210c320c86ed -->

   <sect2 id="plpgsql-statements-returning">
<!-- pgdoc-cn_start sig_en=b4caad16bc40a7eea76e07371058c0a2 sig_cn_org=None source=14.1 
    <title>Returning from a Function</title>
________________________________________________________-->
    <title>从一个函数返回</title>
<!-- pgdoc-cn_end sig_en=b4caad16bc40a7eea76e07371058c0a2 -->

<!-- pgdoc-cn_start sig_en=387539886128a9603c775b4c49117c3f sig_cn_org=None source=14.1 
    <para>
     There are two commands available that allow you to return data
     from a function: <command>RETURN</command> and <command>RETURN
     NEXT</command>.
    </para>
________________________________________________________-->
    <para>
     有两个命令让我们能够从函数中返回数据：<command>RETURN</command>和<command>RETURN NEXT</command>。
    </para>
<!-- pgdoc-cn_end sig_en=387539886128a9603c775b4c49117c3f -->

    <sect3>
     <title><command>RETURN</command></title>

<!-- pgdoc-cn_start sig_en=efe9240142d3dea0a9ecaff94cbc3402 sig_cn_org=None source=14.1 
<synopsis>
RETURN <replaceable>expression</replaceable>;
</synopsis>
________________________________________________________-->
<synopsis>
RETURN <replaceable>expression</replaceable>;
</synopsis>
<!-- pgdoc-cn_end sig_en=efe9240142d3dea0a9ecaff94cbc3402 -->

<!-- pgdoc-cn_start sig_en=65f5bcfa18fc9f9f6e18a939af48cc8c sig_cn_org=None source=14.1 
     <para>
      <command>RETURN</command> with an expression terminates the
      function and returns the value of
      <replaceable>expression</replaceable> to the caller.  This form
      is used for <application>PL/pgSQL</application> functions that do
      not return a set.
     </para>
________________________________________________________-->
     <para>
      带有一个表达式的<command>RETURN</command>用于终止函数并把<replaceable>expression</replaceable>的值返回给调用者。这种形式被用于不返回集合的<application>PL/pgSQL</application>函数。
     </para>
<!-- pgdoc-cn_end sig_en=65f5bcfa18fc9f9f6e18a939af48cc8c -->

<!-- pgdoc-cn_start sig_en=bd4db3939b43c5e7bcac50408bdb61f7 sig_cn_org=None source=14.1 
     <para>
      In a function that returns a scalar type, the expression's result will
      automatically be cast into the function's return type as described for
      assignments.  But to return a composite (row) value, you must write an
      expression delivering exactly the requested column set.  This may
      require use of explicit casting.
     </para>
________________________________________________________-->
     <para>
      如果一个函数返回一个标量类型，表达式的结果将被自动转换成函数的返回类型。但是要返回一个复合（行）值，你必须写一个正好产生所需列集合的表达式。这可能需要使用显式造型。
     </para>
<!-- pgdoc-cn_end sig_en=bd4db3939b43c5e7bcac50408bdb61f7 -->

<!-- pgdoc-cn_start sig_en=214887f2b80840b142cf7d43391230ed sig_cn_org=None source=14.1 
     <para>
      If you declared the function with output parameters, write just
      <command>RETURN</command> with no expression.  The current values
      of the output parameter variables will be returned.
     </para>
________________________________________________________-->
     <para>
      如果你声明带输出参数的函数，那么就只需要写不带表达式的<command>RETURN</command>。输出参数变量的当前值将被返回。
     </para>
<!-- pgdoc-cn_end sig_en=214887f2b80840b142cf7d43391230ed -->

<!-- pgdoc-cn_start sig_en=75465d10f700efe0801c3155e1cccde6 sig_cn_org=None source=14.1 
     <para>
      If you declared the function to return <type>void</type>, a
      <command>RETURN</command> statement can be used to exit the function
      early; but do not write an expression following
      <command>RETURN</command>.
     </para>
________________________________________________________-->
     <para>
      如果你声明函数返回<type>void</type>，一个<command>RETURN</command>语句可以被用来提前退出函数；但是不要在<command>RETURN</command>后面写一个表达式。
     </para>
<!-- pgdoc-cn_end sig_en=75465d10f700efe0801c3155e1cccde6 -->

<!-- pgdoc-cn_start sig_en=87c4e713403235759bf9c683fff2b758 sig_cn_org=None source=14.1 
     <para>
      The return value of a function cannot be left undefined. If
      control reaches the end of the top-level block of the function
      without hitting a <command>RETURN</command> statement, a run-time
      error will occur.  This restriction does not apply to functions
      with output parameters and functions returning <type>void</type>,
      however.  In those cases a <command>RETURN</command> statement is
      automatically executed if the top-level block finishes.
     </para>
________________________________________________________-->
     <para>
      一个函数的返回值不能是未定义。如果控制到达了函数最顶层的块而没有碰到一个<command>RETURN</command>语句，那么会发生一个运行时错误。不过，这个限制不适用于带输出参数的函数以及返回<type>void</type>的函数。在这些情况中，如果顶层的块结束，将自动执行一个<command>RETURN</command>语句。
     </para>
<!-- pgdoc-cn_end sig_en=87c4e713403235759bf9c683fff2b758 -->

<!-- pgdoc-cn_start sig_en=c6041b2b02f928e98f4ab0b373863ced sig_cn_org=None source=14.1 
     <para>
      Some examples:

<programlisting>
-&minus; functions returning a scalar type
RETURN 1 + 2;
RETURN scalar_var;

-&minus; functions returning a composite type
RETURN composite_type_var;
RETURN (1, 2, 'three'::text);  -&minus; must cast columns to correct types
</programlisting>
     </para>
________________________________________________________-->
     <para>
      一些例子：

<programlisting>
-- 返回一个标量类型的函数
RETURN 1 + 2;
RETURN scalar_var;

-- 返回一个组合类型的函数
RETURN composite_type_var;
RETURN (1, 2, 'three'::text);  -- 必须把列造型成正确的类型
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=c6041b2b02f928e98f4ab0b373863ced -->
    </sect3>

    <sect3>
<!-- pgdoc-cn_start sig_en=72d6e68823a9500149aeeb1fafb58d99 sig_cn_org=None source=14.1 
     <title><command>RETURN NEXT</command> and <command>RETURN QUERY</command></title>
________________________________________________________-->
     <title><command>RETURN NEXT</command>以及<command>RETURN QUERY</command></title>
<!-- pgdoc-cn_end sig_en=72d6e68823a9500149aeeb1fafb58d99 -->
<!-- pgdoc-cn_start sig_en=32444b8a2e73f8f72ace2024ba493ed7 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>RETURN NEXT</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>RETURN NEXT</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=32444b8a2e73f8f72ace2024ba493ed7 -->
<!-- pgdoc-cn_start sig_en=4d5d25a4ed64c98536920315a1630f70 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>RETURN QUERY</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>RETURN QUERY</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=4d5d25a4ed64c98536920315a1630f70 -->

<!-- pgdoc-cn_start sig_en=83973f06b7ed3ceba8f6295bc96c36de sig_cn_org=None source=14.1 
<synopsis>
RETURN NEXT <replaceable>expression</replaceable>;
RETURN QUERY <replaceable>query</replaceable>;
RETURN QUERY EXECUTE <replaceable class="command">command-string</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>
________________________________________________________-->
<synopsis>
RETURN NEXT <replaceable>expression</replaceable>;
RETURN QUERY <replaceable>query</replaceable>;
RETURN QUERY EXECUTE <replaceable class="command">command-string</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>
<!-- pgdoc-cn_end sig_en=83973f06b7ed3ceba8f6295bc96c36de -->

<!-- pgdoc-cn_start sig_en=a58d104b05d269a739856d0c947f7d23 sig_cn_org=None source=14.1 
     <para>
      When a <application>PL/pgSQL</application> function is declared to return
      <literal>SETOF <replaceable>sometype</replaceable></literal>, the procedure
      to follow is slightly different.  In that case, the individual
      items to return are specified by a sequence of <command>RETURN
      NEXT</command> or <command>RETURN QUERY</command> commands, and
      then a final <command>RETURN</command> command with no argument
      is used to indicate that the function has finished executing.
      <command>RETURN NEXT</command> can be used with both scalar and
      composite data types; with a composite result type, an entire
      <quote>table</quote> of results will be returned.
      <command>RETURN QUERY</command> appends the results of executing
      a query to the function's result set. <command>RETURN
      NEXT</command> and <command>RETURN QUERY</command> can be freely
      intermixed in a single set-returning function, in which case
      their results will be concatenated.
     </para>
________________________________________________________-->
     <para>
      当一个<application>PL/pgSQL</application>函数被声明为返回<literal>SETOF <replaceable>sometype</replaceable></literal>，那么遵循的过程则略有不同。在这种情况下，要返回的个体项被用一个<command>RETURN NEXT</command>或者<command>RETURN QUERY</command>命令的序列指定，并且接着会用一个不带参数的最终<command>RETURN</command>命令来指示这个函数已经完成执行。<command>RETURN NEXT</command>可以被用于标量和复合数据类型；对于复合类型，将返回一个完整的结果<quote>表</quote>。<command>RETURN QUERY</command>将执行一个查询的结果追加到一个函数的结果集中。在一个单一的返回集合的函数中，<command>RETURN NEXT</command>和<command>RETURN QUERY</command>可以被随意地混合，这样它们的结果将被串接起来。
     </para>
<!-- pgdoc-cn_end sig_en=a58d104b05d269a739856d0c947f7d23 -->

<!-- pgdoc-cn_start sig_en=6bc71a62e24ba03dfbf03a4b82b3f2a2 sig_cn_org=None source=14.1 
     <para>
      <command>RETURN NEXT</command> and <command>RETURN
      QUERY</command> do not actually return from the function &mdash;
      they simply append zero or more rows to the function's result
      set.  Execution then continues with the next statement in the
      <application>PL/pgSQL</application> function.  As successive
      <command>RETURN NEXT</command> or <command>RETURN
      QUERY</command> commands are executed, the result set is built
      up.  A final <command>RETURN</command>, which should have no
      argument, causes control to exit the function (or you can just
      let control reach the end of the function).
     </para>
________________________________________________________-->
     <para>
      <command>RETURN NEXT</command>和<command>RETURN QUERY</command>实际上不会从函数中返回 &mdash; 它们简单地向函数的结果集中追加零或多行。然后会继续执行<application>PL/pgSQL</application>函数中的下一条语句。随着后继的<command>RETURN NEXT</command>和<command>RETURN QUERY</command>命令的执行，结果集就建立起来了。最后一个<command>RETURN</command>（应该没有参数）会导致控制退出该函数（或者你可以让控制到达函数的结尾）。
     </para>
<!-- pgdoc-cn_end sig_en=6bc71a62e24ba03dfbf03a4b82b3f2a2 -->

<!-- pgdoc-cn_start sig_en=1816841f3352da77db79f51ba82da627 sig_cn_org=None source=14.1 
     <para>
      <command>RETURN QUERY</command> has a variant
      <command>RETURN QUERY EXECUTE</command>, which specifies the
      query to be executed dynamically.  Parameter expressions can
      be inserted into the computed query string via <literal>USING</literal>,
      in just the same way as in the <command>EXECUTE</command> command.
     </para>
________________________________________________________-->
     <para>
      <command>RETURN QUERY</command>有一种变体<command>RETURN QUERY EXECUTE</command>，它可以动态指定要被执行的查询。可以通过<literal>USING</literal>向计算出的查询字符串插入参数表达式，这和在<command>EXECUTE</command>命令中的方式相同。
     </para>
<!-- pgdoc-cn_end sig_en=1816841f3352da77db79f51ba82da627 -->

<!-- pgdoc-cn_start sig_en=cb520bb79a693838c10992c1b2587114 sig_cn_org=None source=14.1 
     <para>
      If you declared the function with output parameters, write just
      <command>RETURN NEXT</command> with no expression.  On each
      execution, the current values of the output parameter
      variable(s) will be saved for eventual return as a row of the
      result.  Note that you must declare the function as returning
      <literal>SETOF record</literal> when there are multiple output
      parameters, or <literal>SETOF <replaceable>sometype</replaceable></literal>
      when there is just one output parameter of type
      <replaceable>sometype</replaceable>, in order to create a set-returning
      function with output parameters.
     </para>
________________________________________________________-->
     <para>
      如果你声明函数带有输出参数，只需要写不带表达式的<command>RETURN NEXT</command>。在每一次执行时，输出参数变量的当前值将被保存下来用于最终返回为结果的一行。注意为了创建一个带有输出参数的集合返回函数，在有多个输出参数时，你必须声明函数为返回<literal>SETOF record</literal>；或者如果只有一个类型为<replaceable>sometype</replaceable>的输出参数时，声明函数为<literal>SETOF <replaceable>sometype</replaceable></literal>。
     </para>
<!-- pgdoc-cn_end sig_en=cb520bb79a693838c10992c1b2587114 -->

<!-- pgdoc-cn_start sig_en=0c2791e59b091c6831120101ea7ff08b sig_cn_org=None source=14.1 
     <para>
      Here is an example of a function using <command>RETURN
      NEXT</command>:

<programlisting>
CREATE TABLE foo (fooid INT, foosubid INT, fooname TEXT);
INSERT INTO foo VALUES (1, 2, 'three');
INSERT INTO foo VALUES (4, 5, 'six');

CREATE OR REPLACE FUNCTION get_all_foo() RETURNS SETOF foo AS
$BODY$
DECLARE
    r foo%rowtype;
BEGIN
    FOR r IN
        SELECT * FROM foo WHERE fooid &gt; 0
    LOOP
        -&minus; can do some processing here
        RETURN NEXT r; -&minus; return current row of SELECT
    END LOOP;
    RETURN;
END;
$BODY$
LANGUAGE plpgsql;

SELECT * FROM get_all_foo();
</programlisting>
     </para>
________________________________________________________-->
     <para>
      下面是一个使用<command>RETURN NEXT</command>的函数例子：

<programlisting>
CREATE TABLE foo (fooid INT, foosubid INT, fooname TEXT);
INSERT INTO foo VALUES (1, 2, 'three');
INSERT INTO foo VALUES (4, 5, 'six');

CREATE OR REPLACE FUNCTION get_all_foo() RETURNS SETOF foo AS
$BODY$
DECLARE
    r foo%rowtype;
BEGIN
    FOR r IN
        SELECT * FROM foo WHERE fooid &gt; 0
    LOOP
        -- 这里可以做一些处理
        RETURN NEXT r; -- 返回 SELECT 的当前行
    END LOOP;
    RETURN;
END;
$BODY$
LANGUAGE plpgsql;

SELECT * FROM get_all_foo();
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=0c2791e59b091c6831120101ea7ff08b -->

<!-- pgdoc-cn_start sig_en=235b8e238352538404f84f89d55ffc34 sig_cn_org=None source=14.1 
     <para>
      Here is an example of a function using <command>RETURN
      QUERY</command>:

<programlisting>
CREATE FUNCTION get_available_flightid(date) RETURNS SETOF integer AS
$BODY$
BEGIN
    RETURN QUERY SELECT flightid
                   FROM flight
                  WHERE flightdate &gt;= $1
                    AND flightdate &lt; ($1 + 1);

    -&minus; Since execution is not finished, we can check whether rows were returned
    -&minus; and raise exception if not.
    IF NOT FOUND THEN
        RAISE EXCEPTION 'No flight at %.', $1;
    END IF;

    RETURN;
 END;
$BODY$
LANGUAGE plpgsql;

-&minus; Returns available flights or raises exception if there are no
-&minus; available flights.
SELECT * FROM get_available_flightid(CURRENT_DATE);
</programlisting>
     </para>
________________________________________________________-->
     <para>
      这里是一个使用<command>RETURN QUERY</command>的函数的例子：

<programlisting>
CREATE FUNCTION get_available_flightid(date) RETURNS SETOF integer AS
$BODY$
BEGIN
    RETURN QUERY SELECT flightid
                   FROM flight
                  WHERE flightdate &gt;= $1
                    AND flightdate &lt; ($1 + 1);

    -- 因为执行还未结束，我们可以检查是否有行被返回
    -- 如果没有就抛出异常。
    IF NOT FOUND THEN
        RAISE EXCEPTION 'No flight at %.', $1;
    END IF;

    RETURN;
 END;
$BODY$
LANGUAGE plpgsql;

-- 返回可用的航班或者在没有可用航班时抛出异常。
SELECT * FROM get_available_flightid(CURRENT_DATE);
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=235b8e238352538404f84f89d55ffc34 -->

     <note>
<!-- pgdoc-cn_start sig_en=de638ef3a45649b99f15b484041718d1 sig_cn_org=None source=14.1 
      <para>
       The current implementation of <command>RETURN NEXT</command>
       and <command>RETURN QUERY</command> stores the entire result set
       before returning from the function, as discussed above.  That
       means that if a <application>PL/pgSQL</application> function produces a
       very large result set, performance might be poor: data will be
       written to disk to avoid memory exhaustion, but the function
       itself will not return until the entire result set has been
       generated.  A future version of <application>PL/pgSQL</application> might
       allow users to define set-returning functions
       that do not have this limitation.  Currently, the point at
       which data begins being written to disk is controlled by the
       <xref linkend="guc-work-mem"/>
       configuration variable.  Administrators who have sufficient
       memory to store larger result sets in memory should consider
       increasing this parameter.
      </para>
________________________________________________________-->
      <para>
       如上所述，目前<command>RETURN NEXT</command>和<command>RETURN QUERY</command>的实现在从函数返回之前会把整个结果集都保存起来。这意味着如果一个<application>PL/pgSQL</application>函数生成一个非常大的结果集，性能可能会很差：数据将被写到磁盘上以避免内存耗尽，但是函数本身在整个结果集都生成之前不会退出。将来的<application>PL/pgSQL</application>版本可能会允许用户定义没有这种限制的集合返回函数。目前，数据开始被写入到磁盘的时机由配置变量<xref linkend="guc-work-mem"/>控制。拥有足够内存来存储大型结果集的管理员可以考虑增大这个参数。
      </para>
<!-- pgdoc-cn_end sig_en=de638ef3a45649b99f15b484041718d1 -->
     </note>
    </sect3>
   </sect2>

   <sect2 id="plpgsql-statements-returning-procedure">
<!-- pgdoc-cn_start sig_en=8ed756e846132d30116af0358aebe6b9 sig_cn_org=None source=14.1 
    <title>Returning from a Procedure</title>
________________________________________________________-->
    <title>从过程中返回</title>
<!-- pgdoc-cn_end sig_en=8ed756e846132d30116af0358aebe6b9 -->

<!-- pgdoc-cn_start sig_en=4466abb49baae85eeb31eee0e159e09d sig_cn_org=None source=14.1 
    <para>
     A procedure does not have a return value.  A procedure can therefore end
     without a <command>RETURN</command> statement.  If you wish to use
     a <command>RETURN</command> statement to exit the code early, write
     just <command>RETURN</command> with no expression.
    </para>
________________________________________________________-->
    <para>
     过程没有返回值。因此，过程的结束可以不用<command>RETURN</command>语句。
     如果想用一个<command>RETURN</command>语句提前退出代码，只需写一个没有表达式的<command>RETURN</command>。
    </para>
<!-- pgdoc-cn_end sig_en=4466abb49baae85eeb31eee0e159e09d -->

<!-- pgdoc-cn_start sig_en=5660ea9a68796dbfa4cf0bba69fcc4c0 sig_cn_org=None source=14.1 
    <para>
     If the procedure has output parameters, the final values of the output
     parameter variables will be returned to the caller.
    </para>
________________________________________________________-->
    <para>
     如果过程有输出参数，那么输出参数最终的值会被返回给调用者。
    </para>
<!-- pgdoc-cn_end sig_en=5660ea9a68796dbfa4cf0bba69fcc4c0 -->
   </sect2>

   <sect2 id="plpgsql-statements-calling-procedure">
<!-- pgdoc-cn_start sig_en=d7ac0e6949e873973fb1d480430e34c9 sig_cn_org=None source=14.1 
    <title>Calling a Procedure</title>
________________________________________________________-->
    <title>调用存储过程</title>
<!-- pgdoc-cn_end sig_en=d7ac0e6949e873973fb1d480430e34c9 -->

<!-- pgdoc-cn_start sig_en=fc8684520445cff4354605bb4e77a7a1 sig_cn_org=None source=14.1 
    <para>
     A <application>PL/pgSQL</application> function, procedure,
     or <command>DO</command> block can call a procedure
     using <command>CALL</command>.  Output parameters are handled
     differently from the way that <command>CALL</command> works in plain
     SQL.  Each <literal>OUT</literal> or <literal>INOUT</literal>
     parameter of the procedure must
     correspond to a variable in the <command>CALL</command> statement, and
     whatever the procedure returns is assigned back to that variable after
     it returns.  For example:
<programlisting>
CREATE PROCEDURE triple(INOUT x int)
LANGUAGE plpgsql
AS $$
BEGIN
    x := x * 3;
END;
$$;

DO $$
DECLARE myvar int := 5;
BEGIN
  CALL triple(myvar);
  RAISE NOTICE 'myvar = %', myvar;  -&minus; prints 15
END;
$$;
</programlisting>
     The variable corresponding to an output parameter can be a simple
     variable or a field of a composite-type variable.  Currently,
     it cannot be an element of an array.
    </para>
________________________________________________________-->
    <para>
<application>PL/pgSQL</application>函数，存储过程或<command>DO</command>块可以使用
<command>CALL</command>调用存储过程。
输出参数的处理方式与纯SQL中<command>CALL</command>的工作方式不同。
存储过程的每个<literal>OUT</literal> 或者 <literal>INOUT</literal>参数必须和<command>CALL</command>语句中的变量对应，
并且无论存储过程返回什么，都会在返回后赋值给该变量。
例如：
<programlisting>
CREATE PROCEDURE triple(INOUT x int)
LANGUAGE plpgsql
AS $$
BEGIN
    x := x * 3;
END;
$$;

DO $$
DECLARE myvar int := 5;
BEGIN
  CALL triple(myvar);
  RAISE NOTICE 'myvar = %', myvar;  -- prints 15
END;
$$;
</programlisting>
     与输出参数相对应的变量可以是一个简单的变量或一个组合型变量的字段。 目前，它不能是一个数组的元素。
    </para>
<!-- pgdoc-cn_end sig_en=fc8684520445cff4354605bb4e77a7a1 -->
   </sect2>

   <sect2 id="plpgsql-conditionals">
<!-- pgdoc-cn_start sig_en=1bd05e43f6fbd78d59e858b97bd2d06d sig_cn_org=None source=14.1 
    <title>Conditionals</title>
________________________________________________________-->
    <title>条件</title>
<!-- pgdoc-cn_end sig_en=1bd05e43f6fbd78d59e858b97bd2d06d -->

<!-- pgdoc-cn_start sig_en=8fab08eb236decb1d3992bd567841800 sig_cn_org=None source=14.1 
    <para>
     <command>IF</command> and <command>CASE</command> statements let you execute
     alternative commands based on certain conditions.
     <application>PL/pgSQL</application> has three forms of <command>IF</command>:
    <itemizedlist>
     <listitem>
      <para><literal>IF ... THEN ... END IF</literal></para>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSE ... END IF</literal></para>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSIF ... THEN ... ELSE ... END IF</literal></para>
     </listitem>
    </itemizedlist>

    and two forms of <command>CASE</command>:
    <itemizedlist>
     <listitem>
      <para><literal>CASE ... WHEN ... THEN ... ELSE ... END CASE</literal></para>
     </listitem>
     <listitem>
      <para><literal>CASE WHEN ... THEN ... ELSE ... END CASE</literal></para>
     </listitem>
    </itemizedlist>
    </para>
________________________________________________________-->
    <para>
     <command>IF</command>和<command>CASE</command>语句让你可以根据某种条件执行二选其一的命令。<application>PL/pgSQL</application>有三种形式的<command>IF</command>：
    <itemizedlist>
     <listitem>
      <para><literal>IF ... THEN ... END IF</literal></para>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSE ... END IF</literal></para>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSIF ... THEN ... ELSE ... END IF</literal></para>
     </listitem>
    </itemizedlist>

    以及两种形式的<command>CASE</command>：
    <itemizedlist>
     <listitem>
      <para><literal>CASE ... WHEN ... THEN ... ELSE ... END CASE</literal></para>
     </listitem>
     <listitem>
      <para><literal>CASE WHEN ... THEN ... ELSE ... END CASE</literal></para>
     </listitem>
    </itemizedlist>
    </para>
<!-- pgdoc-cn_end sig_en=8fab08eb236decb1d3992bd567841800 -->

    <sect3>
     <title><literal>IF-THEN</literal></title>

<!-- pgdoc-cn_start sig_en=52096351cb365d2a4b776748d4041bc6 sig_cn_org=None source=14.1 
<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
END IF;
</synopsis>
________________________________________________________-->
<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
END IF;
</synopsis>
<!-- pgdoc-cn_end sig_en=52096351cb365d2a4b776748d4041bc6 -->

<!-- pgdoc-cn_start sig_en=242c84537c30cce6b32f9f0cc098fa0e sig_cn_org=None source=14.1 
       <para>
        <literal>IF-THEN</literal> statements are the simplest form of
        <literal>IF</literal>. The statements between
        <literal>THEN</literal> and <literal>END IF</literal> will be
        executed if the condition is true. Otherwise, they are
        skipped.
       </para>
________________________________________________________-->
       <para>
        <literal>IF-THEN</literal>语句是<command>IF</command>的最简单形式。 如果条件为真，在<literal>THEN</literal>和<literal>END IF</literal>之间的语句将被执行。否则，将忽略它们。
       </para>
<!-- pgdoc-cn_end sig_en=242c84537c30cce6b32f9f0cc098fa0e -->

<!-- pgdoc-cn_start sig_en=c2dadb94cc95e45d33ffbac89cffcc85 sig_cn_org=None source=14.1 
       <para>
        Example:
<programlisting>
IF v_user_id &lt;&gt; 0 THEN
    UPDATE users SET email = v_email WHERE user_id = v_user_id;
END IF;
</programlisting>
       </para>
________________________________________________________-->
       <para>
        例子：
<programlisting>
IF v_user_id &lt;&gt; 0 THEN
    UPDATE users SET email = v_email WHERE user_id = v_user_id;
END IF;
</programlisting>
       </para>
<!-- pgdoc-cn_end sig_en=c2dadb94cc95e45d33ffbac89cffcc85 -->
     </sect3>

     <sect3>
      <title><literal>IF-THEN-ELSE</literal></title>

<!-- pgdoc-cn_start sig_en=0f2e136c3c0f2f3ae1ad055a0d06f4d9 sig_cn_org=None source=14.1 
<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
ELSE
    <replaceable>statements</replaceable>
END IF;
</synopsis>
________________________________________________________-->
<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
ELSE
    <replaceable>statements</replaceable>
END IF;
</synopsis>
<!-- pgdoc-cn_end sig_en=0f2e136c3c0f2f3ae1ad055a0d06f4d9 -->

<!-- pgdoc-cn_start sig_en=7ca65c0d88dc95ef775ef01d5f9c82df sig_cn_org=None source=14.1 
       <para>
        <literal>IF-THEN-ELSE</literal> statements add to
        <literal>IF-THEN</literal> by letting you specify an
        alternative set of statements that should be executed if the
        condition is not true.  (Note this includes the case where the
        condition evaluates to NULL.)
       </para>
________________________________________________________-->
       <para>
        <literal>IF-THEN-ELSE</literal>语句对<literal>IF-THEN</literal>进行了增加，它让你能够指定一组在条件不为真时应该被执行的语句（注意这也包括条件为 NULL 的情况）。
       </para>
<!-- pgdoc-cn_end sig_en=7ca65c0d88dc95ef775ef01d5f9c82df -->

<!-- pgdoc-cn_start sig_en=ff298edadbcdd6bf331343830956de1f sig_cn_org=None source=14.1 
       <para>
        Examples:
<programlisting>
IF parentid IS NULL OR parentid = ''
THEN
    RETURN fullname;
ELSE
    RETURN hp_true_filename(parentid) || '/' || fullname;
END IF;
</programlisting>

<programlisting>
IF v_count &gt; 0 THEN
    INSERT INTO users_count (count) VALUES (v_count);
    RETURN 't';
ELSE
    RETURN 'f';
END IF;
</programlisting>
     </para>
________________________________________________________-->
       <para>
        例子：
<programlisting>
IF parentid IS NULL OR parentid = ''
THEN
    RETURN fullname;
ELSE
    RETURN hp_true_filename(parentid) || '/' || fullname;
END IF;
</programlisting>

<programlisting>
IF v_count &gt; 0 THEN
    INSERT INTO users_count (count) VALUES (v_count);
    RETURN 't';
ELSE
    RETURN 'f';
END IF;
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=ff298edadbcdd6bf331343830956de1f -->
    </sect3>

     <sect3>
      <title><literal>IF-THEN-ELSIF</literal></title>

<!-- pgdoc-cn_start sig_en=545385f29aec0c905a26d45d08fd9bc0 sig_cn_org=None source=14.1 
<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
<optional> ELSIF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
<optional> ELSIF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
    ...
</optional>
</optional>
<optional> ELSE
    <replaceable>statements</replaceable> </optional>
END IF;
</synopsis>
________________________________________________________-->
<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
<optional> ELSIF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
<optional> ELSIF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
    ...
</optional>
</optional>
<optional> ELSE
    <replaceable>statements</replaceable> </optional>
END IF;
</synopsis>
<!-- pgdoc-cn_end sig_en=545385f29aec0c905a26d45d08fd9bc0 -->

<!-- pgdoc-cn_start sig_en=6c8546e4bf892337652cac1176f9686e sig_cn_org=None source=14.1 
       <para>
        Sometimes there are more than just two alternatives.
        <literal>IF-THEN-ELSIF</literal> provides a convenient
        method of checking several alternatives in turn.
        The <literal>IF</literal> conditions are tested successively
        until the first one that is true is found.  Then the
        associated statement(s) are executed, after which control
        passes to the next statement after <literal>END IF</literal>.
        (Any subsequent <literal>IF</literal> conditions are <emphasis>not</emphasis>
        tested.)  If none of the <literal>IF</literal> conditions is true,
        then the <literal>ELSE</literal> block (if any) is executed.
       </para>
________________________________________________________-->
       <para>
        有时会有多于两种选择。<literal>IF-THEN-ELSIF</literal>则提供了一个简便的方法来检查多个条件。<literal>IF</literal>条件会被一个接一个测试，直到找到第一个为真的。然后执行相关语句，然后控制会被交给<literal>END IF</literal>之后的下一个语句（后续的任何<literal>IF</literal>条件<emphasis>不会</emphasis>被测试）。如果没有一个<literal>IF</literal>条件为真，那么<literal>ELSE</literal>块（如果有）将被执行。
       </para>
<!-- pgdoc-cn_end sig_en=6c8546e4bf892337652cac1176f9686e -->

<!-- pgdoc-cn_start sig_en=14088122f90048ebd03e974455dae91c sig_cn_org=None source=14.1 
       <para>
        Here is an example:

<programlisting>
IF number = 0 THEN
    result := 'zero';
ELSIF number &gt; 0 THEN
    result := 'positive';
ELSIF number &lt; 0 THEN
    result := 'negative';
ELSE
    -&minus; hmm, the only other possibility is that number is null
    result := 'NULL';
END IF;
</programlisting>
       </para>
________________________________________________________-->
       <para>
        这里有一个例子：

<programlisting>
IF number = 0 THEN
    result := 'zero';
ELSIF number &gt; 0 THEN
    result := 'positive';
ELSIF number &lt; 0 THEN
    result := 'negative';
ELSE
    -- 嗯，唯一的其他可能性是数字为空
    result := 'NULL';
END IF;
</programlisting>
       </para>
<!-- pgdoc-cn_end sig_en=14088122f90048ebd03e974455dae91c -->

<!-- pgdoc-cn_start sig_en=3d98157021141ee14b2bd3f06b567225 sig_cn_org=None source=14.1 
       <para>
        The key word <literal>ELSIF</literal> can also be spelled
        <literal>ELSEIF</literal>.
       </para>
________________________________________________________-->
       <para>
        关键词<literal>ELSIF</literal>也可以被拼写成<literal>ELSEIF</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=3d98157021141ee14b2bd3f06b567225 -->

<!-- pgdoc-cn_start sig_en=8dbb64f9d695a4dab9d1e4f29c638938 sig_cn_org=None source=14.1 
       <para>
        An alternative way of accomplishing the same task is to nest
        <literal>IF-THEN-ELSE</literal> statements, as in the
        following example:

<programlisting>
IF demo_row.sex = 'm' THEN
    pretty_sex := 'man';
ELSE
    IF demo_row.sex = 'f' THEN
        pretty_sex := 'woman';
    END IF;
END IF;
</programlisting>
       </para>
________________________________________________________-->
       <para>
        另一个可以完成相同任务的方法是嵌套<literal>IF-THEN-ELSE</literal>语句，如下例：

<programlisting>
IF demo_row.sex = 'm' THEN
    pretty_sex := 'man';
ELSE
    IF demo_row.sex = 'f' THEN
        pretty_sex := 'woman';
    END IF;
END IF;
</programlisting>
       </para>
<!-- pgdoc-cn_end sig_en=8dbb64f9d695a4dab9d1e4f29c638938 -->

<!-- pgdoc-cn_start sig_en=e66bffadccda3aaa4f5627e6d970bb29 sig_cn_org=None source=14.1 
       <para>
        However, this method requires writing a matching <literal>END IF</literal>
        for each <literal>IF</literal>, so it is much more cumbersome than
        using <literal>ELSIF</literal> when there are many alternatives.
       </para>
________________________________________________________-->
       <para>
        不过，这种方法需要为每个<literal>IF</literal>都写一个匹配的<literal>END IF</literal>，因此当有很多选择时，这种方法比使用<literal>ELSIF</literal>要麻烦得多。
       </para>
<!-- pgdoc-cn_end sig_en=e66bffadccda3aaa4f5627e6d970bb29 -->
     </sect3>

     <sect3>
<!-- pgdoc-cn_start sig_en=b04276f34c1f288832b10eabd507090a sig_cn_org=None source=14.1 
      <title>Simple <literal>CASE</literal></title>
________________________________________________________-->
      <title>简单<literal>CASE</literal></title>
<!-- pgdoc-cn_end sig_en=b04276f34c1f288832b10eabd507090a -->

<!-- pgdoc-cn_start sig_en=94538854ae19f85702183dbe2d04c0e7 sig_cn_org=None source=14.1 
<synopsis>
CASE <replaceable>search-expression</replaceable>
    WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>statements</replaceable>
  <optional> WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>statements</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>statements</replaceable> </optional>
END CASE;
</synopsis>
________________________________________________________-->
<synopsis>
CASE <replaceable>search-expression</replaceable>
    WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>statements</replaceable>
  <optional> WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>statements</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>statements</replaceable> </optional>
END CASE;
</synopsis>
<!-- pgdoc-cn_end sig_en=94538854ae19f85702183dbe2d04c0e7 -->

<!-- pgdoc-cn_start sig_en=337bdf784c0d2bca07fedf34f29a875c sig_cn_org=None source=14.1 
      <para>
       The simple form of <command>CASE</command> provides conditional execution
       based on equality of operands.  The <replaceable>search-expression</replaceable>
       is evaluated (once) and successively compared to each
       <replaceable>expression</replaceable> in the <literal>WHEN</literal> clauses.
       If a match is found, then the corresponding
       <replaceable>statements</replaceable> are executed, and then control
       passes to the next statement after <literal>END CASE</literal>.  (Subsequent
       <literal>WHEN</literal> expressions are not evaluated.)  If no match is
       found, the <literal>ELSE</literal> <replaceable>statements</replaceable> are
       executed; but if <literal>ELSE</literal> is not present, then a
       <literal>CASE_NOT_FOUND</literal> exception is raised.
      </para>
________________________________________________________-->
      <para>
       <command>CASE</command>的简单形式提供了基于操作数等值判断的有条件执行。<replaceable>search-expression</replaceable>会被计算（一次）并且一个接一个地与<literal>WHEN</literal>子句中的每个<replaceable>expression</replaceable>比较。如果找到一个匹配，那么相应的<replaceable>statements</replaceable>会被执行，并且接着控制会被交给<literal>END CASE</literal>之后的下一个语句（后续的<literal>WHEN</literal>表达式不会被计算）。如果没有找到匹配，<literal>ELSE</literal> <replaceable>语句</replaceable>会被执行。但是如果<literal>ELSE</literal>不存在，将会抛出一个<literal>CASE_NOT_FOUND</literal>异常。
      </para>
<!-- pgdoc-cn_end sig_en=337bdf784c0d2bca07fedf34f29a875c -->

<!-- pgdoc-cn_start sig_en=9d4973f523055a49cf203b82e6357a14 sig_cn_org=None source=14.1 
      <para>
       Here is a simple example:

<programlisting>
CASE x
    WHEN 1, 2 THEN
        msg := 'one or two';
    ELSE
        msg := 'other value than one or two';
END CASE;
</programlisting>
      </para>
________________________________________________________-->
      <para>
       这里是一个简单的例子：

<programlisting>
CASE x
    WHEN 1, 2 THEN
        msg := 'one or two';
    ELSE
        msg := 'other value than one or two';
END CASE;
</programlisting>
      </para>
<!-- pgdoc-cn_end sig_en=9d4973f523055a49cf203b82e6357a14 -->
     </sect3>

     <sect3>
<!-- pgdoc-cn_start sig_en=5bbb704757c74b64b762805e2e2d5629 sig_cn_org=None source=14.1 
      <title>Searched <literal>CASE</literal></title>
________________________________________________________-->
      <title>搜索<literal>CASE</literal></title>
<!-- pgdoc-cn_end sig_en=5bbb704757c74b64b762805e2e2d5629 -->

<!-- pgdoc-cn_start sig_en=dbe09da05ce9f4ef9e73f7e85eb2e477 sig_cn_org=None source=14.1 
<synopsis>
CASE
    WHEN <replaceable>boolean-expression</replaceable> THEN
      <replaceable>statements</replaceable>
  <optional> WHEN <replaceable>boolean-expression</replaceable> THEN
      <replaceable>statements</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>statements</replaceable> </optional>
END CASE;
</synopsis>
________________________________________________________-->
<synopsis>
CASE
    WHEN <replaceable>boolean-expression</replaceable> THEN
      <replaceable>statements</replaceable>
  <optional> WHEN <replaceable>boolean-expression</replaceable> THEN
      <replaceable>statements</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>statements</replaceable> </optional>
END CASE;
</synopsis>
<!-- pgdoc-cn_end sig_en=dbe09da05ce9f4ef9e73f7e85eb2e477 -->

<!-- pgdoc-cn_start sig_en=92a76c0f5d55ddd5c15b07a691a79a6d sig_cn_org=None source=14.1 
      <para>
       The searched form of <command>CASE</command> provides conditional execution
       based on truth of Boolean expressions.  Each <literal>WHEN</literal> clause's
       <replaceable>boolean-expression</replaceable> is evaluated in turn,
       until one is found that yields <literal>true</literal>.  Then the
       corresponding <replaceable>statements</replaceable> are executed, and
       then control passes to the next statement after <literal>END CASE</literal>.
       (Subsequent <literal>WHEN</literal> expressions are not evaluated.)
       If no true result is found, the <literal>ELSE</literal>
       <replaceable>statements</replaceable> are executed;
       but if <literal>ELSE</literal> is not present, then a
       <literal>CASE_NOT_FOUND</literal> exception is raised.
      </para>
________________________________________________________-->
      <para>
       <command>CASE</command>的搜索形式基于布尔表达式真假的有条件执行。每一个<literal>WHEN</literal>子句的<replaceable>boolean-expression</replaceable>会被依次计算，直到找到一个得到<literal>真</literal>的。然后相应的<replaceable>statements</replaceable>会被执行，并且接下来控制会被传递给<literal>END CASE</literal>之后的下一个语句（后续的<literal>WHEN</literal>表达式不会被计算）。如果没有找到为真的结果，<literal>ELSE</literal> <replaceable>statements</replaceable>会被执行。但是如果<literal>ELSE</literal>不存在，那么将会抛出一个<literal>CASE_NOT_FOUND</literal>异常。
      </para>
<!-- pgdoc-cn_end sig_en=92a76c0f5d55ddd5c15b07a691a79a6d -->

<!-- pgdoc-cn_start sig_en=e98d854dd2b1101b563db8a996954863 sig_cn_org=None source=14.1 
      <para>
       Here is an example:

<programlisting>
CASE
    WHEN x BETWEEN 0 AND 10 THEN
        msg := 'value is between zero and ten';
    WHEN x BETWEEN 11 AND 20 THEN
        msg := 'value is between eleven and twenty';
END CASE;
</programlisting>
      </para>
________________________________________________________-->
      <para>
       这里是一个例子：

<programlisting>
CASE
    WHEN x BETWEEN 0 AND 10 THEN
        msg := 'value is between zero and ten';
    WHEN x BETWEEN 11 AND 20 THEN
        msg := 'value is between eleven and twenty';
END CASE;
</programlisting>
      </para>
<!-- pgdoc-cn_end sig_en=e98d854dd2b1101b563db8a996954863 -->

<!-- pgdoc-cn_start sig_en=97c8cb1896e06a56e73da368c5664ed7 sig_cn_org=None source=14.1 
      <para>
       This form of <command>CASE</command> is entirely equivalent to
       <literal>IF-THEN-ELSIF</literal>, except for the rule that reaching
       an omitted <literal>ELSE</literal> clause results in an error rather
       than doing nothing.
      </para>
________________________________________________________-->
      <para>
       这种形式的<command>CASE</command>整体上等价于<literal>IF-THEN-ELSIF</literal>，不同之处在于<command>CASE</command>到达一个被忽略的<literal>ELSE</literal>子句时会导致一个错误而不是什么也不做。
      </para>
<!-- pgdoc-cn_end sig_en=97c8cb1896e06a56e73da368c5664ed7 -->

     </sect3>
   </sect2>

   <sect2 id="plpgsql-control-structures-loops">
<!-- pgdoc-cn_start sig_en=2439cbf25f96d99fcd7a557bb2fe2407 sig_cn_org=None source=14.1 
    <title>Simple Loops</title>
________________________________________________________-->
    <title>简单循环</title>
<!-- pgdoc-cn_end sig_en=2439cbf25f96d99fcd7a557bb2fe2407 -->

<!-- pgdoc-cn_start sig_en=f1e63b77c23696d17878340b6c532ac5 sig_cn_org=None source=14.1 
    <indexterm zone="plpgsql-control-structures-loops">
     <primary>loop</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="plpgsql-control-structures-loops">
     <primary>loop</primary>
     <secondary>在 PL/pgSQL 中</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=f1e63b77c23696d17878340b6c532ac5 -->

<!-- pgdoc-cn_start sig_en=d9fdd421fbdb0ef424dc61049f57cd43 sig_cn_org=None source=14.1 
    <para>
     With the <literal>LOOP</literal>, <literal>EXIT</literal>,
     <literal>CONTINUE</literal>, <literal>WHILE</literal>, <literal>FOR</literal>,
     and <literal>FOREACH</literal> statements, you can arrange for your
     <application>PL/pgSQL</application> function to repeat a series of commands.
    </para>
________________________________________________________-->
    <para>
     使用<literal>LOOP</literal>、<literal>EXIT</literal>、<literal>CONTINUE</literal>、<literal>WHILE</literal>、<literal>FOR</literal>和<literal>FOREACH</literal>语句，你可以安排<application>PL/pgSQL</application>重复一系列命令。
    </para>
<!-- pgdoc-cn_end sig_en=d9fdd421fbdb0ef424dc61049f57cd43 -->

    <sect3>
     <title><literal>LOOP</literal></title>

<!-- pgdoc-cn_start sig_en=38ee53f505de28f6771181378f26c177 sig_cn_org=None source=14.1 
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
________________________________________________________-->
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
<!-- pgdoc-cn_end sig_en=38ee53f505de28f6771181378f26c177 -->

<!-- pgdoc-cn_start sig_en=6f05da1cfdd7b59a4260a3400a55f965 sig_cn_org=None source=14.1 
     <para>
      <literal>LOOP</literal> defines an unconditional loop that is repeated
      indefinitely until terminated by an <literal>EXIT</literal> or
      <command>RETURN</command> statement.  The optional
      <replaceable>label</replaceable> can be used by <literal>EXIT</literal>
      and <literal>CONTINUE</literal> statements within nested loops to
      specify which loop those statements refer to.
     </para>
________________________________________________________-->
     <para>
      <literal>LOOP</literal>定义一个无条件的循环，它会无限重复直到被<literal>EXIT</literal>或<command>RETURN</command>语句终止。可选的<replaceable>label</replaceable>可以被<literal>EXIT</literal>和<literal>CONTINUE</literal>语句用在嵌套循环中指定这些语句引用的是哪一层循环。
     </para>
<!-- pgdoc-cn_end sig_en=6f05da1cfdd7b59a4260a3400a55f965 -->
    </sect3>

     <sect3>
      <title><literal>EXIT</literal></title>

<!-- pgdoc-cn_start sig_en=e68277f0dc910b013fb7e8f46cfe1cad sig_cn_org=None source=14.1 
     <indexterm>
      <primary>EXIT</primary>
      <secondary>in PL/pgSQL</secondary>
     </indexterm>
________________________________________________________-->
     <indexterm>
      <primary>EXIT</primary>
      <secondary>在 PL/pgSQL 中</secondary>
     </indexterm>
<!-- pgdoc-cn_end sig_en=e68277f0dc910b013fb7e8f46cfe1cad -->

<!-- pgdoc-cn_start sig_en=253cc9eab47175cbe3d24b3052f50eca sig_cn_org=None source=14.1 
<synopsis>
EXIT <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>boolean-expression</replaceable> </optional>;
</synopsis>
________________________________________________________-->
<synopsis>
EXIT <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>boolean-expression</replaceable> </optional>;
</synopsis>
<!-- pgdoc-cn_end sig_en=253cc9eab47175cbe3d24b3052f50eca -->

<!-- pgdoc-cn_start sig_en=32e1d9e7725d8971410402612c64c361 sig_cn_org=None source=14.1 
       <para>
        If no <replaceable>label</replaceable> is given, the innermost
        loop is terminated and the statement following <literal>END
        LOOP</literal> is executed next.  If <replaceable>label</replaceable>
        is given, it must be the label of the current or some outer
        level of nested loop or block. Then the named loop or block is
        terminated and control continues with the statement after the
        loop's/block's corresponding <literal>END</literal>.
       </para>
________________________________________________________-->
       <para>
        如果没有给出<replaceable>label</replaceable>，那么最内层的循环会被终止，然后跟在<literal>END LOOP</literal>后面的语句会被执行。如果给出了<replaceable>label</replaceable>，那么它必须是当前或者更高层的嵌套循环或者语句块的标签。然后该命名循环或块就会被终止，并且控制会转移到该循环/块相应的<literal>END</literal>之后的语句上。
       </para>
<!-- pgdoc-cn_end sig_en=32e1d9e7725d8971410402612c64c361 -->

<!-- pgdoc-cn_start sig_en=a28f9567b91487444a345174a5e99348 sig_cn_org=None source=14.1 
       <para>
        If <literal>WHEN</literal> is specified, the loop exit occurs only if
        <replaceable>boolean-expression</replaceable> is true. Otherwise, control passes
        to the statement after <literal>EXIT</literal>.
       </para>
________________________________________________________-->
       <para>
        如果指定了<literal>WHEN</literal>，只有<replaceable>boolean-expression</replaceable>为真时才会发生循环退出。否则，控制会转移到<literal>EXIT</literal>之后的语句。
       </para>
<!-- pgdoc-cn_end sig_en=a28f9567b91487444a345174a5e99348 -->

<!-- pgdoc-cn_start sig_en=de20ad0fe8478b6a2b9ae1c172309313 sig_cn_org=None source=14.1 
       <para>
        <literal>EXIT</literal> can be used with all types of loops; it is
        not limited to use with unconditional loops.
       </para>
________________________________________________________-->
       <para>
        <literal>EXIT</literal>可以被用在所有类型的循环中，它并不限于在无条件循环中使用。
       </para>
<!-- pgdoc-cn_end sig_en=de20ad0fe8478b6a2b9ae1c172309313 -->

<!-- pgdoc-cn_start sig_en=efeed4104ed24feb2977753860c065f0 sig_cn_org=None source=14.1 
       <para>
        When used with a
        <literal>BEGIN</literal> block, <literal>EXIT</literal> passes
        control to the next statement after the end of the block.
        Note that a label must be used for this purpose; an unlabeled
        <literal>EXIT</literal> is never considered to match a
        <literal>BEGIN</literal> block.  (This is a change from
        pre-8.4 releases of <productname>PostgreSQL</productname>, which
        would allow an unlabeled <literal>EXIT</literal> to match
        a <literal>BEGIN</literal> block.)
       </para>
________________________________________________________-->
       <para>
        在和<literal>BEGIN</literal>块一起使用时，<literal>EXIT</literal>会把控制交给块结束后的下一个语句。需要注意的是，一个标签必须被用于这个目的；一个没有被标记的<literal>EXIT</literal>永远无法被认为与一个<literal>BEGIN</literal>块匹配（这种状况从<productname>PostgreSQL</productname> 8.4 之前的发布就已经开始改变。这可能允许一个未被标记的<literal>EXIT</literal>匹配一个<literal>BEGIN</literal>块）。
       </para>
<!-- pgdoc-cn_end sig_en=efeed4104ed24feb2977753860c065f0 -->

<!-- pgdoc-cn_start sig_en=d0d5869efd8f4c08f0f30bb9feb7bb79 sig_cn_org=None source=14.1 
       <para>
        Examples:
<programlisting>
LOOP
    -&minus; some computations
    IF count &gt; 0 THEN
        EXIT;  -&minus; exit loop
    END IF;
END LOOP;

LOOP
    -&minus; some computations
    EXIT WHEN count &gt; 0;  -&minus; same result as previous example
END LOOP;

&lt;&lt;ablock&gt;&gt;
BEGIN
    -&minus; some computations
    IF stocks &gt; 100000 THEN
        EXIT ablock;  -&minus; causes exit from the BEGIN block
    END IF;
    -&minus; computations here will be skipped when stocks &gt; 100000
END;
</programlisting>
       </para>
________________________________________________________-->
       <para>
        例子：
<programlisting>
LOOP
    -- 一些计算
    IF count &gt; 0 THEN
        EXIT;  -- 退出循环
    END IF;
END LOOP;

LOOP
    -- 一些计算
    EXIT WHEN count &gt; 0;  -- 和前一个例子相同的结果
END LOOP;

&lt;&lt;ablock&gt;&gt;
BEGIN
    -- 一些计算
    IF stocks &gt; 100000 THEN
        EXIT ablock;  -- 导致从 BEGIN 块中退出
    END IF;
    -- 当stocks &gt; 100000时，这里的计算将被跳过
END;
</programlisting>
       </para>
<!-- pgdoc-cn_end sig_en=d0d5869efd8f4c08f0f30bb9feb7bb79 -->
     </sect3>

     <sect3>
      <title><literal>CONTINUE</literal></title>

<!-- pgdoc-cn_start sig_en=2fd61a4e3116b38afb94d9bf3fcf8946 sig_cn_org=None source=14.1 
     <indexterm>
      <primary>CONTINUE</primary>
      <secondary>in PL/pgSQL</secondary>
     </indexterm>
________________________________________________________-->
     <indexterm>
      <primary>CONTINUE</primary>
      <secondary>在 PL/pgSQL 中</secondary>
     </indexterm>
<!-- pgdoc-cn_end sig_en=2fd61a4e3116b38afb94d9bf3fcf8946 -->

<!-- pgdoc-cn_start sig_en=93a5bc6ba55246fde094940f48813c55 sig_cn_org=None source=14.1 
<synopsis>
CONTINUE <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>boolean-expression</replaceable> </optional>;
</synopsis>
________________________________________________________-->
<synopsis>
CONTINUE <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>boolean-expression</replaceable> </optional>;
</synopsis>
<!-- pgdoc-cn_end sig_en=93a5bc6ba55246fde094940f48813c55 -->

<!-- pgdoc-cn_start sig_en=46dbfd4bc2eff1300733884ef65ecadf sig_cn_org=None source=14.1 
       <para>
        If no <replaceable>label</replaceable> is given, the next iteration of
        the innermost loop is begun. That is, all statements remaining
        in the loop body are skipped, and control returns
        to the loop control expression (if any) to determine whether
        another loop iteration is needed.
        If <replaceable>label</replaceable> is present, it
        specifies the label of the loop whose execution will be
        continued.
       </para>
________________________________________________________-->
       <para>
        如果没有给出<replaceable>label</replaceable>，最内层循环的下一次迭代会开始。也就是，循环体中剩余的所有语句将被跳过，并且控制会返回到循环控制表达式（如果有）来决定是否需要另一次循环迭代。如果<replaceable>label</replaceable>存在，它指定应该继续执行的循环的标签。
       </para>
<!-- pgdoc-cn_end sig_en=46dbfd4bc2eff1300733884ef65ecadf -->

<!-- pgdoc-cn_start sig_en=7b9640883c0c0d4145e04f575a2392b6 sig_cn_org=None source=14.1 
       <para>
        If <literal>WHEN</literal> is specified, the next iteration of the
        loop is begun only if <replaceable>boolean-expression</replaceable> is
        true. Otherwise, control passes to the statement after
        <literal>CONTINUE</literal>.
       </para>
________________________________________________________-->
       <para>
        如果指定了<literal>WHEN</literal>，该循环的下一次迭代只有在<replaceable>boolean-expression</replaceable>为真时才会开始。否则，控制会传递给<literal>CONTINUE</literal>后面的语句。
       </para>
<!-- pgdoc-cn_end sig_en=7b9640883c0c0d4145e04f575a2392b6 -->

<!-- pgdoc-cn_start sig_en=a6a7d847476d2b023c04ade738927af0 sig_cn_org=None source=14.1 
       <para>
        <literal>CONTINUE</literal> can be used with all types of loops; it
        is not limited to use with unconditional loops.
       </para>
________________________________________________________-->
       <para>
        <literal>CONTINUE</literal>可以被用在所有类型的循环中，它并不限于在无条件循环中使用。
       </para>
<!-- pgdoc-cn_end sig_en=a6a7d847476d2b023c04ade738927af0 -->

<!-- pgdoc-cn_start sig_en=9b472e93eb4a3cd7731ec8b502cbb563 sig_cn_org=None source=14.1 
       <para>
        Examples:
<programlisting>
LOOP
    -&minus; some computations
    EXIT WHEN count &gt; 100;
    CONTINUE WHEN count &lt; 50;
    -&minus; some computations for count IN [50 .. 100]
END LOOP;
</programlisting>
       </para>
________________________________________________________-->
       <para>
        例子：
<programlisting>
LOOP
    -- 一些计算
    EXIT WHEN count &gt; 100;
    CONTINUE WHEN count &lt; 50;
    -- 一些用于 count IN [50 .. 100] 的计算
END LOOP;
</programlisting>
       </para>
<!-- pgdoc-cn_end sig_en=9b472e93eb4a3cd7731ec8b502cbb563 -->
     </sect3>


     <sect3>
      <title><literal>WHILE</literal></title>

<!-- pgdoc-cn_start sig_en=9a4f68965b709f90a3b1252bda75bba7 sig_cn_org=None source=14.1 
     <indexterm>
      <primary>WHILE</primary>
      <secondary>in PL/pgSQL</secondary>
     </indexterm>
________________________________________________________-->
     <indexterm>
      <primary>WHILE</primary>
      <secondary>在 PL/pgSQL 中</secondary>
     </indexterm>
<!-- pgdoc-cn_end sig_en=9a4f68965b709f90a3b1252bda75bba7 -->

<!-- pgdoc-cn_start sig_en=b5ce8fcb1bf7558aa51594514aaafaa7 sig_cn_org=None source=14.1 
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
WHILE <replaceable>boolean-expression</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
________________________________________________________-->
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
WHILE <replaceable>boolean-expression</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
<!-- pgdoc-cn_end sig_en=b5ce8fcb1bf7558aa51594514aaafaa7 -->

<!-- pgdoc-cn_start sig_en=d9f52e2ebed62ce1a628af5e50fcb60a sig_cn_org=None source=14.1 
       <para>
        The <literal>WHILE</literal> statement repeats a
        sequence of statements so long as the
        <replaceable>boolean-expression</replaceable>
        evaluates to true.  The expression is checked just before
        each entry to the loop body.
       </para>
________________________________________________________-->
       <para>
        只要<replaceable>boolean-expression</replaceable>被计算为真，<literal>WHILE</literal>语句就会重复一个语句序列。在每次进入到循环体之前都会检查该表达式。
       </para>
<!-- pgdoc-cn_end sig_en=d9f52e2ebed62ce1a628af5e50fcb60a -->

<!-- pgdoc-cn_start sig_en=370ebdab2cbd35bccb4dbc38f8dd03d8 sig_cn_org=None source=14.1 
       <para>
        For example:
<programlisting>
WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP
    -&minus; some computations here
END LOOP;

WHILE NOT done LOOP
    -&minus; some computations here
END LOOP;
</programlisting>
       </para>
________________________________________________________-->
       <para>
        例如：
<programlisting>
WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP
    -- 这里是一些计算
END LOOP;

WHILE NOT done LOOP
    -- 这里是一些计算
END LOOP;
</programlisting>
       </para>
<!-- pgdoc-cn_end sig_en=370ebdab2cbd35bccb4dbc38f8dd03d8 -->
     </sect3>

     <sect3 id="plpgsql-integer-for">
<!-- pgdoc-cn_start sig_en=ea8e87d5598d26d9127494f555b7e6b5 sig_cn_org=None source=14.1 
      <title><literal>FOR</literal> (Integer Variant)</title>
________________________________________________________-->
      <title><literal>FOR</literal>（整型变体）</title>
<!-- pgdoc-cn_end sig_en=ea8e87d5598d26d9127494f555b7e6b5 -->

<!-- pgdoc-cn_start sig_en=ef91a5c01692830a1f9b9cc8331db039 sig_cn_org=None source=14.1 
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>name</replaceable> IN <optional> REVERSE </optional> <replaceable>expression</replaceable> .. <replaceable>expression</replaceable> <optional> BY <replaceable>expression</replaceable> </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
________________________________________________________-->
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>name</replaceable> IN <optional> REVERSE </optional> <replaceable>expression</replaceable> .. <replaceable>expression</replaceable> <optional> BY <replaceable>expression</replaceable> </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
<!-- pgdoc-cn_end sig_en=ef91a5c01692830a1f9b9cc8331db039 -->

<!-- pgdoc-cn_start sig_en=453f9b712f7b4db0065e1ee05a248bf6 sig_cn_org=None source=14.1 
       <para>
        This form of <literal>FOR</literal> creates a loop that iterates over a range
        of integer values. The variable
        <replaceable>name</replaceable> is automatically defined as type
        <type>integer</type> and exists only inside the loop (any existing
        definition of the variable name is ignored within the loop).
        The two expressions giving
        the lower and upper bound of the range are evaluated once when entering
        the loop. If the <literal>BY</literal> clause isn't specified the iteration
        step is 1, otherwise it's the value specified in the <literal>BY</literal>
        clause, which again is evaluated once on loop entry.
        If <literal>REVERSE</literal> is specified then the step value is
        subtracted, rather than added, after each iteration.
       </para>
________________________________________________________-->
       <para>
        这种形式的<literal>FOR</literal>会创建一个在一个整数范围上迭代的循环。变量<replaceable>name</replaceable>会自动定义为类型<type>integer</type>并且只在循环内存在（任何该变量名的现有定义在此循环内都将被忽略）。给出范围上下界的两个表达式在进入循环的时候计算一次。如果没有指定<literal>BY</literal>子句，迭代步长为 1，否则步长是<literal>BY</literal>中指定的值，该值也只在循环进入时计算一次。如果指定了<literal>REVERSE</literal>，那么在每次迭代后步长值会被减除而不是增加。
       </para>
<!-- pgdoc-cn_end sig_en=453f9b712f7b4db0065e1ee05a248bf6 -->

<!-- pgdoc-cn_start sig_en=cc51b4738b31f9f4200df343f490702c sig_cn_org=None source=14.1 
       <para>
        Some examples of integer <literal>FOR</literal> loops:
<programlisting>
FOR i IN 1..10 LOOP
    -&minus; i will take on the values 1,2,3,4,5,6,7,8,9,10 within the loop
END LOOP;

FOR i IN REVERSE 10..1 LOOP
    -&minus; i will take on the values 10,9,8,7,6,5,4,3,2,1 within the loop
END LOOP;

FOR i IN REVERSE 10..1 BY 2 LOOP
    -&minus; i will take on the values 10,8,6,4,2 within the loop
END LOOP;
</programlisting>
       </para>
________________________________________________________-->
       <para>
        整数<literal>FOR</literal>循环的一些例子：
<programlisting>
FOR i IN 1..10 LOOP
    -- 我在循环中将取值 1,2,3,4,5,6,7,8,9,10 
END LOOP;

FOR i IN REVERSE 10..1 LOOP
    -- 我在循环中将取值 10,9,8,7,6,5,4,3,2,1 
END LOOP;

FOR i IN REVERSE 10..1 BY 2 LOOP
    -- 我在循环中将取值 10,8,6,4,2 
END LOOP;
</programlisting>
       </para>
<!-- pgdoc-cn_end sig_en=cc51b4738b31f9f4200df343f490702c -->

<!-- pgdoc-cn_start sig_en=0977df97b7ef98e62b15bd764d7f23e2 sig_cn_org=None source=14.1 
       <para>
        If the lower bound is greater than the upper bound (or less than,
        in the <literal>REVERSE</literal> case), the loop body is not
        executed at all.  No error is raised.
       </para>
________________________________________________________-->
       <para>
        如果下界大于上界（或者在<literal>REVERSE</literal>情况下是小于），循环体根本不会被执行。而且不会抛出任何错误。
       </para>
<!-- pgdoc-cn_end sig_en=0977df97b7ef98e62b15bd764d7f23e2 -->

<!-- pgdoc-cn_start sig_en=dfcd03e0f36f72c4c20b56cc62cb9264 sig_cn_org=None source=14.1 
       <para>
        If a <replaceable>label</replaceable> is attached to the
        <literal>FOR</literal> loop then the integer loop variable can be
        referenced with a qualified name, using that
        <replaceable>label</replaceable>.
       </para>
________________________________________________________-->
       <para>
        如果一个<replaceable>label</replaceable>被附加到<literal>FOR</literal>循环，那么整数循环变量可以用一个使用那个<replaceable>label</replaceable>的限定名引用。
       </para>
<!-- pgdoc-cn_end sig_en=dfcd03e0f36f72c4c20b56cc62cb9264 -->
     </sect3>
   </sect2>

   <sect2 id="plpgsql-records-iterating">
<!-- pgdoc-cn_start sig_en=90df8d5f1b41733f63fd54992ffdb1a7 sig_cn_org=None source=14.1 
    <title>Looping through Query Results</title>
________________________________________________________-->
    <title>通过查询结果循环</title>
<!-- pgdoc-cn_end sig_en=90df8d5f1b41733f63fd54992ffdb1a7 -->

<!-- pgdoc-cn_start sig_en=4aec1227e8dd01a7963056521120d8c0 sig_cn_org=None source=14.1 
    <para>
     Using a different type of <literal>FOR</literal> loop, you can iterate through
     the results of a query and manipulate that data
     accordingly. The syntax is:
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>target</replaceable> IN <replaceable>query</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
     The <replaceable>target</replaceable> is a record variable, row variable,
     or comma-separated list of scalar variables.
     The <replaceable>target</replaceable> is successively assigned each row
     resulting from the <replaceable>query</replaceable> and the loop body is
     executed for each row. Here is an example:
<programlisting>
CREATE FUNCTION refresh_mviews() RETURNS integer AS $$
DECLARE
    mviews RECORD;
BEGIN
    RAISE NOTICE 'Refreshing all materialized views...';

    FOR mviews IN
       SELECT n.nspname AS mv_schema,
              c.relname AS mv_name,
              pg_catalog.pg_get_userbyid(c.relowner) AS owner
         FROM pg_catalog.pg_class c
    LEFT JOIN pg_catalog.pg_namespace n ON (n.oid = c.relnamespace)
        WHERE c.relkind = 'm'
     ORDER BY 1
    LOOP

        -&minus; Now "mviews" has one record with information about the materialized view

        RAISE NOTICE 'Refreshing materialized view %.% (owner: %)...',
                     quote_ident(mviews.mv_schema),
                     quote_ident(mviews.mv_name),
                     quote_ident(mviews.owner);
        EXECUTE format('REFRESH MATERIALIZED VIEW %I.%I', mviews.mv_schema, mviews.mv_name);
    END LOOP;

    RAISE NOTICE 'Done refreshing materialized views.';
    RETURN 1;
END;
$$ LANGUAGE plpgsql;
</programlisting>

     If the loop is terminated by an <literal>EXIT</literal> statement, the last
     assigned row value is still accessible after the loop.
    </para>
________________________________________________________-->
    <para>
     使用一种不同类型的<literal>FOR</literal>循环，你可以通过一个查询的结果进行迭代并且操纵相应的数据。语法是：
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>target</replaceable> IN <replaceable>query</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
     <replaceable>target</replaceable>是一个记录变量、行变量或者逗号分隔的标量变量列表。<replaceable>target</replaceable>被连续不断被赋予来自<replaceable>query</replaceable>的每一行，并且循环体将为每一行执行一次。下面是一个例子：
<programlisting>
CREATE FUNCTION refresh_mviews() RETURNS integer AS $$
DECLARE
    mviews RECORD;
BEGIN
    RAISE NOTICE 'Refreshing all materialized views...';

    FOR mviews IN
       SELECT n.nspname AS mv_schema,
              c.relname AS mv_name,
              pg_catalog.pg_get_userbyid(c.relowner) AS owner
         FROM pg_catalog.pg_class c
    LEFT JOIN pg_catalog.pg_namespace n ON (n.oid = c.relnamespace)
        WHERE c.relkind = 'm'
     ORDER BY 1
    LOOP

        -- Now "mviews" has one record with information about the materialized view

        RAISE NOTICE 'Refreshing materialized view %.% (owner: %)...',
                     quote_ident(mviews.mv_schema),
                     quote_ident(mviews.mv_name),
                     quote_ident(mviews.owner);
        EXECUTE format('REFRESH MATERIALIZED VIEW %I.%I', mviews.mv_schema, mviews.mv_name);
    END LOOP;

    RAISE NOTICE 'Done refreshing materialized views.';
    RETURN 1;
END;
$$ LANGUAGE plpgsql;
</programlisting>

     如果循环被一个<literal>EXIT</literal>语句终止，那么在循环之后你仍然可以访问最后被赋予的行值。
    </para>
<!-- pgdoc-cn_end sig_en=4aec1227e8dd01a7963056521120d8c0 -->

<!-- pgdoc-cn_start sig_en=d6d1f3460ab9845299bc531e9c7eb78b sig_cn_org=None source=14.1 
    <para>
     The <replaceable>query</replaceable> used in this type of <literal>FOR</literal>
     statement can be any SQL command that returns rows to the caller:
     <command>SELECT</command> is the most common case,
     but you can also use <command>INSERT</command>, <command>UPDATE</command>, or
     <command>DELETE</command> with a <literal>RETURNING</literal> clause.  Some utility
     commands such as <command>EXPLAIN</command> will work too.
    </para>
________________________________________________________-->
    <para>
     在这类<literal>FOR</literal>语句中使用的<replaceable>query</replaceable>可以是任何返回行给调用者的 SQL 命令：最常见的是<command>SELECT</command>，但你也可以使用带有<literal>RETURNING</literal>子句的<command>INSERT</command>、<command>UPDATE</command>或<command>DELETE</command>。一些<command>EXPLAIN</command>之类的功能性命令也可以用在这里。
    </para>
<!-- pgdoc-cn_end sig_en=d6d1f3460ab9845299bc531e9c7eb78b -->

<!-- pgdoc-cn_start sig_en=b3bc5e4606c7307bfaf7926cf32f1900 sig_cn_org=None source=14.1 
    <para>
     <application>PL/pgSQL</application> variables are replaced by query parameters,
     and the query plan is cached for possible re-use, as discussed in
     detail in <xref linkend="plpgsql-var-subst"/> and
     <xref linkend="plpgsql-plan-caching"/>.
    </para>
________________________________________________________-->
    <para>
     <application>PL/pgSQL</application>变量会被查询参数替换，并且如<xref linkend="plpgsql-var-subst"/>和<xref linkend="plpgsql-plan-caching"/>中详细讨论的，查询计划会被缓存以用于可能的重用。
    </para>
<!-- pgdoc-cn_end sig_en=b3bc5e4606c7307bfaf7926cf32f1900 -->

<!-- pgdoc-cn_start sig_en=e8728f8ce1c4c4207ebd738a44657f60 sig_cn_org=None source=14.1 
    <para>
     The <literal>FOR-IN-EXECUTE</literal> statement is another way to iterate over
     rows:
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>target</replaceable> IN EXECUTE <replaceable>text_expression</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
     This is like the previous form, except that the source query
     is specified as a string expression, which is evaluated and replanned
     on each entry to the <literal>FOR</literal> loop.  This allows the programmer to
     choose the speed of a preplanned query or the flexibility of a dynamic
     query, just as with a plain <command>EXECUTE</command> statement.
     As with <command>EXECUTE</command>, parameter values can be inserted
     into the dynamic command via <literal>USING</literal>.
    </para>
________________________________________________________-->
    <para>
     <literal>FOR-IN-EXECUTE</literal>语句是在行上迭代的另一种方式：
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>target</replaceable> IN EXECUTE <replaceable>text_expression</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
     这个例子类似前面的形式，只不过源查询被指定为一个字符串表达式，在每次进入<literal>FOR</literal>循环时都会计算它并且重新规划。这允许程序员在一个预先规划好了的命令的速度和一个动态命令的灵活性之间进行选择，就像一个纯<command>EXECUTE</command>语句那样。在使用<command>EXECUTE</command>时，可以通过<literal>USING</literal>将参数值插入到动态命令中。
    </para>
<!-- pgdoc-cn_end sig_en=e8728f8ce1c4c4207ebd738a44657f60 -->

<!-- pgdoc-cn_start sig_en=e18e874a3cfb0abec7c02c4c2340dcd7 sig_cn_org=None source=14.1 
    <para>
     Another way to specify the query whose results should be iterated
     through is to declare it as a cursor.  This is described in
     <xref linkend="plpgsql-cursor-for-loop"/>.
    </para>
________________________________________________________-->
    <para>
     另一种指定要对其结果迭代的查询的方式是将它声明为一个游标。这会在<xref linkend="plpgsql-cursor-for-loop"/>中描述。
    </para>
<!-- pgdoc-cn_end sig_en=e18e874a3cfb0abec7c02c4c2340dcd7 -->
   </sect2>

   <sect2 id="plpgsql-foreach-array">
<!-- pgdoc-cn_start sig_en=e63e127e2489dcfefdb1425621f7d3f0 sig_cn_org=None source=14.1 
    <title>Looping through Arrays</title>
________________________________________________________-->
    <title>通过数组循环</title>
<!-- pgdoc-cn_end sig_en=e63e127e2489dcfefdb1425621f7d3f0 -->

<!-- pgdoc-cn_start sig_en=1d4f95a4e652d5a380fa7ce18b38a50c sig_cn_org=None source=14.1 
    <para>
     The <literal>FOREACH</literal> loop is much like a <literal>FOR</literal> loop,
     but instead of iterating through the rows returned by an SQL query,
     it iterates through the elements of an array value.
     (In general, <literal>FOREACH</literal> is meant for looping through
     components of a composite-valued expression; variants for looping
     through composites besides arrays may be added in future.)
     The <literal>FOREACH</literal> statement to loop over an array is:

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOREACH <replaceable>target</replaceable> <optional> SLICE <replaceable>number</replaceable> </optional> IN ARRAY <replaceable>expression</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
    </para>
________________________________________________________-->
    <para>
     <literal>FOREACH</literal>循环很像一个<literal>FOR</literal>循环，但不是通过一个 SQL 查询返回的行进行迭代，它通过一个数组值的元素来迭代（通常，<literal>FOREACH</literal>意味着通过一个组合值表达式的部件迭代；用于通过除数组之外组合类型进行循环的变体可能会在未来被加入）。在一个数组上循环的<literal>FOREACH</literal>语句是：

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOREACH <replaceable>target</replaceable> <optional> SLICE <replaceable>number</replaceable> </optional> IN ARRAY <replaceable>expression</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
    </para>
<!-- pgdoc-cn_end sig_en=1d4f95a4e652d5a380fa7ce18b38a50c -->

<!-- pgdoc-cn_start sig_en=662839b300f6cef23e61c4dd3f24eae3 sig_cn_org=None source=14.1 
    <para>
     Without <literal>SLICE</literal>, or if <literal>SLICE 0</literal> is specified,
     the loop iterates through individual elements of the array produced
     by evaluating the <replaceable>expression</replaceable>.
     The <replaceable>target</replaceable> variable is assigned each
     element value in sequence, and the loop body is executed for each element.
     Here is an example of looping through the elements of an integer
     array:

<programlisting>
CREATE FUNCTION sum(int[]) RETURNS int8 AS $$
DECLARE
  s int8 := 0;
  x int;
BEGIN
  FOREACH x IN ARRAY $1
  LOOP
    s := s + x;
  END LOOP;
  RETURN s;
END;
$$ LANGUAGE plpgsql;
</programlisting>

     The elements are visited in storage order, regardless of the number of
     array dimensions.  Although the <replaceable>target</replaceable> is
     usually just a single variable, it can be a list of variables when
     looping through an array of composite values (records).  In that case,
     for each array element, the variables are assigned from successive
     columns of the composite value.
    </para>
________________________________________________________-->
    <para>
     如果没有<literal>SLICE</literal>，或者如果没有指定<literal>SLICE 0</literal>，循环会通过计算<replaceable>expression</replaceable>得到的数组的个体元素进行迭代。<replaceable>target</replaceable>变量被逐一赋予每一个元素值，并且循环体会为每一个元素执行。这里是一个通过整数数组的元素循环的例子：

<programlisting>
CREATE FUNCTION sum(int[]) RETURNS int8 AS $$
DECLARE
  s int8 := 0;
  x int;
BEGIN
  FOREACH x IN ARRAY $1
  LOOP
    s := s + x;
  END LOOP;
  RETURN s;
END;
$$ LANGUAGE plpgsql;
</programlisting>

     元素会被按照存储顺序访问，而不管数组的维度数。尽管<replaceable>target</replaceable>通常只是一个单一变量，当通过一个组合值（记录）的数组循环时，它可以是一个变量列表。在那种情况下，对每一个数组元素，变量会被从组合值的连续列赋值。
    </para>
<!-- pgdoc-cn_end sig_en=662839b300f6cef23e61c4dd3f24eae3 -->

<!-- pgdoc-cn_start sig_en=c6d97759ef7f9a067122c16cb7a5e813 sig_cn_org=None source=14.1 
    <para>
     With a positive <literal>SLICE</literal> value, <literal>FOREACH</literal>
     iterates through slices of the array rather than single elements.
     The <literal>SLICE</literal> value must be an integer constant not larger
     than the number of dimensions of the array.  The
     <replaceable>target</replaceable> variable must be an array,
     and it receives successive slices of the array value, where each slice
     is of the number of dimensions specified by <literal>SLICE</literal>.
     Here is an example of iterating through one-dimensional slices:

<programlisting>
CREATE FUNCTION scan_rows(int[]) RETURNS void AS $$
DECLARE
  x int[];
BEGIN
  FOREACH x SLICE 1 IN ARRAY $1
  LOOP
    RAISE NOTICE 'row = %', x;
  END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT scan_rows(ARRAY[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]);

NOTICE:  row = {1,2,3}
NOTICE:  row = {4,5,6}
NOTICE:  row = {7,8,9}
NOTICE:  row = {10,11,12}
</programlisting>
    </para>
________________________________________________________-->
    <para>
     通过一个正<literal>SLICE</literal>值，<literal>FOREACH</literal>通过数组的切片而不是单一元素迭代。<literal>SLICE</literal>值必须是一个不大于数组维度数的整数常量。<replaceable>target</replaceable>变量必须是一个数组，并且它接收数组值的连续切片，其中每一个切片都有<literal>SLICE</literal>指定的维度数。这里是一个通过一维切片迭代的例子：

<programlisting>
CREATE FUNCTION scan_rows(int[]) RETURNS void AS $$
DECLARE
  x int[];
BEGIN
  FOREACH x SLICE 1 IN ARRAY $1
  LOOP
    RAISE NOTICE 'row = %', x;
  END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT scan_rows(ARRAY[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]);

NOTICE:  row = {1,2,3}
NOTICE:  row = {4,5,6}
NOTICE:  row = {7,8,9}
NOTICE:  row = {10,11,12}
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=c6d97759ef7f9a067122c16cb7a5e813 -->
   </sect2>

   <sect2 id="plpgsql-error-trapping">
<!-- pgdoc-cn_start sig_en=33720809531e26832b215af3db19d54d sig_cn_org=None source=14.1 
    <title>Trapping Errors</title>
________________________________________________________-->
    <title>俘获错误</title>
<!-- pgdoc-cn_end sig_en=33720809531e26832b215af3db19d54d -->

<!-- pgdoc-cn_start sig_en=f2fdba73bfa53b1128286b83d5e92144 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>exceptions</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>exceptions</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=f2fdba73bfa53b1128286b83d5e92144 -->

<!-- pgdoc-cn_start sig_en=87ce92dfeaaa98678d7ee27abcd86ac8 sig_cn_org=None source=14.1 
    <para>
     By default, any error occurring in a <application>PL/pgSQL</application>
     function aborts execution of the function and the
     surrounding transaction.  You can trap errors and recover
     from them by using a <command>BEGIN</command> block with an
     <literal>EXCEPTION</literal> clause.  The syntax is an extension of the
     normal syntax for a <command>BEGIN</command> block:

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
<optional> DECLARE
    <replaceable>declarations</replaceable> </optional>
BEGIN
    <replaceable>statements</replaceable>
EXCEPTION
    WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
        <replaceable>handler_statements</replaceable>
    <optional> WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
          <replaceable>handler_statements</replaceable>
      ... </optional>
END;
</synopsis>
    </para>
________________________________________________________-->
    <para>
     默认情况下，<application>PL/pgSQL</application>函数中发生的任何错误都会中止函数和周围事务的执行。你可以使用一个带有<literal>EXCEPTION</literal>子句的<command>BEGIN</command>块俘获错误并且从中恢复。其语法是<command>BEGIN</command>块通常的语法的一个扩展：

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
<optional> DECLARE
    <replaceable>declarations</replaceable> </optional>
BEGIN
    <replaceable>statements</replaceable>
EXCEPTION
    WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
        <replaceable>handler_statements</replaceable>
    <optional> WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
          <replaceable>handler_statements</replaceable>
      ... </optional>
END;
</synopsis>
    </para>
<!-- pgdoc-cn_end sig_en=87ce92dfeaaa98678d7ee27abcd86ac8 -->

<!-- pgdoc-cn_start sig_en=0812841266e6d45b17c5b96096bba8f5 sig_cn_org=None source=14.1 
    <para>
     If no error occurs, this form of block simply executes all the
     <replaceable>statements</replaceable>, and then control passes
     to the next statement after <literal>END</literal>.  But if an error
     occurs within the <replaceable>statements</replaceable>, further
     processing of the <replaceable>statements</replaceable> is
     abandoned, and control passes to the <literal>EXCEPTION</literal> list.
     The list is searched for the first <replaceable>condition</replaceable>
     matching the error that occurred.  If a match is found, the
     corresponding <replaceable>handler_statements</replaceable> are
     executed, and then control passes to the next statement after
     <literal>END</literal>.  If no match is found, the error propagates out
     as though the <literal>EXCEPTION</literal> clause were not there at all:
     the error can be caught by an enclosing block with
     <literal>EXCEPTION</literal>, or if there is none it aborts processing
     of the function.
    </para>
________________________________________________________-->
    <para>
     如果没有发生错误，这种形式的块只是简单地执行所有<replaceable>statements</replaceable>， 并且接着控制转到<literal>END</literal>之后的下一个语句。但是如果在<replaceable>statements</replaceable>内发生了一个错误，则会放弃对<replaceable>statements</replaceable>的进一步处理，然后控制会转到<literal>EXCEPTION</literal>列表。系统会在列表中寻找匹配所发生错误的第一个<replaceable>condition</replaceable>。如果找到一个匹配，则执行对应的<replaceable>handler_statements</replaceable>，并且接着把控制转到<literal>END</literal>之后的下一个语句。如果没有找到匹配，该错误就会传播出去，就好像根本没有<literal>EXCEPTION</literal>一样：错误可以被一个带有<literal>EXCEPTION</literal>的闭合块捕捉，如果没有<literal>EXCEPTION</literal>则中止该函数的处理。
    </para>
<!-- pgdoc-cn_end sig_en=0812841266e6d45b17c5b96096bba8f5 -->

<!-- pgdoc-cn_start sig_en=d639ec49a465cec9c9c3c17e92aae462 sig_cn_org=None source=14.1 
    <para>
     The <replaceable>condition</replaceable> names can be any of
     those shown in <xref linkend="errcodes-appendix"/>.  A category
     name matches any error within its category.  The special
     condition name <literal>OTHERS</literal> matches every error type except
     <literal>QUERY_CANCELED</literal> and <literal>ASSERT_FAILURE</literal>.
     (It is possible, but often unwise, to trap those two error types
     by name.)  Condition names are
     not case-sensitive.  Also, an error condition can be specified
     by <literal>SQLSTATE</literal> code; for example these are equivalent:
<programlisting>
WHEN division_by_zero THEN ...
WHEN SQLSTATE '22012' THEN ...
</programlisting>
    </para>
________________________________________________________-->
    <para>
     <replaceable>condition</replaceable>的名字可以是<xref linkend="errcodes-appendix"/>中显示的任何名字。一个分类名匹配其中所有的错误。特殊的条件名<literal>OTHERS</literal>匹配除了<literal>QUERY_CANCELED</literal>和<literal>ASSERT_FAILURE</literal>之外的所有错误类型（虽然通常并不明智，还是可以用名字捕获这两种错误类型）。条件名是大小写无关的。一个错误条件也可以通过<literal>SQLSTATE</literal>代码指定，例如以下是等价的：
<programlisting>
WHEN division_by_zero THEN ...
WHEN SQLSTATE '22012' THEN ...
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=d639ec49a465cec9c9c3c17e92aae462 -->

<!-- pgdoc-cn_start sig_en=2d6bd8ae5bc603f3b833bfc94c460eea sig_cn_org=None source=14.1 
    <para>
     If a new error occurs within the selected
     <replaceable>handler_statements</replaceable>, it cannot be caught
     by this <literal>EXCEPTION</literal> clause, but is propagated out.
     A surrounding <literal>EXCEPTION</literal> clause could catch it.
    </para>
________________________________________________________-->
    <para>
     如果在选中的<replaceable>handler_statements</replaceable>内发生了新的错误，那么它不能被这个<literal>EXCEPTION</literal>子句捕获，而是被传播出去。一个外层的<literal>EXCEPTION</literal>子句可以捕获它。
    </para>
<!-- pgdoc-cn_end sig_en=2d6bd8ae5bc603f3b833bfc94c460eea -->

<!-- pgdoc-cn_start sig_en=96e5e8506048ad8179545a3b0a1d9d53 sig_cn_org=None source=14.1 
    <para>
     When an error is caught by an <literal>EXCEPTION</literal> clause,
     the local variables of the <application>PL/pgSQL</application> function
     remain as they were when the error occurred, but all changes
     to persistent database state within the block are rolled back.
     As an example, consider this fragment:

<programlisting>
INSERT INTO mytab(firstname, lastname) VALUES('Tom', 'Jones');
BEGIN
    UPDATE mytab SET firstname = 'Joe' WHERE lastname = 'Jones';
    x := x + 1;
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        RAISE NOTICE 'caught division_by_zero';
        RETURN x;
END;
</programlisting>

     When control reaches the assignment to <literal>y</literal>, it will
     fail with a <literal>division_by_zero</literal> error.  This will be caught by
     the <literal>EXCEPTION</literal> clause.  The value returned in the
     <command>RETURN</command> statement will be the incremented value of
     <literal>x</literal>, but the effects of the <command>UPDATE</command> command will
     have been rolled back.  The <command>INSERT</command> command preceding the
     block is not rolled back, however, so the end result is that the database
     contains <literal>Tom Jones</literal> not <literal>Joe Jones</literal>.
    </para>
________________________________________________________-->
    <para>
     当一个错误被<literal>EXCEPTION</literal>捕获时，<application>PL/pgSQL</application>函数的局部变量会保持错误发生时的值，但是该块中所有对持久数据库状态的改变都会被回滚。例如，考虑这个片段：

<programlisting>
INSERT INTO mytab(firstname, lastname) VALUES('Tom', 'Jones');
BEGIN
    UPDATE mytab SET firstname = 'Joe' WHERE lastname = 'Jones';
    x := x + 1;
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        RAISE NOTICE 'caught division_by_zero';
        RETURN x;
END;
</programlisting>

     当控制到达对<literal>y</literal>赋值的地方时，它会带着一个<literal>division_by_zero</literal>错误失败。这个错误将被<literal>EXCEPTION</literal>子句捕获。而在<command>RETURN</command>语句中返回的值将是<literal>x</literal>增加过后的值。但是<command>UPDATE</command>命令的效果将已经被回滚。不过，在该块之前的<command>INSERT</command>将不会被回滚，因此最终的结果是数据库包含<literal>Tom Jones</literal>但不包含<literal>Joe Jones</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=96e5e8506048ad8179545a3b0a1d9d53 -->

    <tip>
<!-- pgdoc-cn_start sig_en=51585423fb004840e53bf002ecc0c1ed sig_cn_org=None source=14.1 
     <para>
      A block containing an <literal>EXCEPTION</literal> clause is significantly
      more expensive to enter and exit than a block without one.  Therefore,
      don't use <literal>EXCEPTION</literal> without need.
     </para>
________________________________________________________-->
     <para>
      进入和退出一个包含<literal>EXCEPTION</literal>子句的块要比不包含<literal>EXCEPTION</literal>的块开销大的多。因此，只在必要的时候使用<literal>EXCEPTION</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=51585423fb004840e53bf002ecc0c1ed -->
    </tip>

    <example id="plpgsql-upsert-example">
<!-- pgdoc-cn_start sig_en=6bd33409947b5f775115164fe0d884fd sig_cn_org=None source=14.1 
    <title>Exceptions with <command>UPDATE</command>/<command>INSERT</command></title>
________________________________________________________-->
    <title><command>UPDATE</command>/<command>INSERT</command>的异常</title>
<!-- pgdoc-cn_end sig_en=6bd33409947b5f775115164fe0d884fd -->
<!-- pgdoc-cn_start sig_en=429e94d7168ecae3bc634f0e4f00931a sig_cn_org=None source=14.1 
    <para>

    This example uses exception handling to perform either
    <command>UPDATE</command> or <command>INSERT</command>, as appropriate.  It is
    recommended that applications use <command>INSERT</command> with
    <literal>ON CONFLICT DO UPDATE</literal> rather than actually using
    this pattern.  This example serves primarily to illustrate use of
    <application>PL/pgSQL</application> control flow structures:

<programlisting>
CREATE TABLE db (a INT PRIMARY KEY, b TEXT);

CREATE FUNCTION merge_db(key INT, data TEXT) RETURNS VOID AS
$$
BEGIN
    LOOP
        -&minus; first try to update the key
        UPDATE db SET b = data WHERE a = key;
        IF found THEN
            RETURN;
        END IF;
        -&minus; not there, so try to insert the key
        -&minus; if someone else inserts the same key concurrently,
        -&minus; we could get a unique-key failure
        BEGIN
            INSERT INTO db(a,b) VALUES (key, data);
            RETURN;
        EXCEPTION WHEN unique_violation THEN
            -&minus; Do nothing, and loop to try the UPDATE again.
        END;
    END LOOP;
END;
$$
LANGUAGE plpgsql;

SELECT merge_db(1, 'david');
SELECT merge_db(1, 'dennis');
</programlisting>

     This coding assumes the <literal>unique_violation</literal> error is caused by
     the <command>INSERT</command>, and not by, say, an <command>INSERT</command> in a
     trigger function on the table.  It might also misbehave if there is
     more than one unique index on the table, since it will retry the
     operation regardless of which index caused the error.
     More safety could be had by using the
     features discussed next to check that the trapped error was the one
     expected.
    </para>
________________________________________________________-->
    <para>
    这个例子使用异常处理来酌情执行<command>UPDATE</command>或
    <command>INSERT</command>。我们推荐应用使用带有
    <literal>ON CONFLICT DO UPDATE</literal>的<command>INSERT</command>
    而不是真正使用这种模式。下面的例子主要是为了展示
    <application>PL/pgSQL</application>如何控制流程：

<programlisting>
CREATE TABLE db (a INT PRIMARY KEY, b TEXT);

CREATE FUNCTION merge_db(key INT, data TEXT) RETURNS VOID AS
$$
BEGIN
    LOOP
        -- 首先尝试更新见
        UPDATE db SET b = data WHERE a = key;
        IF found THEN
            RETURN;
        END IF;
        -- 不在这里，那么尝试插入该键
        -- 如果其他某人并发地插入同一个键，
        -- 我们可能得到一个唯一键失败
        BEGIN
            INSERT INTO db(a,b) VALUES (key, data);
            RETURN;
        EXCEPTION WHEN unique_violation THEN
            -- 什么也不做，并且循环再次尝试 UPDATE
        END;
    END LOOP;
END;
$$
LANGUAGE plpgsql;

SELECT merge_db(1, 'david');
SELECT merge_db(1, 'dennis');
</programlisting>

     这段代码假定<literal>unique_violation</literal>错误是<command>INSERT</command>造成，并且不是由该表上一个触发器函数中的<command>INSERT</command>导致。如果在该表上有多于一个唯一索引，也可能会发生不正确的行为，因为不管哪个索引导致该错误它都将重试该操作。通过接下来要讨论的特性来检查被捕获的错误是否为所预期的会更安全。
    </para>
<!-- pgdoc-cn_end sig_en=429e94d7168ecae3bc634f0e4f00931a -->
    </example>

   <sect3 id="plpgsql-exception-diagnostics">
<!-- pgdoc-cn_start sig_en=e8e8cca7ee0876769474542866f8e56c sig_cn_org=None source=14.1 
    <title>Obtaining Information about an Error</title>
________________________________________________________-->
    <title>得到有关一个错误的信息</title>
<!-- pgdoc-cn_end sig_en=e8e8cca7ee0876769474542866f8e56c -->

<!-- pgdoc-cn_start sig_en=cf348e1d80f570a1d80616ca13923e5d sig_cn_org=None source=14.1 
    <para>
     Exception handlers frequently need to identify the specific error that
     occurred.  There are two ways to get information about the current
     exception in <application>PL/pgSQL</application>: special variables and the
     <command>GET STACKED DIAGNOSTICS</command> command.
    </para>
________________________________________________________-->
    <para>
     异常处理器经常被用来标识发生的特定错误。有两种方法来得到<application>PL/pgSQL</application>中当前异常的信息：特殊变量和<command>GET STACKED DIAGNOSTICS</command>命令。
    </para>
<!-- pgdoc-cn_end sig_en=cf348e1d80f570a1d80616ca13923e5d -->

<!-- pgdoc-cn_start sig_en=0afb6adba8dc0b05b25221db002d535e sig_cn_org=None source=14.1 
    <para>
     Within an exception handler, the special variable
     <varname>SQLSTATE</varname> contains the error code that corresponds to
     the exception that was raised (refer to <xref linkend="errcodes-table"/>
     for a list of possible error codes). The special variable
     <varname>SQLERRM</varname> contains the error message associated with the
     exception. These variables are undefined outside exception handlers.
    </para>
________________________________________________________-->
    <para>
     在一个异常处理器内，特殊变量<varname>SQLSTATE</varname>包含了对应于被抛出异常的错误代码（可能的错误代码列表见<xref linkend="errcodes-table"/>）。特殊变量<varname>SQLERRM</varname>包含与该异常相关的错误消息。这些变量在异常处理器外是未定义的。
    </para>
<!-- pgdoc-cn_end sig_en=0afb6adba8dc0b05b25221db002d535e -->

<!-- pgdoc-cn_start sig_en=cbcdbdad160ef34b0e4906185dbf8ff2 sig_cn_org=None source=14.1 
    <para>
     Within an exception handler, one may also retrieve
     information about the current exception by using the
     <command>GET STACKED DIAGNOSTICS</command> command, which has the form:

<synopsis>
GET STACKED DIAGNOSTICS <replaceable>variable</replaceable> { = | := } <replaceable>item</replaceable> <optional> , ... </optional>;
</synopsis>

     Each <replaceable>item</replaceable> is a key word identifying a status
     value to be assigned to the specified <replaceable>variable</replaceable>
     (which should be of the right data type to receive it).  The currently
     available status items are shown
     in <xref linkend="plpgsql-exception-diagnostics-values"/>.
    </para>
________________________________________________________-->
    <para>
     在一个异常处理器内，我们也可以用<command>GET STACKED DIAGNOSTICS</command>命令检索有关当前异常的信息，该命令的形式为：

<synopsis>
GET STACKED DIAGNOSTICS <replaceable>variable</replaceable> { = | := } <replaceable>item</replaceable> <optional> , ... </optional>;
</synopsis>

     每个<replaceable>item</replaceable>是一个关键词，它标识一个被赋予给指定<replaceable>变量</replaceable>（应该具有接收该值的正确数据类型）的状态值。<xref linkend="plpgsql-exception-diagnostics-values"/>中显示了当前可用的状态项。
    </para>
<!-- pgdoc-cn_end sig_en=cbcdbdad160ef34b0e4906185dbf8ff2 -->

     <table id="plpgsql-exception-diagnostics-values">
<!-- pgdoc-cn_start sig_en=52319bceedbb4794d7ca220b98345d94 sig_cn_org=None source=14.1 
      <title>Error Diagnostics Items</title>
________________________________________________________-->
      <title>错误诊断项</title>
<!-- pgdoc-cn_end sig_en=52319bceedbb4794d7ca220b98345d94 -->
      <tgroup cols="3">
       <colspec colname="col1" colwidth="2*"/>
       <colspec colname="col2" colwidth="1*"/>
       <colspec colname="col3" colwidth="2*"/>
       <thead>
<!-- pgdoc-cn_start sig_en=4b45428ed041b842ea82bb4c6f3a0da5 sig_cn_org=None source=14.1 
        <row>
         <entry>Name</entry>
         <entry>Type</entry>
         <entry>Description</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>名称</entry>
         <entry>类型</entry>
         <entry>描述</entry>
        </row>
<!-- pgdoc-cn_end sig_en=4b45428ed041b842ea82bb4c6f3a0da5 -->
       </thead>
       <tbody>
<!-- pgdoc-cn_start sig_en=01fc9a502c76f1a66d19ac88dae8a56b sig_cn_org=None source=14.1 
        <row>
         <entry><literal>RETURNED_SQLSTATE</literal></entry>
         <entry><type>text</type></entry>
         <entry>the SQLSTATE error code of the exception</entry>
        </row>
________________________________________________________-->
        <row>
         <entry><literal>RETURNED_SQLSTATE</literal></entry>
         <entry><type>text</type></entry>
         <entry>该异常的 SQLSTATE 错误代码</entry>
        </row>
<!-- pgdoc-cn_end sig_en=01fc9a502c76f1a66d19ac88dae8a56b -->
<!-- pgdoc-cn_start sig_en=3d02463a2cea47c3c763761aa13aad68 sig_cn_org=None source=14.1 
        <row>
         <entry><literal>COLUMN_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>the name of the column related to exception</entry>
        </row>
________________________________________________________-->
        <row>
         <entry><literal>COLUMN_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>与异常相关的列名</entry>
        </row>
<!-- pgdoc-cn_end sig_en=3d02463a2cea47c3c763761aa13aad68 -->
<!-- pgdoc-cn_start sig_en=f02f1ec61244f597610e6b04308d3973 sig_cn_org=None source=14.1 
        <row>
         <entry><literal>CONSTRAINT_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>the name of the constraint related to exception</entry>
        </row>
________________________________________________________-->
        <row>
         <entry><literal>CONSTRAINT_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>与异常相关的约束名</entry>
        </row>
<!-- pgdoc-cn_end sig_en=f02f1ec61244f597610e6b04308d3973 -->
<!-- pgdoc-cn_start sig_en=c4c0860b49cfb9aa2aa000aa04f50658 sig_cn_org=None source=14.1 
        <row>
         <entry><literal>PG_DATATYPE_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>the name of the data type related to exception</entry>
        </row>
________________________________________________________-->
        <row>
         <entry><literal>PG_DATATYPE_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>与异常相关的数据类型名</entry>
        </row>
<!-- pgdoc-cn_end sig_en=c4c0860b49cfb9aa2aa000aa04f50658 -->
<!-- pgdoc-cn_start sig_en=6c4af937249b348e7d8465c9a7aaa0c8 sig_cn_org=None source=14.1 
        <row>
         <entry><literal>MESSAGE_TEXT</literal></entry>
         <entry><type>text</type></entry>
         <entry>the text of the exception's primary message</entry>
        </row>
________________________________________________________-->
        <row>
         <entry><literal>MESSAGE_TEXT</literal></entry>
         <entry><type>text</type></entry>
         <entry>该异常的主要消息的文本</entry>
        </row>
<!-- pgdoc-cn_end sig_en=6c4af937249b348e7d8465c9a7aaa0c8 -->
<!-- pgdoc-cn_start sig_en=1a519eee3630b6dd3a2b80f12df4fd62 sig_cn_org=None source=14.1 
        <row>
         <entry><literal>TABLE_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>the name of the table related to exception</entry>
        </row>
________________________________________________________-->
        <row>
         <entry><literal>TABLE_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>与异常相关的表名</entry>
        </row>
<!-- pgdoc-cn_end sig_en=1a519eee3630b6dd3a2b80f12df4fd62 -->
<!-- pgdoc-cn_start sig_en=9ee0b4e4e1f86f9b64cbc8feca7bc33e sig_cn_org=None source=14.1 
        <row>
         <entry><literal>SCHEMA_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>the name of the schema related to exception</entry>
        </row>
________________________________________________________-->
        <row>
         <entry><literal>SCHEMA_NAME</literal></entry>
         <entry><type>text</type></entry>
         <entry>与异常相关的模式名</entry>
        </row>
<!-- pgdoc-cn_end sig_en=9ee0b4e4e1f86f9b64cbc8feca7bc33e -->
<!-- pgdoc-cn_start sig_en=303948ac6ab0349bfa0bf4aa8f90b436 sig_cn_org=None source=14.1 
        <row>
         <entry><literal>PG_EXCEPTION_DETAIL</literal></entry>
         <entry><type>text</type></entry>
         <entry>the text of the exception's detail message, if any</entry>
        </row>
________________________________________________________-->
        <row>
         <entry><literal>PG_EXCEPTION_DETAIL</literal></entry>
         <entry><type>text</type></entry>
         <entry>该异常的详细消息文本（如果有）</entry>
        </row>
<!-- pgdoc-cn_end sig_en=303948ac6ab0349bfa0bf4aa8f90b436 -->
<!-- pgdoc-cn_start sig_en=9ac035b9d8e82d88051c092f718d6da9 sig_cn_org=None source=14.1 
        <row>
         <entry><literal>PG_EXCEPTION_HINT</literal></entry>
         <entry><type>text</type></entry>
         <entry>the text of the exception's hint message, if any</entry>
        </row>
________________________________________________________-->
        <row>
         <entry><literal>PG_EXCEPTION_HINT</literal></entry>
         <entry><type>text</type></entry>
         <entry>该异常的提示消息文本（如果有）</entry>
        </row>
<!-- pgdoc-cn_end sig_en=9ac035b9d8e82d88051c092f718d6da9 -->
<!-- pgdoc-cn_start sig_en=2e5fc40c640648f4dad9e478bf66add5 sig_cn_org=None source=14.1 
        <row>
         <entry><literal>PG_EXCEPTION_CONTEXT</literal></entry>
         <entry><type>text</type></entry>
         <entry>line(s) of text describing the call stack at the time of the
          exception (see <xref linkend="plpgsql-call-stack"/>)</entry>
        </row>
________________________________________________________-->
        <row>
         <entry><literal>PG_EXCEPTION_CONTEXT</literal></entry>
         <entry><type>text</type></entry>
         <entry>描述产生异常时调用栈的文本行（见<xref linkend="plpgsql-call-stack"/>）</entry>
        </row>
<!-- pgdoc-cn_end sig_en=2e5fc40c640648f4dad9e478bf66add5 -->
       </tbody>
      </tgroup>
     </table>

<!-- pgdoc-cn_start sig_en=def605d1f6f2ce06912ae5cc2f162b86 sig_cn_org=None source=14.1 
    <para>
     If the exception did not set a value for an item, an empty string
     will be returned.
    </para>
________________________________________________________-->
    <para>
     如果异常没有为一个项设置值，将返回一个空字符串。
    </para>
<!-- pgdoc-cn_end sig_en=def605d1f6f2ce06912ae5cc2f162b86 -->

<!-- pgdoc-cn_start sig_en=87a89fb20cb31d0a3f4e5c24a5b21d8a sig_cn_org=None source=14.1 
    <para>
     Here is an example:
<programlisting>
DECLARE
  text_var1 text;
  text_var2 text;
  text_var3 text;
BEGIN
  -&minus; some processing which might cause an exception
  ...
EXCEPTION WHEN OTHERS THEN
  GET STACKED DIAGNOSTICS text_var1 = MESSAGE_TEXT,
                          text_var2 = PG_EXCEPTION_DETAIL,
                          text_var3 = PG_EXCEPTION_HINT;
END;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     这里是一个例子：
<programlisting>
DECLARE
  text_var1 text;
  text_var2 text;
  text_var3 text;
BEGIN
  -- 某些可能导致异常的处理
  ...
EXCEPTION WHEN OTHERS THEN
  GET STACKED DIAGNOSTICS text_var1 = MESSAGE_TEXT,
                          text_var2 = PG_EXCEPTION_DETAIL,
                          text_var3 = PG_EXCEPTION_HINT;
END;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=87a89fb20cb31d0a3f4e5c24a5b21d8a -->
   </sect3>
  </sect2>

  <sect2 id="plpgsql-call-stack">
<!-- pgdoc-cn_start sig_en=cba99f7ad5d70466d302d820af9d9a64 sig_cn_org=None source=14.1 
   <title>Obtaining Execution Location Information</title>
________________________________________________________-->
   <title>获得执行位置信息</title>
<!-- pgdoc-cn_end sig_en=cba99f7ad5d70466d302d820af9d9a64 -->

<!-- pgdoc-cn_start sig_en=8e98f4a0606883c9286e7d300c9d83ad sig_cn_org=None source=14.1 
   <para>
    The <command>GET DIAGNOSTICS</command> command, previously described
    in <xref linkend="plpgsql-statements-diagnostics"/>, retrieves information
    about current execution state (whereas the <command>GET STACKED
    DIAGNOSTICS</command> command discussed above reports information about
    the execution state as of a previous error).  Its <literal>PG_CONTEXT</literal>
    status item is useful for identifying the current execution
    location.  <literal>PG_CONTEXT</literal> returns a text string with line(s)
    of text describing the call stack.  The first line refers to the current
    function and currently executing <command>GET DIAGNOSTICS</command>
    command.  The second and any subsequent lines refer to calling functions
    further up the call stack.  For example:

<programlisting>
CREATE OR REPLACE FUNCTION outer_func() RETURNS integer AS $$
BEGIN
  RETURN inner_func();
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION inner_func() RETURNS integer AS $$
DECLARE
  stack text;
BEGIN
  GET DIAGNOSTICS stack = PG_CONTEXT;
  RAISE NOTICE E'-&minus;- Call Stack -&minus;-\n%', stack;
  RETURN 1;
END;
$$ LANGUAGE plpgsql;

SELECT outer_func();

NOTICE:  -&minus;- Call Stack -&minus;-
PL/pgSQL function inner_func() line 5 at GET DIAGNOSTICS
PL/pgSQL function outer_func() line 3 at RETURN
CONTEXT:  PL/pgSQL function outer_func() line 3 at RETURN
 outer_func
 -&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
           1
(1 row)
</programlisting>

   </para>
________________________________________________________-->
   <para>
    <command>GET DIAGNOSTICS</command>（之前在<xref linkend="plpgsql-statements-diagnostics"/>中描述）命令检索有关当前执行状态的信息（反之上文讨论的<command>GET STACKED DIAGNOSTICS</command>命令会把有关执行状态的信息报告成一个以前的错误）。它的<literal>PG_CONTEXT</literal>状态项可用于标识当前执行位置。状态项<literal>PG_CONTEXT</literal>将返回一个文本字符串，其中有描述该调用栈的多行文本。第一行会指向当前函数以及当前正在执行<command>GET DIAGNOSTICS</command>的命令。第二行及其后的行表示调用栈中更上层的调用函数。例如：

<programlisting>
CREATE OR REPLACE FUNCTION outer_func() RETURNS integer AS $$
BEGIN
  RETURN inner_func();
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION inner_func() RETURNS integer AS $$
DECLARE
  stack text;
BEGIN
  GET DIAGNOSTICS stack = PG_CONTEXT;
  RAISE NOTICE E'--- Call Stack ---\n%', stack;
  RETURN 1;
END;
$$ LANGUAGE plpgsql;

SELECT outer_func();

NOTICE:  --- Call Stack ---
PL/pgSQL function inner_func() line 5 at GET DIAGNOSTICS
PL/pgSQL function outer_func() line 3 at RETURN
CONTEXT:  PL/pgSQL function outer_func() line 3 at RETURN
 outer_func
 ------------
           1
(1 row)
</programlisting>

   </para>
<!-- pgdoc-cn_end sig_en=8e98f4a0606883c9286e7d300c9d83ad -->

<!-- pgdoc-cn_start sig_en=d6e9550d8a1ee957d8f17578d6337242 sig_cn_org=None source=14.1 
   <para>
    <literal>GET STACKED DIAGNOSTICS ... PG_EXCEPTION_CONTEXT</literal>
    returns the same sort of stack trace, but describing the location
    at which an error was detected, rather than the current location.
   </para>
________________________________________________________-->
   <para>
    <literal>GET STACKED DIAGNOSTICS ... PG_EXCEPTION_CONTEXT</literal>返回同类的栈跟踪，但是它描述检测到错误的位置而不是当前位置。
   </para>
<!-- pgdoc-cn_end sig_en=d6e9550d8a1ee957d8f17578d6337242 -->
  </sect2>
  </sect1>

  <sect1 id="plpgsql-cursors">
<!-- pgdoc-cn_start sig_en=983b8076885f3d5e206a2a9605ac683e sig_cn_org=None source=14.1 
   <title>Cursors</title>
________________________________________________________-->
   <title>游标</title>
<!-- pgdoc-cn_end sig_en=983b8076885f3d5e206a2a9605ac683e -->

<!-- pgdoc-cn_start sig_en=7ab51f12cd345d17d91987509131e268 sig_cn_org=None source=14.1 
   <indexterm zone="plpgsql-cursors">
    <primary>cursor</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="plpgsql-cursors">
    <primary>cursor</primary>
    <secondary>在 PL/pgSQL 中</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=7ab51f12cd345d17d91987509131e268 -->

<!-- pgdoc-cn_start sig_en=d983e491106ed89c0e1896157485d559 sig_cn_org=None source=14.1 
   <para>
    Rather than executing a whole query at once, it is possible to set
    up a <firstterm>cursor</firstterm> that encapsulates the query, and then read
    the query result a few rows at a time. One reason for doing this is
    to avoid memory overrun when the result contains a large number of
    rows. (However, <application>PL/pgSQL</application> users do not normally need
    to worry about that, since <literal>FOR</literal> loops automatically use a cursor
    internally to avoid memory problems.) A more interesting usage is to
    return a reference to a cursor that a function has created, allowing the
    caller to read the rows. This provides an efficient way to return
    large row sets from functions.
   </para>
________________________________________________________-->
   <para>
    和一次执行整个查询不同，可以建立一个<firstterm>游标</firstterm>来封装该查询，并且接着一次读取该查询结果的一些行。这样做的原因之一是在结果中包含大量行时避免内存不足（不过，<application>PL/pgSQL</application>用户通常不需要担心这些，因为<literal>FOR</literal>循环在内部会自动使用一个游标来避免内存问题）。一种更有趣的用法是返回一个函数已经创建的游标的引用，允许调用者读取行。这提供了一种有效的方法从函数中返回大型行集。
   </para>
<!-- pgdoc-cn_end sig_en=d983e491106ed89c0e1896157485d559 -->

   <sect2 id="plpgsql-cursor-declarations">
<!-- pgdoc-cn_start sig_en=4f39e6dbe3a0f8d0f46b753927302268 sig_cn_org=None source=14.1 
    <title>Declaring Cursor Variables</title>
________________________________________________________-->
    <title>声明游标变量</title>
<!-- pgdoc-cn_end sig_en=4f39e6dbe3a0f8d0f46b753927302268 -->

<!-- pgdoc-cn_start sig_en=1551d23fe40742511110fc5f748973eb sig_cn_org=None source=14.1 
    <para>
     All access to cursors in <application>PL/pgSQL</application> goes through
     cursor variables, which are always of the special data type
     <type>refcursor</type>.  One way to create a cursor variable
     is just to declare it as a variable of type <type>refcursor</type>.
     Another way is to use the cursor declaration syntax,
     which in general is:
<synopsis>
<replaceable>name</replaceable> <optional> <optional> NO </optional> SCROLL </optional> CURSOR <optional> ( <replaceable>arguments</replaceable> ) </optional> FOR <replaceable>query</replaceable>;
</synopsis>
     (<literal>FOR</literal> can be replaced by <literal>IS</literal> for
     <productname>Oracle</productname> compatibility.)
     If <literal>SCROLL</literal> is specified, the cursor will be capable of
     scrolling backward; if <literal>NO SCROLL</literal> is specified, backward
     fetches will be rejected; if neither specification appears, it is
     query-dependent whether backward fetches will be allowed.
     <replaceable>arguments</replaceable>, if specified, is a
     comma-separated list of pairs <literal><replaceable>name</replaceable>
     <replaceable>datatype</replaceable></literal> that define names to be
     replaced by parameter values in the given query.  The actual
     values to substitute for these names will be specified later,
     when the cursor is opened.
    </para>
________________________________________________________-->
    <para>
     所有在<application>PL/pgSQL</application>中对游标的访问都会通过游标变量，它总是特殊的数据类型<type>refcursor</type>。创建游标变量的一种方法是把它声明为一个类型为<type>refcursor</type>的变量。另外一种方法是使用游标声明语法，通常是：
<synopsis>
<replaceable>name</replaceable> <optional> <optional> NO </optional> SCROLL </optional> CURSOR <optional> ( <replaceable>arguments</replaceable> ) </optional> FOR <replaceable>query</replaceable>;
</synopsis>
     （为了对<productname>Oracle</productname>的兼容性，可以用<literal>IS</literal>替代<literal>FOR</literal>）。如果指定了<literal>SCROLL</literal>，那么游标可以反向滚动；如果指定了<literal>NO SCROLL</literal>，那么反向取的动作会被拒绝；如果二者都没有被指定，那么能否进行反向取就取决于查询。如果指定了<replaceable>arguments</replaceable>， 那么它是一个逗号分隔的<literal><replaceable>name</replaceable> <replaceable>datatype</replaceable></literal>对的列表， 它们定义在给定查询中要被参数值替换的名称。实际用于替换这些名字的值将在游标被打开之后指定。
    </para>
<!-- pgdoc-cn_end sig_en=1551d23fe40742511110fc5f748973eb -->
<!-- pgdoc-cn_start sig_en=e16c5c6874d49edab97519cfdc38b503 sig_cn_org=None source=14.1 
    <para>
     Some examples:
<programlisting>
DECLARE
    curs1 refcursor;
    curs2 CURSOR FOR SELECT * FROM tenk1;
    curs3 CURSOR (key integer) FOR SELECT * FROM tenk1 WHERE unique1 = key;
</programlisting>
     All three of these variables have the data type <type>refcursor</type>,
     but the first can be used with any query, while the second has
     a fully specified query already <firstterm>bound</firstterm> to it, and the last
     has a parameterized query bound to it.  (<literal>key</literal> will be
     replaced by an integer parameter value when the cursor is opened.)
     The variable <literal>curs1</literal>
     is said to be <firstterm>unbound</firstterm> since it is not bound to
     any particular query.
    </para>
________________________________________________________-->
    <para>
     一些例子：
<programlisting>
DECLARE
    curs1 refcursor;
    curs2 CURSOR FOR SELECT * FROM tenk1;
    curs3 CURSOR (key integer) FOR SELECT * FROM tenk1 WHERE unique1 = key;
</programlisting>
     所有这三个变量都是<type>refcursor</type>类型，但是第一个可以用于任何查询，而第二个已经被<firstterm>绑定</firstterm>了一个完全指定的查询，并且最后一个被绑定了一个参数化查询。（游标被打开时，<literal>key</literal>将被一个整数参数值替换）。变量<literal>curs1</literal>被称为<firstterm>未绑定</firstterm>，因为它没有被绑定到任何特定查询。
    </para>
<!-- pgdoc-cn_end sig_en=e16c5c6874d49edab97519cfdc38b503 -->

<!-- pgdoc-cn_start sig_en=9c88ec4cf2f5b22beb9f93fbe4bc3895 sig_cn_org=None source=14.1 
    <para>
     The <literal>SCROLL</literal> option cannot be used when the cursor's
     query uses <literal>FOR UPDATE/SHARE</literal>.  Also, it is
     best to use <literal>NO SCROLL</literal> with a query that involves
     volatile functions.  The implementation of <literal>SCROLL</literal>
     assumes that re-reading the query's output will give consistent
     results, which a volatile function might not do.
    </para>
________________________________________________________-->
    <para>
        如果游标查询<literal>FOR UPDATE/SHARE</literal>使用，则该<literal>SCROLL</literal>选项不可用。此外，最好用于涉及可变函数的查询<literal>NO SCROLL</literal>。 <literal>SCROLL</literal>的实现假定重新加载查询的输出将返回一致的结果，而易失性函数并非如此。
        </para>
<!-- pgdoc-cn_end sig_en=9c88ec4cf2f5b22beb9f93fbe4bc3895 -->
   </sect2>

   <sect2 id="plpgsql-cursor-opening">
<!-- pgdoc-cn_start sig_en=1efd31de3f9567e6050326e8b334bc7d sig_cn_org=None source=14.1 
    <title>Opening Cursors</title>
________________________________________________________-->
    <title>打开游标</title>
<!-- pgdoc-cn_end sig_en=1efd31de3f9567e6050326e8b334bc7d -->

<!-- pgdoc-cn_start sig_en=383274f2217341aef8c95dfbe1b3ce51 sig_cn_org=None source=14.1 
    <para>
     Before a cursor can be used to retrieve rows, it must be
     <firstterm>opened</firstterm>. (This is the equivalent action to the SQL
     command <command>DECLARE CURSOR</command>.) <application>PL/pgSQL</application> has
     three forms of the <command>OPEN</command> statement, two of which use unbound
     cursor variables while the third uses a bound cursor variable.
    </para>
________________________________________________________-->
    <para>
     在一个游标可以被用来检索行之前，它必需先被<firstterm>打开</firstterm>（这是和 SQL 命令<command>DECLARE CURSOR</command>等效的操作）。<application>PL/pgSQL</application>有三种形式的<command>OPEN</command>命令，其中两种用于未绑定游标变量，另外一种用于已绑定的游标变量。
    </para>
<!-- pgdoc-cn_end sig_en=383274f2217341aef8c95dfbe1b3ce51 -->

    <note>
<!-- pgdoc-cn_start sig_en=18dc0146e4f94e6a4e4ef378dd0fd040 sig_cn_org=None source=14.1 
     <para>
      Bound cursor variables can also be used without explicitly opening the cursor,
      via the <command>FOR</command> statement described in
      <xref linkend="plpgsql-cursor-for-loop"/>.
     </para>
________________________________________________________-->
     <para>
      可以通过<xref linkend="plpgsql-cursor-for-loop"/>中描述的<command>FOR</command>语句在不显式打开游标的情况下使用已绑定的游标变量。
     </para>
<!-- pgdoc-cn_end sig_en=18dc0146e4f94e6a4e4ef378dd0fd040 -->
    </note>

    <sect3>
     <title><command>OPEN FOR</command> <replaceable>query</replaceable></title>

<!-- pgdoc-cn_start sig_en=c7ad4c0d7adb67cd77761cff9e493f1b sig_cn_org=None source=14.1 
<synopsis>
OPEN <replaceable>unbound_cursorvar</replaceable> <optional> <optional> NO </optional> SCROLL </optional> FOR <replaceable>query</replaceable>;
</synopsis>
________________________________________________________-->
<synopsis>
OPEN <replaceable>unbound_cursorvar</replaceable> <optional> <optional> NO </optional> SCROLL </optional> FOR <replaceable>query</replaceable>;
</synopsis>
<!-- pgdoc-cn_end sig_en=c7ad4c0d7adb67cd77761cff9e493f1b -->

<!-- pgdoc-cn_start sig_en=eb6b737661b3dc5efd0d582a8dd2cc1d sig_cn_org=None source=14.1 
       <para>
        The cursor variable is opened and given the specified query to
        execute.  The cursor cannot be open already, and it must have been
        declared as an unbound cursor variable (that is, as a simple
        <type>refcursor</type> variable).  The query must be a
        <command>SELECT</command>, or something else that returns rows
        (such as <command>EXPLAIN</command>).  The query
        is treated in the same way as other SQL commands in
        <application>PL/pgSQL</application>: <application>PL/pgSQL</application>
        variable names are substituted, and the query plan is cached for
        possible reuse.  When a <application>PL/pgSQL</application>
        variable is substituted into the cursor query, the value that is
        substituted is the one it has at the time of the <command>OPEN</command>;
        subsequent changes to the variable will not affect the cursor's
        behavior.
        The <literal>SCROLL</literal> and <literal>NO SCROLL</literal>
        options have the same meanings as for a bound cursor.
       </para>
________________________________________________________-->
       <para>
        该游标变量被打开并且被给定要执行的查询。游标不能是已经打开的，并且它必需已经被声明为一个未绑定的游标变量（也就是声明为一个简单的<type>refcursor</type>变量）。该查询必须是一条<command>SELECT</command>或者其它返回行的东西（例如<command>EXPLAIN</command>）。该查询会按照其它<application>PL/pgSQL</application>中的 SQL 命令同等的方式对待：先代换<application>PL/pgSQL</application>变量名，并且执行计划会被缓存用于可能的重用。当一个<application>PL/pgSQL</application>变量被替换到游标查询中时，替换的值是在<command>OPEN</command>时它所具有的值。对该变量后续的改变不会影响游标的行为。对于一个已经绑定的游标，<literal>SCROLL</literal>和<literal>NO SCROLL</literal>选项具有相同的含义。
       </para>
<!-- pgdoc-cn_end sig_en=eb6b737661b3dc5efd0d582a8dd2cc1d -->

<!-- pgdoc-cn_start sig_en=56f6f233e8d475444d06b451aefeb790 sig_cn_org=None source=14.1 
       <para>
        An example:
<programlisting>
OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;
</programlisting>
       </para>
________________________________________________________-->
       <para>
        一个例子：
<programlisting>
OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;
</programlisting>
       </para>
<!-- pgdoc-cn_end sig_en=56f6f233e8d475444d06b451aefeb790 -->
     </sect3>

    <sect3>
     <title><command>OPEN FOR EXECUTE</command></title>

<!-- pgdoc-cn_start sig_en=a2e01e96c4cd9ed7ea3d4534d34c2342 sig_cn_org=None source=14.1 
<synopsis>
OPEN <replaceable>unbound_cursorvar</replaceable> <optional> <optional> NO </optional> SCROLL </optional> FOR EXECUTE <replaceable class="command">query_string</replaceable>
                                     <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>
________________________________________________________-->
<synopsis>
OPEN <replaceable>unbound_cursorvar</replaceable> <optional> <optional> NO </optional> SCROLL </optional> FOR EXECUTE <replaceable class="command">query_string</replaceable>
                                     <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>
<!-- pgdoc-cn_end sig_en=a2e01e96c4cd9ed7ea3d4534d34c2342 -->

<!-- pgdoc-cn_start sig_en=9cf53b36fd8a1e2665f6179989ee24e0 sig_cn_org=None source=14.1 
         <para>
          The cursor variable is opened and given the specified query to
          execute.  The cursor cannot be open already, and it must have been
          declared as an unbound cursor variable (that is, as a simple
          <type>refcursor</type> variable).  The query is specified as a string
          expression, in the same way as in the <command>EXECUTE</command>
          command.  As usual, this gives flexibility so the query plan can vary
          from one run to the next (see <xref linkend="plpgsql-plan-caching"/>),
          and it also means that variable substitution is not done on the
          command string. As with <command>EXECUTE</command>, parameter values
          can be inserted into the dynamic command via
          <literal>format()</literal> and <literal>USING</literal>.
          The <literal>SCROLL</literal> and
          <literal>NO SCROLL</literal> options have the same meanings as for a bound
          cursor.
         </para>
________________________________________________________-->
         <para>
          打开游标变量并且执行指定的查询。该游标不能是已打开的，并且必须已经被声明为一个未绑定的游标变量（也就是声明为一个简单的<type>refcursor</type>变量）。该查询以和<command>EXECUTE</command>中相同的方式被指定为一个字符串表达式。照例，这提供了灵活性，因此查询计划可以在两次运行之间变化（见<xref linkend="plpgsql-plan-caching"/>），并且它也意味着在该命令字符串上还没有完成变量替换。正如<command>EXECUTE</command>，可以通过<literal>format()</literal>和<literal>USING</literal>将参数值插入到动态命令中。<literal>SCROLL</literal>和<literal>NO SCROLL</literal>选项具有和已绑定游标相同的含义。
         </para>
<!-- pgdoc-cn_end sig_en=9cf53b36fd8a1e2665f6179989ee24e0 -->

<!-- pgdoc-cn_start sig_en=d8ae42ee8038e92e0b09140b64f875b6 sig_cn_org=None source=14.1 
       <para>
        An example:
<programlisting>
OPEN curs1 FOR EXECUTE format('SELECT * FROM %I WHERE col1 = $1',tabname) USING keyvalue;
</programlisting>
        In this example, the table name is inserted into the query via
        <function>format()</function>.  The comparison value for <literal>col1</literal>
        is inserted via a <literal>USING</literal> parameter, so it needs
        no quoting.
       </para>
________________________________________________________-->
       <para>
        一个例子：
<programlisting>
OPEN curs1 FOR EXECUTE format('SELECT * FROM %I WHERE col1 = $1',tabname) USING keyvalue;
</programlisting>
        在这个例子中，表名被通过<function>format()</function>插入到查询中。
        <literal>col1</literal>的比较值被通过一个<literal>USING</literal>参数插入，
        所以它不需要引用。
       </para>
<!-- pgdoc-cn_end sig_en=d8ae42ee8038e92e0b09140b64f875b6 -->
     </sect3>

    <sect3 id="plpgsql-open-bound-cursor">
<!-- pgdoc-cn_start sig_en=c33b478902733b7a266f92162be0a18a sig_cn_org=None source=14.1 
     <title>Opening a Bound Cursor</title>
________________________________________________________-->
     <title>打开一个已绑定的游标</title>
<!-- pgdoc-cn_end sig_en=c33b478902733b7a266f92162be0a18a -->

<!-- pgdoc-cn_start sig_en=6fded8f5573d7f2b3418e68d60b42d57 sig_cn_org=None source=14.1 
<synopsis>
OPEN <replaceable>bound_cursorvar</replaceable> <optional> ( <optional> <replaceable>argument_name</replaceable> := </optional> <replaceable>argument_value</replaceable> <optional>, ...</optional> ) </optional>;
</synopsis>
________________________________________________________-->
<synopsis>
OPEN <replaceable>bound_cursorvar</replaceable> <optional> ( <optional> <replaceable>argument_name</replaceable> := </optional> <replaceable>argument_value</replaceable> <optional>, ...</optional> ) </optional>;
</synopsis>
<!-- pgdoc-cn_end sig_en=6fded8f5573d7f2b3418e68d60b42d57 -->

<!-- pgdoc-cn_start sig_en=d83ff64c431ec3eafd32fd1191bdac7c sig_cn_org=None source=14.1 
         <para>
          This form of <command>OPEN</command> is used to open a cursor
          variable whose query was bound to it when it was declared.  The
          cursor cannot be open already.  A list of actual argument value
          expressions must appear if and only if the cursor was declared to
          take arguments.  These values will be substituted in the query.
         </para>
________________________________________________________-->
         <para>
          这种形式的<command>OPEN</command>被用于打开一个游标变量，它的查询是在声明时绑定的。该游标不能是已经打开的。当且仅当该游标被声明为接收参数时，才必需出现一个实际参数值表达式的列表。这些值将被替换到命令中。
         </para>
<!-- pgdoc-cn_end sig_en=d83ff64c431ec3eafd32fd1191bdac7c -->

<!-- pgdoc-cn_start sig_en=d8e2426e057e5424e86b19e229220f63 sig_cn_org=None source=14.1 
         <para>
          The query plan for a bound cursor is always considered cacheable;
          there is no equivalent of <command>EXECUTE</command> in this case.
          Notice that <literal>SCROLL</literal> and <literal>NO SCROLL</literal> cannot be
          specified in <command>OPEN</command>, as the cursor's scrolling
          behavior was already determined.
         </para>
________________________________________________________-->
         <para>
          一个已绑定游标的查询计划总是被认为是可缓存的，在这种情况中没有<command>EXECUTE</command>的等效形式。注意<literal>SCROLL</literal>和<literal>NO SCROLL</literal>不能在<command>OPEN</command>中指定，因为游标的滚动行为已经被确定。
         </para>
<!-- pgdoc-cn_end sig_en=d8e2426e057e5424e86b19e229220f63 -->

<!-- pgdoc-cn_start sig_en=c742ca1ab02f1216a6f77edf532a8c39 sig_cn_org=None source=14.1 
         <para>
          Argument values can be passed using either <firstterm>positional</firstterm>
          or <firstterm>named</firstterm> notation.  In positional
          notation, all arguments are specified in order.  In named notation,
          each argument's name is specified using <literal>:=</literal> to
          separate it from the argument expression. Similar to calling
          functions, described in <xref linkend="sql-syntax-calling-funcs"/>, it
          is also allowed to mix positional and named notation.
         </para>
________________________________________________________-->
         <para>
          使用<firstterm>位置</firstterm>或<firstterm>命名</firstterm>记号可以传递参数值。在位置记号中，所有参数都必须按照顺序指定。在命名记号中，每一个参数的名字被使用<literal>:=</literal>指定以将它和参数表达式分隔开。类似于<xref linkend="sql-syntax-calling-funcs"/>中描述的调用函数，也允许混合位置和命名记号。
         </para>
<!-- pgdoc-cn_end sig_en=c742ca1ab02f1216a6f77edf532a8c39 -->

<!-- pgdoc-cn_start sig_en=a5a4d8723144e94a3d7387ee4343a952 sig_cn_org=None source=14.1 
         <para>
          Examples (these use the cursor declaration examples above):
<programlisting>
OPEN curs2;
OPEN curs3(42);
OPEN curs3(key := 42);
</programlisting>
         </para>
________________________________________________________-->
         <para>
          例子（这些例子使用上面例子中的游标声明）：
<programlisting>
OPEN curs2;
OPEN curs3(42);
OPEN curs3(key := 42);
</programlisting>
         </para>
<!-- pgdoc-cn_end sig_en=a5a4d8723144e94a3d7387ee4343a952 -->

<!-- pgdoc-cn_start sig_en=7d59b9036e5615852d9b583d6431381e sig_cn_org=None source=14.1 
         <para>
          Because variable substitution is done on a bound cursor's query,
          there are really two ways to pass values into the cursor: either
          with an explicit argument to <command>OPEN</command>, or implicitly by
          referencing a <application>PL/pgSQL</application> variable in the query.
          However, only variables declared before the bound cursor was
          declared will be substituted into it.  In either case the value to
          be passed is determined at the time of the <command>OPEN</command>.
          For example, another way to get the same effect as the
          <literal>curs3</literal> example above is
<programlisting>
DECLARE
    key integer;
    curs4 CURSOR FOR SELECT * FROM tenk1 WHERE unique1 = key;
BEGIN
    key := 42;
    OPEN curs4;
</programlisting>
         </para>
________________________________________________________-->
         <para>
          因为在一个已绑定游标的查询上已经完成了变量替换，实际有两种方式将值传到游标中：给<command>OPEN</command>一个显式参数，或者在查询中隐式引用一个<application>PL/pgSQL</application>变量。不过，只有在已绑定游标之前声明的变量才将会被替换到游标中。在两种情况下，要被传递的值都是在<command>OPEN</command>时确定的。例如，得到上例中<literal>curs3</literal>相同效果的另一种方式是
<programlisting>
DECLARE
    key integer;
    curs4 CURSOR FOR SELECT * FROM tenk1 WHERE unique1 = key;
BEGIN
    key := 42;
    OPEN curs4;
</programlisting>
         </para>
<!-- pgdoc-cn_end sig_en=7d59b9036e5615852d9b583d6431381e -->
     </sect3>
   </sect2>

   <sect2 id="plpgsql-cursor-using">
<!-- pgdoc-cn_start sig_en=5b4b98187bad53f475112cd47c9e80c2 sig_cn_org=None source=14.1 
    <title>Using Cursors</title>
________________________________________________________-->
    <title>使用游标</title>
<!-- pgdoc-cn_end sig_en=5b4b98187bad53f475112cd47c9e80c2 -->

<!-- pgdoc-cn_start sig_en=c08117b985a7cf41387996bdac4c62f6 sig_cn_org=None source=14.1 
    <para>
     Once a cursor has been opened, it can be manipulated with the
     statements described here.
    </para>
________________________________________________________-->
    <para>
     一旦一个游标已经被打开，那么就可以用这里描述的语句操作它。
    </para>
<!-- pgdoc-cn_end sig_en=c08117b985a7cf41387996bdac4c62f6 -->

<!-- pgdoc-cn_start sig_en=5f9d3a6a5db799b3517d874a21d1e86e sig_cn_org=None source=14.1 
    <para>
     These manipulations need not occur in the same function that
     opened the cursor to begin with.  You can return a <type>refcursor</type>
     value out of a function and let the caller operate on the cursor.
     (Internally, a <type>refcursor</type> value is simply the string name
     of a so-called portal containing the active query for the cursor.  This name
     can be passed around, assigned to other <type>refcursor</type> variables,
     and so on, without disturbing the portal.)
    </para>
________________________________________________________-->
    <para>
     这些操作不需要发生在打开该游标开始操作的同一个函数中。你可以从一个函数返回一个<type>refcursor</type>值，并且让调用者在该游标上操作（在内部，<type>refcursor</type>值只是一个包含该游标活动查询的所谓入口的字符串名称。这个名字可以被传递、赋予给其它<type>refcursor</type>变量等等，而不用担心扰乱入口）。
    </para>
<!-- pgdoc-cn_end sig_en=5f9d3a6a5db799b3517d874a21d1e86e -->

<!-- pgdoc-cn_start sig_en=24d4e71b81413a7bb0708e3f4f18cb9f sig_cn_org=None source=14.1 
    <para>
     All portals are implicitly closed at transaction end.  Therefore
     a <type>refcursor</type> value is usable to reference an open cursor
     only until the end of the transaction.
    </para>
________________________________________________________-->
    <para>
     所有入口会在事务的结尾被隐式地关闭。因此一个<type>refcursor</type>值只能在该事务结束前用于引用一个打开的游标。
    </para>
<!-- pgdoc-cn_end sig_en=24d4e71b81413a7bb0708e3f4f18cb9f -->

    <sect3>
     <title><literal>FETCH</literal></title>

<!-- pgdoc-cn_start sig_en=f24046b73b9739cadf931ae6bdbcf3d4 sig_cn_org=None source=14.1 
<synopsis>
FETCH <optional> <replaceable>direction</replaceable> { FROM | IN } </optional> <replaceable>cursor</replaceable> INTO <replaceable>target</replaceable>;
</synopsis>
________________________________________________________-->
<synopsis>
FETCH <optional> <replaceable>direction</replaceable> { FROM | IN } </optional> <replaceable>cursor</replaceable> INTO <replaceable>target</replaceable>;
</synopsis>
<!-- pgdoc-cn_end sig_en=f24046b73b9739cadf931ae6bdbcf3d4 -->

<!-- pgdoc-cn_start sig_en=4bbaba52a81c2e66b0529e11c9df8d62 sig_cn_org=None source=14.1 
    <para>
     <command>FETCH</command> retrieves the next row from the
     cursor into a target, which might be a row variable, a record
     variable, or a comma-separated list of simple variables, just like
     <command>SELECT INTO</command>.  If there is no next row, the
     target is set to NULL(s).  As with <command>SELECT
     INTO</command>, the special variable <literal>FOUND</literal> can
     be checked to see whether a row was obtained or not.
    </para>
________________________________________________________-->
    <para>
     就像<command>SELECT INTO</command>一样，<command>FETCH</command>从游标中检索下一行到目标中，目标可以是一个行变量、记录变量或者逗号分隔的简单变量列表。如果没有下一行，目标会被设置为 NULL。与<command>SELECT INTO</command>一样，可以检查特殊变量<literal>FOUND</literal>来看一行是否被获得。
    </para>
<!-- pgdoc-cn_end sig_en=4bbaba52a81c2e66b0529e11c9df8d62 -->

<!-- pgdoc-cn_start sig_en=9ddc6856a2152887cb2cf71cb089d90c sig_cn_org=None source=14.1 
    <para>
     The <replaceable>direction</replaceable> clause can be any of the
     variants allowed in the SQL <xref linkend="sql-fetch"/>
     command except the ones that can fetch
     more than one row; namely, it can be
     <literal>NEXT</literal>,
     <literal>PRIOR</literal>,
     <literal>FIRST</literal>,
     <literal>LAST</literal>,
     <literal>ABSOLUTE</literal> <replaceable>count</replaceable>,
     <literal>RELATIVE</literal> <replaceable>count</replaceable>,
     <literal>FORWARD</literal>, or
     <literal>BACKWARD</literal>.
     Omitting <replaceable>direction</replaceable> is the same
     as specifying <literal>NEXT</literal>.
     In the forms using a <replaceable>count</replaceable>,
     the <replaceable>count</replaceable> can be any integer-valued
     expression (unlike the SQL <command>FETCH</command> command,
     which only allows an integer constant).
     <replaceable>direction</replaceable> values that require moving
     backward are likely to fail unless the cursor was declared or opened
     with the <literal>SCROLL</literal> option.
    </para>
________________________________________________________-->
    <para>
     <replaceable>direction</replaceable>子句可以是 SQL <xref linkend="sql-fetch"/>命令中允许的任何变体，除了那些能够取得多于一行的。即它可以是
     <literal>NEXT</literal>、
     <literal>PRIOR</literal>、
     <literal>FIRST</literal>、
     <literal>LAST</literal>、
     <literal>ABSOLUTE</literal> <replaceable>count</replaceable>、
     <literal>RELATIVE</literal> <replaceable>count</replaceable>、
     <literal>FORWARD</literal>或者
     <literal>BACKWARD</literal>。
     省略<replaceable>direction</replaceable>和指定<literal>NEXT</literal>是一样的。在使用<replaceable>count</replaceable>的形式中，<replaceable>count</replaceable>可以是任意的整数值表达式（与SQL命令<command>FETCH</command>不一样，<command>FETCH</command>仅允许整数常量）。除非游标被使用<literal>SCROLL</literal>选项声明或打开，否则要求反向移动的<replaceable>direction</replaceable>值很可能会失败。
    </para>
<!-- pgdoc-cn_end sig_en=9ddc6856a2152887cb2cf71cb089d90c -->

<!-- pgdoc-cn_start sig_en=a2c18aee0c787e07fe58c4f4b75310c1 sig_cn_org=None source=14.1 
    <para>
     <replaceable>cursor</replaceable> must be the name of a <type>refcursor</type>
     variable that references an open cursor portal.
    </para>
________________________________________________________-->
    <para>
     <replaceable>cursor</replaceable>必须是一个引用已打开游标入口的<type>refcursor</type>变量名。
    </para>
<!-- pgdoc-cn_end sig_en=a2c18aee0c787e07fe58c4f4b75310c1 -->

<!-- pgdoc-cn_start sig_en=7f4cee1cee74e11966ccbcfe11c169a4 sig_cn_org=None source=14.1 
    <para>
     Examples:
<programlisting>
FETCH curs1 INTO rowvar;
FETCH curs2 INTO foo, bar, baz;
FETCH LAST FROM curs3 INTO x, y;
FETCH RELATIVE -2 FROM curs4 INTO x;
</programlisting>
       </para>
________________________________________________________-->
    <para>
     例子：
<programlisting>
FETCH curs1 INTO rowvar;
FETCH curs2 INTO foo, bar, baz;
FETCH LAST FROM curs3 INTO x, y;
FETCH RELATIVE -2 FROM curs4 INTO x;
</programlisting>
       </para>
<!-- pgdoc-cn_end sig_en=7f4cee1cee74e11966ccbcfe11c169a4 -->
     </sect3>

    <sect3>
     <title><literal>MOVE</literal></title>

<!-- pgdoc-cn_start sig_en=4d0ff56c7082392e662a5981d56933ea sig_cn_org=None source=14.1 
<synopsis>
MOVE <optional> <replaceable>direction</replaceable> { FROM | IN } </optional> <replaceable>cursor</replaceable>;
</synopsis>
________________________________________________________-->
<synopsis>
MOVE <optional> <replaceable>direction</replaceable> { FROM | IN } </optional> <replaceable>cursor</replaceable>;
</synopsis>
<!-- pgdoc-cn_end sig_en=4d0ff56c7082392e662a5981d56933ea -->

<!-- pgdoc-cn_start sig_en=04a8870a9e0d110e3108a9b73d35ba5d sig_cn_org=None source=14.1 
    <para>
     <command>MOVE</command> repositions a cursor without retrieving
     any data. <command>MOVE</command> works exactly like the
     <command>FETCH</command> command, except it only repositions the
     cursor and does not return the row moved to. As with <command>SELECT
     INTO</command>, the special variable <literal>FOUND</literal> can
     be checked to see whether there was a next row to move to.
    </para>
________________________________________________________-->
    <para>
     <command>MOVE</command>重新定位一个游标而不检索任何数据。<command>MOVE</command>的工作方式与<command>FETCH</command>命令很相似，但是<command>MOVE</command>只是重新定位游标并且不返回至移动到的行。与<command>SELECT INTO</command>一样，可以检查特殊变量<literal>FOUND</literal>来看要移动到的行是否存在。
    </para>
<!-- pgdoc-cn_end sig_en=04a8870a9e0d110e3108a9b73d35ba5d -->

<!-- pgdoc-cn_start sig_en=96c82859430bb1e5a2ca368f09543cd8 sig_cn_org=None source=14.1 
    <para>
     Examples:
<programlisting>
MOVE curs1;
MOVE LAST FROM curs3;
MOVE RELATIVE -2 FROM curs4;
MOVE FORWARD 2 FROM curs4;
</programlisting>
       </para>
________________________________________________________-->
    <para>
     例子：
<programlisting>
MOVE curs1;
MOVE LAST FROM curs3;
MOVE RELATIVE -2 FROM curs4;
MOVE FORWARD 2 FROM curs4;
</programlisting>
       </para>
<!-- pgdoc-cn_end sig_en=96c82859430bb1e5a2ca368f09543cd8 -->
     </sect3>

    <sect3>
     <title><literal>UPDATE/DELETE WHERE CURRENT OF</literal></title>

<!-- pgdoc-cn_start sig_en=d1d00609f827b2f68594ad65efd2fa26 sig_cn_org=None source=14.1 
<synopsis>
UPDATE <replaceable>table</replaceable> SET ... WHERE CURRENT OF <replaceable>cursor</replaceable>;
DELETE FROM <replaceable>table</replaceable> WHERE CURRENT OF <replaceable>cursor</replaceable>;
</synopsis>
________________________________________________________-->
<synopsis>
UPDATE <replaceable>table</replaceable> SET ... WHERE CURRENT OF <replaceable>cursor</replaceable>;
DELETE FROM <replaceable>table</replaceable> WHERE CURRENT OF <replaceable>cursor</replaceable>;
</synopsis>
<!-- pgdoc-cn_end sig_en=d1d00609f827b2f68594ad65efd2fa26 -->

<!-- pgdoc-cn_start sig_en=2386c8169c4bbd686dff60cd8e3f52c1 sig_cn_org=None source=14.1 
       <para>
        When a cursor is positioned on a table row, that row can be updated
        or deleted using the cursor to identify the row.  There are
        restrictions on what the cursor's query can be (in particular,
        no grouping) and it's best to use <literal>FOR UPDATE</literal> in the
        cursor.  For more information see the
        <xref linkend="sql-declare"/>
        reference page.
       </para>
________________________________________________________-->
       <para>
        当一个游标被定位到一个表行上时，使用该游标标识该行就可以对它进行更新或删除。对于游标的查询可以是什么是有限制的（尤其是不能有分组），并且最好在游标中使用<literal>FOR UPDATE</literal>。详见<xref linkend="sql-declare"/>参考页。
       </para>
<!-- pgdoc-cn_end sig_en=2386c8169c4bbd686dff60cd8e3f52c1 -->

<!-- pgdoc-cn_start sig_en=ad411aff468614cce8eeaeb32dd1b0d9 sig_cn_org=None source=14.1 
       <para>
        An example:
<programlisting>
UPDATE foo SET dataval = myval WHERE CURRENT OF curs1;
</programlisting>
       </para>
________________________________________________________-->
       <para>
        一个例子：
<programlisting>
UPDATE foo SET dataval = myval WHERE CURRENT OF curs1;
</programlisting>
       </para>
<!-- pgdoc-cn_end sig_en=ad411aff468614cce8eeaeb32dd1b0d9 -->
     </sect3>

    <sect3>
     <title><literal>CLOSE</literal></title>

<!-- pgdoc-cn_start sig_en=bbe1efb9d0ed767bc348798e20e3520c sig_cn_org=None source=14.1 
<synopsis>
CLOSE <replaceable>cursor</replaceable>;
</synopsis>
________________________________________________________-->
<synopsis>
CLOSE <replaceable>cursor</replaceable>;
</synopsis>
<!-- pgdoc-cn_end sig_en=bbe1efb9d0ed767bc348798e20e3520c -->

<!-- pgdoc-cn_start sig_en=6290a618f499b2432ff94d05c3ee616c sig_cn_org=None source=14.1 
       <para>
        <command>CLOSE</command> closes the portal underlying an open
        cursor.  This can be used to release resources earlier than end of
        transaction, or to free up the cursor variable to be opened again.
       </para>
________________________________________________________-->
       <para>
        <command>CLOSE</command>关闭一个已打开游标的底层入口。这样就可以在事务结束之前释放资源，或者释放掉该游标变量以便再次打开。
       </para>
<!-- pgdoc-cn_end sig_en=6290a618f499b2432ff94d05c3ee616c -->

<!-- pgdoc-cn_start sig_en=2f0026cafc37ef3175ec05f2bb7d492f sig_cn_org=None source=14.1 
       <para>
        An example:
<programlisting>
CLOSE curs1;
</programlisting>
       </para>
________________________________________________________-->
       <para>
        一个例子：
<programlisting>
CLOSE curs1;
</programlisting>
       </para>
<!-- pgdoc-cn_end sig_en=2f0026cafc37ef3175ec05f2bb7d492f -->
     </sect3>

    <sect3>
<!-- pgdoc-cn_start sig_en=07bd733474441e1d5b0d869d594045ae sig_cn_org=None source=14.1 
     <title>Returning Cursors</title>
________________________________________________________-->
     <title>返回游标</title>
<!-- pgdoc-cn_end sig_en=07bd733474441e1d5b0d869d594045ae -->

<!-- pgdoc-cn_start sig_en=4b5198cf5358fcc073d3aa9d7594c8d5 sig_cn_org=None source=14.1 
       <para>
        <application>PL/pgSQL</application> functions can return cursors to the
        caller. This is useful to return multiple rows or columns,
        especially with very large result sets.  To do this, the function
        opens the cursor and returns the cursor name to the caller (or simply
        opens the cursor using a portal name specified by or otherwise known
        to the caller).  The caller can then fetch rows from the cursor. The
        cursor can be closed by the caller, or it will be closed automatically
        when the transaction closes.
       </para>
________________________________________________________-->
       <para>
        <application>PL/pgSQL</application>函数可以向调用者返回游标。这对于返回多行或多列（特别是巨大的结果集）很有用。要想这么做，该函数打开游标并且把该游标的名字返回给调用者（或者简单的使用调用者指定的或已知的入口名打开游标）。调用者接着可以从游标中取得行。游标可以由调用者关闭，或者是在事务关闭时自行关闭。
       </para>
<!-- pgdoc-cn_end sig_en=4b5198cf5358fcc073d3aa9d7594c8d5 -->

<!-- pgdoc-cn_start sig_en=8bf7167d8e80c242d8ae2df11058e818 sig_cn_org=None source=14.1 
       <para>
        The portal name used for a cursor can be specified by the
        programmer or automatically generated.  To specify a portal name,
        simply assign a string to the <type>refcursor</type> variable before
        opening it.  The string value of the <type>refcursor</type> variable
        will be used by <command>OPEN</command> as the name of the underlying portal.
        However, if the <type>refcursor</type> variable is null,
        <command>OPEN</command> automatically generates a name that does not
        conflict with any existing portal, and assigns it to the
        <type>refcursor</type> variable.
       </para>
________________________________________________________-->
       <para>
        用于一个游标的入口名可以由编程者指定或者自动生成。要指定一个入口名，只需要在打开<type>refcursor</type>变量之前简单地为它赋予一个字符串。<command>OPEN</command>将把<type>refcursor</type>变量的字符串值用作底层入口的名字。不过，如果<type>refcursor</type>变量为空，<command>OPEN</command>会自动生成一个与任何现有入口不冲突的名称，并且将它赋予给<type>refcursor</type>变量。
       </para>
<!-- pgdoc-cn_end sig_en=8bf7167d8e80c242d8ae2df11058e818 -->

       <note>
<!-- pgdoc-cn_start sig_en=7c1265451eb238b37967c3ef6ebe8040 sig_cn_org=None source=14.1 
        <para>
         A bound cursor variable is initialized to the string value
         representing its name, so that the portal name is the same as
         the cursor variable name, unless the programmer overrides it
         by assignment before opening the cursor.  But an unbound cursor
         variable defaults to the null value initially, so it will receive
         an automatically-generated unique name, unless overridden.
        </para>
________________________________________________________-->
        <para>
         一个已绑定的游标变量被初始化为表示其名称的字符串值，因此入口的名字和游标变量名相同，除非程序员在打开游标之前通过赋值覆盖了这个名字。但是一个未绑定的游标变量最初默认为空值，因此它会收到一个自动生成的唯一名字，除非被覆盖。
        </para>
<!-- pgdoc-cn_end sig_en=7c1265451eb238b37967c3ef6ebe8040 -->
       </note>

<!-- pgdoc-cn_start sig_en=d8a2ba6f92c01cd385eb9983973a2787 sig_cn_org=None source=14.1 
       <para>
        The following example shows one way a cursor name can be supplied by
        the caller:

<programlisting>
CREATE TABLE test (col text);
INSERT INTO test VALUES ('123');

CREATE FUNCTION reffunc(refcursor) RETURNS refcursor AS '
BEGIN
    OPEN $1 FOR SELECT col FROM test;
    RETURN $1;
END;
' LANGUAGE plpgsql;

BEGIN;
SELECT reffunc('funccursor');
FETCH ALL IN funccursor;
COMMIT;
</programlisting>
       </para>
________________________________________________________-->
       <para>
        下面的例子显示了一个调用者提供游标名字的方法：

<programlisting>
CREATE TABLE test (col text);
INSERT INTO test VALUES ('123');

CREATE FUNCTION reffunc(refcursor) RETURNS refcursor AS '
BEGIN
    OPEN $1 FOR SELECT col FROM test;
    RETURN $1;
END;
' LANGUAGE plpgsql;

BEGIN;
SELECT reffunc('funccursor');
FETCH ALL IN funccursor;
COMMIT;
</programlisting>
       </para>
<!-- pgdoc-cn_end sig_en=d8a2ba6f92c01cd385eb9983973a2787 -->

<!-- pgdoc-cn_start sig_en=8cb143c94ab06de49f581f9f60fdde36 sig_cn_org=None source=14.1 
       <para>
        The following example uses automatic cursor name generation:

<programlisting>
CREATE FUNCTION reffunc2() RETURNS refcursor AS '
DECLARE
    ref refcursor;
BEGIN
    OPEN ref FOR SELECT col FROM test;
    RETURN ref;
END;
' LANGUAGE plpgsql;

-&minus; need to be in a transaction to use cursors.
BEGIN;
SELECT reffunc2();

      reffunc2
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 &lt;unnamed cursor 1&gt;
(1 row)

FETCH ALL IN "&lt;unnamed cursor 1&gt;";
COMMIT;
</programlisting>
       </para>
________________________________________________________-->
       <para>
        下面的例子使用了自动游标名生成：

<programlisting>
CREATE FUNCTION reffunc2() RETURNS refcursor AS '
DECLARE
    ref refcursor;
BEGIN
    OPEN ref FOR SELECT col FROM test;
    RETURN ref;
END;
' LANGUAGE plpgsql;

-- 需要在一个事务中使用游标。
BEGIN;
SELECT reffunc2();

      reffunc2
--------------------
 &lt;unnamed cursor 1&gt;
(1 row)

FETCH ALL IN "&lt;unnamed cursor 1&gt;";
COMMIT;
</programlisting>
       </para>
<!-- pgdoc-cn_end sig_en=8cb143c94ab06de49f581f9f60fdde36 -->

<!-- pgdoc-cn_start sig_en=4f9a74ed018c501fea6e1608627bf99e sig_cn_org=None source=14.1 
       <para>
        The following example shows one way to return multiple cursors
        from a single function:

<programlisting>
CREATE FUNCTION myfunc(refcursor, refcursor) RETURNS SETOF refcursor AS $$
BEGIN
    OPEN $1 FOR SELECT * FROM table_1;
    RETURN NEXT $1;
    OPEN $2 FOR SELECT * FROM table_2;
    RETURN NEXT $2;
END;
$$ LANGUAGE plpgsql;

-&minus; need to be in a transaction to use cursors.
BEGIN;

SELECT * FROM myfunc('a', 'b');

FETCH ALL FROM a;
FETCH ALL FROM b;
COMMIT;
</programlisting>
       </para>
________________________________________________________-->
       <para>
        下面的例子展示了从一个函数中返回多个游标的一种方法：

<programlisting>
CREATE FUNCTION myfunc(refcursor, refcursor) RETURNS SETOF refcursor AS $$
BEGIN
    OPEN $1 FOR SELECT * FROM table_1;
    RETURN NEXT $1;
    OPEN $2 FOR SELECT * FROM table_2;
    RETURN NEXT $2;
END;
$$ LANGUAGE plpgsql;

-- 需要在一个事务中使用游标。
BEGIN;

SELECT * FROM myfunc('a', 'b');

FETCH ALL FROM a;
FETCH ALL FROM b;
COMMIT;
</programlisting>
       </para>
<!-- pgdoc-cn_end sig_en=4f9a74ed018c501fea6e1608627bf99e -->
     </sect3>
   </sect2>

   <sect2 id="plpgsql-cursor-for-loop">
<!-- pgdoc-cn_start sig_en=2d5d5b14f267090e488011b4117a5a0b sig_cn_org=None source=14.1 
    <title>Looping through a Cursor's Result</title>
________________________________________________________-->
    <title>通过一个游标的结果循环</title>
<!-- pgdoc-cn_end sig_en=2d5d5b14f267090e488011b4117a5a0b -->

<!-- pgdoc-cn_start sig_en=6cd3ae1b5b522bd1f2aa9cc61ebf8eb4 sig_cn_org=None source=14.1 
    <para>
     There is a variant of the <command>FOR</command> statement that allows
     iterating through the rows returned by a cursor.  The syntax is:

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>recordvar</replaceable> IN <replaceable>bound_cursorvar</replaceable> <optional> ( <optional> <replaceable>argument_name</replaceable> := </optional> <replaceable>argument_value</replaceable> <optional>, ...</optional> ) </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

     The cursor variable must have been bound to some query when it was
     declared, and it <emphasis>cannot</emphasis> be open already.  The
     <command>FOR</command> statement automatically opens the cursor, and it closes
     the cursor again when the loop exits.  A list of actual argument value
     expressions must appear if and only if the cursor was declared to take
     arguments.  These values will be substituted in the query, in just
     the same way as during an <command>OPEN</command> (see <xref
     linkend="plpgsql-open-bound-cursor"/>).
   </para>
________________________________________________________-->
    <para>
     有一种<command>FOR</command>语句的变体，它允许通过游标返回的行进行迭代。语法是：

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>recordvar</replaceable> IN <replaceable>bound_cursorvar</replaceable> <optional> ( <optional> <replaceable>argument_name</replaceable> := </optional> <replaceable>argument_value</replaceable> <optional>, ...</optional> ) </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

     该游标变量必须在声明时已经被绑定到某个查询，并且它<emphasis>不能</emphasis>已经被打开。<command>FOR</command>语句会自动打开游标，并且在退出循环时自动关闭游标。当且仅当游标被声明要使用参数时，才必须出现一个实际参数值表达式的列表。这些值会被替换到查询中，采用<command>OPEN</command>期间的方式（见<xref linkend="plpgsql-open-bound-cursor"/>）。
   </para>
<!-- pgdoc-cn_end sig_en=6cd3ae1b5b522bd1f2aa9cc61ebf8eb4 -->

<!-- pgdoc-cn_start sig_en=57de2e65a20a3d1715dfe2e83597f705 sig_cn_org=None source=14.1 
   <para>
     The variable <replaceable>recordvar</replaceable> is automatically
     defined as type <type>record</type> and exists only inside the loop (any
     existing definition of the variable name is ignored within the loop).
     Each row returned by the cursor is successively assigned to this
     record variable and the loop body is executed.
    </para>
________________________________________________________-->
   <para>
     变量<replaceable>recordvar</replaceable>会被自动定义为<type>record</type>类型，并且只存在于循环内部（循环中该变量名任何已有定义都会被忽略）。每一个由游标返回的行都会被陆续地赋值给这个记录变量并且执行循环体。
    </para>
<!-- pgdoc-cn_end sig_en=57de2e65a20a3d1715dfe2e83597f705 -->
   </sect2>

  </sect1>

  <sect1 id="plpgsql-transactions">
<!-- pgdoc-cn_start sig_en=168b9264e23c07090b9e1a29f31a5165 sig_cn_org=None source=14.1 
   <title>Transaction Management</title>
________________________________________________________-->
   <title>事务管理</title>
<!-- pgdoc-cn_end sig_en=168b9264e23c07090b9e1a29f31a5165 -->

<!-- pgdoc-cn_start sig_en=81e05094c7b015ee5506aef94b09e497 sig_cn_org=None source=14.1 
   <para>
    In procedures invoked by the <command>CALL</command> command
    as well as in anonymous code blocks (<command>DO</command> command),
    it is possible to end transactions using the
    commands <command>COMMIT</command> and <command>ROLLBACK</command>.  A new
    transaction is started automatically after a transaction is ended using
    these commands, so there is no separate <command>START
    TRANSACTION</command> command.  (Note that <command>BEGIN</command> and
    <command>END</command> have different meanings in PL/pgSQL.)
   </para>
________________________________________________________-->
   <para>
    在由<command>CALL</command>命令调用的过程中以及匿名代码块（<command>DO</command>命令）中，可以用命令<command>COMMIT</command>和<command>ROLLBACK</command>结束事务。在一个事务被使用这些命令结束后，一个新的事务会被自动开始，因此没有单独的<command>START TRANSACTION</command>命令（注意<command>BEGIN</command>和<command>END</command>在PL/pgSQL中有不同的含义）。
   </para>
<!-- pgdoc-cn_end sig_en=81e05094c7b015ee5506aef94b09e497 -->

<!-- pgdoc-cn_start sig_en=00f2b1e4c10cacd37cc701f4cdffdb91 sig_cn_org=None source=14.1 
   <para>
    Here is a simple example:
<programlisting>
CREATE PROCEDURE transaction_test1()
LANGUAGE plpgsql
AS $$
BEGIN
    FOR i IN 0..9 LOOP
        INSERT INTO test1 (a) VALUES (i);
        IF i % 2 = 0 THEN
            COMMIT;
        ELSE
            ROLLBACK;
        END IF;
    END LOOP;
END;
$$;

CALL transaction_test1();
</programlisting>
   </para>
________________________________________________________-->
   <para>
    这里是一个简单的例子：
<programlisting>
CREATE PROCEDURE transaction_test1()
LANGUAGE plpgsql
AS $$
BEGIN
    FOR i IN 0..9 LOOP
        INSERT INTO test1 (a) VALUES (i);
        IF i % 2 = 0 THEN
            COMMIT;
        ELSE
            ROLLBACK;
        END IF;
    END LOOP;
END;
$$;

CALL transaction_test1();
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=00f2b1e4c10cacd37cc701f4cdffdb91 -->

<!-- pgdoc-cn_start sig_en=7e4463f6a69bc19695963bf72ce9dc51 sig_cn_org=None source=14.1 
   <indexterm zone="plpgsql-transaction-chain">
    <primary>chained transactions</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="plpgsql-transaction-chain">
    <primary>连锁的事务</primary>
    <secondary>在 PL/pgSQL</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=7e4463f6a69bc19695963bf72ce9dc51 -->

<!-- pgdoc-cn_start sig_en=cd36dff8618b1e3bfd03741254a5e4ee sig_cn_org=None source=14.1 
   <para id="plpgsql-transaction-chain">
    A new transaction starts out with default transaction characteristics such
    as transaction isolation level.  In cases where transactions are committed
    in a loop, it might be desirable to start new transactions automatically
    with the same characteristics as the previous one.  The commands
    <command>COMMIT AND CHAIN</command> and <command>ROLLBACK AND
    CHAIN</command> accomplish this.
   </para>
________________________________________________________-->
   <para id="plpgsql-transaction-chain">
    新事务开始时具有默认事务特征，如事务隔离级别。在循环中提交事务的情况下，可能需要以与前一个事务相同的特征来自动启动新事务。
    命令<command>COMMIT AND CHAIN</command>和<command>ROLLBACK AND CHAIN</command>可以完成此操作。
   </para>
<!-- pgdoc-cn_end sig_en=cd36dff8618b1e3bfd03741254a5e4ee -->

<!-- pgdoc-cn_start sig_en=98b091967cfc523c738f78e78d221413 sig_cn_org=None source=14.1 
   <para>
    Transaction control is only possible in <command>CALL</command> or
    <command>DO</command> invocations from the top level or nested
    <command>CALL</command> or <command>DO</command> invocations without any
    other intervening command.  For example, if the call stack is
    <command>CALL proc1()</command> &rarr; <command>CALL proc2()</command>
    &rarr; <command>CALL proc3()</command>, then the second and third
    procedures can perform transaction control actions.  But if the call stack
    is <command>CALL proc1()</command> &rarr; <command>SELECT
    func2()</command> &rarr; <command>CALL proc3()</command>, then the last
    procedure cannot do transaction control, because of the
    <command>SELECT</command> in between.
   </para>
________________________________________________________-->
   <para>
    只有在从顶层调用的<command>CALL</command>或<command>DO</command>中才能进行事务控制，在没有任何其他中间命令的嵌套<command>CALL</command>或<command>DO</command>调用中也能进行事务控制。例如，如果调用栈是<command>CALL proc1()</command> &rarr; <command>CALL proc2()</command> &rarr; <command>CALL proc3()</command>，那么第二个和第三个过程可以执行事务控制动作。但是如果调用栈是<command>CALL proc1()</command> &rarr; <command>SELECT func2()</command> &rarr; <command>CALL proc3()</command>，则最后一个过程不能做事务控制，因为中间有<command>SELECT</command>。
   </para>
<!-- pgdoc-cn_end sig_en=98b091967cfc523c738f78e78d221413 -->

<!-- pgdoc-cn_start sig_en=298a5b56f3d1167335dc876202a5be1a sig_cn_org=None source=14.1 
   <para>
    Special considerations apply to cursor loops.  Consider this example:
<programlisting>
CREATE PROCEDURE transaction_test2()
LANGUAGE plpgsql
AS $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN SELECT * FROM test2 ORDER BY x LOOP
        INSERT INTO test1 (a) VALUES (r.x);
        COMMIT;
    END LOOP;
END;
$$;

CALL transaction_test2();
</programlisting>
    Normally, cursors are automatically closed at transaction commit.
    However, a cursor created as part of a loop like this is automatically
    converted to a holdable cursor by the first <command>COMMIT</command> or
    <command>ROLLBACK</command>.  That means that the cursor is fully
    evaluated at the first <command>COMMIT</command> or
    <command>ROLLBACK</command> rather than row by row.  The cursor is still
    removed automatically after the loop, so this is mostly invisible to the
    user.
   </para>
________________________________________________________-->
   <para>
    对于游标循环有特殊的考虑。看看这个例子：
<programlisting>
CREATE PROCEDURE transaction_test2()
LANGUAGE plpgsql
AS $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN SELECT * FROM test2 ORDER BY x LOOP
        INSERT INTO test1 (a) VALUES (r.x);
        COMMIT;
    END LOOP;
END;
$$;

CALL transaction_test2();
</programlisting>
    通常，游标会在事务提交时被自动关闭。但是，一个作为循环的组成部分创建的游标会自动被第一个<command>COMMIT</command>或<command>ROLLBACK</command>转变成一个可保持游标。这意味着该游标在第一个<command>COMMIT</command>或<command>ROLLBACK</command>处会被完全计算出来，而不是逐行被计算。该游标在循环后仍会被自动删除，因此这通常对用户是不可见的。
   </para>
<!-- pgdoc-cn_end sig_en=298a5b56f3d1167335dc876202a5be1a -->

<!-- pgdoc-cn_start sig_en=743b12c0b1452d9abdcc92cf4907ba43 sig_cn_org=None source=14.1 
   <para>
    Transaction commands are not allowed in cursor loops driven by commands
    that are not read-only (for example <command>UPDATE
    ... RETURNING</command>).
   </para>
________________________________________________________-->
   <para>
    有非只读命令（<command>UPDATE ... RETURNING</command>）驱动的游标循环中不允许有事务命令。
   </para>
<!-- pgdoc-cn_end sig_en=743b12c0b1452d9abdcc92cf4907ba43 -->

<!-- pgdoc-cn_start sig_en=ad1c0dd3e26ed74f70f0559ee666f747 sig_cn_org=None source=14.1 
   <para>
    A transaction cannot be ended inside a block with exception handlers.
   </para>
________________________________________________________-->
   <para>
    事务在一个具有异常处理部分的块中不能被结束。
   </para>
<!-- pgdoc-cn_end sig_en=ad1c0dd3e26ed74f70f0559ee666f747 -->
  </sect1>

  <sect1 id="plpgsql-errors-and-messages">
<!-- pgdoc-cn_start sig_en=5d04dbcf2a5b1d244427ec72ca898037 sig_cn_org=None source=14.1 
   <title>Errors and Messages</title>
________________________________________________________-->
   <title>错误和消息</title>
<!-- pgdoc-cn_end sig_en=5d04dbcf2a5b1d244427ec72ca898037 -->

  <sect2 id="plpgsql-statements-raise">
<!-- pgdoc-cn_start sig_en=cefe097612dd28a3a6a5e74ca5468128 sig_cn_org=None source=14.1 
   <title>Reporting Errors and Messages</title>
________________________________________________________-->
   <title>报告错误和消息</title>
<!-- pgdoc-cn_end sig_en=cefe097612dd28a3a6a5e74ca5468128 -->

<!-- pgdoc-cn_start sig_en=97cea31225450c35c603e6e8da85544e sig_cn_org=None source=14.1 
   <indexterm>
    <primary>RAISE</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>RAISE</primary>
    <secondary>在 PL/pgSQL 中</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=97cea31225450c35c603e6e8da85544e -->

<!-- pgdoc-cn_start sig_en=16727dc6d75790b0bbbdb692c74fbee8 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>reporting errors</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>报告错误</primary>
    <secondary>在 PL/pgSQL 中</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=16727dc6d75790b0bbbdb692c74fbee8 -->

<!-- pgdoc-cn_start sig_en=23b4d7c17b331c1064a4566eb5d78cc9 sig_cn_org=None source=14.1 
   <para>
    Use the <command>RAISE</command> statement to report messages and
    raise errors.

<synopsis>
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> '<replaceable class="parameter">format</replaceable>' <optional>, <replaceable class="parameter">expression</replaceable> <optional>, ... </optional></optional> <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> <replaceable class="parameter">condition_name</replaceable> <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> SQLSTATE '<replaceable class="parameter">sqlstate</replaceable>' <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional>;
RAISE ;
</synopsis>

    The <replaceable class="parameter">level</replaceable> option specifies
    the error severity.  Allowed levels are <literal>DEBUG</literal>,
    <literal>LOG</literal>, <literal>INFO</literal>,
    <literal>NOTICE</literal>, <literal>WARNING</literal>,
    and <literal>EXCEPTION</literal>, with <literal>EXCEPTION</literal>
    being the default.
    <literal>EXCEPTION</literal> raises an error (which normally aborts the
    current transaction); the other levels only generate messages of different
    priority levels.
    Whether messages of a particular priority are reported to the client,
    written to the server log, or both is controlled by the
    <xref linkend="guc-log-min-messages"/> and
    <xref linkend="guc-client-min-messages"/> configuration
    variables. See <xref linkend="runtime-config"/> for more
    information.
   </para>
________________________________________________________-->
   <para>
    使用<command>RAISE</command>语句报告消息以及抛出错误。

<synopsis>
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> '<replaceable class="parameter">format</replaceable>' <optional>, <replaceable class="parameter">expression</replaceable> <optional>, ... </optional></optional> <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> <replaceable class="parameter">condition_name</replaceable> <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> SQLSTATE '<replaceable class="parameter">sqlstate</replaceable>' <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional>;
RAISE ;
</synopsis>

    <replaceable class="parameter">level</replaceable>选项指定了错误的严重性。允许的级别有<literal>DEBUG</literal>、<literal>LOG</literal>、<literal>INFO</literal>、<literal>NOTICE</literal>, <literal>WARNING</literal>以及<literal>EXCEPTION</literal>，默认级别是<literal>EXCEPTION</literal>。<literal>EXCEPTION</literal>会抛出一个错误（通常会中止当前事务）。其他级别仅仅是产生不同优先级的消息。不管一个特定优先级的消息是被报告给客户端、还是写到服务器日志、亦或是二者同时都做，这都由<xref linkend="guc-log-min-messages"/>和<xref linkend="guc-client-min-messages"/>配置变量控制。详见<xref linkend="runtime-config"/>。
   </para>
<!-- pgdoc-cn_end sig_en=23b4d7c17b331c1064a4566eb5d78cc9 -->

<!-- pgdoc-cn_start sig_en=75d053143244127646b373c904b4bed3 sig_cn_org=673870ca8c5b4738f3f16306e7f023f1 source=15.7 
   <para>
    After <replaceable class="parameter">level</replaceable> if any,
    you can specify a <replaceable class="parameter">format</replaceable> string
    (which must be a simple string literal, not an expression).  The
    format string specifies the error message text to be reported.
    The format string can be followed
    by optional argument expressions to be inserted into the message.
    Inside the format string, <literal>%</literal> is replaced by the
    string representation of the next optional argument's value. Write
    <literal>%%</literal> to emit a literal <literal>%</literal>.
    The number of arguments must match the number of <literal>%</literal>
    placeholders in the format string, or an error is raised during
    the compilation of the function.
   </para>
________________________________________________________-->
   <para>
    在<replaceable class="parameter">level</replaceable>之后，如果有的话，
    您可以指定一个<replaceable class="parameter">format</replaceable>字符串
    （必须是一个简单的字符串文字，而不是一个表达式）。格式字符串指定要报告的错误消息文本。
    格式字符串后面可以跟随可选的参数表达式，以插入到消息中。
    在格式字符串中，<literal>%</literal>将被下一个可选参数的值的字符串表示替换。写
    <literal>%%</literal>以发出一个字面上的<literal>%</literal>。
    参数的数量必须与格式字符串中的<literal>%</literal>占位符的数量匹配，否则在
    函数编译期间会引发错误。
   </para>
<!-- pgdoc-cn_end sig_en=75d053143244127646b373c904b4bed3 -->

<!-- pgdoc-cn_start sig_en=256753f1a262697491bdf73e626642a5 sig_cn_org=None source=14.1 
   <para>
    In this example, the value of <literal>v_job_id</literal> will replace the
    <literal>%</literal> in the string:
<programlisting>
RAISE NOTICE 'Calling cs_create_job(%)', v_job_id;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    在这个例子中，<literal>v_job_id</literal>的值将替换字符串中的<literal>%</literal>：
<programlisting>
RAISE NOTICE 'Calling cs_create_job(%)', v_job_id;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=256753f1a262697491bdf73e626642a5 -->

<!-- pgdoc-cn_start sig_en=8bed662ff79c65bc91365948ce892331 sig_cn_org=None source=14.1 
   <para>
    You can attach additional information to the error report by writing
    <literal>USING</literal> followed by <replaceable
    class="parameter">option</replaceable> = <replaceable
    class="parameter">expression</replaceable> items.  Each
    <replaceable class="parameter">expression</replaceable> can be any
    string-valued expression.  The allowed <replaceable
    class="parameter">option</replaceable> key words are:

    <variablelist id="raise-using-options">
     <varlistentry>
      <term><literal>MESSAGE</literal></term>
      <listitem>
       <para>Sets the error message text.  This option can't be used in the
        form of <command>RAISE</command> that includes a format string
        before <literal>USING</literal>.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DETAIL</literal></term>
      <listitem>
       <para>Supplies an error detail message.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>HINT</literal></term>
      <listitem>
       <para>Supplies a hint message.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ERRCODE</literal></term>
      <listitem>
       <para>Specifies the error code (SQLSTATE) to report, either by condition
        name, as shown in <xref linkend="errcodes-appendix"/>, or directly as a
        five-character SQLSTATE code.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>COLUMN</literal></term>
      <term><literal>CONSTRAINT</literal></term>
      <term><literal>DATATYPE</literal></term>
      <term><literal>TABLE</literal></term>
      <term><literal>SCHEMA</literal></term>
      <listitem>
       <para>Supplies the name of a related object.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    通过写一个后面跟着<replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable>项的<literal>USING</literal>，可以为错误报告附加一些额外信息。每一个<replaceable class="parameter">expression</replaceable>可以是任意字符串值的表达式。允许的<replaceable class="parameter">option</replaceable>关键词是：

    <variablelist id="raise-using-options">
     <varlistentry>
      <term><literal>MESSAGE</literal></term>
      <listitem>
       <para>设置错误消息文本。这个选项可以被用于在<literal>USING</literal>之前包括一个格式字符串的<command>RAISE</command>形式。</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DETAIL</literal></term>
      <listitem>
       <para>提供一个错误的细节消息。</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>HINT</literal></term>
      <listitem>
       <para>提供一个提示消息。</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ERRCODE</literal></term>
      <listitem>
       <para>指定要报告的错误代码（SQLSTATE），可以用<xref linkend="errcodes-appendix"/>中所示的条件名，或者直接作为一个五字符的 SQLSTATE 代码。</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>COLUMN</literal></term>
      <term><literal>CONSTRAINT</literal></term>
      <term><literal>DATATYPE</literal></term>
      <term><literal>TABLE</literal></term>
      <term><literal>SCHEMA</literal></term>
      <listitem>
       <para>提供一个相关对象的名称。</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=8bed662ff79c65bc91365948ce892331 -->

<!-- pgdoc-cn_start sig_en=079cab125e5e6a9c7a0eac971e0c244b sig_cn_org=None source=14.1 
   <para>
    This example will abort the transaction with the given error message
    and hint:
<programlisting>
RAISE EXCEPTION 'Nonexistent ID -&minus;> %', user_id
      USING HINT = 'Please check your user ID';
</programlisting>
   </para>
________________________________________________________-->
   <para>
    这个例子将用给定的错误消息和提示中止事务：
<programlisting>
RAISE EXCEPTION 'Nonexistent ID --> %', user_id
      USING HINT = 'Please check your user ID';
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=079cab125e5e6a9c7a0eac971e0c244b -->

<!-- pgdoc-cn_start sig_en=4ee3864258c5be88ead6eb1de9b055a7 sig_cn_org=None source=14.1 
   <para>
    These two examples show equivalent ways of setting the SQLSTATE:
<programlisting>
RAISE 'Duplicate user ID: %', user_id USING ERRCODE = 'unique_violation';
RAISE 'Duplicate user ID: %', user_id USING ERRCODE = '23505';
</programlisting>
   </para>
________________________________________________________-->
   <para>
    这两个例子展示了设置 SQLSTATE 的两种等价的方法：
<programlisting>
RAISE 'Duplicate user ID: %', user_id USING ERRCODE = 'unique_violation';
RAISE 'Duplicate user ID: %', user_id USING ERRCODE = '23505';
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=4ee3864258c5be88ead6eb1de9b055a7 -->

<!-- pgdoc-cn_start sig_en=a31c34943fb1970cf35b7e3759a0ede9 sig_cn_org=None source=14.1 
   <para>
    There is a second <command>RAISE</command> syntax in which the main argument
    is the condition name or SQLSTATE to be reported, for example:
<programlisting>
RAISE division_by_zero;
RAISE SQLSTATE '22012';
</programlisting>
    In this syntax, <literal>USING</literal> can be used to supply a custom
    error message, detail, or hint.  Another way to do the earlier
    example is
<programlisting>
RAISE unique_violation USING MESSAGE = 'Duplicate user ID: ' || user_id;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    还有第二种<command>RAISE</command>语法，在其中主要参数是要被报告的条件名或 SQLSTATE，例如：
<programlisting>
RAISE division_by_zero;
RAISE SQLSTATE '22012';
</programlisting>
    在这种语法中，<literal>USING</literal>能被用来提供一个自定义的错误消息、细节或提示。另一种做前面的例子的方法是
<programlisting>
RAISE unique_violation USING MESSAGE = 'Duplicate user ID: ' || user_id;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=a31c34943fb1970cf35b7e3759a0ede9 -->

<!-- pgdoc-cn_start sig_en=352ac010469c4611310af680838f45e7 sig_cn_org=None source=14.1 
   <para>
    Still another variant is to write <literal>RAISE USING</literal> or <literal>RAISE
    <replaceable class="parameter">level</replaceable> USING</literal> and put
    everything else into the <literal>USING</literal> list.
   </para>
________________________________________________________-->
   <para>
    仍有另一种变体是写<literal>RAISE USING</literal>或者<literal>RAISE <replaceable class="parameter">level</replaceable> USING</literal>并且把所有其他东西都放在<literal>USING</literal>列表中。
   </para>
<!-- pgdoc-cn_end sig_en=352ac010469c4611310af680838f45e7 -->

<!-- pgdoc-cn_start sig_en=a3a3fe3895d691298eec1a575d02a7fe sig_cn_org=None source=14.1 
   <para>
    The last variant of <command>RAISE</command> has no parameters at all.
    This form can only be used inside a <literal>BEGIN</literal> block's
    <literal>EXCEPTION</literal> clause;
    it causes the error currently being handled to be re-thrown.
   </para>
________________________________________________________-->
   <para>
    <command>RAISE</command>的最后一种变体根本没有参数。这种形式只能被用在一个<literal>BEGIN</literal>块的<literal>EXCEPTION</literal>子句中，它导致当前正在被处理的错误被重新抛出。
   </para>
<!-- pgdoc-cn_end sig_en=a3a3fe3895d691298eec1a575d02a7fe -->

   <note>
<!-- pgdoc-cn_start sig_en=f7ac5a1773554215edf8443a291f77d4 sig_cn_org=None source=14.1 
    <para>
     Before <productname>PostgreSQL</productname> 9.1, <command>RAISE</command> without
     parameters was interpreted as re-throwing the error from the block
     containing the active exception handler.  Thus an <literal>EXCEPTION</literal>
     clause nested within that handler could not catch it, even if the
     <command>RAISE</command> was within the nested <literal>EXCEPTION</literal> clause's
     block. This was deemed surprising as well as being incompatible with
     Oracle's PL/SQL.
    </para>
________________________________________________________-->
    <para>
     在<productname>PostgreSQL</productname> 9.1 之前，没有参数的<command>RAISE</command>被解释为重新抛出来自包含活动异常处理器的块的错误。因此一个嵌套在那个处理器中的<literal>EXCEPTION</literal>子句无法捕捉它，即使<command>RAISE</command>位于嵌套<literal>EXCEPTION</literal>子句的块中也是这样。这种行为很奇怪，也并不兼容 Oracle 的 PL/SQL。
    </para>
<!-- pgdoc-cn_end sig_en=f7ac5a1773554215edf8443a291f77d4 -->
   </note>

<!-- pgdoc-cn_start sig_en=30d90e6128c32a9919d0527747bbf595 sig_cn_org=8210c5de9afce9600ee68ca072cca3b7 source=15.7 
   <para>
    If no condition name nor SQLSTATE is specified in a
    <command>RAISE EXCEPTION</command> command, the default is to use
    <literal>raise_exception</literal> (<literal>P0001</literal>).
    If no message text is specified, the default is to use the condition
    name or SQLSTATE as message text.
   </para>
________________________________________________________-->
   <para>
    如果在<command>RAISE EXCEPTION</command>命令中没有指定条件名称或SQLSTATE，
    则默认使用<literal>raise_exception</literal> (<literal>P0001</literal>)。
    如果没有指定消息文本，则默认使用条件名称或SQLSTATE作为消息文本。
</para>
<!-- pgdoc-cn_end sig_en=30d90e6128c32a9919d0527747bbf595 -->

   <note>
<!-- pgdoc-cn_start sig_en=e672a94f84dddd9fad9f436d8e57f3f0 sig_cn_org=None source=14.1 
    <para>
     When specifying an error code by SQLSTATE code, you are not
     limited to the predefined error codes, but can select any
     error code consisting of five digits and/or upper-case ASCII
     letters, other than <literal>00000</literal>.  It is recommended that
     you avoid throwing error codes that end in three zeroes, because
     these are category codes and can only be trapped by trapping
     the whole category.
    </para>
________________________________________________________-->
    <para>
     当用 SQLSTATE 代码指定一个错误代码时，你不会受到预定义错误代码的限制，而是可以选择任何由五位以及大写 ASCII 字母构成的错误代码，只有<literal>00000</literal>不能使用。我们推荐尽量避免抛出以三个零结尾的错误代码，因为这些是分类代码并且只能用来捕获整个类别。
    </para>
<!-- pgdoc-cn_end sig_en=e672a94f84dddd9fad9f436d8e57f3f0 -->
   </note>

  </sect2>

  <sect2 id="plpgsql-statements-assert">
<!-- pgdoc-cn_start sig_en=212f80b81ed14e767e52dcfd6544bc51 sig_cn_org=None source=14.1 
   <title>Checking Assertions</title>
________________________________________________________-->
   <title>检查断言</title>
<!-- pgdoc-cn_end sig_en=212f80b81ed14e767e52dcfd6544bc51 -->

<!-- pgdoc-cn_start sig_en=91e90fcd80098ce2ab4d4c958d1bb318 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>ASSERT</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>ASSERT</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=91e90fcd80098ce2ab4d4c958d1bb318 -->

<!-- pgdoc-cn_start sig_en=23d0aa6b9b403987fde3ea2074f2f267 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>assertions</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>assertions</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=23d0aa6b9b403987fde3ea2074f2f267 -->

<!-- pgdoc-cn_start sig_en=157ca5186a4be06fc01aa347980d302b sig_cn_org=None source=14.1 
   <indexterm>
    <primary><varname>plpgsql.check_asserts</varname> configuration parameter</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary><varname>plpgsql.check_asserts</varname>配置参数</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=157ca5186a4be06fc01aa347980d302b -->

<!-- pgdoc-cn_start sig_en=685315c24efe6f3a7f2dd750a9e26529 sig_cn_org=None source=14.1 
   <para>
    The <command>ASSERT</command> statement is a convenient shorthand for
    inserting debugging checks into <application>PL/pgSQL</application>
    functions.

<synopsis>
ASSERT <replaceable class="parameter">condition</replaceable> <optional> , <replaceable class="parameter">message</replaceable> </optional>;
</synopsis>

    The <replaceable class="parameter">condition</replaceable> is a Boolean
    expression that is expected to always evaluate to true; if it does,
    the <command>ASSERT</command> statement does nothing further.  If the
    result is false or null, then an <literal>ASSERT_FAILURE</literal> exception
    is raised.  (If an error occurs while evaluating
    the <replaceable class="parameter">condition</replaceable>, it is
    reported as a normal error.)
   </para>
________________________________________________________-->
   <para>
    <command>ASSERT</command>语句是一种向
    <application>PL/pgSQL</application>函数中插入调试检查的方便方法。

<synopsis>
ASSERT <replaceable class="parameter">condition</replaceable> <optional> , <replaceable class="parameter">message</replaceable> </optional>;
</synopsis>

    <replaceable class="parameter">condition</replaceable>是一个布尔
    表达式，它被期望总是计算为真。如果确实如此，
    <command>ASSERT</command>语句不会再做什么。但如果结果是假
    或者空，那么将发生一个<literal>ASSERT_FAILURE</literal>异常（如果在计算
    <replaceable class="parameter">condition</replaceable>时发生错误，
    它会被报告为一个普通错误）。
   </para>
<!-- pgdoc-cn_end sig_en=685315c24efe6f3a7f2dd750a9e26529 -->

<!-- pgdoc-cn_start sig_en=90b5e47e94ee7ef76947529a0bf59d3a sig_cn_org=None source=14.1 
   <para>
    If the optional <replaceable class="parameter">message</replaceable> is
    provided, it is an expression whose result (if not null) replaces the
    default error message text <quote>assertion failed</quote>, should
    the <replaceable class="parameter">condition</replaceable> fail.
    The <replaceable class="parameter">message</replaceable> expression is
    not evaluated in the normal case where the assertion succeeds.
   </para>
________________________________________________________-->
   <para>
    如果提供了可选的<replaceable class="parameter">message</replaceable>，
    它是一个结果（如果非空）被用来替换默认错误消息文本
    <quote>assertion failed</quote>的表达式（如果
    <replaceable class="parameter">condition</replaceable>失败）。
    <replaceable class="parameter">message</replaceable>表达式在
    断言成功的普通情况下不会被计算。
   </para>
<!-- pgdoc-cn_end sig_en=90b5e47e94ee7ef76947529a0bf59d3a -->

<!-- pgdoc-cn_start sig_en=db1501b791d09b2f6398b62fad9f0e8a sig_cn_org=None source=14.1 
   <para>
    Testing of assertions can be enabled or disabled via the configuration
    parameter <literal>plpgsql.check_asserts</literal>, which takes a Boolean
    value; the default is <literal>on</literal>.  If this parameter
    is <literal>off</literal> then <command>ASSERT</command> statements do nothing.
   </para>
________________________________________________________-->
   <para>
    通过配置参数<literal>plpgsql.check_asserts</literal>可以启用或者禁用断言测试，
    这个参数接受布尔值且默认为<literal>on</literal>。如果这个参数为<literal>off</literal>，
    则<command>ASSERT</command>语句什么也不做。
   </para>
<!-- pgdoc-cn_end sig_en=db1501b791d09b2f6398b62fad9f0e8a -->

<!-- pgdoc-cn_start sig_en=3adbd6b1392fd21a6cb58f82d467d3f8 sig_cn_org=None source=14.1 
   <para>
    Note that <command>ASSERT</command> is meant for detecting program
    bugs, not for reporting ordinary error conditions.  Use
    the <command>RAISE</command> statement, described above, for that.
   </para>
________________________________________________________-->
   <para>
    注意<command>ASSERT</command>是为了检测程序的 bug，而不是
    报告普通的错误情况。如果要报告普通错误，请使用前面介绍的
    <command>RAISE</command>语句。
   </para>
<!-- pgdoc-cn_end sig_en=3adbd6b1392fd21a6cb58f82d467d3f8 -->

  </sect2>

 </sect1>

 <sect1 id="plpgsql-trigger">
<!-- pgdoc-cn_start sig_en=965893d4b4a1c249ddd8a87d973a20c7 sig_cn_org=None source=14.1 
  <title>Trigger Functions</title>
________________________________________________________-->
  <title>触发器函数</title>
<!-- pgdoc-cn_end sig_en=965893d4b4a1c249ddd8a87d973a20c7 -->

<!-- pgdoc-cn_start sig_en=811393c8c1ff363e6d3e0e5945873f0c sig_cn_org=None source=14.1 
  <indexterm zone="plpgsql-trigger">
   <primary>trigger</primary>
   <secondary>in PL/pgSQL</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="plpgsql-trigger">
   <primary>触发器</primary>
   <secondary>在 PL/pgSQL 中</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=811393c8c1ff363e6d3e0e5945873f0c -->

<!-- pgdoc-cn_start sig_en=48c3a134f4a0263040ea74c458b91fa5 sig_cn_org=None source=14.1 
  <para>
   <application>PL/pgSQL</application> can be used to define trigger
   functions on data changes or database events.
   A trigger function is created with the <command>CREATE FUNCTION</command>
   command, declaring it as a function with no arguments and a return type of
   <type>trigger</type> (for data change triggers) or
   <type>event_trigger</type> (for database event triggers).
   Special local variables named <varname>TG_<replaceable>something</replaceable></varname> are
   automatically defined to describe the condition that triggered the call.
  </para>
________________________________________________________-->
  <para>
   <application>PL/pgSQL</application>可以被用来在数据更改或者数据库事件上定义触发器函数。触发器函数用<command>CREATE FUNCTION</command>命令创建，它被声明为一个没有参数并且返回类型为<type>trigger</type>（对于数据更改触发器）或者<type>event_trigger</type>（对于数据库事件触发器）的函数。名为<varname>PG_<replaceable>something</replaceable></varname>的特殊局部变量将被自动创建用以描述触发该调用的条件。
  </para>
<!-- pgdoc-cn_end sig_en=48c3a134f4a0263040ea74c458b91fa5 -->

  <sect2 id="plpgsql-dml-trigger">
<!-- pgdoc-cn_start sig_en=a2b557ae6a30223344cf651246005d33 sig_cn_org=None source=14.1 
   <title>Triggers on Data Changes</title>
________________________________________________________-->
   <title>数据改变的触发器</title>
<!-- pgdoc-cn_end sig_en=a2b557ae6a30223344cf651246005d33 -->

<!-- pgdoc-cn_start sig_en=e6a05982a06d4bccdeed4e80b9440dd0 sig_cn_org=None source=14.1 
  <para>
   A <link linkend="triggers">data change trigger</link> is declared as a
   function with no arguments and a return type of <type>trigger</type>.
   Note that the function must be declared with no arguments even if it
   expects to receive some arguments specified in <command>CREATE TRIGGER</command>
   &mdash; such arguments are passed via <varname>TG_ARGV</varname>, as described
   below.
  </para>
________________________________________________________-->
  <para>
    一个<link linkend="triggers">数据更改触发器</link>被声明为一个没有参数并且返回类型为<type>trigger</type>的函数。注意，如下所述，即便该函数准备接收一些在<command>CREATE TRIGGER</command>中指定的参数 &mdash; 这类参数通过<varname>TG_ARGV</varname>传递，也必须把它声明为没有参数。
  </para>
<!-- pgdoc-cn_end sig_en=e6a05982a06d4bccdeed4e80b9440dd0 -->

<!-- pgdoc-cn_start sig_en=01a3bbd9a965610a54c2c0418ea3eafe sig_cn_org=None source=14.1 
  <para>
   When a <application>PL/pgSQL</application> function is called as a
   trigger, several special variables are created automatically in the
   top-level block. They are:

   <variablelist>
    <varlistentry>
     <term><varname>NEW</varname></term>
     <listitem>
      <para>
       Data type <type>RECORD</type>; variable holding the new
       database row for <command>INSERT</command>/<command>UPDATE</command> operations in row-level
       triggers. This variable is null in statement-level triggers
       and for <command>DELETE</command> operations.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>OLD</varname></term>
     <listitem>
      <para>
       Data type <type>RECORD</type>; variable holding the old
       database row for <command>UPDATE</command>/<command>DELETE</command> operations in row-level
       triggers. This variable is null in statement-level triggers
       and for <command>INSERT</command> operations.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_NAME</varname></term>
     <listitem>
      <para>
       Data type <type>name</type>; variable that contains the name of the trigger actually
       fired.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_WHEN</varname></term>
     <listitem>
      <para>
       Data type <type>text</type>; a string of
       <literal>BEFORE</literal>, <literal>AFTER</literal>, or
       <literal>INSTEAD OF</literal>, depending on the trigger's definition.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_LEVEL</varname></term>
     <listitem>
      <para>
       Data type <type>text</type>; a string of either
       <literal>ROW</literal> or <literal>STATEMENT</literal>
       depending on the trigger's definition.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_OP</varname></term>
     <listitem>
      <para>
       Data type <type>text</type>; a string of
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, or <literal>TRUNCATE</literal>
       telling for which operation the trigger was fired.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_RELID</varname></term>
     <listitem>
      <para>
       Data type <type>oid</type>; the object ID of the table that caused the
       trigger invocation.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_RELNAME</varname></term>
     <listitem>
      <para>
       Data type <type>name</type>; the name of the table that caused the trigger
       invocation. This is now deprecated, and could disappear in a future
       release. Use <literal>TG_TABLE_NAME</literal> instead.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TABLE_NAME</varname></term>
     <listitem>
      <para>
       Data type <type>name</type>; the name of the table that
       caused the trigger invocation.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TABLE_SCHEMA</varname></term>
     <listitem>
      <para>
       Data type <type>name</type>; the name of the schema of the
       table that caused the trigger invocation.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_NARGS</varname></term>
     <listitem>
      <para>
       Data type <type>integer</type>; the number of arguments given to the trigger
       function in the <command>CREATE TRIGGER</command> statement.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_ARGV[]</varname></term>
     <listitem>
      <para>
       Data type array of <type>text</type>; the arguments from
       the <command>CREATE TRIGGER</command> statement.
       The index counts from 0. Invalid
       indexes (less than 0 or greater than or equal to <varname>tg_nargs</varname>)
       result in a null value.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   当一个<application>PL/pgSQL</application>函数当做触发器调用时，在顶层块会自动创建一些特殊变量。它们是：

   <variablelist>
    <varlistentry>
     <term><varname>NEW</varname></term>
     <listitem>
      <para>
       数据类型是<type>RECORD</type>；该变量为行级触发器中的<command>INSERT</command>/<command>UPDATE</command>操作保持新数据行。在语句级别的触发器以及<command>DELETE</command>操作，这个变量是null。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>OLD</varname></term>
     <listitem>
      <para>
       数据类型是<type>RECORD</type>；该变量为行级触发器中的<command>UPDATE</command>/<command>DELETE</command>操作保持新数据行。在语句级别的触发器以及<command>INSERT</command>操作，这个变量是null。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_NAME</varname></term>
     <listitem>
      <para>
       数据类型是<type>name</type>；该变量包含实际触发的触发器名。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_WHEN</varname></term>
     <listitem>
      <para>
       数据类型是<type>text</type>；是值为<literal>BEFORE</literal>、<literal>AFTER</literal>或<literal>INSTEAD OF</literal>的一个字符串，取决于触发器的定义。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_LEVEL</varname></term>
     <listitem>
      <para>
       数据类型是<type>text</type>；是值为<literal>ROW</literal>或<literal>STATEMENT</literal>的一个字符串，取决于触发器的定义。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_OP</varname></term>
     <listitem>
      <para>
       数据类型是<type>text</type>；是值为<literal>INSERT</literal>、<literal>UPDATE</literal>、<literal>DELETE</literal>或<literal>TRUNCATE</literal>的一个字符串，它说明触发器是为哪个操作引发。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_RELID</varname></term>
     <listitem>
      <para>
       数据类型是<type>oid</type>；是导致触发器调用的表的对象 ID。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_RELNAME</varname></term>
     <listitem>
      <para>
       数据类型是<type>name</type>；是导致触发器调用的表的名称。现在已经被废弃，并且可能在未来的一个发行中消失。使用<literal>TG_TABLE_NAME</literal>替代。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TABLE_NAME</varname></term>
     <listitem>
      <para>
       数据类型是<type>name</type>；是导致触发器调用的表的名称。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TABLE_SCHEMA</varname></term>
     <listitem>
      <para>
       数据类型是<type>name</type>；是导致触发器调用的表所在的模式名。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_NARGS</varname></term>
     <listitem>
      <para>
       数据类型是<type>integer</type>；在<command>CREATE TRIGGER</command>语句中给触发器函数的参数数量。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_ARGV[]</varname></term>
     <listitem>
      <para>
       数据类型是<type>text</type>数组；来自<command>CREATE TRIGGER</command>语句的参数。索引从 0 开始记数。非法索引（小于 0 或者大于等于<varname>tg_nargs</varname>）会导致返回一个空值。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=01a3bbd9a965610a54c2c0418ea3eafe -->

<!-- pgdoc-cn_start sig_en=159c5afdbe8e9d9177e7428486801b49 sig_cn_org=None source=14.1 
   <para>
    A trigger function must return either <symbol>NULL</symbol> or a
    record/row value having exactly the structure of the table the
    trigger was fired for.
   </para>
________________________________________________________-->
   <para>
    一个触发器函数必须返回<symbol>NULL</symbol>或者是一个与触发器为之引发的表结构完全相同的记录/行值。
   </para>
<!-- pgdoc-cn_end sig_en=159c5afdbe8e9d9177e7428486801b49 -->

<!-- pgdoc-cn_start sig_en=1062d2b9e50824b51a8db506afdd3dff sig_cn_org=None source=14.1 
   <para>
    Row-level triggers fired <literal>BEFORE</literal> can return null to signal the
    trigger manager to skip the rest of the operation for this row
    (i.e., subsequent triggers are not fired, and the
    <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> does not occur
    for this row).  If a nonnull
    value is returned then the operation proceeds with that row value.
    Returning a row value different from the original value
    of <varname>NEW</varname> alters the row that will be inserted or
    updated.  Thus, if the trigger function wants the triggering
    action to succeed normally without altering the row
    value, <varname>NEW</varname> (or a value equal thereto) has to be
    returned.  To alter the row to be stored, it is possible to
    replace single values directly in <varname>NEW</varname> and return the
    modified <varname>NEW</varname>, or to build a complete new record/row to
    return.  In the case of a before-trigger
    on <command>DELETE</command>, the returned value has no direct
    effect, but it has to be nonnull to allow the trigger action to
    proceed.  Note that <varname>NEW</varname> is null
    in <command>DELETE</command> triggers, so returning that is
    usually not sensible.  The usual idiom in <command>DELETE</command>
    triggers is to return <varname>OLD</varname>.
   </para>
________________________________________________________-->
   <para>
    <literal>BEFORE</literal>引发的行级触发器可以返回一个空来告诉触发器管理器跳过对该行剩下的操作（即后续的触发器将不再被引发，并且不会对该行发生<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>)。如果返回了一个非空值，那么对该行值会继续操作。返回不同于原始<varname>NEW</varname>的行值将修改将要被插入或更新的行。因此，如果该触发器函数想要触发动作正常成功而不修改行值，<varname>NEW</varname>（或者另一个相等的值）必须被返回。要修改将被存储的行，可以直接在<varname>NEW</varname>中替换单一值并且返回修改后的<varname>NEW</varname>，或者构建一个全新的记录/行来返回。在一个<command>DELETE</command>上的前触发器情况下，返回值没有直接效果，但是它必须为非空以允许触发器动作继续下去。注意<varname>NEW</varname>在<command>DELETE</command>触发器中是空值，因此返回它通常没有意义。在<command>DELETE</command>中的常用方法是返回<varname>OLD</varname>.
   </para>
<!-- pgdoc-cn_end sig_en=1062d2b9e50824b51a8db506afdd3dff -->

<!-- pgdoc-cn_start sig_en=dfe9328f10188d396b8f47f78f75328f sig_cn_org=None source=14.1 
   <para>
    <literal>INSTEAD OF</literal> triggers (which are always row-level triggers,
    and may only be used on views) can return null to signal that they did
    not perform any updates, and that the rest of the operation for this
    row should be skipped (i.e., subsequent triggers are not fired, and the
    row is not counted in the rows-affected status for the surrounding
    <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>).
    Otherwise a nonnull value should be returned, to signal
    that the trigger performed the requested operation. For
    <command>INSERT</command> and <command>UPDATE</command> operations, the return value
    should be <varname>NEW</varname>, which the trigger function may modify to
    support <command>INSERT RETURNING</command> and <command>UPDATE RETURNING</command>
    (this will also affect the row value passed to any subsequent triggers,
    or passed to a special <varname>EXCLUDED</varname> alias reference within
    an <command>INSERT</command> statement with an <literal>ON CONFLICT DO
    UPDATE</literal> clause).  For <command>DELETE</command> operations, the return
    value should be <varname>OLD</varname>.
   </para>
________________________________________________________-->
   <para>
    <literal>INSTEAD OF</literal>触发器（总是行级触发器，并且可能只被用于视图）能够返回空来表示它们没有执行任何更新，并且对该行剩余的操作可以被跳过（即后续的触发器不会被引发，并且该行不会被计入外围<command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command>的行影响状态中）。否则一个非空值应该被返回用以表示该触发器执行了所请求的操作。对于<command>INSERT</command> 和<command>UPDATE</command>操作，返回值应该是<varname>NEW</varname>，触发器函数可能对它进行了修改来支持<command>INSERT RETURNING</command>和<command>UPDATE RETURNING</command>（这也将影响被传递给任何后续触发器的行值，或者被传递给带有<literal>ON CONFLICT DO UPDATE</literal>的<command>INSERT</command>语句中一个特殊的<varname>EXCLUDED</varname>别名引用）。对于<command>DELETE</command>操作，返回值应该是<varname>OLD</varname>。
   </para>
<!-- pgdoc-cn_end sig_en=dfe9328f10188d396b8f47f78f75328f -->

<!-- pgdoc-cn_start sig_en=969fac03a4bfd58f9b9a0ed6d9c1caeb sig_cn_org=None source=14.1 
   <para>
    The return value of a row-level trigger
    fired <literal>AFTER</literal> or a statement-level trigger
    fired <literal>BEFORE</literal> or <literal>AFTER</literal> is
    always ignored; it might as well be null. However, any of these types of
    triggers might still abort the entire operation by raising an error.
   </para>
________________________________________________________-->
   <para>
    一个<literal>AFTER</literal>行级触发器或一个<literal>BEFORE</literal>或<literal>AFTER</literal>语句级触发器的返回值总是会被忽略，它可能也是空。不过，任何这些类型的触发器可能仍会通过抛出一个错误来中止整个操作。
   </para>
<!-- pgdoc-cn_end sig_en=969fac03a4bfd58f9b9a0ed6d9c1caeb -->

<!-- pgdoc-cn_start sig_en=14914246216c2c495a18c99da4756937 sig_cn_org=None source=14.1 
   <para>
    <xref linkend="plpgsql-trigger-example"/> shows an example of a
    trigger function in <application>PL/pgSQL</application>.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="plpgsql-trigger-example"/>展示了<application>PL/pgSQL</application>中一个触发器函数的例子。
   </para>
<!-- pgdoc-cn_end sig_en=14914246216c2c495a18c99da4756937 -->

   <example id="plpgsql-trigger-example">
<!-- pgdoc-cn_start sig_en=9319e982994e0656f222ba9d5c76cead sig_cn_org=None source=14.1 
    <title>A <application>PL/pgSQL</application> Trigger Function</title>
________________________________________________________-->
    <title>一个 <application>PL/pgSQL</application> 触发器函数</title>
<!-- pgdoc-cn_end sig_en=9319e982994e0656f222ba9d5c76cead -->

<!-- pgdoc-cn_start sig_en=587181ec3467027f105c18a81909bee2 sig_cn_org=None source=14.1 
    <para>
     This example trigger ensures that any time a row is inserted or updated
     in the table, the current user name and time are stamped into the
     row. And it checks that an employee's name is given and that the
     salary is a positive value.
    </para>
________________________________________________________-->
    <para>
     这个例子触发器保证：任何时候一个行在表中被插入或更新时，当前用户名和时间也会被标记在该行中。并且它会检查给出了一个雇员的姓名以及薪水是一个正值。
    </para>
<!-- pgdoc-cn_end sig_en=587181ec3467027f105c18a81909bee2 -->

<!-- pgdoc-cn_start sig_en=cd2021c121da195403f72269dcaa5bee sig_cn_org=None source=14.1 
<programlisting>
CREATE TABLE emp (
    empname text,
    salary integer,
    last_date timestamp,
    last_user text
);

CREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$
    BEGIN
        -&minus; Check that empname and salary are given
        IF NEW.empname IS NULL THEN
            RAISE EXCEPTION 'empname cannot be null';
        END IF;
        IF NEW.salary IS NULL THEN
            RAISE EXCEPTION '% cannot have null salary', NEW.empname;
        END IF;

        -&minus; Who works for us when they must pay for it?
        IF NEW.salary &lt; 0 THEN
            RAISE EXCEPTION '% cannot have a negative salary', NEW.empname;
        END IF;

        -&minus; Remember who changed the payroll when
        NEW.last_date := current_timestamp;
        NEW.last_user := current_user;
        RETURN NEW;
    END;
$emp_stamp$ LANGUAGE plpgsql;

CREATE TRIGGER emp_stamp BEFORE INSERT OR UPDATE ON emp
    FOR EACH ROW EXECUTE FUNCTION emp_stamp();
</programlisting>
________________________________________________________-->
<programlisting>
CREATE TABLE emp (
    empname text,
    salary integer,
    last_date timestamp,
    last_user text
);

CREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$
    BEGIN
        -- 检查给出了 empname 以及 salary
        IF NEW.empname IS NULL THEN
            RAISE EXCEPTION 'empname cannot be null';
        END IF;
        IF NEW.salary IS NULL THEN
            RAISE EXCEPTION '% cannot have null salary', NEW.empname;
        END IF;

        -- 谁会倒贴钱为我们工作？
        IF NEW.salary &lt; 0 THEN
            RAISE EXCEPTION '% cannot have a negative salary', NEW.empname;
        END IF;

        -- 记住谁在什么时候改变了工资单
        NEW.last_date := current_timestamp;
        NEW.last_user := current_user;
        RETURN NEW;
    END;
$emp_stamp$ LANGUAGE plpgsql;

CREATE TRIGGER emp_stamp BEFORE INSERT OR UPDATE ON emp
    FOR EACH ROW EXECUTE FUNCTION emp_stamp();
</programlisting>
<!-- pgdoc-cn_end sig_en=cd2021c121da195403f72269dcaa5bee -->
   </example>

<!-- pgdoc-cn_start sig_en=4119a8576db1e491135e234d95e5b9d8 sig_cn_org=None source=14.1 
   <para>
    Another way to log changes to a table involves creating a new table that
    holds a row for each insert, update, or delete that occurs. This approach
    can be thought of as auditing changes to a table.
    <xref linkend="plpgsql-trigger-audit-example"/> shows an example of an
    audit trigger function in <application>PL/pgSQL</application>.
   </para>
________________________________________________________-->
   <para>
    另一种记录对表的改变的方法涉及到创建一个新表来为每一个发生的插入、更新或删除保持一行。这种方法可以被认为是对一个表的改变的审计。<xref linkend="plpgsql-trigger-audit-example"/>展示了<application>PL/pgSQL</application>中一个审计触发器函数的例子。
   </para>
<!-- pgdoc-cn_end sig_en=4119a8576db1e491135e234d95e5b9d8 -->

   <example id="plpgsql-trigger-audit-example">
<!-- pgdoc-cn_start sig_en=471a1ea88bfb83e502ec830e602e46d5 sig_cn_org=None source=14.1 
    <title>A <application>PL/pgSQL</application> Trigger Function for Auditing</title>
________________________________________________________-->
    <title>一个用于审计的 <application>PL/pgSQL</application> 触发器函数</title>
<!-- pgdoc-cn_end sig_en=471a1ea88bfb83e502ec830e602e46d5 -->

<!-- pgdoc-cn_start sig_en=487ad8e2f3707c96084f6fbfc4a7d083 sig_cn_org=None source=14.1 
    <para>
     This example trigger ensures that any insert, update or delete of a row
     in the <literal>emp</literal> table is recorded (i.e., audited) in the <literal>emp_audit</literal> table.
     The current time and user name are stamped into the row, together with
     the type of operation performed on it.
    </para>
________________________________________________________-->
    <para>
     这个例子触发器保证了在<literal>emp</literal>表上的任何插入、更新或删除一行的动作都被记录（即审计）在<literal>emp_audit</literal>表中。当前时间和用户名会被记录到行中，还有在其上执行的操作类型。
    </para>
<!-- pgdoc-cn_end sig_en=487ad8e2f3707c96084f6fbfc4a7d083 -->

<!-- pgdoc-cn_start sig_en=167917e8a1e77d4562d746d6a21fbade sig_cn_org=167917e8a1e77d4562d746d6a21fbade source=15.7 
<programlisting>
CREATE TABLE emp (
    empname           text NOT NULL,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    stamp             timestamp NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary integer
);

CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
    BEGIN
        -&minus;
        -&minus; Create a row in emp_audit to reflect the operation performed on emp,
        -&minus; making use of the special variable TG_OP to work out the operation.
        -&minus;
        IF (TG_OP = 'DELETE') THEN
            INSERT INTO emp_audit SELECT 'D', now(), current_user, OLD.*;
        ELSIF (TG_OP = 'UPDATE') THEN
            INSERT INTO emp_audit SELECT 'U', now(), current_user, NEW.*;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp_audit SELECT 'I', now(), current_user, NEW.*;
        END IF;
        RETURN NULL; -&minus; result is ignored since this is an AFTER trigger
    END;
$emp_audit$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
AFTER INSERT OR UPDATE OR DELETE ON emp
    FOR EACH ROW EXECUTE FUNCTION process_emp_audit();
</programlisting>
________________________________________________________-->
<programlisting>
CREATE TABLE emp (
    empname           text NOT NULL,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    stamp             timestamp NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary integer
);

CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
    BEGIN
        --
        -- Create a row in emp_audit to reflect the operation performed on emp,
        -- making use of the special variable TG_OP to work out the operation.
        --
        IF (TG_OP = 'DELETE') THEN
            INSERT INTO emp_audit SELECT 'D', now(), current_user, OLD.*;
        ELSIF (TG_OP = 'UPDATE') THEN
            INSERT INTO emp_audit SELECT 'U', now(), current_user, NEW.*;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp_audit SELECT 'I', now(), current_user, NEW.*;
        END IF;
        RETURN NULL; -- result is ignored since this is an AFTER trigger
    END;
$emp_audit$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
AFTER INSERT OR UPDATE OR DELETE ON emp
    FOR EACH ROW EXECUTE FUNCTION process_emp_audit();
</programlisting>
<!-- pgdoc-cn_end sig_en=167917e8a1e77d4562d746d6a21fbade -->
   </example>

<!-- pgdoc-cn_start sig_en=fd21e5616bff8122e63036253d66be7a sig_cn_org=None source=14.1 
   <para>
    A variation of the previous example uses a view joining the main table
    to the audit table, to show when each entry was last modified. This
    approach still records the full audit trail of changes to the table,
    but also presents a simplified view of the audit trail, showing just
    the last modified timestamp derived from the audit trail for each entry.
    <xref linkend="plpgsql-view-trigger-audit-example"/> shows an example
    of an audit trigger on a view in <application>PL/pgSQL</application>.
   </para>
________________________________________________________-->
   <para>
    前一个例子的一种变体使用一个视图将主表连接到审计表来展示每一项最后被修改是什么时间。这种方法还是记录了对于表修改的完整审查跟踪，但是也提供了审查跟踪的一个简化视图，只为每一个项显示从审查跟踪生成的最后修改时间戳。<xref linkend="plpgsql-view-trigger-audit-example"/>展示了在<application>PL/pgSQL</application>中一个视图上审计触发器的例子。
   </para>
<!-- pgdoc-cn_end sig_en=fd21e5616bff8122e63036253d66be7a -->

   <example id="plpgsql-view-trigger-audit-example">
<!-- pgdoc-cn_start sig_en=d2529486bc3773d0240ed196db8fa56b sig_cn_org=None source=14.1 
    <title>A <application>PL/pgSQL</application> View Trigger Function for Auditing</title>
________________________________________________________-->
    <title>一个用于审计的 <application>PL/pgSQL</application> 视图触发器函数</title>
<!-- pgdoc-cn_end sig_en=d2529486bc3773d0240ed196db8fa56b -->

<!-- pgdoc-cn_start sig_en=587371833f660a3725dba3fd7fd1ccef sig_cn_org=None source=14.1 
    <para>
     This example uses a trigger on the view to make it updatable, and
     ensure that any insert, update or delete of a row in the view is
     recorded (i.e., audited) in the <literal>emp_audit</literal> table. The current time
     and user name are recorded, together with the type of operation
     performed, and the view displays the last modified time of each row.
    </para>
________________________________________________________-->
    <para>
     这个例子在视图上使用了一个触发器让它变得可更新，并且确保视图中一行的任何插入、更新或删除被记录（即审计）在<literal>emp_audit</literal>表中。当前时间和用户名会被与执行的操作类型一起记录，并且该视图会显示每一行的最后修改时间。
    </para>
<!-- pgdoc-cn_end sig_en=587371833f660a3725dba3fd7fd1ccef -->

<!-- pgdoc-cn_start sig_en=bd9bfea0f315e4d7a315f4529a60e01b sig_cn_org=bd9bfea0f315e4d7a315f4529a60e01b source=15.7 
<programlisting>
CREATE TABLE emp (
    empname           text PRIMARY KEY,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary            integer,
    stamp             timestamp NOT NULL
);

CREATE VIEW emp_view AS
    SELECT e.empname,
           e.salary,
           max(ea.stamp) AS last_updated
      FROM emp e
      LEFT JOIN emp_audit ea ON ea.empname = e.empname
     GROUP BY 1, 2;

CREATE OR REPLACE FUNCTION update_emp_view() RETURNS TRIGGER AS $$
    BEGIN
        -&minus;
        -&minus; Perform the required operation on emp, and create a row in emp_audit
        -&minus; to reflect the change made to emp.
        -&minus;
        IF (TG_OP = 'DELETE') THEN
            DELETE FROM emp WHERE empname = OLD.empname;
            IF NOT FOUND THEN RETURN NULL; END IF;

            OLD.last_updated = now();
            INSERT INTO emp_audit VALUES('D', current_user, OLD.*);
            RETURN OLD;
        ELSIF (TG_OP = 'UPDATE') THEN
            UPDATE emp SET salary = NEW.salary WHERE empname = OLD.empname;
            IF NOT FOUND THEN RETURN NULL; END IF;

            NEW.last_updated = now();
            INSERT INTO emp_audit VALUES('U', current_user, NEW.*);
            RETURN NEW;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp VALUES(NEW.empname, NEW.salary);

            NEW.last_updated = now();
            INSERT INTO emp_audit VALUES('I', current_user, NEW.*);
            RETURN NEW;
        END IF;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
INSTEAD OF INSERT OR UPDATE OR DELETE ON emp_view
    FOR EACH ROW EXECUTE FUNCTION update_emp_view();
</programlisting>
________________________________________________________-->
<programlisting>
CREATE TABLE emp (
    empname           text PRIMARY KEY,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary            integer,
    stamp             timestamp NOT NULL
);

CREATE VIEW emp_view AS
    SELECT e.empname,
           e.salary,
           max(ea.stamp) AS last_updated
      FROM emp e
      LEFT JOIN emp_audit ea ON ea.empname = e.empname
     GROUP BY 1, 2;

CREATE OR REPLACE FUNCTION update_emp_view() RETURNS TRIGGER AS $$
    BEGIN
        --
        -- Perform the required operation on emp, and create a row in emp_audit
        -- to reflect the change made to emp.
        --
        IF (TG_OP = 'DELETE') THEN
            DELETE FROM emp WHERE empname = OLD.empname;
            IF NOT FOUND THEN RETURN NULL; END IF;

            OLD.last_updated = now();
            INSERT INTO emp_audit VALUES('D', current_user, OLD.*);
            RETURN OLD;
        ELSIF (TG_OP = 'UPDATE') THEN
            UPDATE emp SET salary = NEW.salary WHERE empname = OLD.empname;
            IF NOT FOUND THEN RETURN NULL; END IF;

            NEW.last_updated = now();
            INSERT INTO emp_audit VALUES('U', current_user, NEW.*);
            RETURN NEW;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp VALUES(NEW.empname, NEW.salary);

            NEW.last_updated = now();
            INSERT INTO emp_audit VALUES('I', current_user, NEW.*);
            RETURN NEW;
        END IF;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
INSTEAD OF INSERT OR UPDATE OR DELETE ON emp_view
    FOR EACH ROW EXECUTE FUNCTION update_emp_view();
</programlisting>
<!-- pgdoc-cn_end sig_en=bd9bfea0f315e4d7a315f4529a60e01b -->
   </example>

<!-- pgdoc-cn_start sig_en=ae50288839c8d970737a1d864a42751c sig_cn_org=None source=14.1 
   <para>
    One use of triggers is to maintain a summary table
    of another table. The resulting summary can be used in place of the
    original table for certain queries &mdash; often with vastly reduced run
    times.
    This technique is commonly used in Data Warehousing, where the tables
    of measured or observed data (called fact tables) might be extremely large.
    <xref linkend="plpgsql-trigger-summary-example"/> shows an example of a
    trigger function in <application>PL/pgSQL</application> that maintains
    a summary table for a fact table in a data warehouse.
   </para>
________________________________________________________-->
   <para>
    触发器的一种用法是维护一个表的另一个汇总表。作为结果的汇总表可以用来在特定查询中替代原始表 &mdash; 通常会大量减少运行时间。这种技术常用于数据仓库中，在其中被度量或被观察数据的表（称为事实表）可能会极度大。<xref linkend="plpgsql-trigger-summary-example"/>展示了<application>PL/pgSQL</application>中一个为数据仓库事实表维护汇总表的触发器函数的例子。
   </para>
<!-- pgdoc-cn_end sig_en=ae50288839c8d970737a1d864a42751c -->


   <example id="plpgsql-trigger-summary-example">
<!-- pgdoc-cn_start sig_en=27dea450d5cafd8ab40140576cde2d56 sig_cn_org=None source=14.1 
    <title>A <application>PL/pgSQL</application> Trigger Function for Maintaining a Summary Table</title>
________________________________________________________-->
    <title>一个 <application>PL/pgSQL</application> 用于维护汇总表的触发器函数</title>
<!-- pgdoc-cn_end sig_en=27dea450d5cafd8ab40140576cde2d56 -->

<!-- pgdoc-cn_start sig_en=59a298f90b0f4fdb64619ca23dad97f3 sig_cn_org=None source=14.1 
    <para>
     The schema detailed here is partly based on the <emphasis>Grocery Store
     </emphasis> example from <emphasis>The Data Warehouse Toolkit</emphasis>
     by Ralph Kimball.
    </para>
________________________________________________________-->
    <para>
     这里详述的模式有一部分是基于 Ralph Kimball 所作的<emphasis>The Data Warehouse Toolkit</emphasis>中的<emphasis>Grocery Store</emphasis>例子。
    </para>
<!-- pgdoc-cn_end sig_en=59a298f90b0f4fdb64619ca23dad97f3 -->

<!-- pgdoc-cn_start sig_en=e2632a50a579212c5c51a6b4920ccc2f sig_cn_org=None source=14.1 
<programlisting>
-&minus;
-&minus; Main tables - time dimension and sales fact.
-&minus;
CREATE TABLE time_dimension (
    time_key                    integer NOT NULL,
    day_of_week                 integer NOT NULL,
    day_of_month                integer NOT NULL,
    month                       integer NOT NULL,
    quarter                     integer NOT NULL,
    year                        integer NOT NULL
);
CREATE UNIQUE INDEX time_dimension_key ON time_dimension(time_key);

CREATE TABLE sales_fact (
    time_key                    integer NOT NULL,
    product_key                 integer NOT NULL,
    store_key                   integer NOT NULL,
    amount_sold                 numeric(12,2) NOT NULL,
    units_sold                  integer NOT NULL,
    amount_cost                 numeric(12,2) NOT NULL
);
CREATE INDEX sales_fact_time ON sales_fact(time_key);

-&minus;
-&minus; Summary table - sales by time.
-&minus;
CREATE TABLE sales_summary_bytime (
    time_key                    integer NOT NULL,
    amount_sold                 numeric(15,2) NOT NULL,
    units_sold                  numeric(12) NOT NULL,
    amount_cost                 numeric(15,2) NOT NULL
);
CREATE UNIQUE INDEX sales_summary_bytime_key ON sales_summary_bytime(time_key);

-&minus;
-&minus; Function and trigger to amend summarized column(s) on UPDATE, INSERT, DELETE.
-&minus;
CREATE OR REPLACE FUNCTION maint_sales_summary_bytime() RETURNS TRIGGER
AS $maint_sales_summary_bytime$
    DECLARE
        delta_time_key          integer;
        delta_amount_sold       numeric(15,2);
        delta_units_sold        numeric(12);
        delta_amount_cost       numeric(15,2);
    BEGIN

        -&minus; Work out the increment/decrement amount(s).
        IF (TG_OP = 'DELETE') THEN

            delta_time_key = OLD.time_key;
            delta_amount_sold = -1 * OLD.amount_sold;
            delta_units_sold = -1 * OLD.units_sold;
            delta_amount_cost = -1 * OLD.amount_cost;

        ELSIF (TG_OP = 'UPDATE') THEN

            -&minus; forbid updates that change the time_key -
            -&minus; (probably not too onerous, as DELETE + INSERT is how most
            -&minus; changes will be made).
            IF ( OLD.time_key != NEW.time_key) THEN
                RAISE EXCEPTION 'Update of time_key : % -&gt; % not allowed',
                                                      OLD.time_key, NEW.time_key;
            END IF;

            delta_time_key = OLD.time_key;
            delta_amount_sold = NEW.amount_sold - OLD.amount_sold;
            delta_units_sold = NEW.units_sold - OLD.units_sold;
            delta_amount_cost = NEW.amount_cost - OLD.amount_cost;

        ELSIF (TG_OP = 'INSERT') THEN

            delta_time_key = NEW.time_key;
            delta_amount_sold = NEW.amount_sold;
            delta_units_sold = NEW.units_sold;
            delta_amount_cost = NEW.amount_cost;

        END IF;


        -&minus; Insert or update the summary row with the new values.
        &lt;&lt;insert_update&gt;&gt;
        LOOP
            UPDATE sales_summary_bytime
                SET amount_sold = amount_sold + delta_amount_sold,
                    units_sold = units_sold + delta_units_sold,
                    amount_cost = amount_cost + delta_amount_cost
                WHERE time_key = delta_time_key;

            EXIT insert_update WHEN found;

            BEGIN
                INSERT INTO sales_summary_bytime (
                            time_key,
                            amount_sold,
                            units_sold,
                            amount_cost)
                    VALUES (
                            delta_time_key,
                            delta_amount_sold,
                            delta_units_sold,
                            delta_amount_cost
                           );

                EXIT insert_update;

            EXCEPTION
                WHEN UNIQUE_VIOLATION THEN
                    -&minus; do nothing
            END;
        END LOOP insert_update;

        RETURN NULL;

    END;
$maint_sales_summary_bytime$ LANGUAGE plpgsql;

CREATE TRIGGER maint_sales_summary_bytime
AFTER INSERT OR UPDATE OR DELETE ON sales_fact
    FOR EACH ROW EXECUTE FUNCTION maint_sales_summary_bytime();

INSERT INTO sales_fact VALUES(1,1,1,10,3,15);
INSERT INTO sales_fact VALUES(1,2,1,20,5,35);
INSERT INTO sales_fact VALUES(2,2,1,40,15,135);
INSERT INTO sales_fact VALUES(2,3,1,10,1,13);
SELECT * FROM sales_summary_bytime;
DELETE FROM sales_fact WHERE product_key = 1;
SELECT * FROM sales_summary_bytime;
UPDATE sales_fact SET units_sold = units_sold * 2;
SELECT * FROM sales_summary_bytime;
</programlisting>
________________________________________________________-->
<programlisting>
--
-- 主表 - 时间维度和销售事实。
--
CREATE TABLE time_dimension (
    time_key                    integer NOT NULL,
    day_of_week                 integer NOT NULL,
    day_of_month                integer NOT NULL,
    month                       integer NOT NULL,
    quarter                     integer NOT NULL,
    year                        integer NOT NULL
);
CREATE UNIQUE INDEX time_dimension_key ON time_dimension(time_key);

CREATE TABLE sales_fact (
    time_key                    integer NOT NULL,
    product_key                 integer NOT NULL,
    store_key                   integer NOT NULL,
    amount_sold                 numeric(12,2) NOT NULL,
    units_sold                  integer NOT NULL,
    amount_cost                 numeric(12,2) NOT NULL
);
CREATE INDEX sales_fact_time ON sales_fact(time_key);

--
-- 汇总表 - 按时间汇总销售
--
CREATE TABLE sales_summary_bytime (
    time_key                    integer NOT NULL,
    amount_sold                 numeric(15,2) NOT NULL,
    units_sold                  numeric(12) NOT NULL,
    amount_cost                 numeric(15,2) NOT NULL
);
CREATE UNIQUE INDEX sales_summary_bytime_key ON sales_summary_bytime(time_key);

--
-- 在 UPDATE、INSERT、DELETE 时修改汇总列的函数和触发器。
--
CREATE OR REPLACE FUNCTION maint_sales_summary_bytime() RETURNS TRIGGER
AS $maint_sales_summary_bytime$
    DECLARE
        delta_time_key          integer;
        delta_amount_sold       numeric(15,2);
        delta_units_sold        numeric(12);
        delta_amount_cost       numeric(15,2);
    BEGIN

        -- 算出增量/减量数。
        IF (TG_OP = 'DELETE') THEN

            delta_time_key = OLD.time_key;
            delta_amount_sold = -1 * OLD.amount_sold;
            delta_units_sold = -1 * OLD.units_sold;
            delta_amount_cost = -1 * OLD.amount_cost;

        ELSIF (TG_OP = 'UPDATE') THEN

            -- 禁止更改 the time_key 的更新-
            -- （可能不会太麻烦，因为大部分的更改是用 DELETE + INSERT 完成的）。
            IF ( OLD.time_key != NEW.time_key) THEN
                RAISE EXCEPTION 'Update of time_key : % -&gt; % not allowed',
                                                      OLD.time_key, NEW.time_key;
            END IF;

            delta_time_key = OLD.time_key;
            delta_amount_sold = NEW.amount_sold - OLD.amount_sold;
            delta_units_sold = NEW.units_sold - OLD.units_sold;
            delta_amount_cost = NEW.amount_cost - OLD.amount_cost;

        ELSIF (TG_OP = 'INSERT') THEN

            delta_time_key = NEW.time_key;
            delta_amount_sold = NEW.amount_sold;
            delta_units_sold = NEW.units_sold;
            delta_amount_cost = NEW.amount_cost;

        END IF;


        -- 插入或更新带有新值的汇总行。
        &lt;&lt;insert_update&gt;&gt;
        LOOP
            UPDATE sales_summary_bytime
                SET amount_sold = amount_sold + delta_amount_sold,
                    units_sold = units_sold + delta_units_sold,
                    amount_cost = amount_cost + delta_amount_cost
                WHERE time_key = delta_time_key;

            EXIT insert_update WHEN found;

            BEGIN
                INSERT INTO sales_summary_bytime (
                            time_key,
                            amount_sold,
                            units_sold,
                            amount_cost)
                    VALUES (
                            delta_time_key,
                            delta_amount_sold,
                            delta_units_sold,
                            delta_amount_cost
                           );

                EXIT insert_update;

            EXCEPTION
                WHEN UNIQUE_VIOLATION THEN
                    -- 什么也不做
            END;
        END LOOP insert_update;

        RETURN NULL;

    END;
$maint_sales_summary_bytime$ LANGUAGE plpgsql;

CREATE TRIGGER maint_sales_summary_bytime
AFTER INSERT OR UPDATE OR DELETE ON sales_fact
    FOR EACH ROW EXECUTE FUNCTION maint_sales_summary_bytime();

INSERT INTO sales_fact VALUES(1,1,1,10,3,15);
INSERT INTO sales_fact VALUES(1,2,1,20,5,35);
INSERT INTO sales_fact VALUES(2,2,1,40,15,135);
INSERT INTO sales_fact VALUES(2,3,1,10,1,13);
SELECT * FROM sales_summary_bytime;
DELETE FROM sales_fact WHERE product_key = 1;
SELECT * FROM sales_summary_bytime;
UPDATE sales_fact SET units_sold = units_sold * 2;
SELECT * FROM sales_summary_bytime;
</programlisting>
<!-- pgdoc-cn_end sig_en=e2632a50a579212c5c51a6b4920ccc2f -->
   </example>

<!-- pgdoc-cn_start sig_en=5d031cdd7a88441959fdd642141a0f47 sig_cn_org=None source=14.1 
   <para>
    <literal>AFTER</literal> triggers can also make use of <firstterm>transition
    tables</firstterm> to inspect the entire set of rows changed by the triggering
    statement.  The <command>CREATE TRIGGER</command> command assigns names to one
    or both transition tables, and then the function can refer to those names
    as though they were read-only temporary tables.
    <xref linkend="plpgsql-trigger-audit-transition-example"/> shows an example.
   </para>
________________________________________________________-->
   <para>
    <literal>AFTER</literal>也可以利用<firstterm>传递表</firstterm>来观察被触发语句更改的整个行集合。<command>CREATE TRIGGER</command>命令会为一个或者两个传递表分配名字，然后函数可以引用那些名字，就好像它们是只读的临时表一样。<xref linkend="plpgsql-trigger-audit-transition-example"/>展示了一个例子。
   </para>
<!-- pgdoc-cn_end sig_en=5d031cdd7a88441959fdd642141a0f47 -->

   <example id="plpgsql-trigger-audit-transition-example">
<!-- pgdoc-cn_start sig_en=18ceb1b96904b35171799bac4d045d81 sig_cn_org=None source=14.1 
    <title>Auditing with Transition Tables</title>
________________________________________________________-->
    <title>用传递表进行审计</title>
<!-- pgdoc-cn_end sig_en=18ceb1b96904b35171799bac4d045d81 -->

<!-- pgdoc-cn_start sig_en=b1d8fe24ea7e8130e62e1422421a989d sig_cn_org=None source=14.1 
    <para>
     This example produces the same results as
     <xref linkend="plpgsql-trigger-audit-example"/>, but instead of using a
     trigger that fires for every row, it uses a trigger that fires once
     per statement, after collecting the relevant information in a transition
     table.  This can be significantly faster than the row-trigger approach
     when the invoking statement has modified many rows.  Notice that we must
     make a separate trigger declaration for each kind of event, since the
     <literal>REFERENCING</literal> clauses must be different for each case.  But
     this does not stop us from using a single trigger function if we choose.
     (In practice, it might be better to use three separate functions and
     avoid the run-time tests on <varname>TG_OP</varname>.)
    </para>
________________________________________________________-->
    <para>
     这个例子产生和<xref linkend="plpgsql-trigger-audit-example"/>相同的结果，但并未使用一个为每一行都触发的触发器，而是在把相关信息收集到一个传递表中之后用了一个只为每个语句引发一次的触发器。当调用语句修改了很多行时，这种方法明显比行触发器方法快。注意我们必须为每一种事件建立一个单独的触发器声明，因为每种情况的<literal>REFERENCING</literal>子句必须不同。但是这并不能阻止我们使用单一的触发器函数（实际上，使用三个单独的函数会更好，因为可以避免在<varname>TG_OP</varname>上的运行时测试）。
    </para>
<!-- pgdoc-cn_end sig_en=b1d8fe24ea7e8130e62e1422421a989d -->

<!-- pgdoc-cn_start sig_en=184baae02e7a6aa0dfb7acc0bf01da79 sig_cn_org=184baae02e7a6aa0dfb7acc0bf01da79 source=15.7 
<programlisting>
CREATE TABLE emp (
    empname           text NOT NULL,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    stamp             timestamp NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary integer
);

CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
    BEGIN
        -&minus;
        -&minus; Create rows in emp_audit to reflect the operations performed on emp,
        -&minus; making use of the special variable TG_OP to work out the operation.
        -&minus;
        IF (TG_OP = 'DELETE') THEN
            INSERT INTO emp_audit
                SELECT 'D', now(), current_user, o.* FROM old_table o;
        ELSIF (TG_OP = 'UPDATE') THEN
            INSERT INTO emp_audit
                SELECT 'U', now(), current_user, n.* FROM new_table n;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp_audit
                SELECT 'I', now(), current_user, n.* FROM new_table n;
        END IF;
        RETURN NULL; -&minus; result is ignored since this is an AFTER trigger
    END;
$emp_audit$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit_ins
    AFTER INSERT ON emp
    REFERENCING NEW TABLE AS new_table
    FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
CREATE TRIGGER emp_audit_upd
    AFTER UPDATE ON emp
    REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table
    FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
CREATE TRIGGER emp_audit_del
    AFTER DELETE ON emp
    REFERENCING OLD TABLE AS old_table
    FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
</programlisting>
________________________________________________________-->
<programlisting>
CREATE TABLE emp (
    empname           text NOT NULL,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    stamp             timestamp NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary integer
);

CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
    BEGIN
        --
        -- Create rows in emp_audit to reflect the operations performed on emp,
        -- making use of the special variable TG_OP to work out the operation.
        --
        IF (TG_OP = 'DELETE') THEN
            INSERT INTO emp_audit
                SELECT 'D', now(), current_user, o.* FROM old_table o;
        ELSIF (TG_OP = 'UPDATE') THEN
            INSERT INTO emp_audit
                SELECT 'U', now(), current_user, n.* FROM new_table n;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp_audit
                SELECT 'I', now(), current_user, n.* FROM new_table n;
        END IF;
        RETURN NULL; -- result is ignored since this is an AFTER trigger
    END;
$emp_audit$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit_ins
    AFTER INSERT ON emp
    REFERENCING NEW TABLE AS new_table
    FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
CREATE TRIGGER emp_audit_upd
    AFTER UPDATE ON emp
    REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table
    FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
CREATE TRIGGER emp_audit_del
    AFTER DELETE ON emp
    REFERENCING OLD TABLE AS old_table
    FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();
</programlisting>
<!-- pgdoc-cn_end sig_en=184baae02e7a6aa0dfb7acc0bf01da79 -->
   </example>

</sect2>

  <sect2 id="plpgsql-event-trigger">
<!-- pgdoc-cn_start sig_en=86a74320542de0be495a2275c3917b83 sig_cn_org=None source=14.1 
   <title>Triggers on Events</title>
________________________________________________________-->
   <title>事件触发器</title>
<!-- pgdoc-cn_end sig_en=86a74320542de0be495a2275c3917b83 -->

<!-- pgdoc-cn_start sig_en=e829db10ec19d9d58e0fee3ce981644c sig_cn_org=None source=14.1 
   <para>
    <application>PL/pgSQL</application> can be used to define
    <link linkend="event-triggers">event triggers</link>.
    <productname>PostgreSQL</productname> requires that a function that
    is to be called as an event trigger must be declared as a function with
    no arguments and a return type of <literal>event_trigger</literal>.
   </para>
________________________________________________________-->
   <para>
    <application>PL/pgSQL</application>可以被用来定义<link linkend="event-triggers">事件触发器</link>。<productname>PostgreSQL</productname>要求一个可以作为事件触发器调用的函数必须被声明为没有参数并且返回类型为<literal>event_trigger</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=e829db10ec19d9d58e0fee3ce981644c -->

<!-- pgdoc-cn_start sig_en=4f41fab97928a51ae1b3878bf58e25b1 sig_cn_org=None source=14.1 
   <para>
    When a <application>PL/pgSQL</application> function is called as an
    event trigger, several special variables are created automatically
    in the top-level block. They are:

   <variablelist>
    <varlistentry>
     <term><varname>TG_EVENT</varname></term>
     <listitem>
      <para>
       Data type <type>text</type>; a string representing the event the
       trigger is fired for.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TAG</varname></term>
     <listitem>
      <para>
       Data type <type>text</type>; variable that contains the command tag
       for which the trigger is fired.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
   <para>
    当一个<application>PL/pgSQL</application>函数被作为一个事件触发器调用，在顶层块中会自动创建一些特殊变量。它们是：

   <variablelist>
    <varlistentry>
     <term><varname>TG_EVENT</varname></term>
     <listitem>
      <para>
       数据类型是<type>text</type>；它是一个表示引发触发器的事件的字符串。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TAG</varname></term>
     <listitem>
      <para>
       数据类型是<type>text</type>；它是一个变量，包含了该触发器为之引发的命令标签。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=4f41fab97928a51ae1b3878bf58e25b1 -->

<!-- pgdoc-cn_start sig_en=cfc59fba46d52ee47a870bfdf6a14eea sig_cn_org=None source=14.1 
   <para>
    <xref linkend="plpgsql-event-trigger-example"/> shows an example of an
    event trigger function in <application>PL/pgSQL</application>.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="plpgsql-event-trigger-example"/>展示了<application>PL/pgSQL</application>中一个事件触发器函数的例子。
   </para>
<!-- pgdoc-cn_end sig_en=cfc59fba46d52ee47a870bfdf6a14eea -->

   <example id="plpgsql-event-trigger-example">
<!-- pgdoc-cn_start sig_en=b4a5e0df37abff75936a3b16aadca32b sig_cn_org=None source=14.1 
    <title>A <application>PL/pgSQL</application> Event Trigger Function</title>
________________________________________________________-->
    <title>一个 <application>PL/pgSQL</application> 事件触发器函数</title>
<!-- pgdoc-cn_end sig_en=b4a5e0df37abff75936a3b16aadca32b -->

<!-- pgdoc-cn_start sig_en=619b9b4c4b3f4fa78c5b4c02491e2f39 sig_cn_org=None source=14.1 
    <para>
     This example trigger simply raises a <literal>NOTICE</literal> message
     each time a supported command is executed.
    </para>
________________________________________________________-->
    <para>
     这个例子触发器在受支持命令每一次被执行时会简单地抛出一个<literal>NOTICE</literal>消息。
    </para>
<!-- pgdoc-cn_end sig_en=619b9b4c4b3f4fa78c5b4c02491e2f39 -->

<!-- pgdoc-cn_start sig_en=ebafefdc3ba7263d4babd4937969b23a sig_cn_org=None source=14.1 
<programlisting>
CREATE OR REPLACE FUNCTION snitch() RETURNS event_trigger AS $$
BEGIN
    RAISE NOTICE 'snitch: % %', tg_event, tg_tag;
END;
$$ LANGUAGE plpgsql;

CREATE EVENT TRIGGER snitch ON ddl_command_start EXECUTE FUNCTION snitch();
</programlisting>
________________________________________________________-->
<programlisting>
CREATE OR REPLACE FUNCTION snitch() RETURNS event_trigger AS $$
BEGIN
    RAISE NOTICE 'snitch: % %', tg_event, tg_tag;
END;
$$ LANGUAGE plpgsql;

CREATE EVENT TRIGGER snitch ON ddl_command_start EXECUTE FUNCTION snitch();
</programlisting>
<!-- pgdoc-cn_end sig_en=ebafefdc3ba7263d4babd4937969b23a -->
   </example>
  </sect2>

  </sect1>

  <sect1 id="plpgsql-implementation">
<!-- pgdoc-cn_start sig_en=7e89b84f02ab0fa2acd73aa9f2406f2f sig_cn_org=None source=14.1 
   <title><application>PL/pgSQL</application> under the Hood</title>
________________________________________________________-->
   <title><application>PL/pgSQL</application>的内部</title>
<!-- pgdoc-cn_end sig_en=7e89b84f02ab0fa2acd73aa9f2406f2f -->

<!-- pgdoc-cn_start sig_en=027296e7e7c782b41fc7cef1bd2e9ccd sig_cn_org=None source=14.1 
   <para>
    This section discusses some implementation details that are
    frequently important for <application>PL/pgSQL</application> users to know.
   </para>
________________________________________________________-->
   <para>
    这一节讨论了一些<application>PL/pgSQL</application>用户应该知道的一些重要的实现细节。
   </para>
<!-- pgdoc-cn_end sig_en=027296e7e7c782b41fc7cef1bd2e9ccd -->

  <sect2 id="plpgsql-var-subst">
<!-- pgdoc-cn_start sig_en=b69013ad1bea4009a1eba7da1d4ad077 sig_cn_org=None source=14.1 
   <title>Variable Substitution</title>
________________________________________________________-->
   <title>变量替换</title>
<!-- pgdoc-cn_end sig_en=b69013ad1bea4009a1eba7da1d4ad077 -->

<!-- pgdoc-cn_start sig_en=83e65cebfba148140f990fe357ce1e16 sig_cn_org=None source=14.1 
   <para>
    SQL statements and expressions within a <application>PL/pgSQL</application> function
    can refer to variables and parameters of the function.  Behind the scenes,
    <application>PL/pgSQL</application> substitutes query parameters for such references.
    Query parameters will only be substituted in places where they are
    syntactically permissible.  As an extreme case, consider
    this example of poor programming style:
<programlisting>
INSERT INTO foo (foo) VALUES (foo(foo));
</programlisting>
    The first occurrence of <literal>foo</literal> must syntactically be a table
    name, so it will not be substituted, even if the function has a variable
    named <literal>foo</literal>.  The second occurrence must be the name of a
    column of that table, so it will not be substituted either.  Likewise
    the third occurrence must be a function name, so it also will not be
    substituted for.  Only the last occurrence is a candidate to be a
    reference to a variable of the <application>PL/pgSQL</application>
    function.
   </para>
________________________________________________________-->
   <para>
    一个<application>PL/pgSQL</application>函数中的 SQL 语句和表达式能够引用该函数的变量和参数。在现象背后，<application>PL/pgSQL</application>会为这些引用替换查询参数。只有在语法上允许的地方才会替换参数。作为一种极端情况，考虑这个编程风格糟糕的例子：
<programlisting>
INSERT INTO foo (foo) VALUES (foo(foo));
</programlisting>
    <literal>foo</literal>的第一次出现在语法上必须是一个表名， 因此它将不会被替换，即使该函数有一个名为<literal>foo</literal>的变量。第二次出现必须是该表的一列的名称，因此它也将不会被替换。同样，第三位应该是一个函数名。因此它也不被替换。只有最后一个位置是<application>PL/pgSQL</application>函数中变量引用的候选者。
   </para>
<!-- pgdoc-cn_end sig_en=83e65cebfba148140f990fe357ce1e16 -->

<!-- pgdoc-cn_start sig_en=8e150a581b614a86a6c58431149ddd70 sig_cn_org=None source=14.1 
   <para>
    Another way to understand this is that variable substitution can only
    insert data values into an SQL command; it cannot dynamically change which
    database objects are referenced by the command.  (If you want to do
    that, you must build a command string dynamically, as explained in
    <xref linkend="plpgsql-statements-executing-dyn"/>.)
   </para>
________________________________________________________-->
   <para>
     另一种理解方式是，变量替换只能将数据值插入到 SQL 命令中。命令引用的数据库对象不能动态更改。（如果你想这样做，你必须动态构造命令字符串，如<xref linkend="plpgsql-statements-executing-dyn"/>中所述。）
    </para>
<!-- pgdoc-cn_end sig_en=8e150a581b614a86a6c58431149ddd70 -->

<!-- pgdoc-cn_start sig_en=3ba622253554cad4b2de25228b2af551 sig_cn_org=None source=14.1 
   <para>
    Since the names of variables are syntactically no different from the names
    of table columns, there can be ambiguity in statements that also refer to
    tables: is a given name meant to refer to a table column, or a variable?
    Let's change the previous example to
<programlisting>
INSERT INTO dest (col) SELECT foo + bar FROM src;
</programlisting>
    Here, <literal>dest</literal> and <literal>src</literal> must be table names, and
    <literal>col</literal> must be a column of <literal>dest</literal>, but <literal>foo</literal>
    and <literal>bar</literal> might reasonably be either variables of the function
    or columns of <literal>src</literal>.
   </para>
________________________________________________________-->
   <para>
    因为变量名在语法上与表列的名字没什么区别，在也引用表的语句中会有歧义：一个给定的名字意味着一个表列或一个变量？让我们把前一个例子改成：
<programlisting>
INSERT INTO dest (col) SELECT foo + bar FROM src;
</programlisting>
    这里，<literal>dest</literal>和<literal>src</literal>必须是表名，并且<literal>col</literal>必须是<literal>dest</literal>的一列，但是<literal>foo</literal>和<literal>bar</literal>可能该函数的变量或者<literal>src</literal>的列。
   </para>
<!-- pgdoc-cn_end sig_en=3ba622253554cad4b2de25228b2af551 -->

<!-- pgdoc-cn_start sig_en=4185d0ce9fb82fc60de6d1ad9a81dbfe sig_cn_org=None source=14.1 
   <para>
    By default, <application>PL/pgSQL</application> will report an error if a name
    in an SQL statement could refer to either a variable or a table column.
    You can fix such a problem by renaming the variable or column,
    or by qualifying the ambiguous reference, or by telling
    <application>PL/pgSQL</application> which interpretation to prefer.
   </para>
________________________________________________________-->
   <para>
    默认情况下，如果一个 SQL 语句中的名称可能引用一个变量或者一个表列，<application>PL/pgSQL</application>将报告一个错误。修复这种问题的方法很多：你可以重命名变量或列来，或者对有歧义的引用加以限定，或者告诉<application>PL/pgSQL</application>要引用哪种解释。
   </para>
<!-- pgdoc-cn_end sig_en=4185d0ce9fb82fc60de6d1ad9a81dbfe -->

<!-- pgdoc-cn_start sig_en=18d5de2c82d9c496ce31c2ad4cfb5440 sig_cn_org=None source=14.1 
   <para>
    The simplest solution is to rename the variable or column.
    A common coding rule is to use a
    different naming convention for <application>PL/pgSQL</application>
    variables than you use for column names.  For example,
    if you consistently name function variables
    <literal>v_<replaceable>something</replaceable></literal> while none of your
    column names start with <literal>v_</literal>, no conflicts will occur.
   </para>
________________________________________________________-->
   <para>
    最简单的解决方案是重命名变量或列。一种常用的编码规则是为<application>PL/pgSQL</application>变量使用一种不同于列名的命名习惯。例如，如果你将函数变量统一地命名为<literal>v_<replaceable>something</replaceable></literal>，而你的列名不会开始于<literal>v_</literal>，就不会发生冲突。
   </para>
<!-- pgdoc-cn_end sig_en=18d5de2c82d9c496ce31c2ad4cfb5440 -->

<!-- pgdoc-cn_start sig_en=d4fd2b88c71e45a1ce66ed71e887bd42 sig_cn_org=None source=14.1 
   <para>
    Alternatively you can qualify ambiguous references to make them clear.
    In the above example, <literal>src.foo</literal> would be an unambiguous reference
    to the table column.  To create an unambiguous reference to a variable,
    declare it in a labeled block and use the block's label
    (see <xref linkend="plpgsql-structure"/>).  For example,
<programlisting>
&lt;&lt;block&gt;&gt;
DECLARE
    foo int;
BEGIN
    foo := ...;
    INSERT INTO dest (col) SELECT block.foo + bar FROM src;
</programlisting>
    Here <literal>block.foo</literal> means the variable even if there is a column
    <literal>foo</literal> in <literal>src</literal>.  Function parameters, as well as
    special variables such as <literal>FOUND</literal>, can be qualified by the
    function's name, because they are implicitly declared in an outer block
    labeled with the function's name.
   </para>
________________________________________________________-->
   <para>
    另外你可以限定有歧义的引用让它们变清晰。在上面的例子中，<literal>src.foo</literal>将是对表列的一种无歧义的引用。要创建对一个变量的无歧义引用，在一个被标记的块中声明它并且使用块的标签（见<xref linkend="plpgsql-structure"/>）。例如
<programlisting>
&lt;&lt;block&gt;&gt;
DECLARE
    foo int;
BEGIN
    foo := ...;
    INSERT INTO dest (col) SELECT block.foo + bar FROM src;
</programlisting>
    这里<literal>block.foo</literal>表示变量，即使在<literal>src</literal>中有一个列<literal>foo</literal>。函数参数以及诸如<literal>FOUND</literal>的特殊变量，都能通过函数的名称被限定，因为它们被隐式地声明在一个带有该函数名称的外层块中。
   </para>
<!-- pgdoc-cn_end sig_en=d4fd2b88c71e45a1ce66ed71e887bd42 -->

<!-- pgdoc-cn_start sig_en=c40630b0e810112adf56c6eabff804ee sig_cn_org=None source=14.1 
   <para>
    Sometimes it is impractical to fix all the ambiguous references in a
    large body of <application>PL/pgSQL</application> code.  In such cases you can
    specify that <application>PL/pgSQL</application> should resolve ambiguous references
    as the variable (which is compatible with <application>PL/pgSQL</application>'s
    behavior before <productname>PostgreSQL</productname> 9.0), or as the
    table column (which is compatible with some other systems such as
    <productname>Oracle</productname>).
   </para>
________________________________________________________-->
   <para>
    有时候在一个大型的<application>PL/pgSQL</application>代码体中修复所有的有歧义引用是不现实的。在这种情况下，你可以指定<application>PL/pgSQL</application>应该将有歧义的引用作为变量（这与<application>PL/pgSQL</application>在 <productname>PostgreSQL</productname> 9.0 之前的行为兼容）或表列（这与某些其他系统兼容，例如<productname>Oracle</productname>）解决。
   </para>
<!-- pgdoc-cn_end sig_en=c40630b0e810112adf56c6eabff804ee -->

<!-- pgdoc-cn_start sig_en=495813a9133a40540106b32856a10605 sig_cn_org=None source=14.1 
   <indexterm>
     <primary><varname>plpgsql.variable_conflict</varname> configuration parameter</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
     <primary><varname>plpgsql.variable_conflict</varname>配置参数</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=495813a9133a40540106b32856a10605 -->

<!-- pgdoc-cn_start sig_en=58991e368b72e54c233d004d096eab15 sig_cn_org=None source=14.1 
   <para>
    To change this behavior on a system-wide basis, set the configuration
    parameter <literal>plpgsql.variable_conflict</literal> to one of
    <literal>error</literal>, <literal>use_variable</literal>, or
    <literal>use_column</literal> (where <literal>error</literal> is the factory default).
    This parameter affects subsequent compilations
    of statements in <application>PL/pgSQL</application> functions, but not statements
    already compiled in the current session.
    Because changing this setting
    can cause unexpected changes in the behavior of <application>PL/pgSQL</application>
    functions, it can only be changed by a superuser.
   </para>
________________________________________________________-->
   <para>
    要在系统范围内改变这种行为，将配置参数<literal>plpgsql.variable_conflict</literal>设置为<literal>error</literal>、<literal>use_variable</literal>或者<literal>use_column</literal>（这里<literal>error</literal>是出厂设置）之一。这个参数会影响<application>PL/pgSQL</application>函数中语句的后续编译，但是不会影响在当前会话中已经编译过的语句。因为改变这个设置能够导致<application>PL/pgSQL</application>函数中行为的意想不到的改变，所以只能由一个超级用户来更改它。
   </para>
<!-- pgdoc-cn_end sig_en=58991e368b72e54c233d004d096eab15 -->

<!-- pgdoc-cn_start sig_en=3187a78fd80ea8f7c90e4aeef0ec56df sig_cn_org=None source=14.1 
   <para>
    You can also set the behavior on a function-by-function basis, by
    inserting one of these special commands at the start of the function
    text:
<programlisting>
#variable_conflict error
#variable_conflict use_variable
#variable_conflict use_column
</programlisting>
    These commands affect only the function they are written in, and override
    the setting of <literal>plpgsql.variable_conflict</literal>.  An example is
<programlisting>
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    #variable_conflict use_variable
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = curtime, comment = comment
          WHERE users.id = id;
    END;
$$ LANGUAGE plpgsql;
</programlisting>
    In the <literal>UPDATE</literal> command, <literal>curtime</literal>, <literal>comment</literal>,
    and <literal>id</literal> will refer to the function's variable and parameters
    whether or not <literal>users</literal> has columns of those names.  Notice
    that we had to qualify the reference to <literal>users.id</literal> in the
    <literal>WHERE</literal> clause to make it refer to the table column.
    But we did not have to qualify the reference to <literal>comment</literal>
    as a target in the <literal>UPDATE</literal> list, because syntactically
    that must be a column of <literal>users</literal>.  We could write the same
    function without depending on the <literal>variable_conflict</literal> setting
    in this way:
<programlisting>
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    &lt;&lt;fn&gt;&gt;
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = fn.curtime, comment = stamp_user.comment
          WHERE users.id = stamp_user.id;
    END;
$$ LANGUAGE plpgsql;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    你也可以对逐个函数设置该行为，做法是在函数文本的开始插入这些特殊命令之一：
<programlisting>
#variable_conflict error
#variable_conflict use_variable
#variable_conflict use_column
</programlisting>
    这些命令只影响它们所属的函数，并且会覆盖<literal>plpgsql.variable_conflict</literal>的设置。一个例子是：
<programlisting>
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    #variable_conflict use_variable
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = curtime, comment = comment
          WHERE users.id = id;
    END;
$$ LANGUAGE plpgsql;
</programlisting>
    在<literal>UPDATE</literal>命令中，<literal>curtime</literal>、<literal>comment</literal>以及<literal>id</literal>将引用该函数的变量和参数，不管<literal>users</literal>有没有这些名称的列。注意，我们不得不在<literal>WHERE</literal>子句中对<literal>users.id</literal>的引用加以限定，以便让它引用表列。但是我们不需要在<literal>UPDATE</literal>列表中把对<literal>comment</literal>的引用限定为一个目标，因为语法上那必须是<literal>users</literal>的一列。我们可以用下面的方式写一个相同的不依赖于<literal>variable_conflict</literal>设置的函数：
<programlisting>
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    &lt;&lt;fn&gt;&gt;
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = fn.curtime, comment = stamp_user.comment
          WHERE users.id = stamp_user.id;
    END;
$$ LANGUAGE plpgsql;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=3187a78fd80ea8f7c90e4aeef0ec56df -->

<!-- pgdoc-cn_start sig_en=a138e36047837a5be18a6c379d85b69f sig_cn_org=None source=14.1 
   <para>
    Variable substitution does not happen in a command string given
    to <command>EXECUTE</command> or one of its variants.  If you need to
    insert a varying value into such a command, do so as part of
    constructing the string value, or use <literal>USING</literal>, as illustrated in
    <xref linkend="plpgsql-statements-executing-dyn"/>.
   </para>
________________________________________________________-->
   <para>
    被交给<command>EXECUTE</command>或其变体的命令字符串中不会发生变量替换。如果你需要插入一个变化值到这样一个命令中，在构建该字符串值时就这样做，或者使用<literal>USING</literal>，如<xref linkend="plpgsql-statements-executing-dyn"/>中所阐明的。
   </para>
<!-- pgdoc-cn_end sig_en=a138e36047837a5be18a6c379d85b69f -->

<!-- pgdoc-cn_start sig_en=e608d2c20d3e85b0fbec8ada03380dfc sig_cn_org=None source=14.1 
   <para>
    Variable substitution currently works only in <command>SELECT</command>,
    <command>INSERT</command>, <command>UPDATE</command>,
    <command>DELETE</command>, and commands containing one of
    these (such as <command>EXPLAIN</command> and <command>CREATE TABLE
    ... AS SELECT</command>),
    because the main SQL engine allows query parameters only in these
    commands.  To use a non-constant name or value in other statement
    types (generically called utility statements), you must construct
    the utility statement as a string and <command>EXECUTE</command> it.
   </para>
________________________________________________________-->
   <para>
    当前变量替换只能在<command>SELECT</command>、<command>INSERT</command>、<command>UPDATE</command>和<command>DELETE</command>还有包含下列之一的命令 (比如 <command>EXPLAIN</command> 和 <command>CREATE TABLE ... AS SELECT</command>)中有效，因为主 SQL 引擎只允许查询参数在这些命令中。要在其他语句类型（通常被称为实用语句）中使用一个非常量名称或值，你必须将实用语句构建为一个字符串并且<command>EXECUTE</command>它。
   </para>
<!-- pgdoc-cn_end sig_en=e608d2c20d3e85b0fbec8ada03380dfc -->

  </sect2>

  <sect2 id="plpgsql-plan-caching">
<!-- pgdoc-cn_start sig_en=189955c220c15ad9fefec60f6a1d7878 sig_cn_org=None source=14.1 
   <title>Plan Caching</title>
________________________________________________________-->
   <title>计划缓存</title>
<!-- pgdoc-cn_end sig_en=189955c220c15ad9fefec60f6a1d7878 -->

<!-- pgdoc-cn_start sig_en=a544ffb4466d01b827c38c2fcf00fa8b sig_cn_org=None source=14.1 
   <para>
    The <application>PL/pgSQL</application> interpreter parses the function's source
    text and produces an internal binary instruction tree the first time the
    function is called (within each session).  The instruction tree
    fully translates the
    <application>PL/pgSQL</application> statement structure, but individual
    <acronym>SQL</acronym> expressions and <acronym>SQL</acronym> commands
    used in the function are not translated immediately.
   </para>
________________________________________________________-->
   <para>
    在函数被第一次调用时（在每个会话中），<application>PL/pgSQL</application>解释器解析函数的源文本并且产生一个内部的二进制指令树。该指令树完全翻译了<application>PL/pgSQL</application>语句结构，但是该函数中使用的<acronym>SQL</acronym>表达式以及<acronym>SQL</acronym>命令并没有被立即翻译。
   </para>
<!-- pgdoc-cn_end sig_en=a544ffb4466d01b827c38c2fcf00fa8b -->

<!-- pgdoc-cn_start sig_en=585d381eaaccd8075cadff844d0d0693 sig_cn_org=None source=14.1 
   <para>
    <indexterm>
     <primary>preparing a query</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>
    As each expression and <acronym>SQL</acronym> command is first
    executed in the function, the <application>PL/pgSQL</application> interpreter
    parses and analyzes the command to create a prepared statement,
    using the <acronym>SPI</acronym> manager's
    <function>SPI_prepare</function> function.
    Subsequent visits to that expression or command
    reuse the prepared statement.  Thus, a function with conditional code
    paths that are seldom visited will never incur the overhead of
    analyzing those commands that are never executed within the current
    session.  A disadvantage is that errors
    in a specific expression or command cannot be detected until that
    part of the function is reached in execution.  (Trivial syntax
    errors will be detected during the initial parsing pass, but
    anything deeper will not be detected until execution.)
   </para>
________________________________________________________-->
   <para>
    <indexterm>
     <primary>准备一个查询</primary>
     <secondary>在 PL/pgSQL 中</secondary>
    </indexterm>
    作为该函数中每一个表达式和第一次被执行的<acronym>SQL</acronym>命令，<application>PL/pgSQL</application>解释器使用<acronym>SPI</acronym>管理器的<function>SPI_prepare</function>函数解析并且分析该命令来创建一个预备语句。对于那个表达式或命令的后续访问将会重用该预备语句。因此，一个带有很少被访问的条件性代码路径的函数将永远不会发生分析那些在当前会话中永远不被执行的命令的开销。一个缺点是在一个特定表达式或命令中的错误将不能被检测到，直到函数的该部分在执行时被到达（不重要的语法错误在初始的解析中就会被检测到，但是任何更深层次的东西将只有在执行时才能检测到）。
   </para>
<!-- pgdoc-cn_end sig_en=585d381eaaccd8075cadff844d0d0693 -->

<!-- pgdoc-cn_start sig_en=e37ce7d3158da9c6a8290cc98ffaa543 sig_cn_org=None source=14.1 
   <para>
    <application>PL/pgSQL</application> (or more precisely, the SPI manager) can
    furthermore attempt to cache the execution plan associated with any
    particular prepared statement.  If a cached plan is not used, then
    a fresh execution plan is generated on each visit to the statement,
    and the current parameter values (that is, <application>PL/pgSQL</application>
    variable values) can be used to optimize the selected plan.  If the
    statement has no parameters, or is executed many times, the SPI manager
    will consider creating a <firstterm>generic</firstterm> plan that is not dependent
    on specific parameter values, and caching that for re-use.  Typically
    this will happen only if the execution plan is not very sensitive to
    the values of the <application>PL/pgSQL</application> variables referenced in it.
    If it is, generating a plan each time is a net win.  See <xref
    linkend="sql-prepare"/> for more information about the behavior of
    prepared statements.
   </para>
________________________________________________________-->
   <para>
    <application>PL/pgSQL</application>（或者更准确地说是 SPI 管理器）能进一步尝试缓冲与任何特定预备语句相关的执行计划。如果没有使用一个已缓存的计划，那么每次访问该语句时都会生成一个新的执行计划，并且当前的参数值（也就是<application>PL/pgSQL</application>的变量值）可以被用来优化被选中的计划。如果该语句没有参数，或者要被执行很多次，SPI 管理器将考虑创建一个不依赖特定参数值的<firstterm>一般</firstterm>计划并且将其缓存用于重用。通常只有在执行计划对其中引用的<application>PL/pgSQL</application>变量值不那么敏感时，才会这样做。如果这样做，每一次生成的计划就是纯利。关于预备语句的行为请详见<xref linkend="sql-prepare"/>。
   </para>
<!-- pgdoc-cn_end sig_en=e37ce7d3158da9c6a8290cc98ffaa543 -->

<!-- pgdoc-cn_start sig_en=cc66a546dc1766954b733cf76e64b869 sig_cn_org=None source=14.1 
   <para>
    Because <application>PL/pgSQL</application> saves prepared statements
    and sometimes execution plans in this way,
    SQL commands that appear directly in a
    <application>PL/pgSQL</application> function must refer to the
    same tables and columns on every execution; that is, you cannot use
    a parameter as the name of a table or column in an SQL command.  To get
    around this restriction, you can construct dynamic commands using
    the <application>PL/pgSQL</application> <command>EXECUTE</command>
    statement &mdash; at the price of performing new parse analysis and
    constructing a new execution plan on every execution.
   </para>
________________________________________________________-->
   <para>
    由于<application>PL/pgSQL</application>保存预备语句并且有时候以这种方式保存执行计划，直接出现在一个<application>PL/pgSQL</application>函数中的 SQL 命令必须在每次执行时引用相同的表和列。也就是说，你不能在一个 SQL 命令中把一个参数用作表或列的名字。要绕过这种限制，你可以构建<application>PL/pgSQL</application> <command>EXECUTE</command>使用的动态命令，但是会付出在每次执行时需要执行新解析分析以及构建新执行计划的代价。
   </para>
<!-- pgdoc-cn_end sig_en=cc66a546dc1766954b733cf76e64b869 -->

<!-- pgdoc-cn_start sig_en=a2920cefe0b4db833ae045165b6d576f sig_cn_org=None source=14.1 
    <para>
     The mutable nature of record variables presents another problem in this
     connection.  When fields of a record variable are used in
     expressions or statements, the data types of the fields must not
     change from one call of the function to the next, since each
     expression will be analyzed using the data type that is present
     when the expression is first reached.  <command>EXECUTE</command> can be
     used to get around this problem when necessary.
    </para>
________________________________________________________-->
    <para>
     记录变量的易变天性在这个关系中带来了另一个问题。当一个记录变量的域被用在表达式或语句中时，域的数据类型不能在该函数的调用之间改变，因为每一个表达式被分析时都将使用第一次到达该表达式时存在的数据类型。必要时，可以用<command>EXECUTE</command>来绕过这个问题。
    </para>
<!-- pgdoc-cn_end sig_en=a2920cefe0b4db833ae045165b6d576f -->

<!-- pgdoc-cn_start sig_en=5b9ac3f185ce142aa54df5c58022a961 sig_cn_org=None source=14.1 
    <para>
     If the same function is used as a trigger for more than one table,
     <application>PL/pgSQL</application> prepares and caches statements
     independently for each such table &mdash; that is, there is a cache
     for each trigger function and table combination, not just for each
     function.  This alleviates some of the problems with varying
     data types; for instance, a trigger function will be able to work
     successfully with a column named <literal>key</literal> even if it happens
     to have different types in different tables.
    </para>
________________________________________________________-->
    <para>
     如果同一个函数被用作一个服务于多个表的触发器，<application>PL/pgSQL</application>会为每一个这样的表独立地准备并缓存语句 &mdash; 也就是对每一种触发器函数和表的组合都会有一个缓存，而不是每个函数一个缓存。这减轻了数据类型变化带来的问题。例如，一个触发器函数将能够成功地使用一个名为<literal>key</literal>的列工作，即使该列正好在不同的表中有不同的类型。
    </para>
<!-- pgdoc-cn_end sig_en=5b9ac3f185ce142aa54df5c58022a961 -->

<!-- pgdoc-cn_start sig_en=45f4f94fd629b8b444f110aea193338b sig_cn_org=None source=14.1 
    <para>
     Likewise, functions having polymorphic argument types have a separate
     statement cache for each combination of actual argument types they have
     been invoked for, so that data type differences do not cause unexpected
     failures.
    </para>
________________________________________________________-->
    <para>
     同样，具有多态参数类型的函数也会为它们已经被调用的每一种实参类型组合都保留一个独立的缓存，这样数据类型差异不会导致意想不到的失败。
    </para>
<!-- pgdoc-cn_end sig_en=45f4f94fd629b8b444f110aea193338b -->

<!-- pgdoc-cn_start sig_en=96492a1f0b23a98936d1c6c93fef0a11 sig_cn_org=None source=14.1 
   <para>
    Statement caching can sometimes have surprising effects on the
    interpretation of time-sensitive values.  For example there
    is a difference between what these two functions do:

<programlisting>
CREATE FUNCTION logfunc1(logtxt text) RETURNS void AS $$
    BEGIN
        INSERT INTO logtable VALUES (logtxt, 'now');
    END;
$$ LANGUAGE plpgsql;
</programlisting>

     and:

<programlisting>
CREATE FUNCTION logfunc2(logtxt text) RETURNS void AS $$
    DECLARE
        curtime timestamp;
    BEGIN
        curtime := 'now';
        INSERT INTO logtable VALUES (logtxt, curtime);
    END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>
________________________________________________________-->
   <para>
    语句缓存有时可能在解释时间敏感的值时产生令人惊讶的效果。例如这两个函数做的事情就有区别：

<programlisting>
CREATE FUNCTION logfunc1(logtxt text) RETURNS void AS $$
    BEGIN
        INSERT INTO logtable VALUES (logtxt, 'now');
    END;
$$ LANGUAGE plpgsql;
</programlisting>

     以及：

<programlisting>
CREATE FUNCTION logfunc2(logtxt text) RETURNS void AS $$
    DECLARE
        curtime timestamp;
    BEGIN
        curtime := 'now';
        INSERT INTO logtable VALUES (logtxt, curtime);
    END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=96492a1f0b23a98936d1c6c93fef0a11 -->

<!-- pgdoc-cn_start sig_en=00318e43dff30c91c382916f97401aa8 sig_cn_org=None source=14.1 
    <para>
     In the case of <function>logfunc1</function>, the
     <productname>PostgreSQL</productname> main parser knows when
     analyzing the <command>INSERT</command> that the
     string <literal>'now'</literal> should be interpreted as
     <type>timestamp</type>, because the target column of
     <classname>logtable</classname> is of that type. Thus,
     <literal>'now'</literal> will be converted to a <type>timestamp</type>
     constant when the
     <command>INSERT</command> is analyzed, and then used in all
     invocations of <function>logfunc1</function> during the lifetime
     of the session. Needless to say, this isn't what the programmer
     wanted.  A better idea is to use the <literal>now()</literal> or
     <literal>current_timestamp</literal> function.
    </para>
________________________________________________________-->
    <para>
     在<function>logfunc1</function>中，<productname>PostgreSQL</productname>的主解析器在分析<command>INSERT</command>时就知道字符串<literal>'now'</literal>应该被解释为<type>timestamp</type>，因为<classname>logtable</classname>的目标列是这种类型。因此，在<command>INSERT</command>被分析时<literal>'now'</literal>将被转换为一个<type>timestamp</type>常量，并且在该会话的生命周期内被用于所有对<function>logfunc1</function>的调用。不用说，这不是程序员想要的。一个更好的主意是使用<literal>now()</literal>或<literal>current_timestamp</literal>函数。
    </para>
<!-- pgdoc-cn_end sig_en=00318e43dff30c91c382916f97401aa8 -->

<!-- pgdoc-cn_start sig_en=cf736dd926d77783027a1d1d6379ca67 sig_cn_org=None source=14.1 
    <para>
     In the case of <function>logfunc2</function>, the
     <productname>PostgreSQL</productname> main parser does not know
     what type <literal>'now'</literal> should become and therefore
     it returns a data value of type <type>text</type> containing the string
     <literal>now</literal>. During the ensuing assignment
     to the local variable <varname>curtime</varname>, the
     <application>PL/pgSQL</application> interpreter casts this
     string to the <type>timestamp</type> type by calling the
     <function>textout</function> and <function>timestamp_in</function>
     functions for the conversion.  So, the computed time stamp is updated
     on each execution as the programmer expects.  Even though this
     happens to work as expected, it's not terribly efficient, so
     use of the <literal>now()</literal> function would still be a better idea.
    </para>
________________________________________________________-->
    <para>
     在<function>logfunc2</function>中，<productname>PostgreSQL</productname>的主解析器不知道<literal>'now'</literal>应该变成什么类型并且因此返回一个<type>text</type>类型的包含字符串<literal>now</literal>的数据值。在确定对本地变量<varname>curtime</varname>的赋值期间，<application>PL/pgSQL</application>解释器通过调用用于转换的<function>textout</function>以及<function>timestamp_in</function>函数将这个字符串造型为<type>timestamp</type>类型。因此，计算出来的时间戳会按照程序员的期待在每次执行时更新。虽然这正好符合预期，但是它的效率很糟糕，因此使用<literal>now()</literal>函数仍然是一种更好的方案。
    </para>
<!-- pgdoc-cn_end sig_en=cf736dd926d77783027a1d1d6379ca67 -->

  </sect2>

  </sect1>

 <sect1 id="plpgsql-development-tips">
<!-- pgdoc-cn_start sig_en=918a8afc5b631b704af5097887c859b0 sig_cn_org=None source=14.1 
  <title>Tips for Developing in <application>PL/pgSQL</application></title>
________________________________________________________-->
  <title><application>PL/pgSQL</application>开发提示</title>
<!-- pgdoc-cn_end sig_en=918a8afc5b631b704af5097887c859b0 -->

<!-- pgdoc-cn_start sig_en=e58e8caeee6226f78db21d07ec7c559b sig_cn_org=None source=14.1 
   <para>
    One good way to develop in
    <application>PL/pgSQL</application> is to use the text editor of your
    choice to create your functions, and in another window, use
    <application>psql</application> to load and test those functions.
    If you are doing it this way, it
    is a good idea to write the function using <command>CREATE OR
    REPLACE FUNCTION</command>. That way you can just reload the file to update
    the function definition.  For example:
<programlisting>
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $$
          ....
$$ LANGUAGE plpgsql;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    在<application>PL/pgSQL</application>中进行开发的一种好方法是使用你自己选择的文本编辑器来创建函数，并且在另一个窗口中使用<application>psql</application>来载入并且测试那些函数。如果你正在这样做，使用<command>CREATE OR REPLACE FUNCTION</command>来编写函数是一个好主意。用那种方式你只需要重载该文件来更新函数的定义。例如：
<programlisting>
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $$
          ....
$$ LANGUAGE plpgsql;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=e58e8caeee6226f78db21d07ec7c559b -->

<!-- pgdoc-cn_start sig_en=b919b7e09e05456e9d48905059d96e5e sig_cn_org=None source=14.1 
   <para>
    While running <application>psql</application>, you can load or reload such
    a function definition file with:
<programlisting>
\i filename.sql
</programlisting>
    and then immediately issue SQL commands to test the function.
   </para>
________________________________________________________-->
   <para>
    在运行<application>psql</application>期间，你可以用下面的命令载入或者重载这样一个函数定义文件：
<programlisting>
\i filename.sql
</programlisting>
    并且接着立即发出 SQL 命令来测试该函数。
   </para>
<!-- pgdoc-cn_end sig_en=b919b7e09e05456e9d48905059d96e5e -->

<!-- pgdoc-cn_start sig_en=128e295ba5a0e12d31b89ab5c890ee8a sig_cn_org=None source=14.1 
   <para>
    Another good way to develop in <application>PL/pgSQL</application> is with a
    GUI database access tool that facilitates development in a
    procedural language. One example of such a tool is
    <application>pgAdmin</application>, although others exist. These tools often
    provide convenient features such as escaping single quotes and
    making it easier to recreate and debug functions.
   </para>
________________________________________________________-->
   <para>
    另一种在<application>PL/pgSQL</application>中开发的方式是用一个 GUI 数据库访问工具，它能方便对过程语言的开发。这种工具的一个例子是<application>pgAdmin</application>。这些工具通常提供方便的特性，例如转义单引号以及便于重新创建和调试函数。
   </para>
<!-- pgdoc-cn_end sig_en=128e295ba5a0e12d31b89ab5c890ee8a -->

  <sect2 id="plpgsql-quote-tips">
<!-- pgdoc-cn_start sig_en=af78ecb35c7ce54fac1fef740269a4a9 sig_cn_org=None source=14.1 
   <title>Handling of Quotation Marks</title>
________________________________________________________-->
   <title>处理引号</title>
<!-- pgdoc-cn_end sig_en=af78ecb35c7ce54fac1fef740269a4a9 -->

<!-- pgdoc-cn_start sig_en=89bade746fef9c95f939714525f3abf8 sig_cn_org=None source=14.1 
   <para>
    The code of a <application>PL/pgSQL</application> function is specified in
    <command>CREATE FUNCTION</command> as a string literal.  If you
    write the string literal in the ordinary way with surrounding
    single quotes, then any single quotes inside the function body
    must be doubled; likewise any backslashes must be doubled (assuming
    escape string syntax is used).
    Doubling quotes is at best tedious, and in more complicated cases
    the code can become downright incomprehensible, because you can
    easily find yourself needing half a dozen or more adjacent quote marks.
    It's recommended that you instead write the function body as a
    <quote>dollar-quoted</quote> string literal (see <xref
    linkend="sql-syntax-dollar-quoting"/>).  In the dollar-quoting
    approach, you never double any quote marks, but instead take care to
    choose a different dollar-quoting delimiter for each level of
    nesting you need.  For example, you might write the <command>CREATE
    FUNCTION</command> command as:
<programlisting>
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $PROC$
          ....
$PROC$ LANGUAGE plpgsql;
</programlisting>
    Within this, you might use quote marks for simple literal strings in
    SQL commands and <literal>$$</literal> to delimit fragments of SQL commands
    that you are assembling as strings.  If you need to quote text that
    includes <literal>$$</literal>, you could use <literal>$Q$</literal>, and so on.
   </para>
________________________________________________________-->
   <para>
    一个<application>PL/pgSQL</application>函数的代码在一个<command>CREATE FUNCTION</command>中被指定为一个字符串。如果你用通常的方式把该字符串写在单引号中间，那么该函数体中的任何单引号都必须被双写；同样任何反斜线也必须被双写（假定使用了转义字符串语法）。双写引号最多有点冗长，并且在更复杂的情况中代码会变得完全无法理解，因为你很容易发现你需要半打或者更多相邻的引号。我们推荐你转而把函数体写成一个<quote>美元引用</quote>的字符串（见<xref linkend="sql-syntax-dollar-quoting"/>）。在美元引用方法中，你从不需要双写任何引号。但是要注意为你需要的每一层嵌套选择一个不同的美元引用定界符。例如，你可能把<command>CREATE FUNCTION</command>命令写成：
<programlisting>
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $PROC$
          ....
$PROC$ LANGUAGE plpgsql;
</programlisting>
    在这里面，你可以在 SQL 命令中为简单字符串使用引号并且用<literal>$$</literal>来界定被你组装成字符串的 SQL 命令片段。如果你需要引用包括<literal>$$</literal>的文本，你可以使用<literal>$Q$</literal>等等。
   </para>
<!-- pgdoc-cn_end sig_en=89bade746fef9c95f939714525f3abf8 -->

<!-- pgdoc-cn_start sig_en=5e0fb804f7d7bc536008fe175523cf71 sig_cn_org=None source=14.1 
   <para>
    The following chart shows what you have to do when writing quote
    marks without dollar quoting.  It might be useful when translating
    pre-dollar quoting code into something more comprehensible.
  </para>
________________________________________________________-->
   <para>
    下列图表展示了在写没有美元引用的引号时需要做什么。在将之前用美元引用的代码翻译成更容易理解的代码时，它们会有所帮助。
  </para>
<!-- pgdoc-cn_end sig_en=5e0fb804f7d7bc536008fe175523cf71 -->

  <variablelist>
   <varlistentry>
<!-- pgdoc-cn_start sig_en=07b91b13c5d7b73c110b385b58f0bf71 sig_cn_org=None source=14.1 
    <term>1 quotation mark</term>
________________________________________________________-->
    <term>1 个引号</term>
<!-- pgdoc-cn_end sig_en=07b91b13c5d7b73c110b385b58f0bf71 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=00935b72fd2c8c1b9df0084293efc9d9 sig_cn_org=None source=14.1 
     <para>
      To begin and end the function body, for example:
<programlisting>
CREATE FUNCTION foo() RETURNS integer AS '
          ....
' LANGUAGE plpgsql;
</programlisting>
      Anywhere within a single-quoted function body, quote marks
      <emphasis>must</emphasis> appear in pairs.
     </para>
________________________________________________________-->
     <para>
      用来开始和结束函数体，例如：
<programlisting>
CREATE FUNCTION foo() RETURNS integer AS '
          ....
' LANGUAGE plpgsql;
</programlisting>
      在一个单引号引用的函数体中的任何位置，引号<emphasis>必须</emphasis>成对出现。
     </para>
<!-- pgdoc-cn_end sig_en=00935b72fd2c8c1b9df0084293efc9d9 -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=b47c944b0d7613b715ee1f2388412753 sig_cn_org=None source=14.1 
    <term>2 quotation marks</term>
________________________________________________________-->
    <term>2 个引号</term>
<!-- pgdoc-cn_end sig_en=b47c944b0d7613b715ee1f2388412753 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=5e0d309b796dde37ffee8df8689b42bf sig_cn_org=None source=14.1 
     <para>
      For string literals inside the function body, for example:
<programlisting>
a_output := ''Blah'';
SELECT * FROM users WHERE f_name=''foobar'';
</programlisting>
      In the dollar-quoting approach, you'd just write:
<programlisting>
a_output := 'Blah';
SELECT * FROM users WHERE f_name='foobar';
</programlisting>
      which is exactly what the <application>PL/pgSQL</application> parser would see
      in either case.
     </para>
________________________________________________________-->
     <para>
      用于函数体内的字符串，例如：
<programlisting>
a_output := ''Blah'';
SELECT * FROM users WHERE f_name=''foobar'';
</programlisting>
      在美元引用方法中，你只需要写：
<programlisting>
a_output := 'Blah';
SELECT * FROM users WHERE f_name='foobar';
</programlisting>
      这恰好就是<application>PL/pgSQL</application>在两种情况中会看到的。
     </para>
<!-- pgdoc-cn_end sig_en=5e0d309b796dde37ffee8df8689b42bf -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=ab65b4f49c786f60a8f2cf5b7c08d79f sig_cn_org=None source=14.1 
    <term>4 quotation marks</term>
________________________________________________________-->
    <term>4 个引号</term>
<!-- pgdoc-cn_end sig_en=ab65b4f49c786f60a8f2cf5b7c08d79f -->
    <listitem>
<!-- pgdoc-cn_start sig_en=bfab494d2e6cc281013ccbf1cb31b6c4 sig_cn_org=None source=14.1 
     <para>
      When you need a single quotation mark in a string constant inside the
      function body, for example:
<programlisting>
a_output := a_output || '' AND name LIKE ''''foobar'''' AND xyz''
</programlisting>
      The value actually appended to <literal>a_output</literal> would be:
      <literal> AND name LIKE 'foobar' AND xyz</literal>.
     </para>
________________________________________________________-->
     <para>
      当你在函数内的一个字符串常量中需要一个单引号时，例如：
<programlisting>
a_output := a_output || '' AND name LIKE ''''foobar'''' AND xyz''
</programlisting>
      实际会被追加到<literal>a_output</literal>的值将是：<literal> AND name LIKE 'foobar' AND xyz</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=bfab494d2e6cc281013ccbf1cb31b6c4 -->
<!-- pgdoc-cn_start sig_en=37bb083355daf3e777dd3098de4fbb82 sig_cn_org=None source=14.1 
     <para>
      In the dollar-quoting approach, you'd write:
<programlisting>
a_output := a_output || $$ AND name LIKE 'foobar' AND xyz$$
</programlisting>
      being careful that any dollar-quote delimiters around this are not
      just <literal>$$</literal>.
     </para>
________________________________________________________-->
     <para>
      在美元引用方法中，你可以写：
<programlisting>
a_output := a_output || $$ AND name LIKE 'foobar' AND xyz$$
</programlisting>
      要小心在这周围的任何美元引用定界符不只是<literal>$$</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=37bb083355daf3e777dd3098de4fbb82 -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=2b0f8a0a183a1adfa88bfaa20f26a730 sig_cn_org=None source=14.1 
    <term>6 quotation marks</term>
________________________________________________________-->
    <term>6 个引号</term>
<!-- pgdoc-cn_end sig_en=2b0f8a0a183a1adfa88bfaa20f26a730 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=e0861182d6785be5bf260ce8afd20d5d sig_cn_org=None source=14.1 
     <para>
      When a single quotation mark in a string inside the function body is
      adjacent to the end of that string constant, for example:
<programlisting>
a_output := a_output || '' AND name LIKE ''''foobar''''''
</programlisting>
      The value appended to <literal>a_output</literal> would then be:
      <literal> AND name LIKE 'foobar'</literal>.
     </para>
________________________________________________________-->
     <para>
      当在函数体内的一个字符串中的一个单引号与该字符串常量末尾相邻，例如：
<programlisting>
a_output := a_output || '' AND name LIKE ''''foobar''''''
</programlisting>
      被追加到<literal>a_output</literal>的值则将是：<literal> AND name LIKE 'foobar'</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=e0861182d6785be5bf260ce8afd20d5d -->
<!-- pgdoc-cn_start sig_en=46322f15b46b516ae85fe5d2c6b53913 sig_cn_org=None source=14.1 
     <para>
      In the dollar-quoting approach, this becomes:
<programlisting>
a_output := a_output || $$ AND name LIKE 'foobar'$$
</programlisting>
     </para>
________________________________________________________-->
     <para>
      在美元引用方法中，这会变成：
<programlisting>
a_output := a_output || $$ AND name LIKE 'foobar'$$
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=46322f15b46b516ae85fe5d2c6b53913 -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=cbf59a18ccb927b25425c8b60c769217 sig_cn_org=None source=14.1 
    <term>10 quotation marks</term>
________________________________________________________-->
    <term>10 个引号</term>
<!-- pgdoc-cn_end sig_en=cbf59a18ccb927b25425c8b60c769217 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=c4ff8bd6307c0caa1f33bad0bdfd9131 sig_cn_org=None source=14.1 
     <para>
      When you want two single quotation marks in a string constant (which
      accounts for 8 quotation marks) and this is adjacent to the end of that
      string constant (2 more).  You will probably only need that if
      you are writing a function that generates other functions, as in
      <xref linkend="plpgsql-porting-ex2"/>.
      For example:
<programlisting>
a_output := a_output || '' if v_'' ||
    referrer_keys.kind || '' like ''''''''''
    || referrer_keys.key_string || ''''''''''
    then return ''''''  || referrer_keys.referrer_type
    || ''''''; end if;'';
</programlisting>
      The value of <literal>a_output</literal> would then be:
<programlisting>
if v_... like ''...'' then return ''...''; end if;
</programlisting>
     </para>
________________________________________________________-->
     <para>
      当你想在一个字符串常量（占 8 个引号）中有两个单引号时并且这会挨着该字符串常量的末尾（另外 2 个）。如果你正在写一个产生其他函数的函数（如<xref linkend="plpgsql-porting-ex2"/>中），你将很可能只需要这种。例如：
<programlisting>
a_output := a_output || '' if v_'' ||
    referrer_keys.kind || '' like ''''''''''
    || referrer_keys.key_string || ''''''''''
    then return ''''''  || referrer_keys.referrer_type
    || ''''''; end if;'';
</programlisting>
      <literal>a_output</literal>的值将是：
<programlisting>
if v_... like ''...'' then return ''...''; end if;
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=c4ff8bd6307c0caa1f33bad0bdfd9131 -->
<!-- pgdoc-cn_start sig_en=bc7b6103f2c1697e4e3b928cd699177f sig_cn_org=None source=14.1 
     <para>
      In the dollar-quoting approach, this becomes:
<programlisting>
a_output := a_output || $$ if v_$$ || referrer_keys.kind || $$ like '$$
    || referrer_keys.key_string || $$'
    then return '$$  || referrer_keys.referrer_type
    || $$'; end if;$$;
</programlisting>
      where we assume we only need to put single quote marks into
      <literal>a_output</literal>, because it will be re-quoted before use.
     </para>
________________________________________________________-->
     <para>
      在美元引用方法中，这会变成：
<programlisting>
a_output := a_output || $$ if v_$$ || referrer_keys.kind || $$ like '$$
    || referrer_keys.key_string || $$'
    then return '$$  || referrer_keys.referrer_type
    || $$'; end if;$$;
</programlisting>
      这里我们假定我们只需要把单引号放在<literal>a_output</literal>中，因为在使用前它将被再引用。
     </para>
<!-- pgdoc-cn_end sig_en=bc7b6103f2c1697e4e3b928cd699177f -->
    </listitem>
   </varlistentry>
  </variablelist>

  </sect2>
  <sect2 id="plpgsql-extra-checks">
<!-- pgdoc-cn_start sig_en=e0ac0921b23d5998d911cac22ab06d54 sig_cn_org=None source=14.1 
   <title>Additional Compile-Time and Run-Time Checks</title>
________________________________________________________-->
   <title>额外的编译时和运行时检查</title>
<!-- pgdoc-cn_end sig_en=e0ac0921b23d5998d911cac22ab06d54 -->

<!-- pgdoc-cn_start sig_en=19385a1a806e3d3e6d1fcc9e50242f21 sig_cn_org=None source=14.1 
   <para>
    To aid the user in finding instances of simple but common problems before
    they cause harm, <application>PL/pgSQL</application> provides additional
    <replaceable>checks</replaceable>. When enabled, depending on the configuration, they
    can be used to emit either a <literal>WARNING</literal> or an <literal>ERROR</literal>
    during the compilation of a function. A function which has received
    a <literal>WARNING</literal> can be executed without producing further messages,
    so you are advised to test in a separate development environment.
   </para>
________________________________________________________-->
   <para>
    为了辅助用户在一些简单但常见的问题产生危害之前找到它们，
    <application>PL/pgSQL</application>提供了额外的<replaceable>检查</replaceable>。当被启用时，
    根据配置，它们可以在一个函数的编译期间被用来发出
    <literal>WARNING</literal>或者<literal>ERROR</literal>。一个已经收到了
    <literal>WARNING</literal>的函数可以被继续执行而不会产生进一步的消息，
    因此建议你在一个单独的开发环境中进行测试。
   </para>
<!-- pgdoc-cn_end sig_en=19385a1a806e3d3e6d1fcc9e50242f21 -->

<!-- pgdoc-cn_start sig_en=d31f52c1b6a495b9d215b05b394b4b19 sig_cn_org=None source=14.1 
   <para>
    Setting <varname>plpgsql.extra_warnings</varname>, or
    <varname>plpgsql.extra_errors</varname>, as appropriate, to <literal>"all"</literal>
    is encouraged in development and/or testing environments.
   </para>
________________________________________________________-->
   <para>
    根据需要设置 <varname>plpgsql.extra_warnings</varname> 或 <varname>plpgsql.extra_errors</varname>，适当情况下，在开发和/或测试环境中可以设置为 <literal>"all"</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=d31f52c1b6a495b9d215b05b394b4b19 -->

<!-- pgdoc-cn_start sig_en=580585bf4f6a141f383be2f6248d0df5 sig_cn_org=48c41bc302ec521eaa54d3e848d1f206 source=15.7 
   <para>
    These additional checks are enabled through the configuration variables
    <varname>plpgsql.extra_warnings</varname> for warnings and
    <varname>plpgsql.extra_errors</varname> for errors. Both can be set either to
    a comma-separated list of checks, <literal>"none"</literal> or
    <literal>"all"</literal>. The default is <literal>"none"</literal>. Currently
    the list of available checks includes:
    <variablelist>
     <varlistentry>
      <term><varname>shadowed_variables</varname></term>
      <listitem>
       <para>
        Checks if a declaration shadows a previously defined variable.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>strict_multi_assignment</varname></term>
      <listitem>
       <para>
        Some <application>PL/PgSQL</application> commands allow assigning
        values to more than one variable at a time, such as
        <command>SELECT INTO</command>.  Typically, the number of target
        variables and the number of source variables should match, though
        <application>PL/PgSQL</application> will use <literal>NULL</literal>
        for missing values and extra variables are ignored.  Enabling this
        check will cause <application>PL/PgSQL</application> to throw a
        <literal>WARNING</literal> or <literal>ERROR</literal> whenever the
        number of target variables and the number of source variables are
        different.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>too_many_rows</varname></term>
      <listitem>
       <para>
        Enabling this check will cause <application>PL/PgSQL</application> to
        check if a given query returns more than one row when an
        <literal>INTO</literal> clause is used.  As an <literal>INTO</literal>
        statement will only ever use one row, having a query return multiple
        rows is generally either inefficient and/or nondeterministic and
        therefore is likely an error.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    The following example shows the effect of <varname>plpgsql.extra_warnings</varname>
    set to <varname>shadowed_variables</varname>:
<programlisting>
SET plpgsql.extra_warnings TO 'shadowed_variables';

CREATE FUNCTION foo(f1 int) RETURNS int AS $$
DECLARE
f1 int;
BEGIN
RETURN f1;
END;
$$ LANGUAGE plpgsql;
WARNING:  variable "f1" shadows a previously defined variable
LINE 3: f1 int;
        ^
CREATE FUNCTION
</programlisting>
    The below example shows the effects of setting
    <varname>plpgsql.extra_warnings</varname> to
    <varname>strict_multi_assignment</varname>:
<programlisting>
SET plpgsql.extra_warnings TO 'strict_multi_assignment';

CREATE OR REPLACE FUNCTION public.foo()
 RETURNS void
 LANGUAGE plpgsql
AS $$
DECLARE
  x int;
  y int;
BEGIN
  SELECT 1 INTO x, y;
  SELECT 1, 2 INTO x, y;
  SELECT 1, 2, 3 INTO x, y;
END;
$$;

SELECT foo();
WARNING:  number of source and target fields in assignment does not match
DETAIL:  strict_multi_assignment check of extra_warnings is active.
HINT:  Make sure the query returns the exact list of columns.
WARNING:  number of source and target fields in assignment does not match
DETAIL:  strict_multi_assignment check of extra_warnings is active.
HINT:  Make sure the query returns the exact list of columns.

 foo
-&minus;-&minus;-

(1 row)
</programlisting>
   </para>
________________________________________________________-->
   <para>
    这些额外的检查通过配置变量<varname>plpgsql.extra_warnings</varname>来启用警告，
    以及<varname>plpgsql.extra_errors</varname>来启用错误。两者都可以设置为
    逗号分隔的检查列表，<literal>"none"</literal>或<literal>"all"</literal>。
    默认值为<literal>"none"</literal>。目前可用的检查列表包括：
    <variablelist>
     <varlistentry>
      <term><varname>shadowed_variables</varname></term>
      <listitem>
       <para>
        检查声明是否遮蔽了先前定义的变量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>strict_multi_assignment</varname></term>
      <listitem>
       <para>
        一些<application>PL/PgSQL</application>命令允许一次为多个变量赋值，
        例如<command>SELECT INTO</command>。通常，目标变量的数量和源变量的数量应该匹配，
        尽管<application>PL/PgSQL</application>会对缺失的值使用<literal>NULL</literal>，
        并且额外的变量会被忽略。启用此检查将导致<application>PL/PgSQL</application>
        在目标变量的数量和源变量的数量不同时抛出<literal>WARNING</literal>或<literal>ERROR</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>too_many_rows</varname></term>
      <listitem>
       <para>
        启用此检查将导致<application>PL/PgSQL</application>检查给定查询在使用<literal>INTO</literal>子句时是否返回多行。
        由于<literal>INTO</literal>语句只会使用一行，当查询返回多行时通常是低效和/或不确定性的，因此很可能是错误的。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    以下示例显示了将<varname>plpgsql.extra_warnings</varname>设置为
    <varname>shadowed_variables</varname>的效果：
<programlisting>
SET plpgsql.extra_warnings TO 'shadowed_variables';

CREATE FUNCTION foo(f1 int) RETURNS int AS $$
DECLARE
f1 int;
BEGIN
RETURN f1;
END;
$$ LANGUAGE plpgsql;
WARNING:  variable "f1" shadows a previously defined variable
LINE 3: f1 int;
        ^
CREATE FUNCTION
</programlisting>
    以下示例显示了将<varname>plpgsql.extra_warnings</varname>设置为
    <varname>strict_multi_assignment</varname>的效果：
<programlisting>
SET plpgsql.extra_warnings TO 'strict_multi_assignment';

CREATE OR REPLACE FUNCTION public.foo()
 RETURNS void
 LANGUAGE plpgsql
AS $$
DECLARE
  x int;
  y int;
BEGIN
  SELECT 1 INTO x, y;
  SELECT 1, 2 INTO x, y;
  SELECT 1, 2, 3 INTO x, y;
END;
$$;

SELECT foo();
WARNING:  number of source and target fields in assignment does not match
DETAIL:  strict_multi_assignment check of extra_warnings is active.
HINT:  Make sure the query returns the exact list of columns.
WARNING:  number of source and target fields in assignment does not match
DETAIL:  strict_multi_assignment check of extra_warnings is active.
HINT:  Make sure the query returns the exact list of columns.

 foo
-----

(1 row)
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=580585bf4f6a141f383be2f6248d0df5 -->
  </sect2>
 </sect1>

  <!-- **** Porting from Oracle PL/SQL **** -->

 <sect1 id="plpgsql-porting">
<!-- pgdoc-cn_start sig_en=318e6fcf60bfdd2e5cfac7581a486d3f sig_cn_org=None source=14.1 
  <title>Porting from <productname>Oracle</productname> PL/SQL</title>
________________________________________________________-->
  <title>从<productname>Oracle</productname> PL/SQL 移植</title>
<!-- pgdoc-cn_end sig_en=318e6fcf60bfdd2e5cfac7581a486d3f -->

<!-- pgdoc-cn_start sig_en=d91282e3a70e8e7e7e8417c9c8b68a93 sig_cn_org=None source=14.1 
  <indexterm zone="plpgsql-porting">
   <primary>Oracle</primary>
   <secondary>porting from PL/SQL to PL/pgSQL</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="plpgsql-porting">
   <primary>Oracle</primary>
   <secondary>从 PL/SQL 移植到 PL/pgSQL</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=d91282e3a70e8e7e7e8417c9c8b68a93 -->

<!-- pgdoc-cn_start sig_en=3e618f71df3e6b04dc499766cc2c4bef sig_cn_org=None source=14.1 
  <indexterm zone="plpgsql-porting">
   <primary>PL/SQL (Oracle)</primary>
   <secondary>porting to PL/pgSQL</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="plpgsql-porting">
   <primary>PL/SQL (Oracle)</primary>
   <secondary>移植到 PL/pgSQL</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=3e618f71df3e6b04dc499766cc2c4bef -->

<!-- pgdoc-cn_start sig_en=8e28eace72db1c577ec38cf43015df5e sig_cn_org=None source=14.1 
  <para>
   This section explains differences between
   <productname>PostgreSQL</productname>'s <application>PL/pgSQL</application>
   language and Oracle's <application>PL/SQL</application> language,
   to help developers who port applications from
   <trademark class="registered">Oracle</trademark> to <productname>PostgreSQL</productname>.
  </para>
________________________________________________________-->
  <para>
   这一节解释了<productname>PostgreSQL</productname>的<application>PL/pgSQL</application>语言和 Oracle 的<application>PL/SQL</application>语言之间的差别，用以帮助那些从<trademark class="registered">Oracle</trademark>向<productname>PostgreSQL</productname>移植应用的人。
  </para>
<!-- pgdoc-cn_end sig_en=8e28eace72db1c577ec38cf43015df5e -->

<!-- pgdoc-cn_start sig_en=ae2ab405ca67ae79d8105c7acec6ae68 sig_cn_org=None source=14.1 
  <para>
   <application>PL/pgSQL</application> is similar to PL/SQL in many
   aspects. It is a block-structured, imperative language, and all
   variables have to be declared.  Assignments, loops, and conditionals
   are similar.  The main differences you should keep in mind when
   porting from <application>PL/SQL</application> to
   <application>PL/pgSQL</application> are:

    <itemizedlist>
     <listitem>
      <para>
       If a name used in an SQL command could be either a column name of a
       table used in the command or a reference to a variable of the function,
       <application>PL/SQL</application> treats it as a column name.
       By default, <application>PL/pgSQL</application> will throw an error
       complaining that the name is ambiguous.  You can specify
       <literal>plpgsql.variable_conflict</literal> = <literal>use_column</literal>
       to change this behavior to match <application>PL/SQL</application>,
       as explained in <xref linkend="plpgsql-var-subst"/>.
       It's often best to avoid such ambiguities in the first place,
       but if you have to port a large amount of code that depends on
       this behavior, setting <literal>variable_conflict</literal> may be the
       best solution.
      </para>
     </listitem>

     <listitem>
      <para>
       In <productname>PostgreSQL</productname> the function body must be written as
       a string literal.  Therefore you need to use dollar quoting or escape
       single quotes in the function body. (See <xref
       linkend="plpgsql-quote-tips"/>.)
      </para>
     </listitem>

     <listitem>
      <para>
       Data type names often need translation.  For example, in Oracle string
       values are commonly declared as being of type <type>varchar2</type>, which
       is a non-SQL-standard type.  In <productname>PostgreSQL</productname>,
       use type <type>varchar</type> or <type>text</type> instead.  Similarly, replace
       type <type>number</type> with <type>numeric</type>, or use some other numeric
       data type if there's a more appropriate one.
      </para>
     </listitem>

     <listitem>
      <para>
       Instead of packages, use schemas to organize your functions
       into groups.
      </para>
     </listitem>

     <listitem>
      <para>
       Since there are no packages, there are no package-level variables
       either. This is somewhat annoying.  You can keep per-session state
       in temporary tables instead.
      </para>
     </listitem>

     <listitem>
      <para>
       Integer <command>FOR</command> loops with <literal>REVERSE</literal> work
       differently: <application>PL/SQL</application> counts down from the second
       number to the first, while <application>PL/pgSQL</application> counts down
       from the first number to the second, requiring the loop bounds
       to be swapped when porting.  This incompatibility is unfortunate
       but is unlikely to be changed. (See <xref
       linkend="plpgsql-integer-for"/>.)
      </para>
     </listitem>

     <listitem>
      <para>
       <command>FOR</command> loops over queries (other than cursors) also work
       differently: the target variable(s) must have been declared,
       whereas <application>PL/SQL</application> always declares them implicitly.
       An advantage of this is that the variable values are still accessible
       after the loop exits.
      </para>
     </listitem>

     <listitem>
      <para>
       There are various notational differences for the use of cursor
       variables.
      </para>
     </listitem>

    </itemizedlist>
   </para>
________________________________________________________-->
  <para>
   <application>PL/pgSQL</application>与 PL/SQL 在许多方面都非常类似。它是一种块结构的、命令式的语言并且所有变量必须先被声明。赋值、循环和条件则很类似。在从<application>PL/SQL</application>向<application>PL/pgSQL</application>移植时必须记住一些事情：

    <itemizedlist>
     <listitem>
      <para>
       如果一个 SQL 命令中使用的名字可能是一个表的列名或者是对一个函数中变量的引用，那么<application>PL/SQL</application>会将它当作一个列名。默认情况下， <application>PL/pgSQL</application>会抛出名称模糊的错误， 你可以指定<literal>plpgsql.variable_conflict</literal>=<literal>use_column</literal>来改变这一行为以匹配<application>PL/SQL</application>。如<xref linkend="plpgsql-var-subst"/>中所述。通常最好是首先避免这种歧义，但如果不得不移植依赖于该行为的大量代码，那么设置<literal>variable_conflict</literal>将是最好的方案。
      </para>
     </listitem>

     <listitem>
      <para>
       在<productname>PostgreSQL</productname>中，函数体必须写成字符串文本。因此你需要使用美元符引用或者转义函数体中的单引号（见<xref linkend="plpgsql-quote-tips"/>）。
      </para>
     </listitem>
     
     <listitem>
      <para>
       数据类型名称常常需要翻译。例如，在 Oracle 中字符串值通常被声明为类型<type>varchar2</type>，这并非 SQL 标准类型。在<productname>PostgreSQL</productname>中则要使用类型<type>varchar</type>或者<type>text</type>来替代。类似地，要把类型<type>number</type>替换成<type>numeric</type>，或者在适当的时候使用某种其他数字数据类型。
      </para>
     </listitem>

     <listitem>
      <para>
       应该用模式把函数组织成不同的分组，而不是用包。
      </para>
     </listitem>

     <listitem>
      <para>
       因为没有包，所以也没有包级别的变量。这一点有时候挺讨厌。你可以在临时表里保存会话级别的状态。
      </para>
     </listitem>

     <listitem>
      <para>
       带有<literal>REVERSE</literal>的整数<command>FOR</command>循环的工作方式不同：<application>PL/SQL</application>中是从第二个数向第一个数倒数，而<application>PL/pgSQL</application>是从第一个数向第二个数倒数，因此在移植时需要交换循环边界。不幸的是这种不兼容性是不太可能改变的（见<xref linkend="plpgsql-integer-for"/>）。
      </para>
     </listitem>

     <listitem>
      <para>
       查询上的<command>FOR</command>循环（不是游标）的工作方式同样不同：目标变量必须已经被声明，而<application>PL/SQL</application>总是会隐式地声明它们。但是这样做的优点是在退出循环后，变量值仍然可以访问。
      </para>
     </listitem>

     <listitem>
      <para>
       在使用游标变量方面，存在一些记法差异。
      </para>
     </listitem>

    </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=ae2ab405ca67ae79d8105c7acec6ae68 -->

  <sect2>
<!-- pgdoc-cn_start sig_en=476b6c8d40b8e0ca5d72d00f078d0d05 sig_cn_org=None source=14.1 
   <title>Porting Examples</title>
________________________________________________________-->
   <title>移植示例</title>
<!-- pgdoc-cn_end sig_en=476b6c8d40b8e0ca5d72d00f078d0d05 -->

<!-- pgdoc-cn_start sig_en=9a5f62736d76e6ddd7ae083f42361b4e sig_cn_org=None source=14.1 
   <para>
    <xref linkend="pgsql-porting-ex1"/> shows how to port a simple
    function from <application>PL/SQL</application> to <application>PL/pgSQL</application>.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="pgsql-porting-ex1"/>展示了如何从<application>PL/SQL</application>移植一个简单的函数到<application>PL/pgSQL</application>中。
   </para>
<!-- pgdoc-cn_end sig_en=9a5f62736d76e6ddd7ae083f42361b4e -->

   <example id="pgsql-porting-ex1">
<!-- pgdoc-cn_start sig_en=0ffb11a4cbaf62b05f1c46478a1de41c sig_cn_org=None source=14.1 
    <title>Porting a Simple Function from <application>PL/SQL</application> to <application>PL/pgSQL</application></title>
________________________________________________________-->
    <title>从<application>PL/SQL</application>移植一个简单的函数到<application>PL/pgSQL</application></title>
<!-- pgdoc-cn_end sig_en=0ffb11a4cbaf62b05f1c46478a1de41c -->

<!-- pgdoc-cn_start sig_en=f24a58c2bd7700d0fadd27df472e1d95 sig_cn_org=None source=14.1 
    <para>
     Here is an <productname>Oracle</productname> <application>PL/SQL</application> function:
<programlisting>
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar2,
                                                  v_version varchar2)
RETURN varchar2 IS
BEGIN
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
/
show errors;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     这里有一个<productname>Oracle</productname> <application>PL/SQL</application>函数：
<programlisting>
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar2,
                                                  v_version varchar2)
RETURN varchar2 IS
BEGIN
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
/
show errors;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=f24a58c2bd7700d0fadd27df472e1d95 -->

<!-- pgdoc-cn_start sig_en=bbd46100e552c2666d435c633e5f0a30 sig_cn_org=None source=14.1 
    <para>
     Let's go through this function and see the differences compared to
     <application>PL/pgSQL</application>:

     <itemizedlist>
      <listitem>
       <para>
        The type name <type>varchar2</type> has to be changed to <type>varchar</type>
        or <type>text</type>.  In the examples in this section, we'll
        use <type>varchar</type>, but <type>text</type> is often a better choice if
        you do not need specific string length limits.
       </para>
      </listitem>

      <listitem>
       <para>
        The <literal>RETURN</literal> key word in the function
        prototype (not the function body) becomes
        <literal>RETURNS</literal> in
        <productname>PostgreSQL</productname>.
        Also, <literal>IS</literal> becomes <literal>AS</literal>, and you need to
        add a <literal>LANGUAGE</literal> clause because <application>PL/pgSQL</application>
        is not the only possible function language.
       </para>
      </listitem>

      <listitem>
       <para>
        In <productname>PostgreSQL</productname>, the function body is considered
        to be a string literal, so you need to use quote marks or dollar
        quotes around it.  This substitutes for the terminating <literal>/</literal>
        in the Oracle approach.
       </para>
      </listitem>

      <listitem>
       <para>
        The <literal>show errors</literal> command does not exist in
        <productname>PostgreSQL</productname>, and is not needed since errors are
        reported automatically.
       </para>
      </listitem>
     </itemizedlist>
    </para>
________________________________________________________-->
    <para>
     让我们过一遍这个函数并且看看与<application>PL/pgSQL</application>相比有什么样的不同：

     <itemizedlist>
      <listitem>
       <para>
        类型名称<type>varchar2</type>被改成了<type>varchar</type>或者<type>text</type>。在这一节的例子中，我们将使用<type>varchar</type>，但如果不需要特定的字符串长度限制，<type>text</type>常常是更好的选择。
       </para>
      </listitem>
      
      <listitem>
       <para>
        在函数原型中（不是函数体中）的<literal>RETURN</literal>关键字在<productname>PostgreSQL</productname>中变成了<literal>RETURNS</literal>。还有，<literal>IS</literal>变成了<literal>AS</literal>，并且你还需要增加一个<literal>LANGUAGE</literal>子句，因为<application>PL/pgSQL</application>并非唯一可用的函数语言。
       </para>
      </listitem>

      <listitem>
       <para>
        在<productname>PostgreSQL</productname>中，函数体被认为是一个字符串，所以你需要使用引号或者美元符号包围它。这代替了Oracle 方法中的用于终止的<literal>/</literal>。
       </para>
      </listitem>

      <listitem>
       <para>
        在<productname>PostgreSQL</productname>中没有<literal>show errors</literal>命令, 并且也不需要这个命令，因为错误是自动报告的。
       </para>
      </listitem>
     </itemizedlist>
    </para>
<!-- pgdoc-cn_end sig_en=bbd46100e552c2666d435c633e5f0a30 -->

<!-- pgdoc-cn_start sig_en=5328be1adf051d23bd0685b4935b6f8a sig_cn_org=None source=14.1 
    <para>
     This is how this function would look when ported to
     <productname>PostgreSQL</productname>:

<programlisting>
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,
                                                  v_version varchar)
RETURNS varchar AS $$
BEGIN
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     这个函数被移植到<productname>PostgreSQL</productname>后看起来会是这样：

<programlisting>
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,
                                                  v_version varchar)
RETURNS varchar AS $$
BEGIN
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=5328be1adf051d23bd0685b4935b6f8a -->
   </example>

<!-- pgdoc-cn_start sig_en=05f9e0270665e18001151fee272b5791 sig_cn_org=None source=14.1 
   <para>
    <xref linkend="plpgsql-porting-ex2"/> shows how to port a
    function that creates another function and how to handle the
    ensuing quoting problems.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="plpgsql-porting-ex2"/>展示了如何移植一个会创建另一个函数的函数，以及如何处理引号问题。
   </para>
<!-- pgdoc-cn_end sig_en=05f9e0270665e18001151fee272b5791 -->

   <example id="plpgsql-porting-ex2">
<!-- pgdoc-cn_start sig_en=4de53271898721cd3e935b5b6c2a8b49 sig_cn_org=None source=14.1 
    <title>Porting a Function that Creates Another Function from <application>PL/SQL</application> to <application>PL/pgSQL</application></title>
________________________________________________________-->
    <title>从<application>PL/SQL</application>移植一个创建另一个函数的函数到<application>PL/pgSQL</application></title>
<!-- pgdoc-cn_end sig_en=4de53271898721cd3e935b5b6c2a8b49 -->

<!-- pgdoc-cn_start sig_en=d359115b35cf7a25fa23f487b3501a27 sig_cn_org=None source=14.1 
    <para>
     The following procedure grabs rows from a
     <command>SELECT</command> statement and builds a large function
     with the results in <literal>IF</literal> statements, for the
     sake of efficiency.
    </para>
________________________________________________________-->
    <para>
     下面的过程从一个<command>SELECT</command>语句抓取行，并且为了效率而构建一个带有<literal>IF</literal>语句中结果的大型函数。
    </para>
<!-- pgdoc-cn_end sig_en=d359115b35cf7a25fa23f487b3501a27 -->

<!-- pgdoc-cn_start sig_en=0ed118e14f2eda77b98a3f6b6f4d81d4 sig_cn_org=None source=14.1 
    <para>
     This is the Oracle version:
<programlisting>
CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc IS
    CURSOR referrer_keys IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_cmd VARCHAR(4000);
BEGIN
    func_cmd := 'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host IN VARCHAR2,
                 v_domain IN VARCHAR2, v_url IN VARCHAR2) RETURN VARCHAR2 IS BEGIN';

    FOR referrer_key IN referrer_keys LOOP
        func_cmd := func_cmd ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ''' || referrer_key.key_string
          || ''' THEN RETURN ''' || referrer_key.referrer_type
          || '''; END IF;';
    END LOOP;

    func_cmd := func_cmd || ' RETURN NULL; END;';

    EXECUTE IMMEDIATE func_cmd;
END;
/
show errors;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     这是 Oracle 版本：
<programlisting>
CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc IS
    CURSOR referrer_keys IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_cmd VARCHAR(4000);
BEGIN
    func_cmd := 'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host IN VARCHAR2,
                 v_domain IN VARCHAR2, v_url IN VARCHAR2) RETURN VARCHAR2 IS BEGIN';
                 
    FOR referrer_key IN referrer_keys LOOP
        func_cmd := func_cmd ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ''' || referrer_key.key_string
          || ''' THEN RETURN ''' || referrer_key.referrer_type
          || '''; END IF;';
    END LOOP;

    func_cmd := func_cmd || ' RETURN NULL; END;';

    EXECUTE IMMEDIATE func_cmd;
END;
/
show errors;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=0ed118e14f2eda77b98a3f6b6f4d81d4 -->

<!-- pgdoc-cn_start sig_en=4a609c64d6d946b10a112d2efbf57a29 sig_cn_org=None source=14.1 
    <para>
     Here is how this function would end up in <productname>PostgreSQL</productname>:
<programlisting>
CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc() AS $func$
DECLARE
    referrer_keys CURSOR IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_body text;
    func_cmd text;
BEGIN
    func_body := 'BEGIN';

    FOR referrer_key IN referrer_keys LOOP
        func_body := func_body ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ' || quote_literal(referrer_key.key_string)
          || ' THEN RETURN ' || quote_literal(referrer_key.referrer_type)
          || '; END IF;' ;
    END LOOP;

    func_body := func_body || ' RETURN NULL; END;';

    func_cmd :=
      'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host varchar,
                                                        v_domain varchar,
                                                        v_url varchar)
        RETURNS varchar AS '
      || quote_literal(func_body)
      || ' LANGUAGE plpgsql;' ;

    EXECUTE func_cmd;
END;
$func$ LANGUAGE plpgsql;
</programlisting>
     Notice how the body of the function is built separately and passed
     through <literal>quote_literal</literal> to double any quote marks in it.  This
     technique is needed because we cannot safely use dollar quoting for
     defining the new function: we do not know for sure what strings will
     be interpolated from the <structfield>referrer_key.key_string</structfield> field.
     (We are assuming here that <structfield>referrer_key.kind</structfield> can be
     trusted to always be <literal>host</literal>, <literal>domain</literal>, or
     <literal>url</literal>, but <structfield>referrer_key.key_string</structfield> might be
     anything, in particular it might contain dollar signs.) This function
     is actually an improvement on the Oracle original, because it will
     not generate broken code when <structfield>referrer_key.key_string</structfield> or
     <structfield>referrer_key.referrer_type</structfield> contain quote marks.
    </para>
________________________________________________________-->
    <para>
     这里是<productname>PostgreSQL</productname>的版本：
<programlisting>
CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc() RETURNS void AS $func$
DECLARE
    referrer_keys CURSOR IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_body text;
    func_cmd text;
BEGIN
    func_body := 'BEGIN';

    FOR referrer_key IN referrer_keys LOOP
        func_body := func_body ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ' || quote_literal(referrer_key.key_string)
          || ' THEN RETURN ' || quote_literal(referrer_key.referrer_type)
          || '; END IF;' ;
    END LOOP;

    func_body := func_body || ' RETURN NULL; END;';

    func_cmd :=
      'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host varchar,
                                                        v_domain varchar,
                                                        v_url varchar)
        RETURNS varchar AS '
      || quote_literal(func_body)
      || ' LANGUAGE plpgsql;' ;

    EXECUTE func_cmd;
END;
$func$ LANGUAGE plpgsql;
</programlisting>
     请注意函数体是如何被单独构建并且通过<literal>quote_literal</literal>被传递以双写其中的任何引号。需要这个技术是因为无法安全地使用美元引用定义新函数：我们不确定从<structfield>referrer_key.key_string</structfield>域中来的什么字符串会被插入（我们这里假定<structfield>referrer_key.kind</structfield>可以确信总是为<literal>host</literal>、<literal>domain</literal>或者<literal>url</literal>，但是<structfield>referrer_key.key_string</structfield>可能是任何东西，特别是它可能包含美元符号）。这个函数实际上是在 Oracle 的原版上的改进，因为当<structfield>referrer_key.key_string</structfield>或者<structfield>referrer_key.referrer_type</structfield>包含引号时，它将不会生成坏掉的代码。
    </para>
<!-- pgdoc-cn_end sig_en=4a609c64d6d946b10a112d2efbf57a29 -->
   </example>

<!-- pgdoc-cn_start sig_en=a91f3d9dc797c6c2dedbeb33ed88d877 sig_cn_org=None source=14.1 
   <para>
    <xref linkend="plpgsql-porting-ex3"/> shows how to port a function
    with <literal>OUT</literal> parameters and string manipulation.
    <productname>PostgreSQL</productname> does not have a built-in
    <function>instr</function> function, but you can create one
    using a combination of other
    functions. In <xref linkend="plpgsql-porting-appendix"/> there is a
    <application>PL/pgSQL</application> implementation of
    <function>instr</function> that you can use to make your porting
    easier.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="plpgsql-porting-ex3"/>展示了如何移植一个带有<literal>OUT</literal>参数和字符串处理的函数。<productname>PostgreSQL</productname>没有内建的<function>instr</function>函数，但是你可以用其它函数的组合来创建一个。在<xref linkend="plpgsql-porting-appendix"/>中有一个<function>instr</function>的<application>PL/pgSQL</application>实现，你可以用它让你的移植变得更容易。
   </para>
<!-- pgdoc-cn_end sig_en=a91f3d9dc797c6c2dedbeb33ed88d877 -->

   <example id="plpgsql-porting-ex3">
<!-- pgdoc-cn_start sig_en=419955a574cc208c688b42331938be80 sig_cn_org=None source=14.1 
    <title>Porting a Procedure With String Manipulation and
    <literal>OUT</literal> Parameters from <application>PL/SQL</application> to
    <application>PL/pgSQL</application></title>
________________________________________________________-->
    <title>从<application>PL/SQL</application>移植一个带有字符串操作以及<literal>OUT</literal>参数的过程到<application>PL/pgSQL</application></title>
<!-- pgdoc-cn_end sig_en=419955a574cc208c688b42331938be80 -->

<!-- pgdoc-cn_start sig_en=4e2d9be56490488a4f2de1a69e6d0427 sig_cn_org=None source=14.1 
    <para>
     The following <productname>Oracle</productname> PL/SQL procedure is used
     to parse a URL and return several elements (host, path, and query).
    </para>
________________________________________________________-->
    <para>
     下面的<productname>Oracle</productname> PL/SQL 过程被用来解析一个 URL 并且返回一些元素（主机、路径和查询）。
    </para>
<!-- pgdoc-cn_end sig_en=4e2d9be56490488a4f2de1a69e6d0427 -->

<!-- pgdoc-cn_start sig_en=cced29d21170ca5101629199b952182a sig_cn_org=None source=14.1 
    <para>
     This is the Oracle version:
<programlisting>
CREATE OR REPLACE PROCEDURE cs_parse_url(
    v_url IN VARCHAR2,
    v_host OUT VARCHAR2,  -&minus; This will be passed back
    v_path OUT VARCHAR2,  -&minus; This one too
    v_query OUT VARCHAR2) -&minus; And this one
IS
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEGIN
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
/
show errors;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     这是 Oracle 版本：
<programlisting>
CREATE OR REPLACE PROCEDURE cs_parse_url(
    v_url IN VARCHAR2,
    v_host OUT VARCHAR2,  -- 这将被传回去
    v_path OUT VARCHAR2,  -- 这个也是
    v_query OUT VARCHAR2) -- 还有这个
IS
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEGIN
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
/
show errors;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=cced29d21170ca5101629199b952182a -->

<!-- pgdoc-cn_start sig_en=9b345af9d50d1b0f2205128dbab28db3 sig_cn_org=None source=14.1 
    <para>
     Here is a possible translation into <application>PL/pgSQL</application>:
<programlisting>
CREATE OR REPLACE FUNCTION cs_parse_url(
    v_url IN VARCHAR,
    v_host OUT VARCHAR,  -&minus; This will be passed back
    v_path OUT VARCHAR,  -&minus; This one too
    v_query OUT VARCHAR) -&minus; And this one
AS $$
DECLARE
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEGIN
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
$$ LANGUAGE plpgsql;
</programlisting>

     This function could be used like this:
<programlisting>
SELECT * FROM cs_parse_url('http://foobar.com/query.cgi?baz');
</programlisting>
    </para>
________________________________________________________-->
    <para>
     这里是一种到<application>PL/pgSQL</application>的可能翻译：
<programlisting>
CREATE OR REPLACE FUNCTION cs_parse_url(
    v_url IN VARCHAR,
    v_host OUT VARCHAR,  -- 这将被传递回去
    v_path OUT VARCHAR,  -- 这个也是
    v_query OUT VARCHAR) -- 以及这个
AS $$
DECLARE
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEGIN
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
$$ LANGUAGE plpgsql;
</programlisting>

     这个函数可以这样使用：
<programlisting>
SELECT * FROM cs_parse_url('http://foobar.com/query.cgi?baz');
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=9b345af9d50d1b0f2205128dbab28db3 -->
   </example>

<!-- pgdoc-cn_start sig_en=f9179c94dc9a636b01c8283c304e89fe sig_cn_org=None source=14.1 
   <para>
    <xref linkend="plpgsql-porting-ex4"/> shows how to port a procedure
    that uses numerous features that are specific to Oracle.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="plpgsql-porting-ex4"/>展示了如何移植一个使用了多种 Oracle 特性的过程。
   </para>
<!-- pgdoc-cn_end sig_en=f9179c94dc9a636b01c8283c304e89fe -->

   <example id="plpgsql-porting-ex4">
<!-- pgdoc-cn_start sig_en=cd628629e5df9957f64e729115328530 sig_cn_org=None source=14.1 
    <title>Porting a Procedure from <application>PL/SQL</application> to <application>PL/pgSQL</application></title>
________________________________________________________-->
    <title>从<application>PL/SQL</application>移植一个过程到<application>PL/pgSQL</application></title>
<!-- pgdoc-cn_end sig_en=cd628629e5df9957f64e729115328530 -->

<!-- pgdoc-cn_start sig_en=7a686266d2b7b1f05ed1f94ce42427a2 sig_cn_org=None source=14.1 
    <para>
     The Oracle version:

<programlisting>
CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id IN INTEGER) IS
    a_running_job_count INTEGER;
BEGIN
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
        COMMIT; -&minus; free lock
        raise_application_error(-20000,
                 'Unable to create a new job: a job is currently running.');
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEGIN
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());
    EXCEPTION
        WHEN dup_val_on_index THEN NULL; -&minus; don't worry if it already exists
    END;
    COMMIT;
END;
/
show errors
</programlisting>
   </para>
________________________________________________________-->
    <para>
     Oracle 版本：

<programlisting>
CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id IN INTEGER) IS
    a_running_job_count INTEGER;
BEGIN
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
        COMMIT; -- 释放锁
        raise_application_error(-20000,
                 'Unable to create a new job: a job is currently running.');
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEGIN
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());
    EXCEPTION
        WHEN dup_val_on_index THEN NULL; -- 如果已经存在也不用担心
    END;
    COMMIT;
END;
/
show errors
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=7a686266d2b7b1f05ed1f94ce42427a2 -->

<!-- pgdoc-cn_start sig_en=f890a929cf4a36508eec0e43ededd1d8 sig_cn_org=None source=14.1 
   <para>
    This is how we could port this procedure to <application>PL/pgSQL</application>:

<programlisting>
CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id integer) AS $$
DECLARE
    a_running_job_count integer;
BEGIN
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
        COMMIT; -&minus; free lock
        RAISE EXCEPTION 'Unable to create a new job: a job is currently running'; -&minus; <co id="co.plpgsql-porting-raise"/>
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEGIN
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());
    EXCEPTION
        WHEN unique_violation THEN -&minus; <co id="co.plpgsql-porting-exception"/>
            -&minus; don't worry if it already exists
    END;
    COMMIT;
END;
$$ LANGUAGE plpgsql;
</programlisting>

    <calloutlist>
     <callout arearefs="co.plpgsql-porting-raise">
      <para>
       The syntax of <literal>RAISE</literal> is considerably different from
       Oracle's statement, although the basic case <literal>RAISE</literal>
       <replaceable class="parameter">exception_name</replaceable> works
       similarly.
      </para>
     </callout>
     <callout arearefs="co.plpgsql-porting-exception">
      <para>
       The exception names supported by <application>PL/pgSQL</application> are
       different from Oracle's.  The set of built-in exception names
       is much larger (see <xref linkend="errcodes-appendix"/>).  There
       is not currently a way to declare user-defined exception names,
       although you can throw user-chosen SQLSTATE values instead.
      </para>
     </callout>
    </calloutlist>
   </para>
________________________________________________________-->
   <para>
    这是我们如何将这个过程移植到<application>PL/pgSQL</application>：

<programlisting>
CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id integer) RETURNS void AS $$
DECLARE
    a_running_job_count integer;
BEGIN
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
        COMMIT; -- 释放锁
        RAISE EXCEPTION 'Unable to create a new job: a job is currently running'; -- <co id="co.plpgsql-porting-raise"/>
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEGIN
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());
    EXCEPTION
        WHEN unique_violation THEN -- <co id="co.plpgsql-porting-exception"/>
            -- 如果已经存在不要担心
    END;
    COMMIT;
END;
$$ LANGUAGE plpgsql;
</programlisting>

    <calloutlist>
     <callout arearefs="co.plpgsql-porting-raise">
      <para>
       <literal>RAISE</literal>的语法与 Oracle 的语句相当不同，尽管基本的形式<literal>RAISE</literal> <replaceable class="parameter">exception_name</replaceable>工作起来是相似的。
      </para>
     </callout>
     <callout arearefs="co.plpgsql-porting-exception">
      <para>
       <application>PL/pgSQL</application>所支持的异常名称不同于 Oracle。内建的异常名称集合要更大（见<xref linkend="errcodes-appendix"/>）。目前没有办法声明用户定义的异常名称，尽管你能够抛出用户选择的 SQLSTATE 值。
      </para>
     </callout>
    </calloutlist>
   </para>
<!-- pgdoc-cn_end sig_en=f890a929cf4a36508eec0e43ededd1d8 -->
   </example>
  </sect2>

  <sect2 id="plpgsql-porting-other">
<!-- pgdoc-cn_start sig_en=84478019f2d89795b8a2b14f2b23a9db sig_cn_org=None source=14.1 
   <title>Other Things to Watch For</title>
________________________________________________________-->
   <title>其他要关注的事项</title>
<!-- pgdoc-cn_end sig_en=84478019f2d89795b8a2b14f2b23a9db -->

<!-- pgdoc-cn_start sig_en=900748e6a9dfd83965c200fc1cde1f7e sig_cn_org=None source=14.1 
   <para>
    This section explains a few other things to watch for when porting
    Oracle <application>PL/SQL</application> functions to
    <productname>PostgreSQL</productname>.
   </para>
________________________________________________________-->
   <para>
    这一节解释了在移植 Oracle <application>PL/SQL</application>函数到<productname>PostgreSQL</productname>中时要关注的一些其他问题。
   </para>
<!-- pgdoc-cn_end sig_en=900748e6a9dfd83965c200fc1cde1f7e -->

   <sect3 id="plpgsql-porting-exceptions">
<!-- pgdoc-cn_start sig_en=c418d535c27d644324d757a0526a722c sig_cn_org=None source=14.1 
    <title>Implicit Rollback after Exceptions</title>
________________________________________________________-->
    <title>异常后隐式回滚</title>
<!-- pgdoc-cn_end sig_en=c418d535c27d644324d757a0526a722c -->

<!-- pgdoc-cn_start sig_en=10a8bcd196276ba3d18c7884bbaa5a4a sig_cn_org=None source=14.1 
    <para>
     In <application>PL/pgSQL</application>, when an exception is caught by an
     <literal>EXCEPTION</literal> clause, all database changes since the block's
     <literal>BEGIN</literal> are automatically rolled back.  That is, the behavior
     is equivalent to what you'd get in Oracle with:

<programlisting>
BEGIN
    SAVEPOINT s1;
    ... code here ...
EXCEPTION
    WHEN ... THEN
        ROLLBACK TO s1;
        ... code here ...
    WHEN ... THEN
        ROLLBACK TO s1;
        ... code here ...
END;
</programlisting>

     If you are translating an Oracle procedure that uses
     <command>SAVEPOINT</command> and <command>ROLLBACK TO</command> in this style,
     your task is easy: just omit the <command>SAVEPOINT</command> and
     <command>ROLLBACK TO</command>.  If you have a procedure that uses
     <command>SAVEPOINT</command> and <command>ROLLBACK TO</command> in a different way
     then some actual thought will be required.
    </para>
________________________________________________________-->
    <para>
     在<application>PL/pgSQL</application>，当一个异常被<literal>EXCEPTION</literal>子句捕获之后，从该块的<literal>BEGIN</literal>以来的所有数据库改变都会被自动回滚。也就是，该行为等效于你在 Oracle 中用下面的代码得到的效果：

<programlisting>
BEGIN
    SAVEPOINT s1;
    ... 代码 ...
EXCEPTION
    WHEN ... THEN
        ROLLBACK TO s1;
        ... 代码 ...
    WHEN ... THEN
        ROLLBACK TO s1;
        ... 代码 ...
END;
</programlisting>

     如果你正在翻译一个使用这种风格的<command>SAVEPOINT</command>以及<command>ROLLBACK TO</command>的 Oracle 过程，你的工作比较简单：只要忽略掉<command>SAVEPOINT</command>以及<command>ROLLBACK TO</command>。如果你的 Oracle 过程是以不同的方法使用<command>SAVEPOINT</command>以及<command>ROLLBACK TO</command>，那么就要真正地动一番脑筋了。
    </para>
<!-- pgdoc-cn_end sig_en=10a8bcd196276ba3d18c7884bbaa5a4a -->
   </sect3>

   <sect3>
    <title><command>EXECUTE</command></title>

<!-- pgdoc-cn_start sig_en=e9332f344e941f777f5cfd6e885111c5 sig_cn_org=None source=14.1 
    <para>
     The <application>PL/pgSQL</application> version of
     <command>EXECUTE</command> works similarly to the
     <application>PL/SQL</application> version, but you have to remember to use
     <function>quote_literal</function> and
     <function>quote_ident</function> as described in <xref
     linkend="plpgsql-statements-executing-dyn"/>.  Constructs of the
     type <literal>EXECUTE 'SELECT * FROM $1';</literal> will not work
     reliably unless you use these functions.
    </para>
________________________________________________________-->
    <para>
     <application>PL/pgSQL</application>的<command>EXECUTE</command>与<application>PL/SQL</application>中的工作相似，但是必须要记住按照<xref linkend="plpgsql-statements-executing-dyn"/>中所述地使用<function>quote_literal</function>以及<function>quote_ident</function>。<literal>EXECUTE 'SELECT * FROM $1';</literal>类型的结构将无法可靠地工作除非你使用这些函数。
    </para>
<!-- pgdoc-cn_end sig_en=e9332f344e941f777f5cfd6e885111c5 -->
   </sect3>

   <sect3 id="plpgsql-porting-optimization">
<!-- pgdoc-cn_start sig_en=83b406e617598b7781406fb0177722b2 sig_cn_org=None source=14.1 
    <title>Optimizing <application>PL/pgSQL</application> Functions</title>
________________________________________________________-->
    <title>优化 <application>PL/pgSQL</application> 函数</title>
<!-- pgdoc-cn_end sig_en=83b406e617598b7781406fb0177722b2 -->

<!-- pgdoc-cn_start sig_en=60a5fe603c4f90dd753c2d787a10bf73 sig_cn_org=None source=14.1 
    <para>
     <productname>PostgreSQL</productname> gives you two function creation
     modifiers to optimize execution: <quote>volatility</quote> (whether
     the function always returns the same result when given the same
     arguments) and <quote>strictness</quote> (whether the function
     returns null if any argument is null).  Consult the <xref
     linkend="sql-createfunction"/>
     reference page for details.
    </para>
________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>提供了两种函数创建修饰符来优化执行：<quote>volatility</quote>（对于给定的相同参数，函数是否总是返回相同的结果）以及<quote>strictness</quote> （如果任何参数为空，函数是否返回空）。详见<xref linkend="sql-createfunction"/>参考页。
    </para>
<!-- pgdoc-cn_end sig_en=60a5fe603c4f90dd753c2d787a10bf73 -->

<!-- pgdoc-cn_start sig_en=f71befc893d61e02759dfda5ddf4922c sig_cn_org=None source=14.1 
    <para>
     When making use of these optimization attributes, your
     <command>CREATE FUNCTION</command> statement might look something
     like this:

<programlisting>
CREATE FUNCTION foo(...) RETURNS integer AS $$
...
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     在利用这些优化属性时，你的<command>CREATE FUNCTION</command>语句应该看起来像这样：

<programlisting>
CREATE FUNCTION foo(...) RETURNS integer AS $$
...
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=f71befc893d61e02759dfda5ddf4922c -->
   </sect3>
  </sect2>

  <sect2 id="plpgsql-porting-appendix">
<!-- pgdoc-cn_start sig_en=bb6b049fdcb5e7a158aa9df9b14e35f7 sig_cn_org=None source=14.1 
   <title>Appendix</title>
________________________________________________________-->
   <title>附录</title>
<!-- pgdoc-cn_end sig_en=bb6b049fdcb5e7a158aa9df9b14e35f7 -->

<!-- pgdoc-cn_start sig_en=14e6e2e7246f841f83ccb9cd0497acd6 sig_cn_org=None source=14.1 
   <para>
    This section contains the code for a set of Oracle-compatible
    <function>instr</function> functions that you can use to simplify
    your porting efforts.
   </para>
________________________________________________________-->
   <para>
    这一节包含了一组 Oracle 兼容的<function>instr</function>函数代码，你可以用它来简化你的移植工作。
   </para>
<!-- pgdoc-cn_end sig_en=14e6e2e7246f841f83ccb9cd0497acd6 -->

<!-- pgdoc-cn_start sig_en=9f34b7a9f1f039aa2c18251d759ec1aa sig_cn_org=None source=14.1 
   <indexterm>
    <primary><function>instr</function> function</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary><function>instr</function> 函数</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=9f34b7a9f1f039aa2c18251d759ec1aa -->

<programlisting><![CDATA[
--
-- instr functions that mimic Oracle's counterpart
-- Syntax: instr(string1, string2 [, n [, m]])
-- where [] denotes optional parameters.
--
-- Search string1, beginning at the nth character, for the mth occurrence
-- of string2.  If n is negative, search backwards, starting at the abs(n)'th
-- character from the end of string1.
-- If n is not passed, assume 1 (search starts at first character).
-- If m is not passed, assume 1 (find first occurrence).
-- Returns starting index of string2 in string1, or 0 if string2 is not found.
--

CREATE FUNCTION instr(varchar, varchar) RETURNS integer AS $$
BEGIN
    RETURN instr($1, $2, 1);
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search_for varchar,
                      beg_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index > 0 THEN
        temp_str := substring(string FROM beg_index);
        pos := position(string_to_search_for IN temp_str);

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN pos + beg_index - 1;
        END IF;
    ELSIF beg_index < 0 THEN
        ss_length := char_length(string_to_search_for);
        length := char_length(string);
        beg := length + 1 + beg_index;

        WHILE beg > 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            IF string_to_search_for = temp_str THEN
                RETURN beg;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    ELSE
        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search_for varchar,
                      beg_index integer, occur_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    occur_number integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    i integer;
    length integer;
    ss_length integer;
BEGIN
    IF occur_index <= 0 THEN
        RAISE 'argument ''%'' is out of range', occur_index
          USING ERRCODE = '22003';
    END IF;

    IF beg_index > 0 THEN
        beg := beg_index - 1;
        FOR i IN 1..occur_index LOOP
            temp_str := substring(string FROM beg + 1);
            pos := position(string_to_search_for IN temp_str);
            IF pos = 0 THEN
                RETURN 0;
            END IF;
            beg := beg + pos;
        END LOOP;

        RETURN beg;
    ELSIF beg_index < 0 THEN
        ss_length := char_length(string_to_search_for);
        length := char_length(string);
        beg := length + 1 + beg_index;

        WHILE beg > 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            IF string_to_search_for = temp_str THEN
                occur_number := occur_number + 1;
                IF occur_number = occur_index THEN
                    RETURN beg;
                END IF;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    ELSE
        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
]]>
</programlisting>
  </sect2>

 </sect1>

</chapter>
