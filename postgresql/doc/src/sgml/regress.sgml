<!-- doc/src/sgml/regress.sgml -->

 <chapter id="regress">
<!-- pgdoc-cn_start sig_en=6769bdcd94492cefcf5a6600b5cce8b6 sig_cn_org=None source=14.1 
  <title>Regression Tests</title>
________________________________________________________-->
  <title>回归测试</title>
<!-- pgdoc-cn_end sig_en=6769bdcd94492cefcf5a6600b5cce8b6 -->

<!-- pgdoc-cn_start sig_en=59c35b4bf3ed20eb0759d828069a2832 sig_cn_org=None source=14.1 
  <indexterm zone="regress">
   <primary>regression tests</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="regress">
   <primary>regression tests</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=59c35b4bf3ed20eb0759d828069a2832 -->

<!-- pgdoc-cn_start sig_en=c0fc4cbc8d6f497bbd76e300a4b04ae2 sig_cn_org=None source=14.1 
  <indexterm zone="regress">
   <primary>test</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="regress">
   <primary>test</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=c0fc4cbc8d6f497bbd76e300a4b04ae2 -->

<!-- pgdoc-cn_start sig_en=fea3faeadc204972bc1d6525c0d55156 sig_cn_org=None source=14.1 
  <para>
   The regression tests are a comprehensive set of tests for the SQL
   implementation in <productname>PostgreSQL</productname>.  They test
   standard SQL operations as well as the extended capabilities of
   <productname>PostgreSQL</productname>.
  </para>
________________________________________________________-->
  <para>
   回归测试是<productname>PostgreSQL</productname>中对于 SQL 实现的一组综合测试集。它们测试标准 SQL 操作以及<productname>PostgreSQL</productname>的扩展能力。
  </para>
<!-- pgdoc-cn_end sig_en=fea3faeadc204972bc1d6525c0d55156 -->

  <sect1 id="regress-run">
<!-- pgdoc-cn_start sig_en=9f810b985ad99f11a1b4c3d56c9a99dd sig_cn_org=None source=14.1 
   <title>Running the Tests</title>
________________________________________________________-->
   <title>运行测试</title>
<!-- pgdoc-cn_end sig_en=9f810b985ad99f11a1b4c3d56c9a99dd -->

<!-- pgdoc-cn_start sig_en=7c4f6346f197ce688b03acea1c4642df sig_cn_org=None source=14.1 
  <para>
   The regression tests can be run against an already installed and
   running server, or using a temporary installation within the build
   tree.  Furthermore, there is a <quote>parallel</quote> and a
   <quote>sequential</quote> mode for running the tests.  The
   sequential method runs each test script alone, while the
   parallel method starts up multiple server processes to run groups
   of tests in parallel.  Parallel testing adds confidence that
   interprocess communication and locking are working correctly.
  </para>
________________________________________________________-->
  <para>
   回归测试可以在一个已经安装并运行的服务器上运行，或者在编译树中的一个临时安装上运行。此外，还有运行该测试的<quote>并行</quote>和<quote>顺序</quote>模式。顺序方法单独运行每一个测试脚本，而并行方法则开启多个服务器进程来并行地运行多组测试。并行测试能够发现进程间通信和锁定是否工作正确。
  </para>
<!-- pgdoc-cn_end sig_en=7c4f6346f197ce688b03acea1c4642df -->

  <sect2>
<!-- pgdoc-cn_start sig_en=30303ad3a8761d7d3beaa75c59bb3bf8 sig_cn_org=None source=14.1 
   <title>Running the Tests Against a Temporary Installation</title>
________________________________________________________-->
   <title>在一个临时安装上运行测试</title>
<!-- pgdoc-cn_end sig_en=30303ad3a8761d7d3beaa75c59bb3bf8 -->

<!-- pgdoc-cn_start sig_en=151e9b9a04274ed75caa48f2cc946344 sig_cn_org=None source=14.1 
  <para>
   To run the parallel regression tests after building but before installation,
   type:
<screen>
make check
</screen>
   in the top-level directory.  (Or you can change to
   <filename>src/test/regress</filename> and run the command there.)
   At the end you should see something like:
<screen>
<computeroutput>
=======================
 All 193 tests passed.
=======================
</computeroutput>
</screen>
   or otherwise a note about which tests failed.  See <xref
   linkend="regress-evaluation"/> below before assuming that a
   <quote>failure</quote> represents a serious problem.
  </para>
________________________________________________________-->
  <para>
   要在编译之后且在安装之前运行并行回归测试，可在顶层目录中键入：
<screen>
make check
</screen>
   （或者你可以切换到<filename>src/test/regress</filename>并且在那里运行该命令）。最后你应该看到这样的信息：
<screen>
<computeroutput>
=======================
 All 193 tests passed.
=======================
</computeroutput>
</screen>
   或者关于哪些测试失败的提示。见下面的<xref linkend="regress-evaluation"/>来确定一个<quote>失败</quote>是否表示一个严重的问题。
  </para>
<!-- pgdoc-cn_end sig_en=151e9b9a04274ed75caa48f2cc946344 -->

<!-- pgdoc-cn_start sig_en=c0ed46061b4ee58148652602a22f10f2 sig_cn_org=None source=14.1 
   <para>
    Because this test method runs a temporary server, it will not work
    if you did the build as the root user, since the server will not start as
    root.  Recommended procedure is not to do the build as root, or else to
    perform testing after completing the installation.
   </para>
________________________________________________________-->
   <para>
    因为这种测试方法运行一个临时服务器，如果你作为根用户进行了编译，它将无法工作，因为服务器无法用 root 启动。我们推荐的过程是不要作为 root 编译，或者在完成安装后执行测试。
   </para>
<!-- pgdoc-cn_end sig_en=c0ed46061b4ee58148652602a22f10f2 -->

<!-- pgdoc-cn_start sig_en=30c40510adc9d92613f54f3b98329387 sig_cn_org=None source=14.1 
   <para>
    If you have configured <productname>PostgreSQL</productname> to install
    into a location where an older <productname>PostgreSQL</productname>
    installation already exists, and you perform <literal>make check</literal>
    before installing the new version, you might find that the tests fail
    because the new programs try to use the already-installed shared
    libraries.  (Typical symptoms are complaints about undefined symbols.)
    If you wish to run the tests before overwriting the old installation,
    you'll need to build with <literal>configure -&minus;disable-rpath</literal>.
    It is not recommended that you use this option for the final installation,
    however.
   </para>
________________________________________________________-->
   <para>
    如果你已经配置<productname>PostgreSQL</productname>安装到一个已经存在有旧的<productname>PostgreSQL</productname>安装的位置，并且你在安装新版本前执行了<literal>make check</literal>，你可能会发现测试会因为新程序尝试使用已经安装的共享库而失败（典型特征是抱怨未定义的符号）。如果你希望在覆盖旧安装之前运行测试，你将需要使用<literal>configure --disable-rpath</literal>编译。但是我们不推荐为最终安装使用这个选项。
   </para>
<!-- pgdoc-cn_end sig_en=30c40510adc9d92613f54f3b98329387 -->

<!-- pgdoc-cn_start sig_en=cd4ec6a20a70417150e041d292f03a45 sig_cn_org=None source=14.1 
   <para>
    The parallel regression test starts quite a few processes under your
    user ID.  Presently, the maximum concurrency is twenty parallel test
    scripts, which means forty processes: there's a server process and a
    <application>psql</application> process for each test script.
    So if your system enforces a per-user limit on the number of processes,
    make sure this limit is at least fifty or so, else you might get
    random-seeming failures in the parallel test.  If you are not in
    a position to raise the limit, you can cut down the degree of parallelism
    by setting the <literal>MAX_CONNECTIONS</literal> parameter.  For example:
<screen>
make MAX_CONNECTIONS=10 check
</screen>
    runs no more than ten tests concurrently.
   </para>
________________________________________________________-->
   <para>
    并行回归测试会在你的用户 ID 下启动相当多的进程。当前，最大并发量是二十个并行测试脚本，这意味着四十个进程：对每一个测试脚本有一个服务器进程和一个<application>psql</application>进程。因此如果你的系统对每个用户的进程数有强制限制，确保这个限制至少是五十，否则你将在并行测试中失败。如果你没有权利提升该限制，你可以通过设置<literal>MAX_CONNECTIONS</literal>参数来降低并发度。例如：
<screen>
make MAX_CONNECTIONS=10 check
</screen>
    会并发运行不超过十个测试。
   </para>
<!-- pgdoc-cn_end sig_en=cd4ec6a20a70417150e041d292f03a45 -->
  </sect2>

  <sect2>
<!-- pgdoc-cn_start sig_en=919a943f74c768747a51108712b109d7 sig_cn_org=None source=14.1 
   <title>Running the Tests Against an Existing Installation</title>
________________________________________________________-->
   <title>在一个现有安装上运行测试</title>
<!-- pgdoc-cn_end sig_en=919a943f74c768747a51108712b109d7 -->

<!-- pgdoc-cn_start sig_en=7096f74abe4dff2e428899b813d956f2 sig_cn_org=None source=14.1 
  <para>
   To run the tests after installation (see <xref linkend="installation"/>),
   initialize a data directory and start the
   server as explained in <xref linkend="runtime"/>, then type:
<screen>
make installcheck
</screen>
or for a parallel test:
<screen>
make installcheck-parallel
</screen>
   The tests will expect to contact the server at the local host and the
   default port number, unless directed otherwise by <envar>PGHOST</envar> and
   <envar>PGPORT</envar> environment variables.  The tests will be run in a
   database named <literal>regression</literal>; any existing database by this name
   will be dropped.
  </para>
________________________________________________________-->
  <para>
   要在安装后运行测试（见<xref linkend="installation"/>），初始化一个数据目录并且按照<xref linkend="runtime"/>所解释的启动服务器，然后输入：
<screen>
make installcheck
</screen>
或者进行一次并行测试：
<screen>
make installcheck-parallel
</screen>
   该测试将期望联系在本地主机和默认端口号上的服务器（除非通过<envar>PGHOST</envar>和<envar>PGPORT</envar>环境变量覆盖）。该测试将在一个名为<literal>regression</literal>的数据库中运行，任何以该名称存在的数据库将被删除。
  </para>
<!-- pgdoc-cn_end sig_en=7096f74abe4dff2e428899b813d956f2 -->

<!-- pgdoc-cn_start sig_en=ac8ca93d78ee822858bab777188ded60 sig_cn_org=None source=14.1 
  <para>
   The tests will also transiently create some cluster-wide objects, such as
   roles, tablespaces, and subscriptions.  These objects will have names
   beginning with <literal>regress_</literal>.  Beware of
   using <literal>installcheck</literal> mode with an installation that has
   any actual global objects named that way.
  </para>
________________________________________________________-->
  <para>
   该测试还将短暂地创建一些集簇范围内的对象，例如角色、表空间和订阅。这些对象的名称都会以<literal>regress_</literal>开始。在实际具有以这种方式全局对象命名的安装中使用<literal>installcheck</literal>模式时要格外小心。
  </para>
<!-- pgdoc-cn_end sig_en=ac8ca93d78ee822858bab777188ded60 -->
  </sect2>

  <sect2>
<!-- pgdoc-cn_start sig_en=70565ac56e303571b38e670619c277fb sig_cn_org=None source=14.1 
   <title>Additional Test Suites</title>
________________________________________________________-->
   <title>附加测试套件</title>
<!-- pgdoc-cn_end sig_en=70565ac56e303571b38e670619c277fb -->

<!-- pgdoc-cn_start sig_en=b68702aaf9608d399ccef3ddf28507a1 sig_cn_org=None source=14.1 
  <para>
   The <literal>make check</literal> and <literal>make installcheck</literal> commands
   run only the <quote>core</quote> regression tests, which test built-in
   functionality of the <productname>PostgreSQL</productname> server.  The source
   distribution contains many additional test suites, most of them having
   to do with add-on functionality such as optional procedural languages.
  </para>
________________________________________________________-->
  <para>
   <literal>make check</literal>和<literal>make installcheck</literal>命令只运行<quote>核心的</quote>回归测试，这只测试<productname>PostgreSQL</productname>服务器的内建功能。源代码发布包含许多额外的测试套件，它们中的大部分用于测试附加功能，例如可选的过程语言。
  </para>
<!-- pgdoc-cn_end sig_en=b68702aaf9608d399ccef3ddf28507a1 -->

<!-- pgdoc-cn_start sig_en=9be75f5ac4e4a7efdb832fa0b3ea6704 sig_cn_org=None source=14.1 
  <para>
   To run all test suites applicable to the modules that have been selected
   to be built, including the core tests, type one of these commands at the
   top of the build tree:
<screen>
make check-world
make installcheck-world
</screen>
   These commands run the tests using temporary servers or an
   already-installed server, respectively, just as previously explained
   for <literal>make check</literal> and <literal>make installcheck</literal>.  Other
   considerations are the same as previously explained for each method.
   Note that <literal>make check-world</literal> builds a separate instance
   (temporary data directory) for each tested module, so it requires more
   time and disk space than <literal>make installcheck-world</literal>.
  </para>
________________________________________________________-->
  <para>
   要运行将被编译模块的所有测试套件（包括核心测试），在编译树的顶端输入这些命令之一：
<screen>
make check-world
make installcheck-world
</screen>
   这些命令分别在临时服务器或已经安装好的服务器上运行测试（与之前介绍的<literal>make check</literal>和<literal>make installcheck</literal>类似）。
   其他的考虑与之前为每种方法解释的相同。注意<literal>make check-world</literal>为每一个受测模块建立一个独立的实例（临时数据目录），因此它比起<literal>make installcheck-world</literal>需要更多的时间和磁盘空间。
  </para>
<!-- pgdoc-cn_end sig_en=9be75f5ac4e4a7efdb832fa0b3ea6704 -->

<!-- pgdoc-cn_start sig_en=8aec77fab5703759a45d1904bf959598 sig_cn_org=None source=14.1 
  <para>
   On a modern machine with multiple CPU cores and no tight operating-system
   limits, you can make things go substantially faster with parallelism.
   The recipe that most PostgreSQL developers actually use for running all
   tests is something like
<screen>
make check-world -j8 >/dev/null
</screen>
   with a <option>-j</option> limit near to or a bit more than the number
   of available cores.  Discarding <systemitem>stdout</systemitem>
   eliminates chatter that's not interesting when you just want to verify
   success.  (In case of failure, the <systemitem>stderr</systemitem>
   messages are usually enough to determine where to look closer.)
  </para>
________________________________________________________-->
  <para>
   在具有多个 CPU 内核且没有严格操作系统限制的现代计算机上，你可以通过并行化使操作速度大大加快。
   大多数 PostgreSQL 开发人员实际用于运行所有测试的方法类似于这样
<screen>
make check-world -j8 >/dev/null
</screen>
   通过<option>-j</option>限制接近或略高于可用内核数。 当你只是想验证成功时，放弃<systemitem>stdout</systemitem>消除那些没有意义的闲杂信息。 
   （如果发生故障，<systemitem>stderr</systemitem>消息通常足以确定要查找的位置。）
  </para>
<!-- pgdoc-cn_end sig_en=8aec77fab5703759a45d1904bf959598 -->

<!-- pgdoc-cn_start sig_en=93f06b4d99a8ae5a25bcb412b77f8ffa sig_cn_org=None source=14.1 
  <para>
   Alternatively, you can run individual test suites by typing
   <literal>make check</literal> or <literal>make installcheck</literal> in the appropriate
   subdirectory of the build tree.  Keep in mind that <literal>make
   installcheck</literal> assumes you've installed the relevant module(s), not
   only the core server.
  </para>
________________________________________________________-->
  <para>
   你也可以通过在编译树适当的子目录中输入<literal>make check</literal>或<literal>make installcheck</literal>来运行个体的测试套件。记住<literal>make installcheck</literal>假设你已经安装了相关模块，而不仅仅是核心服务器。
  </para>
<!-- pgdoc-cn_end sig_en=93f06b4d99a8ae5a25bcb412b77f8ffa -->

<!-- pgdoc-cn_start sig_en=91342eea7420c87b7bc986f001ef2f2c sig_cn_org=None source=14.1 
  <para>
   The additional tests that can be invoked this way include:
  </para>
________________________________________________________-->
  <para>
   可以以这种方法调用的额外测试包括：
  </para>
<!-- pgdoc-cn_end sig_en=91342eea7420c87b7bc986f001ef2f2c -->

  <itemizedlist>
   <listitem>
<!-- pgdoc-cn_start sig_en=e1097e5d0347ff133b085f166c51c855 sig_cn_org=None source=14.1 
    <para>
     Regression tests for optional procedural languages.
     These are located under <filename>src/pl</filename>.
    </para>
________________________________________________________-->
    <para>
     可选过程语言的回归测试。这些位于<filename>src/pl</filename>之下。
    </para>
<!-- pgdoc-cn_end sig_en=e1097e5d0347ff133b085f166c51c855 -->
   </listitem>
   <listitem>
<!-- pgdoc-cn_start sig_en=4e9333bb3bdf17186d003f4a841b2d74 sig_cn_org=None source=14.1 
    <para>
     Regression tests for <filename>contrib</filename> modules,
     located under <filename>contrib</filename>.
     Not all <filename>contrib</filename> modules have tests.
    </para>
________________________________________________________-->
    <para>
     <filename>contrib</filename>模块的回归测试，位于<filename>contrib</filename>。不是所有的<filename>contrib</filename>模块都有测试。
    </para>
<!-- pgdoc-cn_end sig_en=4e9333bb3bdf17186d003f4a841b2d74 -->
   </listitem>
   <listitem>
<!-- pgdoc-cn_start sig_en=eef62310713e91251330e02491b65a41 sig_cn_org=cbbc5e9532132ef0064d2b2928133662 source=15.7 
    <para>
     Regression tests for the interface libraries,
     located in <filename>src/interfaces/libpq/test</filename> and
     <filename>src/interfaces/ecpg/test</filename>.
    </para>
________________________________________________________-->
    <para>
     接口库的回归测试，位于<filename>src/interfaces/libpq/test</filename>和
     <filename>src/interfaces/ecpg/test</filename>。
    </para>
<!-- pgdoc-cn_end sig_en=eef62310713e91251330e02491b65a41 -->
   </listitem>
   <listitem>
<!-- pgdoc-cn_start sig_en=a7077662bfe0465186d1f347d5cd2b6a sig_cn_org=None source=14.1 
    <para>
     Tests for core-supported authentication methods,
     located in <filename>src/test/authentication</filename>.
     (See below for additional authentication-related tests.)
    </para>
________________________________________________________-->
    <para>
     位于<filename>src/test/authentication</filename>的核心支持的身份验证方法的测试。（更多身份验证相关的测试请参阅下文。）
    </para>
<!-- pgdoc-cn_end sig_en=a7077662bfe0465186d1f347d5cd2b6a -->
   </listitem>
   <listitem>
<!-- pgdoc-cn_start sig_en=6edb217e87dd80eea0103b82abdb70d1 sig_cn_org=None source=14.1 
    <para>
     Tests stressing behavior of concurrent sessions,
     located in <filename>src/test/isolation</filename>.
    </para>
________________________________________________________-->
    <para>
     并发会话行为的压力测试，位于<filename>src/test/isolation</filename>。
    </para>
<!-- pgdoc-cn_end sig_en=6edb217e87dd80eea0103b82abdb70d1 -->
   </listitem>
   <listitem>
<!-- pgdoc-cn_start sig_en=9de47227c95262a356f7264a9eee8f32 sig_cn_org=None source=14.1 
    <para>
     Tests for crash recovery and physical replication,
     located in <filename>src/test/recovery</filename>.
    </para>
________________________________________________________-->
    <para>
     崩溃恢复和物理复制的测试,位于 <filename>src/test/recovery</filename>。
    </para>
<!-- pgdoc-cn_end sig_en=9de47227c95262a356f7264a9eee8f32 -->
   </listitem>
   <listitem>
<!-- pgdoc-cn_start sig_en=e8923349e714dcf4a5ae793bfa51a473 sig_cn_org=None source=14.1 
    <para>
     Tests for logical replication,
     located in <filename>src/test/subscription</filename>.
    </para>
________________________________________________________-->
    <para>
     逻辑复制的测试，位于 <filename>src/test/subscription</filename>。
    </para>
<!-- pgdoc-cn_end sig_en=e8923349e714dcf4a5ae793bfa51a473 -->
   </listitem>
   <listitem>
<!-- pgdoc-cn_start sig_en=9b88933d5743d5d322291dab34c61aed sig_cn_org=None source=14.1 
    <para>
     Tests of client programs, located under <filename>src/bin</filename>.
    </para>
________________________________________________________-->
    <para>
     客户端的测试程序在<filename>src/bin</filename>下。
    </para>
<!-- pgdoc-cn_end sig_en=9b88933d5743d5d322291dab34c61aed -->
   </listitem>
  </itemizedlist>

<!-- pgdoc-cn_start sig_en=912b7eceeeb57bde2e90501f03bf7eb4 sig_cn_org=None source=14.1 
  <para>
   When using <literal>installcheck</literal> mode, these tests will create
   and destroy test databases whose names
   include <literal>regression</literal>, for
   example <literal>pl_regression</literal>
   or <literal>contrib_regression</literal>.  Beware of
   using <literal>installcheck</literal> mode with an installation that has
   any non-test databases named that way.
  </para>
________________________________________________________-->
  <para>
   在使用<literal>installcheck</literal>模式时，这些测试将建立并毁掉名字包括<literal>regression</literal>的测试数据库，例如<literal>pl_regression</literal>或 <literal>contrib_regression</literal>。
   请注意使用 <literal>installcheck</literal> 模式，对于安装时以这种方式命名的任何非测试数据库。
  </para>
<!-- pgdoc-cn_end sig_en=912b7eceeeb57bde2e90501f03bf7eb4 -->

<!-- pgdoc-cn_start sig_en=b3597c321d2139f3140d376ec18b046e sig_cn_org=None source=14.1 
  <para>
   Some of these auxiliary test suites use the TAP infrastructure explained
   in <xref linkend="regress-tap"/>.
   The TAP-based tests are run only when PostgreSQL was configured with the
   option <option>-&minus;enable-tap-tests</option>.  This is recommended for
   development, but can be omitted if there is no suitable Perl installation.
  </para>
________________________________________________________-->
  <para>
   其中一些辅助测试套件使用的TAP基础结构解释在<xref linkend="regress-tap"/>。
   只有在PostgreSQL被使用选项<option>--enable-tap-tests</option>配置时，基于TAP的测试才能被运行。推荐在开发时使用这种方式，但如果没有合适的Perl安装可用也可以忽略。
  </para>
<!-- pgdoc-cn_end sig_en=b3597c321d2139f3140d376ec18b046e -->

<!-- pgdoc-cn_start sig_en=a633fd49b3a6834aa8ebd1d486c5e7e5 sig_cn_org=77c3e72d9b6e846c00f85a453548517d source=15.7 
  <para>
   Some test suites are not run by default, either because they are not secure
   to run on a multiuser system, because they require special software or
   because they are resource intensive.  You can decide which test suites to
   run additionally by setting the <command>make</command> or environment
   variable <varname>PG_TEST_EXTRA</varname> to a whitespace-separated list,
   for example:
<programlisting>
make check-world PG_TEST_EXTRA='kerberos ldap ssl'
</programlisting>
   The following values are currently supported:
   <variablelist>
    <varlistentry>
     <term><literal>kerberos</literal></term>
     <listitem>
      <para>
       Runs the test suite under <filename>src/test/kerberos</filename>.  This
       requires an MIT Kerberos installation and opens TCP/IP listen sockets.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>ldap</literal></term>
     <listitem>
      <para>
       Runs the test suite under <filename>src/test/ldap</filename>.  This
       requires an <productname>OpenLDAP</productname> installation and opens
       TCP/IP listen sockets.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>ssl</literal></term>
     <listitem>
      <para>
       Runs the test suite under <filename>src/test/ssl</filename>.  This opens TCP/IP listen sockets.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>wal_consistency_checking</literal></term>
     <listitem>
      <para>
       Uses <literal>wal_consistency_checking=all</literal> while running
       certain tests under <filename>src/test/recovery</filename>.  Not
       enabled by default because it is resource intensive.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   Tests for features that are not supported by the current build
   configuration are not run even if they are mentioned in
   <varname>PG_TEST_EXTRA</varname>.
  </para>
________________________________________________________-->
  <para>
   一些测试套件默认情况下不会运行，要么是因为它们在多用户系统上运行不安全，要么是因为它们需要特殊软件，要么是因为它们消耗资源。您可以通过将<command>make</command>或环境变量<varname>PG_TEST_EXTRA</varname>设置为空格分隔的列表来决定要额外运行哪些测试套件，例如：
<programlisting>
make check-world PG_TEST_EXTRA='kerberos ldap ssl'
</programlisting>
   目前支持以下值：
   <variablelist>
    <varlistentry>
     <term><literal>kerberos</literal></term>
     <listitem>
      <para>
       在<filename>src/test/kerberos</filename>下运行测试套件。这需要MIT Kerberos安装并打开TCP/IP监听套接字。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>ldap</literal></term>
     <listitem>
      <para>
       在<filename>src/test/ldap</filename>下运行测试套件。这需要<productname>OpenLDAP</productname>安装并打开TCP/IP监听套接字。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>ssl</literal></term>
     <listitem>
      <para>
       在<filename>src/test/ssl</filename>下运行测试套件。这打开TCP/IP监听套接字。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>wal_consistency_checking</literal></term>
     <listitem>
      <para>
       在<filename>src/test/recovery</filename>下运行某些测试时使用<literal>wal_consistency_checking=all</literal>。默认情况下未启用，因为它消耗资源。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

   即使在<varname>PG_TEST_EXTRA</varname>中提到，当前构建配置不支持的功能的测试也不会运行。
  </para>
<!-- pgdoc-cn_end sig_en=a633fd49b3a6834aa8ebd1d486c5e7e5 -->

<!-- pgdoc-cn_start sig_en=89284469b625615164a9682047131273 sig_cn_org=None source=14.1 
  <para>
   In addition, there are tests in <filename>src/test/modules</filename>
   which will be run by <literal>make check-world</literal> but not
   by <literal>make installcheck-world</literal>.  This is because they
   install non-production extensions or have other side-effects that are
   considered undesirable for a production installation.  You can
   use <literal>make install</literal> and <literal>make
   installcheck</literal> in one of those subdirectories if you wish,
   but it's not recommended to do so with a non-test server.
  </para>
________________________________________________________-->
  <para>
   此外，在<filename>src/test/modules</filename>中的测试，将由<literal>make check-world</literal>而不是<literal>make installcheck-world</literal>运行。
   这是因为它们安装非生产扩展，或者具有其他被认为不适合生产安装的副作用。
   如果你愿意，你可以在这些子目录中使用<literal>make install</literal>和<literal>make installcheck</literal>，但不建议使用非测试服务器执行此操作。
  </para>
<!-- pgdoc-cn_end sig_en=89284469b625615164a9682047131273 -->
  </sect2>

  <sect2>
<!-- pgdoc-cn_start sig_en=ae3fbba6e4d2aa8ca82c2f20f2728107 sig_cn_org=None source=14.1 
   <title>Locale and Encoding</title>
________________________________________________________-->
   <title>区域和编码</title>
<!-- pgdoc-cn_end sig_en=ae3fbba6e4d2aa8ca82c2f20f2728107 -->

<!-- pgdoc-cn_start sig_en=6b7ca4d5195a365916e1dd2ed74fc3bf sig_cn_org=None source=14.1 
   <para>
    By default, tests using a temporary installation use the
    locale defined in the current environment and the corresponding
    database encoding as determined by <command>initdb</command>.  It
    can be useful to test different locales by setting the appropriate
    environment variables, for example:
<screen>
make check LANG=C
make check LC_COLLATE=en_US.utf8 LC_CTYPE=fr_CA.utf8
</screen>
    For implementation reasons, setting <envar>LC_ALL</envar> does not
    work for this purpose; all the other locale-related environment
    variables do work.
   </para>
________________________________________________________-->
   <para>
    默认情况下，测试使用的临时安装将使用在当前环境中定义的区域和由<command>initdb</command>决定的相应数据库编码。通过设置适当的环境变量来测试不同的区域是有用的，例如：
<screen>
make check LANG=C
make check LC_COLLATE=en_US.utf8 LC_CTYPE=fr_CA.utf8
</screen>
    由于实现的原因，为此目的设置<envar>LC_ALL</envar>不能工作，所有其他区域相关的环境变量都可以工作。
   </para>
<!-- pgdoc-cn_end sig_en=6b7ca4d5195a365916e1dd2ed74fc3bf -->

<!-- pgdoc-cn_start sig_en=2ae45433d9f6dadc79b74d59c333d9cd sig_cn_org=None source=14.1 
   <para>
    When testing against an existing installation, the locale is
    determined by the existing database cluster and cannot be set
    separately for the test run.
   </para>
________________________________________________________-->
   <para>
    在对一个现有安装测试时，区域由现有数据库集簇决定并且不能为测试而独立设置。
   </para>
<!-- pgdoc-cn_end sig_en=2ae45433d9f6dadc79b74d59c333d9cd -->

<!-- pgdoc-cn_start sig_en=eace52b5951d55c553005e5678747f8e sig_cn_org=None source=14.1 
   <para>
    You can also choose the database encoding explicitly by setting
    the variable <envar>ENCODING</envar>, for example:
<screen>
make check LANG=C ENCODING=EUC_JP
</screen>
    Setting the database encoding this way typically only makes sense
    if the locale is C; otherwise the encoding is chosen automatically
    from the locale, and specifying an encoding that does not match
    the locale will result in an error.
   </para>
________________________________________________________-->
   <para>
    你也可以通过设置变量<envar>ENCODING</envar>来显式地选择数据库编码，例如：
<screen>
make check LANG=C ENCODING=EUC_JP
</screen>
    这样设置数据库编码通常只对区域为 C 有意义；否则编码将自动从区域选择，并且指定一个不匹配区域的编码将会导致错误。
   </para>
<!-- pgdoc-cn_end sig_en=eace52b5951d55c553005e5678747f8e -->

<!-- pgdoc-cn_start sig_en=ae752dfb0291f495b71ecea94eb2b60a sig_cn_org=None source=14.1 
   <para>
    The database encoding can be set for tests against either a temporary or
    an existing installation, though in the latter case it must be
    compatible with the installation's locale.
   </para>
________________________________________________________-->
   <para>
    不管测试是针对临时安装还是已有安装，数据库编码都可以被设置，然而在后一种情况中它必须与安装的区域相兼容。
   </para>
<!-- pgdoc-cn_end sig_en=ae752dfb0291f495b71ecea94eb2b60a -->
  </sect2>

  <sect2>
<!-- pgdoc-cn_start sig_en=54d2ebeaf403278d8bd6669a898ea5f9 sig_cn_org=None source=14.1 
   <title>Custom Server Settings</title>
________________________________________________________-->
   <title>定制服务器设置</title>
<!-- pgdoc-cn_end sig_en=54d2ebeaf403278d8bd6669a898ea5f9 -->

<!-- pgdoc-cn_start sig_en=3706fd2f57bddcaeb6d8ac654cb55d50 sig_cn_org=None source=14.1 
   <para>
    Custom server settings to use when running a regression test suite can be
    set in the <varname>PGOPTIONS</varname> environment variable (for settings
    that allow this):
<screen>
make check PGOPTIONS="-c force_parallel_mode=regress -c work_mem=50MB"
</screen>
    When running against a temporary installation, custom settings can also be
    set by supplying a pre-written <filename>postgresql.conf</filename>:
<screen>
echo 'log_checkpoints = on' > test_postgresql.conf
echo 'work_mem = 50MB' >> test_postgresql.conf
make check EXTRA_REGRESS_OPTS="-&minus;temp-config=test_postgresql.conf"
</screen>
   </para>
________________________________________________________-->
   <para>
    运行回归测试时使用的定制服务器设置可以在<varname>PGOPTIONS</varname>环境变量中设置(对于允许这样的设置)。
<screen>
make check PGOPTIONS="-c force_parallel_mode=regress -c work_mem=50MB"
</screen>
    当遇到临时安装，定制化设置也可以用提供预写的<filename>postgresql.conf</filename>来设置：
<screen>
echo 'log_checkpoints = on' > test_postgresql.conf
echo 'work_mem = 50MB' >> test_postgresql.conf
make check EXTRA_REGRESS_OPTS="--temp-config=test_postgresql.conf"
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=3706fd2f57bddcaeb6d8ac654cb55d50 -->

<!-- pgdoc-cn_start sig_en=fce53e13bbc1c4accd6b9679a2431183 sig_cn_org=None source=14.1 
   <para>
    This can be useful to enable additional logging, adjust resource limits,
    or enable extra run-time checks such as <xref
    linkend="guc-debug-discard-caches"/>.
   </para>
________________________________________________________-->
   <para>
    这可能是有用的，激活附加的日志、调整资源限制、或者激活额外的像<xref linkend="guc-debug-discard-caches"/>这样的运行时检查。
   </para>
<!-- pgdoc-cn_end sig_en=fce53e13bbc1c4accd6b9679a2431183 -->
  </sect2>

  <sect2>
<!-- pgdoc-cn_start sig_en=bd500a9e96cf6fe271718676d2f6eacd sig_cn_org=None source=14.1 
   <title>Extra Tests</title>
________________________________________________________-->
   <title>额外测试</title>
<!-- pgdoc-cn_end sig_en=bd500a9e96cf6fe271718676d2f6eacd -->

<!-- pgdoc-cn_start sig_en=a6529fb326e4cb85bff9dd9a21eda581 sig_cn_org=None source=14.1 
   <para>
    The core regression test suite contains a few test files that are not
    run by default, because they might be platform-dependent or take a
    very long time to run.  You can run these or other extra test
    files by setting the variable <envar>EXTRA_TESTS</envar>.  For
    example, to run the <literal>numeric_big</literal> test:
<screen>
make check EXTRA_TESTS=numeric_big
</screen>
   </para>
________________________________________________________-->
   <para>
    核心回归测试套件包含一些默认情况下不被运行的测试文件，因为它们可能平台相关的或者需要很长时间来运行。你可以通过设置变量<envar>EXTRA_TESTS</envar>来运行这些或者其他额外测试文件。例如，要运行<literal>numeric_big</literal>测试：
<screen>
make check EXTRA_TESTS=numeric_big
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=a6529fb326e4cb85bff9dd9a21eda581 -->
  </sect2>
  </sect1>

  <sect1 id="regress-evaluation">
<!-- pgdoc-cn_start sig_en=d062ada89875e3a4d5718b7f47688157 sig_cn_org=None source=14.1 
   <title>Test Evaluation</title>
________________________________________________________-->
   <title>测试评估</title>
<!-- pgdoc-cn_end sig_en=d062ada89875e3a4d5718b7f47688157 -->

<!-- pgdoc-cn_start sig_en=e53975c4f3f98a68288665287ac04a3e sig_cn_org=None source=14.1 
   <para>
    Some properly installed and fully functional
    <productname>PostgreSQL</productname> installations can
    <quote>fail</quote> some of these regression tests due to
    platform-specific artifacts such as varying floating-point representation
    and message wording. The tests are currently evaluated using a simple
    <command>diff</command> comparison against the outputs
    generated on a reference system, so the results are sensitive to
    small system differences.  When a test is reported as
    <quote>failed</quote>, always examine the differences between
    expected and actual results; you might find that the
    differences are not significant.  Nonetheless, we still strive to
    maintain accurate reference files across all supported platforms,
    so it can be expected that all tests pass.
   </para>
________________________________________________________-->
   <para>
    一些正确安装的并且全功能的<productname>PostgreSQL</productname>安装可能会在这些回归测试中的某些上<quote>失败</quote>，其原因是平台相关的因素，例如可变浮点表示和消息措辞。这些测试目前采用<command>diff</command>命令来比较测试输出和在参考系统上产生的输出，这样测试的结果对小的系统差异也很敏感。当一个测试被报告为<quote>失败</quote>时，请总是检查实际结果和期望结果之间的差异，你可能会发现该差异其实并不明显。不管怎样，我们将努力维护在所有被支持平台上的准确的参考文件，以期待所有的测试都能通过。
   </para>
<!-- pgdoc-cn_end sig_en=e53975c4f3f98a68288665287ac04a3e -->

<!-- pgdoc-cn_start sig_en=40a2433459554bd6257e5f7965f6b796 sig_cn_org=None source=14.1 
   <para>
    The actual outputs of the regression tests are in files in the
    <filename>src/test/regress/results</filename> directory. The test
    script uses <command>diff</command> to compare each output
    file against the reference outputs stored in the
    <filename>src/test/regress/expected</filename> directory.  Any
    differences are saved for your inspection in
    <filename>src/test/regress/regression.diffs</filename>.
    (When running a test suite other than the core tests, these files
    of course appear in the relevant subdirectory,
    not <filename>src/test/regress</filename>.)
   </para>
________________________________________________________-->
   <para>
    回归测试的实际输出在<filename>src/test/regress/results</filename>目录中的文件内。测试脚本会使用<command>diff</command>来把每一个输出文件与存储在<filename>src/test/regress/expected</filename>目录中的参考输出进行比较。任何差异都被保存在<filename>src/test/regress/regression.diffs</filename>中便于你的观察（当运行一个除核心测试之外的测试套件时，这些文件当然会出现在相关子目录中，而不是<filename>src/test/regress</filename>）。
   </para>
<!-- pgdoc-cn_end sig_en=40a2433459554bd6257e5f7965f6b796 -->

<!-- pgdoc-cn_start sig_en=30d4c98ae0298d06d57c2b5d04d9ce58 sig_cn_org=None source=14.1 
   <para>
    If you don't
    like the <command>diff</command> options that are used by default, set the
    environment variable <envar>PG_REGRESS_DIFF_OPTS</envar>, for
    instance <literal>PG_REGRESS_DIFF_OPTS='-c'</literal>.  (Or you
    can run <command>diff</command> yourself, if you prefer.)
   </para>
________________________________________________________-->
   <para>
    如果你不喜欢被默认使用的<command>diff</command>选项，请设置环境变量<envar>PG_REGRESS_DIFF_OPTS</envar>，例如<literal>PG_REGRESS_DIFF_OPTS='-c'</literal>（或者如果你愿意，你可以自己运行<command>diff</command>）。
   </para>
<!-- pgdoc-cn_end sig_en=30d4c98ae0298d06d57c2b5d04d9ce58 -->

<!-- pgdoc-cn_start sig_en=a3ac55645b2d5d5eb97defb3010d601c sig_cn_org=None source=14.1 
   <para>
    If for some reason a particular platform generates a <quote>failure</quote>
    for a given test, but inspection of the output convinces you that
    the result is valid, you can add a new comparison file to silence
    the failure report in future test runs.  See
    <xref linkend="regress-variant"/> for details.
   </para>
________________________________________________________-->
   <para>
    如果由于某种原因一个特定的平台对一个给定测试产生了<quote>失败</quote>，而对输出的检查却说明该结果是合法的，你可以增加一个新的比较文件来让失败报告在未来的测试运行中保持沉默。详见<xref linkend="regress-variant"/>。
   </para>
<!-- pgdoc-cn_end sig_en=a3ac55645b2d5d5eb97defb3010d601c -->

   <sect2>
<!-- pgdoc-cn_start sig_en=8f91be73c5d81390a5a53a4f8119f503 sig_cn_org=None source=14.1 
    <title>Error Message Differences</title>
________________________________________________________-->
    <title>错误消息差异</title>
<!-- pgdoc-cn_end sig_en=8f91be73c5d81390a5a53a4f8119f503 -->

<!-- pgdoc-cn_start sig_en=caa07f96e16afe34871218b2a690116a sig_cn_org=None source=14.1 
    <para>
     Some of the regression tests involve intentional invalid input
     values.  Error messages can come from either the
     <productname>PostgreSQL</productname> code or from the host
     platform system routines. In the latter case, the messages can
     vary between platforms, but should reflect similar
     information. These differences in messages will result in a
     <quote>failed</quote> regression test that can be validated by
     inspection.
    </para>
________________________________________________________-->
    <para>
     某些回归测试涉及到故意的非法输入值。错误消息可能来自<productname>PostgreSQL</productname>代码或主机平台系统例程。在后一种情况中，消息会随着平台而变化，但是会反映相似的信息。这些消息中的差异将导致一次<quote>失败的</quote>回归测试，这可以通过检查来确认。
    </para>
<!-- pgdoc-cn_end sig_en=caa07f96e16afe34871218b2a690116a -->
   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=993eb6d8e1eca4b1d11cc1272d39ffa2 sig_cn_org=None source=14.1 
    <title>Locale Differences</title>
________________________________________________________-->
    <title>区域差异</title>
<!-- pgdoc-cn_end sig_en=993eb6d8e1eca4b1d11cc1272d39ffa2 -->

<!-- pgdoc-cn_start sig_en=16941d9b584ede7c88c28d2784cfbef2 sig_cn_org=None source=14.1 
    <para>
     If you run the tests against a server that was
     initialized with a collation-order locale other than C, then
     there might be differences due to sort order and subsequent
     failures.  The regression test suite is set up to handle this
     problem by providing alternate result files that together are
     known to handle a large number of locales.
    </para>
________________________________________________________-->
    <para>
     如果你在一台使用除 C 之外的排序规则顺序区域初始化的服务器上运行测试，那么可能会出现由于排序顺序和后续失败产生的差异。回归测试套件被设置为可以处理这种问题，方法是提供替代的结果文件来处理大量的区域。
    </para>
<!-- pgdoc-cn_end sig_en=16941d9b584ede7c88c28d2784cfbef2 -->

<!-- pgdoc-cn_start sig_en=d8b8dfe08dbb6174780e2c718fa94334 sig_cn_org=None source=14.1 
    <para>
     To run the tests in a different locale when using the
     temporary-installation method, pass the appropriate
     locale-related environment variables on
     the <command>make</command> command line, for example:
<programlisting>
make check LANG=de_DE.utf8
</programlisting>
     (The regression test driver unsets <envar>LC_ALL</envar>, so it
     does not work to choose the locale using that variable.)  To use
     no locale, either unset all locale-related environment variables
     (or set them to <literal>C</literal>) or use the following
     special invocation:
<programlisting>
make check NO_LOCALE=1
</programlisting>
     When running the tests against an existing installation, the
     locale setup is determined by the existing installation.  To
     change it, initialize the database cluster with a different
     locale by passing the appropriate options
     to <command>initdb</command>.
    </para>
________________________________________________________-->
    <para>
     要在使用临时安装方法时在一种不同的区域中运行测试，可在<command>make</command>命令行上传递适当的区域相关的环境变量，例如：
<programlisting>
make check LANG=de_DE.utf8
</programlisting>
     （回归测试驱动器会取消<envar>LC_ALL</envar>设置，因此使用这个变量选择区域是不起作用的）。要不使用区域，要么取消所有区域相关的环境变量设置（或把它们设置为<literal>C</literal>），要么使用下列特殊调用：
<programlisting>
make check NO_LOCALE=1
</programlisting>
     当对一个现有安装运行测试时，区域设置由现有安装决定。要改变它，通过向<command>initdb</command>传递合适的选项来使用不同的区域初始化数据库集簇。
    </para>
<!-- pgdoc-cn_end sig_en=d8b8dfe08dbb6174780e2c718fa94334 -->

<!-- pgdoc-cn_start sig_en=d333a5dc7ad8f7995c4aa947179e53ec sig_cn_org=None source=14.1 
    <para>
     In general, it is advisable to try to run the
     regression tests in the locale setup that is wanted for
     production use, as this will exercise the locale- and
     encoding-related code portions that will actually be used in
     production.  Depending on the operating system environment, you
     might get failures, but then you will at least know what
     locale-specific behaviors to expect when running real
     applications.
    </para>
________________________________________________________-->
    <para>
     通常，我们建议对将要在生产环境中使用的区域设置运行回归测试，因为这样可以测试即将真正被用在生产环境中的与区域和编码相关的代码。根据 操作系统环境，你可能会得到失败，但是那样你将至少知道在真实应用运行时会得到什么样的与区域相关的行为。
    </para>
<!-- pgdoc-cn_end sig_en=d333a5dc7ad8f7995c4aa947179e53ec -->
   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=6dd36b285a2a3f6db13e1c8144e5c70b sig_cn_org=None source=14.1 
    <title>Date and Time Differences</title>
________________________________________________________-->
    <title>日期和时间差异</title>
<!-- pgdoc-cn_end sig_en=6dd36b285a2a3f6db13e1c8144e5c70b -->

<!-- pgdoc-cn_start sig_en=cb9a822b6ba5bfb5307ab348203683c7 sig_cn_org=None source=14.1 
    <para>
     Most of the date and time results are dependent on the time zone
     environment.  The reference files are generated for time zone
     <literal>PST8PDT</literal> (Berkeley, California), and there will be
     apparent failures if the tests are not run with that time zone setting.
     The regression test driver sets environment variable
     <envar>PGTZ</envar> to <literal>PST8PDT</literal>, which normally
     ensures proper results.
    </para>
________________________________________________________-->
    <para>
     大部分的日期和时间结果依赖于时区环境。参考文件是用时区<literal>PST8PDT</literal>（伯克利，加利福利亚）生成的，并且如果测试不是运行在该时区设置中显然会出现失败。回归测试驱动器会设置环境变量<envar>PGTZ</envar>为 <literal>PST8PDT</literal>，这通常能保证正确的结果。
    </para>
<!-- pgdoc-cn_end sig_en=cb9a822b6ba5bfb5307ab348203683c7 -->
   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=a19b63e9954b994124ed17b96d1de17c sig_cn_org=None source=14.1 
    <title>Floating-Point Differences</title>
________________________________________________________-->
    <title>浮点差异</title>
<!-- pgdoc-cn_end sig_en=a19b63e9954b994124ed17b96d1de17c -->

<!-- pgdoc-cn_start sig_en=f09aeec7b462a0af4eef1f4cc9e5f2d3 sig_cn_org=None source=14.1 
    <para>
     Some of the tests involve computing 64-bit floating-point numbers (<type>double
     precision</type>) from table columns. Differences in
     results involving mathematical functions of <type>double
     precision</type> columns have been observed.  The <literal>float8</literal> and
     <literal>geometry</literal> tests are particularly prone to small differences
     across platforms, or even with different compiler optimization settings.
     Human eyeball comparison is needed to determine the real
     significance of these differences which are usually 10 places to
     the right of the decimal point.
    </para>
________________________________________________________-->
    <para>
     某些测试涉及到从表列中计算 64 位浮点数（<type>双精度</type>）。我们已经发现了涉及到<type>双精度</type>列的数学函数的结果中的差异。<literal>float8</literal>和<literal>geometry</literal>测试容易在不同平台之间产生小的差异，甚至对不同的编译器优化设置也可能产生差异。这些差异通常位于小数点右边的 10 个位置，决定这些差异的实际意义需要人类眼球比较。
    </para>
<!-- pgdoc-cn_end sig_en=f09aeec7b462a0af4eef1f4cc9e5f2d3 -->

<!-- pgdoc-cn_start sig_en=8d9d8df0fff24e02cc526651d8ba6f0c sig_cn_org=None source=14.1 
    <para>
     Some systems display minus zero as <literal>-0</literal>, while others
     just show <literal>0</literal>.
    </para>
________________________________________________________-->
    <para>
     某些系统显示负零为<literal>-0</literal>，而其他的只显示<literal>0</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=8d9d8df0fff24e02cc526651d8ba6f0c -->

<!-- pgdoc-cn_start sig_en=fb32ede1427f6a70765b1e2b8596de5d sig_cn_org=None source=14.1 
    <para>
     Some systems signal errors from <function>pow()</function> and
     <function>exp()</function> differently from the mechanism
     expected by the current <productname>PostgreSQL</productname>
     code.
    </para>
________________________________________________________-->
    <para>
     某些系统标志来自<function>pow()</function>和<function>exp()</function>的错误的机制不同于当前<productname>PostgreSQL</productname>代码所期望的机制。
    </para>
<!-- pgdoc-cn_end sig_en=fb32ede1427f6a70765b1e2b8596de5d -->
   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=431b497e4443db804849c3e519136cff sig_cn_org=None source=14.1 
    <title>Row Ordering Differences</title>
________________________________________________________-->
    <title>行序差异</title>
<!-- pgdoc-cn_end sig_en=431b497e4443db804849c3e519136cff -->

<!-- pgdoc-cn_start sig_en=5db330a7b2e718c215ad47b1fad44977 sig_cn_org=None source=14.1 
    <para>
You might see differences in which the same rows are output in a
different order than what appears in the expected file.  In most cases
this is not, strictly speaking, a bug.  Most of the regression test
scripts are not so pedantic as to use an <literal>ORDER BY</literal> for every single
<literal>SELECT</literal>, and so their result row orderings are not well-defined
according to the SQL specification.  In practice, since we are
looking at the same queries being executed on the same data by the same
software, we usually get the same result ordering on all platforms,
so the lack of <literal>ORDER BY</literal> is not a problem.  Some queries do exhibit
cross-platform ordering differences, however.  When testing against an
already-installed server, ordering differences can also be caused by
non-C locale settings or non-default parameter settings, such as custom values
of <varname>work_mem</varname> or the planner cost parameters.
    </para>
________________________________________________________-->
    <para>
你可能看到这样一些差异：一组相同的行在输出中的顺序与参考文件中的顺序不同。严格来说，在大部分情况下这不是缺陷。大部分回归测试脚本没有为每一个单独的<literal>SELECT</literal>使用一个<literal>ORDER BY</literal>，并且因此它们的结果行顺序根据 SQL 规范是非良定义的。实际上，因为我们考虑的是由相同的软件在相同的数据上执行相同的查询，我们通常会在所有平台上得到相同的结果顺序，所以缺少<literal>ORDER BY</literal>不是一个问题。但是，某些查询确实会在不同平台上产生不同的顺序。当对一个已经安装的服务器运行测试时，顺序差异可能由非 C 区域设置或非默认参数设置导致，例如<varname>work_mem</varname>的自定义值或规划器代价参数。
    </para>
<!-- pgdoc-cn_end sig_en=5db330a7b2e718c215ad47b1fad44977 -->

<!-- pgdoc-cn_start sig_en=21036a27b736a2e03473ce2f98a1e304 sig_cn_org=None source=14.1 
    <para>
Therefore, if you see an ordering difference, it's not something to
worry about, unless the query does have an <literal>ORDER BY</literal> that your
result is violating.  However, please report it anyway, so that we can add an
<literal>ORDER BY</literal> to that particular query to eliminate the bogus
<quote>failure</quote> in future releases.
    </para>
________________________________________________________-->
    <para>
因此，如果你看到一个顺序差异，没有什么可担心的，除非查询确实有一个<literal>ORDER BY</literal>而结果却违反了。但是，不管怎样请报告它，这样我们可以为特定的查询加上一个<literal>ORDER BY</literal>来在未来的发布中消除虚假的<quote>失败</quote>。
    </para>
<!-- pgdoc-cn_end sig_en=21036a27b736a2e03473ce2f98a1e304 -->

<!-- pgdoc-cn_start sig_en=9567f3cd58eb4d76f391c2f502d6f8f8 sig_cn_org=None source=14.1 
    <para>
You might wonder why we don't order all the regression test queries explicitly
to get rid of this issue once and for all.  The reason is that that would
make the regression tests less useful, not more, since they'd tend
to exercise query plan types that produce ordered results to the
exclusion of those that don't.
    </para>
________________________________________________________-->
    <para>
你可能好奇为什么我们不对所有回归测试查询进行显式排序来一次性解决这个问题。其原因是那可能会降低回归测试的有用性，因为它们已经倾向于测试产生有序结果的查询计划类型而排除了那些无法产生有序结果的计划类型。
    </para>
<!-- pgdoc-cn_end sig_en=9567f3cd58eb4d76f391c2f502d6f8f8 -->
   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=96a7013caa712bdf3b894900ea3d9ef9 sig_cn_org=None source=14.1 
    <title>Insufficient Stack Depth</title>
________________________________________________________-->
    <title>栈深度不足</title>
<!-- pgdoc-cn_end sig_en=96a7013caa712bdf3b894900ea3d9ef9 -->

<!-- pgdoc-cn_start sig_en=9c14fa46b3f6c01d0e7e027854a48f01 sig_cn_org=None source=14.1 
    <para>
     If the <literal>errors</literal> test results in a server crash
     at the <literal>select infinite_recurse()</literal> command, it means that
     the platform's limit on process stack size is smaller than the
     <xref linkend="guc-max-stack-depth"/> parameter indicates.  This
     can be fixed by running the server under a higher stack
     size limit (4MB is recommended with the default value of
     <varname>max_stack_depth</varname>).  If you are unable to do that, an
     alternative is to reduce the value of <varname>max_stack_depth</varname>.
    </para>
________________________________________________________-->
    <para>
     如果<literal>错误</literal>测试导致了在<literal>select infinite_recurse()</literal>命令上的一次服务器崩溃，它意味着平台对进程栈尺寸的限制低于<xref linkend="guc-max-stack-depth"/>参数所指定的值。这可以通过在一个更高的栈尺寸限制（对<varname>max_stack_depth</varname>的默认值，我们推荐 4 MB）下运行该服务器来修复。如果你不能这样做，一种可替代的方案是减小<varname>max_stack_depth</varname>的值。
    </para>
<!-- pgdoc-cn_end sig_en=9c14fa46b3f6c01d0e7e027854a48f01 -->

<!-- pgdoc-cn_start sig_en=fc1a1d3de0053c1cd619bc02024b95b1 sig_cn_org=None source=14.1 
    <para>
     On platforms supporting <function>getrlimit()</function>, the server should
     automatically choose a safe value of <varname>max_stack_depth</varname>;
     so unless you've manually overridden this setting, a failure of this
     kind is a reportable bug.
    </para>
________________________________________________________-->
    <para>
     在支持<function>getrlimit()</function>的平台上，服务器应该自动选择一个<varname>max_stack_depth</varname>的安全值。所以除非你已经手工覆盖了该设置，这类失败就是一个可报告的缺陷。
    </para>
<!-- pgdoc-cn_end sig_en=fc1a1d3de0053c1cd619bc02024b95b1 -->
   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=ef00749f8d29e21c84349ee363f924bd sig_cn_org=None source=14.1 
    <title>The <quote>random</quote> Test</title>
________________________________________________________-->
    <title><quote>随机</quote>测试</title>
<!-- pgdoc-cn_end sig_en=ef00749f8d29e21c84349ee363f924bd -->

<!-- pgdoc-cn_start sig_en=8f3bf3558e5d9dc9eb067c864babfceb sig_cn_org=None source=14.1 
    <para>
     The <literal>random</literal> test script is intended to produce
     random results.   In very rare cases, this causes that regression
     test to fail.  Typing:
<programlisting>
diff results/random.out expected/random.out
</programlisting>
     should produce only one or a few lines of differences.  You need
     not worry unless the random test fails repeatedly.
    </para>
________________________________________________________-->
    <para>
     <literal>随机</literal>测试脚本用来产生随机结果。在非常少见的情况下，这会导致回归测试失败。输入：
<programlisting>
diff results/random.out expected/random.out
</programlisting>
     应当产生一行或少数几行差异。你不需要担心，除非随机测试重复地失败。
    </para>
<!-- pgdoc-cn_end sig_en=8f3bf3558e5d9dc9eb067c864babfceb -->
   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=9125daac1844cde69a678e3c3c9c9bcf sig_cn_org=None source=14.1 
    <title>Configuration Parameters</title>
________________________________________________________-->
    <title>配置参数</title>
<!-- pgdoc-cn_end sig_en=9125daac1844cde69a678e3c3c9c9bcf -->

<!-- pgdoc-cn_start sig_en=f0eaaa7dcf2bb958af410dc4528809a6 sig_cn_org=None source=14.1 
    <para>
     When running the tests against an existing installation, some non-default
     parameter settings could cause the tests to fail.  For example, changing
     parameters such as <varname>enable_seqscan</varname> or
     <varname>enable_indexscan</varname> could cause plan changes that would
     affect the results of tests that use <command>EXPLAIN</command>.
    </para>
________________________________________________________-->
    <para>
     当对一个现有安装运行测试时，某些非默认参数设置可能导致测试失败。例如，改变<varname>enable_seqscan</varname>或<varname>enable_indexscan</varname>等参数可能导致计划改变，然后影响使用<command>EXPLAIN</command>的测试的结果。
    </para>
<!-- pgdoc-cn_end sig_en=f0eaaa7dcf2bb958af410dc4528809a6 -->
   </sect2>
  </sect1>

<!-- We might want to move the following section into the developer's guide. -->
  <sect1 id="regress-variant">
<!-- pgdoc-cn_start sig_en=4e37fcdcfa95c209c1a9bddbdf80fd3d sig_cn_org=None source=14.1 
   <title>Variant Comparison Files</title>
________________________________________________________-->
   <title>变体比较文件</title>
<!-- pgdoc-cn_end sig_en=4e37fcdcfa95c209c1a9bddbdf80fd3d -->

<!-- pgdoc-cn_start sig_en=4fd399505b1bdcbdab6e75da3f530cc3 sig_cn_org=None source=14.1 
   <para>
    Since some of the tests inherently produce environment-dependent
    results, we have provided ways to specify alternate <quote>expected</quote>
    result files.  Each regression test can have several comparison files
    showing possible results on different platforms.  There are two
    independent mechanisms for determining which comparison file is used
    for each test.
   </para>
________________________________________________________-->
   <para>
    因为某些测试生来就会产生依赖环境的结果，我们提供了方法来指定替代的<quote>预期</quote>结果文件。每一个回归测试可以有多个比较文件来展示在不同平台上的可能结果。有两种独立的机制来决定为每一个测试使用哪个比较文件。
   </para>
<!-- pgdoc-cn_end sig_en=4fd399505b1bdcbdab6e75da3f530cc3 -->

<!-- pgdoc-cn_start sig_en=41b7f4f52bc7e428ef61ea781f92ba0d sig_cn_org=None source=14.1 
   <para>
    The first mechanism allows comparison files to be selected for
    specific platforms.  There is a mapping file,
    <filename>src/test/regress/resultmap</filename>, that defines
    which comparison file to use for each platform.
    To eliminate bogus test <quote>failures</quote> for a particular platform,
    you first choose or make a variant result file, and then add a line to the
    <filename>resultmap</filename> file.
   </para>
________________________________________________________-->
   <para>
    第一种机制允许为指定平台选择比较文件。这是一个映射文件<filename>src/test/regress/resultmap</filename>，它定义了为每一个平台使用哪个比较文件。要为一个特定平台消除虚假的测试<quote>失败</quote>，你可以首先选择或创建一个变体结果文件，然后在<filename>resultmap</filename>文件中增加一行。
   </para>
<!-- pgdoc-cn_end sig_en=41b7f4f52bc7e428ef61ea781f92ba0d -->

<!-- pgdoc-cn_start sig_en=055cd9e6fb4bc2cc1c2ddcfc7a75cb25 sig_cn_org=None source=14.1 
   <para>
    Each line in the mapping file is of the form
<synopsis>
testname:output:platformpattern=comparisonfilename
</synopsis>
    The test name is just the name of the particular regression test
    module. The output value indicates which output file to check. For the
    standard regression tests, this is always <literal>out</literal>. The
    value corresponds to the file extension of the output file.
    The platform pattern is a pattern in the style of the Unix
    tool <command>expr</command> (that is, a regular expression with an implicit
    <literal>^</literal> anchor at the start).  It is matched against the
    platform name as printed by <command>config.guess</command>.
    The comparison file name is the base name of the substitute result
    comparison file.
   </para>
________________________________________________________-->
   <para>
    在该映射文件中的每一行的形式为：
<synopsis>
testname:output:platformpattern=comparisonfilename
</synopsis>
    测试名只是该特定回归测试模块的名称。输出值指定要检查哪个输出文件。对于标准回归测试，这总是<literal>out</literal>。该值对应于输出文件的文件扩展。平台模式是一个 Unix 工具<command>expr</command>风格的模式（即在开头带有一个隐式<literal>^</literal>锚的正则表达式）。它被与<command>config.guess</command>打印出的平台名称进行匹配。比较文件名是替补的结果比较文件的基础名。
   </para>
<!-- pgdoc-cn_end sig_en=055cd9e6fb4bc2cc1c2ddcfc7a75cb25 -->

<!-- pgdoc-cn_start sig_en=caa5dbe9f6dd0ef66fb6a6b91239853d sig_cn_org=None source=14.1 
   <para>
    For example: some systems lack a working <literal>strtof</literal> function,
    for which our workaround causes rounding errors in the
    <filename>float4</filename> regression test.
    Therefore, we provide a variant comparison file,
    <filename>float4-misrounded-input.out</filename>, which includes
    the results to be expected on these systems.  To silence the bogus
    <quote>failure</quote> message on <systemitem>HP-UX 10</systemitem>
    platforms, <filename>resultmap</filename> includes:
<programlisting>
float4:out:hppa.*-hp-hpux10.*=float4-misrounded-input.out
</programlisting>
    which will trigger on any machine where the output of
    <command>config.guess</command> matches <literal>hppa.*-hp-hpux10.*</literal>.
    Other lines in <filename>resultmap</filename> select the variant comparison
    file for other platforms where it's appropriate.
   </para>
________________________________________________________-->
   <para>
    例如：某些系统缺少工作<literal>strtof</literal>函数，我们的解决方法在<filename>float4</filename>回归测试中会导致舍入误差。
    因此，我们提供一个变体比较文件<filename>float4-misrounded-input.out</filename>，其中包括了在这些系统上的期望结果。
    要在<systemitem>HP-UX 10</systemitem>平台上屏蔽这种虚假的<quote>failure</quote> 消息，<filename>resultmap</filename>包括：
<programlisting>
float4:out:hppa.*-hp-hpux10.*=float4-misrounded-input.out
</programlisting>
    这将触发<command>config.guess</command> 的输出匹配 <literal>hppa.*-hp-hpux10.*</literal>的任何机器。
    <filename>resultmap</filename>中的其他行为其他平台选择适用的变体比较文件。
   </para>
<!-- pgdoc-cn_end sig_en=caa5dbe9f6dd0ef66fb6a6b91239853d -->

<!-- pgdoc-cn_start sig_en=599f1ff7a59f73d6d802f58b0674fd9a sig_cn_org=None source=14.1 
   <para>
    The second selection mechanism for variant comparison files is
    much more automatic: it simply uses the <quote>best match</quote> among
    several supplied comparison files.  The regression test driver
    script considers both the standard comparison file for a test,
    <literal><replaceable>testname</replaceable>.out</literal>, and variant files named
    <literal><replaceable>testname</replaceable>_<replaceable>digit</replaceable>.out</literal>
    (where the <replaceable>digit</replaceable> is any single digit
    <literal>0</literal>-<literal>9</literal>).  If any such file is an exact match,
    the test is considered to pass; otherwise, the one that generates
    the shortest diff is used to create the failure report.  (If
    <filename>resultmap</filename> includes an entry for the particular
    test, then the base <replaceable>testname</replaceable> is the substitute
    name given in <filename>resultmap</filename>.)
   </para>
________________________________________________________-->
   <para>
    第二种变体比较文件的选择机制更加自动：它简单地在多个提供的比较文件中采用<quote>最佳匹配</quote>。回归测试驱动器脚本对一个测试考虑两种标准比较文件，<literal><replaceable>testname</replaceable>.out</literal>以及名为<literal><replaceable>testname</replaceable>_<replaceable>digit</replaceable>.out</literal>的变体文件（其中<replaceable>digit</replaceable>是任何单一数字<literal>0</literal>-<literal>9</literal>）。如果任一这种文件是一个完全匹配，测试被认为是通过的。否则，产生最短区别的文件被用来创建失败报告（如果<filename>resultmap</filename>包括特定测试的一个项，那么基础<replaceable>testname</replaceable>是<filename>resultmap</filename>中给定的替补名称）。
   </para>
<!-- pgdoc-cn_end sig_en=599f1ff7a59f73d6d802f58b0674fd9a -->

<!-- pgdoc-cn_start sig_en=b6b8d60adb9220a55a4087d07f80281a sig_cn_org=None source=14.1 
   <para>
    For example, for the <literal>char</literal> test, the comparison file
    <filename>char.out</filename> contains results that are expected
    in the <literal>C</literal> and <literal>POSIX</literal> locales, while
    the file <filename>char_1.out</filename> contains results sorted as
    they appear in many other locales.
   </para>
________________________________________________________-->
   <para>
    例如，对于<literal>char</literal>测试，比较文件<filename>char.out</filename>包含在<literal>C</literal>和<literal>POSIX</literal>区域中期望的结果，而文件<filename>char_1.out</filename>包含在其他很多区域中的排序结果。
   </para>
<!-- pgdoc-cn_end sig_en=b6b8d60adb9220a55a4087d07f80281a -->

<!-- pgdoc-cn_start sig_en=56b41ea7cb43cf280629ae9c427f2dbe sig_cn_org=None source=14.1 
   <para>
    The best-match mechanism was devised to cope with locale-dependent
    results, but it can be used in any situation where the test results
    cannot be predicted easily from the platform name alone.  A limitation of
    this mechanism is that the test driver cannot tell which variant is
    actually <quote>correct</quote> for the current environment; it will just pick
    the variant that seems to work best.  Therefore it is safest to use this
    mechanism only for variant results that you are willing to consider
    equally valid in all contexts.
   </para>
________________________________________________________-->
   <para>
    最佳匹配机制被设计为与区域依赖的结果协同工作，但是它可以被用在任何测试结果无法只从平台名很容易地预测的情况中。这种机制的一个限制是测试驱动器不能说出哪个变体对当前环境是真正<quote>正确的</quote>，它将只是选择看起来工作得最好的变体。因此对你认为在所有上下文中具有同等合法性的变体结果使用这种机制才是最安全的。
   </para>
<!-- pgdoc-cn_end sig_en=56b41ea7cb43cf280629ae9c427f2dbe -->

  </sect1>

  <sect1 id="regress-tap">
<!-- pgdoc-cn_start sig_en=27060f0b57d64889eb5e94754cbc49d4 sig_cn_org=None source=14.1 
   <title>TAP Tests</title>
________________________________________________________-->
   <title>TAP 测试</title>
<!-- pgdoc-cn_end sig_en=27060f0b57d64889eb5e94754cbc49d4 -->

<!-- pgdoc-cn_start sig_en=99c083900749ab4acda50d8ec79cb7ed sig_cn_org=None source=14.1 
   <para>
    Various tests, particularly the client program tests
    under <filename>src/bin</filename>, use the Perl TAP tools and are run
    using the Perl testing program <command>prove</command>.  You can pass
    command-line options to <command>prove</command> by setting
    the <command>make</command> variable <varname>PROVE_FLAGS</varname>, for example:
<programlisting>
make -C src/bin check PROVE_FLAGS='-&minus;timer'
</programlisting>
    See the manual page of <command>prove</command> for more information.
   </para>
________________________________________________________-->
   <para>
    很多测试，特别是<filename>src/bin</filename>下面的客户端程序测试使用 Perl 的
    TAP 工具并且用Perl测试程序<command>prove</command>运行。你可以通过
    设置<command>make</command>变量<varname>PROVE_FLAGS</varname>
    向<command>prove</command>传递命令行选项，例如：
<programlisting>
make -C src/bin check PROVE_FLAGS='--timer'
</programlisting>
    详见<command>prove</command>的手册页。
   </para>
<!-- pgdoc-cn_end sig_en=99c083900749ab4acda50d8ec79cb7ed -->

<!-- pgdoc-cn_start sig_en=3138dd2f04b5d3814296777cc5b4235b sig_cn_org=None source=14.1 
   <para>
    The <command>make</command> variable <varname>PROVE_TESTS</varname>
    can be used to define a whitespace-separated list of paths relative
    to the <filename>Makefile</filename> invoking <command>prove</command>
    to run the specified subset of tests instead of the default
    <filename>t/*.pl</filename>.  For example:
<programlisting>
make check PROVE_TESTS='t/001_test1.pl t/003_test3.pl'
</programlisting>
   </para>
________________________________________________________-->
   <para>
    <command>make</command>变量<varname>PROVE_TESTS</varname>可被用来定义一个空格分隔的列表，其中是调用<command>prove</command>来运行的指定测试子集的路径，这些测试子集将取代默认的<filename>t/*.pl</filename>，并且这些路径是相对于<filename>Makefile</filename>的。例如：
<programlisting>
make check PROVE_TESTS='t/001_test1.pl t/003_test3.pl'
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=3138dd2f04b5d3814296777cc5b4235b -->

<!-- pgdoc-cn_start sig_en=0305577e4178a660c2898489a7e5fcae sig_cn_org=None source=14.1 
   <para>
    The TAP tests require the Perl module <literal>IPC::Run</literal>.
    This module is available from CPAN or an operating system package.
    They also require <productname>PostgreSQL</productname> to be
    configured with the option <option>-&minus;enable-tap-tests</option>.
   </para>
________________________________________________________-->
   <para>
    TAP测试需要 Perl 模块<literal>IPC::Run</literal>。
    这个模块可以从 CPAN 或者一个操作系统包得到。
    它们还需要为<productname>PostgreSQL</productname>配置<option>--enable-tap-tests</option>选项。
   </para>
<!-- pgdoc-cn_end sig_en=0305577e4178a660c2898489a7e5fcae -->

<!-- pgdoc-cn_start sig_en=e208465b7e71c8506cd0ea86a34b863c sig_cn_org=None source=14.1 
   <para>
    Generically speaking, the TAP tests will test the executables in a
    previously-installed installation tree if you say <literal>make
    installcheck</literal>, or will build a new local installation tree from
    current sources if you say <literal>make check</literal>.  In either
    case they will initialize a local instance (data directory) and
    transiently run a server in it.  Some of these tests run more than one
    server.  Thus, these tests can be fairly resource-intensive.
   </para>
________________________________________________________-->
   <para>
    一般来说，如果你执行<literal>make installcheck</literal>，TAP测试将测试之前安装的安装树中的可执行文件；
	或者如果你执行<literal>make check</literal>，将从当前源构建新的本地安装树。
    在这两种情况下，他们将初始化本地实例（数据目录），并在其中暂时运行服务器。 其中一些测试运行多个服务器。 因此，这些测试可能相当耗费资源。
   </para>
<!-- pgdoc-cn_end sig_en=e208465b7e71c8506cd0ea86a34b863c -->

<!-- pgdoc-cn_start sig_en=16a08a52fcd5762660597f6a352798b8 sig_cn_org=None source=14.1 
   <para>
    It's important to realize that the TAP tests will start test server(s)
    even when you say <literal>make installcheck</literal>; this is unlike
    the traditional non-TAP testing infrastructure, which expects to use an
    already-running test server in that case.  Some PostgreSQL
    subdirectories contain both traditional-style and TAP-style tests,
    meaning that <literal>make installcheck</literal> will produce a mix of
    results from temporary servers and the already-running test server.
   </para>
________________________________________________________-->
   <para>
    重要的是要认识到TAP测试将启动测试服务器，即使你说<literal>make installcheck</literal>；这与传统的非TAP 测试基础架构不同，在这种情况下它期望使用已经运行的测试服务器。
    某些 PostgreSQL 子目录包含传统样式和 TAP 样式测试，这意味着<literal>make installcheck</literal>将产生来自临时服务器和已运行测试服务器的混合结果。
   </para>
<!-- pgdoc-cn_end sig_en=16a08a52fcd5762660597f6a352798b8 -->
  </sect1>

  <sect1 id="regress-coverage">
<!-- pgdoc-cn_start sig_en=6f0f9746b36f7aa7615754fd0d2eabf0 sig_cn_org=None source=14.1 
   <title>Test Coverage Examination</title>
________________________________________________________-->
   <title>测试覆盖检查</title>
<!-- pgdoc-cn_end sig_en=6f0f9746b36f7aa7615754fd0d2eabf0 -->

<!-- pgdoc-cn_start sig_en=2b783ea473620f2466a077bcc74693ae sig_cn_org=None source=14.1 
   <para>
    The PostgreSQL source code can be compiled with coverage testing
    instrumentation, so that it becomes possible to examine which
    parts of the code are covered by the regression tests or any other
    test suite that is run with the code.  This is currently supported
    when compiling with GCC, and it requires the <command>gcov</command>
    and <command>lcov</command> programs.
   </para>
________________________________________________________-->
   <para>
    PostgreSQL 源代码可以使用覆盖测试指令编译，因此可以检查哪些部分的代码被回归测试或任何其他测试套件所覆盖。
    当前使用 GCC 编译时支持该特性，并且它需要<command>gcov</command>和<command>lcov</command>程序。
   </para>
<!-- pgdoc-cn_end sig_en=2b783ea473620f2466a077bcc74693ae -->

<!-- pgdoc-cn_start sig_en=7b43e47aaecadd126b1d9b2ff6fadd2b sig_cn_org=None source=14.1 
   <para>
    A typical workflow looks like this:
<screen>
./configure -&minus;enable-coverage ... OTHER OPTIONS ...
make
make check # or other test suite
make coverage-html
</screen>
    Then point your HTML browser
    to <filename>coverage/index.html</filename>.
   </para>
________________________________________________________-->
   <para>
    一个典型的工作流程看起来是：
<screen>
./configure --enable-coverage ... OTHER OPTIONS ...
make
make check # 或其他测试套件
make coverage-html
</screen>
    然后将你的 HTML 浏览器指向<filename>coverage/index.html</filename>。
   </para>
<!-- pgdoc-cn_end sig_en=7b43e47aaecadd126b1d9b2ff6fadd2b -->

<!-- pgdoc-cn_start sig_en=2275b189ba0f918c6f4431a91b66414e sig_cn_org=None source=14.1 
   <para>
    If you don't have <command>lcov</command> or prefer text output over an
    HTML report, you can run
<screen>
make coverage
</screen>
    instead of <literal>make coverage-html</literal>, which will
    produce <filename>.gcov</filename> output files for each source file
    relevant to the test.  (<literal>make coverage</literal> and <literal>make
    coverage-html</literal> will overwrite each other's files, so mixing them
    might be confusing.)
   </para>
________________________________________________________-->
   <para>
    如果没有<command>lcov</command>或者更喜欢文本输出而不是HTML报告，还可以运行
<screen>
make coverage
</screen>
    来取代<literal>make coverage-html</literal>，它将为每个与测试相关的源文件产生<filename>.gcov</filename>输出文件（<literal>make coverage</literal>和<literal>make
    coverage-html</literal>将覆盖彼此的文件，所以把它们混合在一起可能会导致混乱）。
   </para>
<!-- pgdoc-cn_end sig_en=2275b189ba0f918c6f4431a91b66414e -->

<!-- pgdoc-cn_start sig_en=b1228b4b63b4ac06e563670a31b36966 sig_cn_org=None source=14.1 
   <para>
    You can run several different tests before making the coverage report;
    the execution counts will accumulate.  If you want
    to reset the execution counts between test runs, run:
<screen>
make coverage-clean
</screen>
   </para>
________________________________________________________-->
   <para>
    你可以运行一些不同的测试，在制作覆盖范围报告之前；执行次数将被累计。
    如果你要在多次测试运行之间重置执行计数，运行：
<screen>
make coverage-clean
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=b1228b4b63b4ac06e563670a31b36966 -->

<!-- pgdoc-cn_start sig_en=6bf819041510d80e0932c736f822bc1e sig_cn_org=None source=14.1 
   <para>
    You can run the <literal>make coverage-html</literal> or <literal>make
    coverage</literal> command in a subdirectory if you want a coverage
    report for only a portion of the code tree.
   </para>
________________________________________________________-->
   <para>
    你可以在子目录中运行<literal>make coverage-html</literal> 或 <literal>make coverage</literal>命令，如果你覆盖范围报告仅针对代码树的一个分区。
   </para>
<!-- pgdoc-cn_end sig_en=6bf819041510d80e0932c736f822bc1e -->

<!-- pgdoc-cn_start sig_en=4075de69e6f1d9af9b07717a601a78c7 sig_cn_org=None source=14.1 
   <para>
    Use <literal>make distclean</literal> to clean up when done.
   </para>
________________________________________________________-->
   <para>
    结束时使用<literal>make distclean</literal> 清理。
   </para>
<!-- pgdoc-cn_end sig_en=4075de69e6f1d9af9b07717a601a78c7 -->
  </sect1>

</chapter>
