<!-- doc/src/sgml/high-availability.sgml -->

<chapter id="high-availability">
<!-- pgdoc-cn_start sig_en=bd2d6b820508a91241778d42632bb4e0 sig_cn_org=None source=14.1 
 <title>High Availability, Load Balancing, and Replication</title>
________________________________________________________-->
 <title>高可用、负载均衡和复制</title>
<!-- pgdoc-cn_end sig_en=bd2d6b820508a91241778d42632bb4e0 -->

<!-- pgdoc-cn_start sig_en=0440ed48d80e34fb7d33c08017bb631e sig_cn_org=None source=14.1 
 <indexterm><primary>high availability</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>高可用</primary></indexterm>
<!-- pgdoc-cn_end sig_en=0440ed48d80e34fb7d33c08017bb631e -->
<!-- pgdoc-cn_start sig_en=8a76ab3dd3a419af9f07e92c06194d69 sig_cn_org=None source=14.1 
 <indexterm><primary>failover</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>failover</primary></indexterm>
<!-- pgdoc-cn_end sig_en=8a76ab3dd3a419af9f07e92c06194d69 -->
<!-- pgdoc-cn_start sig_en=843d5dd18bb40b95f7550f1838dc78bb sig_cn_org=None source=14.1 
 <indexterm><primary>replication</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>复制</primary></indexterm>
<!-- pgdoc-cn_end sig_en=843d5dd18bb40b95f7550f1838dc78bb -->
<!-- pgdoc-cn_start sig_en=a9abfc577a0acc1cc77e9b8ee65071c4 sig_cn_org=None source=14.1 
 <indexterm><primary>load balancing</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>负载均衡</primary></indexterm>
<!-- pgdoc-cn_end sig_en=a9abfc577a0acc1cc77e9b8ee65071c4 -->
<!-- pgdoc-cn_start sig_en=abbe02fb0faf67b89541350b26ef51ce sig_cn_org=None source=14.1 
 <indexterm><primary>clustering</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>clustering</primary></indexterm>
<!-- pgdoc-cn_end sig_en=abbe02fb0faf67b89541350b26ef51ce -->
<!-- pgdoc-cn_start sig_en=c72460e66cd218746daf8bb2ad16f461 sig_cn_org=None source=14.1 
 <indexterm><primary>data partitioning</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>数据分区</primary></indexterm>
<!-- pgdoc-cn_end sig_en=c72460e66cd218746daf8bb2ad16f461 -->

<!-- pgdoc-cn_start sig_en=5ddfa57a1b8b87f57f9c3597cec6d9bb sig_cn_org=None source=14.1 
 <para>
  Database servers can work together to allow a second server to
  take over quickly if the primary server fails (high
  availability), or to allow several computers to serve the same
  data (load balancing).  Ideally, database servers could work
  together seamlessly.  Web servers serving static web pages can
  be combined quite easily by merely load-balancing web requests
  to multiple machines.  In fact, read-only database servers can
  be combined relatively easily too.  Unfortunately, most database
  servers have a read/write mix of requests, and read/write servers
  are much harder to combine.  This is because though read-only
  data needs to be placed on each server only once, a write to any
  server has to be propagated to all servers so that future read
  requests to those servers return consistent results.
 </para>
________________________________________________________-->
 <para>
  数据库服务器可以一起工作，这样如果主要的服务器失效则允许一个第二服务器快速接手它的任务（高可用性），或者可以允许多个计算机提供相同的数据（负载均衡）。理想情况下，数据库服务器能够无缝地一起工作。提供静态网页服务的网页服务器可以非常容易地通过把网页请求均衡到多个机器来组合。事实上，只读的数据库服务器也可以相对容易地组合起来。不幸的是，大部分数据库服务器收到的请求是读/写混合的，并且读/写服务器更难于组合。这是因为尽管只读数据只需要在每台服务器上放置一次，但对于任意服务器的一次写动作却必须被传播给所有的服务器，这样才能保证未来对于那些服务器的读请求能返回一致的结果。
 </para>
<!-- pgdoc-cn_end sig_en=5ddfa57a1b8b87f57f9c3597cec6d9bb -->

<!-- pgdoc-cn_start sig_en=2a92dadc40db14722b609c8d39021d4c sig_cn_org=None source=14.1 
 <para>
  This synchronization problem is the fundamental difficulty for
  servers working together.  Because there is no single solution
  that eliminates the impact of the sync problem for all use cases,
  there are multiple solutions.  Each solution addresses this
  problem in a different way, and minimizes its impact for a specific
  workload.
 </para>
________________________________________________________-->
 <para>
  这种同步问题是服务器一起工作的最根本的困难。因为没有单一解决方案能够消除该同步问题对所有用例的影响。有多种解决方案，每一种方案都以一种不同的方式提出了这个问题，并且对于一种特定的负载最小化了该问题所产生的影响。
 </para>
<!-- pgdoc-cn_end sig_en=2a92dadc40db14722b609c8d39021d4c -->

<!-- pgdoc-cn_start sig_en=76d6ea6187f133dcdaac86e868fef061 sig_cn_org=None source=14.1 
 <para>
  Some solutions deal with synchronization by allowing only one
  server to modify the data.  Servers that can modify data are
  called read/write, <firstterm>master</firstterm> or <firstterm>primary</firstterm> servers.
  Servers that track changes in the primary are called <firstterm>standby</firstterm>
  or <firstterm>secondary</firstterm> servers. A standby server that cannot be connected
  to until it is promoted to a primary server is called a <firstterm>warm
  standby</firstterm> server, and one that can accept connections and serves read-only
  queries is called a <firstterm>hot standby</firstterm> server.
 </para>
________________________________________________________-->
 <para>
  某些方案通过只允许一台服务器修改数据来处理同步。能修改数据的服务器被称为读/写、<firstterm>主控</firstterm>或<firstterm>主要</firstterm>服务器。跟踪主控机中改变的服务器被称为<firstterm>后备</firstterm>或<firstterm>次级</firstterm>服务器。如果一台后备服务器只有被提升为一台主控服务器后才能被连接，它被称为一台<firstterm>温后备</firstterm>服务器，而一台总是能够接受连接并且提供只读查询的后备服务器被称为一台<firstterm>热后备</firstterm>服务器。
 </para>
<!-- pgdoc-cn_end sig_en=76d6ea6187f133dcdaac86e868fef061 -->

<!-- pgdoc-cn_start sig_en=0f8f4ccdeef09f8302ae23c0b8e49554 sig_cn_org=None source=14.1 
 <para>
  Some solutions are synchronous,
  meaning that a data-modifying transaction is not considered
  committed until all servers have committed the transaction.  This
  guarantees that a failover will not lose any data and that all
  load-balanced servers will return consistent results no matter
  which server is queried. In contrast, asynchronous solutions allow some
  delay between the time of a commit and its propagation to the other servers,
  opening the possibility that some transactions might be lost in
  the switch to a backup server, and that load balanced servers
  might return slightly stale results.  Asynchronous communication
  is used when synchronous would be too slow.
 </para>
________________________________________________________-->
 <para>
  某些方案是同步的，即一个数据修改事务只有到所有服务器都提交了该事务之后才被认为是提交成功。这保证了一次故障转移不会丢失任何数据并且所有负载均衡的服务器将返回一致的结果（不管哪台服务器被查询）。相反，异步的方案允许在一次提交和它被传播到其他服务器之间有一些延迟，这产生了切换到一个备份服务器时丢失某些事务的可能性，并且负载均衡的服务器可能会返回略微陈旧的结果。当同步通信可能很慢时，可以使用异步通信。
 </para>
<!-- pgdoc-cn_end sig_en=0f8f4ccdeef09f8302ae23c0b8e49554 -->

<!-- pgdoc-cn_start sig_en=0866fedc64ae0b5e7525595d57796e35 sig_cn_org=None source=14.1 
 <para>
  Solutions can also be categorized by their granularity.  Some solutions
  can deal only with an entire database server, while others allow control
  at the per-table or per-database level.
 </para>
________________________________________________________-->
 <para>
  方案也可以按照它们的粒度进行分类。某些方案只能处理一整个数据库服务器，而其他的允许在每个表或每个数据库的级别上进行控制。
 </para>
<!-- pgdoc-cn_end sig_en=0866fedc64ae0b5e7525595d57796e35 -->

<!-- pgdoc-cn_start sig_en=99d3ba1e517276bbfd6190f69537acfa sig_cn_org=None source=14.1 
 <para>
  Performance must be considered in any choice.  There is usually a
  trade-off between functionality and
  performance.  For example, a fully synchronous solution over a slow
  network might cut performance by more than half, while an asynchronous
  one might have a minimal performance impact.
 </para>
________________________________________________________-->
 <para>
  在任何选择中，都必须考虑性能。通常在功能和性能之间都存在着权衡。例如，在一个低速网络上的一种完全同步的方案可能使性能减少超过一半，而一种异步的方案产生的性能影响可能是最小的。
 </para>
<!-- pgdoc-cn_end sig_en=99d3ba1e517276bbfd6190f69537acfa -->

<!-- pgdoc-cn_start sig_en=5f918a5d0904481199818d695b89bf61 sig_cn_org=None source=14.1 
 <para>
  The remainder of this section outlines various failover, replication,
  and load balancing solutions.
 </para>
________________________________________________________-->
 <para>
  本节的剩余部分勾勒了多种故障转移、复制和负载均衡方案。
 </para>
<!-- pgdoc-cn_end sig_en=5f918a5d0904481199818d695b89bf61 -->

 <sect1 id="different-replication-solutions">
<!-- pgdoc-cn_start sig_en=b87da8d41fb380ab6afd88e58cfb1217 sig_cn_org=None source=14.1 
 <title>Comparison of Different Solutions</title>
________________________________________________________-->
 <title>不同方案的比较</title>
<!-- pgdoc-cn_end sig_en=b87da8d41fb380ab6afd88e58cfb1217 -->

 <variablelist>

  <varlistentry>
<!-- pgdoc-cn_start sig_en=c5d7cad46b5b29c0c55d993333e1ad00 sig_cn_org=None source=14.1 
   <term>Shared Disk Failover</term>
________________________________________________________-->
   <term>共享磁盘故障转移</term>
<!-- pgdoc-cn_end sig_en=c5d7cad46b5b29c0c55d993333e1ad00 -->
   <listitem>

<!-- pgdoc-cn_start sig_en=cba509de67b0021e14d6d3f0ce16e2a9 sig_cn_org=None source=14.1 
    <para>
     Shared disk failover avoids synchronization overhead by having only one
     copy of the database.  It uses a single disk array that is shared by
     multiple servers.  If the main database server fails, the standby server
     is able to mount and start the database as though it were recovering from
     a database crash.  This allows rapid failover with no data loss.
    </para>
________________________________________________________-->
    <para>
     共享磁盘故障转移避免了只使用一份数据库拷贝带来的同步开销。它使用一个由多个服务器共享的单一磁盘阵列。如果主数据库服务器失效，后备服务器则可以挂载并启动数据库，就好像它从一次数据库崩溃中恢复过来了。这是一种快速的故障转移，并且不存在数据丢失。
    </para>
<!-- pgdoc-cn_end sig_en=cba509de67b0021e14d6d3f0ce16e2a9 -->

<!-- pgdoc-cn_start sig_en=48faec3f05974724437fc42089af76fa sig_cn_org=None source=14.1 
    <para>
     Shared hardware functionality is common in network storage devices.
     Using a network file system is also possible, though care must be
     taken that the file system has full <acronym>POSIX</acronym> behavior (see <xref
     linkend="creating-cluster-nfs"/>).  One significant limitation of this
     method is that if the shared disk array fails or becomes corrupt, the
     primary and standby servers are both nonfunctional.  Another issue is
     that the standby server should never access the shared storage while
     the primary server is running.
    </para>
________________________________________________________-->
    <para>
     共享硬件功能在网络存储设备中很常见。也可以使用一个网络文件系统，但是要注意的是该文件系统应具有完全的<acronym>POSIX</acronym>行为（见<xref linkend="creating-cluster-nfs"/>）。这种方法的一个重大限制是如果共享磁盘阵列失效或损坏，主要和后备服务器都会变得无法工作。另一个问题是在主要服务器运行时，后备服务器永远不能访问共享存储。
    </para>
<!-- pgdoc-cn_end sig_en=48faec3f05974724437fc42089af76fa -->

   </listitem>
  </varlistentry>

  <varlistentry>
<!-- pgdoc-cn_start sig_en=8b90d1f259b80dadaf3022bc1ef60cdf sig_cn_org=None source=14.1 
   <term>File System (Block Device) Replication</term>
________________________________________________________-->
   <term>文件系统（块设备）复制</term>
<!-- pgdoc-cn_end sig_en=8b90d1f259b80dadaf3022bc1ef60cdf -->
   <listitem>

<!-- pgdoc-cn_start sig_en=20a4b7023bd9cacc223673d004ab5ebf sig_cn_org=None source=14.1 
    <para>
     A modified version of shared hardware functionality is file system
     replication, where all changes to a file system are mirrored to a file
     system residing on another computer.  The only restriction is that
     the mirroring must be done in a way that ensures the standby server
     has a consistent copy of the file system &mdash; specifically, writes
     to the standby must be done in the same order as those on the primary.
     <productname>DRBD</productname> is a popular file system replication solution
     for Linux.
    </para>
________________________________________________________-->
    <para>
     共享硬件功能的一种修改版本是文件系统复制，在其中对一个文件系统的所有改变会被镜像到位于另一台计算机上的一个文件系统。唯一的限制是该镜像过程必须能保证后备服务器有一份该文件系统的一致的拷贝 &mdash; 特别是对后备服务器的写入必须按照主控机上相同的顺序进行。<productname>DRBD</productname>是用于 Linux 的一种流行的文件系统复制方案。
    </para>
<!-- pgdoc-cn_end sig_en=20a4b7023bd9cacc223673d004ab5ebf -->

<!--
https://forge.continuent.org/pipermail/sequoia/2006-November/004070.html

Oracle RAC is a shared disk approach and just send cache invalidations
to other nodes but not actual data. As the disk is shared, data is
only committed once to disk and there is a distributed locking
protocol to make nodes agree on a serializable transactional order.
-->

   </listitem>
  </varlistentry>

  <varlistentry>
<!-- pgdoc-cn_start sig_en=ce37b57d01906b10085d1bbb151e84ef sig_cn_org=None source=14.1 
   <term>Write-Ahead Log Shipping</term>
________________________________________________________-->
   <term>预写式日志传送</term>
<!-- pgdoc-cn_end sig_en=ce37b57d01906b10085d1bbb151e84ef -->
   <listitem>

<!-- pgdoc-cn_start sig_en=e22796a6e9a3423de0884c6903a4b177 sig_cn_org=None source=14.1 
    <para>
     Warm and hot standby servers can be kept current by reading a
     stream of write-ahead log (<acronym>WAL</acronym>)
     records.  If the main server fails, the standby contains
     almost all of the data of the main server, and can be quickly
     made the new primary database server.  This can be synchronous or
     asynchronous and can only be done for the entire database server.
    </para>
________________________________________________________-->
    <para>
     温备和热备服务器能够通过读取一个预写式日志（<acronym>WAL</acronym>）记录的流来保持为当前状态。如果主服务器失效，后备服务器拥有主服务器的几乎所有数据，并且能够快速地被变成新的主数据库服务器。这可以是同步的或异步的，并且只能用于整个数据库服务器。
    </para>
<!-- pgdoc-cn_end sig_en=e22796a6e9a3423de0884c6903a4b177 -->
<!-- pgdoc-cn_start sig_en=7f004daafa9daa89ec825a8369c264ab sig_cn_org=None source=14.1 
    <para>
     A standby server can be implemented using file-based log shipping
     (<xref linkend="warm-standby"/>) or streaming replication (see
     <xref linkend="streaming-replication"/>), or a combination of both. For
     information on hot standby, see <xref linkend="hot-standby"/>.
    </para>
________________________________________________________-->
    <para>
     可以使用基于文件的日志传送（<xref linkend="warm-standby"/>）、流复制（见<xref linkend="streaming-replication"/>）或两者的组合来实现一个后备服务器。关于热备的信息可见<xref linkend="hot-standby"/>。
    </para>
<!-- pgdoc-cn_end sig_en=7f004daafa9daa89ec825a8369c264ab -->
   </listitem>
  </varlistentry>

  <varlistentry>
<!-- pgdoc-cn_start sig_en=b8d2e99de7707a4b7b04115852f4cdc2 sig_cn_org=None source=14.1 
   <term>Logical Replication</term>
________________________________________________________-->
   <term>逻辑复制</term>
<!-- pgdoc-cn_end sig_en=b8d2e99de7707a4b7b04115852f4cdc2 -->
   <listitem>
<!-- pgdoc-cn_start sig_en=e9955001e91f11cba069b23d5670d108 sig_cn_org=None source=14.1 
    <para>
     Logical replication allows a database server to send a stream of data
     modifications to another server.  <productname>PostgreSQL</productname>
     logical replication constructs a stream of logical data modifications
     from the WAL.  Logical replication allows replication of data changes on
     a per-table basis.  In addition, a server that is publishing its own
     changes can also subscribe to changes from another server, allowing data
     to flow in multiple directions.  For more information on logical
     replication, see <xref linkend="logical-replication"/>.  Through the
     logical decoding interface (<xref linkend="logicaldecoding"/>),
     third-party extensions can also provide similar functionality.
    </para>
________________________________________________________-->
    <para>
     逻辑复制允许数据库服务器发送数据更新流给另一台服务器。<productname>PostgreSQL</productname>逻辑复制从WAL构建出逻辑数据更新流。逻辑复制允许您逐个表复制数据更改。此外，发布数据更新的服务器可以同时订阅其他服务器的更改，从而允许数据在多个方向流动。有关逻辑复制的更多信息，请参考 <xref linkend="logical-replication"/>。通过逻辑解码接口 (<xref linkend="logicaldecoding"/>)，第三方扩展也能提供类似的功能。
    </para>
<!-- pgdoc-cn_end sig_en=e9955001e91f11cba069b23d5670d108 -->
   </listitem>
  </varlistentry>

  <varlistentry>
<!-- pgdoc-cn_start sig_en=76d62b61175dacab00052471f052ff5a sig_cn_org=None source=14.1 
   <term>Trigger-Based Primary-Standby Replication</term>
________________________________________________________-->
   <term>基于触发器的主-备复制</term>
<!-- pgdoc-cn_end sig_en=76d62b61175dacab00052471f052ff5a -->
   <listitem>

<!-- pgdoc-cn_start sig_en=9c3c241b58417f0d9562500daefe85d8 sig_cn_org=None source=14.1 
    <para>
     A trigger-based replication setup typically funnels data modification
     queries to a designated primary server. Operating on a per-table basis,
     the primary server sends data changes (typically) asynchronously to the
     standby servers.  Standby servers can answer queries while the primary is
     running, and may allow some local data changes or write activity.  This
     form of replication is often used for offloading large analytical or data
     warehouse queries.
    </para>
________________________________________________________-->
    <para>
     基于触发器的复制通常会将修改数据的查询发送到指定的主服务器。它在逐个表的基础上工作，主服务器（通常）将数据更改异步发送到备用服务器。
     主服务器运行时，备用服务器可以响应查询，并执行本地数据修改或写入操作。这种形式的复制通常用于减轻大数据分析型平台或者数据仓库查询负荷。
    </para>
<!-- pgdoc-cn_end sig_en=9c3c241b58417f0d9562500daefe85d8 -->

<!-- pgdoc-cn_start sig_en=9a4d1e92251d0f780975c0a659591bb4 sig_cn_org=None source=14.1 
    <para>
     <productname>Slony-I</productname> is an example of this type of
     replication, with per-table granularity, and support for multiple standby
     servers.  Because it updates the standby server asynchronously (in
     batches), there is possible data loss during fail over.
    </para>
________________________________________________________-->
    <para>
     <productname>Slony-I</productname>是这种复制类型的一个例子。它使用表粒度，并且支持多个后备服务器。因为它会异步更新后备服务器（批量），在故障转移时可能会有数据丢失。
    </para>
<!-- pgdoc-cn_end sig_en=9a4d1e92251d0f780975c0a659591bb4 -->
   </listitem>
  </varlistentry>

  <varlistentry>
<!-- pgdoc-cn_start sig_en=ee69e55ac1fa5a22252c23f132116b8c sig_cn_org=None source=14.1 
   <term>SQL-Based Replication Middleware</term>
________________________________________________________-->
   <term>基于SQL的复制中间件</term>
<!-- pgdoc-cn_end sig_en=ee69e55ac1fa5a22252c23f132116b8c -->
   <listitem>

<!-- pgdoc-cn_start sig_en=a61f4912105ef657387de7958d11a009 sig_cn_org=None source=14.1 
    <para>
     With SQL-based replication middleware, a program intercepts
     every SQL query and sends it to one or all servers.  Each server
     operates independently.  Read-write queries must be sent to all servers,
     so that every server receives any changes.  But read-only queries can be
     sent to just one server, allowing the read workload to be distributed
     among them.
    </para>
________________________________________________________-->
    <para>
     通过基于SQL的复制中间件，一个程序拦截每一个 SQL 查询并把它发送给一个或所有服务器。每一个服务器独立地操作。读写查询必须被发送给所有服务器，这样每一个服务器都能接收到任何修改。但只读查询可以被只发送给一个服务器，这样允许读负载在服务器之间分布。
    </para>
<!-- pgdoc-cn_end sig_en=a61f4912105ef657387de7958d11a009 -->

<!-- pgdoc-cn_start sig_en=4398bc8fb9eaf737b87e9a9b41838387 sig_cn_org=None source=14.1 
    <para>
     If queries are simply broadcast unmodified, functions like
     <function>random()</function>, <function>CURRENT_TIMESTAMP</function>, and
     sequences can have different values on different servers.
     This is because each server operates independently, and because
     SQL queries are broadcast rather than actual data changes.  If
     this is unacceptable, either the middleware or the application
     must determine such values from a single source and then use those
     values in write queries.  Care must also be taken that all
     transactions either commit or abort on all servers, perhaps
     using two-phase commit (<xref linkend="sql-prepare-transaction"/>
     and <xref linkend="sql-commit-prepared"/>).
     <productname>Pgpool-II</productname> and <productname>Continuent Tungsten</productname>
     are examples of this type of replication.
    </para>
________________________________________________________-->
    <para>如果查询未经修改发送，则函数的<function>random()</function>随机值和<function>CURRENT_TIMESTAMP</function>函数的当前时间和序列值可能因不同服务器而异。
    因为每个服务器独立运行，并且它发送 SQL 查询而没有真正的更改数据。如果这是不可接受的，那么中间件或应用程序必须从单一服务器源确定此类值，并将结果用于写入查询。
    还必须注意确保所有服务器在提交或中止事务时都是相同的。这将涉及使用 两阶段提交（<xref linkend="sql-prepare-transaction"/>和<xref linkend="sql-commit-prepared"/> ）。
    <productname>Pgpool-II</productname>和<productname>Continuent Tungsten</productname>就是这种复制的例子。
    </para>
<!-- pgdoc-cn_end sig_en=4398bc8fb9eaf737b87e9a9b41838387 -->
   </listitem>
  </varlistentry>

  <varlistentry>
<!-- pgdoc-cn_start sig_en=28eeaeb00520401b4fb7a47724868974 sig_cn_org=None source=14.1 
   <term>Asynchronous Multimaster Replication</term>
________________________________________________________-->
   <term>异步多主控机复制</term>
<!-- pgdoc-cn_end sig_en=28eeaeb00520401b4fb7a47724868974 -->
   <listitem>

<!-- pgdoc-cn_start sig_en=72b592f4567cdaa245fb2b696b103e71 sig_cn_org=None source=14.1 
    <para>
     For servers that are not regularly connected or have slow
     communication links, like laptops or
     remote servers, keeping data consistent among servers is a
     challenge.  Using asynchronous multimaster replication, each
     server works independently, and periodically communicates with
     the other servers to identify conflicting transactions.  The
     conflicts can be resolved by users or conflict resolution rules.
     Bucardo is an example of this type of replication.
    </para>
________________________________________________________-->
    <para>
     对于不会被定期连接或通讯链路较慢的服务器，如笔记本或远程服务器，保持服务器间的数据一致是一个挑战。通过使用异步的多主控机复制，每一个服务器独立工作并且定期与其他服务器通信来确定冲突的事务。这些冲突可以由用户或冲突解决规则来解决。Bucardo 是这种复制类型的一个例子。
    </para>
<!-- pgdoc-cn_end sig_en=72b592f4567cdaa245fb2b696b103e71 -->
   </listitem>
  </varlistentry>

  <varlistentry>
<!-- pgdoc-cn_start sig_en=3934c10972961504635288d082a2def5 sig_cn_org=None source=14.1 
   <term>Synchronous Multimaster Replication</term>
________________________________________________________-->
   <term>同步多主控机复制</term>
<!-- pgdoc-cn_end sig_en=3934c10972961504635288d082a2def5 -->
   <listitem>

<!-- pgdoc-cn_start sig_en=977adfdf5512119bd204fe3c4bf6b0ed sig_cn_org=None source=14.1 
    <para>
     In synchronous multimaster replication, each server can accept
     write requests, and modified data is transmitted from the
     original server to every other server before each transaction
     commits.  Heavy write activity can cause excessive locking and
     commit delays, leading to poor performance.  Read requests can
     be sent to any server.  Some implementations use shared disk
     to reduce the communication overhead.  Synchronous multimaster
     replication is best for mostly read workloads, though its big
     advantage is that any server can accept write requests &mdash;
     there is no need to partition workloads between primary and
     standby servers, and because the data changes are sent from one
     server to another, there is no problem with non-deterministic
     functions like <function>random()</function>.
    </para>
________________________________________________________-->
    <para>
     在同步多主控机复制中，每一个服务器能够接受写请求，并且在每一个事务提交之前，被修改的数据会被从原始服务器传送给每一个其他服务器。繁重的写活动可能导致过多的锁定和提交延迟，进而导致很差的性能。读请求可以被发送给任意服务器。某些实现使用共享磁盘来减少通信负荷。同步多主控机复制主要对于读负载最好，尽管它的大优点是任意服务器都能接受写请求 &mdash; 没有必要在主服务器和后备服务器之间划分负载，并且因为数据修改被从一个服务器发送到另一个服务器，不会有非确定函数（如<function>random()</function>）的问题。
    </para>
<!-- pgdoc-cn_end sig_en=977adfdf5512119bd204fe3c4bf6b0ed -->

<!-- pgdoc-cn_start sig_en=9a7befc7a1c4abd557feeca78b00eec8 sig_cn_org=None source=14.1 
    <para>
     <productname>PostgreSQL</productname> does not offer this type of replication,
     though <productname>PostgreSQL</productname> two-phase commit (<xref
     linkend="sql-prepare-transaction"/> and <xref
     linkend="sql-commit-prepared"/>)
     can be used to implement this in application code or middleware.
    </para>
________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>不提供这种复制类型，尽管在应用代码或中间件中可以使用<productname>PostgreSQL</productname>的两阶段提交（<xref linkend="sql-prepare-transaction"/>和<xref linkend="sql-commit-prepared"/>）来实现这种复制。
    </para>
<!-- pgdoc-cn_end sig_en=9a7befc7a1c4abd557feeca78b00eec8 -->
   </listitem>
  </varlistentry>

 </variablelist>

<!-- pgdoc-cn_start sig_en=1ce7428845bb94f69e518ad78bd6611f sig_cn_org=None source=14.1 
 <para>
  <xref linkend="high-availability-matrix"/> summarizes
  the capabilities of the various solutions listed above.
 </para>
________________________________________________________-->
 <para>
  <xref linkend="high-availability-matrix"/>总结了上述多种方案的能力。
 </para>
<!-- pgdoc-cn_end sig_en=1ce7428845bb94f69e518ad78bd6611f -->

 <table id="high-availability-matrix">
<!-- pgdoc-cn_start sig_en=c32a74729f03b18daea965ea4620810e sig_cn_org=None source=14.1 
  <title>High Availability, Load Balancing, and Replication Feature Matrix</title>
________________________________________________________-->
  <title>高可用、负载均衡和复制特性矩阵</title>
<!-- pgdoc-cn_end sig_en=c32a74729f03b18daea965ea4620810e -->
  <tgroup cols="9">
   <colspec colname="col1" colwidth="1.1*"/>
   <colspec colname="col2" colwidth="1*"/>
   <colspec colname="col3" colwidth="1*"/>
   <colspec colname="col4" colwidth="1*"/>
   <colspec colname="col5" colwidth="1*"/>
   <colspec colname="col6" colwidth="1*"/>
   <colspec colname="col7" colwidth="1*"/>
   <colspec colname="col8" colwidth="1*"/>
   <colspec colname="col9" colwidth="1*"/>
   <thead>
<!-- pgdoc-cn_start sig_en=e31f7b02ad8fad4cb665d4cecdf26d4d sig_cn_org=None source=14.1 
    <row>
     <entry>Feature</entry>
     <entry>Shared Disk</entry>
     <entry>File System Repl.</entry>
     <entry>Write-Ahead Log Shipping</entry>
     <entry>Logical Repl.</entry>
     <entry>Trigger-&zwsp;Based Repl.</entry>
     <entry>SQL Repl. Middle-ware</entry>
     <entry>Async. MM Repl.</entry>
     <entry>Sync. MM Repl.</entry>
    </row>
________________________________________________________-->
    <row>
     <entry>特性</entry>
     <entry>共享磁盘</entry>
     <entry>文件系统复制</entry>
     <entry>预写式日志传送</entry>
     <entry>逻辑复制</entry>
     <entry>基于触发器的复制</entry>
     <entry>SQL复制中间件</entry>
     <entry>异步多主控机复制</entry>
     <entry>同步多主控机复制</entry>
    </row>
<!-- pgdoc-cn_end sig_en=e31f7b02ad8fad4cb665d4cecdf26d4d -->
   </thead>

   <tbody>

<!-- pgdoc-cn_start sig_en=1b8c0a7642b0aa8fc50f5229b22c1686 sig_cn_org=None source=14.1 
    <row>
     <entry>Popular examples</entry>
     <entry align="center">NAS</entry>
     <entry align="center">DRBD</entry>
     <entry align="center">built-in streaming repl.</entry>
     <entry align="center">built-in logical repl., pglogical</entry>
     <entry align="center">Londiste, Slony</entry>
     <entry align="center">pgpool-II</entry>
     <entry align="center">Bucardo</entry>
     <entry align="center"></entry>
    </row>
________________________________________________________-->
    <row>
     <entry>常用的示例</entry>
     <entry align="center">NAS</entry>
     <entry align="center">DRBD</entry>
     <entry align="center">内建流复制</entry>
     <entry align="center">内建逻辑复制，pglogical</entry>
     <entry align="center">Londiste，Slony</entry>
     <entry align="center">pgpool-II</entry>
     <entry align="center">Bucardo</entry>
     <entry align="center"></entry>
    </row>
<!-- pgdoc-cn_end sig_en=1b8c0a7642b0aa8fc50f5229b22c1686 -->

<!-- pgdoc-cn_start sig_en=4a983850f69c619044c09080c1d9b7b9 sig_cn_org=None source=14.1 
    <row>
     <entry>Comm. method</entry>
     <entry align="center">shared disk</entry>
     <entry align="center">disk blocks</entry>
     <entry align="center">WAL</entry>
     <entry align="center">logical decoding</entry>
     <entry align="center">table rows</entry>
     <entry align="center">SQL</entry>
     <entry align="center">table rows</entry>
     <entry align="center">table rows and row locks</entry>
    </row>
________________________________________________________-->
    <row>
     <entry>通信方法</entry>
     <entry align="center">共享磁盘</entry>
     <entry align="center">磁盘块</entry>
     <entry align="center">WAL</entry>
     <entry align="center">逻辑解码</entry>
     <entry align="center">表行</entry>
     <entry align="center">SQL</entry>
     <entry align="center">表行</entry>
     <entry align="center">表行和行锁</entry>
    </row>
<!-- pgdoc-cn_end sig_en=4a983850f69c619044c09080c1d9b7b9 -->

<!-- pgdoc-cn_start sig_en=be0e2fee480444808436ad76f169ffe6 sig_cn_org=None source=14.1 
    <row>
     <entry>No special hardware required</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
    </row>
________________________________________________________-->
    <row>
     <entry>不要求特殊硬件</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
    </row>
<!-- pgdoc-cn_end sig_en=be0e2fee480444808436ad76f169ffe6 -->

<!-- pgdoc-cn_start sig_en=da0bef98a5185ab5722cf6fbd08e2550 sig_cn_org=None source=14.1 
    <row>
     <entry>Allows multiple primary servers</entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
    </row>
________________________________________________________-->
    <row>
     <entry>允许多个主控机服务器</entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
    </row>
<!-- pgdoc-cn_end sig_en=da0bef98a5185ab5722cf6fbd08e2550 -->

<!-- pgdoc-cn_start sig_en=9763f545cc4f6d628211e8c94709f90d sig_cn_org=None source=14.1 
    <row>
     <entry>No overhead on primary</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
    </row>
________________________________________________________-->
    <row>
     <entry>无主服务器负载</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
    </row>
<!-- pgdoc-cn_end sig_en=9763f545cc4f6d628211e8c94709f90d -->

<!-- pgdoc-cn_start sig_en=c2f01cb4d8ec50a3e2f3f1bd23a68a0e sig_cn_org=None source=14.1 
    <row>
     <entry>No waiting for multiple servers</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">with sync off</entry>
     <entry align="center">with sync off</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
    </row>
________________________________________________________-->
    <row>
     <entry>不等待多个服务器</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">with sync off</entry>
     <entry align="center">with sync off</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
    </row>
<!-- pgdoc-cn_end sig_en=c2f01cb4d8ec50a3e2f3f1bd23a68a0e -->

<!-- pgdoc-cn_start sig_en=bc38020f9542d0535e0ad914a97515d0 sig_cn_org=None source=14.1 
    <row>
     <entry>Primary failure will never lose data</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">with sync on</entry>
     <entry align="center">with sync on</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
    </row>
________________________________________________________-->
    <row>
     <entry>主控机失效将永不丢失数据</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">with sync on</entry>
     <entry align="center">with sync on</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
    </row>
<!-- pgdoc-cn_end sig_en=bc38020f9542d0535e0ad914a97515d0 -->

<!-- pgdoc-cn_start sig_en=0b4e837bcd77fe8a7243b7f944c9d11b sig_cn_org=None source=14.1 
    <row>
     <entry>Replicas accept read-only queries</entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center">with hot standby</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
    </row>
________________________________________________________-->
    <row>
     <entry>复制体接受只读查询</entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center">with hot</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
    </row>
<!-- pgdoc-cn_end sig_en=0b4e837bcd77fe8a7243b7f944c9d11b -->

<!-- pgdoc-cn_start sig_en=c70b7d08b0e000e05fb741750271447f sig_cn_org=None source=14.1 
    <row>
     <entry>Per-table granularity</entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
    </row>
________________________________________________________-->
    <row>
     <entry>每个表粒度</entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
    </row>
<!-- pgdoc-cn_end sig_en=c70b7d08b0e000e05fb741750271447f -->

<!-- pgdoc-cn_start sig_en=9f11bf5d255fc1c20cc1ccc2fd3c35c8 sig_cn_org=None source=14.1 
    <row>
     <entry>No conflict resolution necessary</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
    </row>
________________________________________________________-->
    <row>
     <entry>不需要冲突解决</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
     <entry align="center">&bull;</entry>
     <entry align="center"></entry>
     <entry align="center">&bull;</entry>
    </row>
<!-- pgdoc-cn_end sig_en=9f11bf5d255fc1c20cc1ccc2fd3c35c8 -->

   </tbody>
  </tgroup>
 </table>

<!-- pgdoc-cn_start sig_en=b4f7ff430586130c625fa69de34e55f0 sig_cn_org=None source=14.1 
 <para>
  There are a few solutions that do not fit into the above categories:
 </para>
________________________________________________________-->
 <para>
  有一些方案不适合上述的类别：
 </para>
<!-- pgdoc-cn_end sig_en=b4f7ff430586130c625fa69de34e55f0 -->

 <variablelist>

  <varlistentry>
<!-- pgdoc-cn_start sig_en=9829d6f67a4ca697b0accc76bead9427 sig_cn_org=None source=14.1 
   <term>Data Partitioning</term>
________________________________________________________-->
   <term>数据分区</term>
<!-- pgdoc-cn_end sig_en=9829d6f67a4ca697b0accc76bead9427 -->
   <listitem>

<!-- pgdoc-cn_start sig_en=599e726e329a081df6c09ab9d3a756f1 sig_cn_org=None source=14.1 
    <para>
     Data partitioning splits tables into data sets.  Each set can
     be modified by only one server.  For example, data can be
     partitioned by offices, e.g., London and Paris, with a server
     in each office.  If queries combining London and Paris data
     are necessary, an application can query both servers, or
     primary/standby replication can be used to keep a read-only copy
     of the other office's data on each server.
    </para>
________________________________________________________-->
    <para>
     数据分区将表分开成数据集。每个集合只能被一个服务器修改。例如，数据可以根据办公室划分，如伦敦和巴黎，每一个办公室有一个服务器。如果查询有必要组合伦敦和巴黎的数据，一个应用可以查询两个服务器，或者可以使用主/备复制来在每一台服务器上保持其他办公室数据的一个只读拷贝。
    </para>
<!-- pgdoc-cn_end sig_en=599e726e329a081df6c09ab9d3a756f1 -->
   </listitem>
  </varlistentry>

  <varlistentry>
<!-- pgdoc-cn_start sig_en=6daebd6b27f7049f0171137fa9ab5680 sig_cn_org=None source=14.1 
   <term>Multiple-Server Parallel Query Execution</term>
________________________________________________________-->
   <term>多服务器并行查询执行</term>
<!-- pgdoc-cn_end sig_en=6daebd6b27f7049f0171137fa9ab5680 -->
   <listitem>

<!-- pgdoc-cn_start sig_en=1b5daa73e06956062e064ae5f7878da2 sig_cn_org=None source=14.1 
    <para>
     Many of the above solutions allow multiple servers to handle multiple
     queries, but none allow a single query to use multiple servers to
     complete faster.  This solution allows multiple servers to work
     concurrently on a single query.  It is usually accomplished by
     splitting the data among servers and having each server execute its
     part of the query and return results to a central server where they
     are combined and returned to the user. This can be implemented using the
     <productname>PL/Proxy</productname> tool set.
    </para>
________________________________________________________-->
    <para>
     上述的很多方案允许多个服务器来处理多个查询，但是没有一个允许一个单一查询使用多个服务器来更快完成。
     这种方案允许多个服务器在一个单一查询上并发工作。
     这通常通过把数据在服务器之间划分并且让每一个服务器执行该查询中属于它的部分，然后将结果返回给一个中心服务器，由它整合结果并发回给用户。
     这也可以使用<productname>PL/Proxy</productname>工具集来实现这种方案。
    </para>
<!-- pgdoc-cn_end sig_en=1b5daa73e06956062e064ae5f7878da2 -->

   </listitem>
  </varlistentry>

 </variablelist>

<!-- pgdoc-cn_start sig_en=09ae3cf39d3a140d49aadfe09de52bd3 sig_cn_org=None source=14.1 
  <para>
   It should also be noted that because <productname>PostgreSQL</productname>
   is open source and easily extended, a number of companies have
   taken <productname>PostgreSQL</productname> and created commercial
   closed-source solutions with unique failover, replication, and load
   balancing capabilities.  These are not discussed here.
  </para>
________________________________________________________-->
  <para>
   还需要注意的是由于<productname>PostgreSQL</productname>是开源的并且易于扩展，许多公司已经采用<productname>PostgreSQL</productname>并创建了具有独特的故障转移、复制和负载平衡功能的商业闭源解决方案。这里不讨论这些。
  </para>
<!-- pgdoc-cn_end sig_en=09ae3cf39d3a140d49aadfe09de52bd3 -->

 </sect1>


 <sect1 id="warm-standby">
<!-- pgdoc-cn_start sig_en=3e2ff94cf7670637ee11894e88f4fad0 sig_cn_org=None source=14.1 
 <title>Log-Shipping Standby Servers</title>
________________________________________________________-->
 <title>日志传送后备服务器</title>
<!-- pgdoc-cn_end sig_en=3e2ff94cf7670637ee11894e88f4fad0 -->


<!-- pgdoc-cn_start sig_en=e83c5c58abdd57e363ace534f3c4ffa2 sig_cn_org=None source=14.1 
  <para>
   Continuous archiving can be used to create a <firstterm>high
   availability</firstterm> (HA) cluster configuration with one or more
   <firstterm>standby servers</firstterm> ready to take over operations if the
   primary server fails. This capability is widely referred to as
   <firstterm>warm standby</firstterm> or <firstterm>log shipping</firstterm>.
  </para>
________________________________________________________-->
  <para>
   连续归档可以被用来创建一个<firstterm>高可用性</firstterm>（HA）集群配置，其中有一个或多个<firstterm>后备服务器</firstterm>随时准备在主服务器失效时接管操作。这种能力被广泛地称为<firstterm>温备</firstterm>或<firstterm>日志传送</firstterm>。
  </para>
<!-- pgdoc-cn_end sig_en=e83c5c58abdd57e363ace534f3c4ffa2 -->

<!-- pgdoc-cn_start sig_en=6dbae7b21846fce673593fc80d761ad1 sig_cn_org=None source=14.1 
  <para>
   The primary and standby server work together to provide this capability,
   though the servers are only loosely coupled. The primary server operates
   in continuous archiving mode, while each standby server operates in
   continuous recovery mode, reading the WAL files from the primary. No
   changes to the database tables are required to enable this capability,
   so it offers low administration overhead compared to some other
   replication solutions. This configuration also has relatively low
   performance impact on the primary server.
  </para>
________________________________________________________-->
  <para>
   主服务器和后备服务器一起工作来提供这种能力，但这些服务器只是松散地组织在一起。主服务器在连续归档模式下操作，而每一个后备服务器在连续恢复模式下操作并且持续从主服务器读取 WAL 文件。要启用这种能力不需要对数据库表做任何改动，因此它相对于其他复制方案降低了管理开销。这种配置对主服务器的性能影响也相对较低。
  </para>
<!-- pgdoc-cn_end sig_en=6dbae7b21846fce673593fc80d761ad1 -->

<!-- pgdoc-cn_start sig_en=a769a96f47247df1c7a5231d81cfbdbe sig_cn_org=None source=14.1 
  <para>
   Directly moving WAL records from one database server to another
   is typically described as log shipping. <productname>PostgreSQL</productname>
   implements file-based log shipping by transferring WAL records
   one file (WAL segment) at a time. WAL files (16MB) can be
   shipped easily and cheaply over any distance, whether it be to an
   adjacent system, another system at the same site, or another system on
   the far side of the globe. The bandwidth required for this technique
   varies according to the transaction rate of the primary server.
   Record-based log shipping is more granular and streams WAL changes
   incrementally over a network connection (see <xref
   linkend="streaming-replication"/>).
  </para>
________________________________________________________-->
  <para>
   直接从一个数据库服务器移动 WAL 记录到另一台服务器通常被描述为日志传送。<productname>PostgreSQL</productname>通过一次一文件（WAL 段）的 WAL 记录传输实现了基于文件的日志传送。不管 WAL 文件（16 MB）要被送到一个临近的系统、同一站点的另一个系统或是在地球遥远的另一端的一个系统上，它都可以在任何距离上被简单和便宜地传送。这种技术所需的带宽取根据主服务器的事务率而变化。基于记录的日志传送具有更细的粒度并且能够在网络连接上以流的方式增量传递 WAL 的改变（见<xref linkend="streaming-replication"/>）。
  </para>
<!-- pgdoc-cn_end sig_en=a769a96f47247df1c7a5231d81cfbdbe -->

<!-- pgdoc-cn_start sig_en=5971d28912c636e3176284c8d22db0a5 sig_cn_org=None source=14.1 
  <para>
   It should be noted that log shipping is asynchronous, i.e., the WAL
   records are shipped after transaction commit. As a result, there is a
   window for data loss should the primary server suffer a catastrophic
   failure; transactions not yet shipped will be lost.  The size of the
   data loss window in file-based log shipping can be limited by use of the
   <varname>archive_timeout</varname> parameter, which can be set as low
   as a few seconds.  However such a low setting will
   substantially increase the bandwidth required for file shipping.
   Streaming replication (see <xref linkend="streaming-replication"/>)
   allows a much smaller window of data loss.
  </para>
________________________________________________________-->
  <para>
   需要注意的是日志传送是异步的，即 WAL 记录是在事务提交后才被传送。正因为如此，在一个窗口期内如果主服务器发生灾难性的失效则会导致数据丢失，还没有被传送的事务将会被丢失。基于文件的日志传送中这个数据丢失窗口的尺寸可以通过使用参数<varname>archive_timeout</varname>进行限制，它可以被设置成低至数秒。但是这样低的设置大体上会增加文件传送所需的带宽。流复制（见<xref linkend="streaming-replication"/>）允许更小的数据丢失窗口。
  </para>
<!-- pgdoc-cn_end sig_en=5971d28912c636e3176284c8d22db0a5 -->

<!-- pgdoc-cn_start sig_en=d5b102489a5b85f8097a6181ff6933b5 sig_cn_org=d2e96cae54884a0018a425bf4a052ae4 source=15.7 
  <para>
   Recovery performance is sufficiently good that the standby will
   typically be only moments away from full
   availability once it has been activated. As a result, this is called
   a warm standby configuration which offers high
   availability. Restoring a server from an archived base backup and
   rollforward will take considerably longer, so that technique only
   offers a solution for disaster recovery, not high availability.
   A standby server can also be used for read-only queries, in which case
   it is called a <firstterm>hot standby</firstterm> server. See
   <xref linkend="hot-standby"/> for more information.
  </para>
________________________________________________________-->
  <para>
   恢复性能足够好，因此备用服务器通常只需几秒钟即可完全可用一次激活。因此，这被称为热备份配置，提供高可用性。从存档的基本备份和回滚恢复服务器将需要更长时间，因此该技术仅提供灾难恢复解决方案，而不是高可用性。备用服务器还可以用于只读查询，此时称为<firstterm>热备份</firstterm>服务器。有关更多信息，请参见<xref linkend="hot-standby"/>。
  </para>
<!-- pgdoc-cn_end sig_en=d5b102489a5b85f8097a6181ff6933b5 -->

<!-- pgdoc-cn_start sig_en=78136a156e2177627386e00044bede8c sig_cn_org=None source=14.1 
  <indexterm zone="high-availability">
   <primary>warm standby</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="high-availability">
   <primary>温备</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=78136a156e2177627386e00044bede8c -->

<!-- pgdoc-cn_start sig_en=65602753730a5adbf14a969be526d245 sig_cn_org=None source=14.1 
  <indexterm zone="high-availability">
   <primary>PITR standby</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="high-availability">
   <primary>PITR standby</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=65602753730a5adbf14a969be526d245 -->

<!-- pgdoc-cn_start sig_en=69c135690d7006f911065c4b158a8548 sig_cn_org=None source=14.1 
  <indexterm zone="high-availability">
   <primary>standby server</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="high-availability">
   <primary>后备服务器</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=69c135690d7006f911065c4b158a8548 -->

<!-- pgdoc-cn_start sig_en=2258dfc3fb9f7d07bcc767a0bfc00960 sig_cn_org=None source=14.1 
  <indexterm zone="high-availability">
   <primary>log shipping</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="high-availability">
   <primary>日志传送</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=2258dfc3fb9f7d07bcc767a0bfc00960 -->

<!-- pgdoc-cn_start sig_en=9f718f4a4810407494774aca2c9c055f sig_cn_org=None source=14.1 
  <indexterm zone="high-availability">
   <primary>witness server</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="high-availability">
   <primary>witness server</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=9f718f4a4810407494774aca2c9c055f -->

<!-- pgdoc-cn_start sig_en=9796727de31c7b7ae4e5fa413eb5f3b5 sig_cn_org=None source=14.1 
  <indexterm zone="high-availability">
   <primary>STONITH</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="high-availability">
   <primary>STONITH</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=9796727de31c7b7ae4e5fa413eb5f3b5 -->

  <sect2 id="standby-planning">
<!-- pgdoc-cn_start sig_en=f2c8de268e736fe449485d7ce15a7e43 sig_cn_org=None source=14.1 
   <title>Planning</title>
________________________________________________________-->
   <title>规划</title>
<!-- pgdoc-cn_end sig_en=f2c8de268e736fe449485d7ce15a7e43 -->

<!-- pgdoc-cn_start sig_en=154537dd24613e91ab1d3cd44e095d33 sig_cn_org=None source=14.1 
   <para>
    It is usually wise to create the primary and standby servers
    so that they are as similar as possible, at least from the
    perspective of the database server.  In particular, the path names
    associated with tablespaces will be passed across unmodified, so both
    primary and standby servers must have the same mount paths for
    tablespaces if that feature is used.  Keep in mind that if
    <xref linkend="sql-createtablespace"/>
    is executed on the primary, any new mount point needed for it must
    be created on the primary and all standby servers before the command
    is executed. Hardware need not be exactly the same, but experience shows
    that maintaining two identical systems is easier than maintaining two
    dissimilar ones over the lifetime of the application and system.
    In any case the hardware architecture must be the same &mdash; shipping
    from, say, a 32-bit to a 64-bit system will not work.
   </para>
________________________________________________________-->
   <para>
    创建主服务器和后备服务器通常是明智的，因此它们可以尽可能相似，至少从数据库服务器的角度来看是这样。特别地，与表空间相关的路径名将被未经修改地传递，因此如果该特性被使用，主、备服务器必须对表空间具有完全相同的挂载路径。记住如果<xref linkend="sql-createtablespace"/>在主服务器上被执行，在命令被执行前，它所需要的任何新挂载点必须在主服务器和所有后备服务器上先创建好。硬件不需要完全相同，但是经验显示，在应用和系统的生命期内维护两个相同的系统比维护两个不相似的系统更容易。在任何情况下硬件架构必须相同 &mdash; 从一个 32 位系统传送到一个 64 位系统将不会工作。
   </para>
<!-- pgdoc-cn_end sig_en=154537dd24613e91ab1d3cd44e095d33 -->

<!-- pgdoc-cn_start sig_en=67fc24d8d69f6dd66fa75f5f14a38bdc sig_cn_org=None source=14.1 
   <para>
    In general, log shipping between servers running different major
    <productname>PostgreSQL</productname> release
    levels is not possible. It is the policy of the PostgreSQL Global
    Development Group not to make changes to disk formats during minor release
    upgrades, so it is likely that running different minor release levels
    on primary and standby servers will work successfully. However, no
    formal support for that is offered and you are advised to keep primary
    and standby servers at the same release level as much as possible.
    When updating to a new minor release, the safest policy is to update
    the standby servers first &mdash; a new minor release is more likely
    to be able to read WAL files from a previous minor release than vice
    versa.
   </para>
________________________________________________________-->
   <para>
    通常，不能在两个运行着不同主版本<productname>PostgreSQL</productname>的服务器之间传送日志。PostgreSQL 全球开发组的策略是不在次版本升级中改变磁盘格式，因此在主服务器和后备服务器上运行不同次版本将会成功地工作。不过，在这方面并没有提供正式的支持，因此我们建议让主备服务器上运行的版本尽可能相同。当升级到一个新的次版本时，最安全的策略是先升级后备服务器 &mdash; 一个新的次版本发行更可能兼容从前一个次版本读取 WAL 文件。
   </para>
<!-- pgdoc-cn_end sig_en=67fc24d8d69f6dd66fa75f5f14a38bdc -->

  </sect2>

  <sect2 id="standby-server-operation" xreflabel="Standby Server Operation">
<!-- pgdoc-cn_start sig_en=4a863eac8256185312ccab161d230c2a sig_cn_org=None source=14.1 
   <title>Standby Server Operation</title>
________________________________________________________-->
   <title>后备服务器操作</title>
<!-- pgdoc-cn_end sig_en=4a863eac8256185312ccab161d230c2a -->

<!-- pgdoc-cn_start sig_en=3bde81a7bc445bef843398513a23c1f3 sig_cn_org=None source=14.1 
   <para>
    A server enters standby mode if a
    <anchor id="file-standby-signal" xreflabel="standby.signal"/>
    <filename>standby.signal</filename>
    <indexterm><primary><filename>standby.signal</filename></primary></indexterm>
    file exists in the data directory when the server is started.
   </para>
________________________________________________________-->
   <para>
    服务器启动时，数据目录中存在<anchor id="file-standby-signal" xreflabel="standby.signal"/>
    <filename>standby.signal</filename>
    <indexterm><primary><filename>standby.signal</filename></primary></indexterm>文件，服务器进入standby模式。
   </para>
<!-- pgdoc-cn_end sig_en=3bde81a7bc445bef843398513a23c1f3 -->

<!-- pgdoc-cn_start sig_en=38d033e0de31640e433f2eb8b603f4ac sig_cn_org=None source=14.1 
   <para>
    In standby mode, the server continuously applies WAL received from the
    primary server. The standby server can read WAL from a WAL archive
    (see <xref linkend="guc-restore-command"/>) or directly from the primary
    over a TCP connection (streaming replication). The standby server will
    also attempt to restore any WAL found in the standby cluster's
    <filename>pg_wal</filename> directory. That typically happens after a server
    restart, when the standby replays again WAL that was streamed from the
    primary before the restart, but you can also manually copy files to
    <filename>pg_wal</filename> at any time to have them replayed.
   </para>
________________________________________________________-->
   <para>
    在后备模式中，服务器持续地应用从主控服务器接收到的 WAL。后备服务器可以从一个 WAL 归档（<xref linkend="guc-restore-command"/>）或者通过一个 TCP 连接直接从主控机（流复制）读取 WAL。后备服务器将也尝试恢复在后备集簇的<filename>pg_wal</filename>目录中找到的 WAL。那通常在一次数据库重启后发生，那时后备机将在重启之前重播从主控机流过来的 WAL，但是你也可以在任何时候手动拷贝文件到<filename>pg_wal</filename>让它们被重播。
   </para>
<!-- pgdoc-cn_end sig_en=38d033e0de31640e433f2eb8b603f4ac -->

<!-- pgdoc-cn_start sig_en=c25d1b5c975b62a8a60f89b916a07218 sig_cn_org=e2a2c1b17813d1457d84e9cc25a4008f source=15.7 
   <para>
    At startup, the standby begins by restoring all WAL available in the
    archive location, calling <varname>restore_command</varname>. Once it
    reaches the end of WAL available there and <varname>restore_command</varname>
    fails, it tries to restore any WAL available in the <filename>pg_wal</filename> directory.
    If that fails, and streaming replication has been configured, the
    standby tries to connect to the primary server and start streaming WAL
    from the last valid record found in archive or <filename>pg_wal</filename>. If that fails
    or streaming replication is not configured, or if the connection is
    later disconnected, the standby goes back to step 1 and tries to
    restore the file from the archive again. This loop of retries from the
    archive, <filename>pg_wal</filename>, and via streaming replication goes on until the server
    is stopped or is promoted.
   </para>
________________________________________________________-->
   <para>
    在启动时，备用服务器首先通过调用<varname>restore_command</varname>来恢复存档位置中的所有WAL。
    一旦到达那里可用的WAL的末尾，并且<varname>restore_command</varname>失败，它会尝试恢复<filename>pg_wal</filename>目录中可用的任何WAL。
    如果失败，并且已配置流复制，备用服务器会尝试连接到主服务器，并从存档或<filename>pg_wal</filename>中找到的最后一个有效记录开始流式传输WAL。
    如果失败，或者未配置流复制，或者连接稍后断开，备用服务器将返回到第1步，并尝试再次从存档中恢复文件。
    这种从存档、<filename>pg_wal</filename>和通过流复制的重试循环将持续，直到服务器停止或升级。
</para>
<!-- pgdoc-cn_end sig_en=c25d1b5c975b62a8a60f89b916a07218 -->

<!-- pgdoc-cn_start sig_en=70df9e33a92b8691bddd09644189f4ff sig_cn_org=None source=14.1 
   <para>
    Standby mode is exited and the server switches to normal operation
    when <command>pg_ctl promote</command> is run,
    <function>pg_promote()</function> is called, or a trigger file is found
    (<varname>promote_trigger_file</varname>). Before failover,
    any WAL immediately available in the archive or in <filename>pg_wal</filename> will be
    restored, but no attempt is made to connect to the primary.
   </para>
________________________________________________________-->
   <para>
    当<command>pg_ctl promote</command>被运行，<function>pg_promote()</function>被调用，或一个触发器文件被找到（<varname>promote_trigger_file</varname>），后备模式会退出并且服务器会切换到普通操作。
    在故障转移之前，在归档或<filename>pg_wal</filename>中立即可用的任何 WAL 将被恢复，但不会尝试连接到主控机。
   </para>
<!-- pgdoc-cn_end sig_en=70df9e33a92b8691bddd09644189f4ff -->
  </sect2>

  <sect2 id="preparing-primary-for-standby">
<!-- pgdoc-cn_start sig_en=f6b83b938206b0216b212fcf27dd3051 sig_cn_org=None source=14.1 
   <title>Preparing the Primary for Standby Servers</title>
________________________________________________________-->
   <title>为后备服务器准备主控机</title>
<!-- pgdoc-cn_end sig_en=f6b83b938206b0216b212fcf27dd3051 -->

<!-- pgdoc-cn_start sig_en=8e15b32c0c183de39142d143fa4ece25 sig_cn_org=None source=14.1 
   <para>
    Set up continuous archiving on the primary to an archive directory
    accessible from the standby, as described
    in <xref linkend="continuous-archiving"/>. The archive location should be
    accessible from the standby even when the primary is down, i.e., it should
    reside on the standby server itself or another trusted server, not on
    the primary server.
   </para>
________________________________________________________-->
   <para>
    如<xref linkend="continuous-archiving"/>中所述，在主服务器上设置连续归档到一个后备服务器可访问的归档目录。即使主服务器垮掉该归档位置也应当是后备服务器可访问的，即它应当位于后备服务器本身或者另一个可信赖的服务器，而不是位于主控服务器上。
   </para>
<!-- pgdoc-cn_end sig_en=8e15b32c0c183de39142d143fa4ece25 -->

<!-- pgdoc-cn_start sig_en=9605f74ffd66289d372be9f1f7f05064 sig_cn_org=None source=14.1 
   <para>
    If you want to use streaming replication, set up authentication on the
    primary server to allow replication connections from the standby
    server(s); that is, create a role and provide a suitable entry or
    entries in <filename>pg_hba.conf</filename> with the database field set to
    <literal>replication</literal>.  Also ensure <varname>max_wal_senders</varname> is set
    to a sufficiently large value in the configuration file of the primary
    server. If replication slots will be used,
    ensure that <varname>max_replication_slots</varname> is set sufficiently
    high as well.
   </para>
________________________________________________________-->
   <para>
    如果你想要使用流复制，在主服务器上设置认证来允许来自后备服务器的复制连接。即创建一个角色并且在<filename>pg_hba.conf</filename>中提供一个或多个数据库域被设置为<literal>replication</literal>的项。还要保证在主服务器的配置文件中<varname>max_wal_senders</varname>被设置为足够大的值。如果要使用复制槽，请确保<varname>max_replication_slots</varname>也被设置得足够高。
   </para>
<!-- pgdoc-cn_end sig_en=9605f74ffd66289d372be9f1f7f05064 -->

<!-- pgdoc-cn_start sig_en=552328324424894c8cfc1e7ebeda1d7e sig_cn_org=None source=14.1 
   <para>
    Take a base backup as described in <xref linkend="backup-base-backup"/>
    to bootstrap the standby server.
   </para>
________________________________________________________-->
   <para>
    按<xref linkend="backup-base-backup"/>所述取得一个基础备份来引导后备服务器。
   </para>
<!-- pgdoc-cn_end sig_en=552328324424894c8cfc1e7ebeda1d7e -->
  </sect2>

  <sect2 id="standby-server-setup">
<!-- pgdoc-cn_start sig_en=40376ddc8561f12f9c974564f0b91f4b sig_cn_org=None source=14.1 
   <title>Setting Up a Standby Server</title>
________________________________________________________-->
   <title>建立一个后备服务器</title>
<!-- pgdoc-cn_end sig_en=40376ddc8561f12f9c974564f0b91f4b -->

<!-- pgdoc-cn_start sig_en=60942d928d6aa4434008c5aa1c1390e9 sig_cn_org=None source=14.1 
   <para>
    To set up the standby server, restore the base backup taken from primary
    server (see <xref linkend="backup-pitr-recovery"/>). Create a file
    <link linkend="file-standby-signal"><filename>standby.signal</filename></link><indexterm><primary>standby.signal</primary></indexterm>
    in the standby's cluster data
    directory. Set <xref linkend="guc-restore-command"/> to a simple command to copy files from
    the WAL archive. If you plan to have multiple standby servers for high
    availability purposes, make sure that <varname>recovery_target_timeline</varname> is set to
    <literal>latest</literal> (the default), to make the standby server follow the timeline change
    that occurs at failover to another standby.
   </para>
________________________________________________________-->
   <para>
    要建立后备服务器，恢复从主服务器取得的基础备份（<xref linkend="backup-pitr-recovery"/>）。在后备服务器的集簇数据目录中创建一个文件<link linkend="file-standby-signal"><filename>standby.signal</filename></link><indexterm><primary>standby.signal</primary></indexterm>。将<xref linkend="guc-restore-command"/>设置为一个从 WAL 归档中复制文件的简单命令。
    如果你计划为了高可用性目的建立多个后备服务器，确认<varname>recovery_target_timeline</varname>被设置为<literal>latest</literal> (默认)来使得该后备服务器遵循发生在故障转移到另一个后备服务器之后发生的时间线改变。
   </para>
<!-- pgdoc-cn_end sig_en=60942d928d6aa4434008c5aa1c1390e9 -->

   <note>
<!-- pgdoc-cn_start sig_en=45ff82c5faf08af5f73ea6723c7d7092 sig_cn_org=None source=14.1 
     <para>
     <xref linkend="guc-restore-command"/> should return immediately
     if the file does not exist; the server will retry the command again if
     necessary.
    </para>
________________________________________________________-->
     <para>
     <xref linkend="guc-restore-command"/>应该立即返回，如果必要该服务器将再次尝试该命令。
    </para>
<!-- pgdoc-cn_end sig_en=45ff82c5faf08af5f73ea6723c7d7092 -->
   </note>

<!-- pgdoc-cn_start sig_en=63f4cd15a5eb10003d113e90483a1510 sig_cn_org=None source=14.1 
   <para>
     If you want to use streaming replication, fill in
     <xref linkend="guc-primary-conninfo"/> with a libpq connection string, including
     the host name (or IP address) and any additional details needed to
     connect to the primary server. If the primary needs a password for
     authentication, the password needs to be specified in
     <xref linkend="guc-primary-conninfo"/> as well.
   </para>
________________________________________________________-->
   <para>
     如果你想要使用流复制，在<xref linkend="guc-primary-conninfo"/>中填入一个 libpq 连接字符串，其中包括主机名（或 IP 地址）和连接到主服务器所需的任何附加细节。如果主服务器需要一个口令用于认证，口令也应该被指定在<xref linkend="guc-primary-conninfo"/>中。
   </para>
<!-- pgdoc-cn_end sig_en=63f4cd15a5eb10003d113e90483a1510 -->

<!-- pgdoc-cn_start sig_en=36851eb06e1e8ae85aea494ef0c4fe56 sig_cn_org=None source=14.1 
   <para>
    If you're setting up the standby server for high availability purposes,
    set up WAL archiving, connections and authentication like the primary
    server, because the standby server will work as a primary server after
    failover.
   </para>
________________________________________________________-->
   <para>
    如果你正在为高性能目的建立后备服务器，像主服务器一样建立 WAL 归档、连接和认证，因为在故障转移后该后备服务器将作为一个主服务器工作。
   </para>
<!-- pgdoc-cn_end sig_en=36851eb06e1e8ae85aea494ef0c4fe56 -->

<!-- pgdoc-cn_start sig_en=c759e8539259858aa9e641d65a501160 sig_cn_org=None source=14.1 
   <para>
    If you're using a WAL archive, its size can be minimized using the <xref
    linkend="guc-archive-cleanup-command"/> parameter to remove files that are no
    longer required by the standby server.
    The <application>pg_archivecleanup</application> utility is designed specifically to
    be used with <varname>archive_cleanup_command</varname> in typical single-standby
    configurations, see <xref linkend="pgarchivecleanup"/>.
    Note however, that if you're using the archive for backup purposes, you
    need to retain files needed to recover from at least the latest base
    backup, even if they're no longer needed by the standby.
   </para>
________________________________________________________-->
   <para>
    如果你正在使用一个 WAL 归档，可以使用<xref linkend="guc-archive-cleanup-command"/>参数来移除后备服务器不再需要的文件，这样可以最小化 WAL 归档的尺寸。<application>pg_archivecleanup</application>工具被特别设计为在典型单一后备配置下与<varname>archive_cleanup_command</varname>共同使用，见<xref linkend="pgarchivecleanup"/>。不过要注意，如果你正在为备份目的使用归档，有一些文件即使后备服务器不再需要你也需要保留它们，它们被用来从至少最后一个基础备份恢复。
   </para>
<!-- pgdoc-cn_end sig_en=c759e8539259858aa9e641d65a501160 -->

<!-- pgdoc-cn_start sig_en=d8d178ae7b0d57473f1f29c1b8e921d7 sig_cn_org=None source=14.1 
   <para>
    A simple example of configuration is:
<programlisting>
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass options=''-c wal_sender_timeout=5000'''
restore_command = 'cp /path/to/archive/%f %p'
archive_cleanup_command = 'pg_archivecleanup /path/to/archive %r'
</programlisting>
   </para>
________________________________________________________-->
   <para>
    配置的一个简单例子是：
<programlisting>
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass options=''-c wal_sender_timeout=5000'''
restore_command = 'cp /path/to/archive/%f %p'
archive_cleanup_command = 'pg_archivecleanup /path/to/archive %r'
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=d8d178ae7b0d57473f1f29c1b8e921d7 -->

<!-- pgdoc-cn_start sig_en=2c0b03dd2e65b8e8c649518553e17df4 sig_cn_org=None source=14.1 
   <para>
    You can have any number of standby servers, but if you use streaming
    replication, make sure you set <varname>max_wal_senders</varname> high enough in
    the primary to allow them to be connected simultaneously.
   </para>
________________________________________________________-->
   <para>
    你可以有任意数量的后备服务器，但是如果你使用流复制，确保你在主服务器上将<varname>max_wal_senders</varname>设置得足够高，这样可以允许它们能同时连接。
   </para>
<!-- pgdoc-cn_end sig_en=2c0b03dd2e65b8e8c649518553e17df4 -->

  </sect2>

  <sect2 id="streaming-replication">
<!-- pgdoc-cn_start sig_en=e9b54685922fdf4e2b6ba3a272e28467 sig_cn_org=None source=14.1 
   <title>Streaming Replication</title>
________________________________________________________-->
   <title>流复制</title>
<!-- pgdoc-cn_end sig_en=e9b54685922fdf4e2b6ba3a272e28467 -->

<!-- pgdoc-cn_start sig_en=93eb0886dcc6b2c0208d4838dec5e89a sig_cn_org=None source=14.1 
   <indexterm zone="high-availability">
    <primary>Streaming Replication</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="high-availability">
    <primary>流复制</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=93eb0886dcc6b2c0208d4838dec5e89a -->

<!-- pgdoc-cn_start sig_en=6e278585f65c30f22999c0730d7b4553 sig_cn_org=None source=14.1 
   <para>
    Streaming replication allows a standby server to stay more up-to-date
    than is possible with file-based log shipping. The standby connects
    to the primary, which streams WAL records to the standby as they're
    generated, without waiting for the WAL file to be filled.
   </para>
________________________________________________________-->
   <para>
    流复制允许一台后备服务器比使用基于文件的日志传送更能保持为最新的状态。后备服务器连接到主服务器，主服务器则在 WAL 记录产生时即将它们以流式传送给后备服务器而不必等到 WAL 文件被填充。
   </para>
<!-- pgdoc-cn_end sig_en=6e278585f65c30f22999c0730d7b4553 -->

<!-- pgdoc-cn_start sig_en=5d8895841d6e41d4790a6906db35e766 sig_cn_org=None source=14.1 
   <para>
    Streaming replication is asynchronous by default
    (see <xref linkend="synchronous-replication"/>), in which case there is
    a small delay between committing a transaction in the primary and the
    changes becoming visible in the standby. This delay is however much
    smaller than with file-based log shipping, typically under one second
    assuming the standby is powerful enough to keep up with the load. With
    streaming replication, <varname>archive_timeout</varname> is not required to
    reduce the data loss window.
   </para>
________________________________________________________-->
   <para>
    默认情况下流复制是异步的（见<xref linkend="synchronous-replication"/>），在这种情况下主服务器上提交一个事务与该变化在后备服务器上变得可见之间存在短暂的延迟。不过这种延迟比基于文件的日志传送方式中要小得多，在后备服务器的能力足以跟得上负载的前提下延迟通常低于一秒。在流复制中，不需要<varname>archive_timeout</varname>来缩减数据丢失窗口。
   </para>
<!-- pgdoc-cn_end sig_en=5d8895841d6e41d4790a6906db35e766 -->

<!-- pgdoc-cn_start sig_en=99c99c53eaaedbc08e518d8df5e6d4b3 sig_cn_org=None source=14.1 
   <para>
    If you use streaming replication without file-based continuous
    archiving, the server might recycle old WAL segments before the standby
    has received them.  If this occurs, the standby will need to be
    reinitialized from a new base backup.  You can avoid this by setting
    <varname>wal_keep_size</varname> to a value large enough to ensure that
    WAL segments are not recycled too early, or by configuring a replication
    slot for the standby.  If you set up a WAL archive that's accessible from
    the standby, these solutions are not required, since the standby can
    always use the archive to catch up provided it retains enough segments.
   </para>
________________________________________________________-->
   <para>
    如果你使用的流复制没有基于文件的连续归档，该服务器可能在后备机收到 WAL 段之
    前回收这些旧的 WAL 段。如果发生这种情况，后备机将需要重新从一个新的基础备
    份初始化。通过设置<varname>wal_keep_size</varname>为一个足够高的值来确保旧
    的 WAL 段不会被太早重用或者为后备机配置一个复制槽，可以避免发生这种情况。如
    果设置了一个后备机可以访问的 WAL 归档，就不需要这些解决方案，因为该归档可以
    为后备机保留足够的段，后备机总是可以使用该归档来追赶主控机。
   </para>
<!-- pgdoc-cn_end sig_en=99c99c53eaaedbc08e518d8df5e6d4b3 -->

<!-- pgdoc-cn_start sig_en=3d76f3d660f5c4d47a8f135ecacb6cad sig_cn_org=None source=14.1 
   <para>
    To use streaming replication, set up a file-based log-shipping standby
    server as described in <xref linkend="warm-standby"/>. The step that
    turns a file-based log-shipping standby into streaming replication
    standby is setting the <varname>primary_conninfo</varname> setting
    to point to the primary server. Set
    <xref linkend="guc-listen-addresses"/> and authentication options
    (see <filename>pg_hba.conf</filename>) on the primary so that the standby server
    can connect to the <literal>replication</literal> pseudo-database on the primary
    server (see <xref linkend="streaming-replication-authentication"/>).
   </para>
________________________________________________________-->
   <para>
    要使用流复制，按<xref linkend="warm-standby"/>所述建立一个基于文件的日志传送后备服务器。将一个基于文件日志传送后备服务器转变成流复制后备服务器的步骤是把<filename>recovery.conf</filename>文件中的设置以指向主服务器。设置主服务器上的<xref linkend="guc-listen-addresses"/>和认证选项（见<filename>pg_hba.conf</filename>），这样后备服务器可以连接到主服务器上的伪数据库<literal>replication</literal>（见<xref linkend="streaming-replication-authentication"/>）。
   </para>
<!-- pgdoc-cn_end sig_en=3d76f3d660f5c4d47a8f135ecacb6cad -->

<!-- pgdoc-cn_start sig_en=0b87ce4922c3733843c6a65141ef85a0 sig_cn_org=None source=14.1 
   <para>
    On systems that support the keepalive socket option, setting
    <xref linkend="guc-tcp-keepalives-idle"/>,
    <xref linkend="guc-tcp-keepalives-interval"/> and
    <xref linkend="guc-tcp-keepalives-count"/> helps the primary promptly
    notice a broken connection.
   </para>
________________________________________________________-->
   <para>
    在支持 keepalive 套接字选项的系统上，设置<xref linkend="guc-tcp-keepalives-idle"/>、<xref linkend="guc-tcp-keepalives-interval"/>和<xref linkend="guc-tcp-keepalives-count"/>有助于主服务器迅速地注意到一个断开的连接。
   </para>
<!-- pgdoc-cn_end sig_en=0b87ce4922c3733843c6a65141ef85a0 -->

<!-- pgdoc-cn_start sig_en=3bf5052f12a2bf37063d87585ece4084 sig_cn_org=None source=14.1 
   <para>
    Set the maximum number of concurrent connections from the standby servers
    (see <xref linkend="guc-max-wal-senders"/> for details).
   </para>
________________________________________________________-->
   <para>
    设置来自后备服务器的并发连接的最大数目（详见<xref linkend="guc-max-wal-senders"/>）。
   </para>
<!-- pgdoc-cn_end sig_en=3bf5052f12a2bf37063d87585ece4084 -->

<!-- pgdoc-cn_start sig_en=17f96cf77b60b34795746b338d1af6f4 sig_cn_org=None source=14.1 
   <para>
    When the standby is started and <varname>primary_conninfo</varname> is set
    correctly, the standby will connect to the primary after replaying all
    WAL files available in the archive. If the connection is established
    successfully, you will see a <literal>walreceiver</literal> in the standby, and
    a corresponding <literal>walsender</literal> process in the primary.
   </para>
________________________________________________________-->
   <para>
    当后备服务器被启动并且<varname>primary_conninfo</varname>被正确设置，后备服务器将在重放完归档中所有可用的 WAL 文件之后连接到主服务器。
    如果连接被成功建立，你将在后备服务器中看到一个 <literal>walreceiver</literal>，并且在主服务器中有一个相应的 <literal>walsender</literal> 进程。
   </para>
<!-- pgdoc-cn_end sig_en=17f96cf77b60b34795746b338d1af6f4 -->

   <sect3 id="streaming-replication-authentication">
<!-- pgdoc-cn_start sig_en=a4156ddb5a8d3f18d3649cb58ec8c0c1 sig_cn_org=None source=14.1 
    <title>Authentication</title>
________________________________________________________-->
    <title>认证</title>
<!-- pgdoc-cn_end sig_en=a4156ddb5a8d3f18d3649cb58ec8c0c1 -->
<!-- pgdoc-cn_start sig_en=ec3e8fd339e386cf2985e090168029c0 sig_cn_org=None source=14.1 
    <para>
     It is very important that the access privileges for replication be set up
     so that only trusted users can read the WAL stream, because it is
     easy to extract privileged information from it.  Standby servers must
     authenticate to the primary as an account that has the
     <literal>REPLICATION</literal> privilege or a superuser. It is
     recommended to create a dedicated user account with
     <literal>REPLICATION</literal> and <literal>LOGIN</literal>
     privileges for replication. While <literal>REPLICATION</literal>
     privilege gives very high permissions, it does not allow the user to
     modify any data on the primary system, which the
     <literal>SUPERUSER</literal> privilege does.
    </para>
________________________________________________________-->
    <para>
     设置好用于复制的访问权限非常重要，这样只有受信的用户可以读取 WAL 流，因为很容易从 WAL 流中抽取出需要特权才能访问的信息。
     后备服务器必须作为一个具有<literal>REPLICATION</literal>特权的账户或一个超级用户来向主服务器认证。
     推荐为复制创建一个专用的具有<literal>REPLICATION</literal>和<literal>LOGIN</literal>特权的用户账户。
     虽然<literal>REPLICATION</literal>特权给出了非常高的权限，但它不允许用户修改主系统上的任何数据，而<literal>SUPERUSER</literal>特权则可以。
    </para>
<!-- pgdoc-cn_end sig_en=ec3e8fd339e386cf2985e090168029c0 -->

<!-- pgdoc-cn_start sig_en=b7c79596ad6f0051bc4fdf77cc83df8a sig_cn_org=None source=14.1 
    <para>
     Client authentication for replication is controlled by a
     <filename>pg_hba.conf</filename> record specifying <literal>replication</literal> in the
     <replaceable>database</replaceable> field. For example, if the standby is running on
     host IP <literal>192.168.1.100</literal> and the account name for replication
     is <literal>foo</literal>, the administrator can add the following line to the
     <filename>pg_hba.conf</filename> file on the primary:

<programlisting>
# Allow the user "foo" from host 192.168.1.100 to connect to the primary
# as a replication standby if the user's password is correctly supplied.
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    replication     foo             192.168.1.100/32        md5
</programlisting>
    </para>
________________________________________________________-->
    <para>
     复制的客户端认证由一个在<replaceable>database</replaceable>域中指定<literal>replication</literal>的<filename>pg_hba.conf</filename>记录控制。例如，如果后备服务器运行在主机 IP <literal>192.168.1.100</literal>并且用于复制的账户名为<literal>foo</literal>，管理员可以在主服务器上向<filename>pg_hba.conf</filename>文件增加下列行：

<programlisting>
# 允许来自 192.168.1.100 的用户 "foo" 在提供了正确的口令时作为一个
# 复制后备机连接到主控机。
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    replication     foo             192.168.1.100/32        md5
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=b7c79596ad6f0051bc4fdf77cc83df8a -->
<!-- pgdoc-cn_start sig_en=ff68dbc80946031973f10a1fb7f16790 sig_cn_org=None source=14.1 
    <para>
     The host name and port number of the primary, connection user name,
     and password are specified in the <xref linkend="guc-primary-conninfo"/>.
     The password can also be set in the <filename>~/.pgpass</filename> file on the
     standby (specify <literal>replication</literal> in the <replaceable>database</replaceable>
     field).
     For example, if the primary is running on host IP <literal>192.168.1.50</literal>,
     port <literal>5432</literal>, the account name for replication is
     <literal>foo</literal>, and the password is <literal>foopass</literal>, the administrator
     can add the following line to the <filename>postgresql.conf</filename> file on the
     standby:

<programlisting>
# The standby connects to the primary that is running on host 192.168.1.50
# and port 5432 as the user "foo" whose password is "foopass".
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'
</programlisting>
    </para>
________________________________________________________-->
    <para>
     主服务器的主机名和端口号、连接用户名和口令在<xref linkend="guc-primary-conninfo"/>中指定。在后备服务器上还可以在<filename>~/.pgpass</filename>文件中设置口令（在<replaceable>database</replaceable>域中指定<literal>replication</literal>）。例如，如果主服务器运行在主机 IP <literal>192.168.1.50</literal>、端口<literal>5432</literal>上，并且口令为<literal>foopass</literal>，管理员可以在后备服务器的<filename>postgresql.conf</filename>文件中增加下列行：

<programlisting>
# 后备机要连接到的主控机运行在主机 192.168.1.50 上，
# 端口号是 5432，连接所用的用户名是 "foo"，口令是 "foopass"。
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=ff68dbc80946031973f10a1fb7f16790 -->
   </sect3>

   <sect3 id="streaming-replication-monitoring">
<!-- pgdoc-cn_start sig_en=7f79d68fa5a8c3bc9aedb664a23056cd sig_cn_org=None source=14.1 
    <title>Monitoring</title>
________________________________________________________-->
    <title>监控</title>
<!-- pgdoc-cn_end sig_en=7f79d68fa5a8c3bc9aedb664a23056cd -->
<!-- pgdoc-cn_start sig_en=636cf89d7e0407bcf2940cece2f89f3b sig_cn_org=None source=14.1 
    <para>
     An important health indicator of streaming replication is the amount
     of WAL records generated in the primary, but not yet applied in the
     standby. You can calculate this lag by comparing the current WAL write
     location on the primary with the last WAL location received by the
     standby. These locations can be retrieved using
     <function>pg_current_wal_lsn</function> on the primary and
     <function>pg_last_wal_receive_lsn</function> on the standby,
     respectively (see <xref linkend="functions-admin-backup-table"/> and
     <xref linkend="functions-recovery-info-table"/> for details).
     The last WAL receive location in the standby is also displayed in the
     process status of the WAL receiver process, displayed using the
     <command>ps</command> command (see <xref linkend="monitoring-ps"/> for details).
    </para>
________________________________________________________-->
    <para>
     流复制的一个重要健康指标是在主服务器上产生但还没有在后备服务器上应用的 WAL 记录数。你可以通过比较主服务器上的当前 WAL 写位置和后备服务器接收到的最后一个 WAL 位置来计算这个滞后量。这些位置分别可以用主服务器上的<function>pg_current_wal_lsn</function>和后备服务器上的<function>pg_last_wal_receive_lsn</function>来检索（详见<xref linkend="functions-admin-backup-table"/>和<xref linkend="functions-recovery-info-table"/>）。后备服务器的最后 WAL 接收位置也被显示在 WAL 接收者进程的进程状态中，即使用<command>ps</command>命令显示的状态（详见<xref linkend="monitoring-ps"/>）。
    </para>
<!-- pgdoc-cn_end sig_en=636cf89d7e0407bcf2940cece2f89f3b -->
<!-- pgdoc-cn_start sig_en=32bbcbd68f91e0d359f0996d9589aaf3 sig_cn_org=None source=14.1 
    <para>
     You can retrieve a list of WAL sender processes via the
     <link linkend="monitoring-pg-stat-replication-view"><structname>
     pg_stat_replication</structname></link> view. Large differences between
     <function>pg_current_wal_lsn</function> and the view's <literal>sent_lsn</literal> field
     might indicate that the primary server is under heavy load, while
     differences between <literal>sent_lsn</literal> and
     <function>pg_last_wal_receive_lsn</function> on the standby might indicate
     network delay, or that the standby is under heavy load.
    </para>
________________________________________________________-->
    <para>
     你可以通过<link linkend="monitoring-pg-stat-replication-view"><structname>pg_stat_replication</structname></link>视图检索 WAL 发送者进程的列表。
     <function>pg_current_wal_lsn</function>与<literal>sent_lsn</literal>域之间的巨大差异表示主服务器承受着巨大的负载，而<literal>sent_lsn</literal>和后备服务器上<function>pg_last_wal_receive_lsn</function>之间的差异可能表示网络延迟或者后备服务器正承受着巨大的负载。
    </para>
<!-- pgdoc-cn_end sig_en=32bbcbd68f91e0d359f0996d9589aaf3 -->
<!-- pgdoc-cn_start sig_en=5b704bb61ea4c6f972fccaf8a3d45e55 sig_cn_org=None source=14.1 
    <para>
     On a hot standby, the status of the WAL receiver process can be retrieved
     via the <link linkend="monitoring-pg-stat-wal-receiver-view">
     <structname>pg_stat_wal_receiver</structname></link> view.  A large
     difference between <function>pg_last_wal_replay_lsn</function> and the
     view's <literal>flushed_lsn</literal> indicates that WAL is being
     received faster than it can be replayed.
    </para>
________________________________________________________-->
    <para>
     在一台热后备上，WAL接收者进程的状态可以通过<link linkend="monitoring-pg-stat-wal-receiver-view">
     <structname>pg_stat_wal_receiver</structname></link>视图检索到。
     <function>pg_last_wal_replay_lsn</function>和该视图的<literal>flushed_lsn</literal>的差别表示WAL的接收速度大于它被重放的速度。
    </para>
<!-- pgdoc-cn_end sig_en=5b704bb61ea4c6f972fccaf8a3d45e55 -->
   </sect3>
  </sect2>

  <sect2 id="streaming-replication-slots">
<!-- pgdoc-cn_start sig_en=54403e923fb60e0c6a8ac1f8e26059a4 sig_cn_org=None source=14.1 
   <title>Replication Slots</title>
________________________________________________________-->
   <title>复制槽</title>
<!-- pgdoc-cn_end sig_en=54403e923fb60e0c6a8ac1f8e26059a4 -->
<!-- pgdoc-cn_start sig_en=b86cdeec62e05efd54c3949b69bf5187 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>replication slot</primary>
    <secondary>streaming replication</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>复制槽</primary>
    <secondary>流复制</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=b86cdeec62e05efd54c3949b69bf5187 -->
<!-- pgdoc-cn_start sig_en=f0fb45a83397cf966cc96ae80f218644 sig_cn_org=None source=14.1 
   <para>
    Replication slots provide an automated way to ensure that the primary does
    not remove WAL segments until they have been received by all standbys,
    and that the primary does not remove rows which could cause a
    <link linkend="hot-standby-conflict">recovery conflict</link> even when the
    standby is disconnected.
   </para>
________________________________________________________-->
   <para>
    复制槽提供了一种自动化的方法来确保主控机在所有的后备机收到 WAL 段
    之前不会移除它们，并且主控机也不会移除可能导致<link linkend="hot-standby-conflict">
    恢复冲突</link>的行，即使后备机断开也是如此。
   </para>
<!-- pgdoc-cn_end sig_en=f0fb45a83397cf966cc96ae80f218644 -->
<!-- pgdoc-cn_start sig_en=631d819203f37b792b2bf9e6bc67f15c sig_cn_org=40959a6bba5da7d3aade38121977d607 source=15.7 
   <para>
    In lieu of using replication slots, it is possible to prevent the removal
    of old WAL segments using <xref linkend="guc-wal-keep-size"/>, or by
    storing the segments in an archive using
    <xref linkend="guc-archive-command"/> or <xref linkend="guc-archive-library"/>.
    However, these methods often result in retaining more WAL segments than
    required, whereas replication slots retain only the number of segments
    known to be needed.  On the other hand, replication slots can retain so
    many WAL segments that they fill up the space allocated
    for <literal>pg_wal</literal>;
    <xref linkend="guc-max-slot-wal-keep-size"/> limits the size of WAL files
    retained by replication slots.
   </para>
________________________________________________________-->
   <para>
    在不使用复制插槽的情况下，可以通过使用<xref linkend="guc-wal-keep-size"/>来防止删除旧的WAL段，
    或者通过将段存储在存档中使用<xref linkend="guc-archive-command"/>或<xref linkend="guc-archive-library"/>。
    然而，这些方法通常会导致保留比所需更多的WAL段，而复制插槽仅保留已知需要的段数。
    另一方面，复制插槽可能会保留太多的WAL段，导致填满为<literal>pg_wal</literal>分配的空间；
    <xref linkend="guc-max-slot-wal-keep-size"/>限制了复制插槽保留的WAL文件的大小。
</para>
<!-- pgdoc-cn_end sig_en=631d819203f37b792b2bf9e6bc67f15c -->
<!-- pgdoc-cn_start sig_en=d39e5fb200b4b26361a795afec637302 sig_cn_org=None source=14.1 
   <para>
    Similarly, <xref linkend="guc-hot-standby-feedback"/>
    and <xref linkend="guc-vacuum-defer-cleanup-age"/> provide protection against
    relevant rows being removed by vacuum, but the former provides no
    protection during any time period when the standby is not connected,
    and the latter often needs to be set to a high value to provide adequate
    protection.  Replication slots overcome these disadvantages.
   </para>
________________________________________________________-->
   <para>
    类似地，<xref linkend="guc-hot-standby-feedback"/>和
    <xref linkend="guc-vacuum-defer-cleanup-age"/>保护了相关行不被 vacuum
    移除，但是前者在后备机断开期间无法提供保护，而后者则需要被设置为一个很高
    的值已提供足够的保护。复制槽克服了这些缺点。
   </para>
<!-- pgdoc-cn_end sig_en=d39e5fb200b4b26361a795afec637302 -->
   <sect3 id="streaming-replication-slots-manipulation">
<!-- pgdoc-cn_start sig_en=43b9d26127446a3d50fb6ff7987ec326 sig_cn_org=None source=14.1 
    <title>Querying and Manipulating Replication Slots</title>
________________________________________________________-->
    <title>查询和操纵复制槽</title>
<!-- pgdoc-cn_end sig_en=43b9d26127446a3d50fb6ff7987ec326 -->
<!-- pgdoc-cn_start sig_en=8bf9530151a2c1905b8f2bbe44a5b2e9 sig_cn_org=None source=14.1 
    <para>
     Each replication slot has a name, which can contain lower-case letters,
     numbers, and the underscore character.
    </para>
________________________________________________________-->
    <para>
     每个复制槽都有一个名字，名字可以包含小写字母、数字和下划线字符。
    </para>
<!-- pgdoc-cn_end sig_en=8bf9530151a2c1905b8f2bbe44a5b2e9 -->
<!-- pgdoc-cn_start sig_en=27ed4835c40f432f527162ff5b70479b sig_cn_org=None source=14.1 
    <para>
     Existing replication slots and their state can be seen in the
     <link linkend="view-pg-replication-slots"><structname>pg_replication_slots</structname></link>
     view.
    </para>
________________________________________________________-->
    <para>
     已有的复制槽和它们的状态可以在
     <link linkend="view-pg-replication-slots"><structname>pg_replication_slots</structname></link>
     视图中看到。
    </para>
<!-- pgdoc-cn_end sig_en=27ed4835c40f432f527162ff5b70479b -->
<!-- pgdoc-cn_start sig_en=77e365977bc3c1c873370f8eee408f30 sig_cn_org=None source=14.1 
    <para>
     Slots can be created and dropped either via the streaming replication
     protocol (see <xref linkend="protocol-replication"/>) or via SQL
     functions (see <xref linkend="functions-replication"/>).
    </para>
________________________________________________________-->
    <para>
     槽可以通过流复制协议（见<xref linkend="protocol-replication"/>）
     或者 SQL 函数（见<xref linkend="functions-replication"/>）创建并且移除。
    </para>
<!-- pgdoc-cn_end sig_en=77e365977bc3c1c873370f8eee408f30 -->
   </sect3>
   <sect3 id="streaming-replication-slots-config">
<!-- pgdoc-cn_start sig_en=5dd92c17cdc9ea1b9dd7c900c50abe57 sig_cn_org=None source=14.1 
    <title>Configuration Example</title>
________________________________________________________-->
    <title>配置实例</title>
<!-- pgdoc-cn_end sig_en=5dd92c17cdc9ea1b9dd7c900c50abe57 -->
<!-- pgdoc-cn_start sig_en=a8125388d72e6984c1908791d1001adb sig_cn_org=6dd8d29ac6cff2130f99e16b2b73b08a source=15.7 
    <para>
     You can create a replication slot like this:
<programlisting>
postgres=# SELECT * FROM pg_create_physical_replication_slot('node_a_slot');
  slot_name  | lsn
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-
 node_a_slot |

postgres=# SELECT slot_name, slot_type, active FROM pg_replication_slots;
  slot_name  | slot_type | active
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;
 node_a_slot | physical  | f
(1 row)
</programlisting>
     To configure the standby to use this slot, <varname>primary_slot_name</varname>
     should be configured on the standby. Here is a simple example:
<programlisting>
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'
primary_slot_name = 'node_a_slot'
</programlisting>
    </para>
________________________________________________________-->
    <para>
     您可以像这样创建一个复制槽：
<programlisting>
postgres=# SELECT * FROM pg_create_physical_replication_slot('node_a_slot');
  slot_name  | lsn
-------------+-----
 node_a_slot |

postgres=# SELECT slot_name, slot_type, active FROM pg_replication_slots;
  slot_name  | slot_type | active
-------------+-----------+--------
 node_a_slot | physical  | f
(1 row)
</programlisting>
     要配置备用机使用这个槽，<varname>primary_slot_name</varname>
     应该在备用机上配置。这里是一个简单的示例：
<programlisting>
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'
primary_slot_name = 'node_a_slot'
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=a8125388d72e6984c1908791d1001adb -->
   </sect3>
  </sect2>

  <sect2 id="cascading-replication">
<!-- pgdoc-cn_start sig_en=708eaae035c5b7274e984b2ad43bb079 sig_cn_org=None source=14.1 
   <title>Cascading Replication</title>
________________________________________________________-->
   <title>级联复制</title>
<!-- pgdoc-cn_end sig_en=708eaae035c5b7274e984b2ad43bb079 -->

<!-- pgdoc-cn_start sig_en=350b2196ee04895cd8f54d291fbeff53 sig_cn_org=None source=14.1 
   <indexterm zone="high-availability">
    <primary>Cascading Replication</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="high-availability">
    <primary>级联复制</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=350b2196ee04895cd8f54d291fbeff53 -->

<!-- pgdoc-cn_start sig_en=c252faa6699fa93d49b493dd7f9be3fe sig_cn_org=None source=14.1 
   <para>
    The cascading replication feature allows a standby server to accept replication
    connections and stream WAL records to other standbys, acting as a relay.
    This can be used to reduce the number of direct connections to the primary
    and also to minimize inter-site bandwidth overheads.
   </para>
________________________________________________________-->
   <para>
    级联复制特性允许一台后备服务器接收复制连接并且把 WAL 记录流式传送给其他后备服务器，就像一个转发器一样。这可以被用来减小对于主控机的直接连接数并且使得站点间的带宽开销最小化。
   </para>
<!-- pgdoc-cn_end sig_en=c252faa6699fa93d49b493dd7f9be3fe -->

<!-- pgdoc-cn_start sig_en=f7ed4775baf29fc290ec4c0b09942f5f sig_cn_org=None source=14.1 
   <para>
    A standby acting as both a receiver and a sender is known as a cascading
    standby.  Standbys that are more directly connected to the primary are known
    as upstream servers, while those standby servers further away are downstream
    servers.  Cascading replication does not place limits on the number or
    arrangement of downstream servers, though each standby connects to only
    one upstream server which eventually links to a single primary server.
   </para>
________________________________________________________-->
   <para>
    一台同时扮演着接收者和发送者角色的后备服务器被称为一台级联后备服务器。“更直接”（通过更少的级联后备服务器）连接到主控机的后备服务器被称为上游服务器，而那些离得更远的后备服务器被称为下游服务器。级联复制并没有对下游服务器的数量或布置设定限制。
   </para>
<!-- pgdoc-cn_end sig_en=f7ed4775baf29fc290ec4c0b09942f5f -->

<!-- pgdoc-cn_start sig_en=c073c8a3dc5543ad957235c065eb53d1 sig_cn_org=None source=14.1 
   <para>
    A cascading standby sends not only WAL records received from the
    primary but also those restored from the archive. So even if the replication
    connection in some upstream connection is terminated, streaming replication
    continues downstream for as long as new WAL records are available.
   </para>
________________________________________________________-->
   <para>
    一台级联后备服务器不仅仅发送从主控机接收到的 WAL 记录，还要发送那些从归档中恢复的记录。因此即使某些上游连接中的复制连接被中断，只要还有新的 WAL 记录可用，下游的流复制都会继续下去。
   </para>
<!-- pgdoc-cn_end sig_en=c073c8a3dc5543ad957235c065eb53d1 -->

<!-- pgdoc-cn_start sig_en=945780f8e52ff06268182e39b0167076 sig_cn_org=None source=14.1 
   <para>
    Cascading replication is currently asynchronous. Synchronous replication
    (see <xref linkend="synchronous-replication"/>) settings have no effect on
    cascading replication at present.
   </para>
________________________________________________________-->
   <para>
    级联复制目前是异步的。同步复制（见<xref linkend="synchronous-replication"/>）设置当前对级联复制无影响。
   </para>
<!-- pgdoc-cn_end sig_en=945780f8e52ff06268182e39b0167076 -->

<!-- pgdoc-cn_start sig_en=57dc83e88b78aa21d6a7e9f7f8046f66 sig_cn_org=23928610da767098752794bac356a66b source=15.7 
   <para>
    Hot standby feedback propagates upstream, whatever the cascaded arrangement.
   </para>
________________________________________________________-->
   <para>
    热备份反馈向上传播，无论级联排列如何。
   </para>
<!-- pgdoc-cn_end sig_en=57dc83e88b78aa21d6a7e9f7f8046f66 -->

<!-- pgdoc-cn_start sig_en=7b35f72fb0c282f6e2df452e8e583568 sig_cn_org=None source=14.1 
   <para>
    If an upstream standby server is promoted to become the new primary, downstream
    servers will continue to stream from the new primary if
    <varname>recovery_target_timeline</varname> is set to <literal>'latest'</literal> (the default).
   </para>
________________________________________________________-->
   <para>
    如果一台上游后备服务器被提升为新的主控机，且下游服务器的<varname>recovery_target_timeline</varname>被设置成<literal>'latest'</literal>(默认)，下游服务器将继续从新的主控机得到流。
   </para>
<!-- pgdoc-cn_end sig_en=7b35f72fb0c282f6e2df452e8e583568 -->

<!-- pgdoc-cn_start sig_en=c059df103bb08517797afb3c1ad508b0 sig_cn_org=None source=14.1 
   <para>
    To use cascading replication, set up the cascading standby so that it can
    accept replication connections (that is, set
    <xref linkend="guc-max-wal-senders"/> and <xref linkend="guc-hot-standby"/>,
    and configure
    <link linkend="auth-pg-hba-conf">host-based authentication</link>).
    You will also need to set <varname>primary_conninfo</varname> in the downstream
    standby to point to the cascading standby.
   </para>
________________________________________________________-->
   <para>
    要使用级联复制，要建立级联后备服务器让它能够接受复制连接（即设置<xref linkend="guc-max-wal-senders"/>和<xref linkend="guc-hot-standby"/>，并且配置<link linkend="auth-pg-hba-conf">基于主机的认证</link>）。你还将需要设置下游后备服务器中的<varname>primary_conninfo</varname>指向级联后备服务器。
   </para>
<!-- pgdoc-cn_end sig_en=c059df103bb08517797afb3c1ad508b0 -->
  </sect2>

  <sect2 id="synchronous-replication">
<!-- pgdoc-cn_start sig_en=87767ff81b7f5c8cced44766ee48d1a7 sig_cn_org=None source=14.1 
   <title>Synchronous Replication</title>
________________________________________________________-->
   <title>同步复制</title>
<!-- pgdoc-cn_end sig_en=87767ff81b7f5c8cced44766ee48d1a7 -->

<!-- pgdoc-cn_start sig_en=6e032cd1b6c3f39baa6b67cec59d074b sig_cn_org=None source=14.1 
   <indexterm zone="high-availability">
    <primary>Synchronous Replication</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="high-availability">
    <primary>同步复制</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=6e032cd1b6c3f39baa6b67cec59d074b -->

<!-- pgdoc-cn_start sig_en=c496a308ab14c54b0f9074505719c417 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> streaming replication is asynchronous by
    default. If the primary server
    crashes then some transactions that were committed may not have been
    replicated to the standby server, causing data loss. The amount
    of data loss is proportional to the replication delay at the time of
    failover.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>流复制默认是异步的。如果主服务器崩溃，则某些已被提交的事务可能还没有被复制到后备服务器，这会导致数据丢失。数据的丢失量与故障转移时的复制延迟成比例。
   </para>
<!-- pgdoc-cn_end sig_en=c496a308ab14c54b0f9074505719c417 -->

<!-- pgdoc-cn_start sig_en=8b734e9ca2c54b4e9386f8d95483a9e7 sig_cn_org=None source=14.1 
   <para>
    Synchronous replication offers the ability to confirm that all changes
    made by a transaction have been transferred to one or more synchronous
    standby servers. This extends that standard level of durability
    offered by a transaction commit. This level of protection is referred
    to as 2-safe replication in computer science theory, and group-1-safe
    (group-safe and 1-safe) when <varname>synchronous_commit</varname> is set to
    <literal>remote_write</literal>.
   </para>
________________________________________________________-->
   <para>
    同步复制能够保证一个事务的所有修改都能被传送到一台或者多台同步后备服务器。这扩大了由一次事务提交所提供的标准持久化级别。在计算机科学理论中这种保护级别被称为 2-safe 复制。而当<varname>synchronous_commit</varname>被设置为<literal>remote_write</literal>时，则是 group-1-safe （group-safe 和 1-safe）。
   </para>
<!-- pgdoc-cn_end sig_en=8b734e9ca2c54b4e9386f8d95483a9e7 -->

<!-- pgdoc-cn_start sig_en=b7c32d24d04d898971396ee42b31b943 sig_cn_org=62e697bd8bb9e0a7ea36a6ebf5f6fe81 source=15.7 
   <para>
    When requesting synchronous replication, each commit of a
    write transaction will wait until confirmation is
    received that the commit has been written to the write-ahead log on disk
    of both the primary and standby server. The only possibility that data
    can be lost is if both the primary and the standby suffer crashes at the
    same time. This can provide a much higher level of durability, though only
    if the sysadmin is cautious about the placement and management of the two
    servers.  Waiting for confirmation increases the user's confidence that the
    changes will not be lost in the event of server crashes but it also
    necessarily increases the response time for the requesting transaction.
    The minimum wait time is the round-trip time between primary and standby.
   </para>
________________________________________________________-->
   <para>
    当请求同步复制时，每个写事务的提交都会等待确认，直到收到已将提交写入主服务器和备用服务器的预写式日志的确认为止。
    数据可能丢失的唯一可能性是主服务器和备用服务器同时崩溃。这可以提供更高级别的耐用性，尽管只有在系统管理员谨慎地放置和管理这两台服务器时才能实现。
    等待确认可以增加用户对在服务器崩溃时不会丢失更改的信心，但也必然会增加请求事务的响应时间。
    最短等待时间是主服务器和备用服务器之间的往返时间。
</para>
<!-- pgdoc-cn_end sig_en=b7c32d24d04d898971396ee42b31b943 -->

<!-- pgdoc-cn_start sig_en=fdc09ae89be0ab3b4ed4015903f6ec9b sig_cn_org=None source=14.1 
   <para>
    Read-only transactions and transaction rollbacks need not wait for
    replies from standby servers. Subtransaction commits do not wait for
    responses from standby servers, only top-level commits. Long
    running actions such as data loading or index building do not wait
    until the very final commit message. All two-phase commit actions
    require commit waits, including both prepare and commit.
   </para>
________________________________________________________-->
   <para>
    只读事务和事务回滚不需要等待后备服务器的回复。子事务提交也不需要等待后备服务器的响应，只有顶层提交才需要等待。长时间运行的动作（如数据载入或索引构建）不会等待最后的提交消息。所有两阶段提交动作要求提交等待，包括预备和提交。
   </para>
<!-- pgdoc-cn_end sig_en=fdc09ae89be0ab3b4ed4015903f6ec9b -->

<!-- pgdoc-cn_start sig_en=328dde2e6bed117cb25e8b464422190b sig_cn_org=None source=14.1 
   <para>
    A synchronous standby can be a physical replication standby or a logical
    replication subscriber.  It can also be any other physical or logical WAL
    replication stream consumer that knows how to send the appropriate
    feedback messages.  Besides the built-in physical and logical replication
    systems, this includes special programs such
    as <command>pg_receivewal</command> and <command>pg_recvlogical</command>
    as well as some third-party replication systems and custom programs.
    Check the respective documentation for details on synchronous replication
    support.
   </para>
________________________________________________________-->
   <para>
    同步后备可以是物理复制后备或者是逻辑复制订阅者。它还可以是任何其他物理或者逻辑WAL复制流的消费者，它懂得如何发送恰当的反馈消息。除内建的物理和逻辑复制系统之外，还包括<command>pg_receivewal</command>和<command>pg_recvlogical</command>之类的特殊程序，以及一些第三方复制系统和定制程序。同步复制支持的细节请查看相应的文档。
   </para>
<!-- pgdoc-cn_end sig_en=328dde2e6bed117cb25e8b464422190b -->

   <sect3 id="synchronous-replication-config">
<!-- pgdoc-cn_start sig_en=af65d88ccd12a1f08557c543acc1ad26 sig_cn_org=None source=14.1 
    <title>Basic Configuration</title>
________________________________________________________-->
    <title>基本配置</title>
<!-- pgdoc-cn_end sig_en=af65d88ccd12a1f08557c543acc1ad26 -->

<!-- pgdoc-cn_start sig_en=a89ec9047f9a3fa98f05dda4f41e1207 sig_cn_org=None source=14.1 
   <para>
    Once streaming replication has been configured, configuring synchronous
    replication requires only one additional configuration step:
    <xref linkend="guc-synchronous-standby-names"/> must be set to
    a non-empty value.  <varname>synchronous_commit</varname> must also be set to
    <literal>on</literal>, but since this is the default value, typically no change is
    required.  (See <xref linkend="runtime-config-wal-settings"/> and
    <xref linkend="runtime-config-replication-primary"/>.)
    This configuration will cause each commit to wait for
    confirmation that the standby has written the commit record to durable
    storage.
    <varname>synchronous_commit</varname> can be set by individual
    users, so it can be configured in the configuration file, for particular
    users or databases, or dynamically by applications, in order to control
    the durability guarantee on a per-transaction basis.
   </para>
________________________________________________________-->
   <para>
    一旦流复制已经被配置，配置同步复制就只需要一个额外的配置步骤：<xref linkend="guc-synchronous-standby-names"/>必须被设置为一个非空值。<varname>synchronous_commit</varname>也必须被设置为<literal>on</literal>，但由于这是默认值，通常不需要改变（见<xref linkend="runtime-config-wal-settings"/>和<xref linkend="runtime-config-replication-primary"/>）。这样的配置将导致每一次提交都等待确认消息，以保证后备服务器已经将提交记录写入到持久化存储中。<varname>synchronous_commit</varname>可以由个体用户设置，因此它可以在配置文件中配置、可以为特定用户或数据库配置或者由应用动态配置，这样可以在一种每事务基础上控制持久性保证。
   </para>
<!-- pgdoc-cn_end sig_en=a89ec9047f9a3fa98f05dda4f41e1207 -->

<!-- pgdoc-cn_start sig_en=440d4fc99dc266c446d6f86a80284725 sig_cn_org=None source=14.1 
   <para>
    After a commit record has been written to disk on the primary, the
    WAL record is then sent to the standby. The standby sends reply
    messages each time a new batch of WAL data is written to disk, unless
    <varname>wal_receiver_status_interval</varname> is set to zero on the standby.
    In the case that <varname>synchronous_commit</varname> is set to
    <literal>remote_apply</literal>, the standby sends reply messages when the commit
    record is replayed, making the transaction visible.
    If the standby is chosen as a synchronous standby, according to the setting
    of <varname>synchronous_standby_names</varname> on the primary, the reply
    messages from that standby will be considered along with those from other
    synchronous standbys to decide when to release transactions waiting for
    confirmation that the commit record has been received. These parameters
    allow the administrator to specify which standby servers should be
    synchronous standbys. Note that the configuration of synchronous
    replication is mainly on the primary. Named standbys must be directly
    connected to the primary; the primary knows nothing about downstream
    standby servers using cascaded replication.
   </para>
________________________________________________________-->
   <para>
    在一个提交记录已经在主服务器上被写入到磁盘后，WAL 记录接着被发送到后备服务器。每次一批新的 WAL 数据被写入到磁盘后，后备服务器会发送回复消息，除非在后备服务器上<varname>wal_receiver_status_interval</varname>被设置为零。如果<varname>synchronous_commit</varname>被设置为<literal>remote_apply</literal>，当提交记录被重放时后备服务器会发送回应消息，这会让该事务变得可见。如果根据主服务器的<varname>synchronous_standby_names</varname>设置选中该后备服务器作为一个同步后备，将会根据来自该后备服务器和其他同步后备的回应消息来决定何时释放正在等待确认提交记录被收到的事务。这些参数允许管理员指定哪些后备服务器应该是同步后备。注意同步复制的配置主要在主控机上。命名的后备服务器必须直接连接到主控机，主控机对使用级联复制的下游后备服务器一无所知。
   </para>
<!-- pgdoc-cn_end sig_en=440d4fc99dc266c446d6f86a80284725 -->

<!-- pgdoc-cn_start sig_en=aa096512f053fa66069997420fd4f6a0 sig_cn_org=None source=14.1 
   <para>
    Setting <varname>synchronous_commit</varname> to <literal>remote_write</literal> will
    cause each commit to wait for confirmation that the standby has received
    the commit record and written it out to its own operating system, but not
    for the data to be flushed to disk on the standby.  This
    setting provides a weaker guarantee of durability than <literal>on</literal>
    does: the standby could lose the data in the event of an operating system
    crash, though not a <productname>PostgreSQL</productname> crash.
    However, it's a useful setting in practice
    because it can decrease the response time for the transaction.
    Data loss could only occur if both the primary and the standby crash and
    the database of the primary gets corrupted at the same time.
   </para>
________________________________________________________-->
   <para>
    将<varname>synchronous_commit</varname>设置为<literal>remote_write</literal>将导致每次提交都等待后备服务器已经接收提交记录并将它写出到其自身所在的操作系统的确认，但并非等待数据都被刷出到后备服务器上的磁盘。这种设置提供了比<literal>on</literal>要弱一点的持久性保障：在一次操作系统崩溃事件中后备服务器可能丢失数据，尽管它不是一次<productname>PostgreSQL</productname>崩溃。不过，在实际中它是一种有用的设置，因为它可以减少事务的响应时间。只有当主服务器和后备服务器都崩溃并且主服务器的数据库同时被损坏的情况下，数据丢失才会发生。
   </para>
<!-- pgdoc-cn_end sig_en=aa096512f053fa66069997420fd4f6a0 -->

<!-- pgdoc-cn_start sig_en=7d61110320c88e360509329bf9dd97e3 sig_cn_org=None source=14.1 
   <para>
    Setting <varname>synchronous_commit</varname> to <literal>remote_apply</literal> will
    cause each commit to wait until the current synchronous standbys report
    that they have replayed the transaction, making it visible to user
    queries.  In simple cases, this allows for load balancing with causal
    consistency.
   </para>
________________________________________________________-->
   <para>
    把<varname>synchronous_commit</varname>设置为<literal>remote_apply</literal>将导致每一次提交都会等待，直到当前的同步后备服务器报告说它们已经重放了该事务，这样就会使该事务对用户查询可见。在简单的情况下，这为带有因果一致性的负载均衡留出了余地。
   </para>
<!-- pgdoc-cn_end sig_en=7d61110320c88e360509329bf9dd97e3 -->

<!-- pgdoc-cn_start sig_en=d5ee62297b6ef82506741d0c35b4a752 sig_cn_org=None source=14.1 
   <para>
    Users will stop waiting if a fast shutdown is requested.  However, as
    when using asynchronous replication, the server will not fully
    shutdown until all outstanding WAL records are transferred to the currently
    connected standby servers.
   </para>
________________________________________________________-->
   <para>
    如果请求一次快速关闭，用户将停止等待。不过，在使用异步复制时，在所有未解决的 WAL 记录被传输到当前连接的后备服务器之前，服务器将不会完全关闭。
   </para>
<!-- pgdoc-cn_end sig_en=d5ee62297b6ef82506741d0c35b4a752 -->

   </sect3>

   <sect3 id="synchronous-replication-multiple-standbys">
<!-- pgdoc-cn_start sig_en=525f53291b311b95ab78b26aa33dda0b sig_cn_org=None source=14.1 
    <title>Multiple Synchronous Standbys</title>
________________________________________________________-->
    <title>多个同步后备</title>
<!-- pgdoc-cn_end sig_en=525f53291b311b95ab78b26aa33dda0b -->

<!-- pgdoc-cn_start sig_en=886d898077ac13b73fbadf7b727270aa sig_cn_org=None source=14.1 
   <para>
    Synchronous replication supports one or more synchronous standby servers;
    transactions will wait until all the standby servers which are considered
    as synchronous confirm receipt of their data. The number of synchronous
    standbys that transactions must wait for replies from is specified in
    <varname>synchronous_standby_names</varname>. This parameter also specifies
    a list of standby names and the method (<literal>FIRST</literal> and
    <literal>ANY</literal>) to choose synchronous standbys from the listed ones.
   </para>
________________________________________________________-->
   <para>
    同步复制支持一个或者更多个同步后备服务器，事务将会等待，直到所有同步后备服务器都确认收到了它们的数据为止。事务必须等待其回复的同步后备的数量由<varname>synchronous_standby_names</varname>指定。这个参数还指定一个后备服务器名称及方法（<literal>FIRST</literal>和<literal>ANY</literal>）的列表来从列出的后备中选取同步后备。
   </para>
<!-- pgdoc-cn_end sig_en=886d898077ac13b73fbadf7b727270aa -->
<!-- pgdoc-cn_start sig_en=ae931e24b2bb801a3dff2dec91c54318 sig_cn_org=None source=14.1 
   <para>
    The method <literal>FIRST</literal> specifies a priority-based synchronous
    replication and makes transaction commits wait until their WAL records are
    replicated to the requested number of synchronous standbys chosen based on
    their priorities. The standbys whose names appear earlier in the list are
    given higher priority and will be considered as synchronous. Other standby
    servers appearing later in this list represent potential synchronous
    standbys. If any of the current synchronous standbys disconnects for
    whatever reason, it will be replaced immediately with the
    next-highest-priority standby.
   </para>
________________________________________________________-->
   <para>
    方法<literal>FIRST</literal>指定一种基于优先的同步复制并且让事务提交等待，直到它们的WAL记录被复制到基于优先级选中的所要求数量的同步后备上为止。在列表中出现较早的后备被给予较高的优先级，并且将被考虑为同步后备。其他在这个列表中位置靠后的后备服务器表示可能的同步后备。如果任何当前的同步后备由于任何原因断开连接，它将立刻被下一个最高优先级的后备所替代。
   </para>
<!-- pgdoc-cn_end sig_en=ae931e24b2bb801a3dff2dec91c54318 -->
<!-- pgdoc-cn_start sig_en=53a075f440792e300adff3775a323c46 sig_cn_org=None source=14.1 
   <para>
    An example of <varname>synchronous_standby_names</varname> for
    a priority-based multiple synchronous standbys is:
<programlisting>
synchronous_standby_names = 'FIRST 2 (s1, s2, s3)'
</programlisting>
    In this example, if four standby servers <literal>s1</literal>, <literal>s2</literal>,
    <literal>s3</literal> and <literal>s4</literal> are running, the two standbys
    <literal>s1</literal> and <literal>s2</literal> will be chosen as synchronous standbys
    because their names appear early in the list of standby names.
    <literal>s3</literal> is a potential synchronous standby and will take over
    the role of synchronous standby when either of <literal>s1</literal> or
    <literal>s2</literal> fails. <literal>s4</literal> is an asynchronous standby since
    its name is not in the list.
   </para>
________________________________________________________-->
   <para>
    基于优先的多同步后备的<varname>synchronous_standby_names</varname>示例为：
<programlisting>
synchronous_standby_names = 'FIRST 2 (s1, s2, s3)'
</programlisting>
    在这个例子中，如果有四个后备服务器<literal>s1</literal>、<literal>s2</literal>、<literal>s3</literal>和<literal>s4</literal>在运行，两个后备服务器<literal>s1</literal>和<literal>s2</literal>将被选中为同步后备，因为它们出现在后备服务器名称列表的前部。<literal>s3</literal>是一个潜在的同步后备，当<literal>s1</literal>或<literal>s2</literal>中的任何一个失效， 它就会取而代之。<literal>s4</literal>则是一个异步后备因为它的名字不在列表中。
   </para>
<!-- pgdoc-cn_end sig_en=53a075f440792e300adff3775a323c46 -->
<!-- pgdoc-cn_start sig_en=aaebdbd254dc72017a8a293a4a2b1f32 sig_cn_org=None source=14.1 
   <para>
    The method <literal>ANY</literal> specifies a quorum-based synchronous
    replication and makes transaction commits wait until their WAL records
    are replicated to <emphasis>at least</emphasis> the requested number of
    synchronous standbys in the list.
   </para>
________________________________________________________-->
   <para>
    方法<literal>ANY</literal>指定一种基于规定数量的同步复制并且让事务提交等待，直到它们的WAL记录<emphasis>至少</emphasis>被复制到列表中所要求数量的同步后备上为止。
   </para>
<!-- pgdoc-cn_end sig_en=aaebdbd254dc72017a8a293a4a2b1f32 -->
<!-- pgdoc-cn_start sig_en=dc45b16eb444f83b8de38a02f5bf3a31 sig_cn_org=None source=14.1 
   <para>
    An example of <varname>synchronous_standby_names</varname> for
    a quorum-based multiple synchronous standbys is:
<programlisting>
synchronous_standby_names = 'ANY 2 (s1, s2, s3)'
</programlisting>
    In this example, if four standby servers <literal>s1</literal>, <literal>s2</literal>,
    <literal>s3</literal> and <literal>s4</literal> are running, transaction commits will
    wait for replies from at least any two standbys of <literal>s1</literal>,
    <literal>s2</literal> and <literal>s3</literal>. <literal>s4</literal> is an asynchronous
    standby since its name is not in the list.
   </para>
________________________________________________________-->
   <para>
    <varname>synchronous_standby_names</varname>的基于规定数量的多同步后备的例子：
<programlisting>
synchronous_standby_names = 'ANY 2 (s1, s2, s3)'
</programlisting>
    在这个例子中，如果有四台后备服务器<literal>s1</literal>、<literal>s2</literal>、<literal>s3</literal>以及<literal>s4</literal>正在运行，事务提交将会等待来自至少其中任意两台后备服务器的回复。<literal>s4</literal>是一台异步后备，因为它的名字不在该列表中。
   </para>
<!-- pgdoc-cn_end sig_en=dc45b16eb444f83b8de38a02f5bf3a31 -->
<!-- pgdoc-cn_start sig_en=07144466096c42952aae9fe033ec2dd7 sig_cn_org=None source=14.1 
   <para>
    The synchronous states of standby servers can be viewed using
    the <structname>pg_stat_replication</structname> view.
   </para>
________________________________________________________-->
   <para>
    后备服务器的同步状态可以使用<structname>pg_stat_replication</structname>视图查看。
   </para>
<!-- pgdoc-cn_end sig_en=07144466096c42952aae9fe033ec2dd7 -->
   </sect3>

   <sect3 id="synchronous-replication-performance">
<!-- pgdoc-cn_start sig_en=b638f0cd783efc4ce10256877658806e sig_cn_org=None source=14.1 
    <title>Planning for Performance</title>
________________________________________________________-->
    <title>性能规划</title>
<!-- pgdoc-cn_end sig_en=b638f0cd783efc4ce10256877658806e -->

<!-- pgdoc-cn_start sig_en=31a843b037a0784df02ef9c52f9e81ff sig_cn_org=None source=14.1 
   <para>
    Synchronous replication usually requires carefully planned and placed
    standby servers to ensure applications perform acceptably. Waiting
    doesn't utilize system resources, but transaction locks continue to be
    held until the transfer is confirmed. As a result, incautious use of
    synchronous replication will reduce performance for database
    applications because of increased response times and higher contention.
   </para>
________________________________________________________-->
   <para>
    同步复制通常要求仔细地规划和放置后备服务器来保证应用能令人满意地工作。等待并不利用系统资源，但是事务锁会持续保持直到传输被确认。其结果是，不小心使用同步复制将由于响应时间增加以及较高的争用率而降低数据库应用的性能。
   </para>
<!-- pgdoc-cn_end sig_en=31a843b037a0784df02ef9c52f9e81ff -->

<!-- pgdoc-cn_start sig_en=287ee167bef6d0c6602a0929cec427be sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> allows the application developer
    to specify the durability level required via replication. This can be
    specified for the system overall, though it can also be specified for
    specific users or connections, or even individual transactions.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>允许应用开发者通过复制来指定所要求的持久性级别。这可以为整个系统指定，不过它也能够为特定的用户或连接指定，甚至还可以为单个事务指定。
   </para>
<!-- pgdoc-cn_end sig_en=287ee167bef6d0c6602a0929cec427be -->

<!-- pgdoc-cn_start sig_en=fbf4e87583346d472b20e73f3d394099 sig_cn_org=None source=14.1 
   <para>
    For example, an application workload might consist of:
    10% of changes are important customer details, while
    90% of changes are less important data that the business can more
    easily survive if it is lost, such as chat messages between users.
   </para>
________________________________________________________-->
   <para>
    例如，一个应用的载荷的组成可能是这样：10% 的改变是重要的客户详情，而 90% 的改变是不太重要的数据，即使它们丢失业务也比较容易容忍（例如用户间的聊天消息）。
   </para>
<!-- pgdoc-cn_end sig_en=fbf4e87583346d472b20e73f3d394099 -->

<!-- pgdoc-cn_start sig_en=cb0ef5b083add87931ee25503326b6b7 sig_cn_org=None source=14.1 
   <para>
    With synchronous replication options specified at the application level
    (on the primary) we can offer synchronous replication for the most
    important changes, without slowing down the bulk of the total workload.
    Application level options are an important and practical tool for allowing
    the benefits of synchronous replication for high performance applications.
   </para>
________________________________________________________-->
   <para>
    通过在应用级别（在主服务器上）指定的同步复制选项，我们可以为大部分重要的改变提供同步复制，并且不会拖慢整体的载荷。应用级别选项是使高性能应用享受同步复制的一种重要和实用的工具。
   </para>
<!-- pgdoc-cn_end sig_en=cb0ef5b083add87931ee25503326b6b7 -->

<!-- pgdoc-cn_start sig_en=91b6affb2a1952d63dd42c9f8eab8d1a sig_cn_org=None source=14.1 
   <para>
    You should consider that the network bandwidth must be higher than
    the rate of generation of WAL data.
   </para>
________________________________________________________-->
   <para>
    你应该认为网络带宽必须比 WAL 数据的产生率高。
   </para>
<!-- pgdoc-cn_end sig_en=91b6affb2a1952d63dd42c9f8eab8d1a -->

   </sect3>

   <sect3 id="synchronous-replication-ha">
<!-- pgdoc-cn_start sig_en=31a1c1aede6f0ed1cbb1861be107d041 sig_cn_org=None source=14.1 
    <title>Planning for High Availability</title>
________________________________________________________-->
    <title>高可用性规划</title>
<!-- pgdoc-cn_end sig_en=31a1c1aede6f0ed1cbb1861be107d041 -->

<!-- pgdoc-cn_start sig_en=26a3b5cd720276eafbc9362427bf3a7c sig_cn_org=ee555bc12789de8331538bc15cbba6c5 source=15.7 
   <para>
    <varname>synchronous_standby_names</varname> specifies the number and
    names of synchronous standbys that transaction commits made when
    <varname>synchronous_commit</varname> is set to <literal>on</literal>,
    <literal>remote_apply</literal> or <literal>remote_write</literal> will wait for
    responses from. Such transaction commits may never be completed
    if any one of the synchronous standbys should crash.
   </para>
________________________________________________________-->
   <para>
    <varname>synchronous_standby_names</varname>指定了在<varname>synchronous_commit</varname>设置为<literal>on</literal>、
    <literal>remote_apply</literal>或<literal>remote_write</literal>时，事务提交时等待响应的同步备用的数量和名称。
    如果任何一个同步备用发生崩溃，这样的事务提交可能永远无法完成。
</para>
<!-- pgdoc-cn_end sig_en=26a3b5cd720276eafbc9362427bf3a7c -->

<!-- pgdoc-cn_start sig_en=05d95168b1e87dbfe9834b7818f4295c sig_cn_org=None source=14.1 
   <para>
    The best solution for high availability is to ensure you keep as many
    synchronous standbys as requested. This can be achieved by naming multiple
    potential synchronous standbys using <varname>synchronous_standby_names</varname>.
   </para>
________________________________________________________-->
   <para>
    高可用的最佳方案是确保有所要求数量的同步后备。这可以通过使用<varname>synchronous_standby_names</varname>指定多个潜在后备服务器来实现。
   </para>
<!-- pgdoc-cn_end sig_en=05d95168b1e87dbfe9834b7818f4295c -->

<!-- pgdoc-cn_start sig_en=6593e31ae91b4200a7991c0807448c52 sig_cn_org=None source=14.1 
   <para>
    In a priority-based synchronous replication, the standbys whose names
    appear earlier in the list will be used as synchronous standbys.
    Standbys listed after these will take over the role of synchronous standby
    if one of current ones should fail.
   </para>
________________________________________________________-->
   <para>
    在基于优先的同步复制中，出现在该列表前部的后备服务器将被用作同步后备。后面的后备服务器将在当前同步后备服务器失效时取而代之。
   </para>
<!-- pgdoc-cn_end sig_en=6593e31ae91b4200a7991c0807448c52 -->

<!-- pgdoc-cn_start sig_en=6fc03986fe1f75d3575ea9d69c7dcf4b sig_cn_org=None source=14.1 
   <para>
    In a quorum-based synchronous replication, all the standbys appearing
    in the list will be used as candidates for synchronous standbys.
    Even if one of them should fail, the other standbys will keep performing
    the role of candidates of synchronous standby.
   </para>
________________________________________________________-->
   <para>
    在基于规定数量的同步复制中，所有出现在该列表中的后备服务器都将被用作同步后备的候选。即使其中的一个失效，其他后备仍将继续担任候选同步后备的角色。
   </para>
<!-- pgdoc-cn_end sig_en=6fc03986fe1f75d3575ea9d69c7dcf4b -->

<!-- pgdoc-cn_start sig_en=b1975c7f7f9f92408575f1096fc83c5f sig_cn_org=None source=14.1 
   <para>
    When a standby first attaches to the primary, it will not yet be properly
    synchronized. This is described as <literal>catchup</literal> mode. Once
    the lag between standby and primary reaches zero for the first time
    we move to real-time <literal>streaming</literal> state.
    The catch-up duration may be long immediately after the standby has
    been created. If the standby is shut down, then the catch-up period
    will increase according to the length of time the standby has been down.
    The standby is only able to become a synchronous standby
    once it has reached <literal>streaming</literal> state.
    This state can be viewed using
    the <structname>pg_stat_replication</structname> view.
   </para>
________________________________________________________-->
   <para>
    当一台后备服务器第一次附加到主服务器时，它将处于一种还没有正确同步的状态。这被描述为<literal>追赶</literal>模式。一旦后备服务器和主服务器之间的迟滞第一次变成零，我们就来到了实时的<literal>流式</literal>状态。在后备服务器被创建之后的很长一段时间内可能都是追赶模式。如果后备服务器被关闭，则追赶周期将被增加，增加量由后备服务器被关闭的时间长度决定。只有当后备服务器到达<literal>流式</literal>状态后，它才能成为一台同步后备。这种状态可以使用<structname>pg_stat_replication</structname>视图查看。
   </para>
<!-- pgdoc-cn_end sig_en=b1975c7f7f9f92408575f1096fc83c5f -->

<!-- pgdoc-cn_start sig_en=07c5891fcd594f021be058a3f25169f2 sig_cn_org=None source=14.1 
   <para>
    If primary restarts while commits are waiting for acknowledgment, those
    waiting transactions will be marked fully committed once the primary
    database recovers.
    There is no way to be certain that all standbys have received all
    outstanding WAL data at time of the crash of the primary. Some
    transactions may not show as committed on the standby, even though
    they show as committed on the primary. The guarantee we offer is that
    the application will not receive explicit acknowledgment of the
    successful commit of a transaction until the WAL data is known to be
    safely received by all the synchronous standbys.
   </para>
________________________________________________________-->
   <para>
    如果在提交正在等待确认时主服务器重启，那些正在等待的事务将在主数据库恢复时被标记为完全提交。没有办法确认所有后备服务器已经收到了在主服务器崩溃时所有还未处理的 WAL 数据。某些事务可能不会在后备服务器上显示为已提交，即使它们在主服务器上显示为已提交。我们提供的保证是：在 WAL 数据已经被所有后备服务器安全地收到之前，应用将不会收到一个事务成功提交的显式确认。
   </para>
<!-- pgdoc-cn_end sig_en=07c5891fcd594f021be058a3f25169f2 -->

<!-- pgdoc-cn_start sig_en=4112256e796f1efb37eb2a125538b275 sig_cn_org=None source=14.1 
   <para>
    If you really cannot keep as many synchronous standbys as requested
    then you should decrease the number of synchronous standbys that
    transaction commits must wait for responses from
    in <varname>synchronous_standby_names</varname> (or disable it) and
    reload the configuration file on the primary server.
   </para>
________________________________________________________-->
   <para>
    如果实在无法保持所要求数量的同步后备，那么应该减少<varname>synchronous_standby_names</varname>中指定的事务提交应该等待其回应的同步后备的数量（或者禁用），并且在主服务器上重载配置文件。
   </para>
<!-- pgdoc-cn_end sig_en=4112256e796f1efb37eb2a125538b275 -->

<!-- pgdoc-cn_start sig_en=cb180a687d99bc8a00b3314d05891a92 sig_cn_org=None source=14.1 
   <para>
    If the primary is isolated from remaining standby servers you should
    fail over to the best candidate of those other remaining standby servers.
   </para>
________________________________________________________-->
   <para>
    如果主服务器与剩下的后备服务器是隔离的，你应当故障转移到那些其他剩余后备服务器中的最佳候选者上。
   </para>
<!-- pgdoc-cn_end sig_en=cb180a687d99bc8a00b3314d05891a92 -->

<!-- pgdoc-cn_start sig_en=6071233698bc60e15cffd43175d93b17 sig_cn_org=f111dde19b356cddd245e920fcb04b6d source=15.7 
   <para>
    If you need to re-create a standby server while transactions are
    waiting, make sure that the commands pg_backup_start() and
    pg_backup_stop() are run in a session with
    <varname>synchronous_commit</varname> = <literal>off</literal>, otherwise those
    requests will wait forever for the standby to appear.
   </para>
________________________________________________________-->
   <para>
    如果您需要在事务等待时重新创建一个备用服务器，请确保在一个会话中运行命令
    pg_backup_start() 和 pg_backup_stop()，并且<varname>synchronous_commit</varname> = <literal>off</literal>，
    否则这些请求将永远等待备用服务器出现。
   </para>
<!-- pgdoc-cn_end sig_en=6071233698bc60e15cffd43175d93b17 -->

   </sect3>
  </sect2>

  <sect2 id="continuous-archiving-in-standby">
<!-- pgdoc-cn_start sig_en=6265f98352da8207b73d5578215fa1e8 sig_cn_org=None source=14.1 
   <title>Continuous Archiving in Standby</title>
________________________________________________________-->
   <title>在后备机上连续归档</title>
<!-- pgdoc-cn_end sig_en=6265f98352da8207b73d5578215fa1e8 -->

<!-- pgdoc-cn_start sig_en=d4d22a430a2a5d5e931fd65f64d9fb04 sig_cn_org=None source=14.1 
   <indexterm>
     <primary>continuous archiving</primary>
     <secondary>in standby</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
     <primary>continuous archiving</primary>
     <secondary>in standby</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=d4d22a430a2a5d5e931fd65f64d9fb04 -->

<!-- pgdoc-cn_start sig_en=75d0c92a866e2cf6d8fdd550ec0a08ea sig_cn_org=d7fcaa3e0bc5abbd2aae56ff94619715 source=15.7 
   <para>
     When continuous WAL archiving is used in a standby, there are two
     different scenarios: the WAL archive can be shared between the primary
     and the standby, or the standby can have its own WAL archive. When
     the standby has its own WAL archive, set <varname>archive_mode</varname>
     to <literal>always</literal>, and the standby will call the archive
     command for every WAL segment it receives, whether it's by restoring
     from the archive or by streaming replication. The shared archive can
     be handled similarly, but the <varname>archive_command</varname> or <varname>archive_library</varname> must
     test if the file being archived exists already, and if the existing file
     has identical contents. This requires more care in the
     <varname>archive_command</varname> or <varname>archive_library</varname>, as it must
     be careful to not overwrite an existing file with different contents,
     but return success if the exactly same file is archived twice. And
     all that must be done free of race conditions, if two servers attempt
     to archive the same file at the same time.
   </para>
________________________________________________________-->
   <para>
     当在备用机中使用连续的WAL归档时，有两种不同的情况：WAL归档可以在主服务器和备用服务器之间共享，或者备用服务器可以有自己的WAL归档。当备用服务器有自己的WAL归档时，将<varname>archive_mode</varname>设置为<literal>always</literal>，备用服务器将为每个接收到的WAL段调用归档命令，无论是通过从归档中恢复还是通过流复制。共享归档可以类似处理，但<varname>archive_command</varname>或<varname>archive_library</varname>必须检查正在归档的文件是否已经存在，并且如果现有文件具有相同的内容。这需要在<varname>archive_command</varname>或<varname>archive_library</varname>中更加小心，因为它必须小心地不要用不同内容覆盖现有文件，但如果完全相同的文件被归档两次，则返回成功。而且所有这些必须在没有竞争条件的情况下完成，如果两个服务器同时尝试归档同一个文件。
   </para>
<!-- pgdoc-cn_end sig_en=75d0c92a866e2cf6d8fdd550ec0a08ea -->

<!-- pgdoc-cn_start sig_en=e6890bf23b1b4c4881d2e6929857c61b sig_cn_org=None source=14.1 
   <para>
     If <varname>archive_mode</varname> is set to <literal>on</literal>, the
     archiver is not enabled during recovery or standby mode. If the standby
     server is promoted, it will start archiving after the promotion, but
     will not archive any WAL or timeline history files that
     it did not generate itself. To get a complete
     series of WAL files in the archive, you must ensure that all WAL is
     archived, before it reaches the standby. This is inherently true with
     file-based log shipping, as the standby can only restore files that
     are found in the archive, but not if streaming replication is enabled.
     When a server is not in recovery mode, there is no difference between
     <literal>on</literal> and <literal>always</literal> modes.
   </para>
________________________________________________________-->
   <para>
     如果<varname>archive_mode</varname>被设置为<literal>on</literal>，归档器在恢复或者后备模式中无法启用。
     如果后备服务器被提升，它将在被提升后开始归档，但是它将不会归档任何不是它自身产生的 WAL或时间线历史文件。
     要在归档中得到完整的一系列 WAL 文件，你必须确保所有 WAL 在到达后备机之前都被归档。
     对于基于文件的日志传输来说天然就是这样，因为后备机只能恢复在归档中找到的文件，而启用了流复制时则不是这样。
     当一台服务器不在恢复模式中时，在<literal>on</literal>和<literal>always</literal>模式之间没有差别。
   </para>
<!-- pgdoc-cn_end sig_en=e6890bf23b1b4c4881d2e6929857c61b -->
  </sect2>
  </sect1>

  <sect1 id="warm-standby-failover">
<!-- pgdoc-cn_start sig_en=02d283fa605dd39c5e211c95c0cc788b sig_cn_org=None source=14.1 
   <title>Failover</title>
________________________________________________________-->
   <title>故障转移</title>
<!-- pgdoc-cn_end sig_en=02d283fa605dd39c5e211c95c0cc788b -->

<!-- pgdoc-cn_start sig_en=f97d3fb080708e78c85cf7207c42ec9a sig_cn_org=None source=14.1 
   <para>
    If the primary server fails then the standby server should begin
    failover procedures.
   </para>
________________________________________________________-->
   <para>
    如果主服务器失效，则后备服务器应该开始故障转移过程。
   </para>
<!-- pgdoc-cn_end sig_en=f97d3fb080708e78c85cf7207c42ec9a -->

<!-- pgdoc-cn_start sig_en=af405dbd5b03f74f9264f509d983a514 sig_cn_org=None source=14.1 
   <para>
    If the standby server fails then no failover need take place. If the
    standby server can be restarted, even some time later, then the recovery
    process can also be restarted immediately, taking advantage of
    restartable recovery. If the standby server cannot be restarted, then a
    full new standby server instance should be created.
   </para>
________________________________________________________-->
   <para>
    如果后备服务器失效，则不会有故障转移发生。如果后备服务器可以被重启（即使晚一点），由于可重启恢复的优势，那么恢复处理也能被立即重启。如果后备服务器不能被重启，则一个全新的后备服务器实例应该被创建。
   </para>
<!-- pgdoc-cn_end sig_en=af405dbd5b03f74f9264f509d983a514 -->

<!-- pgdoc-cn_start sig_en=ebfe9dab283e0fc5ba1a25164d53485b sig_cn_org=None source=14.1 
   <para>
    If the primary server fails and the standby server becomes the
    new primary, and then the old primary restarts, you must have
    a mechanism for informing the old primary that it is no longer the primary. This is
    sometimes known as <acronym>STONITH</acronym> (Shoot The Other Node In The Head), which is
    necessary to avoid situations where both systems think they are the
    primary, which will lead to confusion and ultimately data loss.
   </para>
________________________________________________________-->
   <para>
    如果主服务器失效并且后备服务器成为了新的主服务器，那么接下来旧的主服务器重启后，你必须有一种机制来通知旧的主服务器不再成为主服务器。有些时候这被称为<acronym>STONITH</acronym>（Shoot The Other Node In The Head，关闭其他节点），这对于避免出现两个系统都认为它们是主服务器的情况非常必要，那种情况将导致混乱并且最终导致数据丢失。
   </para>
<!-- pgdoc-cn_end sig_en=ebfe9dab283e0fc5ba1a25164d53485b -->

<!-- pgdoc-cn_start sig_en=af4db81dcfe741e2d5b50a7c737faa30 sig_cn_org=None source=14.1 
   <para>
    Many failover systems use just two systems, the primary and the standby,
    connected by some kind of heartbeat mechanism to continually verify the
    connectivity between the two and the viability of the primary. It is
    also possible to use a third system (called a witness server) to prevent
    some cases of inappropriate failover, but the additional complexity
    might not be worthwhile unless it is set up with sufficient care and
    rigorous testing.
   </para>
________________________________________________________-->
   <para>
    很多故障转移系统仅使用两个系统，主系统和后备系统，它们由某种心跳机制连接来持续验证两者之间的连接性和主系统的可用性。也可能会使用第三个系统（称为目击者服务器）来防止某些不当故障转移的情况，但是除非非常小心地建立它并且经过了严格地测试，额外的复杂度可能会使该工作得不偿失。
   </para>
<!-- pgdoc-cn_end sig_en=af4db81dcfe741e2d5b50a7c737faa30 -->

<!-- pgdoc-cn_start sig_en=535f51582fb4e45f1f3cf67d5b64f51b sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> does not provide the system
    software required to identify a failure on the primary and notify
    the standby database server.  Many such tools exist and are well
    integrated with the operating system facilities required for
    successful failover, such as IP address migration.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>并不提供在主服务器上标识失败并且通知后备数据库服务器所需的系统软件。现在已有很多这样的工具并且很好地与成功的故障转移所需的操作系统功能整合在一起，例如 IP 地址迁移。
   </para>
<!-- pgdoc-cn_end sig_en=535f51582fb4e45f1f3cf67d5b64f51b -->

<!-- pgdoc-cn_start sig_en=a7d9bee5d9f342afc28504bfb7401100 sig_cn_org=None source=14.1 
   <para>
    Once failover to the standby occurs, there is only a
    single server in operation. This is known as a degenerate state.
    The former standby is now the primary, but the former primary is down
    and might stay down.  To return to normal operation, a standby server
    must be recreated,
    either on the former primary system when it comes up, or on a third,
    possibly new, system. The <xref linkend="app-pgrewind"/> utility can be
    used to speed up this process on large clusters.
    Once complete, the primary and standby can be
    considered to have switched roles. Some people choose to use a third
    server to provide backup for the new primary until the new standby
    server is recreated,
    though clearly this complicates the system configuration and
    operational processes.
   </para>
________________________________________________________-->
   <para>
    一旦发生到后备服务器的故障转移，就只有单一的一台服务器在操作。这被称为一种退化状态。之前的后备服务器现在是主服务器，但之前的主服务器处于关闭并且可能一直保持关闭。要回到正常的操作，一个后备服务器必须被重建，要么在之前的主系统起来时使用它重建，要么使用第三台（可能是全新的）服务器来重建。在大型集簇上，<xref linkend="app-pgrewind"/>功能可以被用来加速这个过程。一旦完成，主服务器和后备服务器可以被认为是互换了角色。某些人选择使用第三台服务器来为新的主服务器提供备份，直到新的后备服务器被重建，不过显然这会使得系统配置和操作处理更复杂。
   </para>
<!-- pgdoc-cn_end sig_en=a7d9bee5d9f342afc28504bfb7401100 -->

<!-- pgdoc-cn_start sig_en=323fc3d63741628090864e4410fc4742 sig_cn_org=None source=14.1 
   <para>
    So, switching from primary to standby server can be fast but requires
    some time to re-prepare the failover cluster. Regular switching from
    primary to standby is useful, since it allows regular downtime on
    each system for maintenance. This also serves as a test of the
    failover mechanism to ensure that it will really work when you need it.
    Written administration procedures are advised.
   </para>
________________________________________________________-->
   <para>
    因此，从主服务器切换到后备服务器可以很快，但是要求一些时间来重新准备故障转移集群。从主服务器到后备服务器的常规切换是有用的，因为它允许每个系统有常规的关闭时间来进行维护。这也可以作为一种对故障转移机制的测试，以保证在你需要它时它真地能够工作。我们推荐写一些管理过程来做这些事情。
   </para>
<!-- pgdoc-cn_end sig_en=323fc3d63741628090864e4410fc4742 -->

<!-- pgdoc-cn_start sig_en=54ba8363f70fe8d2f6d37fec3f2b619d sig_cn_org=None source=14.1 
   <para>
    To trigger failover of a log-shipping standby server, run
    <command>pg_ctl promote</command>, call <function>pg_promote()</function>,
    or create a trigger file with the file name and path specified by the
    <varname>promote_trigger_file</varname>. If you're planning to use
    <command>pg_ctl promote</command> or to call
    <function>pg_promote()</function> to fail over,
    <varname>promote_trigger_file</varname> is not required. If you're
    setting up the reporting servers that are only used to offload read-only
    queries from the primary, not for high availability purposes, you don't
    need to promote it.
   </para>
________________________________________________________-->
   <para>
    要触发一台日志传送后备服务器的故障转移，运行<command>pg_ctl promote</command>，调用 <function>pg_promote()</function>，或者创建一个触发器文件，其文件名和路径由<varname>promote_trigger_file</varname>设置指定。
    如果你正在规划使用<command>pg_ctl promote</command>或调用<function>pg_promote()</function>以进行故障转移，<varname>promote_trigger_file</varname>就不是必要的。
    如果你正在建立只用于从主服务器分流只读查询而不是高可用性目的的报告服务器，你不需要提升它。
   </para>
<!-- pgdoc-cn_end sig_en=54ba8363f70fe8d2f6d37fec3f2b619d -->
  </sect1>

 <sect1 id="hot-standby">
<!-- pgdoc-cn_start sig_en=bc56b7e30503fe54984b4ba6644a08fa sig_cn_org=None source=14.1 
  <title>Hot Standby</title>
________________________________________________________-->
  <title>热备</title>
<!-- pgdoc-cn_end sig_en=bc56b7e30503fe54984b4ba6644a08fa -->

<!-- pgdoc-cn_start sig_en=5e0225332423c07bc4fe7c853af179b3 sig_cn_org=8bd09ec1f40f733eaef3347a519057be source=15.7 
  <indexterm zone="high-availability">
   <primary>hot standby</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="high-availability">
   <primary>热备</primary>
</indexterm>
<!-- pgdoc-cn_end sig_en=5e0225332423c07bc4fe7c853af179b3 -->

<!-- pgdoc-cn_start sig_en=0a46ddf3af753e894b625ba121ce69b4 sig_cn_org=8a6b1a2bb3e40c7efafde4d281afb80e source=15.7 
   <para>
    Hot standby is the term used to describe the ability to connect to
    the server and run read-only queries while the server is in archive
    recovery or standby mode. This
    is useful both for replication purposes and for restoring a backup
    to a desired state with great precision.
    The term hot standby also refers to the ability of the server to move
    from recovery through to normal operation while users continue running
    queries and/or keep their connections open.
   </para>
________________________________________________________-->
   <para>
    热备份是用来描述在服务器处于归档恢复或待机模式时连接并运行只读查询的能力的术语。
    这对于复制目的和以极高的精度将备份恢复到所需状态都非常有用。
    术语热备份还指的是服务器能够从恢复状态转换到正常运行状态，同时用户继续运行查询和/或保持他们的连接打开的能力。
   </para>
<!-- pgdoc-cn_end sig_en=0a46ddf3af753e894b625ba121ce69b4 -->

<!-- pgdoc-cn_start sig_en=392489d91109aaaed585fcba77016ee8 sig_cn_org=None source=14.1 
   <para>
    Running queries in hot standby mode is similar to normal query operation,
    though there are several usage and administrative differences
    explained below.
   </para>
________________________________________________________-->
   <para>
    在热备模式中运行查询与正常查询操作相似，尽管如下所述存在一些用法和管理上的区别。
   </para>
<!-- pgdoc-cn_end sig_en=392489d91109aaaed585fcba77016ee8 -->

  <sect2 id="hot-standby-users">
<!-- pgdoc-cn_start sig_en=069971b79c34db045dc51141c4771712 sig_cn_org=None source=14.1 
   <title>User's Overview</title>
________________________________________________________-->
   <title>用户概览</title>
<!-- pgdoc-cn_end sig_en=069971b79c34db045dc51141c4771712 -->

<!-- pgdoc-cn_start sig_en=1090d160ca4964072e6ae59387cb1141 sig_cn_org=None source=14.1 
   <para>
    When the <xref linkend="guc-hot-standby"/> parameter is set to true on a
    standby server, it will begin accepting connections once the recovery has
    brought the system to a consistent state.  All such connections are
    strictly read-only; not even temporary tables may be written.
   </para>
________________________________________________________-->
   <para>
    当<xref linkend="guc-hot-standby"/>参数在一台后备服务器上被设置为真时，一旦恢复将系统带到一个一致的状态它将开始接受连接。所有这些连接都被限制为只读，甚至临时表都不能被写入。
   </para>
<!-- pgdoc-cn_end sig_en=1090d160ca4964072e6ae59387cb1141 -->

<!-- pgdoc-cn_start sig_en=15dffee77b84aa37f22ac4c1904e1b98 sig_cn_org=None source=14.1 
   <para>
    The data on the standby takes some time to arrive from the primary server
    so there will be a measurable delay between primary and standby. Running the
    same query nearly simultaneously on both primary and standby might therefore
    return differing results. We say that data on the standby is
    <firstterm>eventually consistent</firstterm> with the primary.  Once the
    commit record for a transaction is replayed on the standby, the changes
    made by that transaction will be visible to any new snapshots taken on
    the standby.  Snapshots may be taken at the start of each query or at the
    start of each transaction, depending on the current transaction isolation
    level.  For more details, see <xref linkend="transaction-iso"/>.
   </para>
________________________________________________________-->
   <para>
    后备服务器上的数据需要一些时间从主服务器到达后备服务器，因此在主服务器和后备服务器之间将有一段可以度量的延迟。近乎同时在主服务器和后备服务器上运行相同的查询可能因此而返回不同的结果。我们说后备服务器上的数据与主服务器是<firstterm>最终一致</firstterm>的。一旦一个事务的提交记录在后备服务器上被重播，那个事务所作的修改将对后备服务器上所有新取得的快照可见。快照可以在每个查询或每个事务的开始时取得，这取决于当前的事务隔离级别。详见<xref linkend="transaction-iso"/>。
   </para>
<!-- pgdoc-cn_end sig_en=15dffee77b84aa37f22ac4c1904e1b98 -->

<!-- pgdoc-cn_start sig_en=340a509380adbc58c5f8ecb6c26e816e sig_cn_org=None source=14.1 
   <para>
    Transactions started during hot standby may issue the following commands:

    <itemizedlist>
     <listitem>
      <para>
       Query access: <command>SELECT</command>, <command>COPY TO</command>
      </para>
     </listitem>
     <listitem>
      <para>
       Cursor commands: <command>DECLARE</command>, <command>FETCH</command>, <command>CLOSE</command>
      </para>
     </listitem>
     <listitem>
      <para>
       Settings: <command>SHOW</command>, <command>SET</command>, <command>RESET</command>
      </para>
     </listitem>
     <listitem>
      <para>
       Transaction management commands:
        <itemizedlist>
         <listitem>
          <para>
           <command>BEGIN</command>, <command>END</command>, <command>ABORT</command>, <command>START TRANSACTION</command>
          </para>
         </listitem>
         <listitem>
          <para>
           <command>SAVEPOINT</command>, <command>RELEASE</command>, <command>ROLLBACK TO SAVEPOINT</command>
          </para>
         </listitem>
         <listitem>
          <para>
           <command>EXCEPTION</command> blocks and other internal subtransactions
          </para>
         </listitem>
        </itemizedlist>
      </para>
     </listitem>
     <listitem>
      <para>
       <command>LOCK TABLE</command>, though only when explicitly in one of these modes:
       <literal>ACCESS SHARE</literal>, <literal>ROW SHARE</literal> or <literal>ROW EXCLUSIVE</literal>.
      </para>
     </listitem>
     <listitem>
      <para>
       Plans and resources: <command>PREPARE</command>, <command>EXECUTE</command>,
       <command>DEALLOCATE</command>, <command>DISCARD</command>
      </para>
     </listitem>
     <listitem>
      <para>
       Plugins and extensions: <command>LOAD</command>
      </para>
     </listitem>
     <listitem>
      <para>
       <command>UNLISTEN</command>
      </para>
     </listitem>
    </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    在热备期间开始的事务可能发出下列命令：

    <itemizedlist>
     <listitem>
      <para>
       查询访问: <command>SELECT</command>、<command>COPY TO</command>
      </para>
     </listitem>
     <listitem>
      <para>
       游标命令: <command>DECLARE</command>、<command>FETCH</command>、<command>CLOSE</command>
      </para>
     </listitem>
     <listitem>
      <para>
       设置: <command>SHOW</command>、<command>SET</command>、<command>RESET</command>
      </para>
     </listitem>
     <listitem>
      <para>
       事务管理命令:
        <itemizedlist>
         <listitem>
          <para>
           <command>BEGIN</command>、<command>END</command>、<command>ABORT</command>、<command>START TRANSACTION</command>
          </para>
         </listitem>
         <listitem>
          <para>
           <command>SAVEPOINT</command>、<command>RELEASE</command>、<command>ROLLBACK TO SAVEPOINT</command>
          </para>
         </listitem>
         <listitem>
          <para>
           <command>EXCEPTION</command>块或其他内部子事务
          </para>
         </listitem>
        </itemizedlist>
      </para>
     </listitem>
     <listitem>
      <para>
       <command>LOCK TABLE</command>，不过只在下列模式之一中明确发出：
       <literal>ACCESS SHARE</literal>、<literal>ROW SHARE</literal> 或 <literal>ROW EXCLUSIVE</literal>.
      </para>
     </listitem>
     <listitem>
      <para>
       计划和资源: <command>PREPARE</command>、<command>EXECUTE</command>、
       <command>DEALLOCATE</command>、<command>DISCARD</command>
      </para>
     </listitem>
     <listitem>
      <para>
       插件和扩展: <command>LOAD</command>
      </para>
     </listitem>
     <listitem>
      <para>
       <command>UNLISTEN</command>
      </para>
     </listitem>
    </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=340a509380adbc58c5f8ecb6c26e816e -->

<!-- pgdoc-cn_start sig_en=4d291ef89ad20032907802f0fa319937 sig_cn_org=001d8c25c3ae14e3d9eedbe1e41ecb73 source=15.7 
   <para>
    Transactions started during hot standby will never be assigned a
    transaction ID and cannot write to the system write-ahead log.
    Therefore, the following actions will produce error messages:

    <itemizedlist>
     <listitem>
      <para>
       Data Manipulation Language (DML): <command>INSERT</command>,
       <command>UPDATE</command>, <command>DELETE</command>,
       <command>MERGE</command>, <command>COPY FROM</command>,
       <command>TRUNCATE</command>.
       Note that there are no allowed actions that result in a trigger
       being executed during recovery.  This restriction applies even to
       temporary tables, because table rows cannot be read or written without
       assigning a transaction ID, which is currently not possible in a
       hot standby environment.
      </para>
     </listitem>
     <listitem>
      <para>
       Data Definition Language (DDL): <command>CREATE</command>,
       <command>DROP</command>, <command>ALTER</command>, <command>COMMENT</command>.
       This restriction applies even to temporary tables, because carrying
       out these operations would require updating the system catalog tables.
      </para>
     </listitem>
     <listitem>
      <para>
       <command>SELECT ... FOR SHARE | UPDATE</command>, because row locks cannot be
       taken without updating the underlying data files.
      </para>
     </listitem>
     <listitem>
      <para>
       Rules on <command>SELECT</command> statements that generate DML commands.
      </para>
     </listitem>
     <listitem>
      <para>
       <command>LOCK</command> that explicitly requests a mode higher than <literal>ROW EXCLUSIVE MODE</literal>.
      </para>
     </listitem>
     <listitem>
      <para>
       <command>LOCK</command> in short default form, since it requests <literal>ACCESS EXCLUSIVE MODE</literal>.
      </para>
     </listitem>
     <listitem>
      <para>
       Transaction management commands that explicitly set non-read-only state:
        <itemizedlist>
         <listitem>
          <para>
            <command>BEGIN READ WRITE</command>,
            <command>START TRANSACTION READ WRITE</command>
          </para>
         </listitem>
         <listitem>
          <para>
            <command>SET TRANSACTION READ WRITE</command>,
            <command>SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE</command>
          </para>
         </listitem>
         <listitem>
          <para>
           <command>SET transaction_read_only = off</command>
          </para>
         </listitem>
        </itemizedlist>
      </para>
     </listitem>
     <listitem>
      <para>
       Two-phase commit commands: <command>PREPARE TRANSACTION</command>,
       <command>COMMIT PREPARED</command>, <command>ROLLBACK PREPARED</command>
       because even read-only transactions need to write WAL in the
       prepare phase (the first phase of two phase commit).
      </para>
     </listitem>
     <listitem>
      <para>
       Sequence updates: <function>nextval()</function>, <function>setval()</function>
      </para>
     </listitem>
     <listitem>
      <para>
       <command>LISTEN</command>, <command>NOTIFY</command>
      </para>
     </listitem>
    </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    热备期间启动的事务将永远不会被分配事务ID，也不能写入系统的预写式日志。
    因此，以下操作将产生错误消息：

    <itemizedlist>
     <listitem>
      <para>
       数据操作语言（DML）：<command>INSERT</command>、
       <command>UPDATE</command>、<command>DELETE</command>、
       <command>MERGE</command>、<command>COPY FROM</command>、
       <command>TRUNCATE</command>。
       请注意，在恢复期间不会执行触发器的操作。即使是临时表，也适用此限制，
       因为在热备环境中，不能读取或写入表行而不分配事务ID，这是目前不可能的。
      </para>
     </listitem>
     <listitem>
      <para>
       数据定义语言（DDL）：<command>CREATE</command>、
       <command>DROP</command>、<command>ALTER</command>、<command>COMMENT</command>。
       请注意，即使是临时表，也适用此限制，因为执行这些操作将需要更新系统目录表。
      </para>
     </listitem>
     <listitem>
      <para>
       <command>SELECT ... FOR SHARE | UPDATE</command>，因为无法在不更新基础数据文件的情况下获取行锁。
      </para>
     </listitem>
     <listitem>
      <para>
       生成DML命令的<command>SELECT</command>语句的规则。
      </para>
     </listitem>
     <listitem>
      <para>
       明确请求高于<literal>ROW EXCLUSIVE MODE</literal>的模式的<command>LOCK</command>。
      </para>
     </listitem>
     <listitem>
      <para>
       简短默认形式的<command>LOCK</command>，因为它请求<literal>ACCESS EXCLUSIVE MODE</literal>。
      </para>
     </listitem>
     <listitem>
      <para>
       明确设置非只读状态的事务管理命令：
        <itemizedlist>
         <listitem>
          <para>
            <command>BEGIN READ WRITE</command>、
            <command>START TRANSACTION READ WRITE</command>
          </para>
         </listitem>
         <listitem>
          <para>
            <command>SET TRANSACTION READ WRITE</command>、
            <command>SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE</command>
          </para>
         </listitem>
         <listitem>
          <para>
           <command>SET transaction_read_only = off</command>
          </para>
         </listitem>
        </itemizedlist>
      </para>
     </listitem>
     <listitem>
      <para>
       两阶段提交命令：<command>PREPARE TRANSACTION</command>、
       <command>COMMIT PREPARED</command>、<command>ROLLBACK PREPARED</command>，
       因为即使是只读事务也需要在准备阶段（两阶段提交的第一阶段）写入WAL。
      </para>
     </listitem>
     <listitem>
      <para>
       序列更新：<function>nextval()</function>、<function>setval()</function>
      </para>
     </listitem>
     <listitem>
      <para>
       <command>LISTEN</command>、<command>NOTIFY</command>
      </para>
     </listitem>
    </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=4d291ef89ad20032907802f0fa319937 -->

<!-- pgdoc-cn_start sig_en=610f34cfde8ef2874fc9be18dd41d992 sig_cn_org=f55ae28baf4031d4592747c5c8f1a6ce source=15.7 
   <para>
    In normal operation, <quote>read-only</quote> transactions are allowed to
    use <command>LISTEN</command> and <command>NOTIFY</command>,
    so hot standby sessions operate under slightly tighter
    restrictions than ordinary read-only sessions.  It is possible that some
    of these restrictions might be loosened in a future release.
   </para>
________________________________________________________-->
   <para>
    在正常操作中，<quote>只读</quote>事务允许使用<command>LISTEN</command>和<command>NOTIFY</command>，
    因此热备份会话的操作比普通只读会话稍微受到更严格的限制。可能会在将来的版本中放宽一些这些限制。
   </para>
<!-- pgdoc-cn_end sig_en=610f34cfde8ef2874fc9be18dd41d992 -->

<!-- pgdoc-cn_start sig_en=e2d6bf0c71cb7872596889119d2393e6 sig_cn_org=None source=14.1 
   <para>
    During hot standby, the parameter <varname>transaction_read_only</varname> is always
    true and may not be changed.  But as long as no attempt is made to modify
    the database, connections during hot standby will act much like any other
    database connection.  If failover or switchover occurs, the database will
    switch to normal processing mode.  Sessions will remain connected while the
    server changes mode.  Once hot standby finishes, it will be possible to
    initiate read-write transactions (even from a session begun during
    hot standby).
   </para>
________________________________________________________-->
   <para>
    在热备期间，参数<varname>transaction_read_only</varname>总是为真并且不可以被改变。但是只要不尝试修改数据库，热备期间的连接工作起来更像其他数据库连接。如果发生故障转移或切换，该数据库将切换到正常处理模式。当服务器改变模式时会话将保持连接。一旦热备结束，它将可以发起读写事务（即使是一个在热备期间启动的会话）。
   </para>
<!-- pgdoc-cn_end sig_en=e2d6bf0c71cb7872596889119d2393e6 -->

<!-- pgdoc-cn_start sig_en=0a8f1aafcce448f5834ec687444b84e8 sig_cn_org=None source=14.1 
   <para>
    Users can determine whether hot standby is currently active for their
    session by issuing <command>SHOW in_hot_standby</command>.
    (In server versions before 14, the <varname>in_hot_standby</varname>
    parameter did not exist; a workable substitute method for older servers
    is <command>SHOW transaction_read_only</command>.)  In addition, a set of
    functions (<xref linkend="functions-recovery-info-table"/>) allow users to
    access information about the standby server. These allow you to write
    programs that are aware of the current state of the database. These
    can be used to monitor the progress of recovery, or to allow you to
    write complex programs that restore the database to particular states.
   </para>
________________________________________________________-->
   <para>
    用户可以通过<command>SHOW in_hot_standby</command>来检查hot standby会话是否是活跃的 (在服务器版本 14 之前该参数<varname>in_hot_standby</varname>不存在。对于更早版本的服务器，可行的替代方法是 <command>SHOW transaction_read_only</command>。)  此外， 还有一些函数
     (<xref linkend="functions-recovery-info-table"/>) 允许用户访问有关备用服务器的信息。 它们允许您编写程序来识别数据库当前的状态。用于监控恢复进度， 或者您可以编写复杂的程序将数据库恢复到特定状态。
   </para>
<!-- pgdoc-cn_end sig_en=0a8f1aafcce448f5834ec687444b84e8 -->
  </sect2>

  <sect2 id="hot-standby-conflict">
<!-- pgdoc-cn_start sig_en=b27a82e13b86a6b7d8832feb3a07118a sig_cn_org=None source=14.1 
   <title>Handling Query Conflicts</title>
________________________________________________________-->
   <title>处理查询冲突</title>
<!-- pgdoc-cn_end sig_en=b27a82e13b86a6b7d8832feb3a07118a -->

<!-- pgdoc-cn_start sig_en=063e7b49ceb58c172fdaa99efce3a3a6 sig_cn_org=None source=14.1 
   <para>
    The primary and standby servers are in many ways loosely connected. Actions
    on the primary will have an effect on the standby. As a result, there is
    potential for negative interactions or conflicts between them. The easiest
    conflict to understand is performance: if a huge data load is taking place
    on the primary then this will generate a similar stream of WAL records on the
    standby, so standby queries may contend for system resources, such as I/O.
   </para>
________________________________________________________-->
   <para>
    主服务器和后备服务器在多方面都松散地连接在一起。主服务器上的动作将在后备服务器上产生效果。结果是在它们之间有潜在的负作用或冲突。最容易理解的冲突是性能：如果在主服务器上发生一次大数据量的载入，那么着将在后备服务器上产生一个相似的 WAL 记录流，因而后备服务器查询可能要竞争系统资源（例如 I/O）。
   </para>
<!-- pgdoc-cn_end sig_en=063e7b49ceb58c172fdaa99efce3a3a6 -->

<!-- pgdoc-cn_start sig_en=b62b801a4d05f0f5895aad5c0de48e64 sig_cn_org=cc675bc348cd865ba5e9451262625ccc source=15.7 
   <para>
    There are also additional types of conflict that can occur with hot standby.
    These conflicts are <emphasis>hard conflicts</emphasis> in the sense that queries
    might need to be canceled and, in some cases, sessions disconnected to resolve them.
    The user is provided with several ways to handle these
    conflicts. Conflict cases include:

      <itemizedlist>
       <listitem>
        <para>
         Access Exclusive locks taken on the primary server, including both
         explicit <command>LOCK</command> commands and various <acronym>DDL</acronym>
         actions, conflict with table accesses in standby queries.
        </para>
       </listitem>
       <listitem>
        <para>
         Dropping a tablespace on the primary conflicts with standby queries
         using that tablespace for temporary work files.
        </para>
       </listitem>
       <listitem>
        <para>
         Dropping a database on the primary conflicts with sessions connected
         to that database on the standby.
        </para>
       </listitem>
       <listitem>
        <para>
         Application of a vacuum cleanup record from WAL conflicts with
         standby transactions whose snapshots can still <quote>see</quote> any of
         the rows to be removed.
        </para>
       </listitem>
       <listitem>
        <para>
         Application of a vacuum cleanup record from WAL conflicts with
         queries accessing the target page on the standby, whether or not
         the data to be removed is visible.
        </para>
       </listitem>
      </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    还有其他类型的冲突可能发生在热备份中。这些冲突是<emphasis>硬冲突</emphasis>，因为查询可能需要取消，
    在某些情况下，会断开会话以解决这些冲突。用户提供了几种处理这些冲突的方法。冲突案例包括：

      <itemizedlist>
       <listitem>
        <para>
         在主服务器上获取Access Exclusive锁，包括显式的<command>LOCK</command>命令和各种<acronym>DDL</acronym>
         操作，与备用查询中的表访问发生冲突。
        </para>
       </listitem>
       <listitem>
        <para>
         在主服务器上删除表空间与备用查询使用该表空间进行临时工作文件发生冲突。
        </para>
       </listitem>
       <listitem>
        <para>
         在主服务器上删除数据库与在备用服务器上连接到该数据库的会话发生冲突。
        </para>
       </listitem>
       <listitem>
        <para>
         从WAL应用清理记录与仍然可以<quote>看到</quote>要删除的任何行的备用事务发生冲突。
        </para>
       </listitem>
       <listitem>
        <para>
         从WAL应用清理记录与在备用服务器上访问目标页面的查询发生冲突，无论要删除的数据是否可见。
        </para>
       </listitem>
      </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=b62b801a4d05f0f5895aad5c0de48e64 -->

<!-- pgdoc-cn_start sig_en=90da079eeb096d11db30ceeb32432ee0 sig_cn_org=None source=14.1 
   <para>
    On the primary server, these cases simply result in waiting; and the
    user might choose to cancel either of the conflicting actions.  However,
    on the standby there is no choice: the WAL-logged action already occurred
    on the primary so the standby must not fail to apply it.  Furthermore,
    allowing WAL application to wait indefinitely may be very undesirable,
    because the standby's state will become increasingly far behind the
    primary's.  Therefore, a mechanism is provided to forcibly cancel standby
    queries that conflict with to-be-applied WAL records.
   </para>
________________________________________________________-->
   <para>
    在主服务器上，这些情况仅仅会导致等待；并且用户可以选择取消这些冲突动作中间的一个。但是，在后备服务器上则没有选择：已被 WAL 记录的动作已经在主服务器上发生，那么后备服务器不能在应用它时失败。此外，允许 WAL 应用无限等待是非常不可取的，因为后备服务器的状态将变得逐渐远远落后于主服务器的状态。因此，提供了一种机制来强制性地取消与要被应用的 WAL 记录冲突的后备查询。
   </para>
<!-- pgdoc-cn_end sig_en=90da079eeb096d11db30ceeb32432ee0 -->

<!-- pgdoc-cn_start sig_en=8f7a464eae3f2890809d8855de968751 sig_cn_org=None source=14.1 
   <para>
    An example of the problem situation is an administrator on the primary
    server running <command>DROP TABLE</command> on a table that is currently being
    queried on the standby server.  Clearly the standby query cannot continue
    if the <command>DROP TABLE</command> is applied on the standby. If this situation
    occurred on the primary, the <command>DROP TABLE</command> would wait until the
    other query had finished. But when <command>DROP TABLE</command> is run on the
    primary, the primary doesn't have information about what queries are
    running on the standby, so it will not wait for any such standby
    queries. The WAL change records come through to the standby while the
    standby query is still running, causing a conflict.  The standby server
    must either delay application of the WAL records (and everything after
    them, too) or else cancel the conflicting query so that the <command>DROP
    TABLE</command> can be applied.
   </para>
________________________________________________________-->
   <para>
    该问题情形的一个例子是主服务器上的一位管理员在一个表上运行<command>DROP TABLE</command>，而该表正在后备服务器上被查询。如果<command>DROP TABLE</command>被应用在后备服务器上，很明显该后备查询不能继续。如果这种情况在主服务器上发生，<command>DROP TABLE</command>将等待直到其他查询结束。但是当<command>DROP TABLE</command>被运行在主服务器上，主服务器没有关于运行在后备服务器上查询的信息，因此它将不会等待任何这样的后备查询。WAL 改变记录在后备查询还在运行时来到后备服务器上，导致一个冲突。后备服务器必须要么延迟 WAL 记录的应用（还有它们之后的任何事情），要么取消冲突查询这样<command>DROP TABLE</command>可以被应用。
   </para>
<!-- pgdoc-cn_end sig_en=8f7a464eae3f2890809d8855de968751 -->

<!-- pgdoc-cn_start sig_en=2c57437e378de66e417cd59ce9a0810c sig_cn_org=None source=14.1 
   <para>
    When a conflicting query is short, it's typically desirable to allow it to
    complete by delaying WAL application for a little bit; but a long delay in
    WAL application is usually not desirable.  So the cancel mechanism has
    parameters, <xref linkend="guc-max-standby-archive-delay"/> and <xref
    linkend="guc-max-standby-streaming-delay"/>, that define the maximum
    allowed delay in WAL application.  Conflicting queries will be canceled
    once it has taken longer than the relevant delay setting to apply any
    newly-received WAL data.  There are two parameters so that different delay
    values can be specified for the case of reading WAL data from an archive
    (i.e., initial recovery from a base backup or <quote>catching up</quote> a
    standby server that has fallen far behind) versus reading WAL data via
    streaming replication.
   </para>
________________________________________________________-->
   <para>
    当一个冲突查询很短时，我们通常期望能延迟 WAL 应用一小会儿让它完成；但是在 WAL 应用中的一段长的延迟通常是不受欢迎的。因此取消机制有参数，<xref linkend="guc-max-standby-archive-delay"/>和<xref linkend="guc-max-standby-streaming-delay"/>，它们定义了在 WAL 应用中的最大允许延迟。当应用任何新收到的 WAL 数据花费了超过相关延迟设置值时，冲突查询将被取消。设立两个参数是为了对从一个归档读取 WAL 数据（即来自一个基础备份的初始恢复或者<quote>追赶</quote>一个已经落后很远的后备服务器）和通过流复制读取 WAL数据的两种情况指定不同的延迟值。
   </para>
<!-- pgdoc-cn_end sig_en=2c57437e378de66e417cd59ce9a0810c -->

<!-- pgdoc-cn_start sig_en=d1edb95de9a5a32d05684605ff541038 sig_cn_org=None source=14.1 
   <para>
    In a standby server that exists primarily for high availability, it's
    best to set the delay parameters relatively short, so that the server
    cannot fall far behind the primary due to delays caused by standby
    queries.  However, if the standby server is meant for executing
    long-running queries, then a high or even infinite delay value may be
    preferable.  Keep in mind however that a long-running query could
    cause other sessions on the standby server to not see recent changes
    on the primary, if it delays application of WAL records.
   </para>
________________________________________________________-->
   <para>
    在一台后备服务器上这主要是为了该可用性而存在，最好把延迟参数设置得比较短，这样服务器不会由于后备查询导致的延迟落后主服务器太远。但是，如果该后备服务器是位了执行长时间运行的查询，则一个较高甚至无限的延迟值更好。但是记住一个长时间运行的查询延迟了 WAL 记录的应用，它可能导致后备服务器上的其他会话无法看到主服务器上最近的改变。
   </para>
<!-- pgdoc-cn_end sig_en=d1edb95de9a5a32d05684605ff541038 -->

<!-- pgdoc-cn_start sig_en=51db6fe4841675fa0f95a58e918e19ab sig_cn_org=None source=14.1 
   <para>
    Once the delay specified by <varname>max_standby_archive_delay</varname> or
    <varname>max_standby_streaming_delay</varname> has been exceeded, conflicting
    queries will be canceled.  This usually results just in a cancellation
    error, although in the case of replaying a <command>DROP DATABASE</command>
    the entire conflicting session will be terminated.  Also, if the conflict
    is over a lock held by an idle transaction, the conflicting session is
    terminated (this behavior might change in the future).
   </para>
________________________________________________________-->
   <para>
    一旦<varname>max_standby_archive_delay</varname>或<varname>max_standby_streaming_delay</varname>指定的延迟被超越，冲突查询将被取消。这通常仅导致一个取消错误，尽管在重放一个<command>DROP DATABASE</command>的情况下整个冲突会话都将被中断。另外，如果冲突发生在一个被空闲事务持有的锁上，该冲突会话会被中断（这种行为可能在未来被改变）。
   </para>
<!-- pgdoc-cn_end sig_en=51db6fe4841675fa0f95a58e918e19ab -->

<!-- pgdoc-cn_start sig_en=c1476e2ced64846ea7b3c9aed9e84c62 sig_cn_org=None source=14.1 
   <para>
    Canceled queries may be retried immediately (after beginning a new
    transaction, of course).  Since query cancellation depends on
    the nature of the WAL records being replayed, a query that was
    canceled may well succeed if it is executed again.
   </para>
________________________________________________________-->
   <para>
    被取消的查询可能会立即被重试（当然是在开始一个新的事务后）。因为查询取消依赖于 WAL 记录被重放的本质，如果一个被取消的查询被再次执行，它可能会很好地成功完成。
   </para>
<!-- pgdoc-cn_end sig_en=c1476e2ced64846ea7b3c9aed9e84c62 -->

<!-- pgdoc-cn_start sig_en=ced32b420d5318550643a52a891d0f9f sig_cn_org=None source=14.1 
   <para>
    Keep in mind that the delay parameters are compared to the elapsed time
    since the WAL data was received by the standby server.  Thus, the grace
    period allowed to any one query on the standby is never more than the
    delay parameter, and could be considerably less if the standby has already
    fallen behind as a result of waiting for previous queries to complete, or
    as a result of being unable to keep up with a heavy update load.
   </para>
________________________________________________________-->
   <para>
    记住延迟参数是从 WAL 数据被后备服务器收到后流逝的时间。因此，留给后备服务器上任何一个查询的宽限期从不会超过延迟参数，并且如果后备服务器已经由于等待之前的查询完成而落后或者因为过重的更新负载而无法跟上主服务器，宽限期可能会更少。
   </para>
<!-- pgdoc-cn_end sig_en=ced32b420d5318550643a52a891d0f9f -->

<!-- pgdoc-cn_start sig_en=e8f2b3aef415d40359989bbae749a491 sig_cn_org=None source=14.1 
   <para>
    The most common reason for conflict between standby queries and WAL replay
    is <quote>early cleanup</quote>.  Normally, <productname>PostgreSQL</productname> allows
    cleanup of old row versions when there are no transactions that need to
    see them to ensure correct visibility of data according to MVCC rules.
    However, this rule can only be applied for transactions executing on the
    primary.  So it is possible that cleanup on the primary will remove row
    versions that are still visible to a transaction on the standby.
   </para>
________________________________________________________-->
   <para>
    在后备查询和 WAL 重播之间发生冲突的最常见原因是<quote>过早清除</quote>。正常地，<productname>PostgreSQL</productname>允许在没有事务需要看到旧行版本时对它们进行清除，这样可以保证根据 MVCC 规则的正确的数据可见性。不过，这个规则只能被应用于执行在主控机上的事务。因此有可能主控机上的清除会移除对一个后备服务器事务还可见的行版本。
   </para>
<!-- pgdoc-cn_end sig_en=e8f2b3aef415d40359989bbae749a491 -->

<!-- pgdoc-cn_start sig_en=3bed88d58f07d20525e2a520b781bdc1 sig_cn_org=None source=14.1 
   <para>
    Experienced users should note that both row version cleanup and row version
    freezing will potentially conflict with standby queries. Running a manual
    <command>VACUUM FREEZE</command> is likely to cause conflicts even on tables with
    no updated or deleted rows.
   </para>
________________________________________________________-->
   <para>
    有经验的用户应当注意行版本清除和行版本冻结都可能与后备查询冲突。即便在一个没有被更新或被删除行的表上运行一次手工<command>VACUUM FREEZE</command>也可能导致冲突。
   </para>
<!-- pgdoc-cn_end sig_en=3bed88d58f07d20525e2a520b781bdc1 -->

<!-- pgdoc-cn_start sig_en=4001d62c1e3d5e99087ef3e4f765c45b sig_cn_org=None source=14.1 
   <para>
    Users should be clear that tables that are regularly and heavily updated
    on the primary server will quickly cause cancellation of longer running
    queries on the standby. In such cases the setting of a finite value for
    <varname>max_standby_archive_delay</varname> or
    <varname>max_standby_streaming_delay</varname> can be considered similar to
    setting <varname>statement_timeout</varname>.
   </para>
________________________________________________________-->
   <para>
    用户应当清楚，主服务器上被正常和重度更新的表将快速地导致后备服务器上长时间运行的查询被取消。在这样的情况下，<varname>max_standby_archive_delay</varname>或<varname>max_standby_streaming_delay</varname>的有限制设置可以被视作<varname>statement_timeout</varname>设置。
   </para>
<!-- pgdoc-cn_end sig_en=4001d62c1e3d5e99087ef3e4f765c45b -->

<!-- pgdoc-cn_start sig_en=a026c5938f40967a5897c28108e63c75 sig_cn_org=None source=14.1 
   <para>
    Remedial possibilities exist if the number of standby-query cancellations
    is found to be unacceptable.  The first option is to set the parameter
    <varname>hot_standby_feedback</varname>, which prevents <command>VACUUM</command> from
    removing recently-dead rows and so cleanup conflicts do not occur.
    If you do this, you
    should note that this will delay cleanup of dead rows on the primary,
    which may result in undesirable table bloat. However, the cleanup
    situation will be no worse than if the standby queries were running
    directly on the primary server, and you are still getting the benefit of
    off-loading execution onto the standby.
    If standby servers connect and disconnect frequently, you
    might want to make adjustments to handle the period when
    <varname>hot_standby_feedback</varname> feedback is not being provided.
    For example, consider increasing <varname>max_standby_archive_delay</varname>
    so that queries are not rapidly canceled by conflicts in WAL archive
    files during disconnected periods.  You should also consider increasing
    <varname>max_standby_streaming_delay</varname> to avoid rapid cancellations
    by newly-arrived streaming WAL entries after reconnection.
   </para>
________________________________________________________-->
   <para>
    如果发现后备查询取消的数量不可接受，还是有补救的可能。第一种选项是设置参数
    <varname>hot_standby_feedback</varname>，它阻止<command>VACUUM</command>
    移除最近死亡的元组并且因此清除冲突不会产生。如果你这样做，你应当
    注意这将使主服务器上的死亡元组清除被延迟，这可能会导致不希望发生
    的表膨胀。不过，清除的情况不会比在主服务器上直接运行后备查询时更糟，
    并且你仍然能够享受将执行分流到后备服务器的好处。如果后备服务器频繁地连接和
    断开，你可能想要做些调整来处理无法提供<varname>hot_standby_feedback</varname>
    反馈的时期。例如，考虑增加<varname>max_standby_archive_delay</varname>，这样
    在断开连接的期间查询就不会快速地被 WAL 归档文件中的冲突取消。你也应该考虑
    增加<varname>max_standby_streaming_delay</varname>来避免重新连接后新到达的流
    WAL 项导致的快速取消。
   </para>
<!-- pgdoc-cn_end sig_en=a026c5938f40967a5897c28108e63c75 -->

<!-- pgdoc-cn_start sig_en=bc789450af7af45141e32defc575172f sig_cn_org=None source=14.1 
   <para>
    Another option is to increase <xref linkend="guc-vacuum-defer-cleanup-age"/>
    on the primary server, so that dead rows will not be cleaned up as quickly
    as they normally would be.  This will allow more time for queries to
    execute before they are canceled on the standby, without having to set
    a high <varname>max_standby_streaming_delay</varname>.  However it is
    difficult to guarantee any specific execution-time window with this
    approach, since <varname>vacuum_defer_cleanup_age</varname> is measured in
    transactions executed on the primary server.
   </para>
________________________________________________________-->
   <para>
    另一个选项是增加主服务器上的<xref linkend="guc-vacuum-defer-cleanup-age"/>，这样死亡行不会像平常那么快地被清理。这将允许在后备服务器上的查询能在被取消前有更多时间执行，并且不需要设置一个很高的<varname>max_standby_streaming_delay</varname>。但是，这种方法很难保证任何指定的执行时间窗口，因为<varname>vacuum_defer_cleanup_age</varname>是用主服务器上被执行的事务数来衡量的。
   </para>
<!-- pgdoc-cn_end sig_en=bc789450af7af45141e32defc575172f -->

<!-- pgdoc-cn_start sig_en=ba14c7061afe59e33d3899b5a43bc7bc sig_cn_org=None source=14.1 
   <para>
    The number of query cancels and the reason for them can be viewed using
    the <structname>pg_stat_database_conflicts</structname> system view on the standby
    server. The <structname>pg_stat_database</structname> system view also contains
    summary information.
   </para>
________________________________________________________-->
   <para>
    查询取消的数量和原因可以使用后备服务器上的<structname>pg_stat_database_conflicts</structname>系统视图查看。<structname>pg_stat_database</structname>系统视图也包含汇总信息。
   </para>
<!-- pgdoc-cn_end sig_en=ba14c7061afe59e33d3899b5a43bc7bc -->

<!-- pgdoc-cn_start sig_en=051402b5d2d53f0a7f7d92f39843c5ed sig_cn_org=None source=14.1 
   <para>
    Users can control whether a log message is produced when WAL replay is waiting
    longer than <varname>deadlock_timeout</varname> for conflicts. This
    is controlled by the <xref linkend="guc-log-recovery-conflict-waits"/> parameter.
   </para>
________________________________________________________-->
   <para>
    当 WAL 重放由于冲突而需要比<varname>deadlock_timeout</varname>更长时间时，用户可以控制是否打印日志消息。由参数 <xref linkend="guc-log-recovery-conflict-waits"/> 控制。
   </para>
<!-- pgdoc-cn_end sig_en=051402b5d2d53f0a7f7d92f39843c5ed -->
  </sect2>

  <sect2 id="hot-standby-admin">
<!-- pgdoc-cn_start sig_en=7281e8fa922fccd0692f371799f8fb5e sig_cn_org=None source=14.1 
   <title>Administrator's Overview</title>
________________________________________________________-->
   <title>管理员概览</title>
<!-- pgdoc-cn_end sig_en=7281e8fa922fccd0692f371799f8fb5e -->

<!-- pgdoc-cn_start sig_en=286d564ec1e2361fa6e3f40b96ab7194 sig_cn_org=c813cac92d671a97efb5fdfb85903827 source=15.7 
   <para>
    If <varname>hot_standby</varname> is <literal>on</literal> in <filename>postgresql.conf</filename>
    (the default value) and there is a
    <link linkend="file-standby-signal"><filename>standby.signal</filename></link><indexterm><primary>standby.signal</primary><secondary>for hot standby</secondary></indexterm>
    file present, the server will run in hot standby mode.
    However, it may take some time for hot standby connections to be allowed,
    because the server will not accept connections until it has completed
    sufficient recovery to provide a consistent state against which queries
    can run.  During this period,
    clients that attempt to connect will be refused with an error message.
    To confirm the server has come up, either loop trying to connect from
    the application, or look for these messages in the server logs:

<programlisting>
LOG:  entering standby mode

... then some time later ...

LOG:  consistent recovery state reached
LOG:  database system is ready to accept read-only connections
</programlisting>

    Consistency information is recorded once per checkpoint on the primary.
    It is not possible to enable hot standby when reading WAL
    written during a period when <varname>wal_level</varname> was not set to
    <literal>replica</literal> or <literal>logical</literal> on the primary.  Reaching
    a consistent state can also be delayed in the presence of both of these
    conditions:

      <itemizedlist>
       <listitem>
        <para>
         A write transaction has more than 64 subtransactions
        </para>
       </listitem>
       <listitem>
        <para>
         Very long-lived write transactions
        </para>
       </listitem>
      </itemizedlist>

    If you are running file-based log shipping ("warm standby"), you might need
    to wait until the next WAL file arrives, which could be as long as the
    <varname>archive_timeout</varname> setting on the primary.
   </para>
________________________________________________________-->
   <para>
    如果<varname>hot_standby</varname>在<filename>postgresql.conf</filename>中设置为<literal>on</literal>
    （默认值），并且存在一个<link linkend="file-standby-signal"><filename>standby.signal</filename></link>
    <indexterm><primary>standby.signal</primary><secondary>用于热备</secondary></indexterm>
    文件，则服务器将以热备模式运行。
    但是，热备连接可能需要一些时间才能被允许，
    因为服务器在提供一致状态以供查询运行之前不会接受连接。
    在此期间，试图连接的客户端将被拒绝并显示错误消息。
    要确认服务器已启动，请从应用程序中循环尝试连接，或在服务器日志中查找以下消息：

<programlisting>
LOG:  entering standby mode

... 然后一段时间后 ...

LOG:  consistent recovery state reached
LOG:  database system is ready to accept read-only connections
</programlisting>

    一致性信息每次在主服务器上的检查点时记录一次。
    当在主服务器上设置<varname>wal_level</varname>为<literal>replica</literal>或<literal>logical</literal>时，
    不可能在读取期间启用热备。在以下条件同时存在时，达到一致状态也可能会延迟：

      <itemizedlist>
       <listitem>
        <para>
         写事务具有超过64个子事务
        </para>
       </listitem>
       <listitem>
        <para>
         非常长寿的写事务
        </para>
       </listitem>
      </itemizedlist>

    如果您正在运行基于文件的日志传送（“温备”），您可能需要等待下一个WAL文件到达，
    这可能与主服务器上的<varname>archive_timeout</varname>设置一样长。
   </para>
<!-- pgdoc-cn_end sig_en=286d564ec1e2361fa6e3f40b96ab7194 -->

<!-- pgdoc-cn_start sig_en=34c6ea4e362ac5a9ead49492b6488afe sig_cn_org=None source=14.1 
   <para>
    The settings of some parameters determine the size of shared memory for
    tracking transaction IDs, locks, and prepared transactions.  These shared
    memory structures must be no smaller on a standby than on the primary in
    order to ensure that the standby does not run out of shared memory during
    recovery.  For example, if the primary had used a prepared transaction but
    the standby had not allocated any shared memory for tracking prepared
    transactions, then recovery could not continue until the standby's
    configuration is changed.  The parameters affected are:

      <itemizedlist>
       <listitem>
        <para>
         <varname>max_connections</varname>
        </para>
       </listitem>
       <listitem>
        <para>
         <varname>max_prepared_transactions</varname>
        </para>
       </listitem>
       <listitem>
        <para>
         <varname>max_locks_per_transaction</varname>
        </para>
       </listitem>
       <listitem>
        <para>
         <varname>max_wal_senders</varname>
        </para>
       </listitem>
       <listitem>
        <para>
         <varname>max_worker_processes</varname>
        </para>
       </listitem>
      </itemizedlist>

    The easiest way to ensure this does not become a problem is to have these
    parameters set on the standbys to values equal to or greater than on the
    primary.  Therefore, if you want to increase these values, you should do
    so on all standby servers first, before applying the changes to the
    primary server.  Conversely, if you want to decrease these values, you
    should do so on the primary server first, before applying the changes to
    all standby servers.  Keep in mind that when a standby is promoted, it
    becomes the new reference for the required parameter settings for the
    standbys that follow it.  Therefore, to avoid this becoming a problem
    during a switchover or failover, it is recommended to keep these settings
    the same on all standby servers.
   </para>
________________________________________________________-->
   <para>
    设置几个参数可确定用于跟踪事务ID、锁和预备事务的共享内存大小。备用服务器上的设置必须大于或等于主服务器上的设置，以确保在恢复过程中不会耗尽共享内存。例如，如果主数据库正在执行预备事务，而备用数据库没有获取共享内存来跟踪预备事务，则备用数据库将无法继续恢复，直到配置更改。受影响的参数是：
      <itemizedlist>
       <listitem>
        <para>
         <varname>max_connections</varname>
        </para>
       </listitem>
       <listitem>
        <para>
         <varname>max_prepared_transactions</varname>
        </para>
       </listitem>
       <listitem>
        <para>
         <varname>max_locks_per_transaction</varname>
        </para>
       </listitem>
       <listitem>
        <para>
         <varname>max_wal_senders</varname>
        </para>
       </listitem>
       <listitem>
        <para>
         <varname>max_worker_processes</varname>
        </para>
       </listitem>
      </itemizedlist>
    确保这不是问题的可靠方法是使备用数据库上的这些参数的值等于或大于主数据库上的值。因此，如果您想增加这些值，您应该先更改备用服务器上的设置，然后再更改主服务器上的设置。相反，如果要减小这些值，则应先更改主服务器上的设置，然后再更改备用服务器上的设置。请记住，当一个备用数据库被提升时，它会成为后续备用数据库所需参数设置的新基准。因此，最好在所有备用服务器上保持这些设置相同，这样在切换/故障转移期间就不会出现问题。
   </para>
<!-- pgdoc-cn_end sig_en=34c6ea4e362ac5a9ead49492b6488afe -->

<!-- pgdoc-cn_start sig_en=605cef552298fb3c79ba39e9534ccb7b sig_cn_org=None source=14.1 
   <para>
    The WAL tracks changes to these parameters on the
    primary.  If a hot standby processes WAL that indicates that the current
    value on the primary is higher than its own value, it will log a warning
    and pause recovery, for example:
<screen>
WARNING:  hot standby is not possible because of insufficient parameter settings
DETAIL:  max_connections = 80 is a lower setting than on the primary server, where its value was 100.
LOG:  recovery has paused
DETAIL:  If recovery is unpaused, the server will shut down.
HINT:  You can then restart the server after making the necessary configuration changes.
</screen>
    At that point, the settings on the standby need to be updated and the
    instance restarted before recovery can continue.  If the standby is not a
    hot standby, then when it encounters the incompatible parameter change, it
    will shut down immediately without pausing, since there is then no value
    in keeping it up.
   </para>
________________________________________________________-->
   <para>
   WAL 跟踪主节点上这些参数的变化。如果热备处理一个 WAL，表明主节点当前值大于备用数据库上的值，它将记录一个警告并中止恢复。例如:
<screen>
WARNING：由于参数设置不足，无法进行热备
详细信息：max_connections = 80 的设置低于主服务器上的设置，其值为 100。
LOG：恢复已暂停
详细信息：如果恢复未暂停，服务器将关闭。
提示：您可以在进行必要的配置更改后重新启动服务器。
</screen>
    此时，您应该更改备库设置并重新启动实例以继续恢复。如果备库不是热备，不兼容的参数更改将立即将其关闭而不会暂停。因为这样继续开机没有意义。
   </para>
<!-- pgdoc-cn_end sig_en=605cef552298fb3c79ba39e9534ccb7b -->

<!-- pgdoc-cn_start sig_en=5aa1df925f32c54ce797672d78080dc5 sig_cn_org=None source=14.1 
   <para>
    It is important that the administrator select appropriate settings for
    <xref linkend="guc-max-standby-archive-delay"/> and <xref
    linkend="guc-max-standby-streaming-delay"/>.  The best choices vary
    depending on business priorities.  For example if the server is primarily
    tasked as a High Availability server, then you will want low delay
    settings, perhaps even zero, though that is a very aggressive setting. If
    the standby server is tasked as an additional server for decision support
    queries then it might be acceptable to set the maximum delay values to
    many hours, or even -1 which means wait forever for queries to complete.
   </para>
________________________________________________________-->
   <para>
    管理员为<xref linkend="guc-max-standby-archive-delay"/>和<xref linkend="guc-max-standby-streaming-delay"/>选择适当的设置很重要。最好的选择取决于业务的优先级。例如如果服务器主要的任务是作为高可用服务器，那么你将想要低延迟设置，甚至是零（尽管它是一个非常激进的设置）。如果后备服务器的任务是作为一个用于决策支持查询的额外服务器，那么将其最大延迟值设置为很多小时甚至 -1 （表示无限等待）可能都是可以接受的。
   </para>
<!-- pgdoc-cn_end sig_en=5aa1df925f32c54ce797672d78080dc5 -->

<!-- pgdoc-cn_start sig_en=561a17405b7e8308c32e60b2bae82db9 sig_cn_org=None source=14.1 
   <para>
    Transaction status "hint bits" written on the primary are not WAL-logged,
    so data on the standby will likely re-write the hints again on the standby.
    Thus, the standby server will still perform disk writes even though
    all users are read-only; no changes occur to the data values
    themselves.  Users will still write large sort temporary files and
    re-generate relcache info files, so no part of the database
    is truly read-only during hot standby mode.
    Note also that writes to remote databases using
    <application>dblink</application> module, and other operations outside the
    database using PL functions will still be possible, even though the
    transaction is read-only locally.
   </para>
________________________________________________________-->
   <para>
    在主服务器上写出的事务状态 "hint bits" 是不被 WAL 记录的，因此后备服务器上的数据将可能重新写出该提示。这样，即使所有用户都是只读的，后备服务器仍将执行磁盘写操作；但数据值本身并没有发生改变。用户将仍写出大的排序临时文件并且重新生成 relcache 信息文件，这样在热备模式中数据库没有哪个部分是真正只读的。还要注意使用<application>dblink</application>模块写到远程数据库以及其他使用 PL 函数位于数据库之外的操作仍将可用，即使该事务是本地只读的。
   </para>
<!-- pgdoc-cn_end sig_en=561a17405b7e8308c32e60b2bae82db9 -->

<!-- pgdoc-cn_start sig_en=85efa307300b4d1f99e1a50f06541995 sig_cn_org=None source=14.1 
   <para>
    The following types of administration commands are not accepted
    during recovery mode:

      <itemizedlist>
       <listitem>
        <para>
         Data Definition Language (DDL): e.g., <command>CREATE INDEX</command>
        </para>
       </listitem>
       <listitem>
        <para>
         Privilege and Ownership: <command>GRANT</command>, <command>REVOKE</command>,
         <command>REASSIGN</command>
        </para>
       </listitem>
       <listitem>
        <para>
         Maintenance commands: <command>ANALYZE</command>, <command>VACUUM</command>,
         <command>CLUSTER</command>, <command>REINDEX</command>
        </para>
       </listitem>
      </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    在恢复模式期间，下列类型的管理命令是不被接受的：

      <itemizedlist>
       <listitem>
        <para>
         数据定义语言（DDL）: e.g., <command>CREATE INDEX</command>
        </para>
       </listitem>
       <listitem>
        <para>
         特权和所有权: <command>GRANT</command>, <command>REVOKE</command>,
        </para>
       </listitem>
       <listitem>
        <para>
         维护命令: <command>ANALYZE</command>, <command>VACUUM</command>,<command>CLUSTER</command>, <command>REINDEX</command>
        </para>
       </listitem>
      </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=85efa307300b4d1f99e1a50f06541995 -->

<!-- pgdoc-cn_start sig_en=3dd8f8c630a261b87f111aa860c05f69 sig_cn_org=None source=14.1 
   <para>
    Again, note that some of these commands are actually allowed during
    "read only" mode transactions on the primary.
   </para>
________________________________________________________-->
   <para>
    注意这些命令中的某些实际上在主服务器上的“只读”模式事务期间是被允许的。
   </para>
<!-- pgdoc-cn_end sig_en=3dd8f8c630a261b87f111aa860c05f69 -->

<!-- pgdoc-cn_start sig_en=bb0254a4437ff8ecdd1cb6d12286d77a sig_cn_org=None source=14.1 
   <para>
    As a result, you cannot create additional indexes that exist solely
    on the standby, nor statistics that exist solely on the standby.
    If these administration commands are needed, they should be executed
    on the primary, and eventually those changes will propagate to the
    standby.
   </para>
________________________________________________________-->
   <para>
    结果是，你无法创建只存在于后备服务器上的额外索引以及统计信息。如果需要这些管理命令，它们应该在主服务器上被执行，并且最后那些改变将被传播到后备服务器。
   </para>
<!-- pgdoc-cn_end sig_en=bb0254a4437ff8ecdd1cb6d12286d77a -->

<!-- pgdoc-cn_start sig_en=c4284a8415ac75fbb035f6c5f8139281 sig_cn_org=be18338e40946510e04175629fbd0358 source=15.7 
   <para>
    <function>pg_cancel_backend()</function>
    and <function>pg_terminate_backend()</function> will work on user backends,
    but not the startup process, which performs
    recovery. <structname>pg_stat_activity</structname> does not show
    recovering transactions as active. As a result,
    <structname>pg_prepared_xacts</structname> is always empty during
    recovery. If you wish to resolve in-doubt prepared transactions, view
    <literal>pg_prepared_xacts</literal> on the primary and issue commands to
    resolve transactions there or resolve them after the end of recovery.
   </para>
________________________________________________________-->
   <para>
    <function>pg_cancel_backend()</function>和<function>pg_terminate_backend()</function>将在用户后端工作，
    但不会影响启动过程，该过程执行恢复操作。 <structname>pg_stat_activity</structname>不显示
    正在恢复的事务为活动状态。因此，
    <structname>pg_prepared_xacts</structname>在恢复期间始终为空。
    如果您希望解决准备中的事务，请查看主服务器上的
    <literal>pg_prepared_xacts</literal>并发出命令来解决那里的事务，或在恢复结束后解决它们。
</para>
<!-- pgdoc-cn_end sig_en=c4284a8415ac75fbb035f6c5f8139281 -->

<!-- pgdoc-cn_start sig_en=ed71c092f6e5a4d990f149f73b52d97d sig_cn_org=9169551e2bc09dc9c8506bddc66ac575 source=15.7 
   <para>
    <structname>pg_locks</structname> will show locks held by backends,
    as normal. <structname>pg_locks</structname> also shows
    a virtual transaction managed by the startup process that owns all
    <literal>AccessExclusiveLocks</literal> held by transactions being replayed by recovery.
    Note that the startup process does not acquire locks to
    make database changes, and thus locks other than <literal>AccessExclusiveLocks</literal>
    do not show in <structname>pg_locks</structname> for the Startup
    process; they are just presumed to exist.
   </para>
________________________________________________________-->
   <para>
    <structname>pg_locks</structname>将显示由后端持有的锁，与正常情况一样。
	<structname>pg_locks</structname>还显示了由启动进程管理的虚拟事务，
    该虚拟事务拥有所有被恢复重放的事务持有的<literal>AccessExclusiveLocks</literal>
    请注意，启动进程不会获取锁来进行数据库更改，因此除了<literal>AccessExclusiveLocks</literal>
	之外的锁不会在启动进程的<structname>pg_locks</structname>中显示；
    它们只是被假定存在。
</para>
<!-- pgdoc-cn_end sig_en=ed71c092f6e5a4d990f149f73b52d97d -->

<!-- pgdoc-cn_start sig_en=93aaaad11b112dc5377e1a2cd62ebd05 sig_cn_org=None source=14.1 
   <para>
    The <productname>Nagios</productname> plugin <productname>check_pgsql</productname> will
    work, because the simple information it checks for exists.
    The <productname>check_postgres</productname> monitoring script will also work,
    though some reported values could give different or confusing results.
    For example, last vacuum time will not be maintained, since no
    vacuum occurs on the standby.  Vacuums running on the primary
    do still send their changes to the standby.
   </para>
________________________________________________________-->
   <para>
    <productname>Nagios</productname>的插件<productname>check_pgsql</productname>将可以工作，因为它检查的简单信息是存在的。<productname>check_postgres</productname>监控脚本也将能工作，尽管某些被报告的值可能给出不同或者混乱的结果。例如，上一次清理时间将不会被维护，因为在后备服务器上不会发生清理。在主服务器上运行的清理仍会把它们的改变发送给后备服务器。
   </para>
<!-- pgdoc-cn_end sig_en=93aaaad11b112dc5377e1a2cd62ebd05 -->

<!-- pgdoc-cn_start sig_en=785c07a73da032aab363e46d2d8b5311 sig_cn_org=faa602fece0cff6b09a9a3569f9b9f88 source=15.7 
   <para>
    WAL file control commands will not work during recovery,
    e.g., <function>pg_backup_start</function>, <function>pg_switch_wal</function> etc.
   </para>
________________________________________________________-->
   <para>
    在恢复期间，WAL文件控制命令将无法使用，例如，<function>pg_backup_start</function>，<function>pg_switch_wal</function>等。
   </para>
<!-- pgdoc-cn_end sig_en=785c07a73da032aab363e46d2d8b5311 -->

<!-- pgdoc-cn_start sig_en=e1f1738c5db9f5faf4be4065a3ce59db sig_cn_org=None source=14.1 
   <para>
    Dynamically loadable modules work, including <structname>pg_stat_statements</structname>.
   </para>
________________________________________________________-->
   <para>
    可动态载入的模块可以工作，包括<structname>pg_stat_statements</structname>。
   </para>
<!-- pgdoc-cn_end sig_en=e1f1738c5db9f5faf4be4065a3ce59db -->

<!-- pgdoc-cn_start sig_en=0b1a0496b6d081819fd6d8e1758209c5 sig_cn_org=None source=14.1 
   <para>
    Advisory locks work normally in recovery, including deadlock detection.
    Note that advisory locks are never WAL logged, so it is impossible for
    an advisory lock on either the primary or the standby to conflict with WAL
    replay. Nor is it possible to acquire an advisory lock on the primary
    and have it initiate a similar advisory lock on the standby. Advisory
    locks relate only to the server on which they are acquired.
   </para>
________________________________________________________-->
   <para>
    咨询锁在恢复期间工作正常，包括死锁检测。注意咨询锁从来都不会被 WAL 记录，因此在主服务器或后备服务器上一个咨询锁不可能会与 WAL 重播发生冲突。也不可能会在主服务器上获得一个咨询锁并且在后备服务器上开始一个相似的咨询锁。咨询锁只与它们被取得的那个服务器相关。
   </para>
<!-- pgdoc-cn_end sig_en=0b1a0496b6d081819fd6d8e1758209c5 -->

<!-- pgdoc-cn_start sig_en=9cf23e54bf8cc5dbcdfdd489afaea676 sig_cn_org=None source=14.1 
   <para>
    Trigger-based replication systems such as <productname>Slony</productname>,
    <productname>Londiste</productname> and <productname>Bucardo</productname> won't run on the
    standby at all, though they will run happily on the primary server as
    long as the changes are not sent to standby servers to be applied.
    WAL replay is not trigger-based so you cannot relay from the
    standby to any system that requires additional database writes or
    relies on the use of triggers.
   </para>
________________________________________________________-->
   <para>
    基于触发器的复制系统（如<productname>Slony</productname>、<productname>Londiste</productname>和<productname>Bucardo</productname>）将根本不会运行在后备服务器上，然而只要改变不被发送到要被应用的后备服务器，它们将在主服务器上运行得很好。WAL 重播不是基于触发器的，因此你不能用后备服务器接替任何需要额外数据库写操作或依赖触发器使用的系统。
   </para>
<!-- pgdoc-cn_end sig_en=9cf23e54bf8cc5dbcdfdd489afaea676 -->

<!-- pgdoc-cn_start sig_en=f62edf59b9c38f131b246c1c6f5c8d7f sig_cn_org=None source=14.1 
   <para>
    New OIDs cannot be assigned, though some <acronym>UUID</acronym> generators may still
    work as long as they do not rely on writing new status to the database.
   </para>
________________________________________________________-->
   <para>
    新的 OID 不能被分配，然而某些<acronym>UUID</acronym>生成器仍然能工作，只要它们不依赖于向数据库写新的状态。
   </para>
<!-- pgdoc-cn_end sig_en=f62edf59b9c38f131b246c1c6f5c8d7f -->

<!-- pgdoc-cn_start sig_en=a241f150f54d8f9c73386fd5c04ba13b sig_cn_org=1dfd0b0e7a301acdcbc162e0e036c47b source=15.7 
   <para>
    Currently, temporary table creation is not allowed during read-only
    transactions, so in some cases existing scripts will not run correctly.
    This restriction might be relaxed in a later release. This is
    both an SQL standard compliance issue and a technical issue.
   </para>
________________________________________________________-->
   <para>
    目前，在只读事务期间不允许创建临时表，因此在某些情况下，现有脚本将无法正确运行。
    这个限制可能在以后的版本中放宽。这既是SQL标准遵从问题，也是技术问题。
   </para>
<!-- pgdoc-cn_end sig_en=a241f150f54d8f9c73386fd5c04ba13b -->

<!-- pgdoc-cn_start sig_en=0b2c0d9726bb3dab37a4536f7c8dcd8c sig_cn_org=None source=14.1 
   <para>
    <command>DROP TABLESPACE</command> can only succeed if the tablespace is empty.
    Some standby users may be actively using the tablespace via their
    <varname>temp_tablespaces</varname> parameter. If there are temporary files in the
    tablespace, all active queries are canceled to ensure that temporary
    files are removed, so the tablespace can be removed and WAL replay
    can continue.
   </para>
________________________________________________________-->
   <para>
    只有在表空间为空时<command>DROP TABLESPACE</command>才能成功。某些后备服务器用户可能正在通过他们的<varname>temp_tablespaces</varname>参数使用该表空间。如果在该表空间中有临时文件，所有活动查询将被取消来保证临时文件被移除，这样该表空间可以被移除并且 WAL 重播可以继续。
   </para>
<!-- pgdoc-cn_end sig_en=0b2c0d9726bb3dab37a4536f7c8dcd8c -->

<!-- pgdoc-cn_start sig_en=a9445bc29a624a38b33f5e7ee363de40 sig_cn_org=None source=14.1 
   <para>
    Running <command>DROP DATABASE</command> or <command>ALTER DATABASE ... SET
    TABLESPACE</command> on the primary
    will generate a WAL entry that will cause all users connected to that
    database on the standby to be forcibly disconnected. This action occurs
    immediately, whatever the setting of
    <varname>max_standby_streaming_delay</varname>. Note that
    <command>ALTER DATABASE ... RENAME</command> does not disconnect users, which
    in most cases will go unnoticed, though might in some cases cause a
    program confusion if it depends in some way upon database name.
   </para>
________________________________________________________-->
   <para>
    在主服务器上运行<command>DROP DATABASE</command>或<command>ALTER DATABASE ... SET TABLESPACE</command>将产生一个 WAL 项，它将导致所有连接到后备服务器上那个数据库的用户被强制地断开连接。这个动作会立即发生，不管<varname>max_standby_streaming_delay</varname>的设置是什么。注意<command>ALTER DATABASE ... RENAME</command>不会断开用户，这在大部分情况中不会有提示，然而如果它依赖某种基于数据库名的方法，在某些情况中会导致程序混乱。
   </para>
<!-- pgdoc-cn_end sig_en=a9445bc29a624a38b33f5e7ee363de40 -->

<!-- pgdoc-cn_start sig_en=567fb374b5c06335a186a45ba32bc2b8 sig_cn_org=None source=14.1 
   <para>
    In normal (non-recovery) mode, if you issue <command>DROP USER</command> or <command>DROP ROLE</command>
    for a role with login capability while that user is still connected then
    nothing happens to the connected user &mdash; they remain connected. The user cannot
    reconnect however. This behavior applies in recovery also, so a
    <command>DROP USER</command> on the primary does not disconnect that user on the standby.
   </para>
________________________________________________________-->
   <para>
    在普通（非恢复）模式中，如果你为具有登录能力的角色发出<command>DROP USER</command>或<command>DROP ROLE</command>，而该用户仍然连接着，则对已连接用户不会发生任何事情 - 他们保持连接。但是用户不能重新连接。这种行为也适用于恢复，因此在主服务器上的一次<command>DROP USER</command>不会使后备服务器上的用户断开。
   </para>
<!-- pgdoc-cn_end sig_en=567fb374b5c06335a186a45ba32bc2b8 -->

<!-- pgdoc-cn_start sig_en=4c36d160dfd75e5de91872105ed3b4aa sig_cn_org=80eeb8a445f1dd48ff9443e6f5ea3d36 source=15.7 
   <para>
    The cumulative statistics system is active during recovery. All scans,
    reads, blocks, index usage, etc., will be recorded normally on the
    standby. However, WAL replay will not increment relation and database
    specific counters. I.e. replay will not increment pg_stat_all_tables
    columns (like n_tup_ins), nor will reads or writes performed by the
    startup process be tracked in the pg_statio views, nor will associated
    pg_stat_database columns be incremented.
   </para>
________________________________________________________-->
   <para>
    累积统计系统在恢复期间处于活动状态。所有的扫描、读取、块、索引使用等操作都将正常记录在备用站上。
    但是，WAL回放不会增加关系和数据库特定的计数器。即回放不会增加pg_stat_all_tables列（如n_tup_ins），
    启动过程执行的读取或写入也不会在pg_statio视图中被跟踪，相关的pg_stat_database列也不会增加。
</para>
<!-- pgdoc-cn_end sig_en=4c36d160dfd75e5de91872105ed3b4aa -->

<!-- pgdoc-cn_start sig_en=848d782ee0746b625c27eeca4955eeb2 sig_cn_org=None source=14.1 
   <para>
    Autovacuum is not active during recovery.  It will start normally at the
    end of recovery.
   </para>
________________________________________________________-->
   <para>
    在恢复期间自动清理不是活动的。它将在恢复末尾正常启动。
   </para>
<!-- pgdoc-cn_end sig_en=848d782ee0746b625c27eeca4955eeb2 -->

<!-- pgdoc-cn_start sig_en=7e50e3fcd9c785585147f7afa1e02a80 sig_cn_org=None source=14.1 
   <para>
    The checkpointer process and the background writer process are active during
    recovery. The checkpointer process will perform restartpoints (similar to
    checkpoints on the primary) and the background writer process will perform
    normal block cleaning activities. This can include updates of the hint bit
    information stored on the standby server.
    The <command>CHECKPOINT</command> command is accepted during recovery,
    though it performs a restartpoint rather than a new checkpoint.
   </para>
________________________________________________________-->
   <para>
    检查点进程和后台写入进程在恢复期间是活动状态的。检查点进程将执行重启动点（与主服务器上的检查点相似），后台写入进程将执行正常的块清理活动。	
    这可以包括存储在后备服务器上的提示位信息的更新。在恢复期间，<command>CHECKPOINT</command>命令会被接受，然而它会执行一个重启点而不是一个新的检查点。
   </para>
<!-- pgdoc-cn_end sig_en=7e50e3fcd9c785585147f7afa1e02a80 -->
  </sect2>

  <sect2 id="hot-standby-parameters">
<!-- pgdoc-cn_start sig_en=8322d0bb8557a6237ef2a3f8b0107c1d sig_cn_org=None source=14.1 
   <title>Hot Standby Parameter Reference</title>
________________________________________________________-->
   <title>热备参数参考</title>
<!-- pgdoc-cn_end sig_en=8322d0bb8557a6237ef2a3f8b0107c1d -->

<!-- pgdoc-cn_start sig_en=c0298d3b17e2ad75503ab485ed1f0e62 sig_cn_org=None source=14.1 
   <para>
    Various parameters have been mentioned above in
    <xref linkend="hot-standby-conflict"/> and
    <xref linkend="hot-standby-admin"/>.
   </para>
________________________________________________________-->
   <para>
    多个参数已经在<xref linkend="hot-standby-conflict"/>和<xref linkend="hot-standby-admin"/>中提到过。
   </para>
<!-- pgdoc-cn_end sig_en=c0298d3b17e2ad75503ab485ed1f0e62 -->

<!-- pgdoc-cn_start sig_en=1600e1a1e50b425505b8df3824837773 sig_cn_org=None source=14.1 
   <para>
    On the primary, parameters <xref linkend="guc-wal-level"/> and
    <xref linkend="guc-vacuum-defer-cleanup-age"/> can be used.
    <xref linkend="guc-max-standby-archive-delay"/> and
    <xref linkend="guc-max-standby-streaming-delay"/> have no effect if set on
    the primary.
   </para>
________________________________________________________-->
   <para>
    在主服务器上，可以使用参数<xref linkend="guc-wal-level"/>和<xref linkend="guc-vacuum-defer-cleanup-age"/>。在主服务器上设置<xref linkend="guc-max-standby-archive-delay"/>和<xref linkend="guc-max-standby-streaming-delay"/>不会产生效果。
   </para>
<!-- pgdoc-cn_end sig_en=1600e1a1e50b425505b8df3824837773 -->

<!-- pgdoc-cn_start sig_en=f713cee29fe224d3c11b6081289f97c5 sig_cn_org=None source=14.1 
   <para>
    On the standby, parameters <xref linkend="guc-hot-standby"/>,
    <xref linkend="guc-max-standby-archive-delay"/> and
    <xref linkend="guc-max-standby-streaming-delay"/> can be used.
    <xref linkend="guc-vacuum-defer-cleanup-age"/> has no effect
    as long as the server remains in standby mode, though it will
    become relevant if the standby becomes primary.
   </para>
________________________________________________________-->
   <para>
    在主服务器上，可以使用参数<xref linkend="guc-hot-standby"/>、<xref linkend="guc-max-standby-archive-delay"/>和<xref linkend="guc-max-standby-streaming-delay"/>。只要服务器保持在后备模式<xref linkend="guc-vacuum-defer-cleanup-age"/>就没有效果，然而当后备服务器变成主服务器时它将变得相关。
   </para>
<!-- pgdoc-cn_end sig_en=f713cee29fe224d3c11b6081289f97c5 -->
  </sect2>

  <sect2 id="hot-standby-caveats">
<!-- pgdoc-cn_start sig_en=6aecf7221ae7403619467c1e1a1a629b sig_cn_org=None source=14.1 
   <title>Caveats</title>
________________________________________________________-->
   <title>警告</title>
<!-- pgdoc-cn_end sig_en=6aecf7221ae7403619467c1e1a1a629b -->

<!-- pgdoc-cn_start sig_en=c3f8bed532a283908ed667eecff3ab42 sig_cn_org=7c541e034fdbaf8b02f0e6ce88f70c6e source=15.7 
   <para>
    There are several limitations of hot standby.
    These can and probably will be fixed in future releases:

  <itemizedlist>
   <listitem>
    <para>
     Full knowledge of running transactions is required before snapshots
     can be taken. Transactions that use large numbers of subtransactions
     (currently greater than 64) will delay the start of read-only
     connections until the completion of the longest running write transaction.
     If this situation occurs, explanatory messages will be sent to the server log.
    </para>
   </listitem>
   <listitem>
    <para>
     Valid starting points for standby queries are generated at each
     checkpoint on the primary. If the standby is shut down while the primary
     is in a shutdown state, it might not be possible to re-enter hot standby
     until the primary is started up, so that it generates further starting
     points in the WAL logs.  This situation isn't a problem in the most
     common situations where it might happen. Generally, if the primary is
     shut down and not available anymore, that's likely due to a serious
     failure that requires the standby being converted to operate as
     the new primary anyway.  And in situations where the primary is
     being intentionally taken down, coordinating to make sure the standby
     becomes the new primary smoothly is also standard procedure.
    </para>
   </listitem>
   <listitem>
    <para>
     At the end of recovery, <literal>AccessExclusiveLocks</literal> held by prepared transactions
     will require twice the normal number of lock table entries. If you plan
     on running either a large number of concurrent prepared transactions
     that normally take <literal>AccessExclusiveLocks</literal>, or you plan on having one
     large transaction that takes many <literal>AccessExclusiveLocks</literal>, you are
     advised to select a larger value of <varname>max_locks_per_transaction</varname>,
     perhaps as much as twice the value of the parameter on
     the primary server. You need not consider this at all if
     your setting of <varname>max_prepared_transactions</varname> is 0.
    </para>
   </listitem>
   <listitem>
    <para>
     The Serializable transaction isolation level is not yet available in hot
     standby.  (See <xref linkend="xact-serializable"/> and
     <xref linkend="serializable-consistency"/> for details.)
     An attempt to set a transaction to the serializable isolation level in
     hot standby mode will generate an error.
    </para>
   </listitem>
  </itemizedlist>

   </para>
________________________________________________________-->
   <para>
    热备份有几个限制。
    这些限制可能会在未来的版本中得到修复：

  <itemizedlist>
   <listitem>
    <para>
     在快照被拍摄之前，需要完全了解正在运行的事务。
     使用大量子事务（目前大于64个）的事务将延迟只读连接的启动，直到最长运行的写事务完成。
     如果出现这种情况，将向服务器日志发送解释性消息。
    </para>
   </listitem>
   <listitem>
    <para>
     在主服务器的每个检查点上生成热备份查询的有效起始点。
     如果在主服务器处于关闭状态时关闭热备份，可能无法重新进入热备份状态，直到主服务器启动，以便在WAL日志中生成进一步的起始点。
     在可能发生的最常见情况下，这种情况并不是问题。
     通常，如果主服务器关闭并且不再可用，那很可能是由于需要将热备份转换为新主服务器的严重故障。在主服务器被有意关闭的情况下，协调确保热备份顺利成为新主服务器也是标准程序。
    </para>
   </listitem>
   <listitem>
    <para>
     在恢复结束时，由准备事务持有的<literal>AccessExclusiveLocks</literal>将需要两倍于正常数量的锁表条目。
     如果您计划运行大量并发的准备事务，通常需要<literal>AccessExclusiveLocks</literal>，或者计划有一个需要许多<literal>AccessExclusiveLocks</literal>的大事务，建议您选择更大的<varname>max_locks_per_transaction</varname>值，可能是主服务器上该参数值的两倍。如果您的<varname>max_prepared_transactions</varname>设置为0，则无需考虑这一点。
    </para>
   </listitem>
   <listitem>
    <para>
     热备份中尚不支持Serializable事务隔离级别。（有关详细信息，请参见<xref linkend="xact-serializable"/>和<xref linkend="serializable-consistency"/>。）
     在热备份模式下尝试将事务设置为可串行化隔离级别将生成错误。
    </para>
   </listitem>
  </itemizedlist>

   </para>
<!-- pgdoc-cn_end sig_en=c3f8bed532a283908ed667eecff3ab42 -->
  </sect2>

 </sect1>

</chapter>
