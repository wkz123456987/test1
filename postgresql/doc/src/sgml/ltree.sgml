<!-- doc/src/sgml/ltree.sgml -->

<sect1 id="ltree" xreflabel="ltree">
<!-- pgdoc-cn_start sig_en=0bb38756199fc3134435075948e7b28a sig_cn_org=None source=14.1 
 <title>ltree</title>
________________________________________________________-->
 <title>ltree</title>
<!-- pgdoc-cn_end sig_en=0bb38756199fc3134435075948e7b28a -->

<!-- pgdoc-cn_start sig_en=b95d944b7e7d5bfa3514dd150538a019 sig_cn_org=None source=14.1 
 <indexterm zone="ltree">
  <primary>ltree</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="ltree">
  <primary>ltree</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=b95d944b7e7d5bfa3514dd150538a019 -->

<!-- pgdoc-cn_start sig_en=b329408b00507a0054eb9fd4f228f586 sig_cn_org=None source=14.1 
 <para>
  This module implements a data type <type>ltree</type> for representing
  labels of data stored in a hierarchical tree-like structure.
  Extensive facilities for searching through label trees are provided.
 </para>
________________________________________________________-->
 <para>
  这个模块实现了一种数据类型<type>ltree</type>用于表示存储在一个层次树状结构中的数据的标签。还提供了在标签树中搜索的扩展功能。
 </para>
<!-- pgdoc-cn_end sig_en=b329408b00507a0054eb9fd4f228f586 -->

<!-- pgdoc-cn_start sig_en=73fd7076637bb21a0cce44734412cba6 sig_cn_org=None source=14.1 
 <para>
  This module is considered <quote>trusted</quote>, that is, it can be
  installed by non-superusers who have <literal>CREATE</literal> privilege
  on the current database.
 </para>
________________________________________________________-->
 <para>
  这个模块被视为<quote>trusted</quote>，也就是说，它可以是由拥有<literal>CREATE</literal>特权的非超级用户安装在当前数据库上。
 </para>
<!-- pgdoc-cn_end sig_en=73fd7076637bb21a0cce44734412cba6 -->

 <sect2>
<!-- pgdoc-cn_start sig_en=48f66ae519a72df035f080b0889bef9e sig_cn_org=None source=14.1 
  <title>Definitions</title>
________________________________________________________-->
  <title>定义</title>
<!-- pgdoc-cn_end sig_en=48f66ae519a72df035f080b0889bef9e -->

<!-- pgdoc-cn_start sig_en=baa4fe65ec2fbbbdb83f977628f29a73 sig_cn_org=None source=14.1 
  <para>
   A <firstterm>label</firstterm> is a sequence of alphanumeric characters
   and underscores (for example, in C locale the characters
   <literal>A-Za-z0-9_</literal> are allowed).
   Labels must be less than 256 characters long.
  </para>
________________________________________________________-->
  <para>
   一个<firstterm>标签</firstterm>是一个字母数字字符和下划线的序列（例如，在 C 区域中允许字符<literal>A-Za-z0-9_</literal>）。
   标签长度必须少于 256 个字符。
  </para>
<!-- pgdoc-cn_end sig_en=baa4fe65ec2fbbbdb83f977628f29a73 -->

<!-- pgdoc-cn_start sig_en=46f4c93eca077512d139af65a9e4594b sig_cn_org=None source=14.1 
  <para>
   Examples: <literal>42</literal>, <literal>Personal_Services</literal>
  </para>
________________________________________________________-->
  <para>
   例子： <literal>42</literal>, <literal>Personal_Services</literal>
  </para>
<!-- pgdoc-cn_end sig_en=46f4c93eca077512d139af65a9e4594b -->

<!-- pgdoc-cn_start sig_en=83f06ac795a84d3f665740479190516d sig_cn_org=None source=14.1 
  <para>
   A <firstterm>label path</firstterm> is a sequence of zero or more
   labels separated by dots, for example <literal>L1.L2.L3</literal>, representing
   a path from the root of a hierarchical tree to a particular node.  The
   length of a label path cannot exceed 65535 labels.
  </para>
________________________________________________________-->
  <para>
   一个<firstterm>标签路径</firstterm>是由点号分隔的零个或者更多个标签的序列，例如<literal>L1.L2.L3</literal>，它表示一个从层次树的根到一个特定节点的路径。
   一个标签路径的长度不能超过 65535 个标签。
  </para>
<!-- pgdoc-cn_end sig_en=83f06ac795a84d3f665740479190516d -->

<!-- pgdoc-cn_start sig_en=69ad66c228d0390c1e77fd0cf8c9e2f0 sig_cn_org=None source=14.1 
  <para>
   Example: <literal>Top.Countries.Europe.Russia</literal>
  </para>
________________________________________________________-->
  <para>
   例子：<literal>Top.Countries.Europe.Russia</literal>
  </para>
<!-- pgdoc-cn_end sig_en=69ad66c228d0390c1e77fd0cf8c9e2f0 -->

<!-- pgdoc-cn_start sig_en=0d7daf8ce5543b3c5be6f91db68516dd sig_cn_org=None source=14.1 
  <para>
   The <filename>ltree</filename> module provides several data types:
  </para>
________________________________________________________-->
  <para>
   <filename>ltree</filename>模块提供多种数据类型：
  </para>
<!-- pgdoc-cn_end sig_en=0d7daf8ce5543b3c5be6f91db68516dd -->

  <itemizedlist>
   <listitem>
<!-- pgdoc-cn_start sig_en=3105ac990462b2424ed278bc811cda5f sig_cn_org=None source=14.1 
    <para>
     <type>ltree</type> stores a label path.
    </para>
________________________________________________________-->
    <para>
     <type>ltree</type>存储一个标签路径。
    </para>
<!-- pgdoc-cn_end sig_en=3105ac990462b2424ed278bc811cda5f -->
   </listitem>

   <listitem>
<!-- pgdoc-cn_start sig_en=4ce1cfb3e9843a39744e6e4cad4306be sig_cn_org=None source=14.1 
    <para>
     <type>lquery</type> represents a regular-expression-like pattern
     for matching <type>ltree</type> values.  A simple word matches that
     label within a path.  A star symbol (<literal>*</literal>) matches zero
     or more labels.  These can be joined with dots to form a pattern that
     must match the whole label path.  For example:
<synopsis>
foo         <lineannotation>Match the exact label path <literal>foo</literal></lineannotation>
*.foo.*     <lineannotation>Match any label path containing the label <literal>foo</literal></lineannotation>
*.foo       <lineannotation>Match any label path whose last label is <literal>foo</literal></lineannotation>
</synopsis>
    </para>
________________________________________________________-->
    <para>
     <type>lquery</type>表示一个用于匹配<type>ltree</type>值的类正则表达式的模式。一个简单词匹配一个路径中的那个标签。
     一个星号（<literal>*</literal>）匹配零个或更多个标签。它们可以用点连接起来，以形成一个必须匹配整个标签路径的模式。例如：
<synopsis>
foo         <lineannotation>正好匹配标签路径<literal>foo</literal></lineannotation>
*.foo.*     <lineannotation>匹配任何包含标签<literal>foo</literal>的标签路径</lineannotation>
*.foo       <lineannotation>匹配任何最后一个标签是<literal>foo</literal>的标签路径</lineannotation>
</synopsis>
    </para>
<!-- pgdoc-cn_end sig_en=4ce1cfb3e9843a39744e6e4cad4306be -->

<!-- pgdoc-cn_start sig_en=d6b889491aa8386fc77544fc7b44f162 sig_cn_org=None source=14.1 
    <para>
     Both star symbols and simple words can be quantified to restrict how many
     labels they can match:
<synopsis>
*{<replaceable>n</replaceable>}        <lineannotation>Match exactly <replaceable>n</replaceable> labels</lineannotation>
*{<replaceable>n</replaceable>,}       <lineannotation>Match at least <replaceable>n</replaceable> labels</lineannotation>
*{<replaceable>n</replaceable>,<replaceable>m</replaceable>}      <lineannotation>Match at least <replaceable>n</replaceable> but not more than <replaceable>m</replaceable> labels</lineannotation>
*{,<replaceable>m</replaceable>}       <lineannotation>Match at most <replaceable>m</replaceable> labels &mdash; same as </lineannotation>*{0,<replaceable>m</replaceable>}
foo{<replaceable>n</replaceable>,<replaceable>m</replaceable>}    <lineannotation>Match at least <replaceable>n</replaceable> but not more than <replaceable>m</replaceable> occurrences of <literal>foo</literal></lineannotation>
foo{,}      <lineannotation>Match any number of occurrences of <literal>foo</literal>, including zero</lineannotation>
</synopsis>
     In the absence of any explicit quantifier, the default for a star symbol
     is to match any number of labels (that is, <literal>{,}</literal>) while
     the default for a non-star item is to match exactly once (that
     is, <literal>{1}</literal>).
    </para>
________________________________________________________-->
    <para>
     星号和简单词都可以被限定来限制它能匹配多少标签：
<synopsis>
*{<replaceable>n</replaceable>}        <lineannotation>匹配正好<replaceable>n</replaceable>个标签</lineannotation>
*{<replaceable>n</replaceable>,}       <lineannotation>匹配至少<replaceable>n</replaceable>个标签</lineannotation>
*{<replaceable>n</replaceable>,<replaceable>m</replaceable>}      <lineannotation>匹配至少<replaceable>n</replaceable>个但是最多<replaceable>m</replaceable>个标签</lineannotation>
*{,<replaceable>m</replaceable>}       <lineannotation>匹配最多<replaceable>m</replaceable>个标签 &mdash; 与*{0,<replaceable>m</replaceable>}相同</lineannotation> 
foo{<replaceable>n</replaceable>,<replaceable>m</replaceable>}    <lineannotation>匹配至少 <replaceable>n</replaceable> 但是不超过 <replaceable>m</replaceable> 并发的 <literal>foo</literal></lineannotation>
foo{,}      <lineannotation>匹配任何数量的并发的 <literal>foo</literal>, 包括零</lineannotation>
</synopsis>
     在缺乏任何显式量词的情况下，星号的默认值是匹配任意数量的标签(也就是<literal>{,}</literal>)，而非星号项的默认值是只匹配一次(也就是<literal>{1}</literal>)。
    </para>
<!-- pgdoc-cn_end sig_en=d6b889491aa8386fc77544fc7b44f162 -->

<!-- pgdoc-cn_start sig_en=ca05529b6b2d9b2e5ef8be75aebbf833 sig_cn_org=None source=14.1 
    <para>
     There are several modifiers that can be put at the end of a non-star
     <type>lquery</type> item to make it match more than just the exact match:
<synopsis>
@           <lineannotation>Match case-insensitively, for example <literal>a@</literal> matches <literal>A</literal></lineannotation>
*           <lineannotation>Match any label with this prefix, for example <literal>foo*</literal> matches <literal>foobar</literal></lineannotation>
%           <lineannotation>Match initial underscore-separated words</lineannotation>
</synopsis>
     The behavior of <literal>%</literal> is a bit complicated.  It tries to match
     words rather than the entire label.  For example
     <literal>foo_bar%</literal> matches <literal>foo_bar_baz</literal> but not
     <literal>foo_barbaz</literal>.  If combined with <literal>*</literal>, prefix
     matching applies to each word separately, for example
     <literal>foo_bar%*</literal> matches <literal>foo1_bar2_baz</literal> but
     not <literal>foo1_br2_baz</literal>.
    </para>
________________________________________________________-->
    <para>
     有几个修饰符可以放在一个非星号的<type>lquery</type>项的末尾，使它能匹配除了精确匹配之外更多的匹配:
<synopsis>
@           <lineannotation>不区分大小写匹配，例如<literal>a@</literal>匹配<literal>A</literal></lineannotation>
*           <lineannotation>匹配带此前缀的任何标签，例如<literal>foo*</literal>匹配<literal>foobar</literal></lineannotation>
%           <lineannotation>匹配开头以下划线分隔的词</lineannotation>
</synopsis>
     <literal>%</literal>的行为有点复杂。它尝试匹配词而不是整个标签。例如，<literal>foo_bar%</literal>匹配<literal>foo_bar_baz</literal>但是不匹配<literal>foo_barbaz</literal>。如果和<literal>*</literal>组合，前缀匹配可以单独应用于每一个词，例如<literal>foo_bar%*</literal>匹配<literal>foo1_bar2_baz</literal>但不匹配<literal>foo1_br2_baz</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=ca05529b6b2d9b2e5ef8be75aebbf833 -->

<!-- pgdoc-cn_start sig_en=8996cb25493d5ea123b1399f8bfbeb3c sig_cn_org=None source=14.1 
    <para>
     Also, you can write several possibly-modified non-star items separated with
     <literal>|</literal> (OR) to match any of those items, and you can put
     <literal>!</literal> (NOT) at the start of a non-star group to match any
     label that doesn't match any of the alternatives.  A quantifier, if any,
     goes at the end of the group; it means some number of matches for the
     group as a whole (that is, some number of labels matching or not matching
     any of the alternatives).
    </para>
________________________________________________________-->
    <para>
     此外，你可以写多个带有<literal>|</literal>（OR）的可能改过的非星号项目来匹配那些项目中的任何一个（或几个），并且你可以在非星号组最前面放上<literal>!</literal>（NOT）来匹配任何不匹配那些分支的标签。
     量词，若有的话，位于组的末尾;它意味着作为一个整体的组的一些匹配(也就是说，一些匹配或不匹配任何替代的标签)。
    </para>
<!-- pgdoc-cn_end sig_en=8996cb25493d5ea123b1399f8bfbeb3c -->

<!-- pgdoc-cn_start sig_en=1ee770b8f963d6a7f58c5f00f70416ba sig_cn_org=None source=14.1 
    <para>
     Here's an annotated example of <type>lquery</type>:
<programlisting>
Top.*{0,2}.sport*@.!football|tennis{1,}.Russ*|Spain
a.  b.     c.      d.                   e.
</programlisting>
     This query will match any label path that:
    </para>
________________________________________________________-->
    <para>
     这里是一个<type>lquery</type>的例子：
<programlisting>
Top.*{0,2}.sport*@.!football|tennis{1,}.Russ*|Spain
a.  b.     c.      d.                   e.
</programlisting>
     这个查询将匹配任何这样的标签路径：
    </para>
<!-- pgdoc-cn_end sig_en=1ee770b8f963d6a7f58c5f00f70416ba -->
    <orderedlist numeration="loweralpha">
     <listitem>
<!-- pgdoc-cn_start sig_en=c8d103954511c86636dd67e054ef3456 sig_cn_org=None source=14.1 
      <para>
       begins with the label <literal>Top</literal>
      </para>
________________________________________________________-->
      <para>
       开始于标签<literal>Top</literal>
      </para>
<!-- pgdoc-cn_end sig_en=c8d103954511c86636dd67e054ef3456 -->
     </listitem>
     <listitem>
<!-- pgdoc-cn_start sig_en=d89fe8b1b3fe91f183e347799ec1a051 sig_cn_org=None source=14.1 
      <para>
       and next has zero to two labels before
      </para>
________________________________________________________-->
      <para>
       并且接着具有 0 到 2 个标签
      </para>
<!-- pgdoc-cn_end sig_en=d89fe8b1b3fe91f183e347799ec1a051 -->
     </listitem>
     <listitem>
<!-- pgdoc-cn_start sig_en=7afa7c72c60d104c87249a809cb733ad sig_cn_org=None source=14.1 
      <para>
       a label beginning with the case-insensitive prefix <literal>sport</literal>
      </para>
________________________________________________________-->
      <para>
       之后是一个开始于大小写无关的前缀<literal>sport</literal>的标签
      </para>
<!-- pgdoc-cn_end sig_en=7afa7c72c60d104c87249a809cb733ad -->
     </listitem>
     <listitem>
<!-- pgdoc-cn_start sig_en=6bd2fa90749907896ff732d92917b763 sig_cn_org=None source=14.1 
      <para>
       then has one or more labels, none of which
       match <literal>football</literal> nor <literal>tennis</literal>
      </para>
________________________________________________________-->
      <para>
       然后有一个或多个标签，没有匹配<literal>football</literal>和<literal>tennis</literal>。
      </para>
<!-- pgdoc-cn_end sig_en=6bd2fa90749907896ff732d92917b763 -->
     </listitem>
     <listitem>
<!-- pgdoc-cn_start sig_en=7e3102f94dbd99828dc4c12063f0c7ce sig_cn_org=None source=14.1 
      <para>
       and then ends with a label beginning with <literal>Russ</literal> or
       exactly matching <literal>Spain</literal>.
      </para>
________________________________________________________-->
      <para>
       并且结尾是一个开始于<literal>Russ</literal>的标签，或者完全匹配<literal>Spain</literal>的标签。
      </para>
<!-- pgdoc-cn_end sig_en=7e3102f94dbd99828dc4c12063f0c7ce -->
     </listitem>
    </orderedlist>
   </listitem>

   <listitem>
<!-- pgdoc-cn_start sig_en=048fc90334cb8140499652252e319eaa sig_cn_org=None source=14.1 
    <para><type>ltxtquery</type> represents a full-text-search-like
    pattern for matching <type>ltree</type> values.  An
    <type>ltxtquery</type> value contains words, possibly with the
    modifiers <literal>@</literal>, <literal>*</literal>, <literal>%</literal> at the end;
    the modifiers have the same meanings as in <type>lquery</type>.
    Words can be combined with <literal>&amp;</literal> (AND),
    <literal>|</literal> (OR), <literal>!</literal> (NOT), and parentheses.
    The key difference from
    <type>lquery</type> is that <type>ltxtquery</type> matches words without
    regard to their position in the label path.
    </para>
________________________________________________________-->
    <para><type>ltxtquery</type>表示一种用于匹配<type>ltree</type>值的类全文搜索的模式。一个<type>ltxtquery</type>值包含词，也可能在末尾带有修饰符<literal>@</literal>、<literal>*</literal>、<literal>%</literal>，修饰符具有和<type>lquery</type>中相同的含义。词可以用<literal>&amp;</literal>（AND）、<literal>|</literal>（OR）、<literal>!</literal>（NOT）以及圆括号组合。<type>lquery</type>和<type>ltxtquery</type>的关键区别是前者匹配词时不考虑它们在标签路径中的位置。
    </para>
<!-- pgdoc-cn_end sig_en=048fc90334cb8140499652252e319eaa -->

<!-- pgdoc-cn_start sig_en=9869751eafaa11ac839bd6dd73e38145 sig_cn_org=None source=14.1 
    <para>
     Here's an example <type>ltxtquery</type>:
<programlisting>
Europe &amp; Russia*@ &amp; !Transportation
</programlisting>
     This will match paths that contain the label <literal>Europe</literal> and
     any label beginning with <literal>Russia</literal> (case-insensitive),
     but not paths containing the label <literal>Transportation</literal>.
     The location of these words within the path is not important.
     Also, when <literal>%</literal> is used, the word can be matched to any
     underscore-separated word within a label, regardless of position.
    </para>
________________________________________________________-->
    <para>
     这是一个<type>ltxtquery</type>的例子：
<programlisting>
Europe &amp; Russia*@ &amp; !Transportation
</programlisting>
     这将匹配包含标签<literal>Europe</literal>以及任何以<literal>Russia</literal>开始（大小写不敏感）的标签的路径，但是不匹配包含标签<literal>Transportation</literal>的路径。这些词在路径中的位置并不重要。还有，当使用<literal>%</literal>时，该次可以与一个标签中任何下划线分隔的词匹配，而不管它们的位置如何。
    </para>
<!-- pgdoc-cn_end sig_en=9869751eafaa11ac839bd6dd73e38145 -->
   </listitem>

  </itemizedlist>

<!-- pgdoc-cn_start sig_en=d1fdfa4a87e24989cdec666ece963e32 sig_cn_org=None source=14.1 
  <para>
   Note: <type>ltxtquery</type> allows whitespace between symbols, but
   <type>ltree</type> and <type>lquery</type> do not.
  </para>
________________________________________________________-->
  <para>
   注意：<type>ltxtquery</type>允许符号之间的空白，但是<type>ltree</type>和<type>lquery</type>不允许。
  </para>
<!-- pgdoc-cn_end sig_en=d1fdfa4a87e24989cdec666ece963e32 -->
 </sect2>

 <sect2>
<!-- pgdoc-cn_start sig_en=f88aec755dcc563cb05ac65ba575f0d2 sig_cn_org=None source=14.1 
  <title>Operators and Functions</title>
________________________________________________________-->
  <title>操作符和函数</title>
<!-- pgdoc-cn_end sig_en=f88aec755dcc563cb05ac65ba575f0d2 -->

<!-- pgdoc-cn_start sig_en=5bfcbc26a3af450e2af1e505ca53e5b4 sig_cn_org=None source=14.1 
  <para>
   Type <type>ltree</type> has the usual comparison operators
   <literal>=</literal>, <literal>&lt;&gt;</literal>,
   <literal>&lt;</literal>, <literal>&gt;</literal>, <literal>&lt;=</literal>, <literal>&gt;=</literal>.
   Comparison sorts in the order of a tree traversal, with the children
   of a node sorted by label text.  In addition, the specialized
   operators shown in <xref linkend="ltree-op-table"/> are available.
  </para>
________________________________________________________-->
  <para>
   类型<type>ltree</type>有普通比较操作符
   <literal>=</literal>、<literal>&lt;&gt;</literal>、
   <literal>&lt;</literal>、<literal>&gt;</literal>、<literal>&lt;=</literal>、<literal>&gt;=</literal>。
   比较会按照树遍历的顺序排序，一个节点的子女按照标签文本排序。另外，还有<xref linkend="ltree-op-table"/>中显示的特殊操作符。
  </para>
<!-- pgdoc-cn_end sig_en=5bfcbc26a3af450e2af1e505ca53e5b4 -->

  <table id="ltree-op-table">
<!-- pgdoc-cn_start sig_en=08f913bd13f4e99460180e7216092879 sig_cn_org=None source=14.1 
   <title><type>ltree</type> Operators</title>
________________________________________________________-->
   <title><type>ltree</type> 操作符</title>
<!-- pgdoc-cn_end sig_en=08f913bd13f4e99460180e7216092879 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=860582efa5a4237e828778cb17b589cb sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Operator
       </para>
       <para>
        Description
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        操作符
       </para>
       <para>
        描述
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=860582efa5a4237e828778cb17b589cb -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=c1341508e5b9d81e2c7a05c9530cc0ec sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree</type> <literal>@&gt;</literal> <type>ltree</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is left argument an ancestor of right (or equal)?
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree</type> <literal>@&gt;</literal> <type>ltree</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        左参数是右参数(或相等)的祖先么？
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c1341508e5b9d81e2c7a05c9530cc0ec -->

<!-- pgdoc-cn_start sig_en=65255d0815f78338ef8f85e544541ff9 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree</type> <literal>&lt;@</literal> <type>ltree</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Is left argument a descendant of right (or equal)?
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree</type> <literal>&lt;@</literal> <type>ltree</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        左参数是右参数(或相等)的后代么？
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=65255d0815f78338ef8f85e544541ff9 -->

<!-- pgdoc-cn_start sig_en=996d63fb8f145de0273d450f6140ccec sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree</type> <literal>~</literal> <type>lquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>lquery</type> <literal>~</literal> <type>ltree</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does <type>ltree</type> match <type>lquery</type>?
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree</type> <literal>~</literal> <type>lquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>lquery</type> <literal>~</literal> <type>ltree</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        <type>ltree</type> 匹配 <type>lquery</type>么？
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=996d63fb8f145de0273d450f6140ccec -->

<!-- pgdoc-cn_start sig_en=0c4d4d5968b1fb2b9c89ad572a304841 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree</type> <literal>?</literal> <type>lquery[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>lquery[]</type> <literal>?</literal> <type>ltree</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does <type>ltree</type> match any <type>lquery</type> in array?
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree</type> <literal>?</literal> <type>lquery[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>lquery[]</type> <literal>?</literal> <type>ltree</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        <type>ltree</type> 在数组中匹配任何 <type>lquery</type> 么？
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=0c4d4d5968b1fb2b9c89ad572a304841 -->

<!-- pgdoc-cn_start sig_en=cf90ef33890433c2978a971d8ad34f21 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree</type> <literal>@</literal> <type>ltxtquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>ltxtquery</type> <literal>@</literal> <type>ltree</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does <type>ltree</type> match <type>ltxtquery</type>?
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree</type> <literal>@</literal> <type>ltxtquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>ltxtquery</type> <literal>@</literal> <type>ltree</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        <type>ltree</type> 匹配 <type>ltxtquery</type>么？
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=cf90ef33890433c2978a971d8ad34f21 -->

<!-- pgdoc-cn_start sig_en=129e1961d53597f37a24607a69d494e0 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree</type> <literal>||</literal> <type>ltree</type>
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        Concatenates <type>ltree</type> paths.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree</type> <literal>||</literal> <type>ltree</type>
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        连接 <type>ltree</type> 路径。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=129e1961d53597f37a24607a69d494e0 -->

<!-- pgdoc-cn_start sig_en=d27f1070f9660efd48a76b4bd37c986a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree</type> <literal>||</literal> <type>text</type>
        <returnvalue>ltree</returnvalue>
       </para>
       <para role="func_signature">
        <type>text</type> <literal>||</literal> <type>ltree</type>
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        Converts text to <type>ltree</type> and concatenates.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree</type> <literal>||</literal> <type>text</type>
        <returnvalue>ltree</returnvalue>
       </para>
       <para role="func_signature">
        <type>text</type> <literal>||</literal> <type>ltree</type>
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        把文本转换为 <type>ltree</type> 并连接。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d27f1070f9660efd48a76b4bd37c986a -->

<!-- pgdoc-cn_start sig_en=8cc02fc59f960d1fe363a628c3937412 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree[]</type> <literal>@&gt;</literal> <type>ltree</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>ltree</type> <literal>&lt;@</literal> <type>ltree[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does array contain an ancestor of <type>ltree</type>?
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree[]</type> <literal>@&gt;</literal> <type>ltree</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>ltree</type> <literal>&lt;@</literal> <type>ltree[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        数组中包含一个 <type>ltree</type>的祖先么？
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=8cc02fc59f960d1fe363a628c3937412 -->

<!-- pgdoc-cn_start sig_en=e328206e071e670f77313743fb6c0d4d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree[]</type> <literal>&lt;@</literal> <type>ltree</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>ltree</type> <literal>@&gt;</literal> <type>ltree[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does array contain a descendant of <type>ltree</type>?
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree[]</type> <literal>&lt;@</literal> <type>ltree</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>ltree</type> <literal>@&gt;</literal> <type>ltree[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        数组中包含一个 <type>ltree</type>的后代么？
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e328206e071e670f77313743fb6c0d4d -->

<!-- pgdoc-cn_start sig_en=ada29bd723bfcc80675ed8645291f70e sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree[]</type> <literal>~</literal> <type>lquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>lquery</type> <literal>~</literal> <type>ltree[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does array contain any path matching <type>lquery</type>?
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree[]</type> <literal>~</literal> <type>lquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>lquery</type> <literal>~</literal> <type>ltree[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        数组中包含匹配 <type>lquery</type>的任何路径么？
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ada29bd723bfcc80675ed8645291f70e -->

<!-- pgdoc-cn_start sig_en=95522a95a0c80f166bf6f160ea5fe676 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree[]</type> <literal>?</literal> <type>lquery[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>lquery[]</type> <literal>?</literal> <type>ltree[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does <type>ltree</type> array contain any path matching
        any <type>lquery</type>?
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree[]</type> <literal>?</literal> <type>lquery[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>lquery[]</type> <literal>?</literal> <type>ltree[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does <type>ltree</type> 数组中包含匹配任何<type>lquery</type>的任何路径么？
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=95522a95a0c80f166bf6f160ea5fe676 -->

<!-- pgdoc-cn_start sig_en=9cfef91eaa42fad776c283ba91c88c86 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree[]</type> <literal>@</literal> <type>ltxtquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>ltxtquery</type> <literal>@</literal> <type>ltree[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        Does array contain any path matching <type>ltxtquery</type>?
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree[]</type> <literal>@</literal> <type>ltxtquery</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para role="func_signature">
        <type>ltxtquery</type> <literal>@</literal> <type>ltree[]</type>
        <returnvalue>boolean</returnvalue>
       </para>
       <para>
        数组中包含匹配<type>ltxtquery</type>的任何路径么？
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9cfef91eaa42fad776c283ba91c88c86 -->

<!-- pgdoc-cn_start sig_en=d818a058de4a9fa9634ea5d1c0a12086 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree[]</type> <literal>?@&gt;</literal> <type>ltree</type>
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        Returns first array entry that is an ancestor of <type>ltree</type>,
        or <literal>NULL</literal> if none.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree[]</type> <literal>?@&gt;</literal> <type>ltree</type>
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        返回作为<type>ltree</type>祖先的第一个数组条目，如果没有则返回<literal>NULL</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d818a058de4a9fa9634ea5d1c0a12086 -->

<!-- pgdoc-cn_start sig_en=f7bf909301ff3fdb458f058885b69d0a sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree[]</type> <literal>?&lt;@</literal> <type>ltree</type>
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        Returns first array entry that is a descendant of <type>ltree</type>,
        or <literal>NULL</literal> if none.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree[]</type> <literal>?&lt;@</literal> <type>ltree</type>
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        返回作为<type>ltree</type>后代的第一个数组条目，如果没有则返回<literal>NULL</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f7bf909301ff3fdb458f058885b69d0a -->

<!-- pgdoc-cn_start sig_en=e87ab6109324f344d437ac6ca5cbbece sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree[]</type> <literal>?~</literal> <type>lquery</type>
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        Returns first array entry that matches <type>lquery</type>,
        or <literal>NULL</literal> if none.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree[]</type> <literal>?~</literal> <type>lquery</type>
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        返回匹配<type>lquery</type>的第一个数组条目，如果没有，则返回<literal>NULL</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=e87ab6109324f344d437ac6ca5cbbece -->

<!-- pgdoc-cn_start sig_en=9dcd66a4168d12687e1b074f2b6a0a54 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree[]</type> <literal>?@</literal> <type>ltxtquery</type>
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        Returns first array entry that matches <type>ltxtquery</type>,
        or <literal>NULL</literal> if none.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <type>ltree[]</type> <literal>?@</literal> <type>ltxtquery</type>
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        返回匹配<type>ltxtquery</type>的第一个数组条目，如果没有，则返回<literal>NULL</literal>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9dcd66a4168d12687e1b074f2b6a0a54 -->
     </tbody>
    </tgroup>
  </table>

<!-- pgdoc-cn_start sig_en=319449f6061f4846d2cc3d3d48c498e8 sig_cn_org=None source=14.1 
  <para>
   The operators <literal>&lt;@</literal>, <literal>@&gt;</literal>,
   <literal>@</literal> and <literal>~</literal> have analogues
   <literal>^&lt;@</literal>, <literal>^@&gt;</literal>, <literal>^@</literal>,
   <literal>^~</literal>, which are the same except they do not use
   indexes.  These are useful only for testing purposes.
  </para>
________________________________________________________-->
  <para>
   操作符<literal>&lt;@</literal>、<literal>@&gt;</literal>、
   <literal>@</literal>以及<literal>~</literal>有类似的、
   <literal>^&lt;@</literal>、<literal>^@&gt;</literal>、<literal>^@</literal>、
   <literal>^~</literal>，只是它们不适用索引。它们只对测试目的有用。
  </para>
<!-- pgdoc-cn_end sig_en=319449f6061f4846d2cc3d3d48c498e8 -->

<!-- pgdoc-cn_start sig_en=271abf4b5f30c2c0b9823f4d3cc2d345 sig_cn_org=None source=14.1 
  <para>
   The available functions are shown in <xref linkend="ltree-func-table"/>.
  </para>
________________________________________________________-->
  <para>
   可用的函数在<xref linkend="ltree-func-table"/>中。
  </para>
<!-- pgdoc-cn_end sig_en=271abf4b5f30c2c0b9823f4d3cc2d345 -->

  <table id="ltree-func-table">
<!-- pgdoc-cn_start sig_en=4be2090d21151e330b23eb6548166268 sig_cn_org=None source=14.1 
   <title><type>ltree</type> Functions</title>
________________________________________________________-->
   <title><type>ltree</type> 函数</title>
<!-- pgdoc-cn_end sig_en=4be2090d21151e330b23eb6548166268 -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=aea31b510d403ec475cd76fb26ed5e1f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aea31b510d403ec475cd76fb26ed5e1f -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=9457db21dd5d0902284286654a717d6f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm><primary>subltree</primary></indexterm>
        <function>subltree</function> ( <type>ltree</type>, <parameter>start</parameter> <type>integer</type>, <parameter>end</parameter> <type>integer</type> )
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        Returns subpath of <type>ltree</type> from
        position <parameter>start</parameter> to
        position <parameter>end</parameter>-1 (counting from 0).
       </para>
       <para>
        <literal>subltree('Top.Child1.Child2', 1, 2)</literal>
        <returnvalue>Child1</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm><primary>subltree</primary></indexterm>
        <function>subltree</function> ( <type>ltree</type>, <parameter>start</parameter> <type>integer</type>, <parameter>end</parameter> <type>integer</type> )
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        返回从位置<parameter>start</parameter>到位置<parameter>end</parameter>-1的<type>ltree</type>的子路径(从0开始计数)。
       </para>
       <para>
        <literal>subltree('Top.Child1.Child2', 1, 2)</literal>
        <returnvalue>Child1</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9457db21dd5d0902284286654a717d6f -->

<!-- pgdoc-cn_start sig_en=475dc2c98f7767afe0f993c1f383d378 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm><primary>subpath</primary></indexterm>
        <function>subpath</function> ( <type>ltree</type>, <parameter>offset</parameter> <type>integer</type>, <parameter>len</parameter> <type>integer</type> )
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        Returns subpath of <type>ltree</type> starting at
        position <parameter>offset</parameter>, with
        length <parameter>len</parameter>.  If <parameter>offset</parameter>
        is negative, subpath starts that far from the end of the path.
        If <parameter>len</parameter> is negative, leaves that many labels off
        the end of the path.
       </para>
       <para>
        <literal>subpath('Top.Child1.Child2', 0, 2)</literal>
        <returnvalue>Top.Child1</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm><primary>subpath</primary></indexterm>
        <function>subpath</function> ( <type>ltree</type>, <parameter>offset</parameter> <type>integer</type>, <parameter>len</parameter> <type>integer</type> )
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        返回从位置<parameter>offset</parameter>开始的<type>ltree</type>的子路径，长度为<parameter>len</parameter>。
        如果<parameter>offset</parameter>为负，则子路径从距离路径终点的远端开始。如果<parameter>len</parameter>为负，将许多标签留在路径的末尾。
       </para>
       <para>
        <literal>subpath('Top.Child1.Child2', 0, 2)</literal>
        <returnvalue>Top.Child1</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=475dc2c98f7767afe0f993c1f383d378 -->

<!-- pgdoc-cn_start sig_en=74c86003f5e65688d4aca27ea1559a1d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>subpath</function> ( <type>ltree</type>, <parameter>offset</parameter> <type>integer</type> )
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        Returns subpath of <type>ltree</type> starting at
        position <parameter>offset</parameter>, extending to end of path.
        If <parameter>offset</parameter> is negative, subpath starts that far
        from the end of the path.
       </para>
       <para>
        <literal>subpath('Top.Child1.Child2', 1)</literal>
        <returnvalue>Child1.Child2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>subpath</function> ( <type>ltree</type>, <parameter>offset</parameter> <type>integer</type> )
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        返回从位置<parameter>offset</parameter>开始的<type>ltree</type>的子路径，扩展到路径的结束。
        如果<parameter>offset</parameter>为负，则子路径从距离路径终点的远端开始。
       </para>
       <para>
        <literal>subpath('Top.Child1.Child2', 1)</literal>
        <returnvalue>Child1.Child2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=74c86003f5e65688d4aca27ea1559a1d -->

<!-- pgdoc-cn_start sig_en=ff2c9923aee1eebd1453cf0c6eaad41f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm><primary>nlevel</primary></indexterm>
        <function>nlevel</function> ( <type>ltree</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns number of labels in path.
       </para>
       <para>
        <literal>nlevel('Top.Child1.Child2')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm><primary>nlevel</primary></indexterm>
        <function>nlevel</function> ( <type>ltree</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回路径中标签的数量。
       </para>
       <para>
        <literal>nlevel('Top.Child1.Child2')</literal>
        <returnvalue>3</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ff2c9923aee1eebd1453cf0c6eaad41f -->

<!-- pgdoc-cn_start sig_en=f5c4ddbd7d0ac399d26a4073a2b6ca37 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm><primary>index</primary></indexterm>
        <function>index</function> ( <parameter>a</parameter> <type>ltree</type>, <parameter>b</parameter> <type>ltree</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns position of first occurrence of <parameter>b</parameter> in
        <parameter>a</parameter>, or -1 if not found.
       </para>
       <para>
        <literal>index('0.1.2.3.5.4.5.6.8.5.6.8', '5.6')</literal>
        <returnvalue>6</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm><primary>index</primary></indexterm>
        <function>index</function> ( <parameter>a</parameter> <type>ltree</type>, <parameter>b</parameter> <type>ltree</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回<parameter>b</parameter>在<parameter>a</parameter>中第一次出现的位置，如果没有发现则返回-1。
       </para>
       <para>
        <literal>index('0.1.2.3.5.4.5.6.8.5.6.8', '5.6')</literal>
        <returnvalue>6</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f5c4ddbd7d0ac399d26a4073a2b6ca37 -->

<!-- pgdoc-cn_start sig_en=d5d2760181520c8da6111b5d0fed1342 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>index</function> ( <parameter>a</parameter> <type>ltree</type>,  <parameter>b</parameter> <type>ltree</type>, <parameter>offset</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns position of first occurrence of <parameter>b</parameter>
        in <parameter>a</parameter>, or -1 if not found.  The search starts at
        position <parameter>offset</parameter>;
        negative <parameter>offset</parameter> means
        start <parameter>-offset</parameter> labels from the end of the path.
       </para>
       <para>
        <literal>index('0.1.2.3.5.4.5.6.8.5.6.8', '5.6', -4)</literal>
        <returnvalue>9</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>index</function> ( <parameter>a</parameter> <type>ltree</type>,  <parameter>b</parameter> <type>ltree</type>, <parameter>offset</parameter> <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回<parameter>b</parameter>在<parameter>a</parameter>中第一次出现的位置，如果没有发现则返回-1。
        搜索从位置<parameter>offset</parameter>开始;负的<parameter>offset</parameter>是指从路径的末端开始的<parameter>-offset</parameter>标签。
       </para>
       <para>
        <literal>index('0.1.2.3.5.4.5.6.8.5.6.8', '5.6', -4)</literal>
        <returnvalue>9</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d5d2760181520c8da6111b5d0fed1342 -->

<!-- pgdoc-cn_start sig_en=682edf28b65b4af07f279c069ac05043 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm><primary>text2ltree</primary></indexterm>
        <function>text2ltree</function> ( <type>text</type> )
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        Casts <type>text</type> to <type>ltree</type>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm><primary>text2ltree</primary></indexterm>
        <function>text2ltree</function> ( <type>text</type> )
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        转换 <type>text</type> 到 <type>ltree</type>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=682edf28b65b4af07f279c069ac05043 -->

<!-- pgdoc-cn_start sig_en=f9f1a46de12a6cadaba8831e7ad31b47 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm><primary>ltree2text</primary></indexterm>
        <function>ltree2text</function> ( <type>ltree</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Casts <type>ltree</type> to <type>text</type>.
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm><primary>ltree2text</primary></indexterm>
        <function>ltree2text</function> ( <type>ltree</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        转换 <type>ltree</type> 到 <type>text</type>。
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f9f1a46de12a6cadaba8831e7ad31b47 -->

<!-- pgdoc-cn_start sig_en=c21178bbf7d06cccdb1a5b6b809554fe sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm><primary>lca</primary></indexterm>
        <function>lca</function> ( <type>ltree</type> <optional>, <type>ltree</type> <optional>, ... </optional></optional> )
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        Computes longest common ancestor of paths
        (up to 8 arguments are supported).
       </para>
       <para>
        <literal>lca('1.2.3', '1.2.3.4.5.6')</literal>
        <returnvalue>1.2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm><primary>lca</primary></indexterm>
        <function>lca</function> ( <type>ltree</type> <optional>, <type>ltree</type> <optional>, ... </optional></optional> )
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        计算路径的最长公共祖先(最多可支持8个参数)。
       </para>
       <para>
        <literal>lca('1.2.3', '1.2.3.4.5.6')</literal>
        <returnvalue>1.2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=c21178bbf7d06cccdb1a5b6b809554fe -->

<!-- pgdoc-cn_start sig_en=1247bb21ab7c795e8bee1259fa33a273 sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>lca</function> ( <type>ltree[]</type> )
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        Computes longest common ancestor of paths in array.
       </para>
       <para>
        <literal>lca(array['1.2.3'::ltree,'1.2.3.4'])</literal>
        <returnvalue>1.2</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <function>lca</function> ( <type>ltree[]</type> )
        <returnvalue>ltree</returnvalue>
       </para>
       <para>
        计算数组中的路径的最长公共祖先。
       </para>
       <para>
        <literal>lca(array['1.2.3'::ltree,'1.2.3.4'])</literal>
        <returnvalue>1.2</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=1247bb21ab7c795e8bee1259fa33a273 -->
     </tbody>
    </tgroup>
  </table>
 </sect2>

 <sect2>
<!-- pgdoc-cn_start sig_en=1dd306ead6471d4aaa831b08d5684b3f sig_cn_org=None source=14.1 
  <title>Indexes</title>
________________________________________________________-->
  <title>索引</title>
<!-- pgdoc-cn_end sig_en=1dd306ead6471d4aaa831b08d5684b3f -->
<!-- pgdoc-cn_start sig_en=4c7e90d269d7c7c0e37dca947ac6f65f sig_cn_org=None source=14.1 
  <para>
   <filename>ltree</filename> supports several types of indexes that can speed
   up the indicated operators:
  </para>
________________________________________________________-->
  <para>
   <filename>ltree</filename>支持一些能加速上述操作符的索引类型：
  </para>
<!-- pgdoc-cn_end sig_en=4c7e90d269d7c7c0e37dca947ac6f65f -->

  <itemizedlist>
   <listitem>
<!-- pgdoc-cn_start sig_en=d0d9a7c05d2e215ae304cccccb0f87ff sig_cn_org=None source=14.1 
    <para>
     B-tree index over <type>ltree</type>:
     <literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>=</literal>,
     <literal>&gt;=</literal>, <literal>&gt;</literal>
    </para>
________________________________________________________-->
    <para>
     <type>ltree</type>上的 B-树索引：
     <literal>&lt;</literal>、<literal>&lt;=</literal>、<literal>=</literal>、
     <literal>&gt;=</literal>、<literal>&gt;</literal>
    </para>
<!-- pgdoc-cn_end sig_en=d0d9a7c05d2e215ae304cccccb0f87ff -->
   </listitem>
   <listitem>
<!-- pgdoc-cn_start sig_en=74557f9c767a5ae070e809f227c80ff2 sig_cn_org=None source=14.1 
    <para>
     GiST index over <type>ltree</type> (<literal>gist_ltree_ops</literal>
     opclass):
     <literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>=</literal>,
     <literal>&gt;=</literal>, <literal>&gt;</literal>,
     <literal>@&gt;</literal>, <literal>&lt;@</literal>,
     <literal>@</literal>, <literal>~</literal>, <literal>?</literal>
    </para>
________________________________________________________-->
    <para>
     <type>ltree</type> 之上的GiST索引(<literal>gist_ltree_ops</literal> opclass):
     <literal>&lt;</literal>、<literal>&lt;=</literal>、<literal>=</literal>、
     <literal>&gt;=</literal>、<literal>&gt;</literal>、
     <literal>@&gt;</literal>、<literal>&lt;@</literal>、
     <literal>@</literal>、<literal>~</literal>、<literal>?</literal>
    </para>
<!-- pgdoc-cn_end sig_en=74557f9c767a5ae070e809f227c80ff2 -->
<!-- pgdoc-cn_start sig_en=e5dbc0f54f78d37412c751de1db0122d sig_cn_org=577dfe8032398f60e79254df58e0c1a2 source=15.7 
    <para>
     <literal>gist_ltree_ops</literal> GiST opclass approximates a set of
     path labels as a bitmap signature.  Its optional integer parameter
     <literal>siglen</literal> determines the
     signature length in bytes.  The default signature length is 8 bytes.
     The length must be a positive multiple of <type>int</type> alignment
     (4 bytes on most machines)) up to 2024.  Longer
     signatures lead to a more precise search (scanning a smaller fraction of the index and
     fewer heap pages), at the cost of a larger index.
    </para>
________________________________________________________-->
    <para>
     <literal>gist_ltree_ops</literal> GiST opclass近似将一组路径标签表示为位图签名。
     其可选整数参数<literal>siglen</literal>确定签名长度（以字节为单位）。
     默认签名长度为8字节。长度必须是<type>int</type>对齐的正整数倍（大多数机器上为4字节），
     最多为2024。更长的签名会导致更精确的搜索（扫描索引的较小部分和较少的堆页），
     但会增加索引的大小。
</para>
<!-- pgdoc-cn_end sig_en=e5dbc0f54f78d37412c751de1db0122d -->
<!-- pgdoc-cn_start sig_en=6df568024ff59974d2e2b8fbb20f1c0c sig_cn_org=None source=14.1 
    <para>
     Example of creating such an index with the default signature length of 8 bytes:
    </para>
________________________________________________________-->
    <para>
     创建默认签名长度为8字节的索引的例子：
    </para>
<!-- pgdoc-cn_end sig_en=6df568024ff59974d2e2b8fbb20f1c0c -->
<!-- pgdoc-cn_start sig_en=6063bc4ae57448a769d52c8126f06f38 sig_cn_org=None source=14.1 
<programlisting>
CREATE INDEX path_gist_idx ON test USING GIST (path);
</programlisting>
________________________________________________________-->
<programlisting>
CREATE INDEX path_gist_idx ON test USING GIST (path);
</programlisting>
<!-- pgdoc-cn_end sig_en=6063bc4ae57448a769d52c8126f06f38 -->
<!-- pgdoc-cn_start sig_en=3dcd0514de22cb0d046e13ee273626fe sig_cn_org=None source=14.1 
    <para>
     Example of creating such an index with a signature length of 100 bytes:
    </para>
________________________________________________________-->
    <para>
     创建签名长度为100字节的索引的例子:
    </para>
<!-- pgdoc-cn_end sig_en=3dcd0514de22cb0d046e13ee273626fe -->
<!-- pgdoc-cn_start sig_en=ca53c6d3ed716a478ebe6b646fda0a34 sig_cn_org=None source=14.1 
<programlisting>
CREATE INDEX path_gist_idx ON test USING GIST (path gist_ltree_ops(siglen=100));
</programlisting>
________________________________________________________-->
<programlisting>
CREATE INDEX path_gist_idx ON test USING GIST (path gist_ltree_ops(siglen=100));
</programlisting>
<!-- pgdoc-cn_end sig_en=ca53c6d3ed716a478ebe6b646fda0a34 -->
   </listitem>
   <listitem>
<!-- pgdoc-cn_start sig_en=0c94b372d02eb71d737fc132fccb83f5 sig_cn_org=None source=14.1 
    <para>
     GiST index over <type>ltree[]</type> (<literal>gist__ltree_ops</literal>
     opclass):
     <literal>ltree[] &lt;@ ltree</literal>, <literal>ltree @&gt; ltree[]</literal>,
     <literal>@</literal>, <literal>~</literal>, <literal>?</literal>
    </para>
________________________________________________________-->
    <para>
     <type>ltree[]</type> 之上的GiST索引(<literal>gist__ltree_ops</literal> opclass):
     <literal>ltree[] &lt;@ ltree</literal>、<literal>ltree @&gt; ltree[]</literal>、
     <literal>@</literal>、<literal>~</literal>、<literal>?</literal>
    </para>
<!-- pgdoc-cn_end sig_en=0c94b372d02eb71d737fc132fccb83f5 -->
<!-- pgdoc-cn_start sig_en=293b8a2131129fd90b74c77edd3d5723 sig_cn_org=None source=14.1 
    <para>
     <literal>gist__ltree_ops</literal> GiST opclass works similarly to
     <literal>gist_ltree_ops</literal> and also takes signature length as
     a parameter.  The default value of <literal>siglen</literal> in
      <literal>gist__ltree_ops</literal> is 28 bytes.
    </para>
________________________________________________________-->
    <para>
     <literal>gist__ltree_ops</literal> GiST opclass 的工作类似于<literal>gist_ltree_ops</literal> 并且也使用签名长度作为参数。
     <literal>gist__ltree_ops</literal>中的<literal>siglen</literal>的默认值为28字节。
    </para>
<!-- pgdoc-cn_end sig_en=293b8a2131129fd90b74c77edd3d5723 -->
<!-- pgdoc-cn_start sig_en=b2ef333ec66e6af818649fff1b99bd8c sig_cn_org=None source=14.1 
    <para>
     Example of creating such an index with the default signature length of 28 bytes:
    </para>
________________________________________________________-->
    <para>
     创建这样一个默认签名长度为28字节的索引的例子：
    </para>
<!-- pgdoc-cn_end sig_en=b2ef333ec66e6af818649fff1b99bd8c -->
<!-- pgdoc-cn_start sig_en=e5a814ab61dfe73c8b04a0a6beebb217 sig_cn_org=None source=14.1 
<programlisting>
CREATE INDEX path_gist_idx ON test USING GIST (array_path);
</programlisting>
________________________________________________________-->
<programlisting>
CREATE INDEX path_gist_idx ON test USING GIST (array_path);
</programlisting>
<!-- pgdoc-cn_end sig_en=e5a814ab61dfe73c8b04a0a6beebb217 -->
<!-- pgdoc-cn_start sig_en=3dcd0514de22cb0d046e13ee273626fe sig_cn_org=None source=14.1 
    <para>
     Example of creating such an index with a signature length of 100 bytes:
    </para>
________________________________________________________-->
    <para>
     创建签名长度为100字节的索引的例子:
    </para>
<!-- pgdoc-cn_end sig_en=3dcd0514de22cb0d046e13ee273626fe -->
<!-- pgdoc-cn_start sig_en=0bcc8f0d948090d20b11e894ba73af53 sig_cn_org=None source=14.1 
<programlisting>
CREATE INDEX path_gist_idx ON test USING GIST (array_path gist__ltree_ops(siglen=100));
</programlisting>
________________________________________________________-->
<programlisting>
CREATE INDEX path_gist_idx ON test USING GIST (array_path gist__ltree_ops(siglen=100));
</programlisting>
<!-- pgdoc-cn_end sig_en=0bcc8f0d948090d20b11e894ba73af53 -->
<!-- pgdoc-cn_start sig_en=3657b75e8873759846748b14d07f89f1 sig_cn_org=None source=14.1 
    <para>
     Note: This index type is lossy.
    </para>
________________________________________________________-->
    <para>
     注意：这种索引类型是有损的。
    </para>
<!-- pgdoc-cn_end sig_en=3657b75e8873759846748b14d07f89f1 -->
   </listitem>
  </itemizedlist>
 </sect2>

 <sect2>
<!-- pgdoc-cn_start sig_en=6743e90168b15ae7e535b6fe36ceadd5 sig_cn_org=None source=14.1 
  <title>Example</title>
________________________________________________________-->
  <title>例子</title>
<!-- pgdoc-cn_end sig_en=6743e90168b15ae7e535b6fe36ceadd5 -->

<!-- pgdoc-cn_start sig_en=2172bb48f2c7b838662a67e991db3af1 sig_cn_org=None source=14.1 
  <para>
   This example uses the following data (also available in file
   <filename>contrib/ltree/ltreetest.sql</filename> in the source distribution):
  </para>
________________________________________________________-->
  <para>
   这个例子使用下列数据（在源代码发布的<filename>contrib/ltree/ltreetest.sql</filename>文件中也有）：
  </para>
<!-- pgdoc-cn_end sig_en=2172bb48f2c7b838662a67e991db3af1 -->

<!-- pgdoc-cn_start sig_en=9b91dadfdad3f3f4e9827d2ce4d53479 sig_cn_org=None source=14.1 
<programlisting>
CREATE TABLE test (path ltree);
INSERT INTO test VALUES ('Top');
INSERT INTO test VALUES ('Top.Science');
INSERT INTO test VALUES ('Top.Science.Astronomy');
INSERT INTO test VALUES ('Top.Science.Astronomy.Astrophysics');
INSERT INTO test VALUES ('Top.Science.Astronomy.Cosmology');
INSERT INTO test VALUES ('Top.Hobbies');
INSERT INTO test VALUES ('Top.Hobbies.Amateurs_Astronomy');
INSERT INTO test VALUES ('Top.Collections');
INSERT INTO test VALUES ('Top.Collections.Pictures');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy.Stars');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy.Galaxies');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy.Astronauts');
CREATE INDEX path_gist_idx ON test USING GIST (path);
CREATE INDEX path_idx ON test USING BTREE (path);
</programlisting>
________________________________________________________-->
<programlisting>
CREATE TABLE test (path ltree);
INSERT INTO test VALUES ('Top');
INSERT INTO test VALUES ('Top.Science');
INSERT INTO test VALUES ('Top.Science.Astronomy');
INSERT INTO test VALUES ('Top.Science.Astronomy.Astrophysics');
INSERT INTO test VALUES ('Top.Science.Astronomy.Cosmology');
INSERT INTO test VALUES ('Top.Hobbies');
INSERT INTO test VALUES ('Top.Hobbies.Amateurs_Astronomy');
INSERT INTO test VALUES ('Top.Collections');
INSERT INTO test VALUES ('Top.Collections.Pictures');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy.Stars');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy.Galaxies');
INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy.Astronauts');
CREATE INDEX path_gist_idx ON test USING GIST (path);
CREATE INDEX path_idx ON test USING BTREE (path);
</programlisting>
<!-- pgdoc-cn_end sig_en=9b91dadfdad3f3f4e9827d2ce4d53479 -->

<!-- pgdoc-cn_start sig_en=1b33fb7847b8b0181a7f88490ffd47d7 sig_cn_org=None source=14.1 
  <para>
   Now, we have a table <structname>test</structname> populated with data describing
   the hierarchy shown below:
  </para>
________________________________________________________-->
  <para>
   现在，我们有一个表<structname>test</structname>，它被填充了描述下列层次的数据：
  </para>
<!-- pgdoc-cn_end sig_en=1b33fb7847b8b0181a7f88490ffd47d7 -->

<literallayout class="monospaced">
                        Top
                     /   |  \
             Science Hobbies Collections
                 /       |              \
        Astronomy   Amateurs_Astronomy Pictures
           /  \                            |
Astrophysics  Cosmology                Astronomy
                                        /  |    \
                                 Galaxies Stars Astronauts
</literallayout>

<!-- pgdoc-cn_start sig_en=0839678c7b111162edd33a547cda3f6f sig_cn_org=None source=14.1 
  <para>
   We can do inheritance:
<screen>
ltreetest=&gt; SELECT path FROM test WHERE path &lt;@ 'Top.Science';
                path
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Top.Science
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
(4 rows)
</screen>
  </para>
________________________________________________________-->
  <para>
   我们可以做继承：
<screen>
ltreetest=&gt; SELECT path FROM test WHERE path &lt;@ 'Top.Science';
                path
------------------------------------
 Top.Science
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
(4 rows)
</screen>
  </para>
<!-- pgdoc-cn_end sig_en=0839678c7b111162edd33a547cda3f6f -->

<!-- pgdoc-cn_start sig_en=64230bcc1959cc847786893fc12502fb sig_cn_org=None source=14.1 
  <para>
   Here are some examples of path matching:
<screen>
ltreetest=&gt; SELECT path FROM test WHERE path ~ '*.Astronomy.*';
                     path
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
 Top.Collections.Pictures.Astronomy
 Top.Collections.Pictures.Astronomy.Stars
 Top.Collections.Pictures.Astronomy.Galaxies
 Top.Collections.Pictures.Astronomy.Astronauts
(7 rows)

ltreetest=&gt; SELECT path FROM test WHERE path ~ '*.!pictures@.Astronomy.*';
                path
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
(3 rows)
</screen>
  </para>
________________________________________________________-->
  <para>
   这里是一些路径匹配的例子：
<screen>
ltreetest=&gt; SELECT path FROM test WHERE path ~ '*.Astronomy.*';
                     path
-----------------------------------------------
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
 Top.Collections.Pictures.Astronomy
 Top.Collections.Pictures.Astronomy.Stars
 Top.Collections.Pictures.Astronomy.Galaxies
 Top.Collections.Pictures.Astronomy.Astronauts
(7 rows)

ltreetest=&gt; SELECT path FROM test WHERE path ~ '*.!pictures@.Astronomy.*';
                path
------------------------------------
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
(3 rows)
</screen>
  </para>
<!-- pgdoc-cn_end sig_en=64230bcc1959cc847786893fc12502fb -->

<!-- pgdoc-cn_start sig_en=dae834a7ff3a91ba98e635e7d407ca64 sig_cn_org=None source=14.1 
  <para>
   Here are some examples of full text search:
<screen>
ltreetest=&gt; SELECT path FROM test WHERE path @ 'Astro*% &amp; !pictures@';
                path
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
 Top.Hobbies.Amateurs_Astronomy
(4 rows)

ltreetest=&gt; SELECT path FROM test WHERE path @ 'Astro* &amp; !pictures@';
                path
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
(3 rows)
</screen>
  </para>
________________________________________________________-->
  <para>
   这里是一些全文搜索的例子：
<screen>
ltreetest=&gt; SELECT path FROM test WHERE path @ 'Astro*% &amp; !pictures@';
                path
------------------------------------
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
 Top.Hobbies.Amateurs_Astronomy
(4 rows)

ltreetest=&gt; SELECT path FROM test WHERE path @ 'Astro* &amp; !pictures@';
                path
------------------------------------
 Top.Science.Astronomy
 Top.Science.Astronomy.Astrophysics
 Top.Science.Astronomy.Cosmology
(3 rows)
</screen>
  </para>
<!-- pgdoc-cn_end sig_en=dae834a7ff3a91ba98e635e7d407ca64 -->

<!-- pgdoc-cn_start sig_en=33bf2e3a79a72cb2494e1277debb8063 sig_cn_org=None source=14.1 
  <para>
   Path construction using functions:
<screen>
ltreetest=&gt; SELECT subpath(path,0,2)||'Space'||subpath(path,2) FROM test WHERE path &lt;@ 'Top.Science.Astronomy';
                 ?column?
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Top.Science.Space.Astronomy
 Top.Science.Space.Astronomy.Astrophysics
 Top.Science.Space.Astronomy.Cosmology
(3 rows)
</screen>
  </para>
________________________________________________________-->
  <para>
   使用函数的路径构建：
<screen>
ltreetest=&gt; SELECT subpath(path,0,2)||'Space'||subpath(path,2) FROM test WHERE path &lt;@ 'Top.Science.Astronomy';
                 ?column?
------------------------------------------
 Top.Science.Space.Astronomy
 Top.Science.Space.Astronomy.Astrophysics
 Top.Science.Space.Astronomy.Cosmology
(3 rows)
</screen>
  </para>
<!-- pgdoc-cn_end sig_en=33bf2e3a79a72cb2494e1277debb8063 -->

<!-- pgdoc-cn_start sig_en=2240e553d3b1cdd3273671c2b559ec68 sig_cn_org=None source=14.1 
  <para>
   We could simplify this by creating an SQL function that inserts a label
   at a specified position in a path:
<screen>
CREATE FUNCTION ins_label(ltree, int, text) RETURNS ltree
    AS 'select subpath($1,0,$2) || $3 || subpath($1,$2);'
    LANGUAGE SQL IMMUTABLE;

ltreetest=&gt; SELECT ins_label(path,2,'Space') FROM test WHERE path &lt;@ 'Top.Science.Astronomy';
                ins_label
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Top.Science.Space.Astronomy
 Top.Science.Space.Astronomy.Astrophysics
 Top.Science.Space.Astronomy.Cosmology
(3 rows)
</screen>
  </para>
________________________________________________________-->
  <para>
   我们可以通过常见一个在路径中指定位置插入标签的 SQL 函数来简化：
<screen>
CREATE FUNCTION ins_label(ltree, int, text) RETURNS ltree
    AS 'select subpath($1,0,$2) || $3 || subpath($1,$2);'
    LANGUAGE SQL IMMUTABLE;

ltreetest=&gt; SELECT ins_label(path,2,'Space') FROM test WHERE path &lt;@ 'Top.Science.Astronomy';
                ins_label
------------------------------------------
 Top.Science.Space.Astronomy
 Top.Science.Space.Astronomy.Astrophysics
 Top.Science.Space.Astronomy.Cosmology
(3 rows)
</screen>
  </para>
<!-- pgdoc-cn_end sig_en=2240e553d3b1cdd3273671c2b559ec68 -->
 </sect2>

 <sect2>
<!-- pgdoc-cn_start sig_en=86ddd9561f97c5e93df34c49b9e90ef8 sig_cn_org=None source=14.1 
  <title>Transforms</title>
________________________________________________________-->
  <title>转换</title>
<!-- pgdoc-cn_end sig_en=86ddd9561f97c5e93df34c49b9e90ef8 -->

<!-- pgdoc-cn_start sig_en=0e04ddb9d3edae0089f9a5231c4fd491 sig_cn_org=9e9abdc950fd6b56a2b163b567909b31 source=15.7 
  <para>
   The <literal>ltree_plpython3u</literal> extension implements transforms for
   the <type>ltree</type> type for PL/Python. If installed and specified when
   creating a function, <type>ltree</type> values are mapped to Python lists.
   (The reverse is currently not supported, however.)
  </para>
________________________________________________________-->
  <para>
   <literal>ltree_plpython3u</literal>扩展实现了PL/Python的<type>ltree</type>类型的转换。
   如果安装并在创建函数时指定，<type>ltree</type>值将映射到Python列表。
   （目前不支持反向操作。）
</para>
<!-- pgdoc-cn_end sig_en=0e04ddb9d3edae0089f9a5231c4fd491 -->

  <caution>
<!-- pgdoc-cn_start sig_en=d80229aa5b68009fa681e417f7e76f69 sig_cn_org=fcb1b116f2cc82865dbc8615b1d2a9d2 source=15.7 
   <para>
    It is strongly recommended that the transform extension be installed in
    the same schema as <filename>ltree</filename>.  Otherwise there are
    installation-time security hazards if a transform extension's schema
    contains objects defined by a hostile user.
   </para>
________________________________________________________-->
   <para>
    强烈建议将转换扩展程序安装在与<filename>ltree</filename>相同的模式中。
    否则，如果转换扩展程序的模式包含由敌对用户定义的对象，则存在安装时的安全风险。
   </para>
<!-- pgdoc-cn_end sig_en=d80229aa5b68009fa681e417f7e76f69 -->
  </caution>
 </sect2>

 <sect2>
<!-- pgdoc-cn_start sig_en=c9d18a21a6b8c7d5325e8feeb56b7420 sig_cn_org=None source=14.1 
  <title>Authors</title>
________________________________________________________-->
  <title>作者</title>
<!-- pgdoc-cn_end sig_en=c9d18a21a6b8c7d5325e8feeb56b7420 -->

<!-- pgdoc-cn_start sig_en=26c59f3a3b05cbc437bbae95c5ad80f2 sig_cn_org=None source=14.1 
  <para>
   All work was done by Teodor Sigaev (<email>teodor@stack.net</email>) and
   Oleg Bartunov (<email>oleg@sai.msu.su</email>). See
   <ulink url="http://www.sai.msu.su/~megera/postgres/gist/"></ulink> for
   additional information. Authors would like to thank Eugeny Rodichev for
   helpful discussions. Comments and bug reports are welcome.
  </para>
________________________________________________________-->
  <para>
   所有工作都是 Teodor Sigaev（<email>teodor@stack.net</email>）和
   Oleg Bartunov（<email>oleg@sai.msu.su</email>）完成的。额外信息可见
   <ulink url="http://www.sai.msu.su/~megera/postgres/gist/"></ulink>。作者还要感谢 Eugeny Rodichev 参与讨论。欢迎评论和缺陷报告。
  </para>
<!-- pgdoc-cn_end sig_en=26c59f3a3b05cbc437bbae95c5ad80f2 -->
 </sect2>

</sect1>
