<!-- doc/src/sgml/queries.sgml -->

<chapter id="queries">
<!-- pgdoc-cn_start sig_en=8eb6afd41be7e5538b169de4d48df3f4 sig_cn_org=None source=14.1 
 <title>Queries</title>
________________________________________________________-->
 <title>查询</title>
<!-- pgdoc-cn_end sig_en=8eb6afd41be7e5538b169de4d48df3f4 -->

<!-- pgdoc-cn_start sig_en=b4bc62494a2695e12dbd4fb8876b2b30 sig_cn_org=None source=14.1 
 <indexterm zone="queries">
  <primary>query</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="queries">
  <primary>查询</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=b4bc62494a2695e12dbd4fb8876b2b30 -->

<!-- pgdoc-cn_start sig_en=b990dc0a914037db7a81555ff69066b7 sig_cn_org=None source=14.1 
 <indexterm zone="queries">
  <primary>SELECT</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="queries">
  <primary>SELECT</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=b990dc0a914037db7a81555ff69066b7 -->

<!-- pgdoc-cn_start sig_en=510fb389cdb015219ca559c45cfe34d1 sig_cn_org=None source=14.1 
 <para>
  The previous chapters explained how to create tables, how to fill
  them with data, and how to manipulate that data.  Now we finally
  discuss how to retrieve the data from the database.
 </para>
________________________________________________________-->
 <para>
  前面的章节解释了如何创建表、如何用数据填充它们 以及如何操纵那些数据。现在我们终于可以讨论如何从数据库中检索数据了。
 </para>
<!-- pgdoc-cn_end sig_en=510fb389cdb015219ca559c45cfe34d1 -->


 <sect1 id="queries-overview">
<!-- pgdoc-cn_start sig_en=13508788fd8dee2d1f9c928870e99338 sig_cn_org=None source=14.1 
  <title>Overview</title>
________________________________________________________-->
  <title>概述</title>
<!-- pgdoc-cn_end sig_en=13508788fd8dee2d1f9c928870e99338 -->

<!-- pgdoc-cn_start sig_en=29f0197071d2b64b7eed06737238d233 sig_cn_org=None source=14.1 
  <para>
   The process of retrieving or the command to retrieve data from a
   database is called a <firstterm>query</firstterm>.  In SQL the
   <link linkend="sql-select"><command>SELECT</command></link> command is
   used to specify queries.  The general syntax of the
   <command>SELECT</command> command is
<synopsis>
<optional>WITH <replaceable>with_queries</replaceable></optional> SELECT <replaceable>select_list</replaceable> FROM <replaceable>table_expression</replaceable> <optional><replaceable>sort_specification</replaceable></optional>
</synopsis>
   The following sections describe the details of the select list, the
   table expression, and the sort specification.  <literal>WITH</literal>
   queries are treated last since they are an advanced feature.
  </para>
________________________________________________________-->
  <para>
   从数据库中检索数据的过程或命令叫做<firstterm>查询</firstterm>。在 SQL 里<link linkend="sql-select"><command>SELECT</command></link>命令用于指定查询。 <command>SELECT</command>命令的一般语法是
<synopsis>
<optional>WITH <replaceable>with_queries</replaceable></optional> SELECT <replaceable>select_list</replaceable> FROM <replaceable>table_expression</replaceable> <optional><replaceable>sort_specification</replaceable></optional>
</synopsis>
   下面几个小节描述选择列表、表表达式和排序声明的细节。<literal>WITH</literal>查询等高级特性将在最后讨论。
  </para>
<!-- pgdoc-cn_end sig_en=29f0197071d2b64b7eed06737238d233 -->

<!-- pgdoc-cn_start sig_en=01b624146562fa4cda9f75f68cef7543 sig_cn_org=None source=14.1 
  <para>
   A simple kind of query has the form:
<programlisting>
SELECT * FROM table1;
</programlisting>
  Assuming that there is a table called <literal>table1</literal>,
  this command would retrieve all rows and all user-defined columns from
  <literal>table1</literal>.  (The method of retrieval depends on the
  client application.  For example, the
  <application>psql</application> program will display an ASCII-art
  table on the screen, while client libraries will offer functions to
  extract individual values from the query result.)  The select list
  specification <literal>*</literal> means all columns that the table
  expression happens to provide.  A select list can also select a
  subset of the available columns or make calculations using the
  columns.  For example, if
  <literal>table1</literal> has columns named <literal>a</literal>,
  <literal>b</literal>, and <literal>c</literal> (and perhaps others) you can make
  the following query:
<programlisting>
SELECT a, b + c FROM table1;
</programlisting>
  (assuming that <literal>b</literal> and <literal>c</literal> are of a numerical
  data type).
  See <xref linkend="queries-select-lists"/> for more details.
 </para>
________________________________________________________-->
  <para>
   一个简单类型的查询的形式：
<programlisting>
SELECT * FROM table1;
</programlisting>
  假设有一个表叫做<literal>table1</literal>，这条命令将<literal>table1</literal>中检索所有行和所有用户定义的列（检索的方法取决于客户端应用。例如，<application>psql</application>程序将在屏幕上显示一个 ASCII 形式的表格， 而客户端库将提供函数来从检索结果中抽取单个值）。 选择列表声明<literal>*</literal>意味着所有表表达式提供的列。 一个选择列表也可以选择可用列的一个子集或者在使用它们之前对列进行计算。例如，如果<literal>table1</literal>有叫做<literal>a</literal>、<literal>b</literal>和<literal>c</literal>的列（可能还有其他），那么你可以用下面的查询：
<programlisting>
SELECT a, b + c FROM table1;
</programlisting>
  （假设<literal>b</literal>和<literal>c</literal>都是数字数据类型）。 参阅<xref linkend="queries-select-lists"/>获取更多细节。
 </para>
<!-- pgdoc-cn_end sig_en=01b624146562fa4cda9f75f68cef7543 -->

<!-- pgdoc-cn_start sig_en=eeef08353ab31ae11aeeb0a4fb8af834 sig_cn_org=None source=14.1 
 <para>
  <literal>FROM table1</literal> is a simple kind of
  table expression: it reads just one table.  In general, table
  expressions can be complex constructs of base tables, joins, and
  subqueries.  But you can also omit the table expression entirely and
  use the <command>SELECT</command> command as a calculator:
<programlisting>
SELECT 3 * 4;
</programlisting>
  This is more useful if the expressions in the select list return
  varying results.  For example, you could call a function this way:
<programlisting>
SELECT random();
</programlisting>
  </para>
________________________________________________________-->
 <para>
  <literal>FROM table1</literal>是一种非常简单的表表达式：它只读取了一个表。通常，表表达式可以是基本表、连接和子查询组成的复杂结构。 但你也可以省略整个表表达式而把<command>SELECT</command>命令当做一个计算器：
<programlisting>
SELECT 3 * 4;
</programlisting>
  如果选择列表里的表达式返回变化的结果，那么这就更有用了。例如，你可以用这种方法调用函数：
<programlisting>
SELECT random();
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=eeef08353ab31ae11aeeb0a4fb8af834 -->
 </sect1>


 <sect1 id="queries-table-expressions">
<!-- pgdoc-cn_start sig_en=72d0c249d450e0e722d88ff16774e21d sig_cn_org=None source=14.1 
  <title>Table Expressions</title>
________________________________________________________-->
  <title>表表达式</title>
<!-- pgdoc-cn_end sig_en=72d0c249d450e0e722d88ff16774e21d -->

<!-- pgdoc-cn_start sig_en=686a65aaddcabf36d552f3e5a40bb566 sig_cn_org=None source=14.1 
  <indexterm zone="queries-table-expressions">
   <primary>table expression</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="queries-table-expressions">
   <primary>表表达式</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=686a65aaddcabf36d552f3e5a40bb566 -->

<!-- pgdoc-cn_start sig_en=492cb0998ae14c7a0ab0a9ef9f6c2295 sig_cn_org=None source=14.1 
  <para>
   A <firstterm>table expression</firstterm> computes a table.  The
   table expression contains a <literal>FROM</literal> clause that is
   optionally followed by <literal>WHERE</literal>, <literal>GROUP BY</literal>, and
   <literal>HAVING</literal> clauses.  Trivial table expressions simply refer
   to a table on disk, a so-called base table, but more complex
   expressions can be used to modify or combine base tables in various
   ways.
  </para>
________________________________________________________-->
  <para>
   <firstterm>表表达式</firstterm>计算一个表。该表表达式包含一个<literal>FROM</literal>子句，该子句后面可以根据需要选用<literal>WHERE</literal>、<literal>GROUP BY</literal>和<literal>HAVING</literal>子句。最简单的表表达式只是引用磁盘上的一个表，一个所谓的基本表，但是我们可以用更复杂的表表达式以多种方法修改或组合基本表。
  </para>
<!-- pgdoc-cn_end sig_en=492cb0998ae14c7a0ab0a9ef9f6c2295 -->

<!-- pgdoc-cn_start sig_en=44cfc0db3975b49b8555ec4aa16791a3 sig_cn_org=None source=14.1 
  <para>
   The optional <literal>WHERE</literal>, <literal>GROUP BY</literal>, and
   <literal>HAVING</literal> clauses in the table expression specify a
   pipeline of successive transformations performed on the table
   derived in the <literal>FROM</literal> clause.  All these transformations
   produce a virtual table that provides the rows that are passed to
   the select list to compute the output rows of the query.
  </para>
________________________________________________________-->
  <para>
   表表达式里可选的<literal>WHERE</literal>、<literal>GROUP BY</literal>和<literal>HAVING</literal>子句指定一系列对源自<literal>FROM</literal>子句的表的转换操作。所有这些转换最后生成一个虚拟表，它提供行传递给选择列表计算查询的输出行。
  </para>
<!-- pgdoc-cn_end sig_en=44cfc0db3975b49b8555ec4aa16791a3 -->

  <sect2 id="queries-from">
<!-- pgdoc-cn_start sig_en=2b5cdfeb309b5a9e7b7df0ca8636736f sig_cn_org=None source=14.1 
   <title>The <literal>FROM</literal> Clause</title>
________________________________________________________-->
   <title><literal>FROM</literal>子句</title>
<!-- pgdoc-cn_end sig_en=2b5cdfeb309b5a9e7b7df0ca8636736f -->

<!-- pgdoc-cn_start sig_en=005aec5403ea945a8651e95dfe8c5ff0 sig_cn_org=None source=14.1 
   <para>
    The <link linkend="sql-from"><literal>FROM</literal></link> clause derives a
    table from one or more other tables given in a comma-separated
    table reference list.
<synopsis>
FROM <replaceable>table_reference</replaceable> <optional>, <replaceable>table_reference</replaceable> <optional>, ...</optional></optional>
</synopsis>

    A table reference can be a table name (possibly schema-qualified),
    or a derived table such as a subquery, a <literal>JOIN</literal> construct, or
    complex combinations of these.  If more than one table reference is
    listed in the <literal>FROM</literal> clause, the tables are cross-joined
    (that is, the Cartesian product of their rows is formed; see below).
    The result of the <literal>FROM</literal> list is an intermediate virtual
    table that can then be subject to
    transformations by the <literal>WHERE</literal>, <literal>GROUP BY</literal>,
    and <literal>HAVING</literal> clauses and is finally the result of the
    overall table expression.
   </para>
________________________________________________________-->
   <para>
    <link linkend="sql-from"><literal>FROM</literal></link>子句从一个用逗号分隔的表引用列表中的一个或更多个其它表中生成一个表。
<synopsis>
FROM <replaceable>table_reference</replaceable> <optional>, <replaceable>table_reference</replaceable> <optional>, ...</optional></optional>
</synopsis>

    表引用可以是一个表名字（可能有模式限定）或者是一个生成的表， 例如子查询、一个<literal>JOIN</literal>结构或者这些东西的复杂组合。如果在<literal>FROM</literal>子句中引用了多于一个表， 那么它们被交叉连接（即构造它们的行的笛卡尔积，见下文）。<literal>FROM</literal>列表的结果是一个中间的虚拟表，该表可以进行由<literal>WHERE</literal>、<literal>GROUP BY</literal>和<literal>HAVING</literal>子句指定的转换，并最后生成全局的表表达式结果。
   </para>
<!-- pgdoc-cn_end sig_en=005aec5403ea945a8651e95dfe8c5ff0 -->

<!-- pgdoc-cn_start sig_en=b83fb8f7fb4b63601c4d77a737a8d0e7 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>ONLY</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>ONLY</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=b83fb8f7fb4b63601c4d77a737a8d0e7 -->

<!-- pgdoc-cn_start sig_en=41ba9ea589611da22d615e7e14d9739b sig_cn_org=None source=14.1 
   <para>
    When a table reference names a table that is the parent of a
    table inheritance hierarchy, the table reference produces rows of
    not only that table but all of its descendant tables, unless the
    key word <literal>ONLY</literal> precedes the table name.  However, the
    reference produces only the columns that appear in the named table
    &mdash; any columns added in subtables are ignored.
   </para>
________________________________________________________-->
   <para>
    如果一个表引用是一个简单的表名字并且它是表继承层次中的父表，那么该表引用将产生该表和它的后代表中的行，除非你在该表名字前面放上<literal>ONLY</literal>关键字。但是，这种引用只会产生出现在该命名表中的列 &mdash; 在子表中增加的列都会被忽略。
   </para>
<!-- pgdoc-cn_end sig_en=41ba9ea589611da22d615e7e14d9739b -->

<!-- pgdoc-cn_start sig_en=acbde4b9d38f987b30a6537ba1ace43b sig_cn_org=None source=14.1 
   <para>
    Instead of writing <literal>ONLY</literal> before the table name, you can write
    <literal>*</literal> after the table name to explicitly specify that descendant
    tables are included.  There is no real reason to use this syntax any more,
    because searching descendant tables is now always the default behavior.
    However, it is supported for compatibility with older releases.
   </para>
________________________________________________________-->
   <para>
    除了在表名前写<literal>ONLY</literal>，你可以在表名后面写上<literal>*</literal>来显式地指定要包括所有的后代表。没有实际的理由再继续使用这种语法，因为搜索后代表现在总是默认行为。不过，为了保持与旧版本的兼容性，仍然支持这种语法。
   </para>
<!-- pgdoc-cn_end sig_en=acbde4b9d38f987b30a6537ba1ace43b -->

   <sect3 id="queries-join">
<!-- pgdoc-cn_start sig_en=cd8326cabb46f749eeddf2d61dd465e4 sig_cn_org=None source=14.1 
    <title>Joined Tables</title>
________________________________________________________-->
    <title>连接表</title>
<!-- pgdoc-cn_end sig_en=cd8326cabb46f749eeddf2d61dd465e4 -->

<!-- pgdoc-cn_start sig_en=5355207afb35e4b2d2af74732590d610 sig_cn_org=None source=14.1 
    <indexterm zone="queries-join">
     <primary>join</primary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="queries-join">
     <primary>连接</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=5355207afb35e4b2d2af74732590d610 -->

<!-- pgdoc-cn_start sig_en=1579a10db0ea11c26169d41f74c74cb2 sig_cn_org=None source=14.1 
    <para>
     A joined table is a table derived from two other (real or
     derived) tables according to the rules of the particular join
     type.  Inner, outer, and cross-joins are available.
     The general syntax of a joined table is
<synopsis>
<replaceable>T1</replaceable> <replaceable>join_type</replaceable> <replaceable>T2</replaceable> <optional> <replaceable>join_condition</replaceable> </optional>
</synopsis>
     Joins of all types can be chained together, or nested: either or
     both <replaceable>T1</replaceable> and
     <replaceable>T2</replaceable> can be joined tables.  Parentheses
     can be used around <literal>JOIN</literal> clauses to control the join
     order.  In the absence of parentheses, <literal>JOIN</literal> clauses
     nest left-to-right.
    </para>
________________________________________________________-->
    <para>
     一个连接表是根据特定的连接类型的规则从两个其它表（真实表或生成表）中派生的表。目前支持内连接、外连接和交叉连接。一个连接表的一般语法是：
<synopsis>
<replaceable>T1</replaceable> <replaceable>join_type</replaceable> <replaceable>T2</replaceable> <optional> <replaceable>join_condition</replaceable> </optional>
</synopsis>
     所有类型的连接都可以被链在一起或者嵌套：<replaceable>T1</replaceable>和<replaceable>T2</replaceable>都可以是连接表。在<literal>JOIN</literal>子句周围可以使用圆括号来控制连接顺序。如果不使用圆括号，<literal>JOIN</literal>子句会从左至右嵌套。
    </para>
<!-- pgdoc-cn_end sig_en=1579a10db0ea11c26169d41f74c74cb2 -->

    <variablelist>
<!-- pgdoc-cn_start sig_en=6e01e7df6ddf8d99e4cb5f8ad07deeca sig_cn_org=None source=14.1 
     <title>Join Types</title>
________________________________________________________-->
     <title>连接类型</title>
<!-- pgdoc-cn_end sig_en=6e01e7df6ddf8d99e4cb5f8ad07deeca -->

     <varlistentry>
<!-- pgdoc-cn_start sig_en=8a1c9fc2262daf1c26e22dc34cdea458 sig_cn_org=None source=14.1 
      <term>Cross join
      <indexterm>
       <primary>join</primary>
       <secondary>cross</secondary>
      </indexterm>

      <indexterm>
       <primary>cross join</primary>
      </indexterm>
      </term>
________________________________________________________-->
      <term>交叉连接

      <indexterm>
       <primary>连接</primary>
       <secondary>交叉</secondary>
      </indexterm>

      <indexterm>
       <primary>交叉连接</primary>
      </indexterm>
      </term>
<!-- pgdoc-cn_end sig_en=8a1c9fc2262daf1c26e22dc34cdea458 -->

      <listitem>
<!-- pgdoc-cn_start sig_en=adcab67531124128f4309f676f0c2c0c sig_cn_org=None source=14.1 
<synopsis>
<replaceable>T1</replaceable> CROSS JOIN <replaceable>T2</replaceable>
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>T1</replaceable> CROSS JOIN <replaceable>T2</replaceable>
</synopsis>
<!-- pgdoc-cn_end sig_en=adcab67531124128f4309f676f0c2c0c -->

<!-- pgdoc-cn_start sig_en=bfdf85529a919d647c12c17b3c7d46ed sig_cn_org=None source=14.1 
       <para>
        For every possible combination of rows from
        <replaceable>T1</replaceable> and
        <replaceable>T2</replaceable> (i.e., a Cartesian product),
        the joined table will contain a
        row consisting of all columns in <replaceable>T1</replaceable>
        followed by all columns in <replaceable>T2</replaceable>.  If
        the tables have N and M rows respectively, the joined
        table will have N * M rows.
       </para>
________________________________________________________-->
       <para>
        对来自于<replaceable>T1</replaceable>和<replaceable>T2</replaceable>的行的每一种可能的组合（即笛卡尔积），连接表将包含这样一行：它由所有<replaceable>T1</replaceable>里面的列后面跟着所有<replaceable>T2</replaceable>里面的列构成。如果两个表分别有 N 和 M 行，连接表将有 N * M 行。
       </para>
<!-- pgdoc-cn_end sig_en=bfdf85529a919d647c12c17b3c7d46ed -->

<!-- pgdoc-cn_start sig_en=b5ec2b2764f361dd5fe91507864d8b10 sig_cn_org=None source=14.1 
       <para>
        <literal>FROM <replaceable>T1</replaceable> CROSS JOIN
        <replaceable>T2</replaceable></literal> is equivalent to
        <literal>FROM <replaceable>T1</replaceable> INNER JOIN
        <replaceable>T2</replaceable> ON TRUE</literal> (see below).
        It is also equivalent to
        <literal>FROM <replaceable>T1</replaceable>,
        <replaceable>T2</replaceable></literal>.
        <note>
        <para>
         This latter equivalence does not hold exactly when more than two
         tables appear, because <literal>JOIN</literal> binds more tightly than
         comma.  For example
         <literal>FROM <replaceable>T1</replaceable> CROSS JOIN
         <replaceable>T2</replaceable> INNER JOIN <replaceable>T3</replaceable>
         ON <replaceable>condition</replaceable></literal>
         is not the same as
         <literal>FROM <replaceable>T1</replaceable>,
         <replaceable>T2</replaceable> INNER JOIN <replaceable>T3</replaceable>
         ON <replaceable>condition</replaceable></literal>
         because the <replaceable>condition</replaceable> can
         reference <replaceable>T1</replaceable> in the first case but not
         the second.
        </para>
        </note>
       </para>
________________________________________________________-->
       <para>
        <literal>FROM <replaceable>T1</replaceable> CROSS JOIN <replaceable>T2</replaceable></literal>等效于<literal>FROM <replaceable>T1</replaceable> INNER JOIN <replaceable>T2</replaceable> ON TRUE</literal>（见下文）。它也等效于<literal>FROM <replaceable>T1</replaceable>,<replaceable>T2</replaceable></literal>。
        <note>
        <para>
         当多于两个表出现时，后一种等效并不严格成立，因为<literal>JOIN</literal>比逗号绑得更紧。例如<literal>FROM <replaceable>T1</replaceable> CROSS JOIN <replaceable>T2</replaceable> INNER JOIN <replaceable>T3</replaceable> ON <replaceable>condition</replaceable></literal>和<literal>FROM <replaceable>T1</replaceable>,<replaceable>T2</replaceable> INNER JOIN <replaceable>T3</replaceable> ON <replaceable>condition</replaceable></literal>并不完全相同，因为第一种情况中的<replaceable>condition</replaceable>可以引用<replaceable>T1</replaceable>，但在第二种情况中却不行。
        </para>
        </note>
       </para>
<!-- pgdoc-cn_end sig_en=b5ec2b2764f361dd5fe91507864d8b10 -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=a44c26c8c4851560d9d3f373f516bf64 sig_cn_org=None source=14.1 
      <term>Qualified joins
      <indexterm>
       <primary>join</primary>
       <secondary>outer</secondary>
      </indexterm>

      <indexterm>
       <primary>outer join</primary>
      </indexterm>
      </term>
________________________________________________________-->
      <term>条件连接

      <indexterm>
       <primary>join</primary>
       <secondary>outer</secondary>
      </indexterm>

      <indexterm>
       <primary>外连接</primary>
      </indexterm>
      </term>
<!-- pgdoc-cn_end sig_en=a44c26c8c4851560d9d3f373f516bf64 -->

      <listitem>
<!-- pgdoc-cn_start sig_en=25201ee72e551e22222640d56419ae2e sig_cn_org=None source=14.1 
<synopsis>
<replaceable>T1</replaceable> { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable> ON <replaceable>boolean_expression</replaceable>
<replaceable>T1</replaceable> { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable> USING ( <replaceable>join column list</replaceable> )
<replaceable>T1</replaceable> NATURAL { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable>
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>T1</replaceable> { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable> ON <replaceable>boolean_expression</replaceable>
<replaceable>T1</replaceable> { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable> USING ( <replaceable>join column list</replaceable> )
<replaceable>T1</replaceable> NATURAL { <optional>INNER</optional> | { LEFT | RIGHT | FULL } <optional>OUTER</optional> } JOIN <replaceable>T2</replaceable>
</synopsis>
<!-- pgdoc-cn_end sig_en=25201ee72e551e22222640d56419ae2e -->

<!-- pgdoc-cn_start sig_en=4a8cd4c249df4f0ba9eda579f1133623 sig_cn_org=None source=14.1 
       <para>
        The words <literal>INNER</literal> and
        <literal>OUTER</literal> are optional in all forms.
        <literal>INNER</literal> is the default;
        <literal>LEFT</literal>, <literal>RIGHT</literal>, and
        <literal>FULL</literal> imply an outer join.
       </para>
________________________________________________________-->
       <para>
        <literal>INNER</literal>和<literal>OUTER</literal>对所有连接形式都是可选的。<literal>INNER</literal>是缺省；<literal>LEFT</literal>、<literal>RIGHT</literal>和<literal>FULL</literal>指示一个外连接。
       </para>
<!-- pgdoc-cn_end sig_en=4a8cd4c249df4f0ba9eda579f1133623 -->

<!-- pgdoc-cn_start sig_en=9e5b928b7e0fa60d86b107de3996560f sig_cn_org=None source=14.1 
       <para>
        The <firstterm>join condition</firstterm> is specified in the
        <literal>ON</literal> or <literal>USING</literal> clause, or implicitly by
        the word <literal>NATURAL</literal>.  The join condition determines
        which rows from the two source tables are considered to
        <quote>match</quote>, as explained in detail below.
       </para>
________________________________________________________-->
       <para>
        <firstterm>连接条件</firstterm>在<literal>ON</literal>或<literal>USING</literal>子句中指定， 或者用关键字<literal>NATURAL</literal>隐含地指定。连接条件决定来自两个源表中的哪些行是<quote>匹配</quote>的，这些我们将在后文详细解释。
       </para>
<!-- pgdoc-cn_end sig_en=9e5b928b7e0fa60d86b107de3996560f -->

<!-- pgdoc-cn_start sig_en=9b61261da346fa37dcccc97a62e00594 sig_cn_org=None source=14.1 
       <para>
        The possible types of qualified join are:

       <variablelist>
        <varlistentry>
         <term><literal>INNER JOIN</literal></term>

         <listitem>
          <para>
           For each row R1 of T1, the joined table has a row for each
           row in T2 that satisfies the join condition with R1.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>LEFT OUTER JOIN</literal>
         <indexterm>
          <primary>join</primary>
          <secondary>left</secondary>
         </indexterm>

         <indexterm>
          <primary>left join</primary>
         </indexterm>
         </term>

         <listitem>
          <para>
           First, an inner join is performed.  Then, for each row in
           T1 that does not satisfy the join condition with any row in
           T2, a joined row is added with null values in columns of
           T2.  Thus, the joined table always has at least
           one row for each row in T1.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>RIGHT OUTER JOIN</literal>
         <indexterm>
          <primary>join</primary>
          <secondary>right</secondary>
         </indexterm>

         <indexterm>
          <primary>right join</primary>
         </indexterm>
         </term>

         <listitem>
          <para>
           First, an inner join is performed.  Then, for each row in
           T2 that does not satisfy the join condition with any row in
           T1, a joined row is added with null values in columns of
           T1.  This is the converse of a left join: the result table
           will always have a row for each row in T2.
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>FULL OUTER JOIN</literal></term>

         <listitem>
          <para>
           First, an inner join is performed.  Then, for each row in
           T1 that does not satisfy the join condition with any row in
           T2, a joined row is added with null values in columns of
           T2.  Also, for each row of T2 that does not satisfy the
           join condition with any row in T1, a joined row with null
           values in the columns of T1 is added.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
       </para>
________________________________________________________-->
       <para>
        可能的条件连接类型是：

       <variablelist>
        <varlistentry>
         <term><literal>INNER JOIN</literal></term>

         <listitem>
          <para>
           对于 T1 的每一行 R1，生成的连接表都有一行对应 T2 中的每一个满足和 R1 的连接条件的行。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>LEFT OUTER JOIN</literal>
         <indexterm>
          <primary>连接</primary>
          <secondary>左</secondary>
         </indexterm>

         <indexterm>
          <primary>左连接</primary>
         </indexterm>
         </term>

         <listitem>
          <para>
           首先，执行一次内连接。然后，为 T1 中每一个无法在连接条件上匹配 T2 里任何一行的行返回一个连接行，该连接行中 T2 的列用空值补齐。因此，生成的连接表里为来自 T1 的每一行都至少包含一行。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>RIGHT OUTER JOIN</literal>
         <indexterm>
          <primary>连接</primary>
          <secondary>右</secondary>
         </indexterm>

         <indexterm>
          <primary>右连接</primary>
         </indexterm>
         </term>

         <listitem>
          <para>
           首先，执行一次内连接。然后，为 T2 中每一个无法在连接条件上匹配 T1 里任何一行的行返回一个连接行，该连接行中 T1 的列用空值补齐。因此，生成的连接表里为来自 T2 的每一行都至少包含一行。
          </para>
         </listitem>
        </varlistentry>

        <varlistentry>
         <term><literal>FULL OUTER JOIN</literal></term>

         <listitem>
          <para>
           首先，执行一次内连接。然后，为 T1 中每一个无法在连接条件上匹配 T2 里任何一行的行返回一个连接行，该连接行中 T2 的列用空值补齐。同样，为 T2 中每一个无法在连接条件上匹配 T1 里任何一行的行返回一个连接行，该连接行中 T1 的列用空值补齐。
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
       </para>
<!-- pgdoc-cn_end sig_en=9b61261da346fa37dcccc97a62e00594 -->

<!-- pgdoc-cn_start sig_en=3216a614e02eaeaadf05ddebd026ad85 sig_cn_org=None source=14.1 
       <para>
        The <literal>ON</literal> clause is the most general kind of join
        condition: it takes a Boolean value expression of the same
        kind as is used in a <literal>WHERE</literal> clause.  A pair of rows
        from <replaceable>T1</replaceable> and <replaceable>T2</replaceable> match if the
        <literal>ON</literal> expression evaluates to true.
       </para>
________________________________________________________-->
       <para>
       <literal>ON</literal>子句是最常见的连接条件的形式：它接收一个和<literal>WHERE</literal>子句里用的一样的布尔值表达式。 如果两个分别来自<replaceable>T1</replaceable>和<replaceable>T2</replaceable>的行在<literal>ON</literal>表达式上运算的结果为真，那么它们就算是匹配的行。
       </para>
<!-- pgdoc-cn_end sig_en=3216a614e02eaeaadf05ddebd026ad85 -->

<!-- pgdoc-cn_start sig_en=07c33ca575468afe6c9090aa62b12c7b sig_cn_org=None source=14.1 
       <para>
        The <literal>USING</literal> clause is a shorthand that allows you to take
        advantage of the specific situation where both sides of the join use
        the same name for the joining column(s).  It takes a
        comma-separated list of the shared column names
        and forms a join condition that includes an equality comparison
        for each one.  For example, joining <replaceable>T1</replaceable>
        and <replaceable>T2</replaceable> with <literal>USING (a, b)</literal> produces
        the join condition <literal>ON <replaceable>T1</replaceable>.a
        = <replaceable>T2</replaceable>.a AND <replaceable>T1</replaceable>.b
        = <replaceable>T2</replaceable>.b</literal>.
       </para>
________________________________________________________-->
       <para>
        <literal>USING</literal>是个缩写符号，它允许你利用特殊的情况：连接的两端都具有相同的连接列名。它接受共享列名的一个逗号分隔列表，并且为其中每一个共享列构造一个包含等值比较的连接条件。例如用<literal>USING (a, b)</literal>连接<replaceable>T1</replaceable>和<replaceable>T2</replaceable>会产生连接条件<literal>ON <replaceable>T1</replaceable>.a = <replaceable>T2</replaceable>.a AND <replaceable>T1</replaceable>.b = <replaceable>T2</replaceable>.b</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=07c33ca575468afe6c9090aa62b12c7b -->

<!-- pgdoc-cn_start sig_en=e53a95d0eb895aa5b0ac03954bd87d4d sig_cn_org=None source=14.1 
       <para>
        Furthermore, the output of <literal>JOIN USING</literal> suppresses
        redundant columns: there is no need to print both of the matched
        columns, since they must have equal values.  While <literal>JOIN
        ON</literal> produces all columns from <replaceable>T1</replaceable> followed by all
        columns from <replaceable>T2</replaceable>, <literal>JOIN USING</literal> produces one
        output column for each of the listed column pairs (in the listed
        order), followed by any remaining columns from <replaceable>T1</replaceable>,
        followed by any remaining columns from <replaceable>T2</replaceable>.
       </para>
________________________________________________________-->
       <para>
        更进一步，<literal>JOIN USING</literal>的输出会废除冗余列：不需要把匹配上的列都打印出来，因为它们必须具有相等的值。不过<literal>JOIN ON</literal>会先产生来自<replaceable>T1</replaceable>的所有列，后面跟上所有来自<replaceable>T2</replaceable>的列；而<literal>JOIN USING</literal>会先为列出的每一个列对产生一个输出列，然后先跟上来自<replaceable>T1</replaceable>的剩余列，最后跟上来自<replaceable>T2</replaceable>的剩余列。
       </para>
<!-- pgdoc-cn_end sig_en=e53a95d0eb895aa5b0ac03954bd87d4d -->

<!-- pgdoc-cn_start sig_en=aaede3e6718c0032fb2670d819723ea4 sig_cn_org=None source=14.1 
       <para>
        <indexterm>
         <primary>join</primary>
         <secondary>natural</secondary>
        </indexterm>
        <indexterm>
         <primary>natural join</primary>
        </indexterm>
        Finally, <literal>NATURAL</literal> is a shorthand form of
        <literal>USING</literal>: it forms a <literal>USING</literal> list
        consisting of all column names that appear in both
        input tables.  As with <literal>USING</literal>, these columns appear
        only once in the output table.  If there are no common
        column names, <literal>NATURAL JOIN</literal> behaves like
        <literal>JOIN ... ON TRUE</literal>, producing a cross-product join.
       </para>
________________________________________________________-->
       <para>
        <indexterm>
         <primary>连接</primary>
         <secondary>自然</secondary>
        </indexterm>
        <indexterm>
         <primary>自然连接</primary>
        </indexterm>
        最后，<literal>NATURAL</literal>是<literal>USING</literal>的缩写形式：它形成一个<literal>USING</literal>列表， 该列表由那些在两个表里都出现了的列名组成。和<literal>USING</literal>一样，这些列只在输出表里出现一次。如果不存在公共列，<literal>NATURAL JOIN</literal>的行为将和<literal>JOIN ... ON TRUE</literal>一样产生交叉集连接。
       </para>
<!-- pgdoc-cn_end sig_en=aaede3e6718c0032fb2670d819723ea4 -->

       <note>
<!-- pgdoc-cn_start sig_en=c81aabd42f6b6a3a598bfa60ce3390de sig_cn_org=None source=14.1 
        <para>
         <literal>USING</literal> is reasonably safe from column changes
         in the joined relations since only the listed columns
         are combined.  <literal>NATURAL</literal> is considerably more risky since
         any schema changes to either relation that cause a new matching
         column name to be present will cause the join to combine that new
         column as well.
        </para>
________________________________________________________-->
        <para>
         <literal>USING</literal>对于连接关系中的列改变是相当安全的，因为只有被列出的列会被组合成连接条件。<literal>NATURAL</literal>的风险更大，因为如果其中一个关系的模式改变会导致出现一个新的匹配列名，就会导致连接将新列也组合成连接条件。
        </para>
<!-- pgdoc-cn_end sig_en=c81aabd42f6b6a3a598bfa60ce3390de -->
       </note>
      </listitem>
     </varlistentry>
    </variablelist>

<!-- pgdoc-cn_start sig_en=43dc0c6cb66d300d4f019d824dcdf899 sig_cn_org=None source=14.1 
    <para>
     To put this together, assume we have tables <literal>t1</literal>:
<programlisting>
 num | name
-&minus;-&minus;-+-&minus;-&minus;-&minus;
   1 | a
   2 | b
   3 | c
</programlisting>
     and <literal>t2</literal>:
<programlisting>
 num | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;-
   1 | xxx
   3 | yyy
   5 | zzz
</programlisting>
     then we get the following results for the various joins:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 CROSS JOIN t2;</userinput>
 num | name | num | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-&minus;-
   1 | a    |   1 | xxx
   1 | a    |   3 | yyy
   1 | a    |   5 | zzz
   2 | b    |   1 | xxx
   2 | b    |   3 | yyy
   2 | b    |   5 | zzz
   3 | c    |   1 | xxx
   3 | c    |   3 | yyy
   3 | c    |   5 | zzz
(9 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-&minus;-
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 INNER JOIN t2 USING (num);</userinput>
 num | name | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 NATURAL INNER JOIN t2;</userinput>
 num | name | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-&minus;-
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 USING (num);</userinput>
 num | name | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
   1 | a    | xxx
   2 | b    |
   3 | c    | yyy
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-&minus;-
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
     |      |   5 | zzz
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 FULL JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-&minus;-
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
     |      |   5 | zzz
(4 rows)
</screen>
    </para>
________________________________________________________-->
    <para>
     为了解释这些问题，假设我们有一个表<literal>t1</literal>：
<programlisting>
 num | name
-----+------
   1 | a
   2 | b
   3 | c
</programlisting>
     和<literal>t2</literal>：
<programlisting>
 num | value
-----+-------
   1 | xxx
   3 | yyy
   5 | zzz
</programlisting>
     然后我们用不同的连接方式可以获得各种结果：
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 CROSS JOIN t2;</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   1 | a    |   3 | yyy
   1 | a    |   5 | zzz
   2 | b    |   1 | xxx
   2 | b    |   3 | yyy
   2 | b    |   5 | zzz
   3 | c    |   1 | xxx
   3 | c    |   3 | yyy
   3 | c    |   5 | zzz
(9 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 INNER JOIN t2 USING (num);</userinput>
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 NATURAL INNER JOIN t2;</userinput>
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 USING (num);</userinput>
 num | name | value
-----+------+-------
   1 | a    | xxx
   2 | b    |
   3 | c    | yyy
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
     |      |   5 | zzz
(3 rows)

<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 FULL JOIN t2 ON t1.num = t2.num;</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
     |      |   5 | zzz
(4 rows)
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=43dc0c6cb66d300d4f019d824dcdf899 -->

<!-- pgdoc-cn_start sig_en=3f75f889422297508d879f1b062f82eb sig_cn_org=None source=14.1 
    <para>
     The join condition specified with <literal>ON</literal> can also contain
     conditions that do not relate directly to the join.  This can
     prove useful for some queries but needs to be thought out
     carefully.  For example:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num AND t2.value = 'xxx';</userinput>
 num | name | num | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-&minus;-
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |     |
(3 rows)
</screen>
     Notice that placing the restriction in the <literal>WHERE</literal> clause
     produces a different result:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num WHERE t2.value = 'xxx';</userinput>
 num | name | num | value
-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-+-&minus;-&minus;-&minus;-
   1 | a    |   1 | xxx
(1 row)
</screen>
     This is because a restriction placed in the <literal>ON</literal>
     clause is processed <emphasis>before</emphasis> the join, while
     a restriction placed in the <literal>WHERE</literal> clause is processed
     <emphasis>after</emphasis> the join.
     That does not matter with inner joins, but it matters a lot with outer
     joins.
    </para>
________________________________________________________-->
    <para>
     用<literal>ON</literal>指定的连接条件也可以包含与连接不直接相关的条件。这种功能可能对某些查询很有用，但是需要我们仔细想清楚。例如：
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num AND t2.value = 'xxx';</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |     |
(3 rows)
</screen>
     注意把限制放在<literal>WHERE</literal>子句中会产生不同的结果：
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num WHERE t2.value = 'xxx';</userinput>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
(1 row)
</screen>
     这是因为放在<literal>ON</literal>子句中的一个约束在连接<emphasis>之前</emphasis>被处理，而放在<literal>WHERE</literal>子句中的一个约束是在连接<emphasis>之后</emphasis>被处理。这对内连接没有关系，但是对于外连接会带来麻烦。
    </para>
<!-- pgdoc-cn_end sig_en=3f75f889422297508d879f1b062f82eb -->
   </sect3>

   <sect3 id="queries-table-aliases">
<!-- pgdoc-cn_start sig_en=873bfb261931653265791d8992448eea sig_cn_org=None source=14.1 
    <title>Table and Column Aliases</title>
________________________________________________________-->
    <title>表和列别名</title>
<!-- pgdoc-cn_end sig_en=873bfb261931653265791d8992448eea -->

<!-- pgdoc-cn_start sig_en=c62862df82b5552222fe16e0d50971da sig_cn_org=None source=14.1 
    <indexterm zone="queries-table-aliases">
     <primary>alias</primary>
     <secondary>in the FROM clause</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="queries-table-aliases">
     <primary>别名</primary>
     <secondary>在FROM子句中</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=c62862df82b5552222fe16e0d50971da -->

<!-- pgdoc-cn_start sig_en=e3154b88cf33dc226f03a6835aae7432 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>label</primary>
     <see>alias</see>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>标签</primary>
     <see>别名</see>
    </indexterm>
<!-- pgdoc-cn_end sig_en=e3154b88cf33dc226f03a6835aae7432 -->

<!-- pgdoc-cn_start sig_en=fdfaa408d19a448d668661ad48d762b4 sig_cn_org=None source=14.1 
    <para>
     A temporary name can be given to tables and complex table
     references to be used for references to the derived table in
     the rest of the query.  This is called a <firstterm>table
     alias</firstterm>.
    </para>
________________________________________________________-->
    <para>
     你可以给一个表或复杂的表引用指定一个临时的名字，用于剩下的查询中引用那些派生的表。这被叫做<firstterm>表别名</firstterm>。
    </para>
<!-- pgdoc-cn_end sig_en=fdfaa408d19a448d668661ad48d762b4 -->

<!-- pgdoc-cn_start sig_en=0a57438fa420bbff10970da52e86f038 sig_cn_org=None source=14.1 
    <para>
     To create a table alias, write
<synopsis>
FROM <replaceable>table_reference</replaceable> AS <replaceable>alias</replaceable>
</synopsis>
     or
<synopsis>
FROM <replaceable>table_reference</replaceable> <replaceable>alias</replaceable>
</synopsis>
     The <literal>AS</literal> key word is optional noise.
     <replaceable>alias</replaceable> can be any identifier.
    </para>
________________________________________________________-->
    <para>
     要创建一个表别名，我们可以写：
<synopsis>
FROM <replaceable>table_reference</replaceable> AS <replaceable>alias</replaceable>
</synopsis>
     或者
<synopsis>
FROM <replaceable>table_reference</replaceable> <replaceable>alias</replaceable>
</synopsis>
     <literal>AS</literal>关键字是可选的。<replaceable>别名</replaceable>可以是任意标识符。
    </para>
<!-- pgdoc-cn_end sig_en=0a57438fa420bbff10970da52e86f038 -->

<!-- pgdoc-cn_start sig_en=5d07d65af2fc3c4c9c3f760eb42c98f9 sig_cn_org=None source=14.1 
    <para>
     A typical application of table aliases is to assign short
     identifiers to long table names to keep the join clauses
     readable.  For example:
<programlisting>
SELECT * FROM some_very_long_table_name s JOIN another_fairly_long_name a ON s.id = a.num;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     表别名的典型应用是给长表名赋予比较短的标识符， 好让连接子句更易读。例如：
<programlisting>
SELECT * FROM some_very_long_table_name s JOIN another_fairly_long_name a ON s.id = a.num;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=5d07d65af2fc3c4c9c3f760eb42c98f9 -->

<!-- pgdoc-cn_start sig_en=210f49ce5be162f55be4680a7a586a72 sig_cn_org=None source=14.1 
    <para>
     The alias becomes the new name of the table reference so far as the
     current query is concerned &mdash; it is not allowed to refer to the
     table by the original name elsewhere in the query.  Thus, this is not
     valid:
<programlisting>
SELECT * FROM my_table AS m WHERE my_table.a &gt; 5;    -&minus; wrong
</programlisting>
    </para>
________________________________________________________-->
    <para>
     到这里，别名成为当前查询的表引用的新名称 &mdash; 我们不再能够用该表最初的名字引用它了。因此，下面的用法是不合法的：
<programlisting>
SELECT * FROM my_table AS m WHERE my_table.a &gt; 5;    -- 错误
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=210f49ce5be162f55be4680a7a586a72 -->

<!-- pgdoc-cn_start sig_en=c6410ab56f55bb4cae667561985729b0 sig_cn_org=None source=14.1 
    <para>
     Table aliases are mainly for notational convenience, but it is
     necessary to use them when joining a table to itself, e.g.:
<programlisting>
SELECT * FROM people AS mother JOIN people AS child ON mother.id = child.mother_id;
</programlisting>
     Additionally, an alias is required if the table reference is a
     subquery (see <xref linkend="queries-subqueries"/>).
    </para>
________________________________________________________-->
    <para>
     表别名主要用于简化符号，但是当把一个表连接到它自身时必须使用别名，例如：
<programlisting>
SELECT * FROM people AS mother JOIN people AS child ON mother.id = child.mother_id;
</programlisting>
     此外，如果一个表引用是一个子查询，则必须要使用一个别名（见<xref linkend="queries-subqueries"/>）。
    </para>
<!-- pgdoc-cn_end sig_en=c6410ab56f55bb4cae667561985729b0 -->

<!-- pgdoc-cn_start sig_en=13c18687f17e59ae99e8cc5f32c68a87 sig_cn_org=None source=14.1 
    <para>
     Parentheses are used to resolve ambiguities.  In the following example,
     the first statement assigns the alias <literal>b</literal> to the second
     instance of <literal>my_table</literal>, but the second statement assigns the
     alias to the result of the join:
<programlisting>
SELECT * FROM my_table AS a CROSS JOIN my_table AS b ...
SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b ...
</programlisting>
    </para>
________________________________________________________-->
    <para>
     圆括弧用于解决歧义。在下面的例子中，第一个语句将把别名<literal>b</literal>赋给<literal>my_table</literal>的第二个实例，但是第二个语句把别名赋给连接的结果：
<programlisting>
SELECT * FROM my_table AS a CROSS JOIN my_table AS b ...
SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b ...
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=13c18687f17e59ae99e8cc5f32c68a87 -->

<!-- pgdoc-cn_start sig_en=16593a15f83d14db2d206eb7bda2f0b7 sig_cn_org=None source=14.1 
    <para>
     Another form of table aliasing gives temporary names to the columns of
     the table, as well as the table itself:
<synopsis>
FROM <replaceable>table_reference</replaceable> <optional>AS</optional> <replaceable>alias</replaceable> ( <replaceable>column1</replaceable> <optional>, <replaceable>column2</replaceable> <optional>, ...</optional></optional> )
</synopsis>
     If fewer column aliases are specified than the actual table has
     columns, the remaining columns are not renamed.  This syntax is
     especially useful for self-joins or subqueries.
    </para>
________________________________________________________-->
    <para>
     另外一种给表指定别名的形式是给表的列赋予临时名字，就像给表本身指定别名一样：
<synopsis>
FROM <replaceable>table_reference</replaceable> <optional>AS</optional> <replaceable>alias</replaceable> ( <replaceable>column1</replaceable> <optional>, <replaceable>column2</replaceable> <optional>, ...</optional></optional> )
</synopsis>
     如果指定的列别名比表里实际的列少，那么剩下的列就没有被重命名。这种语法对于自连接或子查询特别有用。
    </para>
<!-- pgdoc-cn_end sig_en=16593a15f83d14db2d206eb7bda2f0b7 -->

<!-- pgdoc-cn_start sig_en=ccf5aaa875dec5357cfbb412f492969b sig_cn_org=None source=14.1 
    <para>
     When an alias is applied to the output of a <literal>JOIN</literal>
     clause, the alias hides the original
     name(s) within the <literal>JOIN</literal>.  For example:
<programlisting>
SELECT a.* FROM my_table AS a JOIN your_table AS b ON ...
</programlisting>
     is valid SQL, but:
<programlisting>
SELECT a.* FROM (my_table AS a JOIN your_table AS b ON ...) AS c
</programlisting>
     is not valid; the table alias <literal>a</literal> is not visible
     outside the alias <literal>c</literal>.
    </para>
________________________________________________________-->
    <para>
     如果用这些形式中的任何一种给一个<literal>JOIN</literal>子句的输出附加了一个别名， 那么该别名就在<literal>JOIN</literal>的作用下隐去了其原始的名字。例如：
<programlisting>
SELECT a.* FROM my_table AS a JOIN your_table AS b ON ...
</programlisting>
     是合法 SQL，但是：
<programlisting>
SELECT a.* FROM (my_table AS a JOIN your_table AS b ON ...) AS c
</programlisting>
     是不合法的：表别名<literal>a</literal>在别名<literal>c</literal>外面是看不到的。
    </para>
<!-- pgdoc-cn_end sig_en=ccf5aaa875dec5357cfbb412f492969b -->
   </sect3>

   <sect3 id="queries-subqueries">
<!-- pgdoc-cn_start sig_en=e14decc22886e41e8df56d2635c34b66 sig_cn_org=None source=14.1 
    <title>Subqueries</title>
________________________________________________________-->
    <title>子查询</title>
<!-- pgdoc-cn_end sig_en=e14decc22886e41e8df56d2635c34b66 -->

<!-- pgdoc-cn_start sig_en=32406b9204a5a6cad8ec57ecc84931d2 sig_cn_org=None source=14.1 
    <indexterm zone="queries-subqueries">
     <primary>subquery</primary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="queries-subqueries">
     <primary>子查询</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=32406b9204a5a6cad8ec57ecc84931d2 -->

<!-- pgdoc-cn_start sig_en=53ea5b25624afc55a24a52770c3eca99 sig_cn_org=None source=14.1 
    <para>
     Subqueries specifying a derived table must be enclosed in
     parentheses and <emphasis>must</emphasis> be assigned a table
     alias name (as in <xref linkend="queries-table-aliases"/>).  For
     example:
<programlisting>
FROM (SELECT * FROM table1) AS alias_name
</programlisting>
    </para>
________________________________________________________-->
    <para>
     子查询指定了一个派生表，它必须被包围在圆括弧里并且<emphasis>必须</emphasis>被赋予一个表别名（参阅<xref linkend="queries-table-aliases"/>）。例如：
<programlisting>
FROM (SELECT * FROM table1) AS alias_name
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=53ea5b25624afc55a24a52770c3eca99 -->

<!-- pgdoc-cn_start sig_en=916861857340d5483573503a1b8a6b2f sig_cn_org=None source=14.1 
    <para>
     This example is equivalent to <literal>FROM table1 AS
     alias_name</literal>.  More interesting cases, which cannot be
     reduced to a plain join, arise when the subquery involves
     grouping or aggregation.
    </para>
________________________________________________________-->
    <para>
     这个例子等效于<literal>FROM table1 AS alias_name</literal>。更有趣的情况是在子查询里面有分组或聚集的时候， 子查询不能被简化为一个简单的连接。
    </para>
<!-- pgdoc-cn_end sig_en=916861857340d5483573503a1b8a6b2f -->

<!-- pgdoc-cn_start sig_en=d28dfc766f402a87eaa7c298390f084e sig_cn_org=None source=14.1 
    <para>
     A subquery can also be a <command>VALUES</command> list:
<programlisting>
FROM (VALUES ('anne', 'smith'), ('bob', 'jones'), ('joe', 'blow'))
     AS names(first, last)
</programlisting>
     Again, a table alias is required.  Assigning alias names to the columns
     of the <command>VALUES</command> list is optional, but is good practice.
     For more information see <xref linkend="queries-values"/>.
    </para>
________________________________________________________-->
    <para>
     一个子查询也可以是一个<command>VALUES</command>列表：
<programlisting>
FROM (VALUES ('anne', 'smith'), ('bob', 'jones'), ('joe', 'blow'))
     AS names(first, last)
</programlisting>
     再次的，这里要求一个表别名。为<command>VALUES</command>列表中的列分配别名是可选的，但是选择这样做是一个好习惯。更多信息可参见<xref linkend="queries-values"/>。
    </para>
<!-- pgdoc-cn_end sig_en=d28dfc766f402a87eaa7c298390f084e -->
   </sect3>

   <sect3 id="queries-tablefunctions">
<!-- pgdoc-cn_start sig_en=30bd18b654b4801bb9d50dfd4d6efdb1 sig_cn_org=None source=14.1 
    <title>Table Functions</title>
________________________________________________________-->
    <title>表函数</title>
<!-- pgdoc-cn_end sig_en=30bd18b654b4801bb9d50dfd4d6efdb1 -->

<!-- pgdoc-cn_start sig_en=f583d84abd2698dc40ab2cc18a1fddc5 sig_cn_org=None source=14.1 
    <indexterm zone="queries-tablefunctions"><primary>table function</primary></indexterm>
________________________________________________________-->
    <indexterm zone="queries-tablefunctions"><primary>表函数</primary></indexterm>
<!-- pgdoc-cn_end sig_en=f583d84abd2698dc40ab2cc18a1fddc5 -->

<!-- pgdoc-cn_start sig_en=c3ec9221fb860e3f9d0b2e06d49f0042 sig_cn_org=None source=14.1 
    <indexterm zone="queries-tablefunctions">
     <primary>function</primary>
     <secondary>in the FROM clause</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="queries-tablefunctions">
     <primary>函数</primary>
     <secondary>在FROM子句中</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=c3ec9221fb860e3f9d0b2e06d49f0042 -->

<!-- pgdoc-cn_start sig_en=29b8ae605b60906abbe7895e8eb1e0e9 sig_cn_org=None source=14.1 
    <para>
     Table functions are functions that produce a set of rows, made up
     of either base data types (scalar types) or composite data types
     (table rows).  They are used like a table, view, or subquery in
     the <literal>FROM</literal> clause of a query. Columns returned by table
     functions can be included in <literal>SELECT</literal>,
     <literal>JOIN</literal>, or <literal>WHERE</literal> clauses in the same manner
     as columns of a table, view, or subquery.
    </para>
________________________________________________________-->
    <para>
     表函数是那些生成一个行集合的函数，这个集合可以是由基本数据类型（标量类型）组成， 也可以是由复合数据类型（表行）组成。它们的用法类似一个表、视图或者在查询的<literal>FROM</literal>子句里的子查询。表函数返回的列可以像一个表列、视图或者子查询那样被包含在<literal>SELECT</literal>、<literal>JOIN</literal>或<literal>WHERE</literal>子句里。
    </para>
<!-- pgdoc-cn_end sig_en=29b8ae605b60906abbe7895e8eb1e0e9 -->

<!-- pgdoc-cn_start sig_en=7a800cd29744c55ffa6f39b9fbc5aa2e sig_cn_org=None source=14.1 
    <para>
     Table functions may also be combined using the <literal>ROWS FROM</literal>
     syntax, with the results returned in parallel columns; the number of
     result rows in this case is that of the largest function result, with
     smaller results padded with null values to match.
    </para>
________________________________________________________-->
    <para>
     也可以使用<literal>ROWS FROM</literal>语法将平行列返回的结果组合成表函数；
     这种情况下结果行的数量是最大一个函数结果的数量，较小的结果会用空值来填充。
    </para>
<!-- pgdoc-cn_end sig_en=7a800cd29744c55ffa6f39b9fbc5aa2e -->

<!-- pgdoc-cn_start sig_en=0824b21ad79091424a06af9aa99325b4 sig_cn_org=None source=14.1 
<synopsis>
<replaceable>function_call</replaceable> <optional>WITH ORDINALITY</optional> <optional><optional>AS</optional> <replaceable>table_alias</replaceable> <optional>(<replaceable>column_alias</replaceable> <optional>, ... </optional>)</optional></optional>
ROWS FROM( <replaceable>function_call</replaceable> <optional>, ... </optional> ) <optional>WITH ORDINALITY</optional> <optional><optional>AS</optional> <replaceable>table_alias</replaceable> <optional>(<replaceable>column_alias</replaceable> <optional>, ... </optional>)</optional></optional>
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>function_call</replaceable> <optional>WITH ORDINALITY</optional> <optional><optional>AS</optional> <replaceable>table_alias</replaceable> <optional>(<replaceable>column_alias</replaceable> <optional>, ... </optional>)</optional></optional>
ROWS FROM( <replaceable>function_call</replaceable> <optional>, ... </optional> ) <optional>WITH ORDINALITY</optional> <optional><optional>AS</optional> <replaceable>table_alias</replaceable> <optional>(<replaceable>column_alias</replaceable> <optional>, ... </optional>)</optional></optional>
</synopsis>
<!-- pgdoc-cn_end sig_en=0824b21ad79091424a06af9aa99325b4 -->

<!-- pgdoc-cn_start sig_en=e55471e34f1efae3e691b2e0a96d2227 sig_cn_org=None source=14.1 
    <para>
     If the <literal>WITH ORDINALITY</literal> clause is specified, an
     additional column of type <type>bigint</type> will be added to the
     function result columns.  This column numbers the rows of the function
     result set, starting from 1. (This is a generalization of the
     SQL-standard syntax for <literal>UNNEST ... WITH ORDINALITY</literal>.)
     By default, the ordinal column is called <literal>ordinality</literal>, but
     a different column name can be assigned to it using
     an <literal>AS</literal> clause.
    </para>
________________________________________________________-->
    <para>
     如果指定了<literal>WITH ORDINALITY</literal>子句，一个额外的
     <type>bigint</type>类型的列将会被增加到函数的结果列中。这个列对
     函数结果集的行进行编号，编号从 1 开始（这是对 SQL 标准语法
     <literal>UNNEST ... WITH ORDINALITY</literal>的一般化）。默认情
     况下，序数列被称为<literal>ordinality</literal>，但也可以通过使用一个
     <literal>AS</literal>子句给它分配一个不同的列名。
    </para>
<!-- pgdoc-cn_end sig_en=e55471e34f1efae3e691b2e0a96d2227 -->

<!-- pgdoc-cn_start sig_en=581eeb7034fa5b42dbb40fd04314f733 sig_cn_org=None source=14.1 
    <para>
     The special table function <literal>UNNEST</literal> may be called with
     any number of array parameters, and it returns a corresponding number of
     columns, as if <literal>UNNEST</literal>
     (<xref linkend="functions-array"/>) had been called on each parameter
     separately and combined using the <literal>ROWS FROM</literal> construct.
    </para>
________________________________________________________-->
    <para>
     调用特殊的表函数<literal>UNNEST</literal>可以使用任意数量的数组参数，
     它会返回对应的列数，就好像在每一个参数上单独调用
     <literal>UNNEST</literal>（<xref linkend="functions-array"/>）并且使用
     <literal>ROWS FROM</literal>结构把它们组合起来。
    </para>
<!-- pgdoc-cn_end sig_en=581eeb7034fa5b42dbb40fd04314f733 -->

<!-- pgdoc-cn_start sig_en=878c315663f153a0c6a1539040c3ce0a sig_cn_org=None source=14.1 
<synopsis>
UNNEST( <replaceable>array_expression</replaceable> <optional>, ... </optional> ) <optional>WITH ORDINALITY</optional> <optional><optional>AS</optional> <replaceable>table_alias</replaceable> <optional>(<replaceable>column_alias</replaceable> <optional>, ... </optional>)</optional></optional>
</synopsis>
________________________________________________________-->
<synopsis>
UNNEST( <replaceable>array_expression</replaceable> <optional>, ... </optional> ) <optional>WITH ORDINALITY</optional> <optional><optional>AS</optional> <replaceable>table_alias</replaceable> <optional>(<replaceable>column_alias</replaceable> <optional>, ... </optional>)</optional></optional>
</synopsis>
<!-- pgdoc-cn_end sig_en=878c315663f153a0c6a1539040c3ce0a -->

<!-- pgdoc-cn_start sig_en=578ebb39aca6d868615c111c4fbdc0f0 sig_cn_org=None source=14.1 
    <para>
     If no <replaceable>table_alias</replaceable> is specified, the function
     name is used as the table name; in the case of a <literal>ROWS FROM()</literal>
     construct, the first function's name is used.
    </para>
________________________________________________________-->
    <para>
     如果没有指定<replaceable>table_alias</replaceable>，该函数名将被用作
     表名。在<literal>ROWS FROM()</literal>结构的情况中，会使用第一个函数名。
    </para>
<!-- pgdoc-cn_end sig_en=578ebb39aca6d868615c111c4fbdc0f0 -->

<!-- pgdoc-cn_start sig_en=4b177d7ad65af243abb4ed041112d231 sig_cn_org=None source=14.1 
    <para>
     If column aliases are not supplied, then for a function returning a base
     data type, the column name is also the same as the function name.  For a
     function returning a composite type, the result columns get the names
     of the individual attributes of the type.
    </para>
________________________________________________________-->
    <para>
     如果没有提供列的别名，那么对于一个返回基数据类型的函数，列名也与该函数
     名相同。对于一个返回组合类型的函数，结果列会从该类型的属性得到名称。
    </para>
<!-- pgdoc-cn_end sig_en=4b177d7ad65af243abb4ed041112d231 -->

<!-- pgdoc-cn_start sig_en=3c886924b4ce030699c4a830afbda3c9 sig_cn_org=None source=14.1 
    <para>
     Some examples:
<programlisting>
CREATE TABLE foo (fooid int, foosubid int, fooname text);

CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM getfoo(1) AS t1;

SELECT * FROM foo
    WHERE foosubid IN (
                        SELECT foosubid
                        FROM getfoo(foo.fooid) z
                        WHERE z.fooid = foo.fooid
                      );

CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);

SELECT * FROM vw_getfoo;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     例子：
<programlisting>
CREATE TABLE foo (fooid int, foosubid int, fooname text);

CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM getfoo(1) AS t1;

SELECT * FROM foo
    WHERE foosubid IN (
                        SELECT foosubid
                        FROM getfoo(foo.fooid) z
                        WHERE z.fooid = foo.fooid
                      );

CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);

SELECT * FROM vw_getfoo;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=3c886924b4ce030699c4a830afbda3c9 -->

<!-- pgdoc-cn_start sig_en=13a3ec26aa2b7cd7fe2c6df08c18fe89 sig_cn_org=None source=14.1 
    <para>
     In some cases it is useful to define table functions that can
     return different column sets depending on how they are invoked.
     To support this, the table function can be declared as returning
     the pseudo-type <type>record</type> with no <literal>OUT</literal>
     parameters.  When such a function is used in
     a query, the expected row structure must be specified in the
     query itself, so that the system can know how to parse and plan
     the query.  This syntax looks like:
    </para>
________________________________________________________-->
    <para>参数的
     有时侯，定义一个能够根据它们被调用方式返回不同列集合的表函数是很有用的。
     为了支持这些，表函数可以被声明为返回没有<literal>OUT</literal>参数的伪类型<type>record</type>。
     如果在查询里使用这样的函数，那么我们必须在查询中指定所预期的行结构，这样系统才知道如何分析和规划该查询。
     这种语法是这样的：
    </para>
<!-- pgdoc-cn_end sig_en=13a3ec26aa2b7cd7fe2c6df08c18fe89 -->

<!-- pgdoc-cn_start sig_en=b8b3461f478e5c3e1077c295d4dca477 sig_cn_org=None source=14.1 
<synopsis>
<replaceable>function_call</replaceable> <optional>AS</optional> <replaceable>alias</replaceable> (<replaceable>column_definition</replaceable> <optional>, ... </optional>)
<replaceable>function_call</replaceable> AS <optional><replaceable>alias</replaceable></optional> (<replaceable>column_definition</replaceable> <optional>, ... </optional>)
ROWS FROM( ... <replaceable>function_call</replaceable> AS (<replaceable>column_definition</replaceable> <optional>, ... </optional>) <optional>, ... </optional> )
</synopsis>
________________________________________________________-->
<synopsis>
<replaceable>function_call</replaceable> <optional>AS</optional> <replaceable>alias</replaceable> (<replaceable>column_definition</replaceable> <optional>, ... </optional>)
<replaceable>function_call</replaceable> AS <optional><replaceable>alias</replaceable></optional> (<replaceable>column_definition</replaceable> <optional>, ... </optional>)
ROWS FROM( ... <replaceable>function_call</replaceable> AS (<replaceable>column_definition</replaceable> <optional>, ... </optional>) <optional>, ... </optional> )
</synopsis>
<!-- pgdoc-cn_end sig_en=b8b3461f478e5c3e1077c295d4dca477 -->

<!-- pgdoc-cn_start sig_en=7ab58739ba028c6715dc6c36013101d4 sig_cn_org=None source=14.1 
    <para>
     When not using the <literal>ROWS FROM()</literal> syntax,
     the <replaceable>column_definition</replaceable> list replaces the column
     alias list that could otherwise be attached to the <literal>FROM</literal>
     item; the names in the column definitions serve as column aliases.
     When using the <literal>ROWS FROM()</literal> syntax,
     a <replaceable>column_definition</replaceable> list can be attached to
     each member function separately; or if there is only one member function
     and no <literal>WITH ORDINALITY</literal> clause,
     a <replaceable>column_definition</replaceable> list can be written in
     place of a column alias list following <literal>ROWS FROM()</literal>.
    </para>
________________________________________________________-->
    <para>
     在没有使用<literal>ROWS FROM()</literal>语法时，
     <replaceable>column_definition</replaceable>列表会取代无法附着在
     <literal>FROM</literal>项上的列别名列表，列定义中的名称就起到列别名的作用。
     在使用<literal>ROWS FROM()</literal>语法时，
     可以为每一个成员函数单独附着一个
     <replaceable>column_definition</replaceable>列表；或者在只有一个成员
     函数并且没有<literal>WITH ORDINALITY</literal>子句的情况下，可以在
     <literal>ROWS FROM()</literal>后面写一个
     <replaceable>column_definition</replaceable>列表来取代一个列别名列表。
    </para>
<!-- pgdoc-cn_end sig_en=7ab58739ba028c6715dc6c36013101d4 -->

<!-- pgdoc-cn_start sig_en=e429630085cd5d343d38f8888aecf2ac sig_cn_org=None source=14.1 
    <para>
     Consider this example:
<programlisting>
SELECT *
    FROM dblink('dbname=mydb', 'SELECT proname, prosrc FROM pg_proc')
      AS t1(proname name, prosrc text)
    WHERE proname LIKE 'bytea%';
</programlisting>
     The <xref linkend="contrib-dblink-function"/> function
     (part of the <xref linkend="dblink"/> module) executes
     a remote query.  It is declared to return
     <type>record</type> since it might be used for any kind of query.
     The actual column set must be specified in the calling query so
     that the parser knows, for example, what <literal>*</literal> should
     expand to.
    </para>
________________________________________________________-->
    <para>
     考虑下面的例子：
<programlisting>
SELECT *
    FROM dblink('dbname=mydb', 'SELECT proname, prosrc FROM pg_proc')
      AS t1(proname name, prosrc text)
    WHERE proname LIKE 'bytea%';
</programlisting>
     <xref linkend="contrib-dblink-function"/>函数（<xref linkend="dblink"/>模块的一部分）执行一个远程的查询。它被声明为返回<type>record</type>，因为它可能会被用于任何类型的查询。 实际的列集必须在调用它的查询中指定，这样分析器才知道类似<literal>*</literal>这样的东西应该扩展成什么样子。
    </para>
<!-- pgdoc-cn_end sig_en=e429630085cd5d343d38f8888aecf2ac -->

<!-- pgdoc-cn_start sig_en=208099479164e47d34a6debf47199b04 sig_cn_org=None source=14.1 
    <para>
     This example uses <literal>ROWS FROM</literal>:
<programlisting>
SELECT *
FROM ROWS FROM
    (
        json_to_recordset('[{"a":40,"b":"foo"},{"a":"100","b":"bar"}]')
            AS (a INTEGER, b TEXT),
        generate_series(1, 3)
    ) AS x (p, q, s)
ORDER BY p;

  p  |  q  | s
-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-
  40 | foo | 1
 100 | bar | 2
     |     | 3
</programlisting>
     It joins two functions into a single <literal>FROM</literal>
     target.  <function>json_to_recordset()</function> is instructed
     to return two columns, the first <type>integer</type>
     and the second <type>text</type>.  The result of
     <function>generate_series()</function> is used directly.
     The <literal>ORDER BY</literal> clause sorts the column values
     as integers.
    </para>
________________________________________________________-->
    <para>
     此示例使用<literal>ROWS FROM</literal>：
<programlisting>
SELECT *
FROM ROWS FROM
    (
        json_to_recordset('[{"a":40,"b":"foo"},{"a":"100","b":"bar"}]')
            AS (a INTEGER, b TEXT),
        generate_series(1, 3)
    ) AS x (p, q, s)
ORDER BY p;

  p  |  q  | s
-----+-----+---
  40 | foo | 1
 100 | bar | 2
     |     | 3
</programlisting>
     它将两个函数连接到一个<literal>FROM</literal>目标中。
     <function>json_to_recordset()</function>被指示返回两列，第一个<type>integer</type>
     和第二个<type>text</type>。<function>generate_series()</function>的结果直接使用。
     <literal>ORDER BY</literal>子句将列值排序为整数。
    </para>
<!-- pgdoc-cn_end sig_en=208099479164e47d34a6debf47199b04 -->
   </sect3>

   <sect3 id="queries-lateral">
<!-- pgdoc-cn_start sig_en=cdaad735b94ef92f714c577844b74b57 sig_cn_org=None source=14.1 
    <title><literal>LATERAL</literal> Subqueries</title>
________________________________________________________-->
    <title><literal>LATERAL</literal>子查询</title>
<!-- pgdoc-cn_end sig_en=cdaad735b94ef92f714c577844b74b57 -->

<!-- pgdoc-cn_start sig_en=2da915983a026990adf0e49abad82ac6 sig_cn_org=None source=14.1 
    <indexterm zone="queries-lateral">
     <primary>LATERAL</primary>
     <secondary>in the FROM clause</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="queries-lateral">
     <primary>LATERAL</primary>
     <secondary>在FROM子句中</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=2da915983a026990adf0e49abad82ac6 -->

<!-- pgdoc-cn_start sig_en=bc1a1616640f1267172ba46f53952374 sig_cn_org=None source=14.1 
    <para>
     Subqueries appearing in <literal>FROM</literal> can be
     preceded by the key word <literal>LATERAL</literal>.  This allows them to
     reference columns provided by preceding <literal>FROM</literal> items.
     (Without <literal>LATERAL</literal>, each subquery is
     evaluated independently and so cannot cross-reference any other
     <literal>FROM</literal> item.)
    </para>
________________________________________________________-->
    <para>
     可以在出现于<literal>FROM</literal>中的子查询前放置关键词<literal>LATERAL</literal>。这允许它们引用前面的<literal>FROM</literal>项提供的列（如果没有<literal>LATERAL</literal>，每一个子查询将被独立计算，并且因此不能被其他<literal>FROM</literal>项交叉引用）。
    </para>
<!-- pgdoc-cn_end sig_en=bc1a1616640f1267172ba46f53952374 -->

<!-- pgdoc-cn_start sig_en=ae5165b23424dd1498b312916987d471 sig_cn_org=None source=14.1 
    <para>
     Table functions appearing in <literal>FROM</literal> can also be
     preceded by the key word <literal>LATERAL</literal>, but for functions the
     key word is optional; the function's arguments can contain references
     to columns provided by preceding <literal>FROM</literal> items in any case.
    </para>
________________________________________________________-->
    <para>
     出现在<literal>FROM</literal>中的表函数的前面也可以被放上关键词<literal>LATERAL</literal>，但对于函数该关键词是可选的，在任何情况下函数的参数都可以包含对前面的<literal>FROM</literal>项提供的列的引用。
    </para>
<!-- pgdoc-cn_end sig_en=ae5165b23424dd1498b312916987d471 -->

<!-- pgdoc-cn_start sig_en=637d2953e5fd3af04ace016f15e85ca3 sig_cn_org=e9d12ad8db7f41b9dc5b1135c80349c8 source=15.7 
    <para>
     A <literal>LATERAL</literal> item can appear at the top level in the
     <literal>FROM</literal> list, or within a <literal>JOIN</literal> tree.  In the latter
     case it can also refer to any items that are on the left-hand side of a
     <literal>JOIN</literal> that it is on the right-hand side of.
    </para>
________________________________________________________-->
    <para>
     一个<literal>LATERAL</literal>项可以出现在<literal>FROM</literal>列表的顶层，或者在<literal>JOIN</literal>树中。
     在后一种情况下，它还可以引用任何在它右侧的<literal>JOIN</literal>左侧的项。
    </para>
<!-- pgdoc-cn_end sig_en=637d2953e5fd3af04ace016f15e85ca3 -->

<!-- pgdoc-cn_start sig_en=191c1998a647ec01a58e7c245ff8a47a sig_cn_org=None source=14.1 
    <para>
     When a <literal>FROM</literal> item contains <literal>LATERAL</literal>
     cross-references, evaluation proceeds as follows: for each row of the
     <literal>FROM</literal> item providing the cross-referenced column(s), or
     set of rows of multiple <literal>FROM</literal> items providing the
     columns, the <literal>LATERAL</literal> item is evaluated using that
     row or row set's values of the columns.  The resulting row(s) are
     joined as usual with the rows they were computed from.  This is
     repeated for each row or set of rows from the column source table(s).
    </para>
________________________________________________________-->
    <para>
     如果一个<literal>FROM</literal>项包含<literal>LATERAL</literal>交叉引用，计算过程如下：对于提供交叉引用列的<literal>FROM</literal>项的每一行，或者多个提供这些列的多个<literal>FROM</literal>项的行集合，<literal>LATERAL</literal>项将被使用该行或者行集中的列值进行计算。得到的结果行将和它们被计算出来的行进行正常的连接。对于来自这些列的源表的每一行或行集，该过程将重复。
    </para>
<!-- pgdoc-cn_end sig_en=191c1998a647ec01a58e7c245ff8a47a -->

<!-- pgdoc-cn_start sig_en=e29820e83874db987937ead63edd26bf sig_cn_org=None source=14.1 
    <para>
     A trivial example of <literal>LATERAL</literal> is
<programlisting>
SELECT * FROM foo, LATERAL (SELECT * FROM bar WHERE bar.id = foo.bar_id) ss;
</programlisting>
     This is not especially useful since it has exactly the same result as
     the more conventional
<programlisting>
SELECT * FROM foo, bar WHERE bar.id = foo.bar_id;
</programlisting>
     <literal>LATERAL</literal> is primarily useful when the cross-referenced
     column is necessary for computing the row(s) to be joined.  A common
     application is providing an argument value for a set-returning function.
     For example, supposing that <function>vertices(polygon)</function> returns the
     set of vertices of a polygon, we could identify close-together vertices
     of polygons stored in a table with:
<programlisting>
SELECT p1.id, p2.id, v1, v2
FROM polygons p1, polygons p2,
     LATERAL vertices(p1.poly) v1,
     LATERAL vertices(p2.poly) v2
WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;
</programlisting>
     This query could also be written
<programlisting>
SELECT p1.id, p2.id, v1, v2
FROM polygons p1 CROSS JOIN LATERAL vertices(p1.poly) v1,
     polygons p2 CROSS JOIN LATERAL vertices(p2.poly) v2
WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;
</programlisting>
     or in several other equivalent formulations.  (As already mentioned,
     the <literal>LATERAL</literal> key word is unnecessary in this example, but
     we use it for clarity.)
    </para>
________________________________________________________-->
    <para>
     <literal>LATERAL</literal>的一个简单例子：
<programlisting>
SELECT * FROM foo, LATERAL (SELECT * FROM bar WHERE bar.id = foo.bar_id) ss;
</programlisting>
     这不是非常有用，因为它和一种更简单的形式得到的结果完全一样：
<programlisting>
SELECT * FROM foo, bar WHERE bar.id = foo.bar_id;
</programlisting>
     在必须要使用交叉引用列来计算那些即将要被连接的行时，<literal>LATERAL</literal>是最有用的。一种常用的应用是为一个返回集合的函数提供一个参数值。例如，假设<function>vertices(polygon)</function>返回一个多边形的顶点集合，我们可以这样标识存储在一个表中的多边形中靠近的顶点：
<programlisting>
SELECT p1.id, p2.id, v1, v2
FROM polygons p1, polygons p2,
     LATERAL vertices(p1.poly) v1,
     LATERAL vertices(p2.poly) v2
WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;
</programlisting>
     这个查询也可以被写成：
<programlisting>
SELECT p1.id, p2.id, v1, v2
FROM polygons p1 CROSS JOIN LATERAL vertices(p1.poly) v1,
     polygons p2 CROSS JOIN LATERAL vertices(p2.poly) v2
WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;
</programlisting>
     或者写成其他几种等价的公式（正如以上提到的，<literal>LATERAL</literal>关键词在这个例子中并不是必不可少的，但是我们在这里使用它是为了使表述更清晰）。
    </para>
<!-- pgdoc-cn_end sig_en=e29820e83874db987937ead63edd26bf -->

<!-- pgdoc-cn_start sig_en=d98822ae097d191d9c80fe815eadc7ff sig_cn_org=None source=14.1 
    <para>
     It is often particularly handy to <literal>LEFT JOIN</literal> to a
     <literal>LATERAL</literal> subquery, so that source rows will appear in
     the result even if the <literal>LATERAL</literal> subquery produces no
     rows for them.  For example, if <function>get_product_names()</function> returns
     the names of products made by a manufacturer, but some manufacturers in
     our table currently produce no products, we could find out which ones
     those are like this:
<programlisting>
SELECT m.name
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true
WHERE pname IS NULL;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     有时候也会很特别地把<literal>LEFT JOIN</literal>放在一个<literal>LATERAL</literal>子查询的前面，这样即使<literal>LATERAL</literal>子查询对源行不产生行，源行也会出现在结果中。例如，如果<function>get_product_names()</function>返回一个制造商制造的产品的名字，但是某些制造商在我们的表中目前没有制造产品，我们可以找出哪些制造商是这样：
<programlisting>
SELECT m.name
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true
WHERE pname IS NULL;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=d98822ae097d191d9c80fe815eadc7ff -->
   </sect3>
  </sect2>

  <sect2 id="queries-where">
<!-- pgdoc-cn_start sig_en=f669615843c55abaeea54d46bf87673e sig_cn_org=None source=14.1 
   <title>The <literal>WHERE</literal> Clause</title>
________________________________________________________-->
   <title><literal>WHERE</literal>子句</title>
<!-- pgdoc-cn_end sig_en=f669615843c55abaeea54d46bf87673e -->

<!-- pgdoc-cn_start sig_en=fc0016e6c57db2f63f3e2e0d7f7be176 sig_cn_org=None source=14.1 
   <indexterm zone="queries-where">
    <primary>WHERE</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="queries-where">
    <primary>WHERE</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=fc0016e6c57db2f63f3e2e0d7f7be176 -->

<!-- pgdoc-cn_start sig_en=dd36a365a5feeff889b329a449d0227c sig_cn_org=None source=14.1 
   <para>
    The syntax of the <link linkend="sql-where"><literal>WHERE</literal></link>
    clause is
<synopsis>
WHERE <replaceable>search_condition</replaceable>
</synopsis>
    where <replaceable>search_condition</replaceable> is any value
    expression (see <xref linkend="sql-expressions"/>) that
    returns a value of type <type>boolean</type>.
   </para>
________________________________________________________-->
   <para>
    <link linkend="sql-where"><literal>WHERE</literal></link>子句的语法是
<synopsis>
WHERE <replaceable>search_condition</replaceable>
</synopsis>
    这里的<replaceable>search_condition</replaceable>是任意返回一个<type>boolean</type>类型值的值表达式（参阅<xref linkend="sql-expressions"/>）。
   </para>
<!-- pgdoc-cn_end sig_en=dd36a365a5feeff889b329a449d0227c -->

<!-- pgdoc-cn_start sig_en=01f6625ff3ee881e026da8dbf8d978be sig_cn_org=None source=14.1 
   <para>
    After the processing of the <literal>FROM</literal> clause is done, each
    row of the derived virtual table is checked against the search
    condition.  If the result of the condition is true, the row is
    kept in the output table, otherwise (i.e., if the result is
    false or null) it is discarded.  The search condition typically
    references at least one column of the table generated in the
    <literal>FROM</literal> clause; this is not required, but otherwise the
    <literal>WHERE</literal> clause will be fairly useless.
   </para>
________________________________________________________-->
   <para>
    在完成对<literal>FROM</literal>子句的处理之后，生成的虚拟表的每一行都会对根据搜索条件进行检查。 如果该条件的结果是真，那么该行被保留在输出表中；否则（也就是说，如果结果是假或空）就把它抛弃。搜索条件通常至少要引用一些在<literal>FROM</literal>子句里生成的列；虽然这不是必须的，但如果不引用这些列，那么<literal>WHERE</literal>子句就没什么用了。
   </para>
<!-- pgdoc-cn_end sig_en=01f6625ff3ee881e026da8dbf8d978be -->

   <note>
<!-- pgdoc-cn_start sig_en=80f956b234246c0fa35d72d62db210dd sig_cn_org=None source=14.1 
    <para>
     The join condition of an inner join can be written either in
     the <literal>WHERE</literal> clause or in the <literal>JOIN</literal> clause.
     For example, these table expressions are equivalent:
<programlisting>
FROM a, b WHERE a.id = b.id AND b.val &gt; 5
</programlisting>
     and:
<programlisting>
FROM a INNER JOIN b ON (a.id = b.id) WHERE b.val &gt; 5
</programlisting>
     or perhaps even:
<programlisting>
FROM a NATURAL JOIN b WHERE b.val &gt; 5
</programlisting>
     Which one of these you use is mainly a matter of style.  The
     <literal>JOIN</literal> syntax in the <literal>FROM</literal> clause is
     probably not as portable to other SQL database management systems,
     even though it is in the SQL standard.  For
     outer joins there is no choice:  they must be done in
     the <literal>FROM</literal> clause.  The <literal>ON</literal> or <literal>USING</literal>
     clause of an outer join is <emphasis>not</emphasis> equivalent to a
     <literal>WHERE</literal> condition, because it results in the addition
     of rows (for unmatched input rows) as well as the removal of rows
     in the final result.
    </para>
________________________________________________________-->
    <para>
     内连接的连接条件既可以写在<literal>WHERE</literal>子句也可以写在<literal>JOIN</literal>子句里。例如，这些表表达式是等效的：
<programlisting>
FROM a, b WHERE a.id = b.id AND b.val &gt; 5
</programlisting>
     和：
<programlisting>
FROM a INNER JOIN b ON (a.id = b.id) WHERE b.val &gt; 5
</programlisting>
     或者可能还有：
<programlisting>
FROM a NATURAL JOIN b WHERE b.val &gt; 5
</programlisting>
     你想用哪个只是一个风格问题。<literal>FROM</literal>子句里的<literal>JOIN</literal>语法可能不那么容易移植到其它SQL数据库管理系统中。 对于外部连接而言没有选择：它们必须在<literal>FROM</literal>子句中完成。 外部连接的<literal>ON</literal>或<literal>USING</literal>子句<emphasis>不</emphasis>等于<literal>WHERE</literal>条件，因为它导致最终结果中行的增加（对那些不匹配的输入行）和减少。
    </para>
<!-- pgdoc-cn_end sig_en=80f956b234246c0fa35d72d62db210dd -->
   </note>

<!-- pgdoc-cn_start sig_en=5ad49c030ff5e135975954da1fcf3237 sig_cn_org=None source=14.1 
   <para>
    Here are some examples of <literal>WHERE</literal> clauses:
<programlisting>
SELECT ... FROM fdt WHERE c1 &gt; 5

SELECT ... FROM fdt WHERE c1 IN (1, 2, 3)

SELECT ... FROM fdt WHERE c1 IN (SELECT c1 FROM t2)

SELECT ... FROM fdt WHERE c1 IN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10)

SELECT ... FROM fdt WHERE c1 BETWEEN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10) AND 100

SELECT ... FROM fdt WHERE EXISTS (SELECT c1 FROM t2 WHERE c2 &gt; fdt.c1)
</programlisting>
    <literal>fdt</literal> is the table derived in the
    <literal>FROM</literal> clause. Rows that do not meet the search
    condition of the <literal>WHERE</literal> clause are eliminated from
    <literal>fdt</literal>. Notice the use of scalar subqueries as
    value expressions.  Just like any other query, the subqueries can
    employ complex table expressions.  Notice also how
    <literal>fdt</literal> is referenced in the subqueries.
    Qualifying <literal>c1</literal> as <literal>fdt.c1</literal> is only necessary
    if <literal>c1</literal> is also the name of a column in the derived
    input table of the subquery.  But qualifying the column name adds
    clarity even when it is not needed.  This example shows how the column
    naming scope of an outer query extends into its inner queries.
   </para>
________________________________________________________-->
   <para>
    这里是一些<literal>WHERE</literal>子句的例子：
<programlisting>
SELECT ... FROM fdt WHERE c1 &gt; 5

SELECT ... FROM fdt WHERE c1 IN (1, 2, 3)

SELECT ... FROM fdt WHERE c1 IN (SELECT c1 FROM t2)

SELECT ... FROM fdt WHERE c1 IN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10)

SELECT ... FROM fdt WHERE c1 BETWEEN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10) AND 100

SELECT ... FROM fdt WHERE EXISTS (SELECT c1 FROM t2 WHERE c2 &gt; fdt.c1)
</programlisting>
    在上面的例子里，<literal>fdt</literal>是从FROM子句中派生的表。 那些不符合<literal>WHERE</literal>子句的搜索条件的行会被从<literal>fdt</literal>中删除。请注意我们把标量子查询当做一个值表达式来用。 和任何其它查询一样，子查询里可以使用复杂的表表达式。同时还请注意<literal>fdt</literal>在子查询中也被引用。只有在<literal>c1</literal>也是作为子查询输入表的生成表的列时，才必须把<literal>c1</literal>限定成<literal>fdt.c1</literal>。但限定列名字可以增加语句的清晰度，即使有时候不是必须的。这个例子展示了一个外层查询的列名范围如何扩展到它的内层查询。
   </para>
<!-- pgdoc-cn_end sig_en=5ad49c030ff5e135975954da1fcf3237 -->
  </sect2>


  <sect2 id="queries-group">
<!-- pgdoc-cn_start sig_en=b1bb351b1a3f8f7c3dc034a2f7fca671 sig_cn_org=None source=14.1 
   <title>The <literal>GROUP BY</literal> and <literal>HAVING</literal> Clauses</title>
________________________________________________________-->
   <title><literal>GROUP BY</literal>和<literal>HAVING</literal>子句</title>
<!-- pgdoc-cn_end sig_en=b1bb351b1a3f8f7c3dc034a2f7fca671 -->

<!-- pgdoc-cn_start sig_en=bf5478b87cc91ba248c887cf06a8c519 sig_cn_org=None source=14.1 
   <indexterm zone="queries-group">
    <primary>GROUP BY</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="queries-group">
    <primary>GROUP BY</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=bf5478b87cc91ba248c887cf06a8c519 -->

<!-- pgdoc-cn_start sig_en=7092e11953234e043a63f72cf3c15417 sig_cn_org=None source=14.1 
   <indexterm zone="queries-group">
    <primary>grouping</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="queries-group">
    <primary>分组</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=7092e11953234e043a63f72cf3c15417 -->

<!-- pgdoc-cn_start sig_en=9ea62376e65b3d5acc0eb45602d5d291 sig_cn_org=None source=14.1 
   <para>
    After passing the <literal>WHERE</literal> filter, the derived input
    table might be subject to grouping, using the <literal>GROUP BY</literal>
    clause, and elimination of group rows using the <literal>HAVING</literal>
    clause.
   </para>
________________________________________________________-->
   <para>
    在通过了<literal>WHERE</literal>过滤器之后，生成的输入表可以使用<literal>GROUP BY</literal>子句进行分组，然后用<literal>HAVING</literal>子句删除一些分组行。
   </para>
<!-- pgdoc-cn_end sig_en=9ea62376e65b3d5acc0eb45602d5d291 -->

<!-- pgdoc-cn_start sig_en=9d8ae77b28dd7c1926397c8a3d6a7d58 sig_cn_org=None source=14.1 
<synopsis>
SELECT <replaceable>select_list</replaceable>
    FROM ...
    <optional>WHERE ...</optional>
    GROUP BY <replaceable>grouping_column_reference</replaceable> <optional>, <replaceable>grouping_column_reference</replaceable></optional>...
</synopsis>
________________________________________________________-->
<synopsis>
SELECT <replaceable>select_list</replaceable>
    FROM ...
    <optional>WHERE ...</optional>
    GROUP BY <replaceable>grouping_column_reference</replaceable> <optional>, <replaceable>grouping_column_reference</replaceable></optional>...
</synopsis>
<!-- pgdoc-cn_end sig_en=9d8ae77b28dd7c1926397c8a3d6a7d58 -->

<!-- pgdoc-cn_start sig_en=5a145f6f9c246fc086cae9ffaa6cc95c sig_cn_org=None source=14.1 
   <para>
    The <link linkend="sql-groupby"><literal>GROUP BY</literal></link> clause is
    used to group together those rows in a table that have the same
    values in all the columns listed. The order in which the columns
    are listed does not matter.  The effect is to combine each set
    of rows having common values into one group row that
    represents all rows in the group.  This is done to
    eliminate redundancy in the output and/or compute aggregates that
    apply to these groups.  For instance:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM test1;</userinput>
 x | y
-&minus;-+-&minus;-
 a | 3
 c | 2
 b | 5
 a | 1
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT x FROM test1 GROUP BY x;</userinput>
 x
-&minus;-
 a
 b
 c
(3 rows)
</screen>
   </para>
________________________________________________________-->
   <para>
    <link linkend="sql-groupby"><literal>GROUP BY</literal></link>子句被用来把表中在所列出的列上具有相同值的行分组在一起。 这些列的列出顺序并没有什么关系。其效果是把每组具有相同值的行组合为一个组行，它代表该组里的所有行。 这样就可以删除输出里的重复和/或计算应用于这些组的聚集。例如：
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM test1;</userinput>
 x | y
---+---
 a | 3
 c | 2
 b | 5
 a | 1
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT x FROM test1 GROUP BY x;</userinput>
 x
---
 a
 b
 c
(3 rows)
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=5a145f6f9c246fc086cae9ffaa6cc95c -->

<!-- pgdoc-cn_start sig_en=571141c139737013e8a628e504ba0d15 sig_cn_org=None source=14.1 
   <para>
    In the second query, we could not have written <literal>SELECT *
    FROM test1 GROUP BY x</literal>, because there is no single value
    for the column <literal>y</literal> that could be associated with each
    group.  The grouped-by columns can be referenced in the select list since
    they have a single value in each group.
   </para>
________________________________________________________-->
   <para>
    在第二个查询里，我们不能写成<literal>SELECT * FROM test1 GROUP BY x</literal>， 因为列<literal>y</literal>里没有哪个值可以和每个组相关联起来。被分组的列可以在选择列表中引用是因为它们在每个组都有单一的值。
   </para>
<!-- pgdoc-cn_end sig_en=571141c139737013e8a628e504ba0d15 -->

<!-- pgdoc-cn_start sig_en=b0417e05d78bed7ea42aaf524185af44 sig_cn_org=None source=14.1 
   <para>
    In general, if a table is grouped, columns that are not
    listed in <literal>GROUP BY</literal> cannot be referenced except in aggregate
    expressions.  An example with aggregate expressions is:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x;</userinput>
 x | sum
-&minus;-+-&minus;-&minus;-
 a |   4
 b |   5
 c |   2
(3 rows)
</screen>
    Here <literal>sum</literal> is an aggregate function that
    computes a single value over the entire group.  More information
    about the available aggregate functions can be found in <xref
    linkend="functions-aggregate"/>.
   </para>
________________________________________________________-->
   <para>
    通常，如果一个表被分了组，那么没有在<literal>GROUP BY</literal>中列出的列都不能被引用，除非在聚集表达式中被引用。 一个用聚集表达式的例子是：
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x;</userinput>
 x | sum
---+-----
 a |   4
 b |   5
 c |   2
(3 rows)
</screen>
    这里的<literal>sum</literal>是一个聚集函数，它在整个组上计算出一个单一值。有关可用的聚集函数的更多信息可以在<xref linkend="functions-aggregate"/>。
   </para>
<!-- pgdoc-cn_end sig_en=b0417e05d78bed7ea42aaf524185af44 -->

   <tip>
<!-- pgdoc-cn_start sig_en=af7f19dcf418947ff7f0510d009bda03 sig_cn_org=None source=14.1 
    <para>
     Grouping without aggregate expressions effectively calculates the
     set of distinct values in a column.  This can also be achieved
     using the <literal>DISTINCT</literal> clause (see <xref
     linkend="queries-distinct"/>).
    </para>
________________________________________________________-->
    <para>
     没有聚集表达式的分组实际上计算了一个列中可区分值的集合。我们也可以用<literal>DISTINCT</literal>子句实现（参阅<xref linkend="queries-distinct"/>）。
    </para>
<!-- pgdoc-cn_end sig_en=af7f19dcf418947ff7f0510d009bda03 -->
   </tip>

<!-- pgdoc-cn_start sig_en=3776bbfec0eca49e0e39307cbbb305ab sig_cn_org=None source=14.1 
   <para>
    Here is another example:  it calculates the total sales for each
    product (rather than the total sales of all products):
<programlisting>
SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
    FROM products p LEFT JOIN sales s USING (product_id)
    GROUP BY product_id, p.name, p.price;
</programlisting>
    In this example, the columns <literal>product_id</literal>,
    <literal>p.name</literal>, and <literal>p.price</literal> must be
    in the <literal>GROUP BY</literal> clause since they are referenced in
    the query select list (but see below).  The column
    <literal>s.units</literal> does not have to be in the <literal>GROUP
    BY</literal> list since it is only used in an aggregate expression
    (<literal>sum(...)</literal>), which represents the sales
    of a product.  For each product, the query returns a summary row about
    all sales of the product.
   </para>
________________________________________________________-->
   <para>
    这里是另外一个例子：它计算每种产品的总销售额（而不是所有产品的总销售额）：
<programlisting>
SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
    FROM products p LEFT JOIN sales s USING (product_id)
    GROUP BY product_id, p.name, p.price;
</programlisting>
    在这个例子里，列<literal>product_id</literal>、<literal>p.name</literal>和<literal>p.price</literal>必须在<literal>GROUP BY</literal>子句里， 因为它们都在查询的选择列表里被引用到（但见下文）。列<literal>s.units</literal>不必在<literal>GROUP BY</literal>列表里，因为它只是在一个聚集表达式（<literal>sum(...)</literal>）里使用，它代表一组产品的销售额。对于每种产品，这个查询都返回一个该产品的所有销售额的总和行。
   </para>
<!-- pgdoc-cn_end sig_en=3776bbfec0eca49e0e39307cbbb305ab -->

<!-- pgdoc-cn_start sig_en=32753a27e1a4dc5414a70654a6d4af12 sig_cn_org=None source=14.1 
   <indexterm><primary>functional dependency</primary></indexterm>
________________________________________________________-->
   <indexterm><primary>函数依赖</primary></indexterm>
<!-- pgdoc-cn_end sig_en=32753a27e1a4dc5414a70654a6d4af12 -->

<!-- pgdoc-cn_start sig_en=c0206a3c9b12130e521c618f13ae8f05 sig_cn_org=None source=14.1 
   <para>
    If the products table is set up so that, say,
    <literal>product_id</literal> is the primary key, then it would be
    enough to group by <literal>product_id</literal> in the above example,
    since name and price would be <firstterm>functionally
    dependent</firstterm> on the product ID, and so there would be no
    ambiguity about which name and price value to return for each product
    ID group.
   </para>
________________________________________________________-->
   <para>
    如果产品表被建立起来，例如<literal>product_id</literal>是主键，那么在上面的例子中用<literal>product_id</literal>来分组就够了，因为名称和价格都是<firstterm>函数依赖</firstterm>于产品ID，并且关于为每个产品ID分组返回哪个名称和价格值就不会有歧义。
   </para>
<!-- pgdoc-cn_end sig_en=c0206a3c9b12130e521c618f13ae8f05 -->

<!-- pgdoc-cn_start sig_en=685f0d42ae1cf9532dc1810b9ad2bbc3 sig_cn_org=None source=14.1 
   <para>
    In strict SQL, <literal>GROUP BY</literal> can only group by columns of
    the source table but <productname>PostgreSQL</productname> extends
    this to also allow <literal>GROUP BY</literal> to group by columns in the
    select list.  Grouping by value expressions instead of simple
    column names is also allowed.
   </para>
________________________________________________________-->
   <para>
    在严格的 SQL 里，<literal>GROUP BY</literal>只能对源表的列进行分组，但<productname>PostgreSQL</productname>把这个扩展为也允许<literal>GROUP BY</literal>去根据选择列表中的列分组。也允许对值表达式进行分组，而不仅是简单的列名。
   </para>
<!-- pgdoc-cn_end sig_en=685f0d42ae1cf9532dc1810b9ad2bbc3 -->

<!-- pgdoc-cn_start sig_en=c9220a85b0d83c52f7a50892f3b9b51e sig_cn_org=None source=14.1 
   <indexterm>
    <primary>HAVING</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>HAVING</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=c9220a85b0d83c52f7a50892f3b9b51e -->

<!-- pgdoc-cn_start sig_en=dafad1034f4fb98364161530a580f4b4 sig_cn_org=None source=14.1 
   <para>
    If a table has been grouped using <literal>GROUP BY</literal>,
    but only certain groups are of interest, the
    <literal>HAVING</literal> clause can be used, much like a
    <literal>WHERE</literal> clause, to eliminate groups from the result.
    The syntax is:
<synopsis>
SELECT <replaceable>select_list</replaceable> FROM ... <optional>WHERE ...</optional> GROUP BY ... HAVING <replaceable>boolean_expression</replaceable>
</synopsis>
    Expressions in the <literal>HAVING</literal> clause can refer both to
    grouped expressions and to ungrouped expressions (which necessarily
    involve an aggregate function).
   </para>
________________________________________________________-->
   <para>
    如果一个表已经用<literal>GROUP BY</literal>子句分了组，然后你又只对其中的某些组感兴趣， 那么就可以用<literal>HAVING</literal>子句，它很象<literal>WHERE</literal>子句，用于从结果中删除一些组。其语法是：
<synopsis>
SELECT <replaceable>select_list</replaceable> FROM ... <optional>WHERE ...</optional> GROUP BY ... HAVING <replaceable>boolean_expression</replaceable>
</synopsis>
    在<literal>HAVING</literal>子句中的表达式可以引用分组的表达式和未分组的表达式（后者必须涉及一个聚集函数）。
   </para>
<!-- pgdoc-cn_end sig_en=dafad1034f4fb98364161530a580f4b4 -->

<!-- pgdoc-cn_start sig_en=33a39d3b6b87aa90acda8212227cdef9 sig_cn_org=None source=14.1 
   <para>
    Example:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) &gt; 3;</userinput>
 x | sum
-&minus;-+-&minus;-&minus;-
 a |   4
 b |   5
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING x &lt; 'c';</userinput>
 x | sum
-&minus;-+-&minus;-&minus;-
 a |   4
 b |   5
(2 rows)
</screen>
   </para>
________________________________________________________-->
   <para>
    例子：
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) &gt; 3;</userinput>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)

<prompt>=&gt;</prompt> <userinput>SELECT x, sum(y) FROM test1 GROUP BY x HAVING x &lt; 'c';</userinput>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=33a39d3b6b87aa90acda8212227cdef9 -->

<!-- pgdoc-cn_start sig_en=55c35a563083480a4f53d1b78f59312e sig_cn_org=None source=14.1 
   <para>
    Again, a more realistic example:
<programlisting>
SELECT product_id, p.name, (sum(s.units) * (p.price - p.cost)) AS profit
    FROM products p LEFT JOIN sales s USING (product_id)
    WHERE s.date &gt; CURRENT_DATE - INTERVAL '4 weeks'
    GROUP BY product_id, p.name, p.price, p.cost
    HAVING sum(p.price * s.units) &gt; 5000;
</programlisting>
    In the example above, the <literal>WHERE</literal> clause is selecting
    rows by a column that is not grouped (the expression is only true for
    sales during the last four weeks), while the <literal>HAVING</literal>
    clause restricts the output to groups with total gross sales over
    5000.  Note that the aggregate expressions do not necessarily need
    to be the same in all parts of the query.
   </para>
________________________________________________________-->
   <para>
    再次，一个更现实的例子：
<programlisting>
SELECT product_id, p.name, (sum(s.units) * (p.price - p.cost)) AS profit
    FROM products p LEFT JOIN sales s USING (product_id)
    WHERE s.date &gt; CURRENT_DATE - INTERVAL '4 weeks'
    GROUP BY product_id, p.name, p.price, p.cost
    HAVING sum(p.price * s.units) &gt; 5000;
</programlisting>
    在上面的例子里，<literal>WHERE</literal>子句用那些非分组的列选择数据行（表达式只是对那些最近四周发生的销售为真）。 而<literal>HAVING</literal>子句限制输出为总销售收入超过 5000 的组。请注意聚集表达式不需要在查询中的所有地方都一样。
   </para>
<!-- pgdoc-cn_end sig_en=55c35a563083480a4f53d1b78f59312e -->

<!-- pgdoc-cn_start sig_en=fb3752bd8958ec5c0ab606a59df91d74 sig_cn_org=None source=14.1 
   <para>
    If a query contains aggregate function calls, but no <literal>GROUP BY</literal>
    clause, grouping still occurs: the result is a single group row (or
    perhaps no rows at all, if the single row is then eliminated by
    <literal>HAVING</literal>).
    The same is true if it contains a <literal>HAVING</literal> clause, even
    without any aggregate function calls or <literal>GROUP BY</literal> clause.
   </para>
________________________________________________________-->
   <para>
    如果一个查询包含聚集函数调用，但是没有<literal>GROUP BY</literal>子句，分组仍然会发生：结果是一个单一行（或者根本就没有行，如果该单一行被<literal>HAVING</literal>所消除）。它包含一个<literal>HAVING</literal>子句时也是这样，即使没有任何聚集函数调用或者<literal>GROUP BY</literal>子句。
   </para>
<!-- pgdoc-cn_end sig_en=fb3752bd8958ec5c0ab606a59df91d74 -->
  </sect2>

  <sect2 id="queries-grouping-sets">
<!-- pgdoc-cn_start sig_en=3f124ceead2f438554e016a6a6066647 sig_cn_org=None source=14.1 
   <title><literal>GROUPING SETS</literal>, <literal>CUBE</literal>, and <literal>ROLLUP</literal></title>
________________________________________________________-->
   <title><literal>GROUPING SETS</literal>、<literal>CUBE</literal>和<literal>ROLLUP</literal></title>
<!-- pgdoc-cn_end sig_en=3f124ceead2f438554e016a6a6066647 -->

<!-- pgdoc-cn_start sig_en=34e60620e0ec9b9751d5a9155e6c7f6e sig_cn_org=None source=14.1 
   <indexterm zone="queries-grouping-sets">
    <primary>GROUPING SETS</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="queries-grouping-sets">
    <primary>GROUPING SETS</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=34e60620e0ec9b9751d5a9155e6c7f6e -->
<!-- pgdoc-cn_start sig_en=b39b8049f17eb91d0670b6696c8be8b8 sig_cn_org=None source=14.1 
   <indexterm zone="queries-grouping-sets">
    <primary>CUBE</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="queries-grouping-sets">
    <primary>CUBE</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=b39b8049f17eb91d0670b6696c8be8b8 -->
<!-- pgdoc-cn_start sig_en=446f6fcbfae46d616984583d0e55365c sig_cn_org=None source=14.1 
   <indexterm zone="queries-grouping-sets">
    <primary>ROLLUP</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="queries-grouping-sets">
    <primary>ROLLUP</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=446f6fcbfae46d616984583d0e55365c -->

<!-- pgdoc-cn_start sig_en=af1174b6f99220da908da3965c57944e sig_cn_org=None source=14.1 
   <para>
    More complex grouping operations than those described above are possible
    using the concept of <firstterm>grouping sets</firstterm>.  The data selected by
    the <literal>FROM</literal> and <literal>WHERE</literal> clauses is grouped separately
    by each specified grouping set, aggregates computed for each group just as
    for simple <literal>GROUP BY</literal> clauses, and then the results returned.
    For example:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM items_sold;</userinput>
 brand | size | sales
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-
 Foo   | L    |  10
 Foo   | M    |  20
 Bar   | M    |  15
 Bar   | L    |  5
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT brand, size, sum(sales) FROM items_sold GROUP BY GROUPING SETS ((brand), (size), ());</userinput>
 brand | size | sum
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-
 Foo   |      |  30
 Bar   |      |  20
       | L    |  15
       | M    |  35
       |      |  50
(5 rows)
</screen>
   </para>
________________________________________________________-->
   <para>
    使用<firstterm>分组集</firstterm>的概念可以实现比上述更加复杂的分组操作。由
    <literal>FROM</literal>和<literal>WHERE</literal>子句选出的数据被按照每一个指定
    的分组集单独分组，按照简单<literal>GROUP BY</literal>子句对每一个分组计算
    聚集，然后返回结果。例如：
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM items_sold;</userinput>
 brand | size | sales
-------+------+-------
 Foo   | L    |  10
 Foo   | M    |  20
 Bar   | M    |  15
 Bar   | L    |  5
(4 rows)

<prompt>=&gt;</prompt> <userinput>SELECT brand, size, sum(sales) FROM items_sold GROUP BY GROUPING SETS ((brand), (size), ());</userinput>
 brand | size | sum
-------+------+-----
 Foo   |      |  30
 Bar   |      |  20
       | L    |  15
       | M    |  35
       |      |  50
(5 rows)
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=af1174b6f99220da908da3965c57944e -->

<!-- pgdoc-cn_start sig_en=7030644e89f92b5be0f3f733b3fc63ea sig_cn_org=None source=14.1 
   <para>
    Each sublist of <literal>GROUPING SETS</literal> may specify zero or more columns
    or expressions and is interpreted the same way as though it were directly
    in the <literal>GROUP BY</literal> clause.  An empty grouping set means that all
    rows are aggregated down to a single group (which is output even if no
    input rows were present), as described above for the case of aggregate
    functions with no <literal>GROUP BY</literal> clause.
   </para>
________________________________________________________-->
   <para>
    <literal>GROUPING SETS</literal>的每一个子列表可以指定一个或者多个列或者表达式，
    它们将按照直接出现在<literal>GROUP BY</literal>子句中同样的方式被解释。一个空的
    分组集表示所有的行都要被聚集到一个单一分组（即使没有输入行存在也会被输出）
    中，这就像前面所说的没有<literal>GROUP BY</literal>子句的聚集函数的情况一样。
   </para>
<!-- pgdoc-cn_end sig_en=7030644e89f92b5be0f3f733b3fc63ea -->

<!-- pgdoc-cn_start sig_en=72bafc31e3e887a9fd47a9b195f59db4 sig_cn_org=None source=14.1 
   <para>
    References to the grouping columns or expressions are replaced
    by null values in result rows for grouping sets in which those
    columns do not appear.  To distinguish which grouping a particular output
    row resulted from, see <xref linkend="functions-grouping-table"/>.
   </para>
________________________________________________________-->
   <para>
    对于分组列或表达式没有出现在其中的分组集的结果行，对分组列或表达式的引用会
    被空值所替代。要区分一个特定的输出行来自于哪个分组，请见
    <xref linkend="functions-grouping-table"/>。
   </para>
<!-- pgdoc-cn_end sig_en=72bafc31e3e887a9fd47a9b195f59db4 -->

<!-- pgdoc-cn_start sig_en=22546c8fd7d887bdc5825b6867e93f15 sig_cn_org=None source=14.1 
   <para>
    A shorthand notation is provided for specifying two common types of grouping set.
    A clause of the form
<programlisting>
ROLLUP ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, <replaceable>e3</replaceable>, ... )
</programlisting>
    represents the given list of expressions and all prefixes of the list including
    the empty list; thus it is equivalent to
<programlisting>
GROUPING SETS (
    ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, <replaceable>e3</replaceable>, ... ),
    ...
    ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable> ),
    ( <replaceable>e1</replaceable> ),
    ( )
)
</programlisting>
    This is commonly used for analysis over hierarchical data; e.g., total
    salary by department, division, and company-wide total.
   </para>
________________________________________________________-->
   <para>
    PostgreSQL 中提供了一种简化方法来指定两种常用类型的分组集。下面形式的子句
<programlisting>
ROLLUP ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, <replaceable>e3</replaceable>, ... )
</programlisting>
    表示给定的表达式列表及其所有前缀（包括空列表），因此它等效于
<programlisting>
GROUPING SETS (
    ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, <replaceable>e3</replaceable>, ... ),
    ...
    ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable> ),
    ( <replaceable>e1</replaceable> ),
    ( )
)
</programlisting>
    这通常被用来分析历史数据，例如按部门、区和公司范围计算的总薪水。
   </para>
<!-- pgdoc-cn_end sig_en=22546c8fd7d887bdc5825b6867e93f15 -->

<!-- pgdoc-cn_start sig_en=0adf28e27479c12c19e2f958ed395259 sig_cn_org=None source=14.1 
   <para>
    A clause of the form
<programlisting>
CUBE ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, ... )
</programlisting>
    represents the given list and all of its possible subsets (i.e., the power
    set).  Thus
<programlisting>
CUBE ( a, b, c )
</programlisting>
    is equivalent to
<programlisting>
GROUPING SETS (
    ( a, b, c ),
    ( a, b    ),
    ( a,    c ),
    ( a       ),
    (    b, c ),
    (    b    ),
    (       c ),
    (         )
)
</programlisting>
   </para>
________________________________________________________-->
   <para>
    下面形式的子句
<programlisting>
CUBE ( <replaceable>e1</replaceable>, <replaceable>e2</replaceable>, ... )
</programlisting>
    表示给定的列表及其可能的子集（即幂集）。因此
<programlisting>
CUBE ( a, b, c )
</programlisting>
    等效于
<programlisting>
GROUPING SETS (
    ( a, b, c ),
    ( a, b    ),
    ( a,    c ),
    ( a       ),
    (    b, c ),
    (    b    ),
    (       c ),
    (         )
)
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=0adf28e27479c12c19e2f958ed395259 -->

<!-- pgdoc-cn_start sig_en=8de919b30326d2408be5ab3edac3c548 sig_cn_org=None source=14.1 
   <para>
    The individual elements of a <literal>CUBE</literal> or <literal>ROLLUP</literal>
    clause may be either individual expressions, or sublists of elements in
    parentheses.  In the latter case, the sublists are treated as single
    units for the purposes of generating the individual grouping sets.
    For example:
<programlisting>
CUBE ( (a, b), (c, d) )
</programlisting>
    is equivalent to
<programlisting>
GROUPING SETS (
    ( a, b, c, d ),
    ( a, b       ),
    (       c, d ),
    (            )
)
</programlisting>
    and
<programlisting>
ROLLUP ( a, (b, c), d )
</programlisting>
    is equivalent to
<programlisting>
GROUPING SETS (
    ( a, b, c, d ),
    ( a, b, c    ),
    ( a          ),
    (            )
)
</programlisting>
   </para>
________________________________________________________-->
   <para>
    <literal>CUBE</literal>或<literal>ROLLUP</literal>子句中的元素可以是表达式或者
    圆括号中的元素子列表。在后一种情况中，对于生成分组集的目的来说，子列
    表被当做单一单元来对待。例如：
<programlisting>
CUBE ( (a, b), (c, d) )
</programlisting>
    等效于
<programlisting>
GROUPING SETS (
    ( a, b, c, d ),
    ( a, b       ),
    (       c, d ),
    (            )
)
</programlisting>
    并且
<programlisting>
ROLLUP ( a, (b, c), d )
</programlisting>
    等效于
<programlisting>
GROUPING SETS (
    ( a, b, c, d ),
    ( a, b, c    ),
    ( a          ),
    (            )
)
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=8de919b30326d2408be5ab3edac3c548 -->

<!-- pgdoc-cn_start sig_en=2a278f8538d55614e49e5bc7d343e366 sig_cn_org=None source=14.1 
   <para>
    The <literal>CUBE</literal> and <literal>ROLLUP</literal> constructs can be used either
    directly in the <literal>GROUP BY</literal> clause, or nested inside a
    <literal>GROUPING SETS</literal> clause.  If one <literal>GROUPING SETS</literal> clause
    is nested inside another, the effect is the same as if all the elements of
    the inner clause had been written directly in the outer clause.
   </para>
________________________________________________________-->
   <para>
    <literal>CUBE</literal>和<literal>ROLLUP</literal>可以被直接用在
    <literal>GROUP BY</literal>子句中，也可以被嵌套在一个
    <literal>GROUPING SETS</literal>子句中。如果一个
    <literal>GROUPING SETS</literal>子句被嵌套在另一个同类子句中，
    效果和把内层子句的所有元素直接写在外层子句中一样。
   </para>
<!-- pgdoc-cn_end sig_en=2a278f8538d55614e49e5bc7d343e366 -->

<!-- pgdoc-cn_start sig_en=cc01a700cd93649c13f570f21c0768b3 sig_cn_org=None source=14.1 
   <para>
    If multiple grouping items are specified in a single <literal>GROUP BY</literal>
    clause, then the final list of grouping sets is the cross product of the
    individual items.  For example:
<programlisting>
GROUP BY a, CUBE (b, c), GROUPING SETS ((d), (e))
</programlisting>
    is equivalent to
<programlisting>
GROUP BY GROUPING SETS (
    (a, b, c, d), (a, b, c, e),
    (a, b, d),    (a, b, e),
    (a, c, d),    (a, c, e),
    (a, d),       (a, e)
)
</programlisting>
   </para>
________________________________________________________-->
   <para>
    如果在一个<literal>GROUP BY</literal>子句中指定了多个分组项，那么最终的
    分组集列表是这些项的叉积。例如：
<programlisting>
GROUP BY a, CUBE (b, c), GROUPING SETS ((d), (e))
</programlisting>
    等效于
<programlisting>
GROUP BY GROUPING SETS (
    (a, b, c, d), (a, b, c, e),
    (a, b, d),    (a, b, e),
    (a, c, d),    (a, c, e),
    (a, d),       (a, e)
)
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=cc01a700cd93649c13f570f21c0768b3 -->

<!-- pgdoc-cn_start sig_en=5fe79d0b113096dff4a2fe10e4b9eacb sig_cn_org=None source=14.1 
   <para>
    <indexterm zone="queries-grouping-sets">
     <primary>ALL</primary>
     <secondary>GROUP BY ALL</secondary>
    </indexterm>
    <indexterm zone="queries-grouping-sets">
     <primary>DISTINCT</primary>
     <secondary>GROUP BY DISTINCT</secondary>
    </indexterm>
    When specifying multiple grouping items together, the final set of grouping
    sets might contain duplicates. For example:
<programlisting>
GROUP BY ROLLUP (a, b), ROLLUP (a, c)
</programlisting>
    is equivalent to
<programlisting>
GROUP BY GROUPING SETS (
    (a, b, c),
    (a, b),
    (a, b),
    (a, c),
    (a),
    (a),
    (a, c),
    (a),
    ()
)
</programlisting>
    If these duplicates are undesirable, they can be removed using the
    <literal>DISTINCT</literal> clause directly on the <literal>GROUP BY</literal>.
    Therefore:
<programlisting>
GROUP BY <emphasis>DISTINCT</emphasis> ROLLUP (a, b), ROLLUP (a, c)
</programlisting>
    is equivalent to
<programlisting>
GROUP BY GROUPING SETS (
    (a, b, c),
    (a, b),
    (a, c),
    (a),
    ()
)
</programlisting>
    This is not the same as using <literal>SELECT DISTINCT</literal> because the output
    rows may still contain duplicates.  If any of the ungrouped columns contains NULL,
    it will be indistinguishable from the NULL used when that same column is grouped.
   </para>
________________________________________________________-->
   <para>
      <indexterm zone="queries-grouping-sets">
       <primary>ALL</primary>
       <secondary>GROUP BY ALL</secondary>
      </indexterm>
      <indexterm zone="queries-grouping-sets">
       <primary>DISTINCT</primary>
       <secondary>GROUP BY DISTINCT</secondary>
      </indexterm>
       当一次指定多个分组项时，最终的分组集合可能包含重复项。例如：
  <programlisting>
  GROUP BY ROLLUP (a, b), ROLLUP (a, c)
  </programlisting>
      等同于
  <programlisting>
  GROUP BY GROUPING SETS (
      (a, b, c),
      (a, b),
      (a, b),
      (a, c),
      (a),
      (a),
      (a, c),
      (a),
      ()
  )
  </programlisting>
      如果这些重复项是不希望出现的，可以在<literal>GROUP BY</literal>上直接使用<literal>DISTINCT</literal>子句来删除它们。因此：
  <programlisting>
  GROUP BY <emphasis>DISTINCT</emphasis> ROLLUP (a, b), ROLLUP (a, c)
  </programlisting>
      等同于
  <programlisting>
  GROUP BY GROUPING SETS (
      (a, b, c),
      (a, b),
      (a, c),
      (a),
      ()
  )
  </programlisting>
      这与使用<literal>SELECT DISTINCT</literal>不同，因为输出行仍然可能包含重复项。如果任何一个未分组的列包含 NULL，则无法区分其与分组该列时使用的 NULL。
     </para>
<!-- pgdoc-cn_end sig_en=5fe79d0b113096dff4a2fe10e4b9eacb -->

  <note>
<!-- pgdoc-cn_start sig_en=a3eb457780729d90b180d606de738624 sig_cn_org=None source=14.1 
   <para>
    The construct <literal>(a, b)</literal> is normally recognized in expressions as
    a <link linkend="sql-syntax-row-constructors">row constructor</link>.
    Within the <literal>GROUP BY</literal> clause, this does not apply at the top
    levels of expressions, and <literal>(a, b)</literal> is parsed as a list of
    expressions as described above.  If for some reason you <emphasis>need</emphasis>
    a row constructor in a grouping expression, use <literal>ROW(a, b)</literal>.
   </para>
________________________________________________________-->
   <para>
    在表达式中，结构<literal>(a, b)</literal>通常被识别为一个
    a <link linkend="sql-syntax-row-constructors">行构造器</link>。在
    <literal>GROUP BY</literal>子句中，这不会在表达式的顶层应用，并且
    <literal>(a, b)</literal>会按照上面所说的被解析为一个表达式的列表。如果出于
    某种原因你在分组表达式中<emphasis>需要</emphasis>一个行构造器，请使用
    <literal>ROW(a, b)</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=a3eb457780729d90b180d606de738624 -->
  </note>
  </sect2>

  <sect2 id="queries-window">
<!-- pgdoc-cn_start sig_en=ccc16b00ee7fb53c9ec05bdd00f304d7 sig_cn_org=None source=14.1 
   <title>Window Function Processing</title>
________________________________________________________-->
   <title>窗口函数处理</title>
<!-- pgdoc-cn_end sig_en=ccc16b00ee7fb53c9ec05bdd00f304d7 -->

<!-- pgdoc-cn_start sig_en=091403fef83d0e90d67dd9d082dd1d93 sig_cn_org=None source=14.1 
   <indexterm zone="queries-window">
    <primary>window function</primary>
    <secondary>order of execution</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="queries-window">
    <primary>窗口函数</primary>
    <secondary>执行顺序</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=091403fef83d0e90d67dd9d082dd1d93 -->

<!-- pgdoc-cn_start sig_en=cfc471498fa04b3dd00306c90d45da40 sig_cn_org=None source=14.1 
   <para>
    If the query contains any window functions (see
    <xref linkend="tutorial-window"/>,
    <xref linkend="functions-window"/> and
    <xref linkend="syntax-window-functions"/>), these functions are evaluated
    after any grouping, aggregation, and <literal>HAVING</literal> filtering is
    performed.  That is, if the query uses any aggregates, <literal>GROUP
    BY</literal>, or <literal>HAVING</literal>, then the rows seen by the window functions
    are the group rows instead of the original table rows from
    <literal>FROM</literal>/<literal>WHERE</literal>.
   </para>
________________________________________________________-->
   <para>
    如果查询包含任何窗口函数（见<xref linkend="tutorial-window"/>、<xref linkend="functions-window"/>和<xref linkend="syntax-window-functions"/>），这些函数将在任何分组、聚集和<literal>HAVING</literal>过滤被执行之后被计算。也就是说如果查询使用了任何聚集、<literal>GROUP BY</literal>或<literal>HAVING</literal>，则窗口函数看到的行是分组行而不是来自于<literal>FROM</literal>/<literal>WHERE</literal>的原始表行。
   </para>
<!-- pgdoc-cn_end sig_en=cfc471498fa04b3dd00306c90d45da40 -->

<!-- pgdoc-cn_start sig_en=f1a398ead05739b6981085899c3b1d84 sig_cn_org=None source=14.1 
   <para>
    When multiple window functions are used, all the window functions having
    syntactically equivalent <literal>PARTITION BY</literal> and <literal>ORDER BY</literal>
    clauses in their window definitions are guaranteed to be evaluated in a
    single pass over the data. Therefore they will see the same sort ordering,
    even if the <literal>ORDER BY</literal> does not uniquely determine an ordering.
    However, no guarantees are made about the evaluation of functions having
    different <literal>PARTITION BY</literal> or <literal>ORDER BY</literal> specifications.
    (In such cases a sort step is typically required between the passes of
    window function evaluations, and the sort is not guaranteed to preserve
    ordering of rows that its <literal>ORDER BY</literal> sees as equivalent.)
   </para>
________________________________________________________-->
   <para>
    当多个窗口函数被使用，所有在窗口定义中有句法上等效的<literal>PARTITION BY</literal>和<literal>ORDER BY</literal>子句的窗口函数被保证在数据上的同一趟扫描中计算。因此它们将会看到相同的排序顺序，即使<literal>ORDER BY</literal>没有唯一地决定一个顺序。但是，对于具有不同<literal>PARTITION BY</literal>或<literal>ORDER BY</literal>定义的函数的计算没有这种保证（在这种情况中，在多个窗口函数计算之间通常要求一个排序步骤，并且并不保证保留行的顺序，即使它的<literal>ORDER BY</literal>把这些行视为等效的）。
   </para>
<!-- pgdoc-cn_end sig_en=f1a398ead05739b6981085899c3b1d84 -->

<!-- pgdoc-cn_start sig_en=f1388274d7e9096e2de670e35671f0d1 sig_cn_org=None source=14.1 
   <para>
    Currently, window functions always require presorted data, and so the
    query output will be ordered according to one or another of the window
    functions' <literal>PARTITION BY</literal>/<literal>ORDER BY</literal> clauses.
    It is not recommended to rely on this, however.  Use an explicit
    top-level <literal>ORDER BY</literal> clause if you want to be sure the
    results are sorted in a particular way.
   </para>
________________________________________________________-->
   <para>
    目前，窗口函数总是要求排序好的数据，并且这样查询的输出总是被根据窗口函数的<literal>PARTITION BY</literal>/<literal>ORDER BY</literal>子句的一个或者另一个排序。但是，我们不推荐依赖于此。如果你希望确保结果以特定的方式排序，请显式使用顶层的<literal>ORDER BY</literal>子句。
   </para>
<!-- pgdoc-cn_end sig_en=f1388274d7e9096e2de670e35671f0d1 -->
  </sect2>
 </sect1>


 <sect1 id="queries-select-lists">
<!-- pgdoc-cn_start sig_en=89874d73c7fe05e50bd1cbdb80827908 sig_cn_org=None source=14.1 
  <title>Select Lists</title>
________________________________________________________-->
  <title>选择列表</title>
<!-- pgdoc-cn_end sig_en=89874d73c7fe05e50bd1cbdb80827908 -->

<!-- pgdoc-cn_start sig_en=5a2bf7dbc5f53c81f31f2defe37f8eb3 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>SELECT</primary>
   <secondary>select list</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>SELECT</primary>
   <secondary>选择列表</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=5a2bf7dbc5f53c81f31f2defe37f8eb3 -->

<!-- pgdoc-cn_start sig_en=bd9b8f48dff3b0cfbf260a4e20b7529f sig_cn_org=None source=14.1 
  <para>
   As shown in the previous section,
   the table expression in the <command>SELECT</command> command
   constructs an intermediate virtual table by possibly combining
   tables, views, eliminating rows, grouping, etc.  This table is
   finally passed on to processing by the <firstterm>select list</firstterm>.  The select
   list determines which <emphasis>columns</emphasis> of the
   intermediate table are actually output.
  </para>
________________________________________________________-->
  <para>
   如前面的小节说明的那样， 在<command>SELECT</command>命令里的表表达式构造了一个中间的虚拟表， 方法可能有组合表、视图、消除行、分组等等。这个表最后被<firstterm>选择列表</firstterm>传递下去处理。选择列表判断中间表的哪个<emphasis>列</emphasis>是实际输出。
  </para>
<!-- pgdoc-cn_end sig_en=bd9b8f48dff3b0cfbf260a4e20b7529f -->

  <sect2 id="queries-select-list-items">
<!-- pgdoc-cn_start sig_en=651f52e4c447565a3bcdda755b8d2bf7 sig_cn_org=None source=14.1 
   <title>Select-List Items</title>
________________________________________________________-->
   <title>选择列表项</title>
<!-- pgdoc-cn_end sig_en=651f52e4c447565a3bcdda755b8d2bf7 -->

<!-- pgdoc-cn_start sig_en=05bd9302c4605402791404427f045cc2 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>*</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>*</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=05bd9302c4605402791404427f045cc2 -->

<!-- pgdoc-cn_start sig_en=146289402941c001496ab495a3843f2b sig_cn_org=None source=14.1 
   <para>
    The simplest kind of select list is <literal>*</literal> which
    emits all columns that the table expression produces.  Otherwise,
    a select list is a comma-separated list of value expressions (as
    defined in <xref linkend="sql-expressions"/>).  For instance, it
    could be a list of column names:
<programlisting>
SELECT a, b, c FROM ...
</programlisting>
     The columns names <literal>a</literal>, <literal>b</literal>, and <literal>c</literal>
     are either the actual names of the columns of tables referenced
     in the <literal>FROM</literal> clause, or the aliases given to them as
     explained in <xref linkend="queries-table-aliases"/>.  The name
     space available in the select list is the same as in the
     <literal>WHERE</literal> clause, unless grouping is used, in which case
     it is the same as in the <literal>HAVING</literal> clause.
   </para>
________________________________________________________-->
   <para>
    最简单的选择列表类型是<literal>*</literal>，它发出表表达式生成的所有列。否则，一个选择列表是一个逗号分隔的值表达式的列表（和在<xref linkend="sql-expressions"/>里定义的一样）。 例如，它可能是一个列名的列表：
<programlisting>
SELECT a, b, c FROM ...
</programlisting>
     列名字<literal>a</literal>、<literal>b</literal>和<literal>c</literal>要么是在<literal>FROM</literal>子句里引用的表中列的实际名字，要么是像<xref linkend="queries-table-aliases"/>里解释的那样的别名。在选择列表里可用的名字空间和在<literal>WHERE</literal>子句里的一样， 除非你使用了分组，这时候它和<literal>HAVING</literal>子句一样。
   </para>
<!-- pgdoc-cn_end sig_en=146289402941c001496ab495a3843f2b -->

<!-- pgdoc-cn_start sig_en=850390a6bc6580c5c30cd7668322fac9 sig_cn_org=None source=14.1 
   <para>
    If more than one table has a column of the same name, the table
    name must also be given, as in:
<programlisting>
SELECT tbl1.a, tbl2.a, tbl1.b FROM ...
</programlisting>
    When working with multiple tables, it can also be useful to ask for
    all the columns of a particular table:
<programlisting>
SELECT tbl1.*, tbl2.a FROM ...
</programlisting>
    See <xref linkend="rowtypes-usage"/> for more about
    the <replaceable>table_name</replaceable><literal>.*</literal> notation.
   </para>
________________________________________________________-->
   <para>
    如果超过一个表有同样的列名，那么你还必须给出表名字，如：
<programlisting>
SELECT tbl1.a, tbl2.a, tbl1.b FROM ...
</programlisting>
    在使用多个表时，要求一个特定表的所有列也是有用的：
<programlisting>
SELECT tbl1.*, tbl2.a FROM ...
</programlisting>
    更多有关<replaceable>table_name</replaceable><literal>.*</literal>记号的内容请参考<xref linkend="rowtypes-usage"/>。
   </para>
<!-- pgdoc-cn_end sig_en=850390a6bc6580c5c30cd7668322fac9 -->

<!-- pgdoc-cn_start sig_en=f65a011f2e8d9797191b73e015868891 sig_cn_org=None source=14.1 
   <para>
    If an arbitrary value expression is used in the select list, it
    conceptually adds a new virtual column to the returned table.  The
    value expression is evaluated once for each result row, with
    the row's values substituted for any column references.  But the
    expressions in the select list do not have to reference any
    columns in the table expression of the <literal>FROM</literal> clause;
    they can be constant arithmetic expressions, for instance.
   </para>
________________________________________________________-->
   <para>
    如果将任意值表达式用于选择列表，那么它在概念上向返回的表中增加了一个新的虚拟列。 值表达式为结果的每一行进行一次计算，对任何列引用替换行的值。 不过选择列表中的这个表达式并非一定要引用来自<literal>FROM</literal>子句中表表达式里面的列，例如它也可以是任意常量算术表达式。
   </para>
<!-- pgdoc-cn_end sig_en=f65a011f2e8d9797191b73e015868891 -->
  </sect2>

  <sect2 id="queries-column-labels">
<!-- pgdoc-cn_start sig_en=ce88ebeeb8159ab73015ea2f06107771 sig_cn_org=None source=14.1 
   <title>Column Labels</title>
________________________________________________________-->
   <title>列标签</title>
<!-- pgdoc-cn_end sig_en=ce88ebeeb8159ab73015ea2f06107771 -->

<!-- pgdoc-cn_start sig_en=5912900b72b862a410434c22c04ec588 sig_cn_org=None source=14.1 
   <indexterm zone="queries-column-labels">
    <primary>alias</primary>
    <secondary>in the select list</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="queries-column-labels">
    <primary>别名</primary>
    <secondary>在选择列表中</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=5912900b72b862a410434c22c04ec588 -->

<!-- pgdoc-cn_start sig_en=af2eb3dc71dde937bf5684c074c3a81e sig_cn_org=None source=14.1 
   <para>
    The entries in the select list can be assigned names for subsequent
    processing, such as for use in an <literal>ORDER BY</literal> clause
    or for display by the client application.  For example:
<programlisting>
SELECT a AS value, b + c AS sum FROM ...
</programlisting>
   </para>
________________________________________________________-->
   <para>
    选择列表中的项可以被赋予名字，用于进一步的处理。 例如为了在一个<literal>ORDER BY</literal>子句中使用或者为了客户端应用显示。例如：
<programlisting>
SELECT a AS value, b + c AS sum FROM ...
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=af2eb3dc71dde937bf5684c074c3a81e -->

<!-- pgdoc-cn_start sig_en=5ffd69830965edf28f525bee51ad4abf sig_cn_org=None source=14.1 
   <para>
    If no output column name is specified using <literal>AS</literal>,
    the system assigns a default column name.  For simple column references,
    this is the name of the referenced column.  For function
    calls, this is the name of the function.  For complex expressions,
    the system will generate a generic name.
   </para>
________________________________________________________-->
   <para>
    如果没有使用<literal>AS</literal>指定输出列名，那么系统会分配一个缺省的列名。对于简单的列引用， 它是被引用列的名字。对于函数调用，它是函数的名字。对于复杂表达式，系统会生成一个通用的名字。
   </para>
<!-- pgdoc-cn_end sig_en=5ffd69830965edf28f525bee51ad4abf -->

<!-- pgdoc-cn_start sig_en=b0a552d4143905e803f4089495dcc33b sig_cn_org=None source=14.1 
   <para>
    The <literal>AS</literal> key word is usually optional, but in some
    cases where the desired column name matches a
    <productname>PostgreSQL</productname> key word, you must write
    <literal>AS</literal> or double-quote the column name in order to
    avoid ambiguity.
    (<xref linkend="sql-keywords-appendix"/> shows which key words
    require <literal>AS</literal> to be used as a column label.)
    For example, <literal>FROM</literal> is one such key word, so this
    does not work:
<programlisting>
SELECT a from, b + c AS sum FROM ...
</programlisting>
    but either of these do:
<programlisting>
SELECT a AS from, b + c AS sum FROM ...
SELECT a "from", b + c AS sum FROM ...
</programlisting>
    For greatest safety against possible
    future key word additions, it is recommended that you always either
    write <literal>AS</literal> or double-quote the output column name.
   </para>
________________________________________________________-->
   <para>
    <literal>AS</literal>关键词通常是可选的，但在某些情况下，如果想要的列名与<productname>PostgreSQL</productname>关键词相匹配，你必须写上<literal>AS</literal>或双引号的列名，以避免歧义。(<xref linkend="sql-keywords-appendix"/>显示了哪些关键词需要用<literal>AS</literal>作为列标签)。例如，<literal>FROM</literal>就是这样的一个关键词，所以下面的语句是行不通的：
<programlisting>
SELECT a from, b + c AS sum FROM ...
</programlisting>
    但是以下任意一种会起作用：
<programlisting>
SELECT a AS from, b + c AS sum FROM ...
SELECT a "from", b + c AS sum FROM ...
</programlisting>
    为了防止未来可能的关键词增加，我们推荐总是写<literal>AS</literal>或者用双引号修饰输出列名以保证最大的安全性。
   </para>
<!-- pgdoc-cn_end sig_en=b0a552d4143905e803f4089495dcc33b -->

   <note>
<!-- pgdoc-cn_start sig_en=267288d0ddddcf28242450dcdc1368d7 sig_cn_org=None source=14.1 
    <para>
     The naming of output columns here is different from that done in
     the <literal>FROM</literal> clause (see <xref
     linkend="queries-table-aliases"/>).  It is possible
     to rename the same column twice, but the name assigned in
     the select list is the one that will be passed on.
    </para>
________________________________________________________-->
    <para>
     输出列的命名和在<literal>FROM</literal>子句里的命名是不一样的 （参阅<xref linkend="queries-table-aliases"/>）。 它实际上允许你对同一个列命名两次，但是在选择列表中分配的名字是要传递下去的名字。
    </para>
<!-- pgdoc-cn_end sig_en=267288d0ddddcf28242450dcdc1368d7 -->
   </note>
  </sect2>

  <sect2 id="queries-distinct">
   <title><literal>DISTINCT</literal></title>

<!-- pgdoc-cn_start sig_en=bbf874951ef81c77db7a1c093467afde sig_cn_org=None source=14.1 
   <indexterm zone="queries-distinct">
    <primary>ALL</primary>
    <secondary>SELECT ALL</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="queries-distinct">
       <primary>ALL</primary>
       <secondary>SELECT ALL</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=bbf874951ef81c77db7a1c093467afde -->
<!-- pgdoc-cn_start sig_en=154e2f4fdd75a3c6e974c5e2db5068d7 sig_cn_org=None source=14.1 
   <indexterm zone="queries-distinct">
    <primary>DISTINCT</primary>
    <secondary>SELECT DISTINCT</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="queries-distinct">
    <primary>DISTINCT</primary>
    <secondary>SELECT DISTINCT</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=154e2f4fdd75a3c6e974c5e2db5068d7 -->

<!-- pgdoc-cn_start sig_en=84fac710eb6eb48d7a342049ab47c314 sig_cn_org=None source=14.1 
   <indexterm zone="queries-distinct">
    <primary>duplicates</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="queries-distinct">
    <primary>重复</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=84fac710eb6eb48d7a342049ab47c314 -->

<!-- pgdoc-cn_start sig_en=e9c7a7cd1fe56e14520c236739e8ec57 sig_cn_org=None source=14.1 
   <para>
    After the select list has been processed, the result table can
    optionally be subject to the elimination of duplicate rows.  The
    <literal>DISTINCT</literal> key word is written directly after
    <literal>SELECT</literal> to specify this:
<synopsis>
SELECT DISTINCT <replaceable>select_list</replaceable> ...
</synopsis>
    (Instead of <literal>DISTINCT</literal> the key word <literal>ALL</literal>
    can be used to specify the default behavior of retaining all rows.)
   </para>
________________________________________________________-->
   <para>
    在处理完选择列表之后，结果表可以可选的删除重复行。我们可以直接在<literal>SELECT</literal>后面写上<literal>DISTINCT</literal>关键字来指定：
<synopsis>
SELECT DISTINCT <replaceable>select_list</replaceable> ...
</synopsis>
    （如果不用<literal>DISTINCT</literal>你可以用<literal>ALL</literal>关键词来指定获得的所有行的缺省行为）。
   </para>
<!-- pgdoc-cn_end sig_en=e9c7a7cd1fe56e14520c236739e8ec57 -->

<!-- pgdoc-cn_start sig_en=0e39cf6286b0e64a589b99c44fbc1768 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>null value</primary>
    <secondary sortas="DISTINCT">in DISTINCT</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>空值</primary>
    <secondary sortas="DISTINCT">in DISTINCT</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=0e39cf6286b0e64a589b99c44fbc1768 -->

<!-- pgdoc-cn_start sig_en=7a7e33ed91a4309c4bb73d5b7bee5e40 sig_cn_org=None source=14.1 
   <para>
    Obviously, two rows are considered distinct if they differ in at
    least one column value.  Null values are considered equal in this
    comparison.
   </para>
________________________________________________________-->
   <para>
    显然，如果两行里至少有一个列有不同的值，那么我们认为它是可区分的。空值在这种比较中被认为是相同的。
   </para>
<!-- pgdoc-cn_end sig_en=7a7e33ed91a4309c4bb73d5b7bee5e40 -->

<!-- pgdoc-cn_start sig_en=09aea26b77ea5f251cddc19d9dcb6a1d sig_cn_org=None source=14.1 
   <para>
    Alternatively, an arbitrary expression can determine what rows are
    to be considered distinct:
<synopsis>
SELECT DISTINCT ON (<replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ...</optional>) <replaceable>select_list</replaceable> ...
</synopsis>
    Here <replaceable>expression</replaceable> is an arbitrary value
    expression that is evaluated for all rows.  A set of rows for
    which all the expressions are equal are considered duplicates, and
    only the first row of the set is kept in the output.  Note that
    the <quote>first row</quote> of a set is unpredictable unless the
    query is sorted on enough columns to guarantee a unique ordering
    of the rows arriving at the <literal>DISTINCT</literal> filter.
    (<literal>DISTINCT ON</literal> processing occurs after <literal>ORDER
    BY</literal> sorting.)
   </para>
________________________________________________________-->
   <para>
    另外，我们还可以用任意表达式来判断什么行可以被认为是可区分的：
<synopsis>
SELECT DISTINCT ON (<replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ...</optional>) <replaceable>select_list</replaceable> ...
</synopsis>
    这里<replaceable>expression</replaceable>是任意值表达式，它为所有行计算。如果一个行集合里所有表达式的值是一样的， 那么我们认为它们是重复的并且因此只有第一行保留在输出中。请注意这里的一个集合的<quote>第一行</quote>是不可预料的， 除非你在足够多的列上对该查询排了序，保证到达<literal>DISTINCT</literal>过滤器的行的顺序是唯一的（<literal>DISTINCT ON</literal>处理是发生在<literal>ORDER BY</literal>排序后面的）。
   </para>
<!-- pgdoc-cn_end sig_en=09aea26b77ea5f251cddc19d9dcb6a1d -->

<!-- pgdoc-cn_start sig_en=193d21a0af055e9d39088d571fd5f8bb sig_cn_org=None source=14.1 
   <para>
    The <literal>DISTINCT ON</literal> clause is not part of the SQL standard
    and is sometimes considered bad style because of the potentially
    indeterminate nature of its results.  With judicious use of
    <literal>GROUP BY</literal> and subqueries in <literal>FROM</literal>, this
    construct can be avoided, but it is often the most convenient
    alternative.
   </para>
________________________________________________________-->
   <para>
    <literal>DISTINCT ON</literal>子句不是 SQL 标准的一部分， 有时候有人认为它是一个糟糕的风格，因为它的结果是不可判定的。 如果有选择的使用<literal>GROUP BY</literal>和在<literal>FROM</literal>中的子查询，那么我们可以避免使用这个构造， 但是通常它是更方便的候选方法。
   </para>
<!-- pgdoc-cn_end sig_en=193d21a0af055e9d39088d571fd5f8bb -->
  </sect2>
 </sect1>


 <sect1 id="queries-union">
<!-- pgdoc-cn_start sig_en=ace5a42b3432404939660aa350cc7882 sig_cn_org=None source=14.1 
  <title>Combining Queries (<literal>UNION</literal>, <literal>INTERSECT</literal>, <literal>EXCEPT</literal>)</title>
________________________________________________________-->
  <title>组合查询(<literal>UNION</literal>, <literal>INTERSECT</literal>, <literal>EXCEPT</literal>)</title>
<!-- pgdoc-cn_end sig_en=ace5a42b3432404939660aa350cc7882 -->

<!-- pgdoc-cn_start sig_en=f7d29f96de12d7c0cb14b0cfef50b74b sig_cn_org=None source=14.1 
  <indexterm zone="queries-union">
   <primary>UNION</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="queries-union">
   <primary>UNION</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=f7d29f96de12d7c0cb14b0cfef50b74b -->
<!-- pgdoc-cn_start sig_en=5006acc81612173b5a85acc2e968000f sig_cn_org=None source=14.1 
  <indexterm zone="queries-union">
   <primary>INTERSECT</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="queries-union">
   <primary>INTERSECT</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=5006acc81612173b5a85acc2e968000f -->
<!-- pgdoc-cn_start sig_en=68475ce072ef69c26d3d0c762801fdef sig_cn_org=None source=14.1 
  <indexterm zone="queries-union">
   <primary>EXCEPT</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="queries-union">
   <primary>EXCEPT</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=68475ce072ef69c26d3d0c762801fdef -->
<!-- pgdoc-cn_start sig_en=ff761f1ada96fe41677fccad1346501f sig_cn_org=None source=14.1 
  <indexterm zone="queries-union">
   <primary>set union</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="queries-union">
   <primary>集合并</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=ff761f1ada96fe41677fccad1346501f -->
<!-- pgdoc-cn_start sig_en=42997fcf0c25fe6e1c8916b816d361c9 sig_cn_org=None source=14.1 
  <indexterm zone="queries-union">
   <primary>set intersection</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="queries-union">
   <primary>集合交</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=42997fcf0c25fe6e1c8916b816d361c9 -->
<!-- pgdoc-cn_start sig_en=d25137708d9adbd56978676a61ea7051 sig_cn_org=None source=14.1 
  <indexterm zone="queries-union">
   <primary>set difference</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="queries-union">
   <primary>集合差</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=d25137708d9adbd56978676a61ea7051 -->
<!-- pgdoc-cn_start sig_en=a07ea2ac62d2ae329cf0c16fd9fe903c sig_cn_org=None source=14.1 
  <indexterm zone="queries-union">
   <primary>set operation</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="queries-union">
   <primary>集合操作</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=a07ea2ac62d2ae329cf0c16fd9fe903c -->

<!-- pgdoc-cn_start sig_en=036551bbe4d604abbfc70bed3e70c2d7 sig_cn_org=None source=14.1 
  <para>
   The results of two queries can be combined using the set operations
   union, intersection, and difference.  The syntax is
<synopsis>
<replaceable>query1</replaceable> UNION <optional>ALL</optional> <replaceable>query2</replaceable>
<replaceable>query1</replaceable> INTERSECT <optional>ALL</optional> <replaceable>query2</replaceable>
<replaceable>query1</replaceable> EXCEPT <optional>ALL</optional> <replaceable>query2</replaceable>
</synopsis>
   where <replaceable>query1</replaceable> and
   <replaceable>query2</replaceable> are queries that can use any of
   the features discussed up to this point.
  </para>
________________________________________________________-->
  <para>
   两个查询的结果可以用集合操作并、交、差进行组合。语法是
<synopsis>
<replaceable>query1</replaceable> UNION <optional>ALL</optional> <replaceable>query2</replaceable>
<replaceable>query1</replaceable> INTERSECT <optional>ALL</optional> <replaceable>query2</replaceable>
<replaceable>query1</replaceable> EXCEPT <optional>ALL</optional> <replaceable>query2</replaceable>
</synopsis>
   <replaceable>query1</replaceable>和<replaceable>query2</replaceable>都是可以使用以上所有特性的查询。
  </para>
<!-- pgdoc-cn_end sig_en=036551bbe4d604abbfc70bed3e70c2d7 -->

<!-- pgdoc-cn_start sig_en=d0236f6a7a1dfae0148d874881d5668c sig_cn_org=None source=14.1 
  <para>
   <literal>UNION</literal> effectively appends the result of
   <replaceable>query2</replaceable> to the result of
   <replaceable>query1</replaceable> (although there is no guarantee
   that this is the order in which the rows are actually returned).
   Furthermore, it eliminates duplicate rows from its result, in the same
   way as <literal>DISTINCT</literal>, unless <literal>UNION ALL</literal> is used.
  </para>
________________________________________________________-->
  <para>
   <literal>UNION</literal>有效地把<replaceable>query2</replaceable>的结果附加到<replaceable>query1</replaceable>的结果上（不过我们不能保证这就是这些行实际被返回的顺序）。此外，它将删除结果中所有重复的行， 就象<literal>DISTINCT</literal>做的那样，除非你使用了<literal>UNION ALL</literal>。
  </para>
<!-- pgdoc-cn_end sig_en=d0236f6a7a1dfae0148d874881d5668c -->

<!-- pgdoc-cn_start sig_en=8be3ffdc8a0934decf52c011e363b0be sig_cn_org=None source=14.1 
  <para>
   <literal>INTERSECT</literal> returns all rows that are both in the result
   of <replaceable>query1</replaceable> and in the result of
   <replaceable>query2</replaceable>.  Duplicate rows are eliminated
   unless <literal>INTERSECT ALL</literal> is used.
  </para>
________________________________________________________-->
  <para>
   <literal>INTERSECT</literal>返回那些同时存在于<replaceable>query1</replaceable>和<replaceable>query2</replaceable>的结果中的行，除非声明了<literal>INTERSECT ALL</literal>， 否则所有重复行都被消除。
  </para>
<!-- pgdoc-cn_end sig_en=8be3ffdc8a0934decf52c011e363b0be -->

<!-- pgdoc-cn_start sig_en=088bd310027ea4d9e77620d3eadcd884 sig_cn_org=None source=14.1 
  <para>
   <literal>EXCEPT</literal> returns all rows that are in the result of
   <replaceable>query1</replaceable> but not in the result of
   <replaceable>query2</replaceable>.  (This is sometimes called the
   <firstterm>difference</firstterm> between two queries.)  Again, duplicates
   are eliminated unless <literal>EXCEPT ALL</literal> is used.
  </para>
________________________________________________________-->
  <para>
   <literal>EXCEPT</literal>返回所有在<replaceable>query1</replaceable>的结果中但是不在<replaceable>query2</replaceable>的结果中的行（有时侯这叫做两个查询的<firstterm>差</firstterm>）。同样的，除非声明了<literal>EXCEPT ALL</literal>，否则所有重复行都被消除。
  </para>
<!-- pgdoc-cn_end sig_en=088bd310027ea4d9e77620d3eadcd884 -->

<!-- pgdoc-cn_start sig_en=7bba1bc3022147fe3dacac21593df6d8 sig_cn_org=None source=14.1 
  <para>
   In order to calculate the union, intersection, or difference of two
   queries, the two queries must be <quote>union compatible</quote>,
   which means that they return the same number of columns and
   the corresponding columns have compatible data types, as
   described in <xref linkend="typeconv-union-case"/>.
  </para>
________________________________________________________-->
  <para>
   为了计算两个查询的并、交、差，这两个查询必须是<quote>并操作兼容的</quote>，也就意味着它们都返回同样数量的列， 并且对应的列有兼容的数据类型，如<xref linkend="typeconv-union-case"/>中描述的那样。
  </para>
<!-- pgdoc-cn_end sig_en=7bba1bc3022147fe3dacac21593df6d8 -->

<!-- pgdoc-cn_start sig_en=2d047eabb73972ba9648869e79de0788 sig_cn_org=None source=14.1 
  <para>
   Set operations can be combined, for example
<synopsis>
<replaceable>query1</replaceable> UNION <replaceable>query2</replaceable> EXCEPT <replaceable>query3</replaceable>
</synopsis>
   which is equivalent to
<synopsis>
(<replaceable>query1</replaceable> UNION <replaceable>query2</replaceable>) EXCEPT <replaceable>query3</replaceable>
</synopsis>
   As shown here, you can use parentheses to control the order of
   evaluation.  Without parentheses, <literal>UNION</literal>
   and <literal>EXCEPT</literal> associate left-to-right,
   but <literal>INTERSECT</literal> binds more tightly than those two
   operators.  Thus
<synopsis>
<replaceable>query1</replaceable> UNION <replaceable>query2</replaceable> INTERSECT <replaceable>query3</replaceable>
</synopsis>
   means
<synopsis>
<replaceable>query1</replaceable> UNION (<replaceable>query2</replaceable> INTERSECT <replaceable>query3</replaceable>)
</synopsis>
   You can also surround an individual <replaceable>query</replaceable>
   with parentheses.  This is important if
   the <replaceable>query</replaceable> needs to use any of the clauses
   discussed in following sections, such as <literal>LIMIT</literal>.
   Without parentheses, you'll get a syntax error, or else the clause will
   be understood as applying to the output of the set operation rather
   than one of its inputs.  For example,
<synopsis>
SELECT a FROM b UNION SELECT x FROM y LIMIT 10
</synopsis>
   is accepted, but it means
<synopsis>
(SELECT a FROM b UNION SELECT x FROM y) LIMIT 10
</synopsis>
   not
<synopsis>
SELECT a FROM b UNION (SELECT x FROM y LIMIT 10)
</synopsis>
  </para>
________________________________________________________-->
  <para>
     集合操作可以组合使用，例如：
  <synopsis>
  <replaceable>query1</replaceable> UNION <replaceable>query2</replaceable> EXCEPT <replaceable>query3</replaceable>
  </synopsis>
     等价于：
  <synopsis>
  (<replaceable>query1</replaceable> UNION <replaceable>query2</replaceable>) EXCEPT <replaceable>query3</replaceable>
  </synopsis>
  如下所示，您可以使用括号来控制计算顺序。如果没有括号，则 <literal>UNION</literal> 和 <literal>EXCEPT</literal> 从左到右进行关联，但 <literal>INTERSECT</literal> 的绑定比这两个运算符更紧密。因此
  <synopsis>
  <replaceable>query1</replaceable> UNION <replaceable>query2</replaceable> INTERSECT <replaceable>query3</replaceable>
  </synopsis>
     意思是
  <synopsis>
  <replaceable>query1</replaceable> UNION (<replaceable>query2</replaceable> INTERSECT <replaceable>query3</replaceable>)
  </synopsis>
  你也可以用括号包裹一个单独的<replaceable>query</replaceable>。如果<replaceable>query</replaceable>需要使用后续部分中讨论的任何子句（例如<literal>LIMIT</literal>），那么这一点非常重要。没有括号，将会得到语法错误，否则子句将被解析为适用于集合操作的输出，而不是它的输入之一。例如，
  <synopsis>
  SELECT a FROM b UNION SELECT x FROM y LIMIT 10
  </synopsis>
     是可以接受的，但它的意思是
  <synopsis>
  (SELECT a FROM b UNION SELECT x FROM y) LIMIT 10
  </synopsis>
     不是
  <synopsis>
  SELECT a FROM b UNION (SELECT x FROM y LIMIT 10)
  </synopsis>
    </para>
<!-- pgdoc-cn_end sig_en=2d047eabb73972ba9648869e79de0788 -->
 </sect1>


 <sect1 id="queries-order">
<!-- pgdoc-cn_start sig_en=33537a03b966d51fe46d32b90599d44a sig_cn_org=None source=14.1 
  <title>Sorting Rows (<literal>ORDER BY</literal>)</title>
________________________________________________________-->
  <title>行排序(<literal>ORDER BY</literal>)</title>
<!-- pgdoc-cn_end sig_en=33537a03b966d51fe46d32b90599d44a -->

<!-- pgdoc-cn_start sig_en=691c4a772e2e9aa2af5f8cc63395983d sig_cn_org=None source=14.1 
  <indexterm zone="queries-order">
   <primary>sorting</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="queries-order">
   <primary>排序</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=691c4a772e2e9aa2af5f8cc63395983d -->

<!-- pgdoc-cn_start sig_en=4096d044ed424fc6e72d815bb05f5498 sig_cn_org=None source=14.1 
  <indexterm zone="queries-order">
   <primary>ORDER BY</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="queries-order">
   <primary>ORDER BY</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=4096d044ed424fc6e72d815bb05f5498 -->

<!-- pgdoc-cn_start sig_en=e277b4c5110243c1c7d03cc444692b6f sig_cn_org=None source=14.1 
  <para>
   After a query has produced an output table (after the select list
   has been processed) it can optionally be sorted.  If sorting is not
   chosen, the rows will be returned in an unspecified order.  The actual
   order in that case will depend on the scan and join plan types and
   the order on disk, but it must not be relied on.  A particular
   output ordering can only be guaranteed if the sort step is explicitly
   chosen.
  </para>
________________________________________________________-->
  <para>
   在一个查询生成一个输出表之后（在处理完选择列表之后），还可以选择性地对它进行排序。如果没有选择排序，那么行将以未指定的顺序返回。 这时候的实际顺序将取决于扫描和连接计划类型以及行在磁盘上的顺序，但是肯定不能依赖这些东西。一种特定的顺序只能在显式地选择了排序步骤之后才能被保证。
  </para>
<!-- pgdoc-cn_end sig_en=e277b4c5110243c1c7d03cc444692b6f -->

<!-- pgdoc-cn_start sig_en=79ca5c9e7e344f6db81f7ea1d5d35270 sig_cn_org=None source=14.1 
  <para>
   The <literal>ORDER BY</literal> clause specifies the sort order:
<synopsis>
SELECT <replaceable>select_list</replaceable>
    FROM <replaceable>table_expression</replaceable>
    ORDER BY <replaceable>sort_expression1</replaceable> <optional>ASC | DESC</optional> <optional>NULLS { FIRST | LAST }</optional>
             <optional>, <replaceable>sort_expression2</replaceable> <optional>ASC | DESC</optional> <optional>NULLS { FIRST | LAST }</optional> ...</optional>
</synopsis>
   The sort expression(s) can be any expression that would be valid in the
   query's select list.  An example is:
<programlisting>
SELECT a, b FROM table1 ORDER BY a + b, c;
</programlisting>
   When more than one expression is specified,
   the later values are used to sort rows that are equal according to the
   earlier values.  Each expression can be followed by an optional
   <literal>ASC</literal> or <literal>DESC</literal> keyword to set the sort direction to
   ascending or descending.  <literal>ASC</literal> order is the default.
   Ascending order puts smaller values first, where
   <quote>smaller</quote> is defined in terms of the
   <literal>&lt;</literal> operator.  Similarly, descending order is
   determined with the <literal>&gt;</literal> operator.
    <footnote>
     <para>
      Actually, <productname>PostgreSQL</productname> uses the <firstterm>default B-tree
      operator class</firstterm> for the expression's data type to determine the sort
      ordering for <literal>ASC</literal> and <literal>DESC</literal>.  Conventionally,
      data types will be set up so that the <literal>&lt;</literal> and
      <literal>&gt;</literal> operators correspond to this sort ordering,
      but a user-defined data type's designer could choose to do something
      different.
     </para>
    </footnote>
  </para>
________________________________________________________-->
  <para>
   <literal>ORDER BY</literal>子句指定了排序顺序：
<synopsis>
SELECT <replaceable>select_list</replaceable>
    FROM <replaceable>table_expression</replaceable>
    ORDER BY <replaceable>sort_expression1</replaceable> <optional>ASC | DESC</optional> <optional>NULLS { FIRST | LAST }</optional>
             <optional>, <replaceable>sort_expression2</replaceable> <optional>ASC | DESC</optional> <optional>NULLS { FIRST | LAST }</optional> ...</optional>
</synopsis>
   排序表达式可以是任何在查询的选择列表中合法的表达式。一个例子是：
<programlisting>
SELECT a, b FROM table1 ORDER BY a + b, c;
</programlisting>
   当多于一个表达式被指定，后面的值将被用于排序那些在前面值上相等的行。每一个表达式后可以选择性地放置一个<literal>ASC</literal>或<literal>DESC</literal>关键词来设置排序方向为升序或降序。<literal>ASC</literal>顺序是默认值。升序会把较小的值放在前面，而<quote>较小</quote>则由<literal>&lt;</literal>操作符定义。相似地，降序则由<literal>&gt;</literal>操作符定义。
    <footnote>
     <para>
      事实上，<productname>PostgreSQL</productname>为表达式的数据类型使用<firstterm>默认B-tree操作符类</firstterm>来决定<literal>ASC</literal>和<literal>DESC</literal>的排序顺序。照惯例，数据类型将被建立，这样<literal>&lt;</literal>和<literal>&gt;</literal>操作符负责这个排序顺序，但是一个用户定义的数据类型的设计者可以选择做些不同的设置。
     </para>
    </footnote>
  </para>
<!-- pgdoc-cn_end sig_en=79ca5c9e7e344f6db81f7ea1d5d35270 -->

<!-- pgdoc-cn_start sig_en=2b448d7b677d3e60477c7f099d120bee sig_cn_org=None source=14.1 
  <para>
   The <literal>NULLS FIRST</literal> and <literal>NULLS LAST</literal> options can be
   used to determine whether nulls appear before or after non-null values
   in the sort ordering.  By default, null values sort as if larger than any
   non-null value; that is, <literal>NULLS FIRST</literal> is the default for
   <literal>DESC</literal> order, and <literal>NULLS LAST</literal> otherwise.
  </para>
________________________________________________________-->
  <para>
   <literal>NULLS FIRST</literal>和<literal>NULLS LAST</literal>选项将可以被用来决定在排序顺序中，空值是出现在非空值之前或者出现在非空值之后。默认情况下，排序时空值被认为比任何非空值都要大，即<literal>NULLS FIRST</literal>是<literal>DESC</literal>顺序的默认值，而不是<literal>NULLS LAST</literal>的默认值。
  </para>
<!-- pgdoc-cn_end sig_en=2b448d7b677d3e60477c7f099d120bee -->

<!-- pgdoc-cn_start sig_en=885024c988618c8300bf8d4b758a598c sig_cn_org=None source=14.1 
  <para>
   Note that the ordering options are considered independently for each
   sort column.  For example <literal>ORDER BY x, y DESC</literal> means
   <literal>ORDER BY x ASC, y DESC</literal>, which is not the same as
   <literal>ORDER BY x DESC, y DESC</literal>.
  </para>
________________________________________________________-->
  <para>
   注意顺序选项是对每一个排序列独立考虑的。例如<literal>ORDER BY x, y DESC</literal>表示<literal>ORDER BY x ASC, y DESC</literal>，而和<literal>ORDER BY x DESC, y DESC</literal>不同。
  </para>
<!-- pgdoc-cn_end sig_en=885024c988618c8300bf8d4b758a598c -->

<!-- pgdoc-cn_start sig_en=61768e92c3c8baf76be8b17299241dbd sig_cn_org=None source=14.1 
  <para>
   A <replaceable>sort_expression</replaceable> can also be the column label or number
   of an output column, as in:
<programlisting>
SELECT a + b AS sum, c FROM table1 ORDER BY sum;
SELECT a, max(b) FROM table1 GROUP BY a ORDER BY 1;
</programlisting>
   both of which sort by the first output column.  Note that an output
   column name has to stand alone, that is, it cannot be used in an expression
   &mdash; for example, this is <emphasis>not</emphasis> correct:
<programlisting>
SELECT a + b AS sum, c FROM table1 ORDER BY sum + c;          -&minus; wrong
</programlisting>
   This restriction is made to reduce ambiguity.  There is still
   ambiguity if an <literal>ORDER BY</literal> item is a simple name that
   could match either an output column name or a column from the table
   expression.  The output column is used in such cases.  This would
   only cause confusion if you use <literal>AS</literal> to rename an output
   column to match some other table column's name.
  </para>
________________________________________________________-->
  <para>
   一个<replaceable>sort_expression</replaceable>也可以是列标签或者一个输出列的编号，如：
<programlisting>
SELECT a + b AS sum, c FROM table1 ORDER BY sum;
SELECT a, max(b) FROM table1 GROUP BY a ORDER BY 1;
</programlisting>
   两者都根据第一个输出列排序。注意一个输出列的名字必须孤立，即它不能被用在一个表达式中 &mdash; 例如，这是<emphasis>不</emphasis>正确的：
<programlisting>
SELECT a + b AS sum, c FROM table1 ORDER BY sum + c;          -- 错误
</programlisting>
   该限制是为了减少混淆。如果一个<literal>ORDER BY</literal>项是一个单一名字并且匹配一个输出列名或者一个表表达式的列，仍然会出现混淆。在这种情况中输出列将被使用。只有在你使用<literal>AS</literal>来重命名一个输出列来匹配某些其他表列的名字时，这才会导致混淆。
  </para>
<!-- pgdoc-cn_end sig_en=61768e92c3c8baf76be8b17299241dbd -->

<!-- pgdoc-cn_start sig_en=6b42932d7743201577ebfc5cd015af53 sig_cn_org=None source=14.1 
  <para>
   <literal>ORDER BY</literal> can be applied to the result of a
   <literal>UNION</literal>, <literal>INTERSECT</literal>, or <literal>EXCEPT</literal>
   combination, but in this case it is only permitted to sort by
   output column names or numbers, not by expressions.
  </para>
________________________________________________________-->
  <para>
   <literal>ORDER BY</literal>可以被应用于<literal>UNION</literal>、<literal>INTERSECT</literal>或<literal>EXCEPT</literal>组合的结果，但是在这种情况中它只被允许根据输出列名或编号排序，而不能根据表达式排序。
  </para>
<!-- pgdoc-cn_end sig_en=6b42932d7743201577ebfc5cd015af53 -->
 </sect1>


 <sect1 id="queries-limit">
<!-- pgdoc-cn_start sig_en=cb751aecf7fda11ec0c21f009822faf8 sig_cn_org=None source=14.1 
  <title><literal>LIMIT</literal> and <literal>OFFSET</literal></title>
________________________________________________________-->
  <title><literal>LIMIT</literal>和<literal>OFFSET</literal></title>
<!-- pgdoc-cn_end sig_en=cb751aecf7fda11ec0c21f009822faf8 -->

<!-- pgdoc-cn_start sig_en=f6073641042fdfe114a87fb783f428ca sig_cn_org=None source=14.1 
  <indexterm zone="queries-limit">
   <primary>LIMIT</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="queries-limit">
   <primary>LIMIT</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=f6073641042fdfe114a87fb783f428ca -->

<!-- pgdoc-cn_start sig_en=f736a56fb4eb67962abc2606fca579ee sig_cn_org=None source=14.1 
  <indexterm zone="queries-limit">
   <primary>OFFSET</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="queries-limit">
   <primary>OFFSET</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=f736a56fb4eb67962abc2606fca579ee -->

<!-- pgdoc-cn_start sig_en=d5647ca2ad215b06534486af8a4025e3 sig_cn_org=None source=14.1 
  <para>
   <literal>LIMIT</literal> and <literal>OFFSET</literal> allow you to retrieve just
   a portion of the rows that are generated by the rest of the query:
<synopsis>
SELECT <replaceable>select_list</replaceable>
    FROM <replaceable>table_expression</replaceable>
    <optional> ORDER BY ... </optional>
    <optional> LIMIT { <replaceable>number</replaceable> | ALL } </optional> <optional> OFFSET <replaceable>number</replaceable> </optional>
</synopsis>
  </para>
________________________________________________________-->
  <para>
   <literal>LIMIT</literal>和<literal>OFFSET</literal>允许你只检索查询剩余部分产生的行的一部分：
<synopsis>
SELECT <replaceable>select_list</replaceable>
    FROM <replaceable>table_expression</replaceable>
    <optional> ORDER BY ... </optional>
    <optional> LIMIT { <replaceable>number</replaceable> | ALL } </optional> <optional> OFFSET <replaceable>number</replaceable> </optional>
</synopsis>
  </para>
<!-- pgdoc-cn_end sig_en=d5647ca2ad215b06534486af8a4025e3 -->

<!-- pgdoc-cn_start sig_en=9dc1509f9e8f4b8ae26d816bb3d493f9 sig_cn_org=None source=14.1 
  <para>
   If a limit count is given, no more than that many rows will be
   returned (but possibly fewer, if the query itself yields fewer rows).
   <literal>LIMIT ALL</literal> is the same as omitting the <literal>LIMIT</literal>
   clause, as is <literal>LIMIT</literal> with a NULL argument.
  </para>
________________________________________________________-->
  <para>
   如果给出了一个限制计数，那么会返回数量不超过该限制的行（但可能更少些，因为查询本身可能生成的行数就比较少）。<literal>LIMIT ALL</literal>的效果和省略<literal>LIMIT</literal>子句一样，就像是<literal>LIMIT</literal>带有 NULL 参数一样。
  </para>
<!-- pgdoc-cn_end sig_en=9dc1509f9e8f4b8ae26d816bb3d493f9 -->

<!-- pgdoc-cn_start sig_en=5e3f9f1254bcc01b0041ab161d27bbba sig_cn_org=None source=14.1 
  <para>
   <literal>OFFSET</literal> says to skip that many rows before beginning to
   return rows.  <literal>OFFSET 0</literal> is the same as omitting the
   <literal>OFFSET</literal> clause, as is <literal>OFFSET</literal> with a NULL argument.
  </para>
________________________________________________________-->
  <para>
   <literal>OFFSET</literal>说明在开始返回行之前忽略多少行。<literal>OFFSET 0</literal>的效果和省略<literal>OFFSET</literal>子句是一样的，并且<literal>LIMIT NULL</literal>的效果和省略<literal>LIMIT</literal>子句一样，就像是<literal>OFFSET</literal>带有 NULL 参数一样。
  </para>
<!-- pgdoc-cn_end sig_en=5e3f9f1254bcc01b0041ab161d27bbba -->

<!-- pgdoc-cn_start sig_en=f05649446f2860308c67dffcf258a3c3 sig_cn_org=None source=14.1 
  <para>
   If both <literal>OFFSET</literal>
   and <literal>LIMIT</literal> appear, then <literal>OFFSET</literal> rows are
   skipped before starting to count the <literal>LIMIT</literal> rows that
   are returned.
  </para>
________________________________________________________-->
  <para>
   如果<literal>OFFSET</literal>和<literal>LIMIT</literal>都出现了， 那么在返回<literal>LIMIT</literal>个行之前要先忽略<literal>OFFSET</literal>行。
  </para>
<!-- pgdoc-cn_end sig_en=f05649446f2860308c67dffcf258a3c3 -->

<!-- pgdoc-cn_start sig_en=f31256311a5c3904e63c07c67e873baa sig_cn_org=None source=14.1 
  <para>
   When using <literal>LIMIT</literal>, it is important to use an
   <literal>ORDER BY</literal> clause that constrains the result rows into a
   unique order.  Otherwise you will get an unpredictable subset of
   the query's rows. You might be asking for the tenth through
   twentieth rows, but tenth through twentieth in what ordering? The
   ordering is unknown, unless you specified <literal>ORDER BY</literal>.
  </para>
________________________________________________________-->
  <para>
   如果使用<literal>LIMIT</literal>，那么用一个<literal>ORDER BY</literal>子句把结果行约束成一个唯一的顺序是很重要的。否则你就会拿到一个不可预料的该查询的行的子集。你要的可能是第十到第二十行，但以什么顺序的第十到第二十？除非你指定了<literal>ORDER BY</literal>，否则顺序是不知道的。
  </para>
<!-- pgdoc-cn_end sig_en=f31256311a5c3904e63c07c67e873baa -->

<!-- pgdoc-cn_start sig_en=0bd49cc16b1c0aa1306f36b615b2ac92 sig_cn_org=None source=14.1 
  <para>
   The query optimizer takes <literal>LIMIT</literal> into account when
   generating query plans, so you are very likely to get different
   plans (yielding different row orders) depending on what you give
   for <literal>LIMIT</literal> and <literal>OFFSET</literal>.  Thus, using
   different <literal>LIMIT</literal>/<literal>OFFSET</literal> values to select
   different subsets of a query result <emphasis>will give
   inconsistent results</emphasis> unless you enforce a predictable
   result ordering with <literal>ORDER BY</literal>.  This is not a bug; it
   is an inherent consequence of the fact that SQL does not promise to
   deliver the results of a query in any particular order unless
   <literal>ORDER BY</literal> is used to constrain the order.
  </para>
________________________________________________________-->
  <para>
   查询优化器在生成查询计划时会考虑<literal>LIMIT</literal>，因此如果你给定<literal>LIMIT</literal>和<literal>OFFSET</literal>，那么你很可能收到不同的规划（产生不同的行顺序）。因此，使用不同的<literal>LIMIT</literal>/<literal>OFFSET</literal>值选择查询结果的不同子集<emphasis>将生成不一致的结果</emphasis>，除非你用<literal>ORDER BY</literal>强制一个可预测的顺序。这并非bug， 这是一个很自然的结果，因为 SQL 没有许诺把查询的结果按照任何特定的顺序发出，除非用了<literal>ORDER BY</literal>来约束顺序。
  </para>
<!-- pgdoc-cn_end sig_en=0bd49cc16b1c0aa1306f36b615b2ac92 -->

<!-- pgdoc-cn_start sig_en=578e16f43f8d7ee08072cb014bd9894d sig_cn_org=None source=14.1 
  <para>
   The rows skipped by an <literal>OFFSET</literal> clause still have to be
   computed inside the server; therefore a large <literal>OFFSET</literal>
   might be inefficient.
  </para>
________________________________________________________-->
  <para>
   被<literal>OFFSET</literal>子句忽略的行仍然需要在服务器内部计算；因此，一个很大的<literal>OFFSET</literal>的效率可能还是不够高。
  </para>
<!-- pgdoc-cn_end sig_en=578e16f43f8d7ee08072cb014bd9894d -->
 </sect1>


 <sect1 id="queries-values">
<!-- pgdoc-cn_start sig_en=8f3aa57804e5d21261aaad236030ee63 sig_cn_org=None source=14.1 
  <title><literal>VALUES</literal> Lists</title>
________________________________________________________-->
  <title><literal>VALUES</literal>列表</title>
<!-- pgdoc-cn_end sig_en=8f3aa57804e5d21261aaad236030ee63 -->

<!-- pgdoc-cn_start sig_en=8c876160252267f4b5dd368e041fd395 sig_cn_org=None source=14.1 
  <indexterm zone="queries-values">
   <primary>VALUES</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="queries-values">
   <primary>VALUES</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=8c876160252267f4b5dd368e041fd395 -->

<!-- pgdoc-cn_start sig_en=b1aa474b4ecb0c28779d1d758fceb47e sig_cn_org=None source=14.1 
  <para>
   <literal>VALUES</literal> provides a way to generate a <quote>constant table</quote>
   that can be used in a query without having to actually create and populate
   a table on-disk.  The syntax is
<synopsis>
VALUES ( <replaceable class="parameter">expression</replaceable> [, ...] ) [, ...]
</synopsis>
   Each parenthesized list of expressions generates a row in the table.
   The lists must all have the same number of elements (i.e., the number
   of columns in the table), and corresponding entries in each list must
   have compatible data types.  The actual data type assigned to each column
   of the result is determined using the same rules as for <literal>UNION</literal>
   (see <xref linkend="typeconv-union-case"/>).
  </para>
________________________________________________________-->
  <para>
   <literal>VALUES</literal>提供了一种生成<quote>常量表</quote>的方法，它可以被使用在一个查询中而不需要实际在磁盘上创建一个表。语法是：
<synopsis>
VALUES ( <replaceable class="parameter">expression</replaceable> [, ...] ) [, ...]
</synopsis>
   每一个被圆括号包围的表达式列表生成表中的一行。列表都必须具有相同数据的元素（即表中列的数目），并且在每个列表中对应的项必须具有可兼容的数据类型。分配给结果的每一列的实际数据类型使用和<literal>UNION</literal>相同的规则确定（参见<xref linkend="typeconv-union-case"/>）。
  </para>
<!-- pgdoc-cn_end sig_en=b1aa474b4ecb0c28779d1d758fceb47e -->

<!-- pgdoc-cn_start sig_en=e2a46ea659ebc41c8e43b131f3ee0a9d sig_cn_org=None source=14.1 
  <para>
   As an example:
<programlisting>
VALUES (1, 'one'), (2, 'two'), (3, 'three');
</programlisting>

   will return a table of two columns and three rows.  It's effectively
   equivalent to:
<programlisting>
SELECT 1 AS column1, 'one' AS column2
UNION ALL
SELECT 2, 'two'
UNION ALL
SELECT 3, 'three';
</programlisting>

   By default, <productname>PostgreSQL</productname> assigns the names
   <literal>column1</literal>, <literal>column2</literal>, etc. to the columns of a
   <literal>VALUES</literal> table.  The column names are not specified by the
   SQL standard and different database systems do it differently, so
   it's usually better to override the default names with a table alias
   list, like this:
<programlisting>
=&gt; SELECT * FROM (VALUES (1, 'one'), (2, 'two'), (3, 'three')) AS t (num,letter);
 num | letter
-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;
   1 | one
   2 | two
   3 | three
(3 rows)
</programlisting>
  </para>
________________________________________________________-->
  <para>
   一个例子：
<programlisting>
VALUES (1, 'one'), (2, 'two'), (3, 'three');
</programlisting>

   将会返回一个有两列三行的表。它实际上等效于：
<programlisting>
SELECT 1 AS column1, 'one' AS column2
UNION ALL
SELECT 2, 'two'
UNION ALL
SELECT 3, 'three';
</programlisting>

   在默认情况下，<productname>PostgreSQL</productname>将<literal>column1</literal>、<literal>column2</literal>等名字分配给一个<literal>VALUES</literal>表的列。这些列名不是由SQL标准指定的，并且不同的数据库系统的做法也不同，因此通常最好使用表别名列表来重写这些默认的名字，像这样：
<programlisting>
=&gt; SELECT * FROM (VALUES (1, 'one'), (2, 'two'), (3, 'three')) AS t (num,letter);
 num | letter
-----+--------
   1 | one
   2 | two
   3 | three
(3 rows)
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=e2a46ea659ebc41c8e43b131f3ee0a9d -->

<!-- pgdoc-cn_start sig_en=b2b86d1a061a772e0d4b6b3bbbe44667 sig_cn_org=None source=14.1 
  <para>
   Syntactically, <literal>VALUES</literal> followed by expression lists is
   treated as equivalent to:
<synopsis>
SELECT <replaceable>select_list</replaceable> FROM <replaceable>table_expression</replaceable>
</synopsis>
   and can appear anywhere a <literal>SELECT</literal> can.  For example, you can
   use it as part of a <literal>UNION</literal>, or attach a
   <replaceable>sort_specification</replaceable> (<literal>ORDER BY</literal>,
   <literal>LIMIT</literal>, and/or <literal>OFFSET</literal>) to it.  <literal>VALUES</literal>
   is most commonly used as the data source in an <command>INSERT</command> command,
   and next most commonly as a subquery.
  </para>
________________________________________________________-->
  <para>
   在句法上，后面跟随着表达式列表的<literal>VALUES</literal>列表被视为和
<synopsis>
SELECT <replaceable>select_list</replaceable> FROM <replaceable>table_expression</replaceable>
</synopsis>
   一样，并且可以出现在<literal>SELECT</literal>能出现的任何地方。例如，你可以把它用作<literal>UNION</literal>的一部分，或者附加一个<replaceable>sort_specification</replaceable>（<literal>ORDER BY</literal>、<literal>LIMIT</literal>和/或<literal>OFFSET</literal>）给它。<literal>VALUES</literal>最常见的用途是作为一个<command>INSERT</command>命令的数据源，以及作为一个子查询。
  </para>
<!-- pgdoc-cn_end sig_en=b2b86d1a061a772e0d4b6b3bbbe44667 -->

<!-- pgdoc-cn_start sig_en=608f64a711afb4b0f495d9d0da2c98a4 sig_cn_org=None source=14.1 
  <para>
   For more information see <xref linkend="sql-values"/>.
  </para>
________________________________________________________-->
  <para>
   更多信息请见<xref linkend="sql-values"/>。
  </para>
<!-- pgdoc-cn_end sig_en=608f64a711afb4b0f495d9d0da2c98a4 -->

 </sect1>


 <sect1 id="queries-with">
<!-- pgdoc-cn_start sig_en=a4b901d3b9077889a8f2a4e6f8ca7899 sig_cn_org=None source=14.1 
  <title><literal>WITH</literal> Queries (Common Table Expressions)</title>
________________________________________________________-->
  <title><literal>WITH</literal>查询（公共表表达式）</title>
<!-- pgdoc-cn_end sig_en=a4b901d3b9077889a8f2a4e6f8ca7899 -->

<!-- pgdoc-cn_start sig_en=33e9c151afb2b03435051eb9887467c8 sig_cn_org=None source=14.1 
  <indexterm zone="queries-with">
   <primary>WITH</primary>
   <secondary>in SELECT</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="queries-with">
   <primary>WITH</primary>
   <secondary>in SELECT</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=33e9c151afb2b03435051eb9887467c8 -->

<!-- pgdoc-cn_start sig_en=0434c7ac99c2ecdb22aae4473d30d94e sig_cn_org=None source=14.1 
  <indexterm>
   <primary>common table expression</primary>
   <see>WITH</see>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>公共表表达式</primary>
   <see>WITH</see>
  </indexterm>
<!-- pgdoc-cn_end sig_en=0434c7ac99c2ecdb22aae4473d30d94e -->

<!-- pgdoc-cn_start sig_en=94c7c084d5743d89b732d253a93b91f5 sig_cn_org=aa1eec01140af009e017cd18b06fd02f source=15.7 
  <para>
   <literal>WITH</literal> provides a way to write auxiliary statements for use in a
   larger query.  These statements, which are often referred to as Common
   Table Expressions or <acronym>CTE</acronym>s, can be thought of as defining
   temporary tables that exist just for one query.  Each auxiliary statement
   in a <literal>WITH</literal> clause can be a <command>SELECT</command>,
   <command>INSERT</command>, <command>UPDATE</command>, or <command>DELETE</command>; and the
   <literal>WITH</literal> clause itself is attached to a primary statement that can
   be a <command>SELECT</command>, <command>INSERT</command>, <command>UPDATE</command>,
   <command>DELETE</command>, or <command>MERGE</command>.
  </para>
________________________________________________________-->
  <para>
   <literal>WITH</literal>提供了一种编写辅助语句以供在更大查询中使用的方法。这些语句通常被称为公共表达式或<acronym>CTE</acronym>，可以被视为仅用于一个查询的临时表的定义。在<literal>WITH</literal>子句中的每个辅助语句可以是<command>SELECT</command>、<command>INSERT</command>、<command>UPDATE</command>或<command>DELETE</command>；而<literal>WITH</literal>子句本身附加在一个可以是<command>SELECT</command>、<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>或<command>MERGE</command>的主语句上。
  </para>
<!-- pgdoc-cn_end sig_en=94c7c084d5743d89b732d253a93b91f5 -->

 <sect2 id="queries-with-select">
<!-- pgdoc-cn_start sig_en=a09b2a6510fe01ff0b9fb3c1986aca3e sig_cn_org=None source=14.1 
   <title><command>SELECT</command> in <literal>WITH</literal></title>
________________________________________________________-->
   <title><literal>WITH</literal>中的<command>SELECT</command></title>
<!-- pgdoc-cn_end sig_en=a09b2a6510fe01ff0b9fb3c1986aca3e -->

<!-- pgdoc-cn_start sig_en=77d7b32540dc7ab739712efff58a4e92 sig_cn_org=None source=14.1 
  <para>
   The basic value of <command>SELECT</command> in <literal>WITH</literal> is to
   break down complicated queries into simpler parts.  An example is:

<programlisting>
WITH regional_sales AS (
    SELECT region, SUM(amount) AS total_sales
    FROM orders
    GROUP BY region
), top_regions AS (
    SELECT region
    FROM regional_sales
    WHERE total_sales &gt; (SELECT SUM(total_sales)/10 FROM regional_sales)
)
SELECT region,
       product,
       SUM(quantity) AS product_units,
       SUM(amount) AS product_sales
FROM orders
WHERE region IN (SELECT region FROM top_regions)
GROUP BY region, product;
</programlisting>

   which displays per-product sales totals in only the top sales regions.
   The <literal>WITH</literal> clause defines two auxiliary statements named
   <structname>regional_sales</structname> and <structname>top_regions</structname>,
   where the output of <structname>regional_sales</structname> is used in
   <structname>top_regions</structname> and the output of <structname>top_regions</structname>
   is used in the primary <command>SELECT</command> query.
   This example could have been written without <literal>WITH</literal>,
   but we'd have needed two levels of nested sub-<command>SELECT</command>s.  It's a bit
   easier to follow this way.
  </para>
________________________________________________________-->
  <para>
   <literal>WITH</literal>中<command>SELECT</command>的基本价值是将复杂的查询分解称为简单的部分。一个例子：

<programlisting>
WITH regional_sales AS (
    SELECT region, SUM(amount) AS total_sales
    FROM orders
    GROUP BY region
), top_regions AS (
    SELECT region
    FROM regional_sales
    WHERE total_sales &gt; (SELECT SUM(total_sales)/10 FROM regional_sales)
)
SELECT region,
       product,
       SUM(quantity) AS product_units,
       SUM(amount) AS product_sales
FROM orders
WHERE region IN (SELECT region FROM top_regions)
GROUP BY region, product;
</programlisting>

   它只显示在高销售区域每种产品的销售总额。<literal>WITH</literal>子句定义了两个辅助语句<structname>regional_sales</structname>和<structname>top_regions</structname>，其中<structname>regional_sales</structname>的输出用在<structname>top_regions</structname>中而<structname>top_regions</structname>的输出用在主<command>SELECT</command>查询。这个例子可以不用<literal>WITH</literal>来书写，但是我们必须要用两层嵌套的子<command>SELECT</command>。使用这种方法要更简单些。
  </para>
<!-- pgdoc-cn_end sig_en=77d7b32540dc7ab739712efff58a4e92 -->
 </sect2>

 <sect2 id="queries-with-recursive">
<!-- pgdoc-cn_start sig_en=4da4583c32ea4a6efaf2cfece87e1ed0 sig_cn_org=None source=14.1 
  <title>Recursive Queries</title>
________________________________________________________-->
  <title>Recursive Queries</title>
<!-- pgdoc-cn_end sig_en=4da4583c32ea4a6efaf2cfece87e1ed0 -->

<!-- pgdoc-cn_start sig_en=60ff8cff01d0f3b1aad98ce2023aad6c sig_cn_org=None source=14.1 
  <para>
   <indexterm>
    <primary>RECURSIVE</primary>
    <secondary>in common table expressions</secondary>
   </indexterm>
   The optional <literal>RECURSIVE</literal> modifier changes <literal>WITH</literal>
   from a mere syntactic convenience into a feature that accomplishes
   things not otherwise possible in standard SQL.  Using
   <literal>RECURSIVE</literal>, a <literal>WITH</literal> query can refer to its own
   output.  A very simple example is this query to sum the integers from 1
   through 100:

<programlisting>
WITH RECURSIVE t(n) AS (
    VALUES (1)
  UNION ALL
    SELECT n+1 FROM t WHERE n &lt; 100
)
SELECT sum(n) FROM t;
</programlisting>

   The general form of a recursive <literal>WITH</literal> query is always a
   <firstterm>non-recursive term</firstterm>, then <literal>UNION</literal> (or
   <literal>UNION ALL</literal>), then a
   <firstterm>recursive term</firstterm>, where only the recursive term can contain
   a reference to the query's own output.  Such a query is executed as
   follows:
  </para>
________________________________________________________-->
  <para>
   <indexterm>
    <primary>RECURSIVE</primary>
    <secondary>in common table expressions</secondary>
   </indexterm>
   可选的<literal>RECURSIVE</literal>修饰符将<literal>WITH</literal>从单纯的句法便利变成了一种在标准SQL中不能完成的特性。通过使用<literal>RECURSIVE</literal>，一个<literal>WITH</literal>查询可以引用它自己的输出。一个非常简单的例子是计算从1到100的整数和的查询：

<programlisting>
WITH RECURSIVE t(n) AS (
    VALUES (1)
  UNION ALL
    SELECT n+1 FROM t WHERE n &lt; 100
)
SELECT sum(n) FROM t;
</programlisting>

   一个递归<literal>WITH</literal>查询的通常形式总是一个<firstterm>非递归项</firstterm>，然后是<literal>UNION</literal>（或者<literal>UNION ALL</literal>），再然后是一个<firstterm>递归项</firstterm>，其中只有递归项能够包含对于查询自身输出的引用。这样一个查询可以被这样执行：
  </para>
<!-- pgdoc-cn_end sig_en=60ff8cff01d0f3b1aad98ce2023aad6c -->

  <procedure>
<!-- pgdoc-cn_start sig_en=4195e4e83db4cb318933eb7dba7e12a0 sig_cn_org=None source=14.1 
   <title>Recursive Query Evaluation</title>
________________________________________________________-->
   <title>递归查询求值</title>
<!-- pgdoc-cn_end sig_en=4195e4e83db4cb318933eb7dba7e12a0 -->

   <step performance="required">
<!-- pgdoc-cn_start sig_en=4eca5e9b4d7258b6ca6e28348469b068 sig_cn_org=None source=14.1 
    <para>
     Evaluate the non-recursive term.  For <literal>UNION</literal> (but not
     <literal>UNION ALL</literal>), discard duplicate rows.  Include all remaining
     rows in the result of the recursive query, and also place them in a
     temporary <firstterm>working table</firstterm>.
    </para>
________________________________________________________-->
    <para>
     计算非递归项。对<literal>UNION</literal>（但不对<literal>UNION ALL</literal>），抛弃重复行。把所有剩余的行包括在递归查询的结果中，并且也把它们放在一个临时的<firstterm>工作表</firstterm>中。
    </para>
<!-- pgdoc-cn_end sig_en=4eca5e9b4d7258b6ca6e28348469b068 -->
   </step>

   <step performance="required">
<!-- pgdoc-cn_start sig_en=a14c6b92de512e34aa89a8f31f4ea4f1 sig_cn_org=None source=14.1 
    <para>
     So long as the working table is not empty, repeat these steps:
    </para>
________________________________________________________-->
    <para>
     只要工作表不为空，重复下列步骤：
    </para>
<!-- pgdoc-cn_end sig_en=a14c6b92de512e34aa89a8f31f4ea4f1 -->
    <substeps>
     <step performance="required">
<!-- pgdoc-cn_start sig_en=2616c6b960f5e75d2a67cf253ae64876 sig_cn_org=None source=14.1 
      <para>
       Evaluate the recursive term, substituting the current contents of
       the working table for the recursive self-reference.
       For <literal>UNION</literal> (but not <literal>UNION ALL</literal>), discard
       duplicate rows and rows that duplicate any previous result row.
       Include all remaining rows in the result of the recursive query, and
       also place them in a temporary <firstterm>intermediate table</firstterm>.
      </para>
________________________________________________________-->
      <para>
       计算递归项，用当前工作表的内容替换递归自引用。对<literal>UNION</literal>（不是<literal>UNION ALL</literal>），抛弃重复行以及那些与之前结果行重复的行。将剩下的所有行包括在递归查询的结果中，并且也把它们放在一个临时的<firstterm>中间表</firstterm>中。
      </para>
<!-- pgdoc-cn_end sig_en=2616c6b960f5e75d2a67cf253ae64876 -->
     </step>

     <step performance="required">
<!-- pgdoc-cn_start sig_en=daff7a3389936f01b9cf7b808f063b7c sig_cn_org=None source=14.1 
      <para>
       Replace the contents of the working table with the contents of the
       intermediate table, then empty the intermediate table.
      </para>
________________________________________________________-->
      <para>
       用中间表的内容替换工作表的内容，然后清空中间表。
      </para>
<!-- pgdoc-cn_end sig_en=daff7a3389936f01b9cf7b808f063b7c -->
     </step>
    </substeps>
   </step>
  </procedure>

  <note>
<!-- pgdoc-cn_start sig_en=0a1450d64e6a7da2951df3573dc00735 sig_cn_org=3c806eadc1e821141c02a67083d94fec source=15.7 
   <para>
    While <literal>RECURSIVE</literal> allows queries to be specified
    recursively, internally such queries are evaluated iteratively.
   </para>
________________________________________________________-->
   <para>
    虽然<literal>RECURSIVE</literal>允许递归指定查询，但在内部这样的查询是迭代评估的。
   </para>
<!-- pgdoc-cn_end sig_en=0a1450d64e6a7da2951df3573dc00735 -->
  </note>

<!-- pgdoc-cn_start sig_en=9d887151367169468c003630e65f1bec sig_cn_org=None source=14.1 
  <para>
   In the example above, the working table has just a single row in each step,
   and it takes on the values from 1 through 100 in successive steps.  In
   the 100th step, there is no output because of the <literal>WHERE</literal>
   clause, and so the query terminates.
  </para>
________________________________________________________-->
  <para>
   在上面的例子中，工作表在每一步只有一个行，并且它在连续的步骤中取值从1到100。在第100步，由于<literal>WHERE</literal>子句导致没有输出，因此查询终止。
  </para>
<!-- pgdoc-cn_end sig_en=9d887151367169468c003630e65f1bec -->

<!-- pgdoc-cn_start sig_en=d223acc0b0c97f45d6659550f0c96098 sig_cn_org=237a25af8f6f7b4d43f8a7a4acbca418 source=15.7 
  <para>
   Recursive queries are typically used to deal with hierarchical or
   tree-structured data.  A useful example is this query to find all the
   direct and indirect sub-parts of a product, given only a table that
   shows immediate inclusions:

<programlisting>
WITH RECURSIVE included_parts(sub_part, part, quantity) AS (
    SELECT sub_part, part, quantity FROM parts WHERE part = 'our_product'
  UNION ALL
    SELECT p.sub_part, p.part, p.quantity * pr.quantity
    FROM included_parts pr, parts p
    WHERE p.part = pr.sub_part
)
SELECT sub_part, SUM(quantity) as total_quantity
FROM included_parts
GROUP BY sub_part
</programlisting>
  </para>
________________________________________________________-->
  <para>
   递归查询通常用于处理分层或树形结构数据。一个有用的例子是这个查询，用于查找产品的所有直接和间接子部件，只给出一个显示直接包含关系的表：

<programlisting>
WITH RECURSIVE included_parts(sub_part, part, quantity) AS (
    SELECT sub_part, part, quantity FROM parts WHERE part = 'our_product'
  UNION ALL
    SELECT p.sub_part, p.part, p.quantity * pr.quantity
    FROM included_parts pr, parts p
    WHERE p.part = pr.sub_part
)
SELECT sub_part, SUM(quantity) as total_quantity
FROM included_parts
GROUP BY sub_part
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=d223acc0b0c97f45d6659550f0c96098 -->

  <sect3 id="queries-with-search">
<!-- pgdoc-cn_start sig_en=e0133a2ce4fdb92d8678ba6fb87d0e49 sig_cn_org=None source=14.1 
   <title>Search Order</title>
________________________________________________________-->
   <title>Search Order</title>
<!-- pgdoc-cn_end sig_en=e0133a2ce4fdb92d8678ba6fb87d0e49 -->

<!-- pgdoc-cn_start sig_en=0def9d780c93c8dde0272a9d3f506ce0 sig_cn_org=None source=14.1 
   <para>
    When computing a tree traversal using a recursive query, you might want to
    order the results in either depth-first or breadth-first order.  This can
    be done by computing an ordering column alongside the other data columns
    and using that to sort the results at the end.  Note that this does not
    actually control in which order the query evaluation visits the rows; that
    is as always in SQL implementation-dependent.  This approach merely
    provides a convenient way to order the results afterwards.
   </para>
________________________________________________________-->
   <para>
     当使用递归查询计算树形遍历时，你可能希望以深度优先或广度优先的顺序对结果进行排序。这可以通过计算与其他数据列一起的排序列来实现，并在最后用它来对结果进行排序。请注意，这实际上并不能控制查询评估访问行的顺序；这在SQL中总是取决于实现。这种方法只是提供了一种方便的方法来对结果进行排序。
     </para>
<!-- pgdoc-cn_end sig_en=0def9d780c93c8dde0272a9d3f506ce0 -->

<!-- pgdoc-cn_start sig_en=8735d6e14853d208969c7ee1ac64bfb8 sig_cn_org=None source=14.1 
   <para>
    To create a depth-first order, we compute for each result row an array of
    rows that we have visited so far.  For example, consider the following
    query that searches a table <structname>tree</structname> using a
    <structfield>link</structfield> field:

<programlisting>
WITH RECURSIVE search_tree(id, link, data) AS (
    SELECT t.id, t.link, t.data
    FROM tree t
  UNION ALL
    SELECT t.id, t.link, t.data
    FROM tree t, search_tree st
    WHERE t.id = st.link
)
SELECT * FROM search_tree;
</programlisting>

    To add depth-first ordering information, you can write this:

<programlisting>
WITH RECURSIVE search_tree(id, link, data, <emphasis>path</emphasis>) AS (
    SELECT t.id, t.link, t.data, <emphasis>ARRAY[t.id]</emphasis>
    FROM tree t
  UNION ALL
    SELECT t.id, t.link, t.data, <emphasis>path || t.id</emphasis>
    FROM tree t, search_tree st
    WHERE t.id = st.link
)
SELECT * FROM search_tree <emphasis>ORDER BY path</emphasis>;
</programlisting>
   </para>
________________________________________________________-->
   <para>
     为了创建深度优先顺序，我们针对每个结果行计算已访问的行数组。例如，考虑使用<structfield>link</structfield>字段对表<structname>tree</structname>进行搜索的以下查询：
  <programlisting>
  WITH RECURSIVE search_tree(id, link, data) AS (
      SELECT t.id, t.link, t.data
      FROM tree t
    UNION ALL
      SELECT t.id, t.link, t.data
      FROM tree t, search_tree st
      WHERE t.id = st.link
  )
  SELECT * FROM search_tree;
  </programlisting>

      为了增加深度优先的排序信息，你可以这样写：

  <programlisting>
  WITH RECURSIVE search_tree(id, link, data, <emphasis>path</emphasis>) AS (
      SELECT t.id, t.link, t.data, <emphasis>ARRAY[t.id]</emphasis>
      FROM tree t
    UNION ALL
      SELECT t.id, t.link, t.data, <emphasis>path || t.id</emphasis>
      FROM tree t, search_tree st
      WHERE t.id = st.link
  )
  SELECT * FROM search_tree <emphasis>ORDER BY path</emphasis>;
  </programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=8735d6e14853d208969c7ee1ac64bfb8 -->

<!-- pgdoc-cn_start sig_en=d795cf2b3a856e9653b121ccd7e04db4 sig_cn_org=None source=14.1 
   <para>
    In the general case where more than one field needs to be used to identify
    a row, use an array of rows.  For example, if we needed to track fields
    <structfield>f1</structfield> and <structfield>f2</structfield>:

<programlisting>
WITH RECURSIVE search_tree(id, link, data, <emphasis>path</emphasis>) AS (
    SELECT t.id, t.link, t.data, <emphasis>ARRAY[ROW(t.f1, t.f2)]</emphasis>
    FROM tree t
  UNION ALL
    SELECT t.id, t.link, t.data, <emphasis>path || ROW(t.f1, t.f2)</emphasis>
    FROM tree t, search_tree st
    WHERE t.id = st.link
)
SELECT * FROM search_tree <emphasis>ORDER BY path</emphasis>;
</programlisting>
   </para>
________________________________________________________-->
   <para>
     在需要使用多个字段来识别行的一般情况下，使用一组行记录。例如，如果我们需要跟踪 <structfield>f1</structfield> 和 <structfield>f2</structfield> 字段，则使用一个行记录数组：

  <programlisting>
  WITH RECURSIVE search_tree(id, link, data, <emphasis>path</emphasis>) AS (
      SELECT t.id, t.link, t.data, <emphasis>ARRAY[ROW(t.f1, t.f2)]</emphasis>
      FROM tree t
    UNION ALL
      SELECT t.id, t.link, t.data, <emphasis>path || ROW(t.f1, t.f2)</emphasis>
      FROM tree t, search_tree st
      WHERE t.id = st.link
  )
  SELECT * FROM search_tree <emphasis>ORDER BY path</emphasis>;
  </programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=d795cf2b3a856e9653b121ccd7e04db4 -->

   <tip>
<!-- pgdoc-cn_start sig_en=f23ca72c5bc3c910177a7d0bad49c1f5 sig_cn_org=None source=14.1 
    <para>
     Omit the <literal>ROW()</literal> syntax in the common case where only one
     field needs to be tracked.  This allows a simple array rather than a
     composite-type array to be used, gaining efficiency.
    </para>
________________________________________________________-->
    <para>
      在通常情况下只需要跟踪一个字段，可以省略 <literal>ROW()</literal> 语法。这样可以使用简单的数组而不是复合类型数组，提高效率。
      </para>
<!-- pgdoc-cn_end sig_en=f23ca72c5bc3c910177a7d0bad49c1f5 -->
   </tip>

<!-- pgdoc-cn_start sig_en=0456e538340e46c277020fd7087dfd76 sig_cn_org=None source=14.1 
   <para>
    To create a breadth-first order, you can add a column that tracks the depth
    of the search, for example:

<programlisting>
WITH RECURSIVE search_tree(id, link, data, <emphasis>depth</emphasis>) AS (
    SELECT t.id, t.link, t.data, <emphasis>0</emphasis>
    FROM tree t
  UNION ALL
    SELECT t.id, t.link, t.data, <emphasis>depth + 1</emphasis>
    FROM tree t, search_tree st
    WHERE t.id = st.link
)
SELECT * FROM search_tree <emphasis>ORDER BY depth</emphasis>;
</programlisting>

    To get a stable sort, add data columns as secondary sorting columns.
   </para>
________________________________________________________-->
   <para>
      为了创建一个广度优先的顺序，你可以添加一个跟踪搜索深度的列，例如：

  <programlisting>
  WITH RECURSIVE search_tree(id, link, data, <emphasis>depth</emphasis>) AS (
      SELECT t.id, t.link, t.data, <emphasis>0</emphasis>
      FROM tree t
    UNION ALL
      SELECT t.id, t.link, t.data, <emphasis>depth + 1</emphasis>
      FROM tree t, search_tree st
      WHERE t.id = st.link
  )
  SELECT * FROM search_tree <emphasis>ORDER BY depth</emphasis>;
  </programlisting>
      添加数据列作为二级排序列以获得稳定的排序。
     </para>
<!-- pgdoc-cn_end sig_en=0456e538340e46c277020fd7087dfd76 -->

   <tip>
<!-- pgdoc-cn_start sig_en=4b9f48aa49cdac777e838d170b88777f sig_cn_org=None source=14.1 
    <para>
     The recursive query evaluation algorithm produces its output in
     breadth-first search order.  However, this is an implementation detail and
     it is perhaps unsound to rely on it.  The order of the rows within each
     level is certainly undefined, so some explicit ordering might be desired
     in any case.
    </para>
________________________________________________________-->
    <para>
       递归查询评估算法以广度优先搜索顺序生成其输出。但是，这是一种实施细节，可能不能依赖它。每个级别内行的顺序肯定是未定义的，因此在任何情况下都可能需要一些显式排序。
      </para>
<!-- pgdoc-cn_end sig_en=4b9f48aa49cdac777e838d170b88777f -->
   </tip>

<!-- pgdoc-cn_start sig_en=792caec2a39a748b2f6f1fa541ab6610 sig_cn_org=None source=14.1 
   <para>
    There is built-in syntax to compute a depth- or breadth-first sort column.
    For example:

<programlisting>
WITH RECURSIVE search_tree(id, link, data) AS (
    SELECT t.id, t.link, t.data
    FROM tree t
  UNION ALL
    SELECT t.id, t.link, t.data
    FROM tree t, search_tree st
    WHERE t.id = st.link
) <emphasis>SEARCH DEPTH FIRST BY id SET ordercol</emphasis>
SELECT * FROM search_tree ORDER BY ordercol;

WITH RECURSIVE search_tree(id, link, data) AS (
    SELECT t.id, t.link, t.data
    FROM tree t
  UNION ALL
    SELECT t.id, t.link, t.data
    FROM tree t, search_tree st
    WHERE t.id = st.link
) <emphasis>SEARCH BREADTH FIRST BY id SET ordercol</emphasis>
SELECT * FROM search_tree ORDER BY ordercol;
</programlisting>
    This syntax is internally expanded to something similar to the above
    hand-written forms.  The <literal>SEARCH</literal> clause specifies whether
    depth- or breadth first search is wanted, the list of columns to track for
    sorting, and a column name that will contain the result data that can be
    used for sorting.  That column will implicitly be added to the output rows
    of the CTE.
   </para>
________________________________________________________-->
   <para>
      有内置的语法可以计算深度或广度优先排序列。例如：
  <programlisting>
  WITH RECURSIVE search_tree(id, link, data) AS (
      SELECT t.id, t.link, t.data
      FROM tree t
    UNION ALL
      SELECT t.id, t.link, t.data
      FROM tree t, search_tree st
      WHERE t.id = st.link
  ) <emphasis>SEARCH DEPTH FIRST BY id SET ordercol</emphasis>
  SELECT * FROM search_tree ORDER BY ordercol;

  WITH RECURSIVE search_tree(id, link, data) AS (
      SELECT t.id, t.link, t.data
      FROM tree t
    UNION ALL
      SELECT t.id, t.link, t.data
      FROM tree t, search_tree st
      WHERE t.id = st.link
  ) <emphasis>SEARCH BREADTH FIRST BY id SET ordercol</emphasis>
  SELECT * FROM search_tree ORDER BY ordercol;
  </programlisting>
      这个语法会在内部扩展为类似于上面手动编写的表单。 <literal>SEARCH</literal> 子句指定要搜索深度优先还是广度优先，要跟踪进行排序的列的列表以及包含可用于排序的结果数据的列名称。该列将隐式地添加到CTE的输出行中。
     </para>
<!-- pgdoc-cn_end sig_en=792caec2a39a748b2f6f1fa541ab6610 -->
  </sect3>

  <sect3 id="queries-with-cycle">
<!-- pgdoc-cn_start sig_en=d0547114a749639932289030438a0daf sig_cn_org=None source=14.1 
   <title>Cycle Detection</title>
________________________________________________________-->
   <title>Cycle Detection</title>
<!-- pgdoc-cn_end sig_en=d0547114a749639932289030438a0daf -->

<!-- pgdoc-cn_start sig_en=6411d0837e98f2510a4363ecb1d3452f sig_cn_org=None source=14.1 
  <para>
   When working with recursive queries it is important to be sure that
   the recursive part of the query will eventually return no tuples,
   or else the query will loop indefinitely.  Sometimes, using
   <literal>UNION</literal> instead of <literal>UNION ALL</literal> can accomplish this
   by discarding rows that duplicate previous output rows.  However, often a
   cycle does not involve output rows that are completely duplicate: it may be
   necessary to check just one or a few fields to see if the same point has
   been reached before.  The standard method for handling such situations is
   to compute an array of the already-visited values.  For example, consider again
   the following query that searches a table <structname>graph</structname> using a
   <structfield>link</structfield> field:

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth) AS (
    SELECT g.id, g.link, g.data, 0
    FROM graph g
  UNION ALL
    SELECT g.id, g.link, g.data, sg.depth + 1
    FROM graph g, search_graph sg
    WHERE g.id = sg.link
)
SELECT * FROM search_graph;
</programlisting>

   This query will loop if the <structfield>link</structfield> relationships contain
   cycles.  Because we require a <quote>depth</quote> output, just changing
   <literal>UNION ALL</literal> to <literal>UNION</literal> would not eliminate the looping.
   Instead we need to recognize whether we have reached the same row again
   while following a particular path of links.  We add two columns
   <structfield>is_cycle</structfield> and <structfield>path</structfield> to the loop-prone query:

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth, <emphasis>is_cycle, path</emphasis>) AS (
    SELECT g.id, g.link, g.data, 0,
      <emphasis>false,
      ARRAY[g.id]</emphasis>
    FROM graph g
  UNION ALL
    SELECT g.id, g.link, g.data, sg.depth + 1,
      <emphasis>g.id = ANY(path),
      path || g.id</emphasis>
    FROM graph g, search_graph sg
    WHERE g.id = sg.link <emphasis>AND NOT is_cycle</emphasis>
)
SELECT * FROM search_graph;
</programlisting>

   Aside from preventing cycles, the array value is often useful in its own
   right as representing the <quote>path</quote> taken to reach any particular row.
  </para>
________________________________________________________-->
  <para>
   在使用递归查询时，确保查询的递归部分最终将不返回元组非常重要，否则查询将会无限循环。在某些时候，使用<literal>UNION</literal>替代<literal>UNION ALL</literal>可以通过抛弃与之前输出行重复的行来达到这个目的。不过，经常有循环不涉及到完全重复的输出行：它可能只需要检查一个或几个域来看相同点之前是否达到过。处理这种情况的标准方法是计算一个已经访问过值的数组。例如，考虑下面这个使用<structfield>link</structfield>域搜索表<structname>graph</structname>的查询：

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth) AS (
    SELECT g.id, g.link, g.data, 0
    FROM graph g
  UNION ALL
    SELECT g.id, g.link, g.data, sg.depth + 1
    FROM graph g, search_graph sg
    WHERE g.id = sg.link
)
SELECT * FROM search_graph;
</programlisting>

   如果<structfield>link</structfield>关系包含环，这个查询将会循环。因为我们要求一个<quote>depth</quote>输出，仅仅将<literal>UNION ALL</literal> 改为<literal>UNION</literal>不会消除循环。反过来在我们顺着一个特定链接路径搜索时，我们需要识别我们是否再次到达了一个相同的行。我们可以向这个有循环倾向的查询增加两个列<structfield>is_cycle</structfield>和<structfield>path</structfield>：

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth, <emphasis>is_cycle, path</emphasis>) AS (
    SELECT g.id, g.link, g.data, 0,
      <emphasis>false,
      ARRAY[g.id]</emphasis>
    FROM graph g
  UNION ALL
    SELECT g.id, g.link, g.data, sg.depth + 1,
      <emphasis>g.id = ANY(path),
      path || g.id</emphasis>
    FROM graph g, search_graph sg
    WHERE g.id = sg.link <emphasis>AND NOT is_cycle</emphasis>
)
SELECT * FROM search_graph;
</programlisting>

   除了阻止环，数组值对于它们自己的工作显示到达任何特定行的<quote>path</quote>也有用。
  </para>
<!-- pgdoc-cn_end sig_en=6411d0837e98f2510a4363ecb1d3452f -->

<!-- pgdoc-cn_start sig_en=c5066ea048883d52a3b878dadbbb3ae4 sig_cn_org=None source=14.1 
  <para>
   In the general case where more than one field needs to be checked to
   recognize a cycle, use an array of rows.  For example, if we needed to
   compare fields <structfield>f1</structfield> and <structfield>f2</structfield>:

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth, <emphasis>is_cycle, path</emphasis>) AS (
    SELECT g.id, g.link, g.data, 0,
      <emphasis>false,
      ARRAY[ROW(g.f1, g.f2)]</emphasis>
    FROM graph g
  UNION ALL
    SELECT g.id, g.link, g.data, sg.depth + 1,
      <emphasis>ROW(g.f1, g.f2) = ANY(path),
      path || ROW(g.f1, g.f2)</emphasis>
    FROM graph g, search_graph sg
    WHERE g.id = sg.link <emphasis>AND NOT is_cycle</emphasis>
)
SELECT * FROM search_graph;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   在通常情况下如果需要检查多于一个域来识别一个环，请用行数组。例如，如果我们需要比较域<structfield>f1</structfield>和<structfield>f2</structfield>：

<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth, <emphasis>is_cycle, path</emphasis>) AS (
    SELECT g.id, g.link, g.data, 0,
      <emphasis>false,
      ARRAY[ROW(g.f1, g.f2)]</emphasis>
    FROM graph g
  UNION ALL
    SELECT g.id, g.link, g.data, sg.depth + 1,
      <emphasis>ROW(g.f1, g.f2) = ANY(path),
      path || ROW(g.f1, g.f2)</emphasis>
    FROM graph g, search_graph sg
    WHERE g.id = sg.link <emphasis>AND NOT is_cycle</emphasis>
)
SELECT * FROM search_graph;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=c5066ea048883d52a3b878dadbbb3ae4 -->

  <tip>
<!-- pgdoc-cn_start sig_en=d77004433d7d2ef419f466b7a455cde7 sig_cn_org=None source=14.1 
   <para>
    Omit the <literal>ROW()</literal> syntax in the common case where only one field
    needs to be checked to recognize a cycle.  This allows a simple array
    rather than a composite-type array to be used, gaining efficiency.
   </para>
________________________________________________________-->
   <para>
    在通常情况下只有一个域需要被检查来识别一个环，可以省略<literal>ROW()</literal>语法。这允许使用一个简单的数组而不是一个组合类型数组，可以获得效率。
   </para>
<!-- pgdoc-cn_end sig_en=d77004433d7d2ef419f466b7a455cde7 -->
  </tip>

<!-- pgdoc-cn_start sig_en=ee3b105bbcdca639ebea2bf7fb168325 sig_cn_org=None source=14.1 
  <para>
   There is built-in syntax to simplify cycle detection.  The above query can
   also be written like this:
<programlisting>
WITH RECURSIVE search_graph(id, link, data, depth) AS (
    SELECT g.id, g.link, g.data, 1
    FROM graph g
  UNION ALL
    SELECT g.id, g.link, g.data, sg.depth + 1
    FROM graph g, search_graph sg
    WHERE g.id = sg.link
) <emphasis>CYCLE id SET is_cycle USING path</emphasis>
SELECT * FROM search_graph;
</programlisting>
   and it will be internally rewritten to the above form.  The
   <literal>CYCLE</literal> clause specifies first the list of columns to
   track for cycle detection, then a column name that will show whether a
   cycle has been detected, and finally the name of another column that will track the
   path.  The cycle and path columns will implicitly be added to the output
   rows of the CTE.
  </para>
________________________________________________________-->
  <para>
     有一种内置的语法可以简化环路检测。上面的查询也可以这样编写：
  <programlisting>
  WITH RECURSIVE search_graph(id, link, data, depth) AS (
      SELECT g.id, g.link, g.data, 1
      FROM graph g
    UNION ALL
      SELECT g.id, g.link, g.data, sg.depth + 1
      FROM graph g, search_graph sg
      WHERE g.id = sg.link
  ) <emphasis>CYCLE id SET is_cycle USING path</emphasis>
  SELECT * FROM search_graph;
  </programlisting>
     内部将被重写成上述形式。<literal>CYCLE</literal> 子句首先指定要跟踪的列以检测循环，然后是一个列名，它将显示是否检测到循环，最后是将跟踪路径的其他列的名称。 循环和路径列将隐含地添加到 CTE 的输出行中。
    </para>
<!-- pgdoc-cn_end sig_en=ee3b105bbcdca639ebea2bf7fb168325 -->

  <tip>
<!-- pgdoc-cn_start sig_en=3950c0ba2877f04f2304222a45813c49 sig_cn_org=None source=14.1 
   <para>
    The cycle path column is computed in the same way as the depth-first
    ordering column show in the previous section.  A query can have both a
    <literal>SEARCH</literal> and a <literal>CYCLE</literal> clause, but a
    depth-first search specification and a cycle detection specification would
    create redundant computations, so it's more efficient to just use the
    <literal>CYCLE</literal> clause and order by the path column.  If
    breadth-first ordering is wanted, then specifying both
    <literal>SEARCH</literal> and <literal>CYCLE</literal> can be useful.
   </para>
________________________________________________________-->
   <para>
    循环路径列的计算方法与上一节中显示的深度优先排序列相同。 一个查询可以同时有<literal>SEARCH</literal>和<literal>CYCLE</literal>子句，但是深度优先的搜索规范和周期检测规范会产生多余的计算，所以只使用<literal>CYCLE</literal>子句并按路径列排序会更有效率。 如果想要进行广度优先排序，那么同时指定<literal>SEARCH</literal>和<literal>CYCLE</literal>会很有用。
   </para>
<!-- pgdoc-cn_end sig_en=3950c0ba2877f04f2304222a45813c49 -->
  </tip>

<!-- pgdoc-cn_start sig_en=ed5f667695fde380890f589388483c29 sig_cn_org=None source=14.1 
  <para>
   A helpful trick for testing queries
   when you are not certain if they might loop is to place a <literal>LIMIT</literal>
   in the parent query.  For example, this query would loop forever without
   the <literal>LIMIT</literal>:

<programlisting>
WITH RECURSIVE t(n) AS (
    SELECT 1
  UNION ALL
    SELECT n+1 FROM t
)
SELECT n FROM t <emphasis>LIMIT 100</emphasis>;
</programlisting>

   This works because <productname>PostgreSQL</productname>'s implementation
   evaluates only as many rows of a <literal>WITH</literal> query as are actually
   fetched by the parent query.  Using this trick in production is not
   recommended, because other systems might work differently.  Also, it
   usually won't work if you make the outer query sort the recursive query's
   results or join them to some other table, because in such cases the
   outer query will usually try to fetch all of the <literal>WITH</literal> query's
   output anyway.
  </para>
________________________________________________________-->
  <para>
   当你不确定查询是否可能循环时，一个测试查询的有用技巧是在父查询中放一个<literal>LIMIT</literal>。例如，这个查询没有<literal>LIMIT</literal>时会永远循环：

<programlisting>
WITH RECURSIVE t(n) AS (
    SELECT 1
  UNION ALL
    SELECT n+1 FROM t
)
SELECT n FROM t <emphasis>LIMIT 100</emphasis>;
</programlisting>

   这会起作用，因为<productname>PostgreSQL</productname>的实现只计算<literal>WITH</literal>查询中被父查询实际取到的行。不推荐在生产中使用这个技巧，因为其他系统可能以不同方式工作。同样，如果你让外层查询排序递归查询的结果或者把它们连接成某种其他表，这个技巧将不会起作用，因为在这些情况下外层查询通常将尝试取得<literal>WITH</literal>查询的所有输出。
  </para>
<!-- pgdoc-cn_end sig_en=ed5f667695fde380890f589388483c29 -->
  </sect3>
 </sect2>

 <sect2>
<!-- pgdoc-cn_start sig_en=c0b4b2f5083098bf3b2297b2a518771a sig_cn_org=None source=14.1 
  <title>Common Table Expression Materialization</title>
________________________________________________________-->
  <title>Common Table Expression Materialization</title>
<!-- pgdoc-cn_end sig_en=c0b4b2f5083098bf3b2297b2a518771a -->

<!-- pgdoc-cn_start sig_en=667914165a1fa523c9116b27f4cf026e sig_cn_org=None source=14.1 
  <para>
   A useful property of <literal>WITH</literal> queries is that they are
   normally evaluated only once per execution of the parent query, even if
   they are referred to more than once by the parent query or
   sibling <literal>WITH</literal> queries.
   Thus, expensive calculations that are needed in multiple places can be
   placed within a <literal>WITH</literal> query to avoid redundant work.  Another
   possible application is to prevent unwanted multiple evaluations of
   functions with side-effects.
   However, the other side of this coin is that the optimizer is not able to
   push restrictions from the parent query down into a multiply-referenced
   <literal>WITH</literal> query, since that might affect all uses of the
   <literal>WITH</literal> query's output when it should affect only one.
   The multiply-referenced <literal>WITH</literal> query will be
   evaluated as written, without suppression of rows that the parent query
   might discard afterwards.  (But, as mentioned above, evaluation might stop
   early if the reference(s) to the query demand only a limited number of
   rows.)
  </para>
________________________________________________________-->
  <para>
   <literal>WITH</literal>查询的一个有用的特性是在每一次父查询的执行中它们通常只被计算一次，即使它们被父查询或兄弟<literal>WITH</literal>查询引用了超过一次。
   因此，在多个地方需要的昂贵计算可以被放在一个<literal>WITH</literal>查询中来避免冗余工作。另一种可能的应用是阻止不希望的多个函数计算产生副作用。
   但是，从另一方面来看，优化器不能将来自父查询的约束下推到乘法引用<literal>WITH</literal>查询，因为当他应该只影响一个时它可能会影响所有使用<literal>WITH</literal>查询的输出的使用。
   乘法引用<literal>WITH</literal>查询通常将会被按照所写的方式计算，而不抑制父查询以后可能会抛弃的行（但是，如上所述，如果对查询的引用只请求有限数目的行，计算可能会提前停止）。
  </para>
<!-- pgdoc-cn_end sig_en=667914165a1fa523c9116b27f4cf026e -->

<!-- pgdoc-cn_start sig_en=54bb8fec90448cd81a7be68946bad3e4 sig_cn_org=None source=14.1 
  <para>
   However, if a <literal>WITH</literal> query is non-recursive and
   side-effect-free (that is, it is a <literal>SELECT</literal> containing
   no volatile functions) then it can be folded into the parent query,
   allowing joint optimization of the two query levels.  By default, this
   happens if the parent query references the <literal>WITH</literal> query
   just once, but not if it references the <literal>WITH</literal> query
   more than once.  You can override that decision by
   specifying <literal>MATERIALIZED</literal> to force separate calculation
   of the <literal>WITH</literal> query, or by specifying <literal>NOT
   MATERIALIZED</literal> to force it to be merged into the parent query.
   The latter choice risks duplicate computation of
   the <literal>WITH</literal> query, but it can still give a net savings if
   each usage of the <literal>WITH</literal> query needs only a small part
   of the <literal>WITH</literal> query's full output.
  </para>
________________________________________________________-->
  <para>
   但是，如果 <literal>WITH</literal> 查询是非递归和边际效应无关的（就是说，它是一个<literal>SELECT</literal>包含没有可变函数），则它可以合并到父查询中，允许两个查询级别的联合优化。
   默认情况下，这发生在如果父查询仅引用 <literal>WITH</literal>查询一次的时候，而不是它引用<literal>WITH</literal>查询多于一次时。
   你可以超越控制这个决策，通过指定 <literal>MATERIALIZED</literal> 来强制分开计算 <literal>WITH</literal> 查询，或者通过指定 <literal>NOT MATERIALIZED</literal>来强制它被合并到父查询中。
   后一种选择存在重复计算<literal>WITH</literal>查询的风险，但它仍然能提供净节省，如果<literal>WITH</literal>查询的每个使用只需要<literal>WITH</literal>查询的完整输出的一小部分。
  </para>
<!-- pgdoc-cn_end sig_en=54bb8fec90448cd81a7be68946bad3e4 -->

<!-- pgdoc-cn_start sig_en=9bbd0993745dbb01808dd3c083f7de32 sig_cn_org=None source=14.1 
  <para>
   A simple example of these rules is
<programlisting>
WITH w AS (
    SELECT * FROM big_table
)
SELECT * FROM w WHERE key = 123;
</programlisting>
   This <literal>WITH</literal> query will be folded, producing the same
   execution plan as
<programlisting>
SELECT * FROM big_table WHERE key = 123;
</programlisting>
   In particular, if there's an index on <structfield>key</structfield>,
   it will probably be used to fetch just the rows having <literal>key =
   123</literal>.  On the other hand, in
<programlisting>
WITH w AS (
    SELECT * FROM big_table
)
SELECT * FROM w AS w1 JOIN w AS w2 ON w1.key = w2.ref
WHERE w2.key = 123;
</programlisting>
   the <literal>WITH</literal> query will be materialized, producing a
   temporary copy of <structname>big_table</structname> that is then
   joined with itself &mdash; without benefit of any index.  This query
   will be executed much more efficiently if written as
<programlisting>
WITH w AS NOT MATERIALIZED (
    SELECT * FROM big_table
)
SELECT * FROM w AS w1 JOIN w AS w2 ON w1.key = w2.ref
WHERE w2.key = 123;
</programlisting>
   so that the parent query's restrictions can be applied directly
   to scans of <structname>big_table</structname>.
  </para>
________________________________________________________-->
  <para>
   这些规则的一个简单示例是
<programlisting>
WITH w AS (
    SELECT * FROM big_table
)
SELECT * FROM w WHERE key = 123;
</programlisting>
   这个 <literal>WITH</literal> 查询将被合并，生成相同的执行计划为
<programlisting>
SELECT * FROM big_table WHERE key = 123;
</programlisting>
   特别是，如果在<structfield>key</structfield>上有一个索引，它可能只用于获取具有 <literal>key = 123</literal>的行。 另一方面，在
<programlisting>
WITH w AS (
    SELECT * FROM big_table
)
SELECT * FROM w AS w1 JOIN w AS w2 ON w1.key = w2.ref
WHERE w2.key = 123;
</programlisting>
   <literal>WITH</literal>查询将被物化，生成一个<structname>big_table</structname>的临时拷贝，然后与其自身 &mdash; 联合，这样将不能从索引上获得任何好处。
   如果写成下面的形式，这个查询将被执行得更有效率。
<programlisting>
WITH w AS NOT MATERIALIZED (
    SELECT * FROM big_table
)
SELECT * FROM w AS w1 JOIN w AS w2 ON w1.key = w2.ref
WHERE w2.key = 123;
</programlisting>
   所以父查询的限制可以直接应用于<structname>big_table</structname>的扫描。
  </para>
<!-- pgdoc-cn_end sig_en=9bbd0993745dbb01808dd3c083f7de32 -->

<!-- pgdoc-cn_start sig_en=c3faa78ef4452de8e461c58bc93cc89c sig_cn_org=None source=14.1 
  <para>
   An example where <literal>NOT MATERIALIZED</literal> could be
   undesirable is
<programlisting>
WITH w AS (
    SELECT key, very_expensive_function(val) as f FROM some_table
)
SELECT * FROM w AS w1 JOIN w AS w2 ON w1.f = w2.f;
</programlisting>
   Here, materialization of the <literal>WITH</literal> query ensures
   that <function>very_expensive_function</function> is evaluated only
   once per table row, not twice.
  </para>
________________________________________________________-->
  <para>
   一个<literal>NOT MATERIALIZED</literal> 可能不理想的例子为
<programlisting>
WITH w AS (
    SELECT key, very_expensive_function(val) as f FROM some_table
)
SELECT * FROM w AS w1 JOIN w AS w2 ON w1.f = w2.f;
</programlisting>
   在这里，<literal>WITH</literal>查询的物化确保<function>very_expensive_function</function>每个表行只计算一次，而不是两次。
  </para>
<!-- pgdoc-cn_end sig_en=c3faa78ef4452de8e461c58bc93cc89c -->

<!-- pgdoc-cn_start sig_en=d7c78114dbe902ccb8c5be579d7c0877 sig_cn_org=81c7ecd035a994e5e183214beaf54fc3 source=15.7 
  <para>
   The examples above only show <literal>WITH</literal> being used with
   <command>SELECT</command>, but it can be attached in the same way to
   <command>INSERT</command>, <command>UPDATE</command>,
   <command>DELETE</command>, or <command>MERGE</command>.
   In each case it effectively provides temporary table(s) that can
   be referred to in the main command.
  </para>
________________________________________________________-->
  <para>
   上面的示例仅显示了<literal>WITH</literal>与<command>SELECT</command>一起使用，
   但它可以以相同的方式附加到<command>INSERT</command>、<command>UPDATE</command>、
   <command>DELETE</command>或<command>MERGE</command>。
   在每种情况下，它有效地提供了可以在主命令中引用的临时表。
</para>
<!-- pgdoc-cn_end sig_en=d7c78114dbe902ccb8c5be579d7c0877 -->
 </sect2>

 <sect2 id="queries-with-modifying">
<!-- pgdoc-cn_start sig_en=b0224b5ef471c6841582275bc16c0eb8 sig_cn_org=None source=14.1 
   <title>Data-Modifying Statements in <literal>WITH</literal></title>
________________________________________________________-->
   <title><literal>WITH</literal>中的数据修改语句</title>
<!-- pgdoc-cn_end sig_en=b0224b5ef471c6841582275bc16c0eb8 -->

<!-- pgdoc-cn_start sig_en=3f63561ca5fe335b17e30b1a22dba8e7 sig_cn_org=8a52893a8950930afc26991d89d51628 source=15.7 
   <para>
    You can use most data-modifying statements (<command>INSERT</command>,
    <command>UPDATE</command>, or <command>DELETE</command>, but not
    <command>MERGE</command>) in <literal>WITH</literal>.  This
    allows you to perform several different operations in the same query.
    An example is:

<programlisting>
WITH moved_rows AS (
    DELETE FROM products
    WHERE
        "date" &gt;= '2010-10-01' AND
        "date" &lt; '2010-11-01'
    RETURNING *
)
INSERT INTO products_log
SELECT * FROM moved_rows;
</programlisting>

    This query effectively moves rows from <structname>products</structname> to
    <structname>products_log</structname>.  The <command>DELETE</command> in <literal>WITH</literal>
    deletes the specified rows from <structname>products</structname>, returning their
    contents by means of its <literal>RETURNING</literal> clause; and then the
    primary query reads that output and inserts it into
    <structname>products_log</structname>.
   </para>
________________________________________________________-->
   <para>
    您可以在<literal>WITH</literal>中使用大多数数据修改语句（<command>INSERT</command>、
    <command>UPDATE</command>或<command>DELETE</command>，但不能使用
    <command>MERGE</command>）。这样可以在同一查询中执行多个不同的操作。
    例如：

<programlisting>
WITH moved_rows AS (
    DELETE FROM products
    WHERE
        "date" &gt;= '2010-10-01' AND
        "date" &lt; '2010-11-01'
    RETURNING *
)
INSERT INTO products_log
SELECT * FROM moved_rows;
</programlisting>

    这个查询有效地将行从<structname>products</structname>移动到
    <structname>products_log</structname>。在<literal>WITH</literal>中的<command>DELETE</command>
    从<structname>products</structname>中删除指定的行，通过其<literal>RETURNING</literal>子句返回它们的
    内容；然后主查询读取该输出并将其插入到
    <structname>products_log</structname>中。
   </para>
<!-- pgdoc-cn_end sig_en=3f63561ca5fe335b17e30b1a22dba8e7 -->

<!-- pgdoc-cn_start sig_en=49a6abf855c5a4263a0d9883a774d907 sig_cn_org=None source=14.1 
   <para>
    A fine point of the above example is that the <literal>WITH</literal> clause is
    attached to the <command>INSERT</command>, not the sub-<command>SELECT</command> within
    the <command>INSERT</command>.  This is necessary because data-modifying
    statements are only allowed in <literal>WITH</literal> clauses that are attached
    to the top-level statement.  However, normal <literal>WITH</literal> visibility
    rules apply, so it is possible to refer to the <literal>WITH</literal>
    statement's output from the sub-<command>SELECT</command>.
   </para>
________________________________________________________-->
   <para>
    上述例子中好的一点是<literal>WITH</literal>子句被附加给<command>INSERT</command>，而没有附加给<command>INSERT</command>的子<command>SELECT</command>。这是必需的，因为<literal>WITH</literal>中的数据修改语句只能附加到顶层语句。不过，普通<literal>WITH</literal>的可见性规则仍适用，这样才可能从子<command>SELECT</command>中引用<literal>WITH</literal>语句的输出。
   </para>
<!-- pgdoc-cn_end sig_en=49a6abf855c5a4263a0d9883a774d907 -->

<!-- pgdoc-cn_start sig_en=961e34e3230002f05dec0d544bb779b6 sig_cn_org=None source=14.1 
   <para>
    Data-modifying statements in <literal>WITH</literal> usually have
    <literal>RETURNING</literal> clauses (see <xref linkend="dml-returning"/>),
    as shown in the example above.
    It is the output of the <literal>RETURNING</literal> clause, <emphasis>not</emphasis> the
    target table of the data-modifying statement, that forms the temporary
    table that can be referred to by the rest of the query.  If a
    data-modifying statement in <literal>WITH</literal> lacks a <literal>RETURNING</literal>
    clause, then it forms no temporary table and cannot be referred to in
    the rest of the query.  Such a statement will be executed nonetheless.
    A not-particularly-useful example is:

<programlisting>
WITH t AS (
    DELETE FROM foo
)
DELETE FROM bar;
</programlisting>

    This example would remove all rows from tables <structname>foo</structname> and
    <structname>bar</structname>.  The number of affected rows reported to the client
    would only include rows removed from <structname>bar</structname>.
   </para>
________________________________________________________-->
   <para>
    正如上述例子所示，<literal>WITH</literal>中的数据修改语句通常具有<literal>RETURNING</literal>子句（见<xref linkend="dml-returning"/>）。它是<literal>RETURNING</literal>子句的输出，<emphasis>不是</emphasis>数据修改语句的目标表，它形成了其他查询可以引用的临时表。如果一个<literal>WITH</literal>中的数据修改语句缺少一个<literal>RETURNING</literal>子句，则它不会形成临时表并且不能被其他查询引用。尽管如此，这样一个语句仍将被执行。一个不是特别有用的例子：

<programlisting>
WITH t AS (
    DELETE FROM foo
)
DELETE FROM bar;
</programlisting>

    这个例子将从表<structname>foo</structname>和<structname>bar</structname>中移除所有行。被报告给客户端的受影响行的数目可能只包括从<structname>bar</structname>中移除的行。
   </para>
<!-- pgdoc-cn_end sig_en=961e34e3230002f05dec0d544bb779b6 -->

<!-- pgdoc-cn_start sig_en=2949744db7b9cf92ce4ebeec951e5bc5 sig_cn_org=None source=14.1 
   <para>
    Recursive self-references in data-modifying statements are not
    allowed.  In some cases it is possible to work around this limitation by
    referring to the output of a recursive <literal>WITH</literal>, for example:

<programlisting>
WITH RECURSIVE included_parts(sub_part, part) AS (
    SELECT sub_part, part FROM parts WHERE part = 'our_product'
  UNION ALL
    SELECT p.sub_part, p.part
    FROM included_parts pr, parts p
    WHERE p.part = pr.sub_part
)
DELETE FROM parts
  WHERE part IN (SELECT part FROM included_parts);
</programlisting>

    This query would remove all direct and indirect subparts of a product.
   </para>
________________________________________________________-->
   <para>
    数据修改语句中不允许递归自引用。在某些情况中可以采取引用一个递归<literal>WITH</literal>的输出来解除这个限制，例如：

<programlisting>
WITH RECURSIVE included_parts(sub_part, part) AS (
    SELECT sub_part, part FROM parts WHERE part = 'our_product'
  UNION ALL
    SELECT p.sub_part, p.part
    FROM included_parts pr, parts p
    WHERE p.part = pr.sub_part
)
DELETE FROM parts
  WHERE part IN (SELECT part FROM included_parts);
</programlisting>

    这个查询将会移除一个产品的所有直接或间接子部件。
   </para>
<!-- pgdoc-cn_end sig_en=2949744db7b9cf92ce4ebeec951e5bc5 -->

<!-- pgdoc-cn_start sig_en=44953759e472fb4eed230d3cba0d692e sig_cn_org=None source=14.1 
   <para>
    Data-modifying statements in <literal>WITH</literal> are executed exactly once,
    and always to completion, independently of whether the primary query
    reads all (or indeed any) of their output.  Notice that this is different
    from the rule for <command>SELECT</command> in <literal>WITH</literal>: as stated in the
    previous section, execution of a <command>SELECT</command> is carried only as far
    as the primary query demands its output.
   </para>
________________________________________________________-->
   <para>
    <literal>WITH</literal>中的数据修改语句只被执行一次，并且总是能结束，而不管主查询是否读取它们所有（或者任何）的输出。注意这和<literal>WITH</literal>中<command>SELECT</command>的规则不同：正如前一小节所述，直到主查询要求<command>SELECT</command>的输出时，<command>SELECT</command>才会被执行。
   </para>
<!-- pgdoc-cn_end sig_en=44953759e472fb4eed230d3cba0d692e -->

<!-- pgdoc-cn_start sig_en=880be35fd5645a6013feb759ed5b1f8a sig_cn_org=None source=14.1 
   <para>
    The sub-statements in <literal>WITH</literal> are executed concurrently with
    each other and with the main query.  Therefore, when using data-modifying
    statements in <literal>WITH</literal>, the order in which the specified updates
    actually happen is unpredictable.  All the statements are executed with
    the same <firstterm>snapshot</firstterm> (see <xref linkend="mvcc"/>), so they
    cannot <quote>see</quote> one another's effects on the target tables.  This
    alleviates the effects of the unpredictability of the actual order of row
    updates, and means that <literal>RETURNING</literal> data is the only way to
    communicate changes between different <literal>WITH</literal> sub-statements and
    the main query.  An example of this is that in

<programlisting>
WITH t AS (
    UPDATE products SET price = price * 1.05
    RETURNING *
)
SELECT * FROM products;
</programlisting>

    the outer <command>SELECT</command> would return the original prices before the
    action of the <command>UPDATE</command>, while in

<programlisting>
WITH t AS (
    UPDATE products SET price = price * 1.05
    RETURNING *
)
SELECT * FROM t;
</programlisting>

    the outer <command>SELECT</command> would return the updated data.
   </para>
________________________________________________________-->
   <para>
    <literal>WITH</literal>中的子语句和其他子语句以及主查询被并发执行。因此在使用<literal>WITH</literal>中的数据修改语句时，无法预知实际更新顺序。所有的语句都使用同一个<firstterm>snapshot</firstterm>执行（参见<xref linkend="mvcc"/>），因此它们不能<quote>看见</quote>目标表上另一个执行的效果。这减轻了行更新的实际顺序的不可预见性的影响，并且意味着<literal>RETURNING</literal>数据是在不同<literal>WITH</literal>子语句和主查询之间传达改变的唯一方法。其例子

<programlisting>
WITH t AS (
    UPDATE products SET price = price * 1.05
    RETURNING *
)
SELECT * FROM products;
</programlisting>

    外层<command>SELECT</command>可以返回在<command>UPDATE</command>动作之前的原始价格，而在

<programlisting>
WITH t AS (
    UPDATE products SET price = price * 1.05
    RETURNING *
)
SELECT * FROM t;
</programlisting>

    外部<command>SELECT</command>将返回更新过的数据。
   </para>
<!-- pgdoc-cn_end sig_en=880be35fd5645a6013feb759ed5b1f8a -->

<!-- pgdoc-cn_start sig_en=18e898a5490bf61efa2a10bcc57b929c sig_cn_org=None source=14.1 
   <para>
    Trying to update the same row twice in a single statement is not
    supported.  Only one of the modifications takes place, but it is not easy
    (and sometimes not possible) to reliably predict which one.  This also
    applies to deleting a row that was already updated in the same statement:
    only the update is performed.  Therefore you should generally avoid trying
    to modify a single row twice in a single statement.  In particular avoid
    writing <literal>WITH</literal> sub-statements that could affect the same rows
    changed by the main statement or a sibling sub-statement.  The effects
    of such a statement will not be predictable.
   </para>
________________________________________________________-->
   <para>
    在一个语句中试图两次更新同一行是不被支持的。只会发生一次修改，但是该办法不能很容易地（有时是不可能）可靠预测哪一个会被执行。这也应用于删除一个已经在同一个语句中被更新过的行：只有更新被执行。因此你通常应该避免尝试在一个语句中两次修改同一行。尤其是避免编写可以作用于被主语句或兄弟子语句修改行的WITH子语句。这样一个语句的效果将是不可预测的。
   </para>
<!-- pgdoc-cn_end sig_en=18e898a5490bf61efa2a10bcc57b929c -->

<!-- pgdoc-cn_start sig_en=201581a3af5425fd7801c4480888dda0 sig_cn_org=None source=14.1 
   <para>
    At present, any table used as the target of a data-modifying statement in
    <literal>WITH</literal> must not have a conditional rule, nor an <literal>ALSO</literal>
    rule, nor an <literal>INSTEAD</literal> rule that expands to multiple statements.
   </para>
________________________________________________________-->
   <para>
    当前，用作<literal>WITH</literal>中数据修改语句目标的任何表不能有条件规则、<literal>ALSO</literal>规则或扩展到多个语句的<literal>INSTEAD</literal>规则。
   </para>
<!-- pgdoc-cn_end sig_en=201581a3af5425fd7801c4480888dda0 -->

  </sect2>

 </sect1>

</chapter>
