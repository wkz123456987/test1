<!-- doc/src/sgml/plperl.sgml -->

 <chapter id="plperl">
<!-- pgdoc-cn_start sig_en=7b4ecd7e0002038755958ad12d78a431 sig_cn_org=None source=14.1 
  <title>PL/Perl &mdash; Perl Procedural Language</title>
________________________________________________________-->
  <title>PL/Perl &mdash; Perl 过程语言</title>
<!-- pgdoc-cn_end sig_en=7b4ecd7e0002038755958ad12d78a431 -->

<!-- pgdoc-cn_start sig_en=b24099df5ac96d5e36745ffaf97e4b0e sig_cn_org=None source=14.1 
  <indexterm zone="plperl">
   <primary>PL/Perl</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="plperl">
   <primary>PL/Perl</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=b24099df5ac96d5e36745ffaf97e4b0e -->

<!-- pgdoc-cn_start sig_en=5f07680a0722db6984e3595052a18692 sig_cn_org=None source=14.1 
  <indexterm zone="plperl">
   <primary>Perl</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="plperl">
   <primary>Perl</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=5f07680a0722db6984e3595052a18692 -->

<!-- pgdoc-cn_start sig_en=ba725970f12b9968e6dff8b81aa2c5e1 sig_cn_org=None source=14.1 
  <para>
   PL/Perl is a loadable procedural language that enables you to write
   <productname>PostgreSQL</productname> functions and procedures in the
   <ulink url="https://www.perl.org">Perl programming language</ulink>.
  </para>
________________________________________________________-->
  <para>
   PL/Perl 是一种可载入过程语言，它允许我们用
   <ulink url="https://www.perl.org">Perl 编程语言</ulink>编写
   <productname>PostgreSQL</productname>函数和存储过程。
  </para>
<!-- pgdoc-cn_end sig_en=ba725970f12b9968e6dff8b81aa2c5e1 -->

<!-- pgdoc-cn_start sig_en=c83d7415910605074a8b34342a548c18 sig_cn_org=None source=14.1 
  <para>
   The main advantage to using PL/Perl is that this allows use,
   within stored functions and procedures, of the manyfold <quote>string
   munging</quote> operators and functions available for Perl.  Parsing
   complex strings might be easier using Perl than it is with the
   string functions and control structures provided in PL/pgSQL.
  </para>
________________________________________________________-->
  <para>
   使用 PL/Perl 的主要优势它允许在存储函数和存储过程中使用大量 Perl 的
   <quote>串整理</quote>操作符和函数。使用 Perl 解析复杂
   串比使用 PL/pgSQL 中提供的串函数和控制结构要更容易。
  </para>
<!-- pgdoc-cn_end sig_en=c83d7415910605074a8b34342a548c18 -->

<!-- pgdoc-cn_start sig_en=601db55811678f621cf3b1ee706d40f0 sig_cn_org=None source=14.1 
  <para>
   To install PL/Perl in a particular database, use
   <literal>CREATE EXTENSION plperl</literal>.
  </para>
________________________________________________________-->
  <para>
   要在一个特定数据库中安装 PL/Perl，使用
   <literal>CREATE EXTENSION plperl</literal>。
  </para>
<!-- pgdoc-cn_end sig_en=601db55811678f621cf3b1ee706d40f0 -->

  <tip>
<!-- pgdoc-cn_start sig_en=baccbbc8addfed07dd896e5e2dd7a4bb sig_cn_org=None source=14.1 
   <para>
    If a language is installed into <literal>template1</literal>, all subsequently
    created databases will have the language installed automatically.
   </para>
________________________________________________________-->
   <para>
    如果把语言安装在<literal>template1</literal>中，所有后续创建的数据库
    都将自动地安装有该语言。
   </para>
<!-- pgdoc-cn_end sig_en=baccbbc8addfed07dd896e5e2dd7a4bb -->
  </tip>

  <note>
<!-- pgdoc-cn_start sig_en=85e7cb685fd6df059f50bc194b2f7d3c sig_cn_org=None source=14.1 
   <para>
    Users of source packages must specially enable the build of
    PL/Perl during the installation process.  (Refer to <xref
    linkend="installation"/> for more information.)  Users of
    binary packages might find PL/Perl in a separate subpackage.
   </para>
________________________________________________________-->
   <para>
    使用源码包安装的用户必须在安装过程中开启对 PL/Perl 的编译（
    更多信息请参考<xref linkend="installation"/>）。使用二进制包
    安装的用户可能会在独立的子包中找到 PL/Perl。
   </para>
<!-- pgdoc-cn_end sig_en=85e7cb685fd6df059f50bc194b2f7d3c -->
  </note>

 <sect1 id="plperl-funcs">
<!-- pgdoc-cn_start sig_en=fc8f20f451eaa384ae9c3813fcf8dbb2 sig_cn_org=None source=14.1 
  <title>PL/Perl Functions and Arguments</title>
________________________________________________________-->
  <title>PL/Perl 函数和参数</title>
<!-- pgdoc-cn_end sig_en=fc8f20f451eaa384ae9c3813fcf8dbb2 -->

<!-- pgdoc-cn_start sig_en=36e5c7d6e22e0926a253ee2146b0de19 sig_cn_org=None source=14.1 
  <para>
   To create a function in the PL/Perl language, use the standard
   <xref linkend="sql-createfunction"/>
   syntax:

<programlisting>
CREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-types</replaceable>)
RETURNS <replaceable>return-type</replaceable>
-&minus; function attributes can go here
AS $$
    # PL/Perl function body goes here
$$ LANGUAGE plperl;
</programlisting>

   The body of the function is ordinary Perl code. In fact, the PL/Perl
   glue code wraps it inside a Perl subroutine.  A PL/Perl function is
   called in a scalar context, so it can't return a list.  You can return
   non-scalar values (arrays, records, and sets) by returning a reference,
   as discussed below.
  </para>
________________________________________________________-->
  <para>
   要用 PL/Perl 语言创建一个函数，可使用标准的
   <xref linkend="sql-createfunction"/>语法：

<programlisting>
CREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-types</replaceable>)
RETURNS <replaceable>return-type</replaceable>
-- function attributes can go here
AS $$
    # PL/Perl function body goes here
$$ LANGUAGE plperl;
</programlisting>

   函数的主体就是普通的 Perl 代码。事实上，PL/Perl 的粘合代码会把它
   包裹在一个 Perl 子程序中。一个 PL/Perl 函数会在一种标量上下文中
   被调用，因此它无法返回列表。如下文所述，可以通过返回引用来返回
   非标量值（数组、记录和集合）。
  </para>
<!-- pgdoc-cn_end sig_en=36e5c7d6e22e0926a253ee2146b0de19 -->

<!-- pgdoc-cn_start sig_en=2a0d81f496b2d88ca260d2292d0c193f sig_cn_org=None source=14.1 
  <para>
   In a PL/Perl procedure, any return value from the Perl code is ignored.
  </para>
________________________________________________________-->
  <para>
   在一个PL/Perl过程中，任何从Perl代码返回的值都会被忽略。
  </para>
<!-- pgdoc-cn_end sig_en=2a0d81f496b2d88ca260d2292d0c193f -->

<!-- pgdoc-cn_start sig_en=287c9a9931d272d80f230a7713fea187 sig_cn_org=None source=14.1 
  <para>
   PL/Perl also supports anonymous code blocks called with the
   <xref linkend="sql-do"/> statement:

<programlisting>
DO $$
    # PL/Perl code
$$ LANGUAGE plperl;
</programlisting>

   An anonymous code block receives no arguments, and whatever value it
   might return is discarded.  Otherwise it behaves just like a function.
  </para>
________________________________________________________-->
  <para>
   PL/Perl 也支持用<xref linkend="sql-do"/>语句调用的匿名代码块：

<programlisting>
DO $$
    # PL/Perl 代码
$$ LANGUAGE plperl;
</programlisting>

   一个匿名代码块没有参数，并且它返回的任何值都会被抛弃。否则
   其行为就像一个函数。
  </para>
<!-- pgdoc-cn_end sig_en=287c9a9931d272d80f230a7713fea187 -->

  <note>
<!-- pgdoc-cn_start sig_en=01902cf6071a2e1b31728c7e4dddaf0e sig_cn_org=None source=14.1 
   <para>
    The use of named nested subroutines is dangerous in Perl, especially if
    they refer to lexical variables in the enclosing scope. Because a PL/Perl
    function is wrapped in a subroutine, any named subroutine you place inside
    one will be nested. In general, it is far safer to create anonymous
    subroutines which you call via a coderef. For more information, see the
    entries for <literal>Variable "%s" will not stay shared</literal> and
    <literal>Variable "%s" is not available</literal> in the
    <citerefentry><refentrytitle>perldiag</refentrytitle></citerefentry> man page, or
    search the Internet for <quote>perl nested named subroutine</quote>.
   </para>
________________________________________________________-->
   <para>
    在 Perl 中使用命名嵌套子程序是有危险的，特别是当它们在作用域内
    引用局部变量时。因为 PL/Perl 函数被包装成一个子程序，任何放在
    其中的命名子程序都会被嵌套。总之，创建通过 coderef 调用的匿名
    子程序要安全得多。更多信息可见
    <citerefentry><refentrytitle>perldiag</refentrytitle></citerefentry>手册页
    中的<literal>Variable "%s" will not stay shared</literal>以及
    <literal>Variable "%s" is not available</literal>，或者在互联网上
    搜索<quote>perl nested named subroutine</quote>。
   </para>
<!-- pgdoc-cn_end sig_en=01902cf6071a2e1b31728c7e4dddaf0e -->
  </note>

<!-- pgdoc-cn_start sig_en=b88efd039aa878f18b39feb60e2b58af sig_cn_org=None source=14.1 
  <para>
   The syntax of the <command>CREATE FUNCTION</command> command requires
   the function body to be written as a string constant.  It is usually
   most convenient to use dollar quoting (see <xref
   linkend="sql-syntax-dollar-quoting"/>) for the string constant.
   If you choose to use escape string syntax <literal>E''</literal>,
   you must double any single quote marks (<literal>'</literal>) and backslashes
   (<literal>\</literal>) used in the body of the function
   (see <xref linkend="sql-syntax-strings"/>).
  </para>
________________________________________________________-->
  <para>
   <command>CREATE FUNCTION</command>命令的语法要求函数
   体被写作一个字符串常量。通常对字符串常量使用美元引用（见
   <xref linkend="sql-syntax-dollar-quoting"/>）最方便。如果选择使用
   转义字符串语法<literal>E''</literal>，必须双写任何在函数体中使用的单引号
   （<literal>'</literal>）和反斜线（<literal>\</literal>）（见
   <xref linkend="sql-syntax-strings"/>）。
  </para>
<!-- pgdoc-cn_end sig_en=b88efd039aa878f18b39feb60e2b58af -->

<!-- pgdoc-cn_start sig_en=a1be1462d81d4a46a2cfe0393a501563 sig_cn_org=None source=14.1 
  <para>
   Arguments and results are handled as in any other Perl subroutine:
   arguments are passed in <varname>@_</varname>, and a result value
   is returned with <literal>return</literal> or as the last expression
   evaluated in the function.
  </para>
________________________________________________________-->
  <para>
   参数和结果的处理和在任何其他 Perl 子程序中一样：参数被传递到
   <varname>@_</varname>中，并且结果值用<literal>return</literal>
   返回或者把函数中计算的最后一个表达式作为结果值。
  </para>
<!-- pgdoc-cn_end sig_en=a1be1462d81d4a46a2cfe0393a501563 -->

<!-- pgdoc-cn_start sig_en=b8dbcd55bc833989868f81d0bb9062c5 sig_cn_org=None source=14.1 
  <para>
   For example, a function returning the greater of two integer values
   could be defined as:

<programlisting>
CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$
    if ($_[0] &gt; $_[1]) { return $_[0]; }
    return $_[1];
$$ LANGUAGE plperl;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   例如，一个返回两个整数值中较大值的函数可以定义为：

<programlisting>
CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$
    if ($_[0] &gt; $_[1]) { return $_[0]; }
    return $_[1];
$$ LANGUAGE plperl;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=b8dbcd55bc833989868f81d0bb9062c5 -->

  <note>
<!-- pgdoc-cn_start sig_en=be918fbfe2ea104ab41d0a3f058f1478 sig_cn_org=None source=14.1 
    <para>
      Arguments will be converted from the database's encoding to UTF-8
      for use inside PL/Perl, and then converted from UTF-8 back to the
      database encoding upon return.
    </para>
________________________________________________________-->
    <para>
      参数将被从数据库的编码转换到 PL/Perl 中使用的 UTF-8，返回时再从
      UTF-8 转回到数据库编码。
    </para>
<!-- pgdoc-cn_end sig_en=be918fbfe2ea104ab41d0a3f058f1478 -->
  </note>

<!-- pgdoc-cn_start sig_en=0259b96b884b4b25a215055d88ed7f0a sig_cn_org=None source=14.1 
  <para>
   If an SQL null value<indexterm><primary>null value</primary><secondary
   sortas="PL/Perl">in PL/Perl</secondary></indexterm> is passed to a function,
   the argument value will appear as <quote>undefined</quote> in Perl.  The
   above function definition will not behave very nicely with null
   inputs (in fact, it will act as though they are zeroes).  We could
   add <literal>STRICT</literal> to the function definition to make
   <productname>PostgreSQL</productname> do something more reasonable:
   if a null value is passed, the function will not be called at all,
   but will just return a null result automatically.  Alternatively,
   we could check for undefined inputs in the function body.  For
   example, suppose that we wanted <function>perl_max</function> with
   one null and one nonnull argument to return the nonnull argument,
   rather than a null value:

<programlisting>
CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$
    my ($x, $y) = @_;
    if (not defined $x) {
        return undef if not defined $y;
        return $y;
    }
    return $x if not defined $y;
    return $x if $x &gt; $y;
    return $y;
$$ LANGUAGE plperl;
</programlisting>
   As shown above, to return an SQL null value from a PL/Perl
   function, return an undefined value.  This can be done whether the
   function is strict or not.
  </para>
________________________________________________________-->
  <para>
   如果一个 SQL 空值<indexterm><primary>空值</primary><secondary
   sortas="PL/Perl">in PL/Perl</secondary></indexterm>被传给一个函数，在
   Perl 中该参数值将呈现为<quote>undefined</quote>。上述函数定义对于
   空输入的行为不太好（实际上，它会把它们当作零）。我们可以为函数
   定义增加<literal>STRICT</literal>让<productname>PostgreSQL</productname>
   干得更合理：如果空值被传入，函数将根本不会被调用，而只是自动
   返回一个空结果。另外一种方式，我们可以在函数体中检查未定义的
   输入。例如，假设我们想让带有一个空参数或者一个非空参数的
   <function>perl_max</function>返回非空参数而不是空值：

<programlisting>
CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$
    my ($x, $y) = @_;
    if (not defined $x) {
        return undef if not defined $y;
        return $y;
    }
    return $x if not defined $y;
    return $x if $x &gt; $y;
    return $y;
$$ LANGUAGE plperl;
</programlisting>
   如上所述，要从一个 PL/Perl 函数返回一个 SQL 空值，就返回一个未定义值。
   不管函数是严格的还是非严格的都可以这样做。
  </para>
<!-- pgdoc-cn_end sig_en=0259b96b884b4b25a215055d88ed7f0a -->

<!-- pgdoc-cn_start sig_en=daed98569e45994ccff18d1608ad0555 sig_cn_org=None source=14.1 
  <para>
   Anything in a function argument that is not a reference is
   a string, which is in the standard <productname>PostgreSQL</productname>
   external text representation for the relevant data type. In the case of
   ordinary numeric or text types, Perl will just do the right thing and
   the programmer will normally not have to worry about it. However, in
   other cases the argument will need to be converted into a form that is
   more usable in Perl. For example, the <function>decode_bytea</function>
   function can be used to convert an argument of
   type <type>bytea</type> into unescaped binary.
  </para>
________________________________________________________-->
  <para>
   一个非引用的函数参数中的任何东西都是一个串，是相关数据类型的标准
   <productname>PostgreSQL</productname>外部文本表达。在普通
   数字或文本类型的情况下，Perl 将会做正确的事情并且程序员通常不需要
   操心。不过，在其他情况下将需要被转换成在 Perl 中更可用的形式。例如，
   <function>decode_bytea</function>函数可以被用来把类型
   <type>bytea</type>的参数转换成未转义的二进制形式。
  </para>
<!-- pgdoc-cn_end sig_en=daed98569e45994ccff18d1608ad0555 -->

<!-- pgdoc-cn_start sig_en=c543d7c3f77b3f55ba8b59e377479f75 sig_cn_org=None source=14.1 
  <para>
   Similarly, values passed back to <productname>PostgreSQL</productname>
   must be in the external text representation format. For example, the
   <function>encode_bytea</function> function can be used to
   escape binary data for a return value of type <type>bytea</type>.
  </para>
________________________________________________________-->
  <para>
   类似地，回传给<productname>PostgreSQL</productname>的值必须
   是外部文本表达格式。例如，<function>encode_bytea</function>
   函数可以被用来转义二进制数据得到类型<type>bytea</type>的返回值。
  </para>
<!-- pgdoc-cn_end sig_en=c543d7c3f77b3f55ba8b59e377479f75 -->

<!-- pgdoc-cn_start sig_en=08241518752f29f3e4543242a9bc9142 sig_cn_org=None source=14.1 
  <para>
   One case that is particularly important is boolean values.  As just
   stated, the default behavior for <type>bool</type> values is that they
   are passed to Perl as text, thus either <literal>'t'</literal>
   or <literal>'f'</literal>.  This is problematic, since Perl will not
   treat <literal>'f'</literal> as false!  It is possible to improve matters
   by using a <quote>transform</quote> (see
   <xref linkend="sql-createtransform"/>).  Suitable transforms are provided
   by the <filename>bool_plperl</filename> extension.  To use it, install
   the extension:
<programlisting>
CREATE EXTENSION bool_plperl;  -&minus; or bool_plperlu for PL/PerlU
</programlisting>
   Then use the <literal>TRANSFORM</literal> function attribute for a
   PL/Perl function that takes or returns <type>bool</type>, for example:
<programlisting>
CREATE FUNCTION perl_and(bool, bool) RETURNS bool
TRANSFORM FOR TYPE bool
AS $$
  my ($a, $b) = @_;
  return $a &amp;&amp; $b;
$$ LANGUAGE plperl;
</programlisting>
   When this transform is applied, <type>bool</type> arguments will be seen
   by Perl as being <literal>1</literal> or empty, thus properly true or
   false.  If the function result is type <type>bool</type>, it will be true
   or false according to whether Perl would evaluate the returned value as
   true.
   Similar transformations are also performed for boolean query arguments
   and results of SPI queries performed inside the function
   (<xref linkend="plperl-database"/>).
  </para>
________________________________________________________-->
  <para>
   一种特别重要的情况是布尔值。如前所述，<type>bool</type>值的默认行为是它们作为文本传递给 Perl，
   因此要么<literal>'t'</literal>要么<literal>'f'</literal>。
   这是有问题的，因为 Perl 不会将<literal>'f'</literal>视为假！
   可以通过使用<quote>transform</quote>来改善问题（参见<xref linkend="sql-createtransform"/>）。
   <filename>bool_plperl</filename>扩展提供了合适的转换。要使用它，请安装扩展：
<programlisting>
CREATE EXTENSION bool_plperl;  -- or bool_plperlu for PL/PerlU
</programlisting>
   然后将<literal>TRANSFORM</literal>函数属性用于接受或返回<type>bool</type>的 PL/Perl 函数，例如：
<programlisting>
CREATE FUNCTION perl_and(bool, bool) RETURNS bool
TRANSFORM FOR TYPE bool
AS $$
  my ($a, $b) = @_;
  return $a &amp;&amp; $b;
$$ LANGUAGE plperl;
</programlisting>
   当应用这个转换时，<type>bool</type>参数将被 Perl 视为<literal>1</literal>或空，因此正确或错误。
   如果函数结果是<type>bool</type>类型，它会根据 Perl 是否将返回值评估为真来判断为真或假。
   函数内部执行的 SPI 查询的布尔查询参数和结果也执行类似的转换(<xref linkend="plperl-database"/>)。
  </para>
<!-- pgdoc-cn_end sig_en=08241518752f29f3e4543242a9bc9142 -->

<!-- pgdoc-cn_start sig_en=bcd795b25acb8410aac311100ba51615 sig_cn_org=None source=14.1 
  <para>
   Perl can return <productname>PostgreSQL</productname> arrays as
   references to Perl arrays.  Here is an example:

<programlisting>
CREATE OR REPLACE function returns_array()
RETURNS text[][] AS $$
    return [['a&quot;b','c,d'],['e\\f','g']];
$$ LANGUAGE plperl;

select returns_array();
</programlisting>
  </para>
________________________________________________________-->
  <para>
   Perl 可以把<productname>PostgreSQL</productname>数组返回为对
   Perl 数组的引用。这里有一个例子：

<programlisting>
CREATE OR REPLACE function returns_array()
RETURNS text[][] AS $$
    return [['a&quot;b','c,d'],['e\\f','g']];
$$ LANGUAGE plperl;

select returns_array();
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=bcd795b25acb8410aac311100ba51615 -->

<!-- pgdoc-cn_start sig_en=415602a13ce78b14559d7e03d7ad428f sig_cn_org=None source=14.1 
  <para>
   Perl passes <productname>PostgreSQL</productname> arrays as a blessed
   <type>PostgreSQL::InServer::ARRAY</type> object. This object may be treated as an array
   reference or a string, allowing for backward compatibility with Perl
   code written for <productname>PostgreSQL</productname> versions below 9.1 to
   run.  For example:

<programlisting>
CREATE OR REPLACE FUNCTION concat_array_elements(text[]) RETURNS TEXT AS $$
    my $arg = shift;
    my $result = "";
    return undef if (!defined $arg);

    # as an array reference
    for (@$arg) {
        $result .= $_;
    }

    # also works as a string
    $result .= $arg;

    return $result;
$$ LANGUAGE plperl;

SELECT concat_array_elements(ARRAY['PL','/','Perl']);
</programlisting>

  <note>
   <para>
    Multidimensional arrays are represented as references to
    lower-dimensional arrays of references in a way common to every Perl
    programmer.
   </para>
  </note>
  </para>
________________________________________________________-->
  <para>
   Perl 把<productname>PostgreSQL</productname>数组作为被 bless 过的
   <type>PostgreSQL::InServer::ARRAY</type>对象传递。这个对象可以被当作
   一个数组引用或者一个串，允许为了向后兼容性与为 9.1 以下版本的
   <productname>PostgreSQL</productname>编写的 Perl 代码一起运行。
   例如：

<programlisting>
CREATE OR REPLACE FUNCTION concat_array_elements(text[]) RETURNS TEXT AS $$
    my $arg = shift;
    my $result = "";
    return undef if (!defined $arg);

    # as an array reference
    for (@$arg) {
        $result .= $_;
    }

    # also works as a string
    $result .= $arg;

    return $result;
$$ LANGUAGE plperl;

SELECT concat_array_elements(ARRAY['PL','/','Perl']);
</programlisting>

  <note>
   <para>
    多维数组被以一种对每一个 Perl 程序员都公认的方法表示为对较低维引用数组
    的引用。
   </para>
  </note>
  </para>
<!-- pgdoc-cn_end sig_en=415602a13ce78b14559d7e03d7ad428f -->

<!-- pgdoc-cn_start sig_en=0c488079569f0507d08ef62f647c1e51 sig_cn_org=None source=14.1 
  <para>
   Composite-type arguments are passed to the function as references
   to hashes.  The keys of the hash are the attribute names of the
   composite type.  Here is an example:

<programlisting>
CREATE TABLE employee (
    name text,
    basesalary integer,
    bonus integer
);

CREATE FUNCTION empcomp(employee) RETURNS integer AS $$
    my ($emp) = @_;
    return $emp-&gt;{basesalary} + $emp-&gt;{bonus};
$$ LANGUAGE plperl;

SELECT name, empcomp(employee.*) FROM employee;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   组合类型参数被作为哈希的引用传递给函数。哈希的键是组合类型的
   属性名。这里是一个例子：

<programlisting>
CREATE TABLE employee (
    name text,
    basesalary integer,
    bonus integer
);

CREATE FUNCTION empcomp(employee) RETURNS integer AS $$
    my ($emp) = @_;
    return $emp-&gt;{basesalary} + $emp-&gt;{bonus};
$$ LANGUAGE plperl;

SELECT name, empcomp(employee.*) FROM employee;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=0c488079569f0507d08ef62f647c1e51 -->

<!-- pgdoc-cn_start sig_en=a2d8f02ab28b428df76608382603335e sig_cn_org=None source=14.1 
  <para>
   A PL/Perl function can return a composite-type result using the same
   approach: return a reference to a hash that has the required attributes.
   For example:

<programlisting>
CREATE TYPE testrowperl AS (f1 integer, f2 text, f3 text);

CREATE OR REPLACE FUNCTION perl_row() RETURNS testrowperl AS $$
    return {f2 =&gt; 'hello', f1 =&gt; 1, f3 =&gt; 'world'};
$$ LANGUAGE plperl;

SELECT * FROM perl_row();
</programlisting>

   Any columns in the declared result data type that are not present in the
   hash will be returned as null values.
  </para>
________________________________________________________-->
  <para>
   PL/Perl 函数可以使用相同的方法返回组合类型：返回具有所要求属性的
   哈希的引用。例如：

<programlisting>
CREATE TYPE testrowperl AS (f1 integer, f2 text, f3 text);

CREATE OR REPLACE FUNCTION perl_row() RETURNS testrowperl AS $$
    return {f2 =&gt; 'hello', f1 =&gt; 1, f3 =&gt; 'world'};
$$ LANGUAGE plperl;

SELECT * FROM perl_row();
</programlisting>

   任何所要求结果数据类型中不存在于哈希中的列将被返回为空值。
  </para>
<!-- pgdoc-cn_end sig_en=a2d8f02ab28b428df76608382603335e -->

<!-- pgdoc-cn_start sig_en=82e1d624c97d6d59a9b52015e2daaba3 sig_cn_org=None source=14.1 
  <para>
   Similarly, output arguments of procedures can be returned as a hash
   reference:

<programlisting>
CREATE PROCEDURE perl_triple(INOUT a integer, INOUT b integer) AS $$
    my ($a, $b) = @_;
    return {a =&gt; $a * 3, b =&gt; $b * 3};
$$ LANGUAGE plperl;

CALL perl_triple(5, 10);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   类似的，过程的输出参数也可以被返回为哈希引用：

<programlisting>
CREATE PROCEDURE perl_triple(INOUT a integer, INOUT b integer) AS $$
    my ($a, $b) = @_;
    return {a =&gt; $a * 3, b =&gt; $b * 3};
$$ LANGUAGE plperl;

CALL perl_triple(5, 10);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=82e1d624c97d6d59a9b52015e2daaba3 -->

<!-- pgdoc-cn_start sig_en=ba153594ea7f7012120c145baa7244e0 sig_cn_org=None source=14.1 
  <para>
    PL/Perl functions can also return sets of either scalar or
    composite types.  Usually you'll want to return rows one at a
    time, both to speed up startup time and to keep from queuing up
    the entire result set in memory.  You can do this with
    <function>return_next</function> as illustrated below.  Note that
    after the last <function>return_next</function>, you must put
    either <literal>return</literal> or (better) <literal>return
    undef</literal>.

<programlisting>
CREATE OR REPLACE FUNCTION perl_set_int(int)
RETURNS SETOF INTEGER AS $$
    foreach (0..$_[0]) {
        return_next($_);
    }
    return undef;
$$ LANGUAGE plperl;

SELECT * FROM perl_set_int(5);

CREATE OR REPLACE FUNCTION perl_set()
RETURNS SETOF testrowperl AS $$
    return_next({ f1 =&gt; 1, f2 =&gt; 'Hello', f3 =&gt; 'World' });
    return_next({ f1 =&gt; 2, f2 =&gt; 'Hello', f3 =&gt; 'PostgreSQL' });
    return_next({ f1 =&gt; 3, f2 =&gt; 'Hello', f3 =&gt; 'PL/Perl' });
    return undef;
$$ LANGUAGE plperl;
</programlisting>

    For small result sets, you can return a reference to an array that
    contains either scalars, references to arrays, or references to
    hashes for simple types, array types, and composite types,
    respectively.  Here are some simple examples of returning the entire
    result set as an array reference:

<programlisting>
CREATE OR REPLACE FUNCTION perl_set_int(int) RETURNS SETOF INTEGER AS $$
    return [0..$_[0]];
$$ LANGUAGE plperl;

SELECT * FROM perl_set_int(5);

CREATE OR REPLACE FUNCTION perl_set() RETURNS SETOF testrowperl AS $$
    return [
        { f1 =&gt; 1, f2 =&gt; 'Hello', f3 =&gt; 'World' },
        { f1 =&gt; 2, f2 =&gt; 'Hello', f3 =&gt; 'PostgreSQL' },
        { f1 =&gt; 3, f2 =&gt; 'Hello', f3 =&gt; 'PL/Perl' }
    ];
$$ LANGUAGE plperl;

SELECT * FROM perl_set();
</programlisting>
  </para>
________________________________________________________-->
  <para>
    PL/Perl 函数也能返回标量或者组合类型集合。为了加速启动并且避免在
    内存中让整个结果集排队等候，我们通常希望能一次返回一行。可以按
    下文所说的用<function>return_next</function>来这样做。注意在
    最后一次<function>return_next</function>后，必须放上
    <literal>return</literal>或者<literal>return
    undef</literal>（后者更好）。

<programlisting>
CREATE OR REPLACE FUNCTION perl_set_int(int)
RETURNS SETOF INTEGER AS $$
    foreach (0..$_[0]) {
        return_next($_);
    }
    return undef;
$$ LANGUAGE plperl;

SELECT * FROM perl_set_int(5);

CREATE OR REPLACE FUNCTION perl_set()
RETURNS SETOF testrowperl AS $$
    return_next({ f1 =&gt; 1, f2 =&gt; 'Hello', f3 =&gt; 'World' });
    return_next({ f1 =&gt; 2, f2 =&gt; 'Hello', f3 =&gt; 'PostgreSQL' });
    return_next({ f1 =&gt; 3, f2 =&gt; 'Hello', f3 =&gt; 'PL/Perl' });
    return undef;
$$ LANGUAGE plperl;
</programlisting>

    对于小结果集，可以返回到一个数组的引用，该数组分别包含用于
    简单类型、数组类型和组合类型的标量、数组引用或者哈希引用。
    这里有一些简单的例子把整个结果集作为数组引用返回：

<programlisting>
CREATE OR REPLACE FUNCTION perl_set_int(int) RETURNS SETOF INTEGER AS $$
    return [0..$_[0]];
$$ LANGUAGE plperl;

SELECT * FROM perl_set_int(5);

CREATE OR REPLACE FUNCTION perl_set() RETURNS SETOF testrowperl AS $$
    return [
        { f1 =&gt; 1, f2 =&gt; 'Hello', f3 =&gt; 'World' },
        { f1 =&gt; 2, f2 =&gt; 'Hello', f3 =&gt; 'PostgreSQL' },
        { f1 =&gt; 3, f2 =&gt; 'Hello', f3 =&gt; 'PL/Perl' }
    ];
$$ LANGUAGE plperl;

SELECT * FROM perl_set();
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=ba153594ea7f7012120c145baa7244e0 -->

<!-- pgdoc-cn_start sig_en=456fe6385a3096cc167308f674a65168 sig_cn_org=None source=14.1 
  <para>
   If you wish to use the <literal>strict</literal> pragma with your code you
   have a few options. For temporary global use you can <command>SET</command>
   <literal>plperl.use_strict</literal> to true.
   This will affect subsequent compilations of <application>PL/Perl</application>
   functions, but not functions already compiled in the current session.
   For permanent global use you can set <literal>plperl.use_strict</literal>
   to true in the <filename>postgresql.conf</filename> file.
  </para>
________________________________________________________-->
  <para>
   如果你想要对你的代码使用<literal>strict</literal>编译指示，有几种选项可用。
   对于临时的全局使用，你可以<command>SET</command>
   <literal>plperl.use_strict</literal>为真。这将影响后续
   <application>PL/Perl</application>函数的编译，但是对当前会话中已经编译过的
   函数没有影响。对于持久的全局使用，可以在
   <filename>postgresql.conf</filename>文件中设置
   <literal>plperl.use_strict</literal>为真。
  </para>
<!-- pgdoc-cn_end sig_en=456fe6385a3096cc167308f674a65168 -->

<!-- pgdoc-cn_start sig_en=56351b06018930dcaed7707834477c38 sig_cn_org=None source=14.1 
  <para>
   For permanent use in specific functions you can simply put:
<programlisting>
use strict;
</programlisting>
   at the top of the function body.
  </para>
________________________________________________________-->
  <para>
   对于在特定函数中的持久使用，可以简单地把
<programlisting>
use strict;
</programlisting>
   放在函数体的顶层。
  </para>
<!-- pgdoc-cn_end sig_en=56351b06018930dcaed7707834477c38 -->

<!-- pgdoc-cn_start sig_en=e04c58b021335cef1a76895f82fcae66 sig_cn_org=None source=14.1 
  <para>
  The <literal>feature</literal> pragma is also available to <function>use</function> if your Perl is version 5.10.0 or higher.
  </para>
________________________________________________________-->
  <para>
  如果 Perl 版本是 5.10.0 或者更高，也可以<function>使用</function>
  <literal>feature</literal>编译指示。
  </para>
<!-- pgdoc-cn_end sig_en=e04c58b021335cef1a76895f82fcae66 -->

 </sect1>

 <sect1 id="plperl-data">
<!-- pgdoc-cn_start sig_en=90d926aa6b5ee19081c854c8bd7fca84 sig_cn_org=None source=14.1 
  <title>Data Values in PL/Perl</title>
________________________________________________________-->
  <title>PL/Perl 中的数据值</title>
<!-- pgdoc-cn_end sig_en=90d926aa6b5ee19081c854c8bd7fca84 -->

<!-- pgdoc-cn_start sig_en=6d95c8f53107e279f186b38c7bae3196 sig_cn_org=None source=14.1 
  <para>
   The argument values supplied to a PL/Perl function's code are
   simply the input arguments converted to text form (just as if they
   had been displayed by a <command>SELECT</command> statement).
   Conversely, the <function>return</function> and <function>return_next</function>
   commands will accept any string that is acceptable input format
   for the function's declared return type.
  </para>
________________________________________________________-->
  <para>
   提供给 PL/Perl 函数代码的参数值是被转换成文本形式的输入参数（就像它们
   被<command>SELECT</command>语句显示的那样）。反过来，
   <function>return</function>和<function>return_next</function>命令
   将接受任何该函数返回类型可接受的输入格式的串。
  </para>
<!-- pgdoc-cn_end sig_en=6d95c8f53107e279f186b38c7bae3196 -->

<!-- pgdoc-cn_start sig_en=249dbf33fa59b936bd10fcc50ebf84b5 sig_cn_org=None source=14.1 
  <para>
   If this behavior is inconvenient for a particular case, it can be
   improved by using a transform, as already illustrated
   for <type>bool</type> values.  Several examples of transform modules
   are included in the <productname>PostgreSQL</productname> distribution.
  </para>
________________________________________________________-->
  <para>
   如果这种行为在特定情况下不方便，可以通过使用转换来改进，正如已经针对<type>bool</type>值说明的那样。
   <productname>PostgreSQL</productname> 发行版中包含了几个转换模块的示例。
  </para>
<!-- pgdoc-cn_end sig_en=249dbf33fa59b936bd10fcc50ebf84b5 -->
 </sect1>

 <sect1 id="plperl-builtins">
<!-- pgdoc-cn_start sig_en=9d811ec11916c4443c3e2fef414f6e8c sig_cn_org=None source=14.1 
  <title>Built-in Functions</title>
________________________________________________________-->
  <title>内建函数</title>
<!-- pgdoc-cn_end sig_en=9d811ec11916c4443c3e2fef414f6e8c -->

 <sect2 id="plperl-database">
<!-- pgdoc-cn_start sig_en=3f268e3e3b6fef011f53967861dc37a3 sig_cn_org=None source=14.1 
  <title>Database Access from PL/Perl</title>
________________________________________________________-->
  <title>从 PL/Perl 访问数据库</title>
<!-- pgdoc-cn_end sig_en=3f268e3e3b6fef011f53967861dc37a3 -->

<!-- pgdoc-cn_start sig_en=3e8fd090abf4e9988ab61cdb2fb5f4c5 sig_cn_org=None source=14.1 
  <para>
   Access to the database itself from your Perl function can be done
   via the following functions:
  </para>
________________________________________________________-->
  <para>
   可以通过下列函数从 Perl 函数中访问数据库本身：
  </para>
<!-- pgdoc-cn_end sig_en=3e8fd090abf4e9988ab61cdb2fb5f4c5 -->

   <variablelist>
    <varlistentry>
<!-- pgdoc-cn_start sig_en=637fc949a792ae883579825a47969e87 sig_cn_org=75bb6b06e56ef84fc50707431227a9bc source=15.7 
     <term>
      <literal><function>spi_exec_query</function>(<replaceable>query</replaceable> [, <replaceable>limit</replaceable>])</literal>
      <indexterm>
       <primary>spi_exec_query</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
________________________________________________________-->
     <term>
      <literal><function>spi_exec_query</function>(<replaceable>query</replaceable> [, <replaceable>limit</replaceable>])</literal>
      <indexterm>
       <primary>spi_exec_query</primary>
       <secondary>在PL/Perl中</secondary>
      </indexterm>
     </term>
<!-- pgdoc-cn_end sig_en=637fc949a792ae883579825a47969e87 -->
     <listitem>
<!-- pgdoc-cn_start sig_en=83a071bfdcd8f1b574a231d1c3ba2505 sig_cn_org=d64edbf6d708324b75cd11d0f2cb66ff source=15.7 
      <para>
       <function>spi_exec_query</function> executes an SQL command and
returns the entire row set as a reference to an array of hash references.
If <replaceable>limit</replaceable> is specified and is greater than zero,
then <function>spi_exec_query</function> retrieves at
most <replaceable>limit</replaceable> rows, much as if the query included
a <literal>LIMIT</literal> clause.  Omitting <replaceable>limit</replaceable>
or specifying it as zero results in no row limit.
      </para>
________________________________________________________-->
      <para>
       <function>spi_exec_query</function>执行一个SQL命令，并将整个行集作为哈希引用数组的引用返回。
如果指定了<replaceable>limit</replaceable>并且大于零，则<function>spi_exec_query</function>最多检索<replaceable>limit</replaceable>行，就像查询包括一个<literal>LIMIT</literal>子句一样。省略<replaceable>limit</replaceable>或将其指定为零将导致没有行限制。
      </para>
<!-- pgdoc-cn_end sig_en=83a071bfdcd8f1b574a231d1c3ba2505 -->

<!-- pgdoc-cn_start sig_en=9c2714e79e68dbba01468941779ae53e sig_cn_org=0016a44cebffcdb2584c2c19b02930ca source=15.7 
      <para>
<emphasis>You should only use this command when you know
that the result set will be relatively small.</emphasis>  Here is an
example of a query (<command>SELECT</command> command) with the
optional maximum number of rows:

<programlisting>
$rv = spi_exec_query('SELECT * FROM my_table', 5);
</programlisting>
        This returns up to 5 rows from the table
        <literal>my_table</literal>.  If <literal>my_table</literal>
        has a column <literal>my_column</literal>, you can get that
        value from row <literal>$i</literal> of the result like this:
<programlisting>
$foo = $rv-&gt;{rows}[$i]-&gt;{my_column};
</programlisting>
       The total number of rows returned from a <command>SELECT</command>
       query can be accessed like this:
<programlisting>
$nrows = $rv-&gt;{processed}
</programlisting>
      </para>
________________________________________________________-->
      <para>
<emphasis>只有在您知道结果集相对较小时才应使用此命令。</emphasis>这是一个带有可选最大行数的查询（<command>SELECT</command>命令）示例：

<programlisting>
$rv = spi_exec_query('SELECT * FROM my_table', 5);
</programlisting>
        这将从表<literal>my_table</literal>返回最多5行。如果<literal>my_table</literal>有一列<literal>my_column</literal>，您可以像这样从结果的第<literal>$i</literal>行获取该值：
<programlisting>
$foo = $rv-&gt;{rows}[$i]-&gt;{my_column};
</programlisting>
       可以通过以下方式访问从<command>SELECT</command>查询返回的总行数：
<programlisting>
$nrows = $rv-&gt;{processed}
</programlisting>
      </para>
<!-- pgdoc-cn_end sig_en=9c2714e79e68dbba01468941779ae53e -->

<!-- pgdoc-cn_start sig_en=c47d3a3c43bd0a2a9ee223507fb3ae50 sig_cn_org=None source=14.1 
      <para>
       Here is an example using a different command type:
<programlisting>
$query = "INSERT INTO my_table VALUES (1, 'test')";
$rv = spi_exec_query($query);
</programlisting>
       You can then access the command status (e.g.,
       <literal>SPI_OK_INSERT</literal>) like this:
<programlisting>
$res = $rv-&gt;{status};
</programlisting>
       To get the number of rows affected, do:
<programlisting>
$nrows = $rv-&gt;{processed};
</programlisting>
      </para>
________________________________________________________-->
      <para>
       这里是使用不同命令类型的一个例子：
<programlisting>
$query = "INSERT INTO my_table VALUES (1, 'test')";
$rv = spi_exec_query($query);
</programlisting>
       你可以这样访问命令状态（例如<literal>SPI_OK_INSERT</literal>）：
<programlisting>
$res = $rv-&gt;{status};
</programlisting>
       要得到受影响的行数：
<programlisting>
$nrows = $rv-&gt;{processed};
</programlisting>
      </para>
<!-- pgdoc-cn_end sig_en=c47d3a3c43bd0a2a9ee223507fb3ae50 -->

<!-- pgdoc-cn_start sig_en=f3e9c435c38512c98edeee88fcc2972a sig_cn_org=None source=14.1 
      <para>
       Here is a complete example:
<programlisting>
CREATE TABLE test (
    i int,
    v varchar
);

INSERT INTO test (i, v) VALUES (1, 'first line');
INSERT INTO test (i, v) VALUES (2, 'second line');
INSERT INTO test (i, v) VALUES (3, 'third line');
INSERT INTO test (i, v) VALUES (4, 'immortal');

CREATE OR REPLACE FUNCTION test_munge() RETURNS SETOF test AS $$
    my $rv = spi_exec_query('select i, v from test;');
    my $status = $rv-&gt;{status};
    my $nrows = $rv-&gt;{processed};
    foreach my $rn (0 .. $nrows - 1) {
        my $row = $rv-&gt;{rows}[$rn];
        $row-&gt;{i} += 200 if defined($row-&gt;{i});
        $row-&gt;{v} =~ tr/A-Za-z/a-zA-Z/ if (defined($row-&gt;{v}));
        return_next($row);
    }
    return undef;
$$ LANGUAGE plperl;

SELECT * FROM test_munge();
</programlisting>
    </para>
________________________________________________________-->
      <para>
       这里是一个完整的例子：
<programlisting>
CREATE TABLE test (
    i int,
    v varchar
);

INSERT INTO test (i, v) VALUES (1, 'first line');
INSERT INTO test (i, v) VALUES (2, 'second line');
INSERT INTO test (i, v) VALUES (3, 'third line');
INSERT INTO test (i, v) VALUES (4, 'immortal');

CREATE OR REPLACE FUNCTION test_munge() RETURNS SETOF test AS $$
    my $rv = spi_exec_query('select i, v from test;');
    my $status = $rv-&gt;{status};
    my $nrows = $rv-&gt;{processed};
    foreach my $rn (0 .. $nrows - 1) {
        my $row = $rv-&gt;{rows}[$rn];
        $row-&gt;{i} += 200 if defined($row-&gt;{i});
        $row-&gt;{v} =~ tr/A-Za-z/a-zA-Z/ if (defined($row-&gt;{v}));
        return_next($row);
    }
    return undef;
$$ LANGUAGE plperl;

SELECT * FROM test_munge();
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=f3e9c435c38512c98edeee88fcc2972a -->
    </listitem>
    </varlistentry>

    <varlistentry>
<!-- pgdoc-cn_start sig_en=49692057912995513261f03645105493 sig_cn_org=None source=14.1 
     <term>
      <literal><function>spi_query(<replaceable>command</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_query</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
________________________________________________________-->
     <term>
      <literal><function>spi_query(<replaceable>command</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_query</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
<!-- pgdoc-cn_end sig_en=49692057912995513261f03645105493 -->
<!-- pgdoc-cn_start sig_en=0a5febba5bc213b4c331289802cefcdb sig_cn_org=None source=14.1 
     <term>
      <literal><function>spi_fetchrow(<replaceable>cursor</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_fetchrow</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
________________________________________________________-->
     <term>
      <literal><function>spi_fetchrow(<replaceable>cursor</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_fetchrow</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
<!-- pgdoc-cn_end sig_en=0a5febba5bc213b4c331289802cefcdb -->
<!-- pgdoc-cn_start sig_en=955304f6fe8dc11f66f1c0ac81631b12 sig_cn_org=None source=14.1 
     <term>
      <literal><function>spi_cursor_close(<replaceable>cursor</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_cursor_close</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
________________________________________________________-->
     <term>
      <literal><function>spi_cursor_close(<replaceable>cursor</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_cursor_close</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
<!-- pgdoc-cn_end sig_en=955304f6fe8dc11f66f1c0ac81631b12 -->

    <listitem>
<!-- pgdoc-cn_start sig_en=394f2faedebcc12c4669ad7d214ac555 sig_cn_org=None source=14.1 
    <para>
    <literal>spi_query</literal> and <literal>spi_fetchrow</literal>
    work together as a pair for row sets which might be large, or for cases
    where you wish to return rows as they arrive.
    <literal>spi_fetchrow</literal> works <emphasis>only</emphasis> with
    <literal>spi_query</literal>. The following example illustrates how
    you use them together:

<programlisting>
CREATE TYPE foo_type AS (the_num INTEGER, the_text TEXT);

CREATE OR REPLACE FUNCTION lotsa_md5 (INTEGER) RETURNS SETOF foo_type AS $$
    use Digest::MD5 qw(md5_hex);
    my $file = '/usr/share/dict/words';
    my $t = localtime;
    elog(NOTICE, "opening file $file at $t" );
    open my $fh, '&lt;', $file # ooh, it's a file access!
        or elog(ERROR, "cannot open $file for reading: $!");
    my @words = &lt;$fh&gt;;
    close $fh;
    $t = localtime;
    elog(NOTICE, "closed file $file at $t");
    chomp(@words);
    my $row;
    my $sth = spi_query("SELECT * FROM generate_series(1,$_[0]) AS b(a)");
    while (defined ($row = spi_fetchrow($sth))) {
        return_next({
            the_num =&gt; $row-&gt;{a},
            the_text =&gt; md5_hex($words[rand @words])
        });
    }
    return;
$$ LANGUAGE plperlu;

SELECT * from lotsa_md5(500);
</programlisting>
    </para>
________________________________________________________-->
    <para>
    <literal>spi_query</literal>和<literal>spi_fetchrow</literal>
    结对用于可能比较大的行集合，或者用于希望在行到达时返回的情况。
    <literal>spi_fetchrow</literal><emphasis>只</emphasis>和
    <literal>spi_query</literal>一起工作。下面的例子展示了如何使用
    它们：

<programlisting>
CREATE TYPE foo_type AS (the_num INTEGER, the_text TEXT);

CREATE OR REPLACE FUNCTION lotsa_md5 (INTEGER) RETURNS SETOF foo_type AS $$
    use Digest::MD5 qw(md5_hex);
    my $file = '/usr/share/dict/words';
    my $t = localtime;
    elog(NOTICE, "opening file $file at $t" );
    open my $fh, '&lt;', $file # ooh, it's a file access!
        or elog(ERROR, "cannot open $file for reading: $!");
    my @words = &lt;$fh&gt;;
    close $fh;
    $t = localtime;
    elog(NOTICE, "closed file $file at $t");
    chomp(@words);
    my $row;
    my $sth = spi_query("SELECT * FROM generate_series(1,$_[0]) AS b(a)");
    while (defined ($row = spi_fetchrow($sth))) {
        return_next({
            the_num =&gt; $row-&gt;{a},
            the_text =&gt; md5_hex($words[rand @words])
        });
    }
    return;
$$ LANGUAGE plperlu;

SELECT * from lotsa_md5(500);
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=394f2faedebcc12c4669ad7d214ac555 -->

<!-- pgdoc-cn_start sig_en=6ac23e93f410f496b64b2456a0e94a16 sig_cn_org=None source=14.1 
    <para>
     Normally, <function>spi_fetchrow</function> should be repeated until it
     returns <literal>undef</literal>, indicating that there are no more
     rows to read.  The cursor returned by <literal>spi_query</literal>
     is automatically freed when
     <function>spi_fetchrow</function> returns <literal>undef</literal>.
     If you do not wish to read all the rows, instead call
     <function>spi_cursor_close</function> to free the cursor.
     Failure to do so will result in memory leaks.
    </para>
________________________________________________________-->
    <para>
     通常，<function>spi_fetchrow</function>应该重复执行直到它返回
     <literal>undef</literal>（表示没有更多行要读取）。当
     <function>spi_fetchrow</function>返回<literal>undef</literal>时，
     <literal>spi_query</literal>返回的游标会自动被释放。如果不
     想读取所有的行，可以调用<function>spi_cursor_close</function>来
     释放游标。如果没有这样做会导致内存泄露。
    </para>
<!-- pgdoc-cn_end sig_en=6ac23e93f410f496b64b2456a0e94a16 -->

    </listitem>
    </varlistentry>

    <varlistentry>
<!-- pgdoc-cn_start sig_en=ee89a7a681c179d45d37c8f7204c5579 sig_cn_org=None source=14.1 
     <term>
      <literal><function>spi_prepare(<replaceable>command</replaceable>, <replaceable>argument types</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_prepare</primary>
       <secondary>in PL/Perl</secondary>
     </indexterm>
     </term>
________________________________________________________-->
     <term>
      <literal><function>spi_prepare(<replaceable>command</replaceable>, <replaceable>argument types</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_prepare</primary>
       <secondary>in PL/Perl</secondary>
     </indexterm>
     </term>
<!-- pgdoc-cn_end sig_en=ee89a7a681c179d45d37c8f7204c5579 -->
<!-- pgdoc-cn_start sig_en=30ffd2c50c7dc4f30ce31cf12c19ac75 sig_cn_org=None source=14.1 
     <term>
      <literal><function>spi_query_prepared(<replaceable>plan</replaceable>, <replaceable>arguments</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_query_prepared</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
________________________________________________________-->
     <term>
      <literal><function>spi_query_prepared(<replaceable>plan</replaceable>, <replaceable>arguments</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_query_prepared</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
<!-- pgdoc-cn_end sig_en=30ffd2c50c7dc4f30ce31cf12c19ac75 -->
<!-- pgdoc-cn_start sig_en=11cde4bab19048e3695643e322750cd3 sig_cn_org=None source=14.1 
     <term>
      <literal><function>spi_exec_prepared(<replaceable>plan</replaceable> [, <replaceable>attributes</replaceable>], <replaceable>arguments</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_exec_prepared</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
________________________________________________________-->
     <term>
      <literal><function>spi_exec_prepared(<replaceable>plan</replaceable> [, <replaceable>attributes</replaceable>], <replaceable>arguments</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_exec_prepared</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
<!-- pgdoc-cn_end sig_en=11cde4bab19048e3695643e322750cd3 -->
<!-- pgdoc-cn_start sig_en=fc9861ab27d3a0bb25391a18d63a0e7d sig_cn_org=None source=14.1 
     <term>
      <literal><function>spi_freeplan(<replaceable>plan</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_freeplan</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
________________________________________________________-->
     <term>
      <literal><function>spi_freeplan(<replaceable>plan</replaceable>)</function></literal>
      <indexterm>
       <primary>spi_freeplan</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
<!-- pgdoc-cn_end sig_en=fc9861ab27d3a0bb25391a18d63a0e7d -->

    <listitem>
<!-- pgdoc-cn_start sig_en=145cb499fef26ed4eee6f9828bcb380c sig_cn_org=28b6f4be3c6f5b0aaceaf5ce67c25648 source=15.7 
    <para>
    <literal>spi_prepare</literal>, <literal>spi_query_prepared</literal>, <literal>spi_exec_prepared</literal>,
    and <literal>spi_freeplan</literal> implement the same functionality but for prepared queries.
    <literal>spi_prepare</literal> accepts a query string with numbered argument placeholders ($1, $2, etc.)
    and a string list of argument types:
<programlisting>
$plan = spi_prepare('SELECT * FROM test WHERE id &gt; $1 AND name = $2',
                                                     'INTEGER', 'TEXT');
</programlisting>
    Once a query plan is prepared by a call to <literal>spi_prepare</literal>, the plan can be used instead
    of the string query, either in <literal>spi_exec_prepared</literal>, where the result is the same as returned
    by <literal>spi_exec_query</literal>, or in <literal>spi_query_prepared</literal> which returns a cursor
    exactly as <literal>spi_query</literal> does, which can be later passed to <literal>spi_fetchrow</literal>.
    The optional second parameter to <literal>spi_exec_prepared</literal> is a hash reference of attributes;
    the only attribute currently supported is <literal>limit</literal>, which
    sets the maximum number of rows returned from the query.
    Omitting <literal>limit</literal> or specifying it as zero results in no
    row limit.
    </para>
________________________________________________________-->
    <para>
    <literal>spi_prepare</literal>, <literal>spi_query_prepared</literal>, <literal>spi_exec_prepared</literal>,
    和<literal>spi_freeplan</literal>实现了相同的功能，但用于预处理查询。
    <literal>spi_prepare</literal>接受一个带有编号参数占位符（$1，$2等）和参数类型的字符串列表：
<programlisting>
$plan = spi_prepare('SELECT * FROM test WHERE id &gt; $1 AND name = $2',
                                                     'INTEGER', 'TEXT');
</programlisting>
    一旦通过调用<literal>spi_prepare</literal>准备了查询计划，该计划可以代替字符串查询使用，
    可以在<literal>spi_exec_prepared</literal>中使用，其结果与<literal>spi_exec_query</literal>返回的结果相同，
    或者在<literal>spi_query_prepared</literal>中使用，该函数返回一个游标，正如<literal>spi_query</literal>所做的那样，
    该游标稍后可以传递给<literal>spi_fetchrow</literal>。
    <literal>spi_exec_prepared</literal>的可选第二个参数是属性的哈希引用；
    目前仅支持的属性是<literal>limit</literal>，它设置从查询返回的最大行数。
    省略<literal>limit</literal>或将其指定为零将导致没有行限制。
</para>
<!-- pgdoc-cn_end sig_en=145cb499fef26ed4eee6f9828bcb380c -->

<!-- pgdoc-cn_start sig_en=0bedf551f4d50b6a1bd248dead76626c sig_cn_org=1001b86cc59ea0fc6137f45082477cb8 source=15.7 
    <para>
    The advantage of prepared queries is that is it possible to use one prepared plan for more
    than one query execution. After the plan is not needed anymore, it can be freed with
    <literal>spi_freeplan</literal>:
<programlisting>
CREATE OR REPLACE FUNCTION init() RETURNS VOID AS $$
        $_SHARED{my_plan} = spi_prepare('SELECT (now() + $1)::date AS now',
                                        'INTERVAL');
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION add_time( INTERVAL ) RETURNS TEXT AS $$
        return spi_exec_prepared(
                $_SHARED{my_plan},
                $_[0]
        )->{rows}->[0]->{now};
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION done() RETURNS VOID AS $$
        spi_freeplan( $_SHARED{my_plan});
        undef $_SHARED{my_plan};
$$ LANGUAGE plperl;

SELECT init();
SELECT add_time('1 day'), add_time('2 days'), add_time('3 days');
SELECT done();

  add_time  |  add_time  |  add_time
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 2005-12-10 | 2005-12-11 | 2005-12-12
</programlisting>
    Note that the parameter subscript in <literal>spi_prepare</literal> is defined via
    $1, $2, $3, etc., so avoid declaring query strings in double quotes that might easily
    lead to hard-to-catch bugs.
    </para>
________________________________________________________-->
    <para>
    准备查询的优点是可以为多个查询执行使用一个准备计划。在计划不再需要时，可以使用
    <literal>spi_freeplan</literal>来释放它：
<programlisting>
CREATE OR REPLACE FUNCTION init() RETURNS VOID AS $$
        $_SHARED{my_plan} = spi_prepare('SELECT (now() + $1)::date AS now',
                                        'INTERVAL');
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION add_time( INTERVAL ) RETURNS TEXT AS $$
        return spi_exec_prepared(
                $_SHARED{my_plan},
                $_[0]
        )->{rows}->[0]->{now};
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION done() RETURNS VOID AS $$
        spi_freeplan( $_SHARED{my_plan});
        undef $_SHARED{my_plan};
$$ LANGUAGE plperl;

SELECT init();
SELECT add_time('1 day'), add_time('2 days'), add_time('3 days');
SELECT done();

  add_time  |  add_time  |  add_time
------------+------------+------------
 2005-12-10 | 2005-12-11 | 2005-12-12
</programlisting>
    请注意，在<literal>spi_prepare</literal>中的参数下标是通过$1、$2、$3等定义的，因此要避免
    在双引号中声明可能很容易导致难以捕捉错误的查询字符串。
    </para>
<!-- pgdoc-cn_end sig_en=0bedf551f4d50b6a1bd248dead76626c -->

<!-- pgdoc-cn_start sig_en=f9b215c0606b5f6d90964e83cd6de5d8 sig_cn_org=43d9670a919095c2a00d8bf0f1e5e531 source=15.7 
    <para>
    Another example illustrates usage of an optional parameter in <literal>spi_exec_prepared</literal>:
<programlisting>
CREATE TABLE hosts AS SELECT id, ('192.168.1.'||id)::inet AS address
                      FROM generate_series(1,3) AS id;

CREATE OR REPLACE FUNCTION init_hosts_query() RETURNS VOID AS $$
        $_SHARED{plan} = spi_prepare('SELECT * FROM hosts
                                      WHERE address &lt;&lt; $1', 'inet');
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION query_hosts(inet) RETURNS SETOF hosts AS $$
        return spi_exec_prepared(
                $_SHARED{plan},
                {limit =&gt; 2},
                $_[0]
        )->{rows};
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION release_hosts_query() RETURNS VOID AS $$
        spi_freeplan($_SHARED{plan});
        undef $_SHARED{plan};
$$ LANGUAGE plperl;

SELECT init_hosts_query();
SELECT query_hosts('192.168.1.0/30');
SELECT release_hosts_query();

    query_hosts
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 (1,192.168.1.1)
 (2,192.168.1.2)
(2 rows)
</programlisting>
    </para>
________________________________________________________-->
    <para>
    另一个示例说明了在<literal>spi_exec_prepared</literal>中使用可选参数的用法：
<programlisting>
CREATE TABLE hosts AS SELECT id, ('192.168.1.'||id)::inet AS address
                      FROM generate_series(1,3) AS id;

CREATE OR REPLACE FUNCTION init_hosts_query() RETURNS VOID AS $$
        $_SHARED{plan} = spi_prepare('SELECT * FROM hosts
                                      WHERE address &lt;&lt; $1', 'inet');
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION query_hosts(inet) RETURNS SETOF hosts AS $$
        return spi_exec_prepared(
                $_SHARED{plan},
                {limit =&gt; 2},
                $_[0]
        )->{rows};
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION release_hosts_query() RETURNS VOID AS $$
        spi_freeplan($_SHARED{plan});
        undef $_SHARED{plan};
$$ LANGUAGE plperl;

SELECT init_hosts_query();
SELECT query_hosts('192.168.1.0/30');
SELECT release_hosts_query();

    query_hosts
-----------------
 (1,192.168.1.1)
 (2,192.168.1.2)
(2 rows)
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=f9b215c0606b5f6d90964e83cd6de5d8 -->
    </listitem>
    </varlistentry>

    <varlistentry>
<!-- pgdoc-cn_start sig_en=33172ffce6023b680392c8c8ba89224c sig_cn_org=None source=14.1 
     <term>
      <literal><function>spi_commit()</function></literal>
      <indexterm>
       <primary>spi_commit</primary>
       <secondary>in PL/Perl</secondary>
     </indexterm>
     </term>
________________________________________________________-->
     <term>
      <literal><function>spi_commit()</function></literal>
      <indexterm>
       <primary>spi_commit</primary>
       <secondary>in PL/Perl</secondary>
     </indexterm>
     </term>
<!-- pgdoc-cn_end sig_en=33172ffce6023b680392c8c8ba89224c -->
<!-- pgdoc-cn_start sig_en=1c74eda3822f4ee1bc2cee3d9afda71b sig_cn_org=None source=14.1 
     <term>
      <literal><function>spi_rollback()</function></literal>
      <indexterm>
       <primary>spi_rollback</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
________________________________________________________-->
     <term>
      <literal><function>spi_rollback()</function></literal>
      <indexterm>
       <primary>spi_rollback</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
<!-- pgdoc-cn_end sig_en=1c74eda3822f4ee1bc2cee3d9afda71b -->
     <listitem>
<!-- pgdoc-cn_start sig_en=babbe6222b165a3cc4a4139b82f6149c sig_cn_org=None source=14.1 
      <para>
       Commit or roll back the current transaction.  This can only be called
       in a procedure or anonymous code block (<command>DO</command> command)
       called from the top level.  (Note that it is not possible to run the
       SQL commands <command>COMMIT</command> or <command>ROLLBACK</command>
       via <function>spi_exec_query</function> or similar.  It has to be done
       using these functions.)  After a transaction is ended, a new
       transaction is automatically started, so there is no separate function
       for that.
      </para>
________________________________________________________-->
      <para>
       提交或者回滚当前事务。只能在从顶层调用的过程或者匿名代码块（<command>DO</command>命令）中调用这个函数（注意不能通过<function>spi_exec_query</function>或者类似的函数运行SQL命令<command>COMMIT</command>或者<command>ROLLBACK</command>。这样的工作只能使用这些函数完成）。在一个事务结束后，一个新的事务会自动开始，因此没有单独的函数来开始新事务。
      </para>
<!-- pgdoc-cn_end sig_en=babbe6222b165a3cc4a4139b82f6149c -->

<!-- pgdoc-cn_start sig_en=99e1c8606dbd7bcf2fc2a043e7578b1a sig_cn_org=None source=14.1 
      <para>
       Here is an example:
<programlisting>
CREATE PROCEDURE transaction_test1()
LANGUAGE plperl
AS $$
foreach my $i (0..9) {
    spi_exec_query("INSERT INTO test1 (a) VALUES ($i)");
    if ($i % 2 == 0) {
        spi_commit();
    } else {
        spi_rollback();
    }
}
$$;

CALL transaction_test1();
</programlisting>
      </para>
________________________________________________________-->
      <para>
       这里是一个例子：
<programlisting>
CREATE PROCEDURE transaction_test1()
LANGUAGE plperl
AS $$
foreach my $i (0..9) {
    spi_exec_query("INSERT INTO test1 (a) VALUES ($i)");
    if ($i % 2 == 0) {
        spi_commit();
    } else {
        spi_rollback();
    }
}
$$;

CALL transaction_test1();
</programlisting>
      </para>
<!-- pgdoc-cn_end sig_en=99e1c8606dbd7bcf2fc2a043e7578b1a -->
     </listitem>
    </varlistentry>
   </variablelist>
 </sect2>

 <sect2 id="plperl-utility-functions">
<!-- pgdoc-cn_start sig_en=6862531db8cbf662d526f6ebc3cb1b93 sig_cn_org=None source=14.1 
  <title>Utility Functions in PL/Perl</title>
________________________________________________________-->
  <title>PL/Perl 中的工具函数</title>
<!-- pgdoc-cn_end sig_en=6862531db8cbf662d526f6ebc3cb1b93 -->

   <variablelist>
    <varlistentry>
<!-- pgdoc-cn_start sig_en=dbf86e410c16b1de9cbb89b154897154 sig_cn_org=None source=14.1 
     <term>
      <literal><function>elog(<replaceable>level</replaceable>, <replaceable>msg</replaceable>)</function></literal>
      <indexterm>
       <primary>elog</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
________________________________________________________-->
     <term>
      <literal><function>elog(<replaceable>level</replaceable>, <replaceable>msg</replaceable>)</function></literal>
      <indexterm>
       <primary>elog</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
<!-- pgdoc-cn_end sig_en=dbf86e410c16b1de9cbb89b154897154 -->
     <listitem>
<!-- pgdoc-cn_start sig_en=7a5023cf5856ceef8fae92b860b35fc4 sig_cn_org=None source=14.1 
      <para>
       Emit a log or error message. Possible levels are
       <literal>DEBUG</literal>, <literal>LOG</literal>, <literal>INFO</literal>,
       <literal>NOTICE</literal>, <literal>WARNING</literal>, and <literal>ERROR</literal>.
       <literal>ERROR</literal>
        raises an error condition; if this is not trapped by the surrounding
        Perl code, the error propagates out to the calling query, causing
        the current transaction or subtransaction to be aborted.  This
        is effectively the same as the Perl <literal>die</literal> command.
        The other levels only generate messages of different
        priority levels.
        Whether messages of a particular priority are reported to the client,
        written to the server log, or both is controlled by the
        <xref linkend="guc-log-min-messages"/> and
        <xref linkend="guc-client-min-messages"/> configuration
        variables. See <xref linkend="runtime-config"/> for more
        information.
      </para>
________________________________________________________-->
      <para>
       发出一个日志或者错误消息。可用的级别有
       <literal>DEBUG</literal>、<literal>LOG</literal>、<literal>INFO</literal>、
       <literal>NOTICE</literal>、<literal>WARNING</literal>以及<literal>ERROR</literal>。
       <literal>ERROR</literal>产生一种错误情况，如果它没有被周围的 Perl 代码
       捕获，错误会传播到调用查询中，导致当前事务或者子事务被中止。这实际
       上和 Perl 的<literal>die</literal> 命令相同。其他级别只产生不同优先级的消息。
       特定优先级的消息是被报告给客户端、写到服务器日志或者两者都做由
        配置变量<xref linkend="guc-log-min-messages"/>和
        <xref linkend="guc-client-min-messages"/>控制。详见
        <xref linkend="runtime-config"/>。
      </para>
<!-- pgdoc-cn_end sig_en=7a5023cf5856ceef8fae92b860b35fc4 -->
     </listitem>
    </varlistentry>

    <varlistentry>
<!-- pgdoc-cn_start sig_en=9abd7489f4b6d069b7e36dd0eba557c0 sig_cn_org=None source=14.1 
     <term>
      <literal><function>quote_literal(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>quote_literal</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
________________________________________________________-->
     <term>
      <literal><function>quote_literal(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>quote_literal</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
<!-- pgdoc-cn_end sig_en=9abd7489f4b6d069b7e36dd0eba557c0 -->
     <listitem>
<!-- pgdoc-cn_start sig_en=aa5682d4d2936c05184418f853aee151 sig_cn_org=None source=14.1 
      <para>
        Return the given string suitably quoted to be used as a string literal in an SQL
        statement string. Embedded single-quotes and backslashes are properly doubled.
        Note that <function>quote_literal</function> returns undef on undef input; if the argument
        might be undef, <function>quote_nullable</function> is often more suitable.
      </para>
________________________________________________________-->
      <para>
        返回给定字符串的被适当引用后的形式，这种形式能被用作 SQL 语句字符串中的字符串。
        嵌入的引号和反斜线会被正确地双写。注意对 undef 输入<function>quote_literal</function>
        会返回 undef。如果参数可能是 undef，<function>quote_nullable</function>通常更合适。
      </para>
<!-- pgdoc-cn_end sig_en=aa5682d4d2936c05184418f853aee151 -->
     </listitem>
    </varlistentry>

    <varlistentry>
<!-- pgdoc-cn_start sig_en=4750aa12c6dc99344d51bfbfdfa84b3c sig_cn_org=None source=14.1 
     <term>
      <literal><function>quote_nullable(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>quote_nullable</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
________________________________________________________-->
     <term>
      <literal><function>quote_nullable(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>quote_nullable</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
<!-- pgdoc-cn_end sig_en=4750aa12c6dc99344d51bfbfdfa84b3c -->
     <listitem>
<!-- pgdoc-cn_start sig_en=083ac9ed977b4cc04e243903dc9ec811 sig_cn_org=None source=14.1 
      <para>
        Return the given string suitably quoted to be used as a string literal in an SQL
        statement string; or, if the argument is undef, return the unquoted string "NULL".
        Embedded single-quotes and backslashes are properly doubled.
      </para>
________________________________________________________-->
      <para>
        返回给定字符串的被适当引用后的形式，这种形式能被用作 SQL 语句字符串中的字符串。
        或者在参数为 undef 时，返回未引用的串 "NULL"。
        嵌入的引号和反斜线会被正确地双写。
      </para>
<!-- pgdoc-cn_end sig_en=083ac9ed977b4cc04e243903dc9ec811 -->
     </listitem>
    </varlistentry>

    <varlistentry>
<!-- pgdoc-cn_start sig_en=8a7c3ea0140eae2a00c3f24f78c4307f sig_cn_org=None source=14.1 
     <term>
      <literal><function>quote_ident(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>quote_ident</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
________________________________________________________-->
     <term>
      <literal><function>quote_ident(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>quote_ident</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
<!-- pgdoc-cn_end sig_en=8a7c3ea0140eae2a00c3f24f78c4307f -->
     <listitem>
<!-- pgdoc-cn_start sig_en=2e9d9bfcfc17beccd4c94d8abd70238e sig_cn_org=None source=14.1 
      <para>
        Return the given string suitably quoted to be used as an identifier in
        an SQL statement string. Quotes are added only if necessary (i.e., if
        the string contains non-identifier characters or would be case-folded).
        Embedded quotes are properly doubled.
      </para>
________________________________________________________-->
      <para>
        返回给定字符串的被适当引用后的形式，这种形式能被用作 SQL 语句字符串
        中的标识符。只有在必要时才增加引号（即，如果串包含非标识符字符或者是
        大小写折叠的）。嵌入的引号会被正确地双写。
      </para>
<!-- pgdoc-cn_end sig_en=2e9d9bfcfc17beccd4c94d8abd70238e -->
     </listitem>
    </varlistentry>

    <varlistentry>
<!-- pgdoc-cn_start sig_en=1dd8340acf1c8259582b29ca1e7fc1f3 sig_cn_org=None source=14.1 
     <term>
      <literal><function>decode_bytea(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>decode_bytea</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
________________________________________________________-->
     <term>
      <literal><function>decode_bytea(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>decode_bytea</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
<!-- pgdoc-cn_end sig_en=1dd8340acf1c8259582b29ca1e7fc1f3 -->
     <listitem>
<!-- pgdoc-cn_start sig_en=6d3cd784d7461e05a9407471181c35af sig_cn_org=None source=14.1 
      <para>
        Return the unescaped binary data represented by the contents of the given string,
        which should be <type>bytea</type> encoded.
        </para>
________________________________________________________-->
      <para>
        返回由给定串的内容（应该用<type>bytea</type>编码）表示的未转义二进制数据。
        </para>
<!-- pgdoc-cn_end sig_en=6d3cd784d7461e05a9407471181c35af -->
     </listitem>
    </varlistentry>

    <varlistentry>
<!-- pgdoc-cn_start sig_en=92e97659b14f19d5eb284786ed06a92a sig_cn_org=None source=14.1 
     <term>
      <literal><function>encode_bytea(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_bytea</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
________________________________________________________-->
     <term>
      <literal><function>encode_bytea(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_bytea</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
<!-- pgdoc-cn_end sig_en=92e97659b14f19d5eb284786ed06a92a -->
     <listitem>
<!-- pgdoc-cn_start sig_en=5a38d5f984f431518e45f6f25328b70f sig_cn_org=None source=14.1 
      <para>
        Return the <type>bytea</type> encoded form of the binary data contents of the given string.
        </para>
________________________________________________________-->
      <para>
        返回给定串的二进制数据内容的<type>bytea</type>编码形式。
        </para>
<!-- pgdoc-cn_end sig_en=5a38d5f984f431518e45f6f25328b70f -->
     </listitem>
    </varlistentry>

    <varlistentry>
<!-- pgdoc-cn_start sig_en=ab363294075ea55bc9771c80b59525b2 sig_cn_org=None source=14.1 
     <term>
      <literal><function>encode_array_literal(<replaceable>array</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_array_literal</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
________________________________________________________-->
     <term>
      <literal><function>encode_array_literal(<replaceable>array</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_array_literal</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
<!-- pgdoc-cn_end sig_en=ab363294075ea55bc9771c80b59525b2 -->
     <term>
      <literal><function>encode_array_literal(<replaceable>array</replaceable>, <replaceable>delimiter</replaceable>)</function></literal>
     </term>
     <listitem>
<!-- pgdoc-cn_start sig_en=5639f4f98618dae35cd712c10b856006 sig_cn_org=None source=14.1 
      <para>
        Returns the contents of the referenced array as a string in array literal format
        (see <xref linkend="arrays-input"/>).
        Returns the argument value unaltered if it's not a reference to an array.
        The delimiter used between elements of the array literal defaults to "<literal>, </literal>"
        if a delimiter is not specified or is undef.
        </para>
________________________________________________________-->
      <para>
        把被引用的数组的内容返回成数组文字格式（见<xref linkend="arrays-input"/>）
        的一个串。如果它不是一个数组的引用，则不加修改地返回参数值。如果没有指定
        定界符或者定界符为 undef，则默认把"<literal>, </literal>"用作数组文字的元素
        之间的定界符。
        </para>
<!-- pgdoc-cn_end sig_en=5639f4f98618dae35cd712c10b856006 -->
     </listitem>
    </varlistentry>

    <varlistentry>
<!-- pgdoc-cn_start sig_en=deba312cfce4e82486f5feafcb15e7cf sig_cn_org=None source=14.1 
     <term>
      <literal><function>encode_typed_literal(<replaceable>value</replaceable>, <replaceable>typename</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_typed_literal</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
________________________________________________________-->
     <term>
      <literal><function>encode_typed_literal(<replaceable>value</replaceable>, <replaceable>typename</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_typed_literal</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
<!-- pgdoc-cn_end sig_en=deba312cfce4e82486f5feafcb15e7cf -->
      <listitem>
<!-- pgdoc-cn_start sig_en=e2ecd720b892dd4b0ba6b502260faf80 sig_cn_org=None source=14.1 
       <para>
         Converts a Perl variable to the value of the data type passed as a
         second argument and returns a string representation of this value.
         Correctly handles nested arrays and values of composite types.
       </para>
________________________________________________________-->
       <para>
         把一个 Perl 变量转换为由第二个参数传入的数据类型的值，并且返回该值
         的字符串表达。它能正确地处理嵌套数组和组合类型的值。
       </para>
<!-- pgdoc-cn_end sig_en=e2ecd720b892dd4b0ba6b502260faf80 -->
      </listitem>
    </varlistentry>

    <varlistentry>
<!-- pgdoc-cn_start sig_en=0b5bc2dbfa105c94749a54462cd8928c sig_cn_org=None source=14.1 
     <term>
      <literal><function>encode_array_constructor(<replaceable>array</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_array_constructor</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
________________________________________________________-->
     <term>
      <literal><function>encode_array_constructor(<replaceable>array</replaceable>)</function></literal>
      <indexterm>
       <primary>encode_array_constructor</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
<!-- pgdoc-cn_end sig_en=0b5bc2dbfa105c94749a54462cd8928c -->
     <listitem>
<!-- pgdoc-cn_start sig_en=afdb81b33345e65e5c4fa4eac6c74e8a sig_cn_org=None source=14.1 
      <para>
        Returns the contents of the referenced array as a string in array constructor format
        (see <xref linkend="sql-syntax-array-constructors"/>).
        Individual values are quoted using <function>quote_nullable</function>.
        Returns the argument value, quoted using <function>quote_nullable</function>,
        if it's not a reference to an array.
        </para>
________________________________________________________-->
      <para>
        把被引用数组的内容返回为数组构造器格式（
        <xref linkend="sql-syntax-array-constructors"/>）的一个串。其中的个体值用
        <function>quote_nullable</function>引用。如果参数不是一个数组引用，则
        返回用<function>quote_nullable</function>引用的该参数值。
        </para>
<!-- pgdoc-cn_end sig_en=afdb81b33345e65e5c4fa4eac6c74e8a -->
     </listitem>
    </varlistentry>

    <varlistentry>
<!-- pgdoc-cn_start sig_en=6b7ce9fcc828b756b5643666ccb36447 sig_cn_org=None source=14.1 
     <term>
      <literal><function>looks_like_number(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>looks_like_number</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
________________________________________________________-->
     <term>
      <literal><function>looks_like_number(<replaceable>string</replaceable>)</function></literal>
      <indexterm>
       <primary>looks_like_number</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
<!-- pgdoc-cn_end sig_en=6b7ce9fcc828b756b5643666ccb36447 -->
     <listitem>
<!-- pgdoc-cn_start sig_en=24f525a3e9f19f8375286d673df32f70 sig_cn_org=None source=14.1 
      <para>
        Returns a true value if the content of the given string looks like a
        number, according to Perl, returns false otherwise.
        Returns undef if the argument is undef.  Leading and trailing space is
        ignored. <literal>Inf</literal> and <literal>Infinity</literal> are regarded as numbers.
        </para>
________________________________________________________-->
      <para>
        如果给定串的内容对于 Perl 看起来像是数字则返回真，否则返回假。如果
        参数是 undef 则返回 undef。前导和结尾的空格会被忽略。
        <literal>Inf</literal>和<literal>Infinity</literal>被视作数字。
        </para>
<!-- pgdoc-cn_end sig_en=24f525a3e9f19f8375286d673df32f70 -->
     </listitem>
    </varlistentry>

    <varlistentry>
<!-- pgdoc-cn_start sig_en=10ce69ff6071e2eb97fbd81587cc14dd sig_cn_org=None source=14.1 
     <term>
      <literal><function>is_array_ref(<replaceable>argument</replaceable>)</function></literal>
      <indexterm>
       <primary>is_array_ref</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
________________________________________________________-->
     <term>
      <literal><function>is_array_ref(<replaceable>argument</replaceable>)</function></literal>
      <indexterm>
       <primary>is_array_ref</primary>
       <secondary>in PL/Perl</secondary>
      </indexterm>
     </term>
<!-- pgdoc-cn_end sig_en=10ce69ff6071e2eb97fbd81587cc14dd -->
     <listitem>
<!-- pgdoc-cn_start sig_en=3c89a680e62c8827ef7620b9291f0acb sig_cn_org=None source=14.1 
      <para>
        Returns a true value if the given argument may be treated as an
        array reference, that is, if ref of the argument is <literal>ARRAY</literal> or
        <literal>PostgreSQL::InServer::ARRAY</literal>.  Returns false otherwise.
      </para>
________________________________________________________-->
      <para>
        如果给定参数可以被当作一个数组引用对待则返回真值，即该参数的定义为
        <literal>ARRAY</literal>或者<literal>PostgreSQL::InServer::ARRAY</literal>时返回
        真。否则返回假。
      </para>
<!-- pgdoc-cn_end sig_en=3c89a680e62c8827ef7620b9291f0acb -->
     </listitem>
    </varlistentry>

   </variablelist>
  </sect2>
 </sect1>

 <sect1 id="plperl-global">
<!-- pgdoc-cn_start sig_en=1d42d64aaa725ceaeb5b0b441739b8d5 sig_cn_org=None source=14.1 
  <title>Global Values in PL/Perl</title>
________________________________________________________-->
  <title>PL/Perl 中的全局值</title>
<!-- pgdoc-cn_end sig_en=1d42d64aaa725ceaeb5b0b441739b8d5 -->

<!-- pgdoc-cn_start sig_en=eb32bfacd81056df6081de20205735eb sig_cn_org=None source=14.1 
  <para>
    You can use the global hash <varname>%_SHARED</varname> to store
    data, including code references, between function calls for the
    lifetime of the current session.
  </para>
________________________________________________________-->
  <para>
    可以在函数调用之间或者当前会话的生命期中用全局哈希
    <varname>%_SHARED</varname>来存储数据，包括代码引用。
  </para>
<!-- pgdoc-cn_end sig_en=eb32bfacd81056df6081de20205735eb -->

<!-- pgdoc-cn_start sig_en=5da4a333f15ef06fcff190af29860557 sig_cn_org=None source=14.1 
  <para>
    Here is a simple example for shared data:
<programlisting>
CREATE OR REPLACE FUNCTION set_var(name text, val text) RETURNS text AS $$
    if ($_SHARED{$_[0]} = $_[1]) {
        return 'ok';
    } else {
        return "cannot set shared variable $_[0] to $_[1]";
    }
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION get_var(name text) RETURNS text AS $$
    return $_SHARED{$_[0]};
$$ LANGUAGE plperl;

SELECT set_var('sample', 'Hello, PL/Perl!  How''s tricks?');
SELECT get_var('sample');
</programlisting>
  </para>
________________________________________________________-->
  <para>
    这是共享数据的一个简单例子：
<programlisting>
CREATE OR REPLACE FUNCTION set_var(name text, val text) RETURNS text AS $$
    if ($_SHARED{$_[0]} = $_[1]) {
        return 'ok';
    } else {
        return "cannot set shared variable $_[0] to $_[1]";
    }
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION get_var(name text) RETURNS text AS $$
    return $_SHARED{$_[0]};
$$ LANGUAGE plperl;

SELECT set_var('sample', 'Hello, PL/Perl!  How''s tricks?');
SELECT get_var('sample');
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=5da4a333f15ef06fcff190af29860557 -->

<!-- pgdoc-cn_start sig_en=9cff42cc414c0cd99d74d8daeba19696 sig_cn_org=None source=14.1 
  <para>
   Here is a slightly more complicated example using a code reference:

<programlisting>
CREATE OR REPLACE FUNCTION myfuncs() RETURNS void AS $$
    $_SHARED{myquote} = sub {
        my $arg = shift;
        $arg =~ s/(['\\])/\\$1/g;
        return "'$arg'";
    };
$$ LANGUAGE plperl;

SELECT myfuncs(); /* initializes the function */

/* Set up a function that uses the quote function */

CREATE OR REPLACE FUNCTION use_quote(TEXT) RETURNS text AS $$
    my $text_to_quote = shift;
    my $qfunc = $_SHARED{myquote};
    return &amp;$qfunc($text_to_quote);
$$ LANGUAGE plperl;
</programlisting>

   (You could have replaced the above with the one-liner
   <literal>return $_SHARED{myquote}-&gt;($_[0]);</literal>
   at the expense of readability.)
  </para>
________________________________________________________-->
  <para>
   这是一个使用代码引用的稍微复杂一点的例子：

<programlisting>
CREATE OR REPLACE FUNCTION myfuncs() RETURNS void AS $$
    $_SHARED{myquote} = sub {
        my $arg = shift;
        $arg =~ s/(['\\])/\\$1/g;
        return "'$arg'";
    };
$$ LANGUAGE plperl;

SELECT myfuncs(); /* 初始化函数 */

/* 设置一个使用引用函数的函数 */

CREATE OR REPLACE FUNCTION use_quote(TEXT) RETURNS text AS $$
    my $text_to_quote = shift;
    my $qfunc = $_SHARED{myquote};
    return &amp;$qfunc($text_to_quote);
$$ LANGUAGE plperl;
</programlisting>

   （你可以把上面的代码用一行
   <literal>return $_SHARED{myquote}-&gt;($_[0]);</literal>替换，
   代价是牺牲了可读性）。
  </para>
<!-- pgdoc-cn_end sig_en=9cff42cc414c0cd99d74d8daeba19696 -->

<!-- pgdoc-cn_start sig_en=c20b13732d90c58673f43ea1bb582692 sig_cn_org=d36bdecfc9dd737a76d68fb7f60601fc source=15.7 
  <para>
   For security reasons, PL/Perl executes functions called by any one SQL role
   in a separate Perl interpreter for that role.  This prevents accidental or
   malicious interference by one user with the behavior of another user's
   PL/Perl functions.  Each such interpreter has its own value of the
   <varname>%_SHARED</varname> variable and other global state.  Thus, two
   PL/Perl functions will share the same value of <varname>%_SHARED</varname>
   if and only if they are executed by the same SQL role.  In an application
   wherein a single session executes code under multiple SQL roles (via
   <literal>SECURITY DEFINER</literal> functions, use of <command>SET ROLE</command>, etc.)
   you may need to take explicit steps to ensure that PL/Perl functions can
   share data via <varname>%_SHARED</varname>.  To do that, make sure that
   functions that should communicate are owned by the same user, and mark
   them <literal>SECURITY DEFINER</literal>.  You must of course take care that
   such functions can't be used to do anything unintended.
  </para>
________________________________________________________-->
  <para>
   出于安全原因，PL/Perl为每个SQL角色调用的函数在一个单独的Perl解释器中执行。
   这可以防止一个用户意外或恶意干扰另一个用户的PL/Perl函数的行为。
   每个这样的解释器都有自己的<varname>%_SHARED</varname>变量和其他全局状态。
   因此，只有当两个PL/Perl函数由相同的SQL角色执行时，它们才会共享<varname>%_SHARED</varname>的值。
   在一个应用程序中，一个会话通过多个SQL角色执行代码（通过<literal>SECURITY DEFINER</literal>函数、
   使用<command>SET ROLE</command>等），您可能需要采取明确的步骤来确保PL/Perl函数可以通过
   <varname>%_SHARED</varname>共享数据。为此，请确保应该通信的函数由同一用户拥有，并标记为
   <literal>SECURITY DEFINER</literal>。当然，您必须小心确保这些函数不能被用于执行任何意外操作。
</para>
<!-- pgdoc-cn_end sig_en=c20b13732d90c58673f43ea1bb582692 -->
 </sect1>

 <sect1 id="plperl-trusted">
<!-- pgdoc-cn_start sig_en=01c880d947b541db1cc4dcb3786e9f05 sig_cn_org=None source=14.1 
  <title>Trusted and Untrusted PL/Perl</title>
________________________________________________________-->
  <title>可信的和不可信的 PL/Perl</title>
<!-- pgdoc-cn_end sig_en=01c880d947b541db1cc4dcb3786e9f05 -->

<!-- pgdoc-cn_start sig_en=89ba86cdfa2c11903811cfe8edab682e sig_cn_org=None source=14.1 
  <indexterm zone="plperl-trusted">
   <primary>trusted</primary>
   <secondary>PL/Perl</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="plperl-trusted">
   <primary>trusted</primary>
   <secondary>PL/Perl</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=89ba86cdfa2c11903811cfe8edab682e -->

<!-- pgdoc-cn_start sig_en=75d37102168a2d4acd092c31c8f33dd2 sig_cn_org=None source=14.1 
  <para>
   Normally, PL/Perl is installed as a <quote>trusted</quote> programming
   language named <literal>plperl</literal>.  In this setup, certain Perl
   operations are disabled to preserve security.  In general, the
   operations that are restricted are those that interact with the
   environment. This includes file handle operations,
   <literal>require</literal>, and <literal>use</literal> (for
   external modules).  There is no way to access internals of the
   database server process or to gain OS-level access with the
   permissions of the server process,
   as a C function can do.  Thus, any unprivileged database user can
   be permitted to use this language.
  </para>
________________________________________________________-->
  <para>
   通常，PL/Perl 被作为一种<quote>可信的</quote>编程语言安装，其名称
   为<literal>plperl</literal>。在这种设置下，为了保持安全性禁用了某些
   Perl 操作。一般来说，被限制的操作是那些与环境交互的操作。它们
   包括文件处理操作、<literal>require</literal>以及
   <literal>use</literal>（外部模块）。没有办法像 C 函数那样访问
   数据库服务器进程的内部或者用服务器进程的权限得到 OS 级别的访问。
   因此，任何没有特权的数据库用户也被允许使用这种语言。
  </para>
<!-- pgdoc-cn_end sig_en=75d37102168a2d4acd092c31c8f33dd2 -->

<!-- pgdoc-cn_start sig_en=d9ef94fffa105f954be0e32f9f9128a0 sig_cn_org=None source=14.1 
  <para>
   Here is an example of a function that will not work because file
   system operations are not allowed for security reasons:
<programlisting>
CREATE FUNCTION badfunc() RETURNS integer AS $$
    my $tmpfile = "/tmp/badfile";
    open my $fh, '&gt;', $tmpfile
        or elog(ERROR, qq{could not open the file "$tmpfile": $!});
    print $fh "Testing writing to a file\n";
    close $fh or elog(ERROR, qq{could not close the file "$tmpfile": $!});
    return 1;
$$ LANGUAGE plperl;
</programlisting>
    The creation of this function will fail as its use of a forbidden
    operation will be caught by the validator.
  </para>
________________________________________________________-->
  <para>
   下面例子中的函数将无法工作，因为出于安全原因不允许它做文件操作：
<programlisting>
CREATE FUNCTION badfunc() RETURNS integer AS $$
    my $tmpfile = "/tmp/badfile";
    open my $fh, '&gt;', $tmpfile
        or elog(ERROR, qq{could not open the file "$tmpfile": $!});
    print $fh "Testing writing to a file\n";
    close $fh or elog(ERROR, qq{could not close the file "$tmpfile": $!});
    return 1;
$$ LANGUAGE plperl;
</programlisting>
    这个函数的创建会失败，因为验证器会捕捉到它使用了禁用的操作。
  </para>
<!-- pgdoc-cn_end sig_en=d9ef94fffa105f954be0e32f9f9128a0 -->

<!-- pgdoc-cn_start sig_en=d69f39b7d3bba38664a03223adb52684 sig_cn_org=None source=14.1 
  <para>
   Sometimes it is desirable to write Perl functions that are not
   restricted.  For example, one might want a Perl function that sends
   mail.  To handle these cases, PL/Perl can also be installed as an
   <quote>untrusted</quote> language (usually called
   <application>PL/PerlU</application><indexterm><primary>PL/PerlU</primary></indexterm>).
   In this case the full Perl language is available.  When installing the
   language, the language name <literal>plperlu</literal> will select
   the untrusted PL/Perl variant.
  </para>
________________________________________________________-->
  <para>
   有些时候需要编写不受限制的 Perl 函数。例如，我们可能想要一个能发送
   电子邮件的 Perl 函数。要处理这些情况，可以把 PL/Perl 安装成一种
   <quote>不可信的</quote>语言（通常被称作
   <application>PL/PerlU</application><indexterm><primary>PL/PerlU</primary></indexterm>）。
   在这种情况下整个 Perl 语言的特性都可以使用。在安装语言时，用语言
   名称<literal>plperlu</literal>将会选择不可信的 PL/Perl 变体。
  </para>
<!-- pgdoc-cn_end sig_en=d69f39b7d3bba38664a03223adb52684 -->

<!-- pgdoc-cn_start sig_en=ad7a64310525acdad009abf7592e7364 sig_cn_org=None source=14.1 
  <para>
   The writer of a <application>PL/PerlU</application> function must take care that the function
   cannot be used to do anything unwanted, since it will be able to do
   anything that could be done by a user logged in as the database
   administrator.  Note that the database system allows only database
   superusers to create functions in untrusted languages.
  </para>
________________________________________________________-->
  <para>
   <application>PL/PerlU</application>函数的编写者必须注意该函数不能被用来做
   其设计目的之外的事情，因为该函数能做一个作为数据库管理员登录的用户
   可以做的任何事情。注意数据库系统只允许数据库超级用户用不可信语言
   创建函数。
  </para>
<!-- pgdoc-cn_end sig_en=ad7a64310525acdad009abf7592e7364 -->

<!-- pgdoc-cn_start sig_en=3dc7c893aabdaf4a554598fecfe52a3d sig_cn_org=None source=14.1 
  <para>
   If the above function was created by a superuser using the language
   <literal>plperlu</literal>, execution would succeed.
  </para>
________________________________________________________-->
  <para>
   如果上述函数是一个超级用户用语言<literal>plperlu</literal>创建的，则可以
   执行成功。
  </para>
<!-- pgdoc-cn_end sig_en=3dc7c893aabdaf4a554598fecfe52a3d -->

<!-- pgdoc-cn_start sig_en=8d164465aac0aa82ee271950e1c87d17 sig_cn_org=None source=14.1 
  <para>
   In the same way, anonymous code blocks written in Perl can use
   restricted operations if the language is specified as
   <literal>plperlu</literal> rather than <literal>plperl</literal>, but the caller
   must be a superuser.
  </para>
________________________________________________________-->
  <para>
   以和<literal>plperl</literal>语言同样的方式，可以用<literal>plperlu</literal>
   编写 Perl 中的匿名代码块，这样的代码块能够使用受限的操作，不过调用
   者必须是超级用户。
  </para>
<!-- pgdoc-cn_end sig_en=8d164465aac0aa82ee271950e1c87d17 -->

  <note>
<!-- pgdoc-cn_start sig_en=6c1e3b6832ab72bb892b0dd7a357377e sig_cn_org=None source=14.1 
   <para>
    While <application>PL/Perl</application> functions run in a separate Perl
    interpreter for each SQL role, all <application>PL/PerlU</application> functions
    executed in a given session run in a single Perl interpreter (which is
    not any of the ones used for <application>PL/Perl</application> functions).
    This allows <application>PL/PerlU</application> functions to share data freely,
    but no communication can occur between <application>PL/Perl</application> and
    <application>PL/PerlU</application> functions.
   </para>
________________________________________________________-->
   <para>
    虽然对每个 SQL 角色会在一个独立的 Perl 解释器中运行
    <application>PL/Perl</application>函数，但是在一个给定会话中执行的所有
    <application>PL/PerlU</application>函数都运行在一个 Perl 解释器中（与用于
    任何<application>PL/Perl</application>函数的解释器不同）。这允许
    <application>PL/PerlU</application>函数自由地共享数据，但是
    <application>PL/Perl</application>和<application>PL/PerlU</application>函数之间不会
    发生任何交流。
   </para>
<!-- pgdoc-cn_end sig_en=6c1e3b6832ab72bb892b0dd7a357377e -->
  </note>

  <note>
<!-- pgdoc-cn_start sig_en=b1a3c5835531fc83fca3b1dacfa5a580 sig_cn_org=None source=14.1 
   <para>
    Perl cannot support multiple interpreters within one process unless
    it was built with the appropriate flags, namely either
    <literal>usemultiplicity</literal> or <literal>useithreads</literal>.
    (<literal>usemultiplicity</literal> is preferred unless you actually need
    to use threads.  For more details, see the
    <citerefentry><refentrytitle>perlembed</refentrytitle></citerefentry> man page.)
    If <application>PL/Perl</application> is used with a copy of Perl that was not built
    this way, then it is only possible to have one Perl interpreter per
    session, and so any one session can only execute either
    <application>PL/PerlU</application> functions, or <application>PL/Perl</application> functions
    that are all called by the same SQL role.
   </para>
________________________________________________________-->
   <para>
    Perl 不支持一个进程中的多个解释器，除非编译它时使用了合适的标志，
    即<literal>usemultiplicity</literal>或者<literal>useithreads</literal>（
    <literal>usemultiplicity</literal>会更好，除非你确实需要使用线程。更多细节，
    请见<citerefentry><refentrytitle>perlembed</refentrytitle></citerefentry>手册页）。
    如果<application>PL/Perl</application>用的是一份没有这样编译的 Perl 拷贝，那么
    在每个会话中只能有一个 Perl 解释器，并且因此任一会话只能要么执行
    <application>PL/PerlU</application>函数，要么执行同一个 SQL 角色调用的
    <application>PL/Perl</application>函数。
   </para>
<!-- pgdoc-cn_end sig_en=b1a3c5835531fc83fca3b1dacfa5a580 -->
  </note>

 </sect1>

 <sect1 id="plperl-triggers">
<!-- pgdoc-cn_start sig_en=e71bcd7e7977737d8790232ca1cc1874 sig_cn_org=None source=14.1 
  <title>PL/Perl Triggers</title>
________________________________________________________-->
  <title>PL/Perl 触发器</title>
<!-- pgdoc-cn_end sig_en=e71bcd7e7977737d8790232ca1cc1874 -->

<!-- pgdoc-cn_start sig_en=9d39ec9906bad70d4685c2a2363c737b sig_cn_org=None source=14.1 
  <para>
   PL/Perl can be used to write trigger functions.  In a trigger function,
   the hash reference <varname>$_TD</varname> contains information about the
   current trigger event. <varname>$_TD</varname> is a global variable,
   which gets a separate local value for each invocation of the trigger.
   The fields of the <varname>$_TD</varname> hash reference are:

   <variablelist>
    <varlistentry>
     <term><literal>$_TD-&gt;{new}{foo}</literal></term>
     <listitem>
      <para>
       <literal>NEW</literal> value of column <literal>foo</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{old}{foo}</literal></term>
     <listitem>
      <para>
       <literal>OLD</literal> value of column <literal>foo</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{name}</literal></term>
     <listitem>
      <para>
       Name of the trigger being called
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{event}</literal></term>
     <listitem>
      <para>
       Trigger event: <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, <literal>TRUNCATE</literal>, or <literal>UNKNOWN</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{when}</literal></term>
     <listitem>
      <para>
       When the trigger was called: <literal>BEFORE</literal>,
       <literal>AFTER</literal>, <literal>INSTEAD OF</literal>, or
       <literal>UNKNOWN</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{level}</literal></term>
     <listitem>
      <para>
       The trigger level: <literal>ROW</literal>, <literal>STATEMENT</literal>, or <literal>UNKNOWN</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{relid}</literal></term>
     <listitem>
      <para>
       OID of the table on which the trigger fired
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{table_name}</literal></term>
     <listitem>
      <para>
       Name of the table on which the trigger fired
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{relname}</literal></term>
     <listitem>
      <para>
       Name of the table on which the trigger fired. This has been deprecated,
       and could be removed in a future release.
       Please use $_TD-&gt;{table_name} instead.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{table_schema}</literal></term>
     <listitem>
      <para>
       Name of the schema in which the table on which the trigger fired, is
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{argc}</literal></term>
     <listitem>
      <para>
       Number of arguments of the trigger function
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>@{$_TD-&gt;{args}}</literal></term>
     <listitem>
      <para>
       Arguments of the trigger function.  Does not exist if <literal>$_TD-&gt;{argc}</literal> is 0.
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>
________________________________________________________-->
  <para>
   PL/Perl 可以被用来编写触发器函数。在触发器函数中，哈希引用
   <varname>$_TD</varname>包含有关当前触发器事件的信息。
   <varname>$_TD</varname>是一个全局变量，对触发器的每一次调用它都会
   得到一个独立的本地值。<varname>$_TD</varname>哈希引用的域有：

   <variablelist>
    <varlistentry>
     <term><literal>$_TD-&gt;{new}{foo}</literal></term>
     <listitem>
      <para>
       列<literal>foo</literal>的<literal>NEW</literal>值
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{old}{foo}</literal></term>
     <listitem>
      <para>
       列<literal>foo</literal>的<literal>OLD</literal>值
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{name}</literal></term>
     <listitem>
      <para>
       要被调用的触发器的名称
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{event}</literal></term>
     <listitem>
      <para>
       触发器事件：<literal>INSERT</literal>、<literal>UPDATE</literal>、
       <literal>DELETE</literal>、<literal>TRUNCATE</literal>或者<literal>UNKNOWN</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{when}</literal></term>
     <listitem>
      <para>
       什么时候调用触发器：<literal>BEFORE</literal>、
       <literal>AFTER</literal>、<literal>INSTEAD OF</literal>或者
       <literal>UNKNOWN</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{level}</literal></term>
     <listitem>
      <para>
       触发器级别：<literal>ROW</literal>、<literal>STATEMENT</literal>或者<literal>UNKNOWN</literal>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{relid}</literal></term>
     <listitem>
      <para>
       触发器定义在其上的表的 OID
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{table_name}</literal></term>
     <listitem>
      <para>
       触发器定义在其上的表的名称
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{relname}</literal></term>
     <listitem>
      <para>
       触发器定义在其上的表的名称。这已经被废弃，并且可能会在
       未来的发布中被移除。请使用
       $_TD-&gt;{table_name}。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{table_schema}</literal></term>
     <listitem>
      <para>
       触发器定义在其上的表所在的模式的名称
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{argc}</literal></term>
     <listitem>
      <para>
       触发器函数的参数数目
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>@{$_TD-&gt;{args}}</literal></term>
     <listitem>
      <para>
       触发器函数的参数。如果<literal>$_TD-&gt;{argc}</literal>为 0 则不存在
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=9d39ec9906bad70d4685c2a2363c737b -->

<!-- pgdoc-cn_start sig_en=d35d2e4d5b01237a46d0a38d9169099c sig_cn_org=None source=14.1 
  <para>
   Row-level triggers can return one of the following:

   <variablelist>
    <varlistentry>
     <term><literal>return;</literal></term>
     <listitem>
      <para>
       Execute the operation
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>"SKIP"</literal></term>
     <listitem>
      <para>
       Don't execute the operation
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>"MODIFY"</literal></term>
     <listitem>
      <para>
       Indicates that the <literal>NEW</literal> row was modified by
       the trigger function
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   行级触发器可以返回下列之一：

   <variablelist>
    <varlistentry>
     <term><literal>return;</literal></term>
     <listitem>
      <para>
       执行操作
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>"SKIP"</literal></term>
     <listitem>
      <para>
       不执行操作
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>"MODIFY"</literal></term>
     <listitem>
      <para>
       指示触发器函数修改了<literal>NEW</literal>行
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=d35d2e4d5b01237a46d0a38d9169099c -->

<!-- pgdoc-cn_start sig_en=113fa0afd41dc0a0b5c1b26c138f0c3d sig_cn_org=None source=14.1 
  <para>
   Here is an example of a trigger function, illustrating some of the
   above:
<programlisting>
CREATE TABLE test (
    i int,
    v varchar
);

CREATE OR REPLACE FUNCTION valid_id() RETURNS trigger AS $$
    if (($_TD-&gt;{new}{i} &gt;= 100) || ($_TD-&gt;{new}{i} &lt;= 0)) {
        return "SKIP";    # skip INSERT/UPDATE command
    } elsif ($_TD-&gt;{new}{v} ne "immortal") {
        $_TD-&gt;{new}{v} .= "(modified by trigger)";
        return "MODIFY";  # modify row and execute INSERT/UPDATE command
    } else {
        return;           # execute INSERT/UPDATE command
    }
$$ LANGUAGE plperl;

CREATE TRIGGER test_valid_id_trig
    BEFORE INSERT OR UPDATE ON test
    FOR EACH ROW EXECUTE FUNCTION valid_id();
</programlisting>
  </para>
________________________________________________________-->
  <para>
   这里是一个触发器函数的例子，展示上文所说的一些东西：
<programlisting>
CREATE TABLE test (
    i int,
    v varchar
);

CREATE OR REPLACE FUNCTION valid_id() RETURNS trigger AS $$
    if (($_TD-&gt;{new}{i} &gt;= 100) || ($_TD-&gt;{new}{i} &lt;= 0)) {
        return "SKIP";    # skip INSERT/UPDATE command
    } elsif ($_TD-&gt;{new}{v} ne "immortal") {
        $_TD-&gt;{new}{v} .= "(modified by trigger)";
        return "MODIFY";  # 修改行并且执行 INSERT/UPDATE 命令
    } else {
        return;           # 执行 INSERT/UPDATE 命令
    }
$$ LANGUAGE plperl;

CREATE TRIGGER test_valid_id_trig
    BEFORE INSERT OR UPDATE ON test
    FOR EACH ROW EXECUTE FUNCTION valid_id();
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=113fa0afd41dc0a0b5c1b26c138f0c3d -->
 </sect1>

 <sect1 id="plperl-event-triggers">
<!-- pgdoc-cn_start sig_en=15ca8f41ab8ddb9570d54cb4effcf4de sig_cn_org=None source=14.1 
  <title>PL/Perl Event Triggers</title>
________________________________________________________-->
  <title>PL/Perl 事件触发器</title>
<!-- pgdoc-cn_end sig_en=15ca8f41ab8ddb9570d54cb4effcf4de -->

<!-- pgdoc-cn_start sig_en=40e1c6f219a2449c0bc12ba81cde0bff sig_cn_org=None source=14.1 
  <para>
   PL/Perl can be used to write event trigger functions.  In an event trigger
   function, the hash reference <varname>$_TD</varname> contains information
   about the current trigger event.  <varname>$_TD</varname> is a global variable,
   which gets a separate local value for each invocation of the trigger.  The
   fields of the <varname>$_TD</varname> hash reference are:

   <variablelist>
    <varlistentry>
     <term><literal>$_TD-&gt;{event}</literal></term>
     <listitem>
      <para>
       The name of the event the trigger is fired for.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{tag}</literal></term>
     <listitem>
      <para>
       The command tag for which the trigger is fired.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   PL/Perl 可以被用来编写事件触发器函数。在事件触发器函数中，哈希引用
   <varname>$_TD</varname>包含有关当前触发器事件的信息。
   <varname>$_TD</varname>是一个全局变量，对触发器的每一次调用它都会
   得到一个独立的本地值。<varname>$_TD</varname>哈希引用的域有：

   <variablelist>
    <varlistentry>
     <term><literal>$_TD-&gt;{event}</literal></term>
     <listitem>
      <para>
       触发器为其触发的事件名称。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{tag}</literal></term>
     <listitem>
      <para>
       触发器为其触发的命令标签。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=40e1c6f219a2449c0bc12ba81cde0bff -->

<!-- pgdoc-cn_start sig_en=d5ba7bb3ba9f6e0ad1843167b90c365e sig_cn_org=None source=14.1 
  <para>
   The return value of the trigger function is ignored.
  </para>
________________________________________________________-->
  <para>
   触发器函数的返回值会被忽略。
  </para>
<!-- pgdoc-cn_end sig_en=d5ba7bb3ba9f6e0ad1843167b90c365e -->

<!-- pgdoc-cn_start sig_en=9238a89289cd60ddd621793aebc339b0 sig_cn_org=None source=14.1 
  <para>
   Here is an example of an event trigger function, illustrating some of the
   above:
<programlisting>
CREATE OR REPLACE FUNCTION perlsnitch() RETURNS event_trigger AS $$
  elog(NOTICE, "perlsnitch: " . $_TD->{event} . " " . $_TD->{tag} . " ");
$$ LANGUAGE plperl;

CREATE EVENT TRIGGER perl_a_snitch
    ON ddl_command_start
    EXECUTE FUNCTION perlsnitch();
</programlisting>
  </para>
________________________________________________________-->
  <para>
   这里是一个事件触发器函数的例子，展示了上文所说的一些东西：
<programlisting>
CREATE OR REPLACE FUNCTION perlsnitch() RETURNS event_trigger AS $$
  elog(NOTICE, "perlsnitch: " . $_TD->{event} . " " . $_TD->{tag} . " ");
$$ LANGUAGE plperl;

CREATE EVENT TRIGGER perl_a_snitch
    ON ddl_command_start
    EXECUTE FUNCTION perlsnitch();
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=9238a89289cd60ddd621793aebc339b0 -->
 </sect1>

 <sect1 id="plperl-under-the-hood">
<!-- pgdoc-cn_start sig_en=4d06bab2d611ab0340fb29d74856de41 sig_cn_org=None source=14.1 
  <title>PL/Perl Under the Hood</title>
________________________________________________________-->
  <title>PL/Perl 下面的东西</title>
<!-- pgdoc-cn_end sig_en=4d06bab2d611ab0340fb29d74856de41 -->

 <sect2 id="plperl-config">
<!-- pgdoc-cn_start sig_en=78fd6ae8f68f7c009e14488907792dde sig_cn_org=None source=14.1 
  <title>Configuration</title>
________________________________________________________-->
  <title>配置</title>
<!-- pgdoc-cn_end sig_en=78fd6ae8f68f7c009e14488907792dde -->

<!-- pgdoc-cn_start sig_en=be6f43ab984d36079a02f71cebcddd3d sig_cn_org=None source=14.1 
  <para>
  This section lists configuration parameters that affect <application>PL/Perl</application>.
  </para>
________________________________________________________-->
  <para>
  这一节列出了影响<application>PL/Perl</application>的配置参数。
  </para>
<!-- pgdoc-cn_end sig_en=be6f43ab984d36079a02f71cebcddd3d -->

  <variablelist>

     <varlistentry id="guc-plperl-on-init" xreflabel="plperl.on_init">
<!-- pgdoc-cn_start sig_en=d5345d1e7d22aea9a19d25537454db81 sig_cn_org=None source=14.1 
      <term>
       <varname>plperl.on_init</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>plperl.on_init</varname> configuration parameter</primary>
      </indexterm>
      </term>
________________________________________________________-->
      <term>
       <varname>plperl.on_init</varname> (<type>string</type>)
      <indexterm>
       <primary><varname>plperl.on_init</varname> 配置参数</primary>
      </indexterm>
      </term>
<!-- pgdoc-cn_end sig_en=d5345d1e7d22aea9a19d25537454db81 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=3533e02457a0db01901ccf27fbd86925 sig_cn_org=None source=14.1 
       <para>
        Specifies Perl code to be executed when a Perl interpreter is first
        initialized, before it is specialized for use by <literal>plperl</literal> or
        <literal>plperlu</literal>.
        The SPI functions are not available when this code is executed.
        If the code fails with an error it will abort the initialization of
        the interpreter and propagate out to the calling query, causing the
        current transaction or subtransaction to be aborted.
       </para>
________________________________________________________-->
       <para>
        指定当第一次初始化一个 Perl 解释器时要执行的 Perl 代码，这会在
        具体用于<literal>plperl</literal>或<literal>plperlu</literal>之前做完。当
        这段代码被执行时 SPI 函数不可用。如果该代码由于错误失败，它
        将中止解释器的初始化并且把错误传播到调用查询，最终导致当前
        事务或者子事务被中止。
       </para>
<!-- pgdoc-cn_end sig_en=3533e02457a0db01901ccf27fbd86925 -->
<!-- pgdoc-cn_start sig_en=91f3f7ee2cb40c14e8c412a4af209ee6 sig_cn_org=None source=14.1 
       <para>
       The Perl code is limited to a single string. Longer code can be placed
       into a module and loaded by the <literal>on_init</literal> string.
       Examples:
<programlisting>
plperl.on_init = 'require "plperlinit.pl"'
plperl.on_init = 'use lib "/my/app"; use MyApp::PgInit;'
</programlisting>
       </para>
________________________________________________________-->
       <para>
       该 Perl 代码被限制为一个单一的字符串。更长的代码可以放在一个
       模块中，然后由<literal>on_init</literal>字符串载入。例子：
<programlisting>
plperl.on_init = 'require "plperlinit.pl"'
plperl.on_init = 'use lib "/my/app"; use MyApp::PgInit;'
</programlisting>
       </para>
<!-- pgdoc-cn_end sig_en=91f3f7ee2cb40c14e8c412a4af209ee6 -->
<!-- pgdoc-cn_start sig_en=c10ecb2a5c3cc5b27d99c5c0d18b0246 sig_cn_org=None source=14.1 
       <para>
       Any modules loaded by <literal>plperl.on_init</literal>, either directly or
       indirectly, will be available for use by <literal>plperl</literal>.  This may
       create a security risk. To see what modules have been loaded you can use:
<programlisting>
DO 'elog(WARNING, join ", ", sort keys %INC)' LANGUAGE plperl;
</programlisting>
       </para>
________________________________________________________-->
       <para>
       任何被<literal>plperl.on_init</literal>载入的模块（不管是直接还是间接）都
       可以被<literal>plperl</literal>使用。这可能会导致安全性风险。要看哪些模块
       已经被载入，可以使用：
<programlisting>
DO 'elog(WARNING, join ", ", sort keys %INC)' LANGUAGE plperl;
</programlisting>
       </para>
<!-- pgdoc-cn_end sig_en=c10ecb2a5c3cc5b27d99c5c0d18b0246 -->
<!-- pgdoc-cn_start sig_en=ec4c9f1c20221cc5025970c5f03deb73 sig_cn_org=None source=14.1 
       <para>
        Initialization will happen in the postmaster if the <literal>plperl</literal> library is
        included in <xref linkend="guc-shared-preload-libraries"/>, in which
        case extra consideration should be given to the risk of destabilizing
        the postmaster.  The principal reason for making use of this feature
        is that Perl modules loaded by <literal>plperl.on_init</literal> need be
        loaded only at postmaster start, and will be instantly available
        without loading overhead in individual database sessions.  However,
        keep in mind that the overhead is avoided only for the first Perl
        interpreter used by a database session &mdash; either PL/PerlU, or
        PL/Perl for the first SQL role that calls a PL/Perl function.  Any
        additional Perl interpreters created in a database session will have
        to execute <literal>plperl.on_init</literal> afresh.  Also, on Windows there
        will be no savings whatsoever from preloading, since the Perl
        interpreter created in the postmaster process does not propagate to
        child processes.
       </para>
________________________________________________________-->
       <para>
        如果 plperl 库被包括在<xref linkend="guc-shared-preload-libraries"/>
        中，那么初始化将发生在 postmaster 中，在这种情况下要特别地考虑对
        postmaster 带来的不稳定风险。使用这种特性的主要原因是，
        <literal>plperl.on_init</literal>载入的 Perl 模块只需要在 postmaster 开始时
        被载入，并且在数据库会话中不需要任何工作就立刻可用。不过，要记住这
        只免除了一个数据库会话中使用的第一个 Perl 解释器的负载 &mdash; 不管
        是 PL/PerlU 还是用于第一个 SQL 角色调用 PL/Perl 函数的 PL/Perl。在一个
        数据库会话中创建的任何额外的 Perl 解释器将不得不重新执行
        <literal>plperl.on_init</literal>。还有，在 Windows 上无论从什么里面进行
        预先载入，都不会有这种节约，因为在 postmaster 进程中创建的 Perl 解释器
        不会传播到子进程中。
       </para>
<!-- pgdoc-cn_end sig_en=ec4c9f1c20221cc5025970c5f03deb73 -->
<!-- pgdoc-cn_start sig_en=b16168872a36109ed9754785a3c7697b sig_cn_org=None source=14.1 
       <para>
       This parameter can only be set in the <filename>postgresql.conf</filename> file or on the server command line.
       </para>
________________________________________________________-->
       <para>
       这个参数只能在<filename>postgresql.conf</filename>文件或者服务器命令中设置。
       </para>
<!-- pgdoc-cn_end sig_en=b16168872a36109ed9754785a3c7697b -->
      </listitem>
     </varlistentry>

     <varlistentry id="guc-plperl-on-plperl-init" xreflabel="plperl.on_plperl_init">
<!-- pgdoc-cn_start sig_en=b5b722efc213c131250ba139184b8bce sig_cn_org=None source=14.1 
      <term>
       <varname>plperl.on_plperl_init</varname> (<type>string</type>)
       <indexterm>
        <primary><varname>plperl.on_plperl_init</varname> configuration parameter</primary>
       </indexterm>
      </term>
________________________________________________________-->
      <term>
       <varname>plperl.on_plperl_init</varname> (<type>string</type>)
       <indexterm>
        <primary><varname>plperl.on_plperl_init</varname> 配置参数</primary>
       </indexterm>
      </term>
<!-- pgdoc-cn_end sig_en=b5b722efc213c131250ba139184b8bce -->
<!-- pgdoc-cn_start sig_en=470ac39a78b5b62f7484f1f3f58c9d7e sig_cn_org=None source=14.1 
      <term>
       <varname>plperl.on_plperlu_init</varname> (<type>string</type>)
       <indexterm>
        <primary><varname>plperl.on_plperlu_init</varname> configuration parameter</primary>
       </indexterm>
      </term>
________________________________________________________-->
      <term>
       <varname>plperl.on_plperlu_init</varname> (<type>string</type>)
       <indexterm>
        <primary><varname>plperl.on_plperlu_init</varname> 配置参数</primary>
       </indexterm>
      </term>
<!-- pgdoc-cn_end sig_en=470ac39a78b5b62f7484f1f3f58c9d7e -->
      <listitem>
<!-- pgdoc-cn_start sig_en=73ab429154c8ec185fb36dcafc5c7ff4 sig_cn_org=None source=14.1 
       <para>
        These parameters specify Perl code to be executed when a Perl
        interpreter is specialized for <literal>plperl</literal> or
        <literal>plperlu</literal> respectively.  This will happen when a PL/Perl or
        PL/PerlU function is first executed in a database session, or when
        an additional interpreter has to be created because the other language
        is called or a PL/Perl function is called by a new SQL role.  This
        follows any initialization done by <literal>plperl.on_init</literal>.
        The SPI functions are not available when this code is executed.
        The Perl code in <literal>plperl.on_plperl_init</literal> is executed after
        <quote>locking down</quote> the interpreter, and thus it can only perform
        trusted operations.
       </para>
________________________________________________________-->
       <para>
        这些参数分别指定当为<literal>plperl</literal>或<literal>plperlu</literal>专门准备好
        一个 Perl 解释器时要执行的 Perl 代码。当一个 PL/Perl 或者 PL/PerlU 函数
        第一次在一个数据库会话中被执行时会发生这种动作，或者由于调用其他语言
        或者新的 SQL 角色调用 PL/Perl 函数导致创建额外的解释器时也会发生这种
        动作。这些初始化跟随着<literal>plperl.on_init</literal>所作的初始化。当这段
        代码被执行时，SPI 函数不可用。<literal>plperl.on_plperl_init</literal>中的 Perl
        代码在<quote>锁闭</quote>解释器之后被执行，因此它只能执行可信的操作。
       </para>
<!-- pgdoc-cn_end sig_en=73ab429154c8ec185fb36dcafc5c7ff4 -->
<!-- pgdoc-cn_start sig_en=994581efbaff45ccc0785be33b999763 sig_cn_org=None source=14.1 
       <para>
        If the code fails with an error it will abort the initialization and
        propagate out to the calling query, causing the current transaction or
        subtransaction to be aborted.  Any actions already done within Perl
        won't be undone; however, that interpreter won't be used again.
        If the language is used again the initialization will be attempted
        again within a fresh Perl interpreter.
       </para>
________________________________________________________-->
       <para>
        如果该代码由于错误失败，它将中止初始化并且把错误传播到调用查询，
        最终导致当前事务或者子事务被中止。在 Perl 中已经完成的任何动作都
        不会被撤销。不过，该解释器将不能被再次使用。如果再次使用该语言，
        将在一个新鲜的 Perl 解释器中再次尝试初始化。
       </para>
<!-- pgdoc-cn_end sig_en=994581efbaff45ccc0785be33b999763 -->
<!-- pgdoc-cn_start sig_en=5f871c53ab960b9b838dae53a79d5752 sig_cn_org=None source=14.1 
       <para>
        Only superusers can change these settings.  Although these settings
        can be changed within a session, such changes will not affect Perl
        interpreters that have already been used to execute functions.
       </para>
________________________________________________________-->
       <para>
        只有超级用户能够更改这些设置。尽管这些设置可以在会话中被修改，
        但是这类更改将不会影响已经被用来执行函数的 Perl 解释器。
       </para>
<!-- pgdoc-cn_end sig_en=5f871c53ab960b9b838dae53a79d5752 -->
      </listitem>
     </varlistentry>

     <varlistentry id="guc-plperl-use-strict" xreflabel="plperl.use_strict">
<!-- pgdoc-cn_start sig_en=0ad502764b4954511bf6e5d334e5df74 sig_cn_org=None source=14.1 
      <term>
       <varname>plperl.use_strict</varname> (<type>boolean</type>)
       <indexterm>
        <primary><varname>plperl.use_strict</varname> configuration parameter</primary>
       </indexterm>
      </term>
________________________________________________________-->
      <term>
       <varname>plperl.use_strict</varname> (<type>boolean</type>)
       <indexterm>
        <primary><varname>plperl.use_strict</varname> 配置参数</primary>
       </indexterm>
      </term>
<!-- pgdoc-cn_end sig_en=0ad502764b4954511bf6e5d334e5df74 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=8b4165da521685043923d1e7bcc52d27 sig_cn_org=None source=14.1 
       <para>
        When set true subsequent compilations of PL/Perl functions will have
        the <literal>strict</literal> pragma enabled.  This parameter does not affect
        functions already compiled in the current session.
       </para>
________________________________________________________-->
       <para>
        如果被设置为真，则后续的 PL/Perl 函数编译将会启用
        <literal>strict</literal>编译指示。这个参数不影响当前会话中已编译的函数。
       </para>
<!-- pgdoc-cn_end sig_en=8b4165da521685043923d1e7bcc52d27 -->
      </listitem>
     </varlistentry>

  </variablelist>
</sect2>

 <sect2 id="plperl-missing">
<!-- pgdoc-cn_start sig_en=ed825f36a5ecd8cfeeaba26f4d7324d0 sig_cn_org=None source=14.1 
  <title>Limitations and Missing Features</title>
________________________________________________________-->
  <title>限制和缺失的特性</title>
<!-- pgdoc-cn_end sig_en=ed825f36a5ecd8cfeeaba26f4d7324d0 -->

<!-- pgdoc-cn_start sig_en=09b9b5b384df1db3bdb56685dda6e0dc sig_cn_org=None source=14.1 
  <para>
   The following features are currently missing from PL/Perl, but they
   would make welcome contributions.

   <itemizedlist>
    <listitem>
     <para>
      PL/Perl functions cannot call each other directly.
     </para>
    </listitem>

    <listitem>
     <para>
      SPI is not yet fully implemented.
     </para>
    </listitem>

    <listitem>
     <para>
      If you are fetching very large data sets using
      <literal>spi_exec_query</literal>, you should be aware that
      these will all go into memory.  You can avoid this by using
      <literal>spi_query</literal>/<literal>spi_fetchrow</literal> as
      illustrated earlier.
     </para>
     <para>
        A similar problem occurs if a set-returning function passes a
        large set of rows back to PostgreSQL via <literal>return</literal>. You
        can avoid this problem too by instead using
        <literal>return_next</literal> for each row returned, as shown
        previously.
     </para>
    </listitem>

     <listitem>
      <para>
        When a session ends normally, not due to a fatal error, any
        <literal>END</literal> blocks that have been defined are executed.
        Currently no other actions are performed. Specifically,
        file handles are not automatically flushed and objects are
        not automatically destroyed.
      </para>
     </listitem>
   </itemizedlist>
  </para>
________________________________________________________-->
  <para>
   PL/Perl 中目前缺少下列特性，但是欢迎大家对此作出贡献。

   <itemizedlist>
    <listitem>
     <para>
      PL/Perl 函数不能直接调用彼此。
     </para>
    </listitem>

    <listitem>
     <para>
      SPI 还没有被完全实现。
     </para>
    </listitem>

    <listitem>
     <para>
      如果正在使用<literal>spi_exec_query</literal>取一个非常大的数据集，
      你应该注意它们都会进入到内存中。可以按先前所述，通过使用
      <literal>spi_query</literal>/<literal>spi_fetchrow</literal>来避免发生
      这类情况。
     </para>
     <para>
        如果一个集合返回函数通过<literal>return</literal>把一个大型的行集合
        返回给 PostgreSQL，同样会发生这种情况。同样如前所述，可以为每一个
        要返回的行使用<literal>return_next</literal>来避免这种问题。
     </para>
    </listitem>

     <listitem>
      <para>
        当会话正常结束（而不是由于致命错误结束）时，任何已经定义的
        <literal>END</literal>块将被执行。当前不会执行其他动作。特别地，
        此时文件句柄不会被自动刷写并且对象不会被自动销毁。
      </para>
     </listitem>
   </itemizedlist>
  </para>
<!-- pgdoc-cn_end sig_en=09b9b5b384df1db3bdb56685dda6e0dc -->
 </sect2>

 </sect1>

</chapter>
