<!-- doc/src/sgml/ecpg.sgml -->

<chapter id="ecpg">
<!-- pgdoc-cn_start sig_en=58a57089485298f047d80de5c6f88c2d sig_cn_org=None source=14.1 
 <title><application>ECPG</application> &mdash; Embedded <acronym>SQL</acronym> in C</title>
________________________________________________________-->
 <title><application>ECPG</application> &mdash; C中的嵌入式 <acronym>SQL</acronym> </title>
<!-- pgdoc-cn_end sig_en=58a57089485298f047d80de5c6f88c2d -->

<!-- pgdoc-cn_start sig_en=66c883a51395dd8a7d016b7c7cb6f741 sig_cn_org=None source=14.1 
 <indexterm zone="ecpg"><primary>embedded SQL</primary><secondary>in C</secondary></indexterm>
________________________________________________________-->
 <indexterm zone="ecpg"><primary>embedded SQL</primary><secondary>in C</secondary></indexterm>
<!-- pgdoc-cn_end sig_en=66c883a51395dd8a7d016b7c7cb6f741 -->
<!-- pgdoc-cn_start sig_en=d9ab7c857c4567a0e5a64765e9dd7efa sig_cn_org=None source=14.1 
 <indexterm zone="ecpg"><primary>C</primary></indexterm>
________________________________________________________-->
 <indexterm zone="ecpg"><primary>C</primary></indexterm>
<!-- pgdoc-cn_end sig_en=d9ab7c857c4567a0e5a64765e9dd7efa -->
<!-- pgdoc-cn_start sig_en=ee148edcb331b8801d1506391b15f63b sig_cn_org=None source=14.1 
 <indexterm zone="ecpg"><primary>ECPG</primary></indexterm>
________________________________________________________-->
 <indexterm zone="ecpg"><primary>ECPG</primary></indexterm>
<!-- pgdoc-cn_end sig_en=ee148edcb331b8801d1506391b15f63b -->

<!-- pgdoc-cn_start sig_en=bc3a59467a8fb15b297cc79a8c4b7340 sig_cn_org=None source=14.1 
 <para>
  This chapter describes the embedded <acronym>SQL</acronym> package
  for <productname>PostgreSQL</productname>. It was written by
  Linus Tolke (<email>linus@epact.se</email>) and Michael Meskes
  (<email>meskes@postgresql.org</email>). Originally it was written to work with
  <acronym>C</acronym>. It also works with <acronym>C++</acronym>, but
  it does not recognize all <acronym>C++</acronym> constructs yet.
 </para>
________________________________________________________-->
 <para>
  这一章描述了用于<productname>PostgreSQL</productname>的嵌入式<acronym>SQL</acronym>包。它由 Linus Tolke（<email>linus@epact.se</email>）和 Michael Meskes（<email>meskes@postgresql.org</email>）编写。最初它是为了与<acronym>C</acronym>一起工作而编写的。它也能与<acronym>C++</acronym>配合，但是它还不识别所有的<acronym>C++</acronym>结构。
 </para>
<!-- pgdoc-cn_end sig_en=bc3a59467a8fb15b297cc79a8c4b7340 -->

<!-- pgdoc-cn_start sig_en=f1243fe48cc85f8e2a342d9fc369fdb1 sig_cn_org=None source=14.1 
 <para>
  This documentation is quite incomplete.  But since this
  interface is standardized, additional information can be found in
  many resources about SQL.
 </para>
________________________________________________________-->
 <para>
  这份文档还远没有完成。但是因为这个结构是标准化的，额外的信息可以在有关 SQL 的很多资源中找到。
 </para>
<!-- pgdoc-cn_end sig_en=f1243fe48cc85f8e2a342d9fc369fdb1 -->

 <sect1 id="ecpg-concept">
<!-- pgdoc-cn_start sig_en=d39b1e938230a934fd342b6491973c99 sig_cn_org=None source=14.1 
  <title>The Concept</title>
________________________________________________________-->
  <title>概念</title>
<!-- pgdoc-cn_end sig_en=d39b1e938230a934fd342b6491973c99 -->

<!-- pgdoc-cn_start sig_en=58942167003677bca415d4b9f82910c6 sig_cn_org=None source=14.1 
  <para>
   An embedded SQL program consists of code written in an ordinary
   programming language, in this case C, mixed with SQL commands in
   specially marked sections.  To build the program, the source code (<filename>*.pgc</filename>)
   is first passed through the embedded SQL preprocessor, which converts it
   to an ordinary C program (<filename>*.c</filename>), and afterwards it can be processed by a C
   compiler.  (For details about the compiling and linking see <xref linkend="ecpg-process"/>.)
   Converted ECPG applications call functions in the libpq library
   through the embedded SQL library (ecpglib), and communicate with
   the PostgreSQL server using the normal frontend-backend protocol.
  </para>
________________________________________________________-->
  <para>
   一个嵌入式 SQL 程序由一种普通编程语言编写的代码（在这里是 C）和位于特殊标记的小节中的 SQL 命令混合组成。
   要构建该程序，源代码（<filename>*.pgc</filename>）首先会通过嵌入式 SQL 预处理器，它会将源代码转换成一个普通 C 程序（<filename>*.c</filename>），并且后来它能够被一个 C 编译器所处理。（编译和链接详见<xref linkend="ecpg-process"/>。）
   转换过的 ECPG 应用会通过嵌入式 SQL 库（ecpglib）调用 libpq 库中的函数，并且与 PostgreSQL 服务器使用普通的前端/后端协议通信。
  </para>
<!-- pgdoc-cn_end sig_en=58942167003677bca415d4b9f82910c6 -->

<!-- pgdoc-cn_start sig_en=c2499ca4b92801083843b5ef510dfc1b sig_cn_org=None source=14.1 
  <para>
   Embedded <acronym>SQL</acronym> has advantages over other methods
   for handling <acronym>SQL</acronym> commands from C code. First, it
   takes care of the tedious passing of information to and from
   variables in your <acronym>C</acronym> program.  Second, the SQL
   code in the program is checked at build time for syntactical
   correctness.  Third, embedded <acronym>SQL</acronym> in C is
   specified in the <acronym>SQL</acronym> standard and supported by
   many other <acronym>SQL</acronym> database systems.  The
   <productname>PostgreSQL</productname> implementation is designed to match this
   standard as much as possible, and it is usually possible to port
   embedded <acronym>SQL</acronym> programs written for other SQL
   databases to <productname>PostgreSQL</productname> with relative
   ease.
  </para>
________________________________________________________-->
  <para>
   嵌入式<acronym>SQL</acronym>在为 C 代码处理<acronym>SQL</acronym>命令方面比起其他方法来具有优势。首先，它会搞定向你的<acronym>C</acronym>程序变量传递或者读取信息时的繁文缛节。其次，程序中的 SQL 代码在编译时就会被检查以保证语法正确性。第三，C 中的嵌入式<acronym>SQL</acronym>是在<acronym>SQL</acronym>标准中指定的并且受到很多其他<acronym>SQL</acronym>数据库系统的支持。<productname>PostgreSQL</productname>实现被设计为尽可能匹配这个标准，并且通常可以相对容易地把为其他 SQL 数据库编写的<acronym>SQL</acronym>程序移植到<productname>PostgreSQL</productname>。
  </para>
<!-- pgdoc-cn_end sig_en=c2499ca4b92801083843b5ef510dfc1b -->

<!-- pgdoc-cn_start sig_en=cf17db57729bf76484d28ad7acfdfa89 sig_cn_org=None source=14.1 
  <para>
   As already stated, programs written for the embedded
   <acronym>SQL</acronym> interface are normal C programs with special
   code inserted to perform database-related actions.  This special
   code always has the form:
<programlisting>
EXEC SQL ...;
</programlisting>
   These statements syntactically take the place of a C statement.
   Depending on the particular statement, they can appear at the
   global level or within a function.
  </para>
________________________________________________________-->
  <para>
   正如已经支出的，为嵌入式<acronym>SQL</acronym>接口编写的程序是插入了用于执行数据库相关动作的特殊代码的普通的 C 程序。这种特殊代码总是具有这样的形式：
<programlisting>
EXEC SQL ...;
</programlisting>
   这些语句在语法上取代了一个 C 语句。取决于特定的语句，它们可以出现在全局层面或者是一个函数中。
  </para>
<!-- pgdoc-cn_end sig_en=cf17db57729bf76484d28ad7acfdfa89 -->

<!-- pgdoc-cn_start sig_en=f5fe0dc9c9ab7958ea3e7e8cb7bac4e0 sig_cn_org=None source=14.1 
  <para>
   Embedded
   <acronym>SQL</acronym> statements follow the case-sensitivity rules of
   normal <acronym>SQL</acronym> code, and not those of C. Also they allow nested
   C-style comments as per the SQL standard. The C part of the
   program, however, follows the C standard of not accepting nested comments.
   Embedded <acronym>SQL</acronym> statements likewise use SQL rules, not
   C rules, for parsing quoted strings and identifiers.
   (See <xref linkend="sql-syntax-strings"/> and
   <xref linkend="sql-syntax-identifiers"/> respectively.  Note that
   ECPG assumes that <varname>standard_conforming_strings</varname>
   is <literal>on</literal>.)
   Of course, the C part of the program follows C quoting rules.
  </para>
________________________________________________________-->
  <para>
   内嵌的<acronym>SQL</acronym>语句遵循普通<acronym>SQL</acronym>代码的大小写敏感性规则，而不是 C 的大小写敏感性规则。
   它们也允许嵌套的遵循SQL标准的 C 风格注释。
   不过，程序的 C 部分遵循 C 的标准不接受嵌套注释。
   嵌入的<acronym>SQL</acronym>语句同样使用SQL规则，不是C规则，针对引用字符串和标识符的语法解析。
   (分别参见 <xref linkend="sql-syntax-strings"/> 和 <xref linkend="sql-syntax-identifiers"/> 。 请注意ECPG 假设 <varname>standard_conforming_strings</varname> 为 <literal>on</literal>.)
   当然, 程序的C部分遵循 C 引用规则。
  </para>
<!-- pgdoc-cn_end sig_en=f5fe0dc9c9ab7958ea3e7e8cb7bac4e0 -->

<!-- pgdoc-cn_start sig_en=ac367bff453f9c4f3c8582f558abc586 sig_cn_org=None source=14.1 
  <para>
   The following sections explain all the embedded SQL statements.
  </para>
________________________________________________________-->
  <para>
   下列小节解释了所有嵌入式 SQL 语句。
  </para>
<!-- pgdoc-cn_end sig_en=ac367bff453f9c4f3c8582f558abc586 -->
 </sect1>

 <sect1 id="ecpg-connect">
<!-- pgdoc-cn_start sig_en=a85965fda02782b7458b92dd156580be sig_cn_org=None source=14.1 
  <title>Managing Database Connections</title>
________________________________________________________-->
  <title>管理数据库连接</title>
<!-- pgdoc-cn_end sig_en=a85965fda02782b7458b92dd156580be -->

<!-- pgdoc-cn_start sig_en=c630699d6e9b3e2bc707a54f1cb6cdc1 sig_cn_org=None source=14.1 
  <para>
   This section describes how to open, close, and switch database
   connections.
  </para>
________________________________________________________-->
  <para>
   这一节描述如何打开、关闭以及切换数据库连接。
  </para>
<!-- pgdoc-cn_end sig_en=c630699d6e9b3e2bc707a54f1cb6cdc1 -->

  <sect2 id="ecpg-connecting">
<!-- pgdoc-cn_start sig_en=f6c8939a13bb834c2434010bc7cb6712 sig_cn_org=None source=14.1 
   <title>Connecting to the Database Server</title>
________________________________________________________-->
   <title>连接到数据库服务器</title>
<!-- pgdoc-cn_end sig_en=f6c8939a13bb834c2434010bc7cb6712 -->

<!-- pgdoc-cn_start sig_en=c7e6918dde78041d30b6221787a8925c sig_cn_org=None source=14.1 
  <para>
   One connects to a database using the following statement:
<programlisting>
EXEC SQL CONNECT TO <replaceable>target</replaceable> <optional>AS <replaceable>connection-name</replaceable></optional> <optional>USER <replaceable>user-name</replaceable></optional>;
</programlisting>
   The <replaceable>target</replaceable> can be specified in the
   following ways:

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>dbname</replaceable><optional>@<replaceable>hostname</replaceable></optional><optional>:<replaceable>port</replaceable></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>tcp:postgresql://<replaceable>hostname</replaceable><optional>:<replaceable>port</replaceable></optional><optional>/<replaceable>dbname</replaceable></optional><optional>?<replaceable>options</replaceable></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>unix:postgresql://localhost<optional>:<replaceable>port</replaceable></optional><optional>/<replaceable>dbname</replaceable></optional><optional>?<replaceable>options</replaceable></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      an SQL string literal containing one of the above forms
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      a reference to a character variable containing one of the above forms (see examples)
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>DEFAULT</literal>
     </simpara>
    </listitem>
   </itemizedlist>

   The connection target <literal>DEFAULT</literal> initiates a connection
   to the default database under the default user name.  No separate
   user name or connection name can be specified in that case.
  </para>
________________________________________________________-->
  <para>
   我们可以使用下列语句连接到一个数据库：
<programlisting>
EXEC SQL CONNECT TO <replaceable>target</replaceable> <optional>AS <replaceable>connection-name</replaceable></optional> <optional>USER <replaceable>user-name</replaceable></optional>;
</programlisting>
   <replaceable>target</replaceable>可以用下列方法指定：

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>dbname</replaceable><optional>@<replaceable>hostname</replaceable></optional><optional>:<replaceable>port</replaceable></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>tcp:postgresql://<replaceable>hostname</replaceable><optional>:<replaceable>port</replaceable></optional><optional>/<replaceable>dbname</replaceable></optional><optional>?<replaceable>options</replaceable></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>unix:postgresql://localhost<optional>:<replaceable>port</replaceable></optional><optional>/<replaceable>dbname</replaceable></optional><optional>?<replaceable>options</replaceable></optional></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      一个包含上述形式之一的 SQL 字符串
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      到一个包含上述形式之一（参见例子）的字符变量的引用
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>DEFAULT</literal>
     </simpara>
    </listitem>
   </itemizedlist>

   连接目标<literal>DEFAULT</literal>会以默认用户名发起一个到默认数据库的连接。
   在那种情况中不能指定单独的用户名或连接名。
  </para>
<!-- pgdoc-cn_end sig_en=c7e6918dde78041d30b6221787a8925c -->

<!-- pgdoc-cn_start sig_en=58119ad725261d08fae724d555a5fb8d sig_cn_org=None source=14.1 
  <para>
   If you specify the connection target directly (that is, not as a string
   literal or variable reference), then the components of the target are
   passed through normal SQL parsing; this means that, for example,
   the <replaceable>hostname</replaceable> must look like one or more SQL
   identifiers separated by dots, and those identifiers will be
   case-folded unless double-quoted.  Values of
   any <replaceable>options</replaceable> must be SQL identifiers,
   integers, or variable references.  Of course, you can put nearly
   anything into an SQL identifier by double-quoting it.
   In practice, it is probably less error-prone to use a (single-quoted)
   string literal or a variable reference than to write the connection
   target directly.
  </para>
________________________________________________________-->
  <para>
   如果你直接指定了连接目标(也就是说，不是字符串或变量引用)，则目标的内容传递到常规SQL语法解析；
   这意味着，例如，<replaceable>hostname</replaceable>必须看起来像一个或多个由点分开的SQL标识符，并且除非被双引号括住，那些标识符将是大写的。
   任何<replaceable>options</replaceable>的值必须是SQL标识符，整数，或变量引用。
   当然，你可以用双引号把几乎任何内容放到SQL标识符中。
   实际上，使用字符串(单引号)或变量引用可能比直接写入连接目标更不容易出错。
  </para>
<!-- pgdoc-cn_end sig_en=58119ad725261d08fae724d555a5fb8d -->

<!-- pgdoc-cn_start sig_en=e35995d1485f7594ac138260228afa20 sig_cn_org=None source=14.1 
  <para>
   There are also different ways to specify the user name:

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable>/<replaceable>password</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable> IDENTIFIED BY <replaceable>password</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable> USING <replaceable>password</replaceable></literal>
     </simpara>
    </listitem>
   </itemizedlist>

   As above, the parameters <replaceable>username</replaceable> and
   <replaceable>password</replaceable> can be an SQL identifier, an
   SQL string literal, or a reference to a character variable.
  </para>
________________________________________________________-->
  <para>
   也有不同的方法来指定用户名：

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable>/<replaceable>password</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable> IDENTIFIED BY <replaceable>password</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal><replaceable>username</replaceable> USING <replaceable>password</replaceable></literal>
     </simpara>
    </listitem>
   </itemizedlist>

   如上所述，参数<replaceable>username</replaceable>以及<replaceable>password</replaceable>可以是一个 SQL 标识符、一个 SQL 字符串或者一个对字符变量的引用。
  </para>
<!-- pgdoc-cn_end sig_en=e35995d1485f7594ac138260228afa20 -->

<!-- pgdoc-cn_start sig_en=1bb3545dbbb9a497566d814139185f38 sig_cn_org=None source=14.1 
  <para>
   If the connection target includes any <replaceable>options</replaceable>,
   those consist of
   <literal><replaceable>keyword</replaceable>=<replaceable>value</replaceable></literal>
   specifications separated by ampersands (<literal>&amp;</literal>).
   The allowed key words are the same ones recognized
   by <application>libpq</application> (see
   <xref linkend="libpq-paramkeywords"/>).  Spaces are ignored before
   any <replaceable>keyword</replaceable> or <replaceable>value</replaceable>,
   though not within or after one.  Note that there is no way to
   write <literal>&amp;</literal> within a <replaceable>value</replaceable>.
  </para>
________________________________________________________-->
  <para>
   如果连接目标包含任何<replaceable>options</replaceable>，
   这些由<literal><replaceable>keyword</replaceable>=<replaceable>value</replaceable></literal>组成的规范，由表示“和”的符号(<literal>&amp;</literal>)分隔。
   允许的关键字与<application>libpq</application>识别的关键字相同(参见<xref linkend="libpq-paramkeywords"/>)。
   在任何<replaceable>keyword</replaceable>或<replaceable>value</replaceable>之前的空格将被忽略，但其中或之后则不会。
   请注意，无法将<literal>&amp;</literal>写入<replaceable>value</replaceable>。
  </para>
<!-- pgdoc-cn_end sig_en=1bb3545dbbb9a497566d814139185f38 -->

<!-- pgdoc-cn_start sig_en=997724c8f2e3737fdc6522c166fe7b88 sig_cn_org=None source=14.1 
  <para>
   Notice that when specifying a socket connection
   (with the <literal>unix:</literal> prefix), the host name must be
   exactly <literal>localhost</literal>.  To select a non-default
   socket directory, write the directory's pathname as the value of
   a <varname>host</varname> option in
   the <replaceable>options</replaceable> part of the target.
  </para>
________________________________________________________-->
  <para>
   注意当指定嵌套连接(具有<literal>unix:</literal>前缀)，主机名必须是精确的<literal>localhost</literal>。
   要选择一个非默认嵌套目录，写目录的路径名作为<varname>host</varname>选项的值，在目标的<replaceable>options</replaceable>部分。
  </para>
<!-- pgdoc-cn_end sig_en=997724c8f2e3737fdc6522c166fe7b88 -->

<!-- pgdoc-cn_start sig_en=d0af835313306a7f8ebdbc9dc438d567 sig_cn_org=None source=14.1 
  <para>
   The <replaceable>connection-name</replaceable> is used to handle
   multiple connections in one program.  It can be omitted if a
   program uses only one connection.  The most recently opened
   connection becomes the current connection, which is used by default
   when an SQL statement is to be executed (see later in this
   chapter).
  </para>
________________________________________________________-->
  <para>
   <replaceable>connection-name</replaceable>被用来在一个程序中处理多个连接。如果一个程序只使用一个连接，它可以被忽略。最近被打开的连接将成为当前连接，当一个 SQL 语句要被执行时，将默认使用它（见这一章稍后的部分）。
  </para>
<!-- pgdoc-cn_end sig_en=d0af835313306a7f8ebdbc9dc438d567 -->

<!-- pgdoc-cn_start sig_en=87735caed2244d94ef6e7d5404d83eed sig_cn_org=None source=14.1 
  <para>
   Here are some examples of <command>CONNECT</command> statements:
<programlisting>
EXEC SQL CONNECT TO mydb@sql.mydomain.com;

EXEC SQL CONNECT TO tcp:postgresql://sql.mydomain.com/mydb AS myconnection USER john;

EXEC SQL BEGIN DECLARE SECTION;
const char *target = "mydb@sql.mydomain.com";
const char *user = "john";
const char *passwd = "secret";
EXEC SQL END DECLARE SECTION;
 ...
EXEC SQL CONNECT TO :target USER :user USING :passwd;
/* or EXEC SQL CONNECT TO :target USER :user/:passwd; */
</programlisting>
   The last example makes use of the feature referred to above as
   character variable references.  You will see in later sections how C
   variables can be used in SQL statements when you prefix them with a
   colon.
  </para>
________________________________________________________-->
  <para>
   这里有一些<command>CONNECT</command>语句的例子：
<programlisting>
EXEC SQL CONNECT TO mydb@sql.mydomain.com;

EXEC SQL CONNECT TO tcp:postgresql://sql.mydomain.com/mydb AS myconnection USER john;

EXEC SQL BEGIN DECLARE SECTION;
const char *target = "mydb@sql.mydomain.com";
const char *user = "john";
const char *passwd = "secret";
EXEC SQL END DECLARE SECTION;
 ...
EXEC SQL CONNECT TO :target USER :user USING :passwd;
/* 或者 EXEC SQL CONNECT TO :target USER :user/:passwd; */
</programlisting>
   最后一种示例利用被上文成为字符特征引用的变体。你将在后面的小节中看到当你把 C 变量前放上一个冒号时，它们是怎样被用于 SQL 语句的。
  </para>
<!-- pgdoc-cn_end sig_en=87735caed2244d94ef6e7d5404d83eed -->

<!-- pgdoc-cn_start sig_en=db052f47138a489fb511c6459fd98e69 sig_cn_org=None source=14.1 
  <para>
   Be advised that the format of the connection target is not
   specified in the SQL standard.  So if you want to develop portable
   applications, you might want to use something based on the last
   example above to encapsulate the connection target string
   somewhere.
  </para>
________________________________________________________-->
  <para>
   注意连接目标的格式没有在 SQL 标准中说明。因此如果你想要开发可移植的应用，你可能想要使用某种基于上述最后一个例子的方法来把连接目标字符串封装在某个地方。
  </para>
<!-- pgdoc-cn_end sig_en=db052f47138a489fb511c6459fd98e69 -->

<!-- pgdoc-cn_start sig_en=5d14306a8f0944dfa3374cb9995d636a sig_cn_org=None source=14.1 
  <para>
   If untrusted users have access to a database that has not adopted a
   <link linkend="ddl-schemas-patterns">secure schema usage pattern</link>,
   begin each session by removing publicly-writable schemas
   from <varname>search_path</varname>.  For example,
   add <literal>options=-c search_path=</literal>
   to <literal><replaceable>options</replaceable></literal>, or
   issue <literal>EXEC SQL SELECT pg_catalog.set_config('search_path', '',
   false);</literal> after connecting.  This consideration is not specific to
   ECPG; it applies to every interface for executing arbitrary SQL commands.
  </para>
________________________________________________________-->
  <para>
   如果不受信任的用户访问没有采用<link linkend="ddl-schemas-patterns">secure schema usage pattern</link>的数据库，通过从<varname>search_path</varname>中删除公共可写模式来开始每个会话。
   例如，添加<literal>options=-c search_path=</literal> 到<literal><replaceable>options</replaceable></literal>，或在连接后发出 <literal>EXEC SQL SELECT pg_catalog.set_config('search_path', '',false);</literal>。
   这种考虑并不特定于ECPG;它适用于执行任意SQL命令的每个接口。
  </para>
<!-- pgdoc-cn_end sig_en=5d14306a8f0944dfa3374cb9995d636a -->
  </sect2>

  <sect2 id="ecpg-set-connection">
<!-- pgdoc-cn_start sig_en=a88a2fe4b12136092f7911ea62306cf3 sig_cn_org=None source=14.1 
   <title>Choosing a Connection</title>
________________________________________________________-->
   <title>选择一个连接</title>
<!-- pgdoc-cn_end sig_en=a88a2fe4b12136092f7911ea62306cf3 -->

<!-- pgdoc-cn_start sig_en=0b6d34ff56c13db2a94aad2ab179dacf sig_cn_org=None source=14.1 
  <para>
   SQL statements in embedded SQL programs are by default executed on
   the current connection, that is, the most recently opened one.  If
   an application needs to manage multiple connections, then there are
   three ways to handle this.
  </para>
________________________________________________________-->
  <para>
   嵌入式 SQL 程序中的 SQL 语句默认是在当前连接（也就是最近打开的那一个）上执行的。如果一个应用需要管理多个连接，那么有三种方法来处理这种需求。
  </para>
<!-- pgdoc-cn_end sig_en=0b6d34ff56c13db2a94aad2ab179dacf -->

<!-- pgdoc-cn_start sig_en=0766b2ccaa79f7ef25f252c7f5f82111 sig_cn_org=None source=14.1 
  <para>
   The first option is to explicitly choose a connection for each SQL
   statement, for example:
<programlisting>
EXEC SQL AT <replaceable>connection-name</replaceable> SELECT ...;
</programlisting>
   This option is particularly suitable if the application needs to
   use several connections in mixed order.
  </para>
________________________________________________________-->
  <para>
   第一个选项是显式地为每一个 SQL 语句选择一个连接，例如：
<programlisting>
EXEC SQL AT <replaceable>connection-name</replaceable> SELECT ...;
</programlisting>
   如果应用需要以混合的顺序使用多个连接，这个选项特别合适。
  </para>
<!-- pgdoc-cn_end sig_en=0766b2ccaa79f7ef25f252c7f5f82111 -->

<!-- pgdoc-cn_start sig_en=ec60c571723812e1d893b4bbca5c8863 sig_cn_org=None source=14.1 
  <para>
   If your application uses multiple threads of execution, they cannot share a
   connection concurrently. You must either explicitly control access to the connection
   (using mutexes) or use a connection for each thread.
  </para>
________________________________________________________-->
  <para>
   如果你的应用使用多个线程执行，它们不能并发地共享一个连接。你必须显式地控制对连接的访问（使用互斥量）或者为每个线程使用一个连接。
  </para>
<!-- pgdoc-cn_end sig_en=ec60c571723812e1d893b4bbca5c8863 -->

<!-- pgdoc-cn_start sig_en=dc25e3ff414f0866c383bffee2ad29cb sig_cn_org=None source=14.1 
  <para>
   The second option is to execute a statement to switch the current
   connection.  That statement is:
<programlisting>
EXEC SQL SET CONNECTION <replaceable>connection-name</replaceable>;
</programlisting>
   This option is particularly convenient if many statements are to be
   executed on the same connection.
  </para>
________________________________________________________-->
  <para>
   第二个选项是执行一个语句来切换当前的连接。该语句是：
<programlisting>
EXEC SQL SET CONNECTION <replaceable>connection-name</replaceable>;
</programlisting>
   如果很多语句要被在同一个连接上执行，这个选项特别方便。
  </para>
<!-- pgdoc-cn_end sig_en=dc25e3ff414f0866c383bffee2ad29cb -->

<!-- pgdoc-cn_start sig_en=b5fd145542121a1c4b9cc263822a1046 sig_cn_org=None source=14.1 
  <para>
   Here is an example program managing multiple database connections:
<programlisting><![CDATA[
#include <stdio.h>

EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
EXEC SQL END DECLARE SECTION;

int
main()
{
    EXEC SQL CONNECT TO testdb1 AS con1 USER testuser;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
    EXEC SQL CONNECT TO testdb2 AS con2 USER testuser;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
    EXEC SQL CONNECT TO testdb3 AS con3 USER testuser;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    /* This query would be executed in the last opened database "testdb3". */
    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb3)\n", dbname);

    /* Using "AT" to run a query in "testdb2" */
    EXEC SQL AT con2 SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb2)\n", dbname);

    /* Switch the current connection to "testdb1". */
    EXEC SQL SET CONNECTION con1;

    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb1)\n", dbname);

    EXEC SQL DISCONNECT ALL;
    return 0;
}
]]></programlisting>

   This example would produce this output:
<screen>
current=testdb3 (should be testdb3)
current=testdb2 (should be testdb2)
current=testdb1 (should be testdb1)
</screen>
  </para>
________________________________________________________-->
  <para>
   这里有一个管理多个数据库连接的例子程序：
<programlisting><![CDATA[
#include <stdio.h>

EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
EXEC SQL END DECLARE SECTION;

int
main()
{
    EXEC SQL CONNECT TO testdb1 AS con1 USER testuser;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
    EXEC SQL CONNECT TO testdb2 AS con2 USER testuser;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
    EXEC SQL CONNECT TO testdb3 AS con3 USER testuser;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    /* 这个查询将在最近打开的数据库 "testdb3" 中执行 */
    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb3)\n", dbname);

    /* 使用 "AT" 在 "testdb2" 中运行一个查询 */
    EXEC SQL AT con2 SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb2)\n", dbname);

    /* 切换当前连接到 "testdb1" */
    EXEC SQL SET CONNECTION con1;

    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current=%s (should be testdb1)\n", dbname);

    EXEC SQL DISCONNECT ALL;
    return 0;
}
]]></programlisting>

   这个例子将产生这样的输出：
<screen>
current=testdb3 (should be testdb3)
current=testdb2 (should be testdb2)
current=testdb1 (should be testdb1)
</screen>
  </para>
<!-- pgdoc-cn_end sig_en=b5fd145542121a1c4b9cc263822a1046 -->

<!-- pgdoc-cn_start sig_en=22cd8e74e9dd9ec4bcbd876779c8aea7 sig_cn_org=None source=14.1 
  <para>
  The third option is to declare an SQL identifier linked to
  the connection, for example:
<programlisting>
EXEC SQL AT <replaceable>connection-name</replaceable> DECLARE <replaceable>statement-name</replaceable> STATEMENT;
EXEC SQL PREPARE <replaceable>statement-name</replaceable> FROM :<replaceable>dyn-string</replaceable>;
</programlisting>
   Once you link an SQL identifier to a connection, you execute dynamic SQL
   without an AT clause. Note that this option behaves like preprocessor
   directives, therefore the link is enabled only in the file.
  </para>
________________________________________________________-->
  <para>
  第三个选项是声明一个SQL标识符链接到连接，例如：
<programlisting>
EXEC SQL AT <replaceable>connection-name</replaceable> DECLARE <replaceable>statement-name</replaceable> STATEMENT;
EXEC SQL PREPARE <replaceable>statement-name</replaceable> FROM :<replaceable>dyn-string</replaceable>;
</programlisting>
   当你链接一个SQL标识符到连接，你执行动态SQL而不用一个AT子句。
   注意这个选项的行为像预处理器指令，因此链接仅在文件中启用。
  </para>
<!-- pgdoc-cn_end sig_en=22cd8e74e9dd9ec4bcbd876779c8aea7 -->
<!-- pgdoc-cn_start sig_en=b0fe288f03d234386429d228f49a3511 sig_cn_org=None source=14.1 
  <para>
   Here is an example program using this option:
<programlisting><![CDATA[
#include <stdio.h>

EXEC SQL BEGIN DECLARE SECTION;
char dbname[128];
char *dyn_sql = "SELECT current_database()";
EXEC SQL END DECLARE SECTION;

int main(){
  EXEC SQL CONNECT TO postgres AS con1;
  EXEC SQL CONNECT TO testdb AS con2;
  EXEC SQL AT con1 DECLARE stmt STATEMENT;
  EXEC SQL PREPARE stmt FROM :dyn_sql;
  EXEC SQL EXECUTE stmt INTO :dbname;
  printf("%s\n", dbname);

  EXEC SQL DISCONNECT ALL;
  return 0;
}
]]></programlisting>

   This example would produce this output, even if the default connection is testdb:
<screen>
postgres
</screen>
  </para>
________________________________________________________-->
  <para>
   这里是一个用这个选项的示例程序：
<programlisting><![CDATA[
#include <stdio.h>

EXEC SQL BEGIN DECLARE SECTION;
char dbname[128];
char *dyn_sql = "SELECT current_database()";
EXEC SQL END DECLARE SECTION;

int main(){
  EXEC SQL CONNECT TO postgres AS con1;
  EXEC SQL CONNECT TO testdb AS con2;
  EXEC SQL AT con1 DECLARE stmt STATEMENT;
  EXEC SQL PREPARE stmt FROM :dyn_sql;
  EXEC SQL EXECUTE stmt INTO :dbname;
  printf("%s\n", dbname);

  EXEC SQL DISCONNECT ALL;
  return 0;
}
]]></programlisting>

   这个示例会产生这个输出，即使默认的连接是testdb：
<screen>
postgres
</screen>
  </para>
<!-- pgdoc-cn_end sig_en=b0fe288f03d234386429d228f49a3511 -->
  </sect2>

  <sect2 id="ecpg-disconnect">
<!-- pgdoc-cn_start sig_en=6967801f9ec3f4d334765eb4ddba9ce2 sig_cn_org=None source=14.1 
   <title>Closing a Connection</title>
________________________________________________________-->
   <title>关闭一个连接</title>
<!-- pgdoc-cn_end sig_en=6967801f9ec3f4d334765eb4ddba9ce2 -->

<!-- pgdoc-cn_start sig_en=38fadbe68939c7e70650daa1a9ae7662 sig_cn_org=2059a90e06e14a6d9a63ef4755d49269 source=15.7 
  <para>
   To close a connection, use the following statement:
<programlisting>
EXEC SQL DISCONNECT <optional><replaceable>connection</replaceable></optional>;
</programlisting>
   The <replaceable>connection</replaceable> can be specified
   in the following ways:

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>connection-name</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>CURRENT</literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>ALL</literal>
     </simpara>
    </listitem>
   </itemizedlist>

   If no connection name is specified, the current connection is
   closed.
  </para>
________________________________________________________-->
  <para>
   要关闭连接，请使用以下语句：
<programlisting>
EXEC SQL DISCONNECT <optional><replaceable>connection</replaceable></optional>;
</programlisting>
   <replaceable>connection</replaceable>可以通过以下方式指定：

   <itemizedlist>
    <listitem>
     <simpara>
      <literal><replaceable>connection-name</replaceable></literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>CURRENT</literal>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <literal>ALL</literal>
     </simpara>
    </listitem>
   </itemizedlist>

   如果未指定连接名称，则关闭当前连接。
  </para>
<!-- pgdoc-cn_end sig_en=38fadbe68939c7e70650daa1a9ae7662 -->

<!-- pgdoc-cn_start sig_en=9f3736f9ee2d8f383404a793e8a94a86 sig_cn_org=None source=14.1 
  <para>
   It is good style that an application always explicitly disconnect
   from every connection it opened.
  </para>
________________________________________________________-->
  <para>
   在一个应用中总是显式地从它打开的每一个连接断开是一种好的风格。
  </para>
<!-- pgdoc-cn_end sig_en=9f3736f9ee2d8f383404a793e8a94a86 -->
  </sect2>

 </sect1>

 <sect1 id="ecpg-commands">
<!-- pgdoc-cn_start sig_en=6e8c2d37cf8410094465aa6b824db7a5 sig_cn_org=None source=14.1 
  <title>Running SQL Commands</title>
________________________________________________________-->
  <title>运行 SQL 命令</title>
<!-- pgdoc-cn_end sig_en=6e8c2d37cf8410094465aa6b824db7a5 -->

<!-- pgdoc-cn_start sig_en=9d0ed70f375b92088f3870ab82cbae32 sig_cn_org=None source=14.1 
  <para>
   Any SQL command can be run from within an embedded SQL application.
   Below are some examples of how to do that.
  </para>
________________________________________________________-->
  <para>
   任何 SQL 命令都可以在一个嵌入式 SQL 应用中被运行。下面是一些在嵌入式 SQL 应用中运行 SQL 命令的例子。
  </para>
<!-- pgdoc-cn_end sig_en=9d0ed70f375b92088f3870ab82cbae32 -->

  <sect2 id="ecpg-executing">
<!-- pgdoc-cn_start sig_en=fb2adf1423207924f34be95b3b3994a8 sig_cn_org=None source=14.1 
   <title>Executing SQL Statements</title>
________________________________________________________-->
   <title>执行 SQL 语句</title>
<!-- pgdoc-cn_end sig_en=fb2adf1423207924f34be95b3b3994a8 -->

<!-- pgdoc-cn_start sig_en=8887badacee4baa09479bab36680180c sig_cn_org=None source=14.1 
  <para>
   Creating a table:
<programlisting>
EXEC SQL CREATE TABLE foo (number integer, ascii char(16));
EXEC SQL CREATE UNIQUE INDEX num1 ON foo(number);
EXEC SQL COMMIT;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   创建一个表：
<programlisting>
EXEC SQL CREATE TABLE foo (number integer, ascii char(16));
EXEC SQL CREATE UNIQUE INDEX num1 ON foo(number);
EXEC SQL COMMIT;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=8887badacee4baa09479bab36680180c -->

<!-- pgdoc-cn_start sig_en=c256d3768122a0934132fe6b5d8d2f0b sig_cn_org=None source=14.1 
  <para>
   Inserting rows:
<programlisting>
EXEC SQL INSERT INTO foo (number, ascii) VALUES (9999, 'doodad');
EXEC SQL COMMIT;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   插入行：
<programlisting>
EXEC SQL INSERT INTO foo (number, ascii) VALUES (9999, 'doodad');
EXEC SQL COMMIT;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=c256d3768122a0934132fe6b5d8d2f0b -->

<!-- pgdoc-cn_start sig_en=761f69b96bf98e76e30445cdbdf99a05 sig_cn_org=None source=14.1 
  <para>
   Deleting rows:
<programlisting>
EXEC SQL DELETE FROM foo WHERE number = 9999;
EXEC SQL COMMIT;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   删除行：
<programlisting>
EXEC SQL DELETE FROM foo WHERE number = 9999;
EXEC SQL COMMIT;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=761f69b96bf98e76e30445cdbdf99a05 -->

<!-- pgdoc-cn_start sig_en=f0ffb348e27397d42c35c341b192444c sig_cn_org=None source=14.1 
  <para>
   Updates:
<programlisting>
EXEC SQL UPDATE foo
    SET ascii = 'foobar'
    WHERE number = 9999;
EXEC SQL COMMIT;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   更新：
<programlisting>
EXEC SQL UPDATE foo
    SET ascii = 'foobar'
    WHERE number = 9999;
EXEC SQL COMMIT;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=f0ffb348e27397d42c35c341b192444c -->

<!-- pgdoc-cn_start sig_en=387747d091d21f943288bed5d77f7f81 sig_cn_org=None source=14.1 
  <para>
   <literal>SELECT</literal> statements that return a single result
   row can also be executed using
   <literal>EXEC SQL</literal> directly.  To handle result sets with
   multiple rows, an application has to use a cursor;
   see <xref linkend="ecpg-cursors"/> below.  (As a special case, an
   application can fetch multiple rows at once into an array host
   variable; see <xref linkend="ecpg-variables-arrays"/>.)
  </para>
________________________________________________________-->
  <para>
   返回一个单一结果行的<literal>SELECT</literal>语句也可以直接使用<literal>EXEC SQL</literal>执行。要处理有多行的结果集，一个应用必须使用一个游标，可参考下面的<xref linkend="ecpg-cursors"/>（作为一种特殊情况，一个应用可以一次取出多行到一个数组主变量中，参考<xref linkend="ecpg-variables-arrays"/>）。
  </para>
<!-- pgdoc-cn_end sig_en=387747d091d21f943288bed5d77f7f81 -->

<!-- pgdoc-cn_start sig_en=513cb93a2bee19055a44c6bb52b21a00 sig_cn_org=None source=14.1 
  <para>
   Single-row select:
<programlisting>
EXEC SQL SELECT foo INTO :FooBar FROM table1 WHERE ascii = 'doodad';
</programlisting>
  </para>
________________________________________________________-->
  <para>
   单行选择：
<programlisting>
EXEC SQL SELECT foo INTO :FooBar FROM table1 WHERE ascii = 'doodad';
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=513cb93a2bee19055a44c6bb52b21a00 -->

<!-- pgdoc-cn_start sig_en=580b68b8d9de17303896f6a4259ad368 sig_cn_org=None source=14.1 
  <para>
   Also, a configuration parameter can be retrieved with the
   <literal>SHOW</literal> command:
<programlisting>
EXEC SQL SHOW search_path INTO :var;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   还有，一个配置参数可以用<literal>SHOW</literal>命令检索：
<programlisting>
EXEC SQL SHOW search_path INTO :var;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=580b68b8d9de17303896f6a4259ad368 -->

<!-- pgdoc-cn_start sig_en=aae55b8e8f326eea86bb629cb76a87fb sig_cn_org=None source=14.1 
  <para>
   The tokens of the form
   <literal>:<replaceable>something</replaceable></literal> are
   <firstterm>host variables</firstterm>, that is, they refer to
   variables in the C program.  They are explained in <xref
   linkend="ecpg-variables"/>.
  </para>
________________________________________________________-->
  <para>
   <literal>:<replaceable>something</replaceable></literal>形式的记号是<firstterm>主变量</firstterm>，即它们指向 C 程序中的变量。它们在<xref linkend="ecpg-variables"/>中解释。
  </para>
<!-- pgdoc-cn_end sig_en=aae55b8e8f326eea86bb629cb76a87fb -->
  </sect2>

  <sect2 id="ecpg-cursors">
<!-- pgdoc-cn_start sig_en=5b4b98187bad53f475112cd47c9e80c2 sig_cn_org=None source=14.1 
   <title>Using Cursors</title>
________________________________________________________-->
   <title>使用游标</title>
<!-- pgdoc-cn_end sig_en=5b4b98187bad53f475112cd47c9e80c2 -->

<!-- pgdoc-cn_start sig_en=bff8728ca1e4f1da99f48982248fd185 sig_cn_org=None source=14.1 
  <para>
   To retrieve a result set holding multiple rows, an application has
   to declare a cursor and fetch each row from the cursor.  The steps
   to use a cursor are the following: declare a cursor, open it, fetch
   a row from the cursor, repeat, and finally close it.
  </para>
________________________________________________________-->
  <para>
   要检索一个保持多行的结果集，一个应用必须声明一个游标并且从该游标中取得每一行。使用一个游标的步骤如下：声明一个游标、打开它、从该游标取得一行、重复并且最终关闭它。
  </para>
<!-- pgdoc-cn_end sig_en=bff8728ca1e4f1da99f48982248fd185 -->

<!-- pgdoc-cn_start sig_en=55ebfa17611195022d3f0015f6c04a7e sig_cn_org=None source=14.1 
  <para>
   Select using cursors:
<programlisting>
EXEC SQL DECLARE foo_bar CURSOR FOR
    SELECT number, ascii FROM foo
    ORDER BY ascii;
EXEC SQL OPEN foo_bar;
EXEC SQL FETCH foo_bar INTO :FooBar, DooDad;
...
EXEC SQL CLOSE foo_bar;
EXEC SQL COMMIT;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   使用游标选择：
<programlisting>
EXEC SQL DECLARE foo_bar CURSOR FOR
    SELECT number, ascii FROM foo
    ORDER BY ascii;
EXEC SQL OPEN foo_bar;
EXEC SQL FETCH foo_bar INTO :FooBar, DooDad;
...
EXEC SQL CLOSE foo_bar;
EXEC SQL COMMIT;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=55ebfa17611195022d3f0015f6c04a7e -->

<!-- pgdoc-cn_start sig_en=c1b05c00b5971907142260b7eaee25e3 sig_cn_org=None source=14.1 
  <para>
   For more details about declaring a cursor, see <xref
   linkend="ecpg-sql-declare"/>; for more details about fetching rows from a
   cursor, see <xref linkend="sql-fetch"/>.
  </para>
________________________________________________________-->
  <para>
   有关声明游标的更多细节，可参考<xref linkend="ecpg-sql-declare"/>；关于从游标中预取行的更多细节则，参见<xref linkend="sql-fetch"/>。
  </para>
<!-- pgdoc-cn_end sig_en=c1b05c00b5971907142260b7eaee25e3 -->

   <note>
<!-- pgdoc-cn_start sig_en=b05438b1803a20f6dc27aa95366ada82 sig_cn_org=None source=14.1 
    <para>
     The ECPG <command>DECLARE</command> command does not actually
     cause a statement to be sent to the PostgreSQL backend.  The
     cursor is opened in the backend (using the
     backend's <command>DECLARE</command> command) at the point when
     the <command>OPEN</command> command is executed.
    </para>
________________________________________________________-->
    <para>
     ECPG <command>DECLARE</command>命令实际上不会导致一个语句被发送到 PostgreSQL 后端。在<command>OPEN</command>命令被执行时，游标会在后端被打开（使用后端的<command>DECLARE</command>命令）。
    </para>
<!-- pgdoc-cn_end sig_en=b05438b1803a20f6dc27aa95366ada82 -->
   </note>
  </sect2>

  <sect2 id="ecpg-transactions">
<!-- pgdoc-cn_start sig_en=8b5764207395917cbdd2b92fc985432e sig_cn_org=None source=14.1 
   <title>Managing Transactions</title>
________________________________________________________-->
   <title>管理事务</title>
<!-- pgdoc-cn_end sig_en=8b5764207395917cbdd2b92fc985432e -->

<!-- pgdoc-cn_start sig_en=e763531756f55218256e2abdef1cc185 sig_cn_org=None source=14.1 
  <para>
   In the default mode, statements are committed only when
   <command>EXEC SQL COMMIT</command> is issued. The embedded SQL
   interface also supports autocommit of transactions (similar to
   <application>psql</application>'s default behavior) via the <option>-t</option>
   command-line option to <command>ecpg</command> (see <xref
   linkend="app-ecpg"/>) or via the <literal>EXEC SQL SET AUTOCOMMIT TO
   ON</literal> statement. In autocommit mode, each command is
   automatically committed unless it is inside an explicit transaction
   block. This mode can be explicitly turned off using <literal>EXEC
   SQL SET AUTOCOMMIT TO OFF</literal>.
  </para>
________________________________________________________-->
  <para>
   在默认模式中，只有当<command>EXEC SQL COMMIT</command>被发出时才会提交命令。嵌入式 SQL 接口也通过<command>ecpg</command>的<option>-t</option>命令行选项（见<xref linkend="app-ecpg"/>）或者通过<literal>EXEC SQL SET AUTOCOMMIT TO ON</literal>语句支持事务的自动提交（类似于<application>psql</application>的默认行为）。在自动提交模式中，除非位于一个显式事务块内，每一个命令都会被自动提交。这种模式可以使用<literal>EXEC SQL SET AUTOCOMMIT TO OFF</literal>显式地关闭。
  </para>
<!-- pgdoc-cn_end sig_en=e763531756f55218256e2abdef1cc185 -->

<!-- pgdoc-cn_start sig_en=62f8fe0f1b435741df6c7d1b8fed2482 sig_cn_org=None source=14.1 
   <para>
    The following transaction management commands are available:

    <variablelist>
     <varlistentry>
      <term><literal>EXEC SQL COMMIT</literal></term>
      <listitem>
       <para>
        Commit an in-progress transaction.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL ROLLBACK</literal></term>
      <listitem>
       <para>
        Roll back an in-progress transaction.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL PREPARE TRANSACTION </literal><replaceable class="parameter">transaction_id</replaceable></term>
      <listitem>
       <para>
        Prepare the current transaction for two-phase commit.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL COMMIT PREPARED </literal><replaceable class="parameter">transaction_id</replaceable></term>
      <listitem>
       <para>
        Commit a transaction that is in prepared state.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL ROLLBACK PREPARED </literal><replaceable class="parameter">transaction_id</replaceable></term>
      <listitem>
       <para>
        Roll back a transaction that is in prepared state.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL SET AUTOCOMMIT TO ON</literal></term>
      <listitem>
       <para>
        Enable autocommit mode.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL SET AUTOCOMMIT TO OFF</literal></term>
      <listitem>
       <para>
        Disable autocommit mode.  This is the default.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    可以使用下列事务管理命令：

    <variablelist>
     <varlistentry>
      <term><literal>EXEC SQL COMMIT</literal></term>
      <listitem>
       <para>
        提交一个进行中的事务。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL ROLLBACK</literal></term>
      <listitem>
       <para>
        回滚一个进行中的事务。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL PREPARE TRANSACTION </literal><replaceable class="parameter">transaction_id</replaceable></term>
      <listitem>
       <para>
        为两阶段提交准备当前事务。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL COMMIT PREPARED </literal><replaceable class="parameter">transaction_id</replaceable></term>
      <listitem>
       <para>
        提交一个处于准备好状态的事务。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL ROLLBACK PREPARED </literal><replaceable class="parameter">transaction_id</replaceable></term>
      <listitem>
       <para>
        回滚一个处于准备好状态的事务。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL SET AUTOCOMMIT TO ON</literal></term>
      <listitem>
       <para>
        启用自动提交模式。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>EXEC SQL SET AUTOCOMMIT TO OFF</literal></term>
      <listitem>
       <para>
        禁用自动提交模式。这是默认值。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=62f8fe0f1b435741df6c7d1b8fed2482 -->
  </sect2>

  <sect2 id="ecpg-prepared">
<!-- pgdoc-cn_start sig_en=732719eed5f7baa436b3dd1fa89bcbf7 sig_cn_org=None source=14.1 
   <title>Prepared Statements</title>
________________________________________________________-->
   <title>预备语句</title>
<!-- pgdoc-cn_end sig_en=732719eed5f7baa436b3dd1fa89bcbf7 -->

<!-- pgdoc-cn_start sig_en=108dc708afd9f1e456c8515a5e5b4efc sig_cn_org=None source=14.1 
   <para>
    When the values to be passed to an SQL statement are not known at
    compile time, or the same statement is going to be used many
    times, then prepared statements can be useful.
   </para>
________________________________________________________-->
   <para>
    当传递给 SQL 语句的值在编译时未知或者同一个语句要被使用多次时，那么预备语句就有用武之地了。
   </para>
<!-- pgdoc-cn_end sig_en=108dc708afd9f1e456c8515a5e5b4efc -->

<!-- pgdoc-cn_start sig_en=f1654aad94c9cd862b673e7cd2cbf969 sig_cn_org=None source=14.1 
   <para>
    The statement is prepared using the
    command <literal>PREPARE</literal>.  For the values that are not
    known yet, use the
    placeholder <quote><literal>?</literal></quote>:
<programlisting>
EXEC SQL PREPARE stmt1 FROM "SELECT oid, datname FROM pg_database WHERE oid = ?";
</programlisting>
   </para>
________________________________________________________-->
   <para>
    语句使用命令<literal>PREPARE</literal>进行预备。对于还未知的值，使用占位符<quote><literal>?</literal></quote>：
<programlisting>
EXEC SQL PREPARE stmt1 FROM "SELECT oid, datname FROM pg_database WHERE oid = ?";
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=f1654aad94c9cd862b673e7cd2cbf969 -->

<!-- pgdoc-cn_start sig_en=12d22b4e2433d26e065104b0cf587604 sig_cn_org=None source=14.1 
   <para>
    If a statement returns a single row, the application can
    call <literal>EXECUTE</literal> after
    <literal>PREPARE</literal> to execute the statement, supplying the
    actual values for the placeholders with a <literal>USING</literal>
    clause:
<programlisting>
EXEC SQL EXECUTE stmt1 INTO :dboid, :dbname USING 1;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    如果一个语句返回一个单一行，应用可以在<literal>PREPARE</literal>之后调用<literal>EXECUTE</literal>来执行该语句，同时要用一个<literal>USING</literal>子句为占位符提供真实的值：
<programlisting>
EXEC SQL EXECUTE stmt1 INTO :dboid, :dbname USING 1;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=12d22b4e2433d26e065104b0cf587604 -->

<!-- pgdoc-cn_start sig_en=4fcf4544ce3380f77b7abce0be703644 sig_cn_org=None source=14.1 
   <para>
    If a statement returns multiple rows, the application can use a
    cursor declared based on the prepared statement.  To bind input
    parameters, the cursor must be opened with
    a <literal>USING</literal> clause:
<programlisting>
EXEC SQL PREPARE stmt1 FROM "SELECT oid,datname FROM pg_database WHERE oid &gt; ?";
EXEC SQL DECLARE foo_bar CURSOR FOR stmt1;

/* when end of result set reached, break out of while loop */
EXEC SQL WHENEVER NOT FOUND DO BREAK;

EXEC SQL OPEN foo_bar USING 100;
...
while (1)
{
    EXEC SQL FETCH NEXT FROM foo_bar INTO :dboid, :dbname;
    ...
}
EXEC SQL CLOSE foo_bar;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    如果一个语句返回多行，应用可以使用一个基于该预备语句声明的游标。要绑定输入参数，该游标必须用一个<literal>USING</literal>子句打开：
<programlisting>
EXEC SQL PREPARE stmt1 FROM "SELECT oid,datname FROM pg_database WHERE oid &gt; ?";
EXEC SQL DECLARE foo_bar CURSOR FOR stmt1;

/* 当到达结果集末尾时，跳出 while 循环 */
EXEC SQL WHENEVER NOT FOUND DO BREAK;

EXEC SQL OPEN foo_bar USING 100;
...
while (1)
{
    EXEC SQL FETCH NEXT FROM foo_bar INTO :dboid, :dbname;
    ...
}
EXEC SQL CLOSE foo_bar;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=4fcf4544ce3380f77b7abce0be703644 -->

<!-- pgdoc-cn_start sig_en=14488fe3e97f2102ea1f6690e38d1d41 sig_cn_org=None source=14.1 
   <para>
    When you don't need the prepared statement anymore, you should
    deallocate it:
<programlisting>
EXEC SQL DEALLOCATE PREPARE <replaceable>name</replaceable>;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    当你不再需要该预备语句时，你应该释放它：
<programlisting>
EXEC SQL DEALLOCATE PREPARE <replaceable>name</replaceable>;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=14488fe3e97f2102ea1f6690e38d1d41 -->

<!-- pgdoc-cn_start sig_en=a8106f85193494377f9b7576a1809322 sig_cn_org=None source=14.1 
   <para>
    For more details about <literal>PREPARE</literal>,
    see <xref linkend="ecpg-sql-prepare"/>. Also
    see <xref linkend="ecpg-dynamic"/> for more details about using
    placeholders and input parameters.
   </para>
________________________________________________________-->
   <para>
    更多有关<literal>PREPARE</literal>的细节，可参考<xref linkend="ecpg-sql-prepare"/>。关于使用占位符和输入参数的细节，可参考<xref linkend="ecpg-dynamic"/>。
   </para>
<!-- pgdoc-cn_end sig_en=a8106f85193494377f9b7576a1809322 -->
  </sect2>
 </sect1>

 <sect1 id="ecpg-variables">
<!-- pgdoc-cn_start sig_en=c13d7f0ea865e8d9e2bfed7f7318b410 sig_cn_org=None source=14.1 
  <title>Using Host Variables</title>
________________________________________________________-->
  <title>使用主变量</title>
<!-- pgdoc-cn_end sig_en=c13d7f0ea865e8d9e2bfed7f7318b410 -->

<!-- pgdoc-cn_start sig_en=aa02bd658185b0df46613789740b5a23 sig_cn_org=None source=14.1 
  <para>
   In <xref linkend="ecpg-commands"/> you saw how you can execute SQL
   statements from an embedded SQL program.  Some of those statements
   only used fixed values and did not provide a way to insert
   user-supplied values into statements or have the program process
   the values returned by the query.  Those kinds of statements are
   not really useful in real applications.  This section explains in
   detail how you can pass data between your C program and the
   embedded SQL statements using a simple mechanism called
   <firstterm>host variables</firstterm>. In an embedded SQL program we
   consider the SQL statements to be <firstterm>guests</firstterm> in the C
   program code which is the <firstterm>host language</firstterm>. Therefore
   the variables of the C program are called <firstterm>host
   variables</firstterm>.
  </para>
________________________________________________________-->
  <para>
   在<xref linkend="ecpg-commands"/>中，你了解了如何从一个嵌入式 SQL 程序执行 SQL 语句。某些那种语句只使用固定值并且没有提供方法来插入用户提供的值到语句中或者让程序处理查询返回的值。那种语句在实际应用中其实没有什么用处。这一节详细解释了如何使用一种简单的机制（<firstterm>主变量</firstterm>）在 C 程序和嵌入式 SQL 语句之间传递数据。在一个嵌入式 SQL 程序中，我们认为 SQL 语句是 C 程序代码中的<firstterm>客人</firstterm>，而 C 代码是<firstterm>主语言</firstterm>。因此 C 程序的变量被称为<firstterm>主变量</firstterm>。
  </para>
<!-- pgdoc-cn_end sig_en=aa02bd658185b0df46613789740b5a23 -->

<!-- pgdoc-cn_start sig_en=af9445698968664aec3865c386253fdd sig_cn_org=None source=14.1 
  <para>
   Another way to exchange values between PostgreSQL backends and ECPG
   applications is the use of SQL descriptors, described
   in <xref linkend="ecpg-descriptors"/>.
  </para>
________________________________________________________-->
  <para>
   另一种在 PostgreSQL 后端和 ECPG 应用之间交换值的方式是使用 SQL 描述符，它在<xref linkend="ecpg-descriptors"/>中介绍。
  </para>
<!-- pgdoc-cn_end sig_en=af9445698968664aec3865c386253fdd -->

  <sect2 id="ecpg-variables-overview">
<!-- pgdoc-cn_start sig_en=13508788fd8dee2d1f9c928870e99338 sig_cn_org=None source=14.1 
   <title>Overview</title>
________________________________________________________-->
   <title>概述</title>
<!-- pgdoc-cn_end sig_en=13508788fd8dee2d1f9c928870e99338 -->

<!-- pgdoc-cn_start sig_en=9c8c2a3e12270f22287164266f47a246 sig_cn_org=None source=14.1 
   <para>
    Passing data between the C program and the SQL statements is
    particularly simple in embedded SQL.  Instead of having the
    program paste the data into the statement, which entails various
    complications, such as properly quoting the value, you can simply
    write the name of a C variable into the SQL statement, prefixed by
    a colon.  For example:
<programlisting>
EXEC SQL INSERT INTO sometable VALUES (:v1, 'foo', :v2);
</programlisting>
    This statement refers to two C variables named
    <varname>v1</varname> and <varname>v2</varname> and also uses a
    regular SQL string literal, to illustrate that you are not
    restricted to use one kind of data or the other.
   </para>
________________________________________________________-->
   <para>
    在嵌入式 SQL 中进行 C 程序和 SQL 语句见的数据传递特别简单。我们不需要让程序把数据粘贴到语句（这会导致很多复杂性，例如正确地引用值），我们可以简单地在 SQL 语句中写 C 变量的名称，只要在它前面放上一个冒号。例如：
<programlisting>
EXEC SQL INSERT INTO sometable VALUES (:v1, 'foo', :v2);
</programlisting>
    这个语句引用了两个 C 变量（名为<varname>v1</varname>和<varname>v2</varname>）并且还使用了一个常规的 SQL 字符串来说明你没有被限制于使用某一种数据。
   </para>
<!-- pgdoc-cn_end sig_en=9c8c2a3e12270f22287164266f47a246 -->

<!-- pgdoc-cn_start sig_en=9a9b35b4357a813d867b3901223c8742 sig_cn_org=None source=14.1 
   <para>
    This style of inserting C variables in SQL statements works
    anywhere a value expression is expected in an SQL statement.
   </para>
________________________________________________________-->
   <para>
    这种在 SQL 语句中插入 C 变量的风格可以用在 SQL 语句中每一个应该出现值表达式的地方。
   </para>
<!-- pgdoc-cn_end sig_en=9a9b35b4357a813d867b3901223c8742 -->
  </sect2>

  <sect2 id="ecpg-declare-sections">
<!-- pgdoc-cn_start sig_en=2394d4b11f407189d8fb91e6de8150a0 sig_cn_org=None source=14.1 
   <title>Declare Sections</title>
________________________________________________________-->
   <title>声明小节</title>
<!-- pgdoc-cn_end sig_en=2394d4b11f407189d8fb91e6de8150a0 -->

<!-- pgdoc-cn_start sig_en=49db14ca1e2c5b0ce3b1c9bf49b00cb4 sig_cn_org=None source=14.1 
   <para>
    To pass data from the program to the database, for example as
    parameters in a query, or to pass data from the database back to
    the program, the C variables that are intended to contain this
    data need to be declared in specially marked sections, so the
    embedded SQL preprocessor is made aware of them.
   </para>
________________________________________________________-->
   <para>
    要从程序传递数据给数据库（例如作为一个查询的参数）或者从数据库传数据回程序，用于包含这些数据的 C 变量必须在特别标记的节中被声明，这样嵌入式 SQL 预处理器才会注意它们。
   </para>
<!-- pgdoc-cn_end sig_en=49db14ca1e2c5b0ce3b1c9bf49b00cb4 -->

<!-- pgdoc-cn_start sig_en=b3283a90ba1452ffa4b7894e7bdc8410 sig_cn_org=None source=14.1 
   <para>
    This section starts with:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
</programlisting>
    and ends with:
<programlisting>
EXEC SQL END DECLARE SECTION;
</programlisting>
    Between those lines, there must be normal C variable declarations,
    such as:
<programlisting>
int   x = 4;
char  foo[16], bar[16];
</programlisting>
    As you can see, you can optionally assign an initial value to the variable.
    The variable's scope is determined by the location of its declaring
    section within the program.
    You can also declare variables with the following syntax which implicitly
    creates a declare section:
<programlisting>
EXEC SQL int i = 4;
</programlisting>
    You can have as many declare sections in a program as you like.
   </para>
________________________________________________________-->
   <para>
    这个节开始于：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
</programlisting>
    并且结束于：
<programlisting>
EXEC SQL END DECLARE SECTION;
</programlisting>
    在这两行之间，必须是正常的 C 变量声明，例如：
<programlisting>
int   x = 4;
char  foo[16], bar[16];
</programlisting>
    如你所见，你可以选择为变量赋一个初始值。变量的可见范围由定义它的节在程序中的位置决定。你也可以使用下面的语法声明变量，这种语法将会隐式地创建一个声明节：
<programlisting>
EXEC SQL int i = 4;
</programlisting>
    你可以按照你的意愿在一个程序中放上多个声明节。
   </para>
<!-- pgdoc-cn_end sig_en=b3283a90ba1452ffa4b7894e7bdc8410 -->

<!-- pgdoc-cn_start sig_en=c572cb58fa83939a008eaa1de4828e07 sig_cn_org=None source=14.1 
   <para>
    The declarations are also echoed to the output file as normal C
    variables, so there's no need to declare them again.  Variables
    that are not intended to be used in SQL commands can be declared
    normally outside these special sections.
   </para>
________________________________________________________-->
   <para>
    这些声明也会作为 C 变量被重复在输出文件中，因此无需再次声明它们。不准备在 SQL 命令中使用的变量可以正常地在这些特殊节之外声明。
   </para>
<!-- pgdoc-cn_end sig_en=c572cb58fa83939a008eaa1de4828e07 -->

<!-- pgdoc-cn_start sig_en=85631506c5715fc0f1741505b70ea6c1 sig_cn_org=None source=14.1 
   <para>
    The definition of a structure or union also must be listed inside
    a <literal>DECLARE</literal> section. Otherwise the preprocessor cannot
    handle these types since it does not know the definition.
   </para>
________________________________________________________-->
   <para>
    一个结构或联合的定义也必须被列在一个<literal>DECLARE</literal>节中。否则预处理器无法处理这些类型，因为它不知道它们的定义。
   </para>
<!-- pgdoc-cn_end sig_en=85631506c5715fc0f1741505b70ea6c1 -->
  </sect2>

  <sect2 id="ecpg-retrieving">
<!-- pgdoc-cn_start sig_en=fc6924f2dbc5a99f8eb0d87b159c31d2 sig_cn_org=None source=14.1 
   <title>Retrieving Query Results</title>
________________________________________________________-->
   <title>检索查询结果</title>
<!-- pgdoc-cn_end sig_en=fc6924f2dbc5a99f8eb0d87b159c31d2 -->

<!-- pgdoc-cn_start sig_en=7bde42ea6fb3127a3b1772a7e28ba7b7 sig_cn_org=None source=14.1 
   <para>
    Now you should be able to pass data generated by your program into
    an SQL command.  But how do you retrieve the results of a query?
    For that purpose, embedded SQL provides special variants of the
    usual commands <command>SELECT</command> and
    <command>FETCH</command>.  These commands have a special
    <literal>INTO</literal> clause that specifies which host variables
    the retrieved values are to be stored in.
    <command>SELECT</command> is used for a query that returns only
    single row, and <command>FETCH</command> is used for a query that
    returns multiple rows, using a cursor.
   </para>
________________________________________________________-->
   <para>
    现在你应该能够把程序产生的数据传递到一个 SQL 命令中了。但是怎么检索一个查询的结果呢？为此，嵌入式  SQL 提供了常规命令<command>SELECT</command>和<command>FETCH</command>的特殊变体。这些命令有一个特殊的<literal>INTO</literal>子句，它指定被检索到的值要被存储在哪些主变量中。<command>SELECT</command>被用于只返回单一行的查询，而<command>FETCH</command>被用于使用一个游标返回多行的查询。
   </para>
<!-- pgdoc-cn_end sig_en=7bde42ea6fb3127a3b1772a7e28ba7b7 -->

<!-- pgdoc-cn_start sig_en=7fa5f40ce87fb6031a5b5d50bd7eec81 sig_cn_org=None source=14.1 
   <para>
    Here is an example:
<programlisting>
/*
 * assume this table:
 * CREATE TABLE test1 (a int, b varchar(50));
 */

EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL SELECT a, b INTO :v1, :v2 FROM test;
</programlisting>
    So the <literal>INTO</literal> clause appears between the select
    list and the <literal>FROM</literal> clause.  The number of
    elements in the select list and the list after
    <literal>INTO</literal> (also called the target list) must be
    equal.
   </para>
________________________________________________________-->
   <para>
    这里是一个例子：
<programlisting>
/*
 * 假定有这个表：
 * CREATE TABLE test1 (a int, b varchar(50));
 */

EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL SELECT a, b INTO :v1, :v2 FROM test;
</programlisting>
    那么<literal>INTO</literal>子句出现在选择列表和<literal>FROM</literal>子句之间。选择列表中的元素数量必须和<literal>INTO</literal>后面列表（也被称为目标列表）的元素数量相等。
   </para>
<!-- pgdoc-cn_end sig_en=7fa5f40ce87fb6031a5b5d50bd7eec81 -->

<!-- pgdoc-cn_start sig_en=f1eabb248db5c21e6f509b3b416555ab sig_cn_org=None source=14.1 
   <para>
    Here is an example using the command <command>FETCH</command>:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL DECLARE foo CURSOR FOR SELECT a, b FROM test;

 ...

do
{
    ...
    EXEC SQL FETCH NEXT FROM foo INTO :v1, :v2;
    ...
} while (...);
</programlisting>
    Here the <literal>INTO</literal> clause appears after all the
    normal clauses.
   </para>
________________________________________________________-->
   <para>
    这里有一个使用命令<command>FETCH</command>的例子：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int v1;
VARCHAR v2;
EXEC SQL END DECLARE SECTION;

 ...

EXEC SQL DECLARE foo CURSOR FOR SELECT a, b FROM test;

 ...

do
{
    ...
    EXEC SQL FETCH NEXT FROM foo INTO :v1, :v2;
    ...
} while (...);
</programlisting>
    这里<literal>INTO</literal>子句出现在所有正常子句的后面。
   </para>
<!-- pgdoc-cn_end sig_en=f1eabb248db5c21e6f509b3b416555ab -->

  </sect2>

  <sect2 id="ecpg-variables-type-mapping">
<!-- pgdoc-cn_start sig_en=c2d147fdf1fe4255b52ac0d783363281 sig_cn_org=None source=14.1 
   <title>Type Mapping</title>
________________________________________________________-->
   <title>类型映射</title>
<!-- pgdoc-cn_end sig_en=c2d147fdf1fe4255b52ac0d783363281 -->

<!-- pgdoc-cn_start sig_en=f6a8a99bc5a65362ca49bd08c756edc8 sig_cn_org=None source=14.1 
   <para>
    When ECPG applications exchange values between the PostgreSQL
    server and the C application, such as when retrieving query
    results from the server or executing SQL statements with input
    parameters, the values need to be converted between PostgreSQL
    data types and host language variable types (C language data
    types, concretely).  One of the main points of ECPG is that it
    takes care of this automatically in most cases.
   </para>
________________________________________________________-->
   <para>
    当 ECPG 应用在 PostgreSQL 服务器和 C 应用之间交换值时（例如从服务器检索查询结果时或者用输入参数执行 SQL 语句时），值需要在 PostgreSQL 数据类型和主语言变量类型（具体来说是 C 语言数据类型）之间转换。ECPG 的要点之一就是它会在大多数情况下自动搞定这种转换。
   </para>
<!-- pgdoc-cn_end sig_en=f6a8a99bc5a65362ca49bd08c756edc8 -->

<!-- pgdoc-cn_start sig_en=32fec4d7ad5e7ad55f75ee836818badd sig_cn_org=None source=14.1 
   <para>
    In this respect, there are two kinds of data types: Some simple
    PostgreSQL data types, such as <type>integer</type>
    and <type>text</type>, can be read and written by the application
    directly.  Other PostgreSQL data types, such
    as <type>timestamp</type> and <type>numeric</type> can only be
    accessed through special library functions; see
    <xref linkend="ecpg-special-types"/>.
   </para>
________________________________________________________-->
   <para>
    在这方面有两类数据类型：一些简单 PostgreSQL 数据类型（例如<type>integer</type>和<type>text</type>）可以被应用直接读取和写入。其他 PostgreSQL 数据类型（例如<type>timestamp</type>和<type>numeric</type>）只能通过特殊库函数访问，见<xref linkend="ecpg-special-types"/>。
   </para>
<!-- pgdoc-cn_end sig_en=32fec4d7ad5e7ad55f75ee836818badd -->

<!-- pgdoc-cn_start sig_en=7e03314b550aa6a9723f8a05a1d3ac6c sig_cn_org=None source=14.1 
   <para>
    <xref linkend="ecpg-datatype-hostvars-table"/> shows which PostgreSQL
    data types correspond to which C data types.  When you wish to
    send or receive a value of a given PostgreSQL data type, you
    should declare a C variable of the corresponding C data type in
    the declare section.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="ecpg-datatype-hostvars-table"/>展示了哪种 PostgreSQL 数据类型对应于哪一种 C 数据类型。当你希望发送或接收一种给定 PostgreSQL 数据类型的值时，你应该在声明节中声明一个具有相应 C 数据类型的 C 变量。
   </para>
<!-- pgdoc-cn_end sig_en=7e03314b550aa6a9723f8a05a1d3ac6c -->

   <table id="ecpg-datatype-hostvars-table">
<!-- pgdoc-cn_start sig_en=fe6ebf168b07a77f7b926e36360b80d6 sig_cn_org=None source=14.1 
    <title>Mapping Between PostgreSQL Data Types and C Variable Types</title>
________________________________________________________-->
    <title>在 PostgreSQL 数据类型和 C 变量类型之间映射</title>
<!-- pgdoc-cn_end sig_en=fe6ebf168b07a77f7b926e36360b80d6 -->
    <tgroup cols="2">
     <thead>
<!-- pgdoc-cn_start sig_en=6b6b52582f1ffff08d3a6a570d196776 sig_cn_org=None source=14.1 
      <row>
       <entry>PostgreSQL data type</entry>
       <entry>Host variable type</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>PostgreSQL 数据类型</entry>
       <entry>主变量类型</entry>
      </row>
<!-- pgdoc-cn_end sig_en=6b6b52582f1ffff08d3a6a570d196776 -->
     </thead>

     <tbody>
      <row>
       <entry><type>smallint</type></entry>
       <entry><type>short</type></entry>
      </row>

      <row>
       <entry><type>integer</type></entry>
       <entry><type>int</type></entry>
      </row>

      <row>
       <entry><type>bigint</type></entry>
       <entry><type>long long int</type></entry>
      </row>

<!-- pgdoc-cn_start sig_en=d95d6038227bb2b0da2bba2e9c4c2f40 sig_cn_org=None source=14.1 
      <row>
       <entry><type>decimal</type></entry>
       <entry><type>decimal</type><footnote id="ecpg-datatype-table-fn"><para>This type can only be accessed through special library functions; see <xref linkend="ecpg-special-types"/>.</para></footnote></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>decimal</type></entry>
       <entry><type>decimal</type><footnote id="ecpg-datatype-table-fn"><para>这种类型只能通过特殊的库函数访问，见<xref linkend="ecpg-special-types"/>。</para></footnote></entry>
      </row>
<!-- pgdoc-cn_end sig_en=d95d6038227bb2b0da2bba2e9c4c2f40 -->

      <row>
       <entry><type>numeric</type></entry>
       <entry><type>numeric</type><footnoteref linkend="ecpg-datatype-table-fn"/></entry>
      </row>

      <row>
       <entry><type>real</type></entry>
       <entry><type>float</type></entry>
      </row>

      <row>
       <entry><type>double precision</type></entry>
       <entry><type>double</type></entry>
      </row>

      <row>
       <entry><type>smallserial</type></entry>
       <entry><type>short</type></entry>
      </row>

      <row>
       <entry><type>serial</type></entry>
       <entry><type>int</type></entry>
      </row>

      <row>
       <entry><type>bigserial</type></entry>
       <entry><type>long long int</type></entry>
      </row>

      <row>
       <entry><type>oid</type></entry>
       <entry><type>unsigned int</type></entry>
      </row>

<!-- pgdoc-cn_start sig_en=9ef9d127ab2d3e8bbee1c4a5dc1f8910 sig_cn_org=None source=14.1 
      <row>
       <entry><type>character(<replaceable>n</replaceable>)</type>, <type>varchar(<replaceable>n</replaceable>)</type>, <type>text</type></entry>
       <entry><type>char[<replaceable>n</replaceable>+1]</type>, <type>VARCHAR[<replaceable>n</replaceable>+1]</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>character(<replaceable>n</replaceable>)</type>, <type>varchar(<replaceable>n</replaceable>)</type>, <type>text</type></entry>
       <entry><type>char[<replaceable>n</replaceable>+1]</type>, <type>VARCHAR[<replaceable>n</replaceable>+1]</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=9ef9d127ab2d3e8bbee1c4a5dc1f8910 -->

      <row>
       <entry><type>name</type></entry>
       <entry><type>char[NAMEDATALEN]</type></entry>
      </row>

      <row>
       <entry><type>timestamp</type></entry>
       <entry><type>timestamp</type><footnoteref linkend="ecpg-datatype-table-fn"/></entry>
      </row>

      <row>
       <entry><type>interval</type></entry>
       <entry><type>interval</type><footnoteref linkend="ecpg-datatype-table-fn"/></entry>
      </row>

      <row>
       <entry><type>date</type></entry>
       <entry><type>date</type><footnoteref linkend="ecpg-datatype-table-fn"/></entry>
      </row>

<!-- pgdoc-cn_start sig_en=378a5c6504065fe090593472278d203c sig_cn_org=None source=14.1 
      <row>
       <entry><type>boolean</type></entry>
       <entry><type>bool</type><footnote><para>declared in <filename>ecpglib.h</filename> if not native</para></footnote></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>boolean</type></entry>
       <entry><type>bool</type><footnote><para>如果不是本地化类型，则声明在<filename>ecpglib.h</filename>中</para></footnote></entry>
      </row>
<!-- pgdoc-cn_end sig_en=378a5c6504065fe090593472278d203c -->

<!-- pgdoc-cn_start sig_en=7698e8bbadc1cb808908626897243b89 sig_cn_org=None source=14.1 
      <row>
       <entry><type>bytea</type></entry>
       <entry><type>char *</type>, <type>bytea[<replaceable>n</replaceable>]</type></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>bytea</type></entry>
       <entry><type>char *</type>, <type>bytea[<replaceable>n</replaceable>]</type></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7698e8bbadc1cb808908626897243b89 -->
     </tbody>
    </tgroup>
   </table>

   <sect3 id="ecpg-char">
<!-- pgdoc-cn_start sig_en=37fa7f1719d29215b3f88be3260512f2 sig_cn_org=None source=14.1 
    <title>Handling Character Strings</title>
________________________________________________________-->
    <title>处理字符串</title>
<!-- pgdoc-cn_end sig_en=37fa7f1719d29215b3f88be3260512f2 -->

<!-- pgdoc-cn_start sig_en=06c09163d6cb038b3519272a297cf807 sig_cn_org=None source=14.1 
    <para>
     To handle SQL character string data types, such
     as <type>varchar</type> and <type>text</type>, there are two
     possible ways to declare the host variables.
    </para>
________________________________________________________-->
    <para>
     要处理 SQL 字符串数据类型（例如<type>varchar</type>以及<type>text</type>），有两种可能的方式来声明主变量。
    </para>
<!-- pgdoc-cn_end sig_en=06c09163d6cb038b3519272a297cf807 -->

<!-- pgdoc-cn_start sig_en=0e737245c2e94462f3cd7b23cd6503e1 sig_cn_org=None source=14.1 
    <para>
     One way is using <type>char[]</type>, an array
     of <type>char</type>, which is the most common way to handle
     character data in C.
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    char str[50];
EXEC SQL END DECLARE SECTION;
</programlisting>
     Note that you have to take care of the length yourself.  If you
     use this host variable as the target variable of a query which
     returns a string with more than 49 characters, a buffer overflow
     occurs.
    </para>
________________________________________________________-->
    <para>
     一种方式是使用<type>char[]</type>（一个<type>char</type>字符串），这是在 C 中处理字符数据最常见的方式。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    char str[50];
EXEC SQL END DECLARE SECTION;
</programlisting>
     注意你必须自己照看长度。如果你把这个主变量用作一个查询的目标变量并且该查询返回超过 49 个字符的字符串，那么将会发生缓冲区溢出。
    </para>
<!-- pgdoc-cn_end sig_en=0e737245c2e94462f3cd7b23cd6503e1 -->

<!-- pgdoc-cn_start sig_en=2ce0c2c5abf3f9b21258391f604d44c2 sig_cn_org=None source=14.1 
    <para>
     The other way is using the <type>VARCHAR</type> type, which is a
     special type provided by ECPG.  The definition on an array of
     type <type>VARCHAR</type> is converted into a
     named <type>struct</type> for every variable. A declaration like:
<programlisting>
VARCHAR var[180];
</programlisting>
     is converted into:
<programlisting>
struct varchar_var { int len; char arr[180]; } var;
</programlisting>
     The member <structfield>arr</structfield> hosts the string
     including a terminating zero byte.  Thus, to store a string in
     a <type>VARCHAR</type> host variable, the host variable has to be
     declared with the length including the zero byte terminator.  The
     member <structfield>len</structfield> holds the length of the
     string stored in the <structfield>arr</structfield> without the
     terminating zero byte.  When a host variable is used as input for
     a query, if <literal>strlen(arr)</literal>
     and <structfield>len</structfield> are different, the shorter one
     is used.
    </para>
________________________________________________________-->
    <para>
     另一种方式是使用<type>VARCHAR</type>类型，它是 ECPG 提供的一种特殊类型。在一个<type>VARCHAR</type>类型数组上的定义会被转变成一个命名的<type>struct</type>。这样一个声明：
<programlisting>
VARCHAR var[180];
</programlisting>
     会被转变成：
<programlisting>
struct varchar_var { int len; char arr[180]; } var;
</programlisting>
     成员<structfield>arr</structfield>容纳包含一个终止零字节的字符串。因此，要在一个<type>VARCHAR</type>主变量中存储一个字符串，该主变量必须被声明为具有包括零字节终止符的长度。成员<structfield>len</structfield>保存存储在<structfield>arr</structfield>中的字符串的长度，不包括终止零字节。当一个主变量被用做一个查询的输入时，如果<literal>strlen(arr)</literal>和<structfield>len</structfield>不同，将使用短的那一个。
    </para>
<!-- pgdoc-cn_end sig_en=2ce0c2c5abf3f9b21258391f604d44c2 -->

<!-- pgdoc-cn_start sig_en=18d92cc696bf4af25fa9649757e75ce8 sig_cn_org=None source=14.1 
    <para>
     <type>VARCHAR</type> can be written in upper or lower case, but
     not in mixed case.
    </para>
________________________________________________________-->
    <para>
     <type>VARCHAR</type>可以被写成大写或小写形式，但是不能大小写混合。
    </para>
<!-- pgdoc-cn_end sig_en=18d92cc696bf4af25fa9649757e75ce8 -->

<!-- pgdoc-cn_start sig_en=817f6b81647539215268d065ae7c9739 sig_cn_org=None source=14.1 
    <para>
     <type>char</type> and <type>VARCHAR</type> host variables can
     also hold values of other SQL types, which will be stored in
     their string forms.
    </para>
________________________________________________________-->
    <para>
     <type>char</type>和<type>VARCHAR</type>主变量也可以保存其他 SQL 类型的值，它们将被存储为字符串形式。
    </para>
<!-- pgdoc-cn_end sig_en=817f6b81647539215268d065ae7c9739 -->
   </sect3>

   <sect3 id="ecpg-special-types">
<!-- pgdoc-cn_start sig_en=1e4509e9a25921eef2061b1594d8b3ad sig_cn_org=None source=14.1 
    <title>Accessing Special Data Types</title>
________________________________________________________-->
    <title>访问特殊数据类型</title>
<!-- pgdoc-cn_end sig_en=1e4509e9a25921eef2061b1594d8b3ad -->

<!-- pgdoc-cn_start sig_en=d76d6e3942eb78ab5f5ffc635a89fa9f sig_cn_org=None source=14.1 
    <para>
     ECPG contains some special types that help you to interact easily
     with some special data types from the PostgreSQL server. In
     particular, it has implemented support for the
     <type>numeric</type>, <type>decimal</type>, <type>date</type>, <type>timestamp</type>,
     and <type>interval</type> types.  These data types cannot usefully be
     mapped to primitive host variable types (such
     as <type>int</type>, <type>long long int</type>,
     or <type>char[]</type>), because they have a complex internal
     structure.  Applications deal with these types by declaring host
     variables in special types and accessing them using functions in
     the pgtypes library.  The pgtypes library, described in detail
     in <xref linkend="ecpg-pgtypes"/> contains basic functions to deal
     with those types, such that you do not need to send a query to
     the SQL server just for adding an interval to a time stamp for
     example.
    </para>
________________________________________________________-->
    <para>
     ECPG 包含一些特殊类型帮助你容易地与来自 PostgreSQL 服务器的一些特殊数据类型交互。特别地，它已经实现了对于<type>numeric</type>、<type>decimal</type>、<type>date</type>、<type>timestamp</type>以及<type>interval</type>类型的支持。这些数据类型无法有效地被映射到原始的主变量类型（例如<type>int</type>、<type>long long int</type>或者<type>char[]</type>），因为它们有一种复杂的内部结构。应用通过声明特殊类型的主变量以及使用 pgtypes 库中的函数来处理这些类型。pgtypes 库（在<xref linkend="ecpg-pgtypes"/>中详细描述）包含了处理这些类型的基本函数，这样你不需要仅仅为了给一个时间戳增加一个时段而发送一个查询给 SQL 服务器。
    </para>
<!-- pgdoc-cn_end sig_en=d76d6e3942eb78ab5f5ffc635a89fa9f -->

<!-- pgdoc-cn_start sig_en=fe19e289f8a45c807aebe07178eac7cb sig_cn_org=None source=14.1 
    <para>
     The follow subsections describe these special data types. For
     more details about pgtypes library functions,
     see <xref linkend="ecpg-pgtypes"/>.
    </para>
________________________________________________________-->
    <para>
     下面的小节描述了这些特殊数据类型。关于 pgtypes 库函数的更多细节，请参考<xref linkend="ecpg-pgtypes"/>。
    </para>
<!-- pgdoc-cn_end sig_en=fe19e289f8a45c807aebe07178eac7cb -->

    <sect4>
<!-- pgdoc-cn_start sig_en=a5d9bc1838539721fa3ef84c263a4f26 sig_cn_org=None source=14.1 
     <title>timestamp, date</title>
________________________________________________________-->
     <title>timestamp, date</title>
<!-- pgdoc-cn_end sig_en=a5d9bc1838539721fa3ef84c263a4f26 -->

<!-- pgdoc-cn_start sig_en=771af19e00eb36c9d9005f5c2a91a3c6 sig_cn_org=None source=14.1 
     <para>
      Here is a pattern for handling <type>timestamp</type> variables
      in the ECPG host application.
     </para>
________________________________________________________-->
     <para>
      这里有一种在 ECPG 主应用中处理<type>timestamp</type>变量的模式。
     </para>
<!-- pgdoc-cn_end sig_en=771af19e00eb36c9d9005f5c2a91a3c6 -->

<!-- pgdoc-cn_start sig_en=c94676557ea46a0bda7e96b8ecb6f91b sig_cn_org=None source=14.1 
     <para>
      First, the program has to include the header file for the
      <type>timestamp</type> type:
<programlisting>
#include &lt;pgtypes_timestamp.h>
</programlisting>
     </para>
________________________________________________________-->
     <para>
      首先，程序必须包括用于<type>timestamp</type>类型的头文件：
<programlisting>
#include &lt;pgtypes_timestamp.h>
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=c94676557ea46a0bda7e96b8ecb6f91b -->

<!-- pgdoc-cn_start sig_en=4575d5b95faac08b4215198907925b11 sig_cn_org=None source=14.1 
     <para>
      Next, declare a host variable as type <type>timestamp</type> in
      the declare section:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
timestamp ts;
EXEC SQL END DECLARE SECTION;
</programlisting>
     </para>
________________________________________________________-->
     <para>
      接着，在声明节中声明一个主变量为类型<type>timestamp</type>：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
timestamp ts;
EXEC SQL END DECLARE SECTION;
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=4575d5b95faac08b4215198907925b11 -->

<!-- pgdoc-cn_start sig_en=199c1f8f1c5a07b2de9147c975d275e5 sig_cn_org=None source=14.1 
     <para>
      And after reading a value into the host variable, process it
      using pgtypes library functions. In following example, the
      <type>timestamp</type> value is converted into text (ASCII) form
      with the <function>PGTYPEStimestamp_to_asc()</function>
      function:
<programlisting>
EXEC SQL SELECT now()::timestamp INTO :ts;

printf("ts = %s\n", PGTYPEStimestamp_to_asc(ts));
</programlisting>
      This example will show some result like following:
<screen>
ts = 2010-06-27 18:03:56.949343
</screen>
     </para>
________________________________________________________-->
     <para>
      并且在读入一个值到该主变量中之后，使用 pgtypes 库函数处理它。在下面的例子中，<type>timestamp</type>值被<function>PGTYPEStimestamp_to_asc()</function>函数转变成文本（ASCII）形式：
<programlisting>
EXEC SQL SELECT now()::timestamp INTO :ts;

printf("ts = %s\n", PGTYPEStimestamp_to_asc(ts));
</programlisting>
      这个例子将展示像下面形式的一些结果：
<screen>
ts = 2010-06-27 18:03:56.949343
</screen>
     </para>
<!-- pgdoc-cn_end sig_en=199c1f8f1c5a07b2de9147c975d275e5 -->

<!-- pgdoc-cn_start sig_en=6524ab0cc8a9a7c1e174de50d7998e8b sig_cn_org=None source=14.1 
     <para>
      In addition, the DATE type can be handled in the same way. The
      program has to include <filename>pgtypes_date.h</filename>, declare a host variable
      as the date type and convert a DATE value into a text form using
      <function>PGTYPESdate_to_asc()</function> function. For more details about the
      pgtypes library functions, see <xref linkend="ecpg-pgtypes"/>.
     </para>
________________________________________________________-->
     <para>
      另外，DATE 类型可以用相同的方式处理。程序必须包括<filename>pgtypes_date.h</filename>，声明一个主变量为日期类型并且将一个 DATE 值使用<function>PGTYPESdate_to_asc()</function>函数转变成一种文本形式。关于 pgtypes 库函数的更多细节，请参考<xref linkend="ecpg-pgtypes"/>。
     </para>
<!-- pgdoc-cn_end sig_en=6524ab0cc8a9a7c1e174de50d7998e8b -->
    </sect4>

    <sect4 id="ecpg-type-interval">
<!-- pgdoc-cn_start sig_en=08d0f211f87216ee021a57fb6a1c7108 sig_cn_org=None source=14.1 
     <title>interval</title>
________________________________________________________-->
     <title>interval</title>
<!-- pgdoc-cn_end sig_en=08d0f211f87216ee021a57fb6a1c7108 -->

<!-- pgdoc-cn_start sig_en=b570a31b8496e4bab3104d1d3115b6a2 sig_cn_org=None source=14.1 
     <para>
      The handling of the <type>interval</type> type is also similar
      to the <type>timestamp</type> and <type>date</type> types.  It
      is required, however, to allocate memory for
      an <type>interval</type> type value explicitly.  In other words,
      the memory space for the variable has to be allocated in the
      heap memory, not in the stack memory.
     </para>
________________________________________________________-->
     <para>
      对<type>interval</type>类型的处理也类似于<type>timestamp</type>和<type>date</type>类型。不过，必须显式为一个<type>interval</type>类型分配内存。换句话说，该变量的内存空间必须在堆内存中分配，而不是在栈内存中分配。
     </para>
<!-- pgdoc-cn_end sig_en=b570a31b8496e4bab3104d1d3115b6a2 -->

<!-- pgdoc-cn_start sig_en=31f9669fc482417ed772fed8d1d80042 sig_cn_org=None source=14.1 
     <para>
      Here is an example program:
<programlisting>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pgtypes_interval.h>

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    interval *in;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    in = PGTYPESinterval_new();
    EXEC SQL SELECT '1 min'::interval INTO :in;
    printf("interval = %s\n", PGTYPESinterval_to_asc(in));
    PGTYPESinterval_free(in);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
</programlisting>
     </para>
________________________________________________________-->
     <para>
      这里是一个例子程序：
<programlisting>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pgtypes_interval.h>

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    interval *in;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    in = PGTYPESinterval_new();
    EXEC SQL SELECT '1 min'::interval INTO :in;
    printf("interval = %s\n", PGTYPESinterval_to_asc(in));
    PGTYPESinterval_free(in);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=31f9669fc482417ed772fed8d1d80042 -->
    </sect4>

    <sect4 id="ecpg-type-numeric-decimal">
<!-- pgdoc-cn_start sig_en=dc5e6f46b9d23f1988c5fc6192f2dba2 sig_cn_org=None source=14.1 
     <title>numeric, decimal</title>
________________________________________________________-->
     <title>numeric, decimal</title>
<!-- pgdoc-cn_end sig_en=dc5e6f46b9d23f1988c5fc6192f2dba2 -->

<!-- pgdoc-cn_start sig_en=dadcfe30acaa073ab740f4a92d808c27 sig_cn_org=None source=14.1 
     <para>
      The handling of the <type>numeric</type>
      and <type>decimal</type> types is similar to the
      <type>interval</type> type: It requires defining a pointer,
      allocating some memory space on the heap, and accessing the
      variable using the pgtypes library functions.  For more details
      about the pgtypes library functions,
      see <xref linkend="ecpg-pgtypes"/>.
     </para>
________________________________________________________-->
     <para>
      <type>numeric</type>和<type>decimal</type>类型的处理类似于<type>interval</type>类型：需要定义一个指针、在堆上分配一些内存空间并且使用 pgtypes 库函数访问该变量。关于 pgtypes 库函数的更多细节，请参考<xref linkend="ecpg-pgtypes"/>。
     </para>
<!-- pgdoc-cn_end sig_en=dadcfe30acaa073ab740f4a92d808c27 -->

<!-- pgdoc-cn_start sig_en=50df346ae2c49f533a8528a49c29e6e9 sig_cn_org=None source=14.1 
     <para>
      No functions are provided specifically for
      the <type>decimal</type> type.  An application has to convert it
      to a <type>numeric</type> variable using a pgtypes library
      function to do further processing.
     </para>
________________________________________________________-->
     <para>
      pgtypes 库没有特别为<type>decimal</type>类型提供函数。一个应用必须使用一个 pgtypes 库函数把它转变成一个<type>numeric</type>变量以便进一步处理。
     </para>
<!-- pgdoc-cn_end sig_en=50df346ae2c49f533a8528a49c29e6e9 -->

<!-- pgdoc-cn_start sig_en=edacfab6c5aa9c18164b54fb2057dd3f sig_cn_org=None source=14.1 
     <para>
      Here is an example program handling <type>numeric</type>
      and <type>decimal</type> type variables.
<programlisting>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pgtypes_numeric.h>

EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    numeric *num;
    numeric *num2;
    decimal *dec;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    num = PGTYPESnumeric_new();
    dec = PGTYPESdecimal_new();

    EXEC SQL SELECT 12.345::numeric(4,2), 23.456::decimal(4,2) INTO :num, :dec;

    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 0));
    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 1));
    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 2));

    /* Convert decimal to numeric to show a decimal value. */
    num2 = PGTYPESnumeric_new();
    PGTYPESnumeric_from_decimal(dec, num2);

    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 0));
    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 1));
    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 2));

    PGTYPESnumeric_free(num2);
    PGTYPESdecimal_free(dec);
    PGTYPESnumeric_free(num);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
</programlisting>
     </para>
________________________________________________________-->
     <para>
      这里是一个处理<type>numeric</type>和<type>decimal</type>类型变量的例子程序。
<programlisting>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;pgtypes_numeric.h>

EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    numeric *num;
    numeric *num2;
    decimal *dec;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    num = PGTYPESnumeric_new();
    dec = PGTYPESdecimal_new();

    EXEC SQL SELECT 12.345::numeric(4,2), 23.456::decimal(4,2) INTO :num, :dec;

    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 0));
    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 1));
    printf("numeric = %s\n", PGTYPESnumeric_to_asc(num, 2));

    /* 将一个decimal转变成numeric以显示一个decimal值。 */
    num2 = PGTYPESnumeric_new();
    PGTYPESnumeric_from_decimal(dec, num2);

    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 0));
    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 1));
    printf("decimal = %s\n", PGTYPESnumeric_to_asc(num2, 2));

    PGTYPESnumeric_free(num2);
    PGTYPESdecimal_free(dec);
    PGTYPESnumeric_free(num);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=edacfab6c5aa9c18164b54fb2057dd3f -->
    </sect4>

    <sect4>
<!-- pgdoc-cn_start sig_en=7a376f93a292fb93c7f866c12fc2fb4c sig_cn_org=None source=14.1 
     <title>bytea</title>
________________________________________________________-->
     <title>bytea</title>
<!-- pgdoc-cn_end sig_en=7a376f93a292fb93c7f866c12fc2fb4c -->

<!-- pgdoc-cn_start sig_en=958aa1acf7c81634c66f83be59a95feb sig_cn_org=None source=14.1 
     <para>
      The handling of the <type>bytea</type> type is similar to
      that of <type>VARCHAR</type>. The definition on an array of type
      <type>bytea</type> is converted into a named struct for every
      variable. A declaration like:
<programlisting>
bytea var[180];
</programlisting>
     is converted into:
<programlisting>
struct bytea_var { int len; char arr[180]; } var;
</programlisting>
      The member <structfield>arr</structfield> hosts binary format
      data. It can also handle <literal>'\0'</literal> as part of
      data, unlike <type>VARCHAR</type>.
      The data is converted from/to hex format and sent/received by
      ecpglib.
     </para>
________________________________________________________-->
     <para>
      <type>bytea</type>类型的处理与<type>VARCHAR</type>相似。
      类型<type>bytea</type>的数组上的定义被转换为每个变量的命名结构。声明类似于：
<programlisting>
bytea var[180];
</programlisting>
     is converted into:
<programlisting>
struct bytea_var { int len; char arr[180]; } var;
</programlisting>
      成员 <structfield>arr</structfield> 承载二进制格式数据。
      不像<type>VARCHAR</type>，它还可以作为数据的一部分处理 <literal>'\0'</literal> 。
      数据往/来转换为十六进制格式，并通过 ecpglib 发送/接收。
     </para>
<!-- pgdoc-cn_end sig_en=958aa1acf7c81634c66f83be59a95feb -->

     <note>
<!-- pgdoc-cn_start sig_en=3ea3cce607b76b4f3f6bc5ca885c885f sig_cn_org=None source=14.1 
      <para>
       <type>bytea</type> variable can be used only when
       <xref linkend="guc-bytea-output"/> is set to <literal>hex</literal>.
      </para>
________________________________________________________-->
      <para>
       <type>bytea</type> 变量只有在 <xref linkend="guc-bytea-output"/> 被设置为 <literal>hex</literal>时才能够使用.
      </para>
<!-- pgdoc-cn_end sig_en=3ea3cce607b76b4f3f6bc5ca885c885f -->
     </note>
    </sect4>
   </sect3>

   <sect3 id="ecpg-variables-nonprimitive-c">
<!-- pgdoc-cn_start sig_en=4fbb38f18daa71ba0a1bd6b1e4080135 sig_cn_org=None source=14.1 
    <title>Host Variables with Nonprimitive Types</title>
________________________________________________________-->
    <title>非简单类型的主变量</title>
<!-- pgdoc-cn_end sig_en=4fbb38f18daa71ba0a1bd6b1e4080135 -->

<!-- pgdoc-cn_start sig_en=587b3a3552483ba5c3972db8001058b9 sig_cn_org=None source=14.1 
    <para>
     As a host variable you can also use arrays, typedefs, structs, and
     pointers.
    </para>
________________________________________________________-->
    <para>
     你也可以把数组、typedefs、结构和指针用作主变量。
    </para>
<!-- pgdoc-cn_end sig_en=587b3a3552483ba5c3972db8001058b9 -->

    <sect4 id="ecpg-variables-arrays">
<!-- pgdoc-cn_start sig_en=0fb3985cbab3b01370993f5ad778a91b sig_cn_org=None source=14.1 
     <title>Arrays</title>
________________________________________________________-->
     <title>数组</title>
<!-- pgdoc-cn_end sig_en=0fb3985cbab3b01370993f5ad778a91b -->

<!-- pgdoc-cn_start sig_en=d4892bec0655ace9a94c8440d75f7768 sig_cn_org=None source=14.1 
     <para>
      There are two use cases for arrays as host variables.  The first
      is a way to store some text string in <type>char[]</type>
      or <type>VARCHAR[]</type>, as
      explained in <xref linkend="ecpg-char"/>.  The second use case is to
      retrieve multiple rows from a query result without using a
      cursor.  Without an array, to process a query result consisting
      of multiple rows, it is required to use a cursor and
      the <command>FETCH</command> command.  But with array host
      variables, multiple rows can be received at once.  The length of
      the array has to be defined to be able to accommodate all rows,
      otherwise a buffer overflow will likely occur.
     </para>
________________________________________________________-->
     <para>
      将数组用作主变量有两种情况。第一种如<xref linkend="ecpg-char"/>所述，是一种将一些文本字符串存储在<type>char[]</type>或<type>VARCHAR[]</type>中的方法。第二种是不用一个游标从一个查询结果中检索多行。如果没有一个数组，要处理由多个行组成的查询结果，我们需要使用一个游标以及<command>FETCH</command>命令。但是使用数组主变量，多个行可以被一次收取。该数组的长度必须被定义成足以容纳所有的行，否则很可能会发生一次缓冲区溢出。
     </para>
<!-- pgdoc-cn_end sig_en=d4892bec0655ace9a94c8440d75f7768 -->

<!-- pgdoc-cn_start sig_en=973a4d619aee7ca43080e4935142257e sig_cn_org=None source=14.1 
     <para>
      Following example scans the <literal>pg_database</literal>
      system table and shows all OIDs and names of the available
      databases:
<programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    int dbid[8];
    char dbname[8][16];
    int i;
EXEC SQL END DECLARE SECTION;

    memset(dbname, 0, sizeof(char)* 16 * 8);
    memset(dbid, 0, sizeof(int) * 8);

    EXEC SQL CONNECT TO testdb;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    /* Retrieve multiple rows into arrays at once. */
    EXEC SQL SELECT oid,datname INTO :dbid, :dbname FROM pg_database;

    for (i = 0; i &lt; 8; i++)
        printf("oid=%d, dbname=%s\n", dbid[i], dbname[i]);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
</programlisting>

    This example shows following result. (The exact values depend on
    local circumstances.)
<screen>
oid=1, dbname=template1
oid=11510, dbname=template0
oid=11511, dbname=postgres
oid=313780, dbname=testdb
oid=0, dbname=
oid=0, dbname=
oid=0, dbname=
</screen>
     </para>
________________________________________________________-->
     <para>
      下面的例子扫描<literal>pg_database</literal>系统表并且显示所有可用数据库的 OID 和名称：
<programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    int dbid[8];
    char dbname[8][16];
    int i;
EXEC SQL END DECLARE SECTION;

    memset(dbname, 0, sizeof(char)* 16 * 8);
    memset(dbid, 0, sizeof(int) * 8);

    EXEC SQL CONNECT TO testdb;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    /* 一次检索多行到数组中。 */
    EXEC SQL SELECT oid,datname INTO :dbid, :dbname FROM pg_database;

    for (i = 0; i &lt; 8; i++)
        printf("oid=%d, dbname=%s\n", dbid[i], dbname[i]);

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
</programlisting>

    这个例子显示下面的结果（确切的值取决于本地环境）。
<screen>
oid=1, dbname=template1
oid=11510, dbname=template0
oid=11511, dbname=postgres
oid=313780, dbname=testdb
oid=0, dbname=
oid=0, dbname=
oid=0, dbname=
</screen>
     </para>
<!-- pgdoc-cn_end sig_en=973a4d619aee7ca43080e4935142257e -->
    </sect4>

    <sect4 id="ecpg-variables-struct">
<!-- pgdoc-cn_start sig_en=01419cf17ea75503691388e070b410ca sig_cn_org=None source=14.1 
     <title>Structures</title>
________________________________________________________-->
     <title>结构</title>
<!-- pgdoc-cn_end sig_en=01419cf17ea75503691388e070b410ca -->

<!-- pgdoc-cn_start sig_en=27355db3812b7e0d0227df5b77df6f67 sig_cn_org=None source=14.1 
     <para>
      A structure whose member names match the column names of a query
      result, can be used to retrieve multiple columns at once.  The
      structure enables handling multiple column values in a single
      host variable.
     </para>
________________________________________________________-->
     <para>
      一个成员名称匹配查询结果列名的结构可以被用来一次检索多列。该结构使得我们能够在一个单一主变量中处理多列值。
     </para>
<!-- pgdoc-cn_end sig_en=27355db3812b7e0d0227df5b77df6f67 -->

<!-- pgdoc-cn_start sig_en=25c3ac925ca0ffef24df998059a472ae sig_cn_org=None source=14.1 
     <para>
      The following example retrieves OIDs, names, and sizes of the
      available databases from the <literal>pg_database</literal>
      system table and using
      the <function>pg_database_size()</function> function.  In this
      example, a structure variable <varname>dbinfo_t</varname> with
      members whose names match each column in
      the <literal>SELECT</literal> result is used to retrieve one
      result row without putting multiple host variables in
      the <literal>FETCH</literal> statement.
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef struct
    {
       int oid;
       char datname[65];
       long long int size;
    } dbinfo_t;

    dbinfo_t dbval;
EXEC SQL END DECLARE SECTION;

    memset(&amp;dbval, 0, sizeof(dbinfo_t));

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;
    EXEC SQL OPEN cur1;

    /* when end of result set reached, break out of while loop */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        /* Fetch multiple columns into one structure. */
        EXEC SQL FETCH FROM cur1 INTO :dbval;

        /* Print members of the structure. */
        printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname, dbval.size);
    }

    EXEC SQL CLOSE cur1;
</programlisting>
     </para>
________________________________________________________-->
     <para>
      下面的例子从<literal>pg_database</literal>系统表以及使用<function>pg_database_size()</function>函数检索可用数据库的 OID、名称和尺寸。在这个例子中，一个成员名匹配<literal>SELECT</literal>结果的每一列的结构变量<varname>dbinfo_t</varname>被用来检索结果行，而不需要把多个主变量放在<literal>FETCH</literal>语句中。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef struct
    {
       int oid;
       char datname[65];
       long long int size;
    } dbinfo_t;

    dbinfo_t dbval;
EXEC SQL END DECLARE SECTION;

    memset(&amp;dbval, 0, sizeof(dbinfo_t));

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;
    EXEC SQL OPEN cur1;

    /* 在达到结果集末尾时，跳出 while 循环 */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        /* 将多列取到一个结构中。 */
        EXEC SQL FETCH FROM cur1 INTO :dbval;

        /* 打印该结构的成员。 */
        printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname, dbval.size);
    }

    EXEC SQL CLOSE cur1;
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=25c3ac925ca0ffef24df998059a472ae -->

<!-- pgdoc-cn_start sig_en=3fc80faf6e54a5aa146595f6bff73b99 sig_cn_org=None source=14.1 
     <para>
      This example shows following result. (The exact values depend on
      local circumstances.)
<screen>
oid=1, datname=template1, size=4324580
oid=11510, datname=template0, size=4243460
oid=11511, datname=postgres, size=4324580
oid=313780, datname=testdb, size=8183012
</screen>
     </para>
________________________________________________________-->
     <para>
      这个例子会显示下列结果（确切的值取决于本地环境）。
<screen>
oid=1, datname=template1, size=4324580
oid=11510, datname=template0, size=4243460
oid=11511, datname=postgres, size=4324580
oid=313780, datname=testdb, size=8183012
</screen>
     </para>
<!-- pgdoc-cn_end sig_en=3fc80faf6e54a5aa146595f6bff73b99 -->

<!-- pgdoc-cn_start sig_en=69c8f25d8d3a1a361b91234149aea16a sig_cn_org=None source=14.1 
     <para>
      Structure host variables <quote>absorb</quote> as many columns
      as the structure as fields.  Additional columns can be assigned
      to other host variables. For example, the above program could
      also be restructured like this, with the <varname>size</varname>
      variable outside the structure:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef struct
    {
       int oid;
       char datname[65];
    } dbinfo_t;

    dbinfo_t dbval;
    long long int size;
EXEC SQL END DECLARE SECTION;

    memset(&amp;dbval, 0, sizeof(dbinfo_t));

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;
    EXEC SQL OPEN cur1;

    /* when end of result set reached, break out of while loop */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        /* Fetch multiple columns into one structure. */
        EXEC SQL FETCH FROM cur1 INTO :dbval, :size;

        /* Print members of the structure. */
        printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname, size);
    }

    EXEC SQL CLOSE cur1;
</programlisting>
     </para>
________________________________________________________-->
     <para>
      结构主变量将列尽数<quote>吸收</quote>成结构的域。额外的列可以被分配给其他主变量。例如，上面的程序也可以使用结构外部的<varname>size</varname>变量重新构造：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef struct
    {
       int oid;
       char datname[65];
    } dbinfo_t;

    dbinfo_t dbval;
    long long int size;
EXEC SQL END DECLARE SECTION;

    memset(&amp;dbval, 0, sizeof(dbinfo_t));

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database;
    EXEC SQL OPEN cur1;

    /* 在达到结果集末尾时，跳出 while 循环 */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        /* 将多列取到一个结构中。 */
        EXEC SQL FETCH FROM cur1 INTO :dbval, :size;

        /* 打印该结构的成员。 */
        printf("oid=%d, datname=%s, size=%lld\n", dbval.oid, dbval.datname, size);
    }

    EXEC SQL CLOSE cur1;
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=69c8f25d8d3a1a361b91234149aea16a -->
    </sect4>

    <sect4>
<!-- pgdoc-cn_start sig_en=2e008564ceb0903e85ea7dc00416a0f4 sig_cn_org=None source=14.1 
     <title>Typedefs</title>
________________________________________________________-->
     <title>Typedefs</title>
<!-- pgdoc-cn_end sig_en=2e008564ceb0903e85ea7dc00416a0f4 -->

<!-- pgdoc-cn_start sig_en=02769e5a5e8ba0a67986b0ab7ff79eee sig_cn_org=None source=14.1 
     <para>
      Use the <literal>typedef</literal> keyword to map new types to already
      existing types.
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef char mychartype[40];
    typedef long serial_t;
EXEC SQL END DECLARE SECTION;
</programlisting>
      Note that you could also use:
<programlisting>
EXEC SQL TYPE serial_t IS long;
</programlisting>
      This declaration does not need to be part of a declare section.
     </para>
________________________________________________________-->
     <para>
      使用<literal>typedef</literal>关键词可以把新类型映射到已经存在的类型。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    typedef char mychartype[40];
    typedef long serial_t;
EXEC SQL END DECLARE SECTION;
</programlisting>
      注意你也可以使用：
<programlisting>
EXEC SQL TYPE serial_t IS long;
</programlisting>
      这种声明不需要位于一个声明节之中。
     </para>
<!-- pgdoc-cn_end sig_en=02769e5a5e8ba0a67986b0ab7ff79eee -->
    </sect4>

    <sect4>
<!-- pgdoc-cn_start sig_en=69f49404f77f8688340022350371b697 sig_cn_org=None source=14.1 
     <title>Pointers</title>
________________________________________________________-->
     <title>指针</title>
<!-- pgdoc-cn_end sig_en=69f49404f77f8688340022350371b697 -->

<!-- pgdoc-cn_start sig_en=e8065b7c5cbbda5faac5f17799eab7e4 sig_cn_org=None source=14.1 
     <para>
      You can declare pointers to the most common types. Note however
      that you cannot use pointers as target variables of queries
      without auto-allocation. See <xref linkend="ecpg-descriptors"/>
      for more information on auto-allocation.
     </para>
________________________________________________________-->
     <para>
      你可以声明最常见类型的指针。不过注意，你不能使用指针作为不带自动分配内存的查询的目标变量。关于自动分配内存的详情请参考<xref linkend="ecpg-descriptors"/>。
     </para>
<!-- pgdoc-cn_end sig_en=e8065b7c5cbbda5faac5f17799eab7e4 -->

<!-- pgdoc-cn_start sig_en=eafdb578000751e36de78a5048916e05 sig_cn_org=None source=14.1 
     <para>
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    int   *intp;
    char **charp;
EXEC SQL END DECLARE SECTION;
</programlisting>
     </para>
________________________________________________________-->
     <para>
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    int   *intp;
    char **charp;
EXEC SQL END DECLARE SECTION;
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=eafdb578000751e36de78a5048916e05 -->
    </sect4>
   </sect3>
  </sect2>

  <sect2 id="ecpg-variables-nonprimitive-sql">
<!-- pgdoc-cn_start sig_en=e622c4b7818c1f5fdd6165d48a1a025e sig_cn_org=None source=14.1 
   <title>Handling Nonprimitive SQL Data Types</title>
________________________________________________________-->
   <title>处理非简单 SQL 数据类型</title>
<!-- pgdoc-cn_end sig_en=e622c4b7818c1f5fdd6165d48a1a025e -->

<!-- pgdoc-cn_start sig_en=335e8c58580786638b61f98efb895a57 sig_cn_org=None source=14.1 
   <para>
    This section contains information on how to handle nonscalar and
    user-defined SQL-level data types in ECPG applications.  Note that
    this is distinct from the handling of host variables of
    nonprimitive types, described in the previous section.
   </para>
________________________________________________________-->
   <para>
    这一节包含关于如何处理 ECPG 应用中非标量以及用户定义的 SQL 级别数据类型。注意这和上一节中描述的简单类型主变量的处理有所不同。
   </para>
<!-- pgdoc-cn_end sig_en=335e8c58580786638b61f98efb895a57 -->

   <sect3>
<!-- pgdoc-cn_start sig_en=0fb3985cbab3b01370993f5ad778a91b sig_cn_org=None source=14.1 
    <title>Arrays</title>
________________________________________________________-->
    <title>数组</title>
<!-- pgdoc-cn_end sig_en=0fb3985cbab3b01370993f5ad778a91b -->

<!-- pgdoc-cn_start sig_en=5abcb969100c34f964d52fb718db7a30 sig_cn_org=None source=14.1 
    <para>
     Multi-dimensional SQL-level arrays are not directly supported in ECPG.
     One-dimensional SQL-level arrays can be mapped into C array host
     variables and vice-versa.  However, when creating a statement ecpg does
     not know the types of the columns, so that it cannot check if a C array
     is input into a corresponding SQL-level array.  When processing the
     output of an SQL statement, ecpg has the necessary information and thus
     checks if both are arrays.
    </para>
________________________________________________________-->
    <para>
     ECPG 中不直接支持 SQL 级别的多维数组。一维 SQL 数组可以被映射到 C 数组主机变量，反之
     亦然。不过，在创建一个语句时，ecpg并不知道列的类型，因此它无法检查一个 C 数组否是一个
     SQL 数组的输入。在处理一个 SQL 语句的输出时，ecpg 有必需的信息并且进而检查是否两者都是
     数组。
    </para>
<!-- pgdoc-cn_end sig_en=5abcb969100c34f964d52fb718db7a30 -->

<!-- pgdoc-cn_start sig_en=e9de8c0407283eac5b170d7dd052f767 sig_cn_org=None source=14.1 
    <para>
     If a query accesses <emphasis>elements</emphasis> of an array
     separately, then this avoids the use of arrays in ECPG.  Then, a
     host variable with a type that can be mapped to the element type
     should be used.  For example, if a column type is array of
     <type>integer</type>, a host variable of type <type>int</type>
     can be used.  Also if the element type is <type>varchar</type>
     or <type>text</type>, a host variable of type <type>char[]</type>
     or <type>VARCHAR[]</type> can be used.
    </para>
________________________________________________________-->
    <para>
     如果一个查询个别地访问一个数组的<emphasis>元素</emphasis>，那么这可以避免使用 ECPG 中的数组。然后，应该使用一个能被映射到该元素类型的类型的主变量。例如，如果一个列类型是<type>integer</type>数组，可以使用一个类型<type>int</type>的主变量。还有如果元素类型是<type>varchar</type>或<type>text</type>，可以使用一个类型<type>char[]</type>或<type>VARCHAR[]</type>的主变量。
    </para>
<!-- pgdoc-cn_end sig_en=e9de8c0407283eac5b170d7dd052f767 -->

<!-- pgdoc-cn_start sig_en=47da963c2e5fa8885ba838d191de8a60 sig_cn_org=None source=14.1 
    <para>
     Here is an example.  Assume the following table:
<programlisting>
CREATE TABLE t3 (
    ii integer[]
);

testdb=&gt; SELECT * FROM t3;
     ii
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {1,2,3,4,5}
(1 row)
</programlisting>

     The following example program retrieves the 4th element of the
     array and stores it into a host variable of
     type <type>int</type>:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii;
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[4] FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH FROM cur1 INTO :ii ;
    printf("ii=%d\n", ii);
}

EXEC SQL CLOSE cur1;
</programlisting>

     This example shows the following result:
<screen>
ii=4
</screen>
    </para>
________________________________________________________-->
    <para>
     这里是一个例子。假定有下面的表：
<programlisting>
CREATE TABLE t3 (
    ii integer[]
);

testdb=&gt; SELECT * FROM t3;
     ii
-------------
 {1,2,3,4,5}
(1 row)
</programlisting>

     下面的例子程序检索数组的第四个元素并且把它存储到一个类型为<type>int</type>的主变量中：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii;
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[4] FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH FROM cur1 INTO :ii ;
    printf("ii=%d\n", ii);
}

EXEC SQL CLOSE cur1;
</programlisting>

     这个例子会显示下面的结果：
<screen>
ii=4
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=47da963c2e5fa8885ba838d191de8a60 -->

<!-- pgdoc-cn_start sig_en=270c008e151d7a04852d8faa2259aa2d sig_cn_org=None source=14.1 
    <para>
     To map multiple array elements to the multiple elements in an
     array type host variables each element of array column and each
     element of the host variable array have to be managed separately,
     for example:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii_a[8];
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[1], ii[2], ii[3], ii[4] FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH FROM cur1 INTO :ii_a[0], :ii_a[1], :ii_a[2], :ii_a[3];
    ...
}
</programlisting>
    </para>
________________________________________________________-->
    <para>
     要把多个数组元素映射到一个数组类型主变量中的多个元素，数组列的每一个元素以及主变量数组的每一个元素都必须被单独管理，例如：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii_a[8];
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[1], ii[2], ii[3], ii[4] FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH FROM cur1 INTO :ii_a[0], :ii_a[1], :ii_a[2], :ii_a[3];
    ...
}
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=270c008e151d7a04852d8faa2259aa2d -->

<!-- pgdoc-cn_start sig_en=c95d8606fd9b5e0fc6b2dde97a9f6cf3 sig_cn_org=None source=14.1 
    <para>
     Note again that
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii_a[8];
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* WRONG */
    EXEC SQL FETCH FROM cur1 INTO :ii_a;
    ...
}
</programlisting>
     would not work correctly in this case, because you cannot map an
     array type column to an array host variable directly.
    </para>
________________________________________________________-->
    <para>
     注意
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int ii_a[8];
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii FROM t3;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* 错误 */
    EXEC SQL FETCH FROM cur1 INTO :ii_a;
    ...
}
</programlisting>
     在这种情况中不会正确工作，因为你无法把一个数组类型列直接映射到一个数组主变量。
    </para>
<!-- pgdoc-cn_end sig_en=c95d8606fd9b5e0fc6b2dde97a9f6cf3 -->

<!-- pgdoc-cn_start sig_en=2bf2d348597be14ba2f409132c1683a6 sig_cn_org=None source=14.1 
    <para>
     Another workaround is to store arrays in their external string
     representation in host variables of type <type>char[]</type>
     or <type>VARCHAR[]</type>.  For more details about this
     representation, see <xref linkend="arrays-input"/>.  Note that
     this means that the array cannot be accessed naturally as an
     array in the host program (without further processing that parses
     the text representation).
    </para>
________________________________________________________-->
    <para>
     另一种变通方案是在类型<type>char[]</type>或<type>VARCHAR[]</type>的主变量中存储数组的外部字符串表达。关于这种表达的详情请见<xref linkend="arrays-input"/>。注意这意味着该数组无法作为一个主程序中的数组被自然地访问（没有解析文本表达的进一步处理）。
    </para>
<!-- pgdoc-cn_end sig_en=2bf2d348597be14ba2f409132c1683a6 -->
   </sect3>

   <sect3>
<!-- pgdoc-cn_start sig_en=f3b2f5a3e6cd2d4f9d699f2b3ad65cc7 sig_cn_org=None source=14.1 
    <title>Composite Types</title>
________________________________________________________-->
    <title>组合类型</title>
<!-- pgdoc-cn_end sig_en=f3b2f5a3e6cd2d4f9d699f2b3ad65cc7 -->

<!-- pgdoc-cn_start sig_en=19b244cfeb385a4cfb3b06f02c8996c8 sig_cn_org=None source=14.1 
    <para>
     Composite types are not directly supported in ECPG, but an easy workaround is possible.
  The
     available workarounds are similar to the ones described for
     arrays above: Either access each attribute separately or use the
     external string representation.
    </para>
________________________________________________________-->
    <para>
     ECPG 中并不直接支持组合类型，但是有一种可能的简单变通方案。可用的变通方案和上述用于数组的方案相似：要么单独访问每一个属性或者使用外部字符串表达。
    </para>
<!-- pgdoc-cn_end sig_en=19b244cfeb385a4cfb3b06f02c8996c8 -->

<!-- pgdoc-cn_start sig_en=24cc3b4aed13606bb01907a99d309356 sig_cn_org=None source=14.1 
    <para>
     For the following examples, assume the following type and table:
<programlisting>
CREATE TYPE comp_t AS (intval integer, textval varchar(32));
CREATE TABLE t4 (compval comp_t);
INSERT INTO t4 VALUES ( (256, 'PostgreSQL') );
</programlisting>

     The most obvious solution is to access each attribute separately.
     The following program retrieves data from the example table by
     selecting each attribute of the type <type>comp_t</type>
     separately:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int intval;
varchar textval[33];
EXEC SQL END DECLARE SECTION;

/* Put each element of the composite type column in the SELECT list. */
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* Fetch each element of the composite type column into host variables. */
    EXEC SQL FETCH FROM cur1 INTO :intval, :textval;

    printf("intval=%d, textval=%s\n", intval, textval.arr);
}

EXEC SQL CLOSE cur1;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     对于下列例子，假定有下面的类型和表：
<programlisting>
CREATE TYPE comp_t AS (intval integer, textval varchar(32));
CREATE TABLE t4 (compval comp_t);
INSERT INTO t4 VALUES ( (256, 'PostgreSQL') );
</programlisting>

     最显而易见的解决方案是单独访问每一个属性。下面的程序通过单独选择类型<type>comp_t</type>的每一个属性从例子表中检索数据：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int intval;
varchar textval[33];
EXEC SQL END DECLARE SECTION;

/* 将组合类型列的每一个元素放在 SELECT 列表中。 */
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* 将组合类型列的每一个元素取到主变量中。 */
    EXEC SQL FETCH FROM cur1 INTO :intval, :textval;

    printf("intval=%d, textval=%s\n", intval, textval.arr);
}

EXEC SQL CLOSE cur1;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=24cc3b4aed13606bb01907a99d309356 -->

<!-- pgdoc-cn_start sig_en=b5abd19462a6be7d157020acd56edf1f sig_cn_org=None source=14.1 
    <para>
     To enhance this example, the host variables to store values in
     the <command>FETCH</command> command can be gathered into one
     structure.  For more details about the host variable in the
     structure form, see <xref linkend="ecpg-variables-struct"/>.
     To switch to the structure, the example can be modified as below.
     The two host variables, <varname>intval</varname>
     and <varname>textval</varname>, become members of
     the <structname>comp_t</structname> structure, and the structure
     is specified on the <command>FETCH</command> command.
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
typedef struct
{
    int intval;
    varchar textval[33];
} comp_t;

comp_t compval;
EXEC SQL END DECLARE SECTION;

/* Put each element of the composite type column in the SELECT list. */
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* Put all values in the SELECT list into one structure. */
    EXEC SQL FETCH FROM cur1 INTO :compval;

    printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}

EXEC SQL CLOSE cur1;
</programlisting>

     Although a structure is used in the <command>FETCH</command>
     command, the attribute names in the <command>SELECT</command>
     clause are specified one by one.  This can be enhanced by using
     a <literal>*</literal> to ask for all attributes of the composite
     type value.
<programlisting>
...
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).* FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* Put all values in the SELECT list into one structure. */
    EXEC SQL FETCH FROM cur1 INTO :compval;

    printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}
...
</programlisting>
     This way, composite types can be mapped into structures almost
     seamlessly, even though ECPG does not understand the composite
     type itself.
    </para>
________________________________________________________-->
    <para>
     为了加强这个例子，在<command>FETCH</command>命令中存储值的主变量可以被集中在一个结构中。结构形式的主变量的详情可见<xref linkend="ecpg-variables-struct"/>。要切换到结构形式，该例子可以被改成下面的样子。两个主变量<varname>intval</varname>和<varname>textval</varname>变成<structname>comp_t</structname>结构的成员，并且该结构在<command>FETCH</command>命令中指定。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
typedef struct
{
    int intval;
    varchar textval[33];
} comp_t;

comp_t compval;
EXEC SQL END DECLARE SECTION;

/* 将组合类型列的每一个元素放在 SELECT 列表中。 */
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* 将 SELECT 列表中的所有值放入一个结构。 */
    EXEC SQL FETCH FROM cur1 INTO :compval;

    printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}

EXEC SQL CLOSE cur1;
</programlisting>

     尽管在<command>FETCH</command>命令中使用了一个结构，<command>SELECT</command>子句中的属性名还是要一个一个指定。可以通过使用一个<literal>*</literal>来要求该组合类型值的所有属性来改进。
<programlisting>
...
EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).* FROM t4;
EXEC SQL OPEN cur1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    /* 将 SELECT 列表中的所有值放入一个结构。 */
    EXEC SQL FETCH FROM cur1 INTO :compval;

    printf("intval=%d, textval=%s\n", compval.intval, compval.textval.arr);
}
...
</programlisting>
     通过这种方法，即便 ECPG 不理解组合类型本身，组合类型也能够几乎无缝地被映射到结构。
    </para>
<!-- pgdoc-cn_end sig_en=b5abd19462a6be7d157020acd56edf1f -->

<!-- pgdoc-cn_start sig_en=e2e5a575e73dfdaf232011eb7df249c1 sig_cn_org=None source=14.1 
    <para>
     Finally, it is also possible to store composite type values in
     their external string representation in host variables of
     type <type>char[]</type> or <type>VARCHAR[]</type>.  But that
     way, it is not easily possible to access the fields of the value
     from the host program.
    </para>
________________________________________________________-->
    <para>
     最后，也可以在类型<type>char[]</type>或<type>VARCHAR[]</type>的主变量中把组合类型值存储成它们的外部字符串表达。但是如果使用那种方法，就不太可能从主程序中访问该值的各个域了。
    </para>
<!-- pgdoc-cn_end sig_en=e2e5a575e73dfdaf232011eb7df249c1 -->
   </sect3>

   <sect3>
<!-- pgdoc-cn_start sig_en=ebf8e6bd66636f4bd5f9407e951b525f sig_cn_org=None source=14.1 
    <title>User-Defined Base Types</title>
________________________________________________________-->
    <title>用户定义的基础类型</title>
<!-- pgdoc-cn_end sig_en=ebf8e6bd66636f4bd5f9407e951b525f -->

<!-- pgdoc-cn_start sig_en=a9f8dc3230ca4f1e588dd90cc122dce4 sig_cn_org=None source=14.1 
    <para>
     New user-defined base types are not directly supported by ECPG.
     You can use the external string representation and host variables
     of type <type>char[]</type> or <type>VARCHAR[]</type>, and this
     solution is indeed appropriate and sufficient for many types.
    </para>
________________________________________________________-->
    <para>
     ECPG 并不直接支持新的用户定义的基本类型。你可以使用外部字符串表达以及类型<type>char[]</type>或<type>VARCHAR[]</type>的主变量，并且这种方案事实上对很多类型都是合适和足够的。
    </para>
<!-- pgdoc-cn_end sig_en=a9f8dc3230ca4f1e588dd90cc122dce4 -->

<!-- pgdoc-cn_start sig_en=02223e34519ce01953b756bbe799f5a8 sig_cn_org=None source=14.1 
    <para>
     Here is an example using the data type <type>complex</type> from
     the example in <xref linkend="xtypes"/>.  The external string
     representation of that type is <literal>(%f,%f)</literal>,
     which is defined in the
     functions <function>complex_in()</function>
     and <function>complex_out()</function> functions
     in <xref linkend="xtypes"/>.  The following example inserts the
     complex type values <literal>(1,1)</literal>
     and <literal>(3,3)</literal> into the
     columns <literal>a</literal> and <literal>b</literal>, and select
     them from the table after that.

<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    varchar a[64];
    varchar b[64];
EXEC SQL END DECLARE SECTION;

    EXEC SQL INSERT INTO test_complex VALUES ('(1,1)', '(3,3)');

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT a, b FROM test_complex;
    EXEC SQL OPEN cur1;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        EXEC SQL FETCH FROM cur1 INTO :a, :b;
        printf("a=%s, b=%s\n", a.arr, b.arr);
    }

    EXEC SQL CLOSE cur1;
</programlisting>

     This example shows following result:
<screen>
a=(1,1), b=(3,3)
</screen>
   </para>
________________________________________________________-->
    <para>
     这里有一个使用来自<xref linkend="xtypes"/>中例子里的数据类型<type>complex</type>的例子。该类型的外部字符串表达是<literal>(%f,%f)</literal>，它被定义在函数<function>complex_in()</function>以及<xref linkend="xtypes"/>中的<function>complex_out()</function>函数内。下面的例子把复杂类型值<literal>(1,1)</literal>和<literal>(3,3)</literal>插入到列<literal>a</literal>和<literal>b</literal>，并且之后把它们从表中选择出来。

<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
    varchar a[64];
    varchar b[64];
EXEC SQL END DECLARE SECTION;

    EXEC SQL INSERT INTO test_complex VALUES ('(1,1)', '(3,3)');

    EXEC SQL DECLARE cur1 CURSOR FOR SELECT a, b FROM test_complex;
    EXEC SQL OPEN cur1;

    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        EXEC SQL FETCH FROM cur1 INTO :a, :b;
        printf("a=%s, b=%s\n", a.arr, b.arr);
    }

    EXEC SQL CLOSE cur1;
</programlisting>

     这个例子会显示下列结果：
<screen>
a=(1,1), b=(3,3)
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=02223e34519ce01953b756bbe799f5a8 -->

<!-- pgdoc-cn_start sig_en=d5f870aa23ce932d905e43ab1c436113 sig_cn_org=None source=14.1 
    <para>
     Another workaround is avoiding the direct use of the user-defined
     types in ECPG and instead create a function or cast that converts
     between the user-defined type and a primitive type that ECPG can
     handle.  Note, however, that type casts, especially implicit
     ones, should be introduced into the type system very carefully.
    </para>
________________________________________________________-->
    <para>
     另一种变通方案是避免在 ECPG 中直接使用用户定义的类型，而是创建一个在用户定义的类型和 ECPG 能处理的简单类型之间转换的函数或者造型。不过要注意，在类型系统中引入类型造型（特别是隐式造型）要非常小心。
    </para>
<!-- pgdoc-cn_end sig_en=d5f870aa23ce932d905e43ab1c436113 -->

<!-- pgdoc-cn_start sig_en=4e956565391e405b4142d1318f467d84 sig_cn_org=None source=14.1 
    <para>
     For example,
<programlisting>
CREATE FUNCTION create_complex(r double, i double) RETURNS complex
LANGUAGE SQL
IMMUTABLE
AS $$ SELECT $1 * complex '(1,0')' + $2 * complex '(0,1)' $$;
</programlisting>
    After this definition, the following
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
double a, b, c, d;
EXEC SQL END DECLARE SECTION;

a = 1;
b = 2;
c = 3;
d = 4;

EXEC SQL INSERT INTO test_complex VALUES (create_complex(:a, :b), create_complex(:c, :d));
</programlisting>
    has the same effect as
<programlisting>
EXEC SQL INSERT INTO test_complex VALUES ('(1,2)', '(3,4)');
</programlisting>
    </para>
________________________________________________________-->
    <para>
     例如，
<programlisting>
CREATE FUNCTION create_complex(r double, i double) RETURNS complex
LANGUAGE SQL
IMMUTABLE
AS $$ SELECT $1 * complex '(1,0')' + $2 * complex '(0,1)' $$;
</programlisting>
    在这个定义之后 ，下面的语句
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
double a, b, c, d;
EXEC SQL END DECLARE SECTION;

a = 1;
b = 2;
c = 3;
d = 4;

EXEC SQL INSERT INTO test_complex VALUES (create_complex(:a, :b), create_complex(:c, :d));
</programlisting>
    具有和
<programlisting>
EXEC SQL INSERT INTO test_complex VALUES ('(1,2)', '(3,4)');
</programlisting>
    相同的效果。
    </para>
<!-- pgdoc-cn_end sig_en=4e956565391e405b4142d1318f467d84 -->
   </sect3>
  </sect2>

  <sect2 id="ecpg-indicators">
<!-- pgdoc-cn_start sig_en=2bdd4fbe4c65b2dfe34758bf058dce06 sig_cn_org=None source=14.1 
   <title>Indicators</title>
________________________________________________________-->
   <title>指示符</title>
<!-- pgdoc-cn_end sig_en=2bdd4fbe4c65b2dfe34758bf058dce06 -->

<!-- pgdoc-cn_start sig_en=da96f5f5a7c671080856c8fe63f95577 sig_cn_org=35cac3023cabade07e2d08a81588c7e1 source=15.7 
   <para>
    The examples above do not handle null values.  In fact, the
    retrieval examples will raise an error if they fetch a null value
    from the database.  To be able to pass null values to the database
    or retrieve null values from the database, you need to append a
    second host variable specification to each host variable that
    contains data.  This second host variable is called the
    <firstterm>indicator</firstterm> and contains a flag that tells
    whether the datum is null, in which case the value of the real
    host variable is ignored.  Here is an example that handles the
    retrieval of null values correctly:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
VARCHAR val;
int val_ind;
EXEC SQL END DECLARE SECTION:

 ...

EXEC SQL SELECT b INTO :val :val_ind FROM test1;
</programlisting>
    The indicator variable <varname>val_ind</varname> will be zero if
    the value was not null, and it will be negative if the value was
    null.  (See <xref linkend="ecpg-oracle-compat"/> to enable
    Oracle-specific behavior.)
   </para>
________________________________________________________-->
   <para>
    上面的示例不处理空值。实际上，如果从数据库中获取空值，检索示例将引发错误。
    要能够将空值传递给数据库或从数据库中检索空值，需要在包含数据的每个主机变量后附加第二个主机变量规范。
    这第二个主机变量称为<firstterm>指示器</firstterm>，其中包含一个标志，指示数据是否为空，如果是，则忽略实际主机变量的值。
    这里是一个正确处理检索空值的示例：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
VARCHAR val;
int val_ind;
EXEC SQL END DECLARE SECTION:

 ...

EXEC SQL SELECT b INTO :val :val_ind FROM test1;
</programlisting>
    指示变量<varname>val_ind</varname>如果值不为空，则为零，如果值为空，则为负数。
    （请参见<xref linkend="ecpg-oracle-compat"/>以启用特定于Oracle的行为。）
   </para>
<!-- pgdoc-cn_end sig_en=da96f5f5a7c671080856c8fe63f95577 -->

<!-- pgdoc-cn_start sig_en=df42ed252397d48e5d7c3f858435fcc1 sig_cn_org=None source=14.1 
   <para>
    The indicator has another function: if the indicator value is
    positive, it means that the value is not null, but it was
    truncated when it was stored in the host variable.
   </para>
________________________________________________________-->
   <para>
    指示符有另一种功能：如果指示符值为正，它表示值不为空，但是当它被存储在主变量中时已被截断。
   </para>
<!-- pgdoc-cn_end sig_en=df42ed252397d48e5d7c3f858435fcc1 -->

<!-- pgdoc-cn_start sig_en=a6ddea6be3ddf7d5c97282cf36eca8d5 sig_cn_org=None source=14.1 
   <para>
    If the argument <literal>-r no_indicator</literal> is passed to
    the preprocessor <command>ecpg</command>, it works in
    <quote>no-indicator</quote> mode. In no-indicator mode, if no
    indicator variable is specified, null values are signaled (on
    input and output) for character string types as empty string and
    for integer types as the lowest possible value for type (for
    example, <symbol>INT_MIN</symbol> for <type>int</type>).
   </para>
________________________________________________________-->
   <para>
    如果参数<literal>-r no_indicator</literal>被传递给预处理器<command>ecpg</command>，它会工作在<quote>无指示符</quote>模式。在无指示符模式中，如果没有指定指示符变量，对于字符串类型空值被标志（在输入和输出上）为空串，对于整数类型空值被标志为类型的最低可能值（例如，<type>int</type>的是<symbol>INT_MIN</symbol>）。
   </para>
<!-- pgdoc-cn_end sig_en=a6ddea6be3ddf7d5c97282cf36eca8d5 -->
  </sect2>
 </sect1>

 <sect1 id="ecpg-dynamic">
<!-- pgdoc-cn_start sig_en=18b9b99a9a306c99365e70272350c3d0 sig_cn_org=None source=14.1 
  <title>Dynamic SQL</title>
________________________________________________________-->
  <title>动态 SQL</title>
<!-- pgdoc-cn_end sig_en=18b9b99a9a306c99365e70272350c3d0 -->

<!-- pgdoc-cn_start sig_en=ef19abd2a09bd365f2eeec291c8bdf69 sig_cn_org=None source=14.1 
  <para>
   In many cases, the particular SQL statements that an application
   has to execute are known at the time the application is written.
   In some cases, however, the SQL statements are composed at run time
   or provided by an external source.  In these cases you cannot embed
   the SQL statements directly into the C source code, but there is a
   facility that allows you to call arbitrary SQL statements that you
   provide in a string variable.
  </para>
________________________________________________________-->
  <para>
   在很多情况中，一个应用必须要执行的特定 SQL 语句在编写该应用时就已知。不过在某些情况中，SQL 语句在运行时构造或者由一个外部来源提供。这样你就不能直接把 SQL 语句嵌入到 C 源代码，不过有一种功能允许你调用在一个字符串变量中提供的任意 SQL 语句。
  </para>
<!-- pgdoc-cn_end sig_en=ef19abd2a09bd365f2eeec291c8bdf69 -->

  <sect2 id="ecpg-dynamic-without-result">
<!-- pgdoc-cn_start sig_en=6662511d54330e2b33740d49171ead07 sig_cn_org=None source=14.1 
   <title>Executing Statements without a Result Set</title>
________________________________________________________-->
   <title>执行没有结果集的语句</title>
<!-- pgdoc-cn_end sig_en=6662511d54330e2b33740d49171ead07 -->

<!-- pgdoc-cn_start sig_en=0ecf45c46e0733b474bee2f972122b7f sig_cn_org=None source=14.1 
   <para>
    The simplest way to execute an arbitrary SQL statement is to use
    the command <command>EXECUTE IMMEDIATE</command>.  For example:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "CREATE TABLE test1 (...);";
EXEC SQL END DECLARE SECTION;

EXEC SQL EXECUTE IMMEDIATE :stmt;
</programlisting>
    <command>EXECUTE IMMEDIATE</command> can be used for SQL
    statements that do not return a result set (e.g.,
    DDL, <command>INSERT</command>, <command>UPDATE</command>,
    <command>DELETE</command>).  You cannot execute statements that
    retrieve data (e.g., <command>SELECT</command>) this way.  The
    next section describes how to do that.
   </para>
________________________________________________________-->
   <para>
    执行一个任意 SQL 语句的最简单方法是使用命令<command>EXECUTE IMMEDIATE</command>。例如：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "CREATE TABLE test1 (...);";
EXEC SQL END DECLARE SECTION;

EXEC SQL EXECUTE IMMEDIATE :stmt;
</programlisting>
    <command>EXECUTE IMMEDIATE</command>可以被用于不返回结果集的 SQL 语句（例如 DDL、<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>）。你不能用这种方法执行检索数据的语句（例如<command>SELECT</command>）。下一节将描述如何执行这一种语句。
   </para>
<!-- pgdoc-cn_end sig_en=0ecf45c46e0733b474bee2f972122b7f -->
  </sect2>

  <sect2 id="ecpg-dynamic-input">
<!-- pgdoc-cn_start sig_en=50d92ebd4263f326b84cc919ebf7029f sig_cn_org=None source=14.1 
   <title>Executing a Statement with Input Parameters</title>
________________________________________________________-->
   <title>执行一个有输入参数的语句</title>
<!-- pgdoc-cn_end sig_en=50d92ebd4263f326b84cc919ebf7029f -->

<!-- pgdoc-cn_start sig_en=7d9ca1ce31d08b79a08919b8549e83f6 sig_cn_org=None source=14.1 
   <para>
    A more powerful way to execute arbitrary SQL statements is to
    prepare them once and execute the prepared statement as often as
    you like.  It is also possible to prepare a generalized version of
    a statement and then execute specific versions of it by
    substituting parameters.  When preparing the statement, write
    question marks where you want to substitute parameters later.  For
    example:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "INSERT INTO test1 VALUES(?, ?);";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt USING 42, 'foobar';
</programlisting>
   </para>
________________________________________________________-->
   <para>
    执行任意 SQL 语句的一种更强大的方法是准备它们一次并且在每次需要时执行该预备语句。也可以准备一个一般化的语句，然后通过替换参数执行它的特定版本。在准备语句时，在你想要稍后替换参数的地方写上问号。例如：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "INSERT INTO test1 VALUES(?, ?);";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt USING 42, 'foobar';
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=7d9ca1ce31d08b79a08919b8549e83f6 -->

<!-- pgdoc-cn_start sig_en=14488fe3e97f2102ea1f6690e38d1d41 sig_cn_org=None source=14.1 
   <para>
    When you don't need the prepared statement anymore, you should
    deallocate it:
<programlisting>
EXEC SQL DEALLOCATE PREPARE <replaceable>name</replaceable>;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    当你不再需要该预备语句时，你应该释放它：
<programlisting>
EXEC SQL DEALLOCATE PREPARE <replaceable>name</replaceable>;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=14488fe3e97f2102ea1f6690e38d1d41 -->
  </sect2>

  <sect2 id="ecpg-dynamic-with-result">
<!-- pgdoc-cn_start sig_en=074035fb360faebf62bfaf992230dd18 sig_cn_org=None source=14.1 
   <title>Executing a Statement with a Result Set</title>
________________________________________________________-->
   <title>执行一个有结果集的语句</title>
<!-- pgdoc-cn_end sig_en=074035fb360faebf62bfaf992230dd18 -->

<!-- pgdoc-cn_start sig_en=54d7607acdb903865a09faeb25ecdece sig_cn_org=None source=14.1 
   <para>
    To execute an SQL statement with a single result row,
    <command>EXECUTE</command> can be used.  To save the result, add
    an <literal>INTO</literal> clause.
<programlisting><![CDATA[
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "SELECT a, b, c FROM test1 WHERE a > ?";
int v1, v2;
VARCHAR v3[50];
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt INTO :v1, :v2, :v3 USING 37;
]]>
</programlisting>
    An <command>EXECUTE</command> command can have an
    <literal>INTO</literal> clause, a <literal>USING</literal> clause,
    both, or neither.
   </para>
________________________________________________________-->
   <para>
    要执行一个只有单一结果行的 SQL 语句，可以使用<command>EXECUTE</command>。要保存结果，在其中增加一个<literal>INTO</literal>子句。
<programlisting><![CDATA[
EXEC SQL BEGIN DECLARE SECTION;
const char *stmt = "SELECT a, b, c FROM test1 WHERE a > ?";
int v1, v2;
VARCHAR v3[50];
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE mystmt FROM :stmt;
 ...
EXEC SQL EXECUTE mystmt INTO :v1, :v2, :v3 USING 37;
]]>
</programlisting>
    一个<command>EXECUTE</command>命令可以有一个<literal>INTO</literal>子句、一个<literal>USING</literal>子句，可以同时有这两个子句，也可以不带这两个子句。
   </para>
<!-- pgdoc-cn_end sig_en=54d7607acdb903865a09faeb25ecdece -->

<!-- pgdoc-cn_start sig_en=9a7b492b7b40cbfa9090f723071fe0a8 sig_cn_org=None source=14.1 
   <para>
    If a query is expected to return more than one result row, a
    cursor should be used, as in the following example.
    (See <xref linkend="ecpg-cursors"/> for more details about the
    cursor.)
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char dbaname[128];
char datname[128];
char *stmt = "SELECT u.usename as dbaname, d.datname "
             "  FROM pg_database d, pg_user u "
             "  WHERE d.datdba = u.usesysid";
EXEC SQL END DECLARE SECTION;

EXEC SQL CONNECT TO testdb AS con1 USER testuser;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

EXEC SQL PREPARE stmt1 FROM :stmt;

EXEC SQL DECLARE cursor1 CURSOR FOR stmt1;
EXEC SQL OPEN cursor1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH cursor1 INTO :dbaname,:datname;
    printf("dbaname=%s, datname=%s\n", dbaname, datname);
}

EXEC SQL CLOSE cursor1;

EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    如果一个查询被期望返回多于一个结果行，应该如下列例子所示使用一个游标（关于游标详见<xref linkend="ecpg-cursors"/>）。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char dbaname[128];
char datname[128];
char *stmt = "SELECT u.usename as dbaname, d.datname "
             "  FROM pg_database d, pg_user u "
             "  WHERE d.datdba = u.usesysid";
EXEC SQL END DECLARE SECTION;

EXEC SQL CONNECT TO testdb AS con1 USER testuser;
EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

EXEC SQL PREPARE stmt1 FROM :stmt;

EXEC SQL DECLARE cursor1 CURSOR FOR stmt1;
EXEC SQL OPEN cursor1;

EXEC SQL WHENEVER NOT FOUND DO BREAK;

while (1)
{
    EXEC SQL FETCH cursor1 INTO :dbaname,:datname;
    printf("dbaname=%s, datname=%s\n", dbaname, datname);
}

EXEC SQL CLOSE cursor1;

EXEC SQL COMMIT;
EXEC SQL DISCONNECT ALL;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=9a7b492b7b40cbfa9090f723071fe0a8 -->
  </sect2>
 </sect1>

 <sect1 id="ecpg-pgtypes">
<!-- pgdoc-cn_start sig_en=c634c2c292cb8dcc9e913f36c401eb42 sig_cn_org=None source=14.1 
  <title>pgtypes Library</title>
________________________________________________________-->
  <title>pgtypes 库</title>
<!-- pgdoc-cn_end sig_en=c634c2c292cb8dcc9e913f36c401eb42 -->

<!-- pgdoc-cn_start sig_en=4a2fccf83484731598036b7bf0c1ceac sig_cn_org=None source=14.1 
  <para>
   The pgtypes library maps <productname>PostgreSQL</productname> database
   types to C equivalents that can be used in C programs. It also offers
   functions to do basic calculations with those types within C, i.e., without
   the help of the <productname>PostgreSQL</productname> server. See the
   following example:
<programlisting><![CDATA[
EXEC SQL BEGIN DECLARE SECTION;
   date date1;
   timestamp ts1, tsout;
   interval iv1;
   char *out;
EXEC SQL END DECLARE SECTION;

PGTYPESdate_today(&date1);
EXEC SQL SELECT started, duration INTO :ts1, :iv1 FROM datetbl WHERE d=:date1;
PGTYPEStimestamp_add_interval(&ts1, &iv1, &tsout);
out = PGTYPEStimestamp_to_asc(&tsout);
printf("Started + duration: %s\n", out);
PGTYPESchar_free(out);
]]>
</programlisting>
  </para>
________________________________________________________-->
  <para>
   pgtypes 库将<productname>PostgreSQL</productname>数据库类型映射到 C 中等价的类型以便在 C 程序中使用。它还提供在 C 中对这些类型进行基本计算的函数，即不依赖<productname>PostgreSQL</productname>服务器进行计算。请看下面的例子：
<programlisting><![CDATA[
EXEC SQL BEGIN DECLARE SECTION;
   date date1;
   timestamp ts1, tsout;
   interval iv1;
   char *out;
EXEC SQL END DECLARE SECTION;

PGTYPESdate_today(&date1);
EXEC SQL SELECT started, duration INTO :ts1, :iv1 FROM datetbl WHERE d=:date1;
PGTYPEStimestamp_add_interval(&ts1, &iv1, &tsout);
out = PGTYPEStimestamp_to_asc(&tsout);
printf("Started + duration: %s\n", out);
PGTYPESchar_free(out);
]]>
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=4a2fccf83484731598036b7bf0c1ceac -->

  <sect2 id="ecpg-pgtypes-cstrings">
<!-- pgdoc-cn_start sig_en=11f6d2f189db9e6107b063027383c78c sig_cn_org=None source=14.1 
   <title>Character Strings</title>
________________________________________________________-->
   <title>字符串</title>
<!-- pgdoc-cn_end sig_en=11f6d2f189db9e6107b063027383c78c -->
<!-- pgdoc-cn_start sig_en=6326fc25a456b1e384d25795f7b708de sig_cn_org=None source=14.1 
   <para>
   Some functions such as <function>PGTYPESnumeric_to_asc</function> return
   a pointer to a freshly allocated character string. These results should be
   freed with <function>PGTYPESchar_free</function> instead of
   <function>free</function>. (This is important only on Windows, where
   memory allocation and release sometimes need to be done by the same
   library.)
   </para>
________________________________________________________-->
   <para>
   <function>PGTYPESnumeric_to_asc</function>之类的一些函数返回一个新分配的字符串的指针。这些结果应该用<function>PGTYPESchar_free</function>而不是<function>free</function>释放（这只在Windows上很重要，因为Windows上的内存分配和释放有时候需要由同一个库完成）。
   </para>
<!-- pgdoc-cn_end sig_en=6326fc25a456b1e384d25795f7b708de -->
  </sect2>

  <sect2 id="ecpg-pgtypes-numeric">
<!-- pgdoc-cn_start sig_en=b8467552e7a446e4f1c8f2c6ad2ab661 sig_cn_org=None source=14.1 
   <title>The numeric Type</title>
________________________________________________________-->
   <title>numeric类型</title>
<!-- pgdoc-cn_end sig_en=b8467552e7a446e4f1c8f2c6ad2ab661 -->
<!-- pgdoc-cn_start sig_en=08f8b4cacc2858d569135a3cca53f429 sig_cn_org=None source=14.1 
   <para>
    The numeric type offers to do calculations with arbitrary precision. See
    <xref linkend="datatype-numeric"/> for the equivalent type in the
    <productname>PostgreSQL</productname> server. Because of the arbitrary precision this
    variable needs to be able to expand and shrink dynamically. That's why you
    can only create numeric variables on the heap, by means of the
    <function>PGTYPESnumeric_new</function> and <function>PGTYPESnumeric_free</function>
    functions. The decimal type, which is similar but limited in precision,
    can be created on the stack as well as on the heap.
   </para>
________________________________________________________-->
   <para>
    numeric类型用来完成对任意精度的计算。<productname>PostgreSQL</productname>服务器中等效的类型请见<xref linkend="datatype-numeric"/>。因为要用于任意精度，这种变量需要能够动态地扩展和收缩。这也是为什么你只能用<function>PGTYPESnumeric_new</function>和<function>PGTYPESnumeric_free</function>函数在堆上创建numeric变量。decimal类型与numeric类型相似但是在精度上有限制，decimal类型可以在堆上创建也可以在栈上创建。
   </para>
<!-- pgdoc-cn_end sig_en=08f8b4cacc2858d569135a3cca53f429 -->
<!-- pgdoc-cn_start sig_en=5f43675323456dc7e8406cde1d10b056 sig_cn_org=None source=14.1 
   <para>
   The following functions can be used to work with the numeric type:
   <variablelist>
    <varlistentry>
     <term><function>PGTYPESnumeric_new</function></term>
     <listitem>
      <para>
      Request a pointer to a newly allocated numeric variable.
<synopsis>
numeric *PGTYPESnumeric_new(void);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_free</function></term>
     <listitem>
      <para>
      Free a numeric type, release all of its memory.
<synopsis>
void PGTYPESnumeric_free(numeric *var);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_asc</function></term>
     <listitem>
      <para>
       Parse a numeric type from its string notation.
<synopsis>
numeric *PGTYPESnumeric_from_asc(char *str, char **endptr);
</synopsis>
       Valid formats are for example:
        <literal>-2</literal>,
        <literal>.794</literal>,
        <literal>+3.44</literal>,
        <literal>592.49E07</literal> or
        <literal>-32.84e-4</literal>.
       If the value could be parsed successfully, a valid pointer is returned,
       else the NULL pointer. At the moment ECPG always parses the complete
       string and so it currently does not support to store the address of the
       first invalid character in <literal>*endptr</literal>. You can safely
       set <literal>endptr</literal> to NULL.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_asc</function></term>
     <listitem>
      <para>
       Returns a pointer to a string allocated by <function>malloc</function> that contains the string
       representation of the numeric type <literal>num</literal>.
<synopsis>
char *PGTYPESnumeric_to_asc(numeric *num, int dscale);
</synopsis>
       The numeric value will be printed with <literal>dscale</literal> decimal
       digits, with rounding applied if necessary.
       The result must be freed with <function>PGTYPESchar_free()</function>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_add</function></term>
     <listitem>
      <para>
       Add two numeric variables into a third one.
<synopsis>
int PGTYPESnumeric_add(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       The function adds the variables <literal>var1</literal> and
       <literal>var2</literal> into the result variable
       <literal>result</literal>.
       The function returns 0 on success and -1 in case of error.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_sub</function></term>
     <listitem>
      <para>
       Subtract two numeric variables and return the result in a third one.
<synopsis>
int PGTYPESnumeric_sub(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       The function subtracts the variable <literal>var2</literal> from
       the variable <literal>var1</literal>. The result of the operation is
       stored in the variable <literal>result</literal>.
       The function returns 0 on success and -1 in case of error.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_mul</function></term>
     <listitem>
      <para>
       Multiply two numeric variables and return the result in a third one.
<synopsis>
int PGTYPESnumeric_mul(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       The function multiplies the variables <literal>var1</literal> and
       <literal>var2</literal>. The result of the operation is stored in the
       variable <literal>result</literal>.
       The function returns 0 on success and -1 in case of error.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_div</function></term>
     <listitem>
      <para>
       Divide two numeric variables and return the result in a third one.
<synopsis>
int PGTYPESnumeric_div(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       The function divides the variables <literal>var1</literal> by
       <literal>var2</literal>. The result of the operation is stored in the
       variable <literal>result</literal>.
       The function returns 0 on success and -1 in case of error.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_cmp</function></term>
     <listitem>
      <para>
       Compare two numeric variables.
<synopsis>
int PGTYPESnumeric_cmp(numeric *var1, numeric *var2)
</synopsis>
       This function compares two numeric variables. In case of error,
       <literal>INT_MAX</literal> is returned. On success, the function
       returns one of three possible results:
       <itemizedlist>
        <listitem>
         <para>
          1, if <literal>var1</literal> is bigger than <literal>var2</literal>
         </para>
        </listitem>
        <listitem>
         <para>
          -1, if <literal>var1</literal> is smaller than <literal>var2</literal>
         </para>
        </listitem>
        <listitem>
         <para>
          0, if <literal>var1</literal> and <literal>var2</literal> are equal
         </para>
        </listitem>
       </itemizedlist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_int</function></term>
     <listitem>
      <para>
       Convert an int variable to a numeric variable.
<synopsis>
int PGTYPESnumeric_from_int(signed int int_val, numeric *var);
</synopsis>
       This function accepts a variable of type signed int and stores it
       in the numeric variable <literal>var</literal>. Upon success, 0 is returned and
       -1 in case of a failure.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_long</function></term>
     <listitem>
      <para>
       Convert a long int variable to a numeric variable.
<synopsis>
int PGTYPESnumeric_from_long(signed long int long_val, numeric *var);
</synopsis>
       This function accepts a variable of type signed long int and stores it
       in the numeric variable <literal>var</literal>. Upon success, 0 is returned and
       -1 in case of a failure.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_copy</function></term>
     <listitem>
      <para>
       Copy over one numeric variable into another one.
<synopsis>
int PGTYPESnumeric_copy(numeric *src, numeric *dst);
</synopsis>
       This function copies over the value of the variable that
       <literal>src</literal> points to into the variable that <literal>dst</literal>
       points to. It returns 0 on success and -1 if an error occurs.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_double</function></term>
     <listitem>
      <para>
       Convert a variable of type double to a numeric.
<synopsis>
int  PGTYPESnumeric_from_double(double d, numeric *dst);
</synopsis>
       This function accepts a variable of type double and stores the result
       in the variable that <literal>dst</literal> points to. It returns 0 on success
       and -1 if an error occurs.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_double</function></term>
     <listitem>
      <para>
       Convert a variable of type numeric to double.
<synopsis>
int PGTYPESnumeric_to_double(numeric *nv, double *dp)
</synopsis>
       The function converts the numeric value from the variable that
       <literal>nv</literal> points to into the double variable that <literal>dp</literal> points
       to. It returns 0 on success and -1 if an error occurs, including
       overflow. On overflow, the global variable <literal>errno</literal> will be set
       to <literal>PGTYPES_NUM_OVERFLOW</literal> additionally.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_int</function></term>
     <listitem>
      <para>
       Convert a variable of type numeric to int.
<synopsis>
int PGTYPESnumeric_to_int(numeric *nv, int *ip);
</synopsis>
       The function converts the numeric value from the variable that
       <literal>nv</literal> points to into the integer variable that <literal>ip</literal>
       points to. It returns 0 on success and -1 if an error occurs, including
       overflow. On overflow, the global variable <literal>errno</literal> will be set
       to <literal>PGTYPES_NUM_OVERFLOW</literal> additionally.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_long</function></term>
     <listitem>
      <para>
       Convert a variable of type numeric to long.
<synopsis>
int PGTYPESnumeric_to_long(numeric *nv, long *lp);
</synopsis>
       The function converts the numeric value from the variable that
       <literal>nv</literal> points to into the long integer variable that
       <literal>lp</literal> points to. It returns 0 on success and -1 if an error
       occurs, including overflow. On overflow, the global variable
       <literal>errno</literal> will be set to <literal>PGTYPES_NUM_OVERFLOW</literal>
       additionally.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_decimal</function></term>
     <listitem>
      <para>
       Convert a variable of type numeric to decimal.
<synopsis>
int PGTYPESnumeric_to_decimal(numeric *src, decimal *dst);
</synopsis>
       The function converts the numeric value from the variable that
       <literal>src</literal> points to into the decimal variable that
       <literal>dst</literal> points to. It returns 0 on success and -1 if an error
       occurs, including overflow. On overflow, the global variable
       <literal>errno</literal> will be set to <literal>PGTYPES_NUM_OVERFLOW</literal>
       additionally.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_decimal</function></term>
     <listitem>
      <para>
       Convert a variable of type decimal to numeric.
<synopsis>
int PGTYPESnumeric_from_decimal(decimal *src, numeric *dst);
</synopsis>
       The function converts the decimal value from the variable that
       <literal>src</literal> points to into the numeric variable that
       <literal>dst</literal> points to. It returns 0 on success and -1 if an error
       occurs. Since the decimal type is implemented as a limited version of
       the numeric type, overflow cannot occur with this conversion.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   </para>
________________________________________________________-->
   <para>
   下列函数可以用于numeric类型：
   <variablelist>
    <varlistentry>
     <term><function>PGTYPESnumeric_new</function></term>
     <listitem>
      <para>
      请求一个指向新分配的numeric变量的指针。
<synopsis>
numeric *PGTYPESnumeric_new(void);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_free</function></term>
     <listitem>
      <para>
      释放一个numeric类型，释放它所有的内存。
<synopsis>
void PGTYPESnumeric_free(numeric *var);
</synopsis>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_asc</function></term>
     <listitem>
      <para>
       从字符串记号中解析一个numeric类型。
<synopsis>
numeric *PGTYPESnumeric_from_asc(char *str, char **endptr);
</synopsis>
       例如，可用的格式是：
        <literal>-2</literal>、
        <literal>.794</literal>、
        <literal>+3.44</literal>、
        <literal>592.49E07</literal>或者
        <literal>-32.84e-4</literal>。
       如果值能被成功地解析，将返回一个有效的指针，否则返回 NULL 指针。目前 ECPG 总是解析整个字符串并且因此当前不支持把第一个非法字符的地址存储在<literal>*endptr</literal>中。你可以安全地把<literal>endptr</literal>设置为 NULL。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_asc</function></term>
     <listitem>
      <para>
       返回由<function>malloc</function>分配的字符串的指针，它包含numeric类型<literal>num</literal>的字符串表达。
<synopsis>
char *PGTYPESnumeric_to_asc(numeric *num, int dscale);
</synopsis>
       numeric值将被使用<literal>dscale</literal>小数位打印，必要时会圆整。结果必须用<function>PGTYPESchar_free()</function>释放。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_add</function></term>
     <listitem>
      <para>
       把两个numeric变量相加放到第三个numeric变量中。
<synopsis>
int PGTYPESnumeric_add(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       该函数把变量<literal>var1</literal>和<literal>var2</literal>相加放到结果变量<literal>result</literal>中。成功时该函数返回 0，出错时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_sub</function></term>
     <listitem>
      <para>
       把两个numeric变量相减并且把结果返回到第三个numeric变量。
<synopsis>
int PGTYPESnumeric_sub(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       该函数把变量<literal>var2</literal>从变量<literal>var1</literal>中减除。该操作的结果被存储在变量<literal>result</literal>中。成功时该函数返回 0，出错时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_mul</function></term>
     <listitem>
      <para>
       把两个numeric变量相乘并且把结果返回到第三个numeric变量。
<synopsis>
int PGTYPESnumeric_mul(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       该函数把变量<literal>var1</literal>和<literal>var2</literal>相乘。该操作的结果被存储在变量<literal>result</literal>中。成功时该函数返回 0，出错时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_div</function></term>
     <listitem>
      <para>
       把两个numeric变量相除并且把结果返回到第三个numeric变量。
<synopsis>
int PGTYPESnumeric_div(numeric *var1, numeric *var2, numeric *result);
</synopsis>
       该函数用变量<literal>var2</literal>除变量<literal>var1</literal>。该操作的结果被存储在变量<literal>result</literal>中。成功时该函数返回 0，出错时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_cmp</function></term>
     <listitem>
      <para>
       比较两个numeric变量。
<synopsis>
int PGTYPESnumeric_cmp(numeric *var1, numeric *var2)
</synopsis>
       这个函数比较两个numeric变量。错误时会返回<literal>INT_MAX</literal>。成功时，该函数返回三种可能结果之一：
       <itemizedlist>
        <listitem>
         <para>
          <literal>var1</literal>大于<literal>var2</literal>则返回 1
         </para>
        </listitem>
        <listitem>
         <para>
          如果<literal>var1</literal>小于<literal>var2</literal>则返回 -1
         </para>
        </listitem>
        <listitem>
         <para>
          如果<literal>var1</literal>和<literal>var2</literal>相等则返回 0
         </para>
        </listitem>
       </itemizedlist>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_int</function></term>
     <listitem>
      <para>
       把一个整数变量转换成一个numeric变量。
<synopsis>
int PGTYPESnumeric_from_int(signed int int_val, numeric *var);
</synopsis>
       这个函数接受一个有符号整型变量并且把它存储在numeric变量<literal>var</literal>中。成功时返回 0，失败时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_long</function></term>
     <listitem>
      <para>
       把一个长整型变量转换成一个numeric变量。
<synopsis>
int PGTYPESnumeric_from_long(signed long int long_val, numeric *var);
</synopsis>
       这个函数接受一个有符号长整型变量并且把它存储在numeric变量<literal>var</literal>中。成功时返回 0，失败时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_copy</function></term>
     <listitem>
      <para>
       把一个numeric变量复制到另一个中。
<synopsis>
int PGTYPESnumeric_copy(numeric *src, numeric *dst);
</synopsis>
       这个函数把<literal>src</literal>指向的变量的值复制到<literal>dst</literal>指向的变量中。成功时该函数返回 0，出错时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_double</function></term>
     <listitem>
      <para>
       把一个双精度类型的变量转换成一个numeric变量。
<synopsis>
int  PGTYPESnumeric_from_double(double d, numeric *dst);
</synopsis>
       这个函数接受一个双精度类型的变量并且把结果存储在<literal>dst</literal>指向的变量中。成功时该函数返回 0，出错时返回 -1。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_double</function></term>
     <listitem>
      <para>
       将一个numeric类型的变量转换成双精度。
<synopsis>
int PGTYPESnumeric_to_double(numeric *nv, double *dp)
</synopsis>
       这个函数将<literal>nv</literal>指向的变量中的numeric值转换成<literal>dp</literal>指向的双精度变量。成功时该函数返回 0，出错时返回 -1（包括溢出）。溢出时，全局变量<literal>errno</literal>将被额外地设置成<literal>PGTYPES_NUM_OVERFLOW</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_int</function></term>
     <listitem>
      <para>
       将一个numeric类型的变量转换成整数。
<synopsis>
int PGTYPESnumeric_to_int(numeric *nv, int *ip);
</synopsis>
       该函数将<literal>nv</literal>指向的变量的numeric值转换成<literal>ip</literal>指向的整数变量。成功时该函数返回 0，出错时返回 -1（包括溢出）。溢出时，全局变量<literal>errno</literal>将被额外地设置成<literal>PGTYPES_NUM_OVERFLOW</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_long</function></term>
     <listitem>
      <para>
       将一个numeric类型的变量转换成长整型。
<synopsis>
int PGTYPESnumeric_to_long(numeric *nv, long *lp);
</synopsis>
       该函数将<literal>nv</literal>指向的变量的numeric值转换成<literal>ip</literal>指向的长整型变量。成功时该函数返回 0，出错时返回 -1（包括溢出）。溢出时，全局变量<literal>errno</literal>将被额外地设置成<literal>PGTYPES_NUM_OVERFLOW</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_to_decimal</function></term>
     <listitem>
      <para>
       将一个numeric类型的变量转换成decimal。
<synopsis>
int PGTYPESnumeric_to_decimal(numeric *src, decimal *dst);
</synopsis>
       该函数将<literal>nv</literal>指向的变量的numeric值转换成<literal>ip</literal>指向的decimal变量。成功时该函数返回 0，出错时返回 -1（包括溢出）。溢出时，全局变量<literal>errno</literal>将被额外地设置成<literal>PGTYPES_NUM_OVERFLOW</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>PGTYPESnumeric_from_decimal</function></term>
     <listitem>
      <para>
       将一个decimal类型的变量转换成numeric。
<synopsis>
int PGTYPESnumeric_from_decimal(decimal *src, numeric *dst);
</synopsis>
       该函数将<literal>nv</literal>指向的变量的decimal值转换成<literal>ip</literal>指向的numeric变量。成功时该函数返回 0，出错时返回 -1（包括溢出）。因为decimal类型被实现为numeric类型的一个有限的版本，在这个转换上不会发生溢出。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=5f43675323456dc7e8406cde1d10b056 -->
  </sect2>

  <sect2 id="ecpg-pgtypes-date">
<!-- pgdoc-cn_start sig_en=31b452ebb20dcc9f46535591d7b3f3de sig_cn_org=None source=14.1 
   <title>The date Type</title>
________________________________________________________-->
   <title>日期类型</title>
<!-- pgdoc-cn_end sig_en=31b452ebb20dcc9f46535591d7b3f3de -->
<!-- pgdoc-cn_start sig_en=cc8b0005c1ef8f081a877a5989e028aa sig_cn_org=None source=14.1 
   <para>
    The date type in C enables your programs to deal with data of the SQL type
    date. See <xref linkend="datatype-datetime"/> for the equivalent type in the
    <productname>PostgreSQL</productname> server.
   </para>
________________________________________________________-->
   <para>
    C 中的日期类型允许你的程序处理 SQL 日期类型的数据。<productname>PostgreSQL</productname>服务器的等效类型可见<xref linkend="datatype-datetime"/>。
   </para>
<!-- pgdoc-cn_end sig_en=cc8b0005c1ef8f081a877a5989e028aa -->
<!-- pgdoc-cn_start sig_en=8607d0f474631a0a78421f77b0795f35 sig_cn_org=None source=14.1 
   <para>
    The following functions can be used to work with the date type:
    <variablelist>
     <varlistentry id="pgtypesdatefromtimestamp">
      <term><function>PGTYPESdate_from_timestamp</function></term>
      <listitem>
       <para>
        Extract the date part from a timestamp.
<synopsis>
date PGTYPESdate_from_timestamp(timestamp dt);
</synopsis>
        The function receives a timestamp as its only argument and returns the
        extracted date part from this timestamp.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatefromasc">
      <term><function>PGTYPESdate_from_asc</function></term>
      <listitem>
       <para>
       Parse a date from its textual representation.
<synopsis>
date PGTYPESdate_from_asc(char *str, char **endptr);
</synopsis>
        The function receives a C char* string <literal>str</literal> and a pointer to
        a C char* string <literal>endptr</literal>. At the moment ECPG always parses
        the complete string and so it currently does not support to store the
        address of the first invalid character in <literal>*endptr</literal>.
        You can safely set <literal>endptr</literal> to NULL.
       </para>
       <para>
        Note that the function always assumes MDY-formatted dates and there is
        currently no variable to change that within ECPG.
       </para>
       <para>
        <xref linkend="ecpg-pgtypesdate-from-asc-table"/> shows the allowed input formats.
       </para>
        <table id="ecpg-pgtypesdate-from-asc-table">
         <title>Valid Input Formats for <function>PGTYPESdate_from_asc</function></title>
         <tgroup cols="2">
          <thead>
           <row>
            <entry>Input</entry>
            <entry>Result</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>January 8, 1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1999-01-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1/8/1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1/18/1999</literal></entry>
            <entry><literal>January 18, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>01/02/03</literal></entry>
            <entry><literal>February 1, 2003</literal></entry>
           </row>
           <row>
            <entry><literal>1999-Jan-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>Jan-08-1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>99-Jan-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-99</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-06</literal></entry>
            <entry><literal>January 8, 2006</literal></entry>
           </row>
           <row>
            <entry><literal>Jan-08-99</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>19990108</literal></entry>
            <entry><literal>ISO 8601; January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>990108</literal></entry>
            <entry><literal>ISO 8601; January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1999.008</literal></entry>
            <entry><literal>year and day of year</literal></entry>
           </row>
           <row>
            <entry><literal>J2451187</literal></entry>
            <entry><literal>Julian day</literal></entry>
           </row>
           <row>
            <entry><literal>January 8, 99 BC</literal></entry>
            <entry><literal>year 99 before the Common Era</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatetoasc">
      <term><function>PGTYPESdate_to_asc</function></term>
      <listitem>
       <para>
        Return the textual representation of a date variable.
<synopsis>
char *PGTYPESdate_to_asc(date dDate);
</synopsis>
        The function receives the date <literal>dDate</literal> as its only parameter.
        It will output the date in the form <literal>1999-01-18</literal>, i.e., in the
        <literal>YYYY-MM-DD</literal> format.
        The result must be freed with <function>PGTYPESchar_free()</function>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatejulmdy">
      <term><function>PGTYPESdate_julmdy</function></term>
      <listitem>
       <para>
        Extract the values for the day, the month and the year from a variable
        of type date.
<synopsis>
void PGTYPESdate_julmdy(date d, int *mdy);
</synopsis>
       <!-&minus; almost same description as for rjulmdy() -&minus;>
        The function receives the date <literal>d</literal> and a pointer to an array
        of 3 integer values <literal>mdy</literal>. The variable name indicates
        the sequential order: <literal>mdy[0]</literal> will be set to contain the
        number of the month, <literal>mdy[1]</literal> will be set to the value of the
        day and <literal>mdy[2]</literal> will contain the year.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatemdyjul">
      <term><function>PGTYPESdate_mdyjul</function></term>
      <listitem>
       <para>
        Create a date value from an array of 3 integers that specify the
        day, the month and the year of the date.
<synopsis>
void PGTYPESdate_mdyjul(int *mdy, date *jdate);
</synopsis>
        The function receives the array of the 3 integers (<literal>mdy</literal>) as
        its first argument and as its second argument a pointer to a variable
        of type date that should hold the result of the operation.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatedayofweek">
      <term><function>PGTYPESdate_dayofweek</function></term>
      <listitem>
       <para>
        Return a number representing the day of the week for a date value.
<synopsis>
int PGTYPESdate_dayofweek(date d);
</synopsis>
        The function receives the date variable <literal>d</literal> as its only
        argument and returns an integer that indicates the day of the week for
        this date.
        <itemizedlist>
         <listitem>
          <para>
           0 - Sunday
          </para>
         </listitem>
         <listitem>
          <para>
           1 - Monday
          </para>
         </listitem>
         <listitem>
          <para>
           2 - Tuesday
          </para>
         </listitem>
         <listitem>
          <para>
           3 - Wednesday
          </para>
         </listitem>
         <listitem>
          <para>
           4 - Thursday
          </para>
         </listitem>
         <listitem>
          <para>
           5 - Friday
          </para>
         </listitem>
         <listitem>
          <para>
           6 - Saturday
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatetoday">
      <term><function>PGTYPESdate_today</function></term>
      <listitem>
       <para>
        Get the current date.
<synopsis>
void PGTYPESdate_today(date *d);
</synopsis>
        The function receives a pointer to a date variable (<literal>d</literal>)
        that it sets to the current date.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatefmtasc">
      <term><function>PGTYPESdate_fmt_asc</function></term>
      <listitem>
       <para>
        Convert a variable of type date to its textual representation using a
        format mask.
<synopsis>
int PGTYPESdate_fmt_asc(date dDate, char *fmtstring, char *outbuf);
</synopsis>
        The function receives the date to convert (<literal>dDate</literal>), the
        format mask (<literal>fmtstring</literal>) and the string that will hold the
        textual representation of the date (<literal>outbuf</literal>).
       </para>
       <para>
        On success, 0 is returned and a negative value if an error occurred.
       </para>
       <para>
        The following literals are the field specifiers you can use:
        <itemizedlist>
         <listitem>
          <para>
           <literal>dd</literal> - The number of the day of the month.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>mm</literal> - The number of the month of the year.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>yy</literal> - The number of the year as a two digit number.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>yyyy</literal> - The number of the year as a four digit number.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ddd</literal> - The name of the day (abbreviated).
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>mmm</literal> - The name of the month (abbreviated).
          </para>
         </listitem>
        </itemizedlist>
        All other characters are copied 1:1 to the output string.
       </para>
       <para>
        <xref linkend="ecpg-pgtypesdate-fmt-asc-example-table"/> indicates a few possible formats. This will give
        you an idea of how to use this function. All output lines are based on
        the same date: November 23, 1959.
       </para>
        <table id="ecpg-pgtypesdate-fmt-asc-example-table">
         <title>Valid Input Formats for <function>PGTYPESdate_fmt_asc</function></title>
         <tgroup cols="2">
          <thead>
           <row>
            <entry>Format</entry>
            <entry>Result</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>mmddyy</literal></entry>
            <entry><literal>112359</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>231159</literal></entry>
           </row>
           <row>
            <entry><literal>yymmdd</literal></entry>
            <entry><literal>591123</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>59/11/23</literal></entry>
           </row>
           <row>
            <entry><literal>yy mm dd</literal></entry>
            <entry><literal>59 11 23</literal></entry>
           </row>
           <row>
            <entry><literal>yy.mm.dd</literal></entry>
            <entry><literal>59.11.23</literal></entry>
           </row>
           <row>
            <entry><literal>.mm.yyyy.dd.</literal></entry>
            <entry><literal>.11.1959.23.</literal></entry>
           </row>
           <row>
            <entry><literal>mmm. dd, yyyy</literal></entry>
            <entry><literal>Nov. 23, 1959</literal></entry>
           </row>
           <row>
            <entry><literal>mmm dd yyyy</literal></entry>
            <entry><literal>Nov 23 1959</literal></entry>
           </row>
           <row>
            <entry><literal>yyyy dd mm</literal></entry>
            <entry><literal>1959 23 11</literal></entry>
           </row>
           <row>
            <entry><literal>ddd, mmm. dd, yyyy</literal></entry>
            <entry><literal>Mon, Nov. 23, 1959</literal></entry>
           </row>
           <row>
            <entry><literal>(ddd) mmm. dd, yyyy</literal></entry>
            <entry><literal>(Mon) Nov. 23, 1959</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatedefmtasc">
      <term><function>PGTYPESdate_defmt_asc</function></term>
      <listitem>
       <para>
        Use a format mask to convert a C <type>char*</type> string to a value of type
        date.
<synopsis>
int PGTYPESdate_defmt_asc(date *d, char *fmt, char *str);
</synopsis>
        <!-&minus; same description as rdefmtdate -&minus;>
        The function receives a pointer to the date value that should hold the
        result of the operation (<literal>d</literal>), the format mask to use for
        parsing the date (<literal>fmt</literal>) and the C char* string containing
        the textual representation of the date (<literal>str</literal>). The textual
        representation is expected to match the format mask. However you do not
        need to have a 1:1 mapping of the string to the format mask. The
        function only analyzes the sequential order and looks for the literals
        <literal>yy</literal> or <literal>yyyy</literal> that indicate the
        position of the year, <literal>mm</literal> to indicate the position of
        the month and <literal>dd</literal> to indicate the position of the
        day.
       </para>
       <para>
        <xref linkend="ecpg-rdefmtdate-example-table"/> indicates a few possible formats. This will give
        you an idea of how to use this function.
       </para>
        <table id="ecpg-rdefmtdate-example-table">
         <title>Valid Input Formats for <function>rdefmtdate</function></title>
         <tgroup cols="3">
          <thead>
           <row>
            <entry>Format</entry>
            <entry>String</entry>
            <entry>Result</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>21-2-54</literal></entry>
            <entry><literal>1954-02-21</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>2-12-54</literal></entry>
            <entry><literal>1954-12-02</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>20111954</literal></entry>
            <entry><literal>1954-11-20</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>130464</literal></entry>
            <entry><literal>1964-04-13</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>MAR-12-1967</literal></entry>
            <entry><literal>1967-03-12</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>1954, February 3rd</literal></entry>
            <entry><literal>1954-02-03</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>041269</literal></entry>
            <entry><literal>1969-04-12</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>In the year 2525, in the month of July, mankind will be alive on the 28th day</literal></entry>
            <entry><literal>2525-07-28</literal></entry>
           </row>
           <row>
            <entry><literal>dd-mm-yy</literal></entry>
            <entry><literal>I said on the 28th of July in the year 2525</literal></entry>
            <entry><literal>2525-07-28</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>9/14/58</literal></entry>
            <entry><literal>1958-09-14</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>47/03/29</literal></entry>
            <entry><literal>1947-03-29</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>oct 28 1975</literal></entry>
            <entry><literal>1975-10-28</literal></entry>
           </row>
           <row>
            <entry><literal>mmddyy</literal></entry>
            <entry><literal>Nov 14th, 1985</literal></entry>
            <entry><literal>1985-11-14</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    下列函数可以被用于日期类型：
    <variablelist>
     <varlistentry id="pgtypesdatefromtimestamp">
      <term><function>PGTYPESdate_from_timestamp</function></term>
      <listitem>
       <para>
        从一个时间戳中抽取日期部分。
<synopsis>
date PGTYPESdate_from_timestamp(timestamp dt);
</synopsis>
        该函数接收一个时间戳作为它的唯一参数并且从这个时间戳返回抽取的日期部分。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatefromasc">
      <term><function>PGTYPESdate_from_asc</function></term>
      <listitem>
       <para>
       从日期的文本表达解析一个日期。
<synopsis>
date PGTYPESdate_from_asc(char *str, char **endptr);
</synopsis>
        该函数接收一个 C 的字符串<literal>str</literal>以及一个指向 C 字符串的指针<literal>endptr</literal>。当前 ECPG 总是解析完整的字符串并且因此当前不支持将第一个非法字符的地址存储在<literal>*endptr</literal>中。你可以安全地把<literal>endptr</literal>设置为 NULL。
       </para>
       <para>
        注意该函数总是假定格式按照 MDY 格式化并且当前在 ECPG 中没有变体可以改变这种格式。
       </para>
       <para>
        <xref linkend="ecpg-pgtypesdate-from-asc-table"/>展示了所有允许的输入格式。
       </para>
        <table id="ecpg-pgtypesdate-from-asc-table">
         <title><function>PGTYPESdate_from_asc</function>的合法输入格式</title>
         <tgroup cols="2">
          <thead>
           <row>
            <entry>输入</entry>
            <entry>结果</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>January 8, 1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1999-01-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1/8/1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1/18/1999</literal></entry>
            <entry><literal>January 18, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>01/02/03</literal></entry>
            <entry><literal>February 1, 2003</literal></entry>
           </row>
           <row>
            <entry><literal>1999-Jan-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>Jan-08-1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-1999</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>99-Jan-08</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-99</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>08-Jan-06</literal></entry>
            <entry><literal>January 8, 2006</literal></entry>
           </row>
           <row>
            <entry><literal>Jan-08-99</literal></entry>
            <entry><literal>January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>19990108</literal></entry>
            <entry><literal>ISO 8601; January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>990108</literal></entry>
            <entry><literal>ISO 8601; January 8, 1999</literal></entry>
           </row>
           <row>
            <entry><literal>1999.008</literal></entry>
            <entry><literal>年以及积日</literal></entry>
           </row>
           <row>
            <entry><literal>J2451187</literal></entry>
            <entry><literal>儒略日</literal></entry>
           </row>
           <row>
            <entry><literal>January 8, 99 BC</literal></entry>
            <entry><literal>公元前 99 年</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatetoasc">
      <term><function>PGTYPESdate_to_asc</function></term>
      <listitem>
       <para>
        返回一个日期变量的文本表达。
<synopsis>
char *PGTYPESdate_to_asc(date dDate);
</synopsis>
        该函数接收日期<literal>dDate</literal>作为它的唯一参数。它将以形式<literal>1999-01-18</literal>输出该日期，即以<literal>YYYY-MM-DD</literal>格式输出。结果必须用<function>PGTYPESchar_free()</function>释放。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatejulmdy">
      <term><function>PGTYPESdate_julmdy</function></term>
      <listitem>
       <para>
        从一个日期类型变量中抽取日、月和年的值。
<synopsis>
void PGTYPESdate_julmdy(date d, int *mdy);
</synopsis>
       <!-- almost same description as for rjulmdy() -->
        该函数接收日期<literal>d</literal>以及一个指向有 3 个整数值的数组<literal>mdy</literal>的指针。变量名就表明了顺序：<literal>mdy[0]</literal>将被设置为包含月份，<literal>mdy[1]</literal>将被设置为日的值，而<literal>mdy[2]</literal>将包含年。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatemdyjul">
      <term><function>PGTYPESdate_mdyjul</function></term>
      <listitem>
       <para>
        从一个由 3 个整数构成的数组创建一个日期值，3 个整数分别指定日、月和年。
<synopsis>
void PGTYPESdate_mdyjul(int *mdy, date *jdate);
</synopsis>
        这个函数接收 3 个整数（<literal>mdy</literal>）组成的数组作为其第一个参数，其第二个参数是一个指向日期类型变量的指针，它被用来保存操作的结果。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatedayofweek">
      <term><function>PGTYPESdate_dayofweek</function></term>
      <listitem>
       <para>
        为一个日期值返回表示它是星期几的数字。
<synopsis>
int PGTYPESdate_dayofweek(date d);
</synopsis>
        这个函数接收日期变量<literal>d</literal>作为它唯一的参数并且返回一个整数说明这个日期是星期几。
        <itemizedlist>
         <listitem>
          <para>
           0 - 星期日
          </para>
         </listitem>
         <listitem>
          <para>
           1 - 星期一
          </para>
         </listitem>
         <listitem>
          <para>
           2 - 星期二
          </para>
         </listitem>
         <listitem>
          <para>
           3 - 星期三
          </para>
         </listitem>
         <listitem>
          <para>
           4 - 星期四
          </para>
         </listitem>
         <listitem>
          <para>
           5 - 星期五
          </para>
         </listitem>
         <listitem>
          <para>
           6 - 星期六
          </para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatetoday">
      <term><function>PGTYPESdate_today</function></term>
      <listitem>
       <para>
        得到当前日期。
<synopsis>
void PGTYPESdate_today(date *d);
</synopsis>
        该函数接收一个指向一个日期变量（<literal>d</literal>）的指针并且把该参数设置为当前日期。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatefmtasc">
      <term><function>PGTYPESdate_fmt_asc</function></term>
      <listitem>
       <para>
        使用一个格式掩码将一个日期类型的变量转换成它的文本表达。
<synopsis>
int PGTYPESdate_fmt_asc(date dDate, char *fmtstring, char *outbuf);
</synopsis>
        该函数接收要转换的日期（<literal>dDate</literal>）、格式掩码（<literal>fmtstring</literal>）以及将要保存日期的文本表达的字符串（<literal>outbuf</literal>）。
       </para>
       <para>
        成功时，返回 0；如果发生错误，则返回一个负值。
       </para>
       <para>
        下面是你可以使用的域指示符：
        <itemizedlist>
         <listitem>
          <para>
           <literal>dd</literal> - 一个月中的第几天。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>mm</literal> - 一年中的第几个月。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>yy</literal> - 两位数的年份。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>yyyy</literal> - 四位数的年份。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ddd</literal> - 星期几的名称（简写）。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>mmm</literal> - 月份的名称（简写）。
          </para>
         </listitem>
        </itemizedlist>
        所有其他字符会被原封不动地复制到输出字符串中。
       </para>
       <para>
        <xref linkend="ecpg-pgtypesdate-fmt-asc-example-table"/>指出了一些可能的格式。这将给你一些线索如何使用这个函数。所有输出都是基于同一个日期：1959年11月23日。
       </para>
        <table id="ecpg-pgtypesdate-fmt-asc-example-table">
         <title><function>PGTYPESdate_fmt_asc</function>的合法输入格式</title>
         <tgroup cols="2">
          <thead>
           <row>
            <entry>格式</entry>
            <entry>结果</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>mmddyy</literal></entry>
            <entry><literal>112359</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>231159</literal></entry>
           </row>
           <row>
            <entry><literal>yymmdd</literal></entry>
            <entry><literal>591123</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>59/11/23</literal></entry>
           </row>
           <row>
            <entry><literal>yy mm dd</literal></entry>
            <entry><literal>59 11 23</literal></entry>
           </row>
           <row>
            <entry><literal>yy.mm.dd</literal></entry>
            <entry><literal>59.11.23</literal></entry>
           </row>
           <row>
            <entry><literal>.mm.yyyy.dd.</literal></entry>
            <entry><literal>.11.1959.23.</literal></entry>
           </row>
           <row>
            <entry><literal>mmm. dd, yyyy</literal></entry>
            <entry><literal>Nov. 23, 1959</literal></entry>
           </row>
           <row>
            <entry><literal>mmm dd yyyy</literal></entry>
            <entry><literal>Nov 23 1959</literal></entry>
           </row>
           <row>
            <entry><literal>yyyy dd mm</literal></entry>
            <entry><literal>1959 23 11</literal></entry>
           </row>
           <row>
            <entry><literal>ddd, mmm. dd, yyyy</literal></entry>
            <entry><literal>Mon, Nov. 23, 1959</literal></entry>
           </row>
           <row>
            <entry><literal>(ddd) mmm. dd, yyyy</literal></entry>
            <entry><literal>(Mon) Nov. 23, 1959</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesdatedefmtasc">
      <term><function>PGTYPESdate_defmt_asc</function></term>
      <listitem>
       <para>
        使用一个格式掩码把一个 C 的 <type>char*</type>子返回串转换成一个日期类型的值。
<synopsis>
int PGTYPESdate_defmt_asc(date *d, char *fmt, char *str);
</synopsis>
        <!-- same description as rdefmtdate -->
        该函数接收一个用来保存操作结果的指向日期值的指针（<literal>d</literal>）、用于解析日期的格式掩码（<literal>fmt</literal>）以及包含日期文本表达的 C char* 串（<literal>str</literal>）。该函数期望文本表达匹配格式掩码。不过你不需要字符串和格式掩码的一一映射。该函数只分析相继顺序并且查找表示年份位置的文字<literal>yy</literal>或者<literal>yyyy</literal>、表示月份位置的<literal>mm</literal>以及表示日位置的<literal>dd</literal>。
       </para>
       <para>
        <xref linkend="ecpg-rdefmtdate-example-table"/>给出了一些可能的格式。这将给你一些线索如何使用这个函数。
       </para>
        <table id="ecpg-rdefmtdate-example-table">
         <title><function>rdefmtdate</function>的合法输入格式</title>
         <tgroup cols="3">
          <thead>
           <row>
            <entry>格式</entry>
            <entry>字符串</entry>
            <entry>结果</entry>
           </row>
          </thead>
          <tbody>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>21-2-54</literal></entry>
            <entry><literal>1954-02-21</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>2-12-54</literal></entry>
            <entry><literal>1954-12-02</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>20111954</literal></entry>
            <entry><literal>1954-11-20</literal></entry>
           </row>
           <row>
            <entry><literal>ddmmyy</literal></entry>
            <entry><literal>130464</literal></entry>
            <entry><literal>1964-04-13</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>MAR-12-1967</literal></entry>
            <entry><literal>1967-03-12</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>1954, February 3rd</literal></entry>
            <entry><literal>1954-02-03</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>041269</literal></entry>
            <entry><literal>1969-04-12</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>在 2525 年的七月二十八日，人类还将存在</literal></entry>
            <entry><literal>2525-07-28</literal></entry>
           </row>
           <row>
            <entry><literal>dd-mm-yy</literal></entry>
            <entry><literal>也是 2525 年七月的二十八日</literal></entry>
            <entry><literal>2525-07-28</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>9/14/58</literal></entry>
            <entry><literal>1958-09-14</literal></entry>
           </row>
           <row>
            <entry><literal>yy/mm/dd</literal></entry>
            <entry><literal>47/03/29</literal></entry>
            <entry><literal>1947-03-29</literal></entry>
           </row>
           <row>
            <entry><literal>mmm.dd.yyyy</literal></entry>
            <entry><literal>oct 28 1975</literal></entry>
            <entry><literal>1975-10-28</literal></entry>
           </row>
           <row>
            <entry><literal>mmddyy</literal></entry>
            <entry><literal>Nov 14th, 1985</literal></entry>
            <entry><literal>1985-11-14</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=8607d0f474631a0a78421f77b0795f35 -->
  </sect2>

  <sect2 id="ecpg-pgtypes-timestamp">
<!-- pgdoc-cn_start sig_en=2bcbec9ace18f1f2d7c8807ce62a07b2 sig_cn_org=None source=14.1 
   <title>The timestamp Type</title>
________________________________________________________-->
   <title>时间戳类型</title>
<!-- pgdoc-cn_end sig_en=2bcbec9ace18f1f2d7c8807ce62a07b2 -->
<!-- pgdoc-cn_start sig_en=2548ddf1039795067f10bf7262e6972d sig_cn_org=None source=14.1 
   <para>
    The timestamp type in C enables your programs to deal with data of the SQL
    type timestamp. See <xref linkend="datatype-datetime"/> for the equivalent
    type in the <productname>PostgreSQL</productname> server.
   </para>
________________________________________________________-->
   <para>
    C 中的时间戳类型允许你的程序处理 SQL 时间戳类型的数据。<productname>PostgreSQL</productname>服务器的等效类型可见<xref linkend="datatype-datetime"/>。
   </para>
<!-- pgdoc-cn_end sig_en=2548ddf1039795067f10bf7262e6972d -->
<!-- pgdoc-cn_start sig_en=f2ecca80d56720c585d4870f0fffdaae sig_cn_org=d39988e9947363a65fed96a0eaded9c3 source=15.7 
   <para>
    The following functions can be used to work with the timestamp type:
    <variablelist>
     <varlistentry id="pgtypestimestampfromasc">
________________________________________________________-->
   <para>
    下列函数可用于处理时间戳类型：
    <variablelist>
     <varlistentry id="pgtypestimestampfromasc">
<!-- pgdoc-cn_end sig_en=f2ecca80d56720c585d4870f0fffdaae -->
      <term><function>PGTYPEStimestamp_from_asc</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=a5510937a85d1634aea29e05b657b54c sig_cn_org=ce0f790a17d684b09dd44a2fc6dc9851 source=15.7 
       <para>
        Parse a timestamp from its textual representation into a timestamp
        variable.
<synopsis>
timestamp PGTYPEStimestamp_from_asc(char *str, char **endptr);
</synopsis>
        The function receives the string to parse (<literal>str</literal>) and a
        pointer to a C char* (<literal>endptr</literal>).
        At the moment ECPG always parses
        the complete string and so it currently does not support to store the
        address of the first invalid character in <literal>*endptr</literal>.
        You can safely set <literal>endptr</literal> to NULL.
       </para>
________________________________________________________-->
       <para>
        从其文本表示中解析时间戳为时间戳变量。
<synopsis>
timestamp PGTYPEStimestamp_from_asc(char *str, char **endptr);
</synopsis>
        该函数接收要解析的字符串（<literal>str</literal>）和一个指向C char*的指针（<literal>endptr</literal>）。
        目前，ECPG总是解析完整的字符串，因此目前不支持存储第一个无效字符的地址在<literal>*endptr</literal>中。
        您可以安全地将<literal>endptr</literal>设置为NULL。
       </para>
<!-- pgdoc-cn_end sig_en=a5510937a85d1634aea29e05b657b54c -->
<!-- pgdoc-cn_start sig_en=d42178670d2dd276ca6464e0f4934483 sig_cn_org=b37be383c97922487ecba0d207d017d0 source=15.7 
       <para>
        The function returns the parsed timestamp on success. On error,
        <literal>PGTYPESInvalidTimestamp</literal> is returned and <varname>errno</varname> is
        set to <literal>PGTYPES_TS_BAD_TIMESTAMP</literal>. See <xref linkend="pgtypesinvalidtimestamp"/> for important notes on this value.
       </para>
________________________________________________________-->
       <para>
        该函数在成功时返回解析后的时间戳。发生错误时，返回<literal>PGTYPESInvalidTimestamp</literal>，
        并将<varname>errno</varname>设置为<literal>PGTYPES_TS_BAD_TIMESTAMP</literal>。
        有关此值的重要说明，请参见<xref linkend="pgtypesinvalidtimestamp"/>。
</para>
<!-- pgdoc-cn_end sig_en=d42178670d2dd276ca6464e0f4934483 -->
<!-- pgdoc-cn_start sig_en=45fc053336b39b9ff4b627eb2f036c41 sig_cn_org=8b747fc5e433073974dac799bd372c7f source=15.7 
       <para>
        In general, the input string can contain any combination of an allowed
        date specification, a whitespace character and an allowed time
        specification. Note that time zones are not supported by ECPG. It can
        parse them but does not apply any calculation as the
        <productname>PostgreSQL</productname> server does for example. Timezone
        specifiers are silently discarded.
       </para>
________________________________________________________-->
       <para>
        通常，输入字符串可以包含允许的日期规范、空白字符和允许的时间规范的任意组合。请注意，ECPG 不支持时区。它可以解析时区，但不像<productname>PostgreSQL</productname>服务器那样应用任何计算。时区标识符会被静默丢弃。
       </para>
<!-- pgdoc-cn_end sig_en=45fc053336b39b9ff4b627eb2f036c41 -->
<!-- pgdoc-cn_start sig_en=b90cc149f301314d39a2a640e97e0dc1 sig_cn_org=359671c2ffa65e11a4910fa5a767c8ec source=15.7 
       <para>
        <xref linkend="ecpg-pgtypestimestamp-from-asc-example-table"/> contains a few examples for input strings.
       </para>
________________________________________________________-->
       <para>
        <xref linkend="ecpg-pgtypestimestamp-from-asc-example-table"/>包含了一些输入字符串的示例。
       </para>
<!-- pgdoc-cn_end sig_en=b90cc149f301314d39a2a640e97e0dc1 -->
        <table id="ecpg-pgtypestimestamp-from-asc-example-table">
<!-- pgdoc-cn_start sig_en=a294c63a077c24d6cfff9e69d044e8ec sig_cn_org=538c6570ea2add8285d4475291c64ca6 source=15.7 
         <title>Valid Input Formats for <function>PGTYPEStimestamp_from_asc</function></title>
________________________________________________________-->
         <title><function>PGTYPEStimestamp_from_asc</function>的有效输入格式</title>
<!-- pgdoc-cn_end sig_en=a294c63a077c24d6cfff9e69d044e8ec -->
         <tgroup cols="2">
          <thead>
<!-- pgdoc-cn_start sig_en=7ed56d2ca72ef02e514485f992974c2f sig_cn_org=4046aa92d48ac302c6f406d4d4d3dd23 source=15.7 
           <row>
            <entry>Input</entry>
            <entry>Result</entry>
           </row>
________________________________________________________-->
           <row>
            <entry>输入</entry>
            <entry>结果</entry>
           </row>
<!-- pgdoc-cn_end sig_en=7ed56d2ca72ef02e514485f992974c2f -->
          </thead>
          <tbody>
           <row>
            <entry><literal>1999-01-08 04:05:06</literal></entry>
            <entry><literal>1999-01-08 04:05:06</literal></entry>
           </row>
           <row>
            <entry><literal>January 8 04:05:06 1999 PST</literal></entry>
            <entry><literal>1999-01-08 04:05:06</literal></entry>
           </row>
           <row>
            <entry><literal>1999-Jan-08 04:05:06.789-8</literal></entry>
            <entry><literal>1999-01-08 04:05:06.789 (time zone specifier ignored)</literal></entry>
           </row>
           <row>
            <entry><literal>J2451187 04:05-08:00</literal></entry>
            <entry><literal>1999-01-08 04:05:00 (time zone specifier ignored)</literal></entry>
           </row>
          </tbody>
         </tgroup>
        </table>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypestimestamptoasc">
      <term><function>PGTYPEStimestamp_to_asc</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=3dcdebf9037498aeb77a1e72b8b5d43c sig_cn_org=d8405acbf37e2e8bf743e2b2ca09dfb5 source=15.7 
       <para>
        Converts a date to a C char* string.
<synopsis>
char *PGTYPEStimestamp_to_asc(timestamp tstamp);
</synopsis>
        The function receives the timestamp <literal>tstamp</literal> as
        its only argument and returns an allocated string that contains the
        textual representation of the timestamp.
        The result must be freed with <function>PGTYPESchar_free()</function>.
       </para>
________________________________________________________-->
       <para>
        将日期转换为C char*字符串。
<synopsis>
char *PGTYPEStimestamp_to_asc(timestamp tstamp);
</synopsis>
        该函数接收时间戳<literal>tstamp</literal>作为其唯一参数，并返回一个包含时间戳文本表示的已分配字符串。
        结果必须使用<function>PGTYPESchar_free()</function>释放。
       </para>
<!-- pgdoc-cn_end sig_en=3dcdebf9037498aeb77a1e72b8b5d43c -->
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypestimestampcurrent">
      <term><function>PGTYPEStimestamp_current</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=03875d9de2f92263e6b828938aa2cfed sig_cn_org=13ed50ce8a4fbd80eb1d0ca51583c860 source=15.7 
       <para>
        Retrieve the current timestamp.
<synopsis>
void PGTYPEStimestamp_current(timestamp *ts);
</synopsis>
        The function retrieves the current timestamp and saves it into the
        timestamp variable that <literal>ts</literal> points to.
       </para>
________________________________________________________-->
       <para>
        检索当前时间戳。
<synopsis>
void PGTYPEStimestamp_current(timestamp *ts);
</synopsis>
        该函数检索当前时间戳，并将其保存到<literal>ts</literal>指向的时间戳变量中。
</para>
<!-- pgdoc-cn_end sig_en=03875d9de2f92263e6b828938aa2cfed -->
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypestimestampfmtasc">
      <term><function>PGTYPEStimestamp_fmt_asc</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=61bc289d84dd4ce4d5676ec68d33bd5f sig_cn_org=6ef876a99c65f02a2d8ab3a0f28c37e9 source=15.7 
       <para>
        Convert a timestamp variable to a C char* using a format mask.
<synopsis>
int PGTYPEStimestamp_fmt_asc(timestamp *ts, char *output, int str_len, char *fmtstr);
</synopsis>
        The function receives a pointer to the timestamp to convert as its
        first argument (<literal>ts</literal>), a pointer to the output buffer
        (<literal>output</literal>), the maximal length that has been allocated for
        the output buffer (<literal>str_len</literal>) and the format mask to
        use for the conversion (<literal>fmtstr</literal>).
       </para>
________________________________________________________-->
       <para>
        将时间戳变量转换为C char*，使用格式掩码。
<synopsis>
int PGTYPEStimestamp_fmt_asc(timestamp *ts, char *output, int str_len, char *fmtstr);
</synopsis>
        该函数接收一个指向要转换的时间戳的指针作为第一个参数（<literal>ts</literal>），
        一个指向输出缓冲区的指针（<literal>output</literal>），已为输出缓冲区分配的最大长度
        （<literal>str_len</literal>），以及用于转换的格式掩码（<literal>fmtstr</literal>）。
</para>
<!-- pgdoc-cn_end sig_en=61bc289d84dd4ce4d5676ec68d33bd5f -->
<!-- pgdoc-cn_start sig_en=e878766ff1009e018fed122a3ee838f2 sig_cn_org=d33969792e2e69de9d63bd993bf4f234 source=15.7 
       <para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
________________________________________________________-->
       <para>
        当成功时，该函数返回0，如果发生错误则返回负值。
       </para>
<!-- pgdoc-cn_end sig_en=e878766ff1009e018fed122a3ee838f2 -->
<!-- pgdoc-cn_start sig_en=35bc8ef088ef7f975cb27b4db0eab7f5 sig_cn_org=54e2541d4bba1723b062de15b48c0753 source=15.7 
       <para>
        You can use the following format specifiers for the format mask. The
        format specifiers are the same ones that are used in the
        <function>strftime</function> function in <productname>libc</productname>. Any
        non-format specifier will be copied into the output buffer.
        <!-&minus; This is from the FreeBSD man page:
             http://www.freebsd.org/cgi/man.cgi?query=strftime&apropos=0&sektion=3&manpath=FreeBSD+7.0-current&format=html
        -&minus;>
        <itemizedlist>
         <listitem>
________________________________________________________-->
       <para>
        您可以使用以下格式说明符来格式化掩码。格式说明符与<productname>libc</productname>中的<function>strftime</function>函数中使用的相同。任何非格式说明符都将被复制到输出缓冲区中。
        <!-- 这是来自FreeBSD手册页：
             http://www.freebsd.org/cgi/man.cgi?query=strftime&apropos=0&sektion=3&manpath=FreeBSD+7.0-current&format=html
        -->
        <itemizedlist>
         <listitem>
<!-- pgdoc-cn_end sig_en=35bc8ef088ef7f975cb27b4db0eab7f5 -->
<!-- pgdoc-cn_start sig_en=14c639189a7c07fd5d0a379cc6b57a61 sig_cn_org=920e9828b6fc3be155bd032d4fa52cd4 source=15.7 
          <para>
           <literal>%A</literal> - is replaced by national representation of
           the full weekday name.
          </para>
________________________________________________________-->
          <para>
           <literal>%A</literal> - 被替换为完整星期几的国家表示形式。
          </para>
<!-- pgdoc-cn_end sig_en=14c639189a7c07fd5d0a379cc6b57a61 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=a86a50db873714714ca68c3e78924d92 sig_cn_org=e8677093541f06542a2d6c64986f7ed6 source=15.7 
          <para>
           <literal>%a</literal> - is replaced by national representation of
           the abbreviated weekday name.
          </para>
________________________________________________________-->
          <para>
           <literal>%a</literal> - 被缩写的星期几名称的国家表示形式所替换。
          </para>
<!-- pgdoc-cn_end sig_en=a86a50db873714714ca68c3e78924d92 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=96f0aa54ea5f694f57e871ac5acbf09e sig_cn_org=516f813b4f79755057048fa79ed7bc4e source=15.7 
          <para>
           <literal>%B</literal> - is replaced by national representation of
           the full month name.
          </para>
________________________________________________________-->
          <para>
           <literal>%B</literal> - 被替换为完整月份名称的国家表示形式。
          </para>
<!-- pgdoc-cn_end sig_en=96f0aa54ea5f694f57e871ac5acbf09e -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=c73bee4fe9310f0233cec095bb302127 sig_cn_org=5158520af1c9d755fc014f5fe48655be source=15.7 
          <para>
           <literal>%b</literal> - is replaced by national representation of
           the abbreviated month name.
          </para>
________________________________________________________-->
          <para>
           <literal>%b</literal> - 被缩写月份的国家表示形式替换。
          </para>
<!-- pgdoc-cn_end sig_en=c73bee4fe9310f0233cec095bb302127 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=b890ffb48074b3f4690f6b26095058a2 sig_cn_org=820241ff4d30e38622d5772b31f494b1 source=15.7 
          <para>
           <literal>%C</literal> - is replaced by (year / 100) as decimal
           number; single digits are preceded by a zero.
          </para>
________________________________________________________-->
          <para>
           <literal>%C</literal> - 被(年份 / 100)替换为十进制数；单个数字前面加零。
          </para>
<!-- pgdoc-cn_end sig_en=b890ffb48074b3f4690f6b26095058a2 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=57afe72c1fd15dcbaa7295e40bb88b11 sig_cn_org=4b80646330934e40dedbac5ae6d89a42 source=15.7 
          <para>
           <literal>%c</literal> - is replaced by national representation of
           time and date.
          </para>
________________________________________________________-->
          <para>
           <literal>%c</literal> - 被时间和日期的国家表示形式替换。
          </para>
<!-- pgdoc-cn_end sig_en=57afe72c1fd15dcbaa7295e40bb88b11 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=d2179a851abd3d3aef7823664bede34f sig_cn_org=fd4bd047b91d1a606d3cb1207586a30a source=15.7 
          <para>
           <literal>%D</literal> - is equivalent to
           <literal>%m/%d/%y</literal>.
          </para>
________________________________________________________-->
          <para>
           <literal>%D</literal> - 等同于
           <literal>%m/%d/%y</literal>。
          </para>
<!-- pgdoc-cn_end sig_en=d2179a851abd3d3aef7823664bede34f -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=4afb17dbab30181c3e732f7e84ce1e77 sig_cn_org=2ede45fc58d02ea34effc1fb72694505 source=15.7 
          <para>
           <literal>%d</literal> - is replaced by the day of the month as a
           decimal number (01&ndash;31).
          </para>
________________________________________________________-->
          <para>
           <literal>%d</literal> - 被月份的日期替换为十进制数字（01-31）。
          </para>
<!-- pgdoc-cn_end sig_en=4afb17dbab30181c3e732f7e84ce1e77 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=0f037c42435e3fe83471b8e78599eae6 sig_cn_org=700b429c963074362905e1e4a9e4d472 source=15.7 
          <para>
           <literal>%E*</literal> <literal>%O*</literal> -  POSIX locale
           extensions. The sequences
           <literal>%Ec</literal>
           <literal>%EC</literal>
           <literal>%Ex</literal>
           <literal>%EX</literal>
           <literal>%Ey</literal>
           <literal>%EY</literal>
           <literal>%Od</literal>
           <literal>%Oe</literal>
           <literal>%OH</literal>
           <literal>%OI</literal>
           <literal>%Om</literal>
           <literal>%OM</literal>
           <literal>%OS</literal>
           <literal>%Ou</literal>
           <literal>%OU</literal>
           <literal>%OV</literal>
           <literal>%Ow</literal>
           <literal>%OW</literal>
           <literal>%Oy</literal>
           are supposed to provide alternative representations.
          </para>
________________________________________________________-->
          <para>
           <literal>%E*</literal> <literal>%O*</literal> -  POSIX 本地化扩展。序列
           <literal>%Ec</literal>
           <literal>%EC</literal>
           <literal>%Ex</literal>
           <literal>%EX</literal>
           <literal>%Ey</literal>
           <literal>%EY</literal>
           <literal>%Od</literal>
           <literal>%Oe</literal>
           <literal>%OH</literal>
           <literal>%OI</literal>
           <literal>%Om</literal>
           <literal>%OM</literal>
           <literal>%OS</literal>
           <literal>%Ou</literal>
           <literal>%OU</literal>
           <literal>%OV</literal>
           <literal>%Ow</literal>
           <literal>%OW</literal>
           <literal>%Oy</literal>
           应该提供替代表示。
          </para>
<!-- pgdoc-cn_end sig_en=0f037c42435e3fe83471b8e78599eae6 -->
<!-- pgdoc-cn_start sig_en=90d29dec85c8d1c518a75a64cf99f5d0 sig_cn_org=bb17c7c137ed39a944b3c59eefc70d16 source=15.7 
          <para>
           Additionally <literal>%OB</literal> implemented to represent
           alternative months names (used standalone, without day mentioned).
          </para>
________________________________________________________-->
          <para>
           另外<literal>%OB</literal>用于表示替代的月份名称（单独使用，不包括日期）。
          </para>
<!-- pgdoc-cn_end sig_en=90d29dec85c8d1c518a75a64cf99f5d0 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=1d5bf28c98a5309f0300c196c09df5f8 sig_cn_org=af98053c77b0372d3ca8af214ce3c521 source=15.7 
          <para>
           <literal>%e</literal> - is replaced by the day of month as a decimal
           number (1&ndash;31); single digits are preceded by a blank.
          </para>
________________________________________________________-->
          <para>
           <literal>%e</literal> - 被一个十进制数字（1-31）替换；单个数字前面有一个空格。
          </para>
<!-- pgdoc-cn_end sig_en=1d5bf28c98a5309f0300c196c09df5f8 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=e6893645562e5b2e8d24e8a44c6e677e sig_cn_org=64fbebb38d3336a8c3340e468979ed80 source=15.7 
          <para>
           <literal>%F</literal> - is equivalent to <literal>%Y-%m-%d</literal>.
          </para>
________________________________________________________-->
          <para>
           <literal>%F</literal> - 等同于<literal>%Y-%m-%d</literal>。
          </para>
<!-- pgdoc-cn_end sig_en=e6893645562e5b2e8d24e8a44c6e677e -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=5b98c658266245e14c0c5b1981a584f7 sig_cn_org=fd76e769cf2b1e1e114f3012fb1bccc9 source=15.7 
          <para>
           <literal>%G</literal> - is replaced by a year as a decimal number
           with century. This year is the one that contains the greater part of
           the week (Monday as the first day of the week).
          </para>
________________________________________________________-->
          <para>
           <literal>%G</literal> - 被一个包含世纪的十进制数字年份替换。这一年是包含大部分周的那一年（以周一作为一周的第一天）。
          </para>
<!-- pgdoc-cn_end sig_en=5b98c658266245e14c0c5b1981a584f7 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=a881d621ec33c19d142c8e7623b2a68a sig_cn_org=03acc4a2de93556037e3bea2f312af9e source=15.7 
          <para>
           <literal>%g</literal> - is replaced by the same year as in
           <literal>%G</literal>, but as a decimal number without century
           (00&ndash;99).
          </para>
________________________________________________________-->
          <para>
           <literal>%g</literal> - 被替换为与<literal>%G</literal>相同的年份，但作为一个没有世纪的十进制数
           (00&ndash;99)。
          </para>
<!-- pgdoc-cn_end sig_en=a881d621ec33c19d142c8e7623b2a68a -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=d5aec8afecca1099c5193ead9772504e sig_cn_org=df15e9b0cc55f16b8226a7124d40275d source=15.7 
          <para>
           <literal>%H</literal> - is replaced by the hour (24-hour clock) as a
           decimal number (00&ndash;23).
          </para>
________________________________________________________-->
          <para>
           <literal>%H</literal> - 被小时（24小时制）替换为十进制数（00-23）。
          </para>
<!-- pgdoc-cn_end sig_en=d5aec8afecca1099c5193ead9772504e -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=108785d8f8c3a8e8bb6c54fc0fb755b0 sig_cn_org=9f54559df7ccdc5f739f0c32789dde24 source=15.7 
          <para>
           <literal>%h</literal> - the same as <literal>%b</literal>.
          </para>
________________________________________________________-->
          <para>
           <literal>%h</literal> - 与<literal>%b</literal>相同。
          </para>
<!-- pgdoc-cn_end sig_en=108785d8f8c3a8e8bb6c54fc0fb755b0 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=03296d370501a0f57102a8f01c20de25 sig_cn_org=01ed3d634eb2ba34429c2d2f7fceecc7 source=15.7 
          <para>
           <literal>%I</literal> - is replaced by the hour (12-hour clock) as a
           decimal number (01&ndash;12).
          </para>
________________________________________________________-->
          <para>
           <literal>%I</literal> - 被小时（12小时制）替换为十进制数（01-12）。
          </para>
<!-- pgdoc-cn_end sig_en=03296d370501a0f57102a8f01c20de25 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=80401f1a7d49ee34d91806da8439b10d sig_cn_org=cb4624bf24d0b0b27a123da744c3af29 source=15.7 
          <para>
           <literal>%j</literal> - is replaced by the day of the year as a
           decimal number (001&ndash;366).
          </para>
________________________________________________________-->
          <para>
           <literal>%j</literal> - 被一年中的日期替换为十进制数(001&ndash;366)。
          </para>
<!-- pgdoc-cn_end sig_en=80401f1a7d49ee34d91806da8439b10d -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=e30d679c327f5108cd3f7d507ddbd28a sig_cn_org=23a7b7b3f2b343861dac24b286c7b3f9 source=15.7 
          <para>
           <literal>%k</literal> - is replaced by the hour (24-hour clock) as a
           decimal number (0&ndash;23); single digits are preceded by a blank.
          </para>
________________________________________________________-->
          <para>
           <literal>%k</literal> - 被小时（24小时制）表示为十进制数（0-23）；单个数字前面有一个空格。
          </para>
<!-- pgdoc-cn_end sig_en=e30d679c327f5108cd3f7d507ddbd28a -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=5e0477571aeff5f73f1bb2e6180ab71c sig_cn_org=fc24c9a0f07e667953dddeea3f23ec44 source=15.7 
          <para>
           <literal>%l</literal> - is replaced by the hour (12-hour clock) as a
           decimal number (1&ndash;12); single digits are preceded by a blank.
          </para>
________________________________________________________-->
          <para>
           <literal>%l</literal> - 被小时（12小时制）替换为十进制数（1-12）；单个数字前面有一个空格。
          </para>
<!-- pgdoc-cn_end sig_en=5e0477571aeff5f73f1bb2e6180ab71c -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=ecb1d92b52dddd37eb1b0ec91ceb0dd3 sig_cn_org=434ef694e541504a1754e3eeac831207 source=15.7 
          <para>
           <literal>%M</literal> - is replaced by the minute as a decimal
           number (00&ndash;59).
          </para>
________________________________________________________-->
          <para>
           <literal>%M</literal> - 被分钟替换为十进制数（00-59）。
          </para>
<!-- pgdoc-cn_end sig_en=ecb1d92b52dddd37eb1b0ec91ceb0dd3 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=c5c922b9154004c1b2120c812ea98abc sig_cn_org=60932f9e93e6954986b9a37eb3c48895 source=15.7 
          <para>
           <literal>%m</literal> - is replaced by the month as a decimal number
           (01&ndash;12).
          </para>
________________________________________________________-->
          <para>
           <literal>%m</literal> - 被月份的十进制数（01-12）替换。
          </para>
<!-- pgdoc-cn_end sig_en=c5c922b9154004c1b2120c812ea98abc -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=7a78c0059fda22e0fb404b8c5bb0e251 sig_cn_org=dc29a852b1ae0c0b9da0f1b992d2d0cd source=15.7 
          <para>
          <literal>%n</literal> - is replaced by a newline.
          </para>
________________________________________________________-->
          <para>
          <literal>%n</literal> - 被换行符替换。
          </para>
<!-- pgdoc-cn_end sig_en=7a78c0059fda22e0fb404b8c5bb0e251 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=6769676a197f30b1fb8e9d3f7b55f794 sig_cn_org=66f647ddf9822734d679c1f3ef6679e1 source=15.7 
          <para>
           <literal>%O*</literal> - the same as <literal>%E*</literal>.
          </para>
________________________________________________________-->
          <para>
           <literal>%O*</literal> - 与<literal>%E*</literal>相同。
          </para>
<!-- pgdoc-cn_end sig_en=6769676a197f30b1fb8e9d3f7b55f794 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=5dcc230c464ec0de910b72def997ff2b sig_cn_org=e62ed3c01c92c7b00916198beed03566 source=15.7 
          <para>
           <literal>%p</literal> - is replaced by national representation of
           either <quote>ante meridiem</quote> or <quote>post meridiem</quote> as appropriate.
          </para>
________________________________________________________-->
          <para>
           <literal>%p</literal> - 被适当地替换为<quote>上午</quote>或<quote>下午</quote>的国家表示形式。
          </para>
<!-- pgdoc-cn_end sig_en=5dcc230c464ec0de910b72def997ff2b -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=a175d3dbb6aacd7746da109a6588a010 sig_cn_org=cf6e623f299fae2eb8a8b10f4c5a5711 source=15.7 
          <para>
           <literal>%R</literal> - is equivalent to <literal>%H:%M</literal>.
          </para>
________________________________________________________-->
          <para>
           <literal>%R</literal> - 等同于<literal>%H:%M</literal>。
          </para>
<!-- pgdoc-cn_end sig_en=a175d3dbb6aacd7746da109a6588a010 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=e2a2fd0f98d228a027e288e7aaf283d1 sig_cn_org=18ae13c773db989e99b8a5b94eeae789 source=15.7 
          <para>
           <literal>%r</literal> - is equivalent to <literal>%I:%M:%S
           %p</literal>.
          </para>
________________________________________________________-->
          <para>
           <literal>%r</literal> - 等同于<literal>%I:%M:%S %p</literal>。
          </para>
<!-- pgdoc-cn_end sig_en=e2a2fd0f98d228a027e288e7aaf283d1 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=03b8ce29878de99776ea6574a3bd517e sig_cn_org=3417f2e7f21d7c429301c6af41991cac source=15.7 
          <para>
           <literal>%S</literal> - is replaced by the second as a decimal
           number (00&ndash;60).
          </para>
________________________________________________________-->
          <para>
           <literal>%S</literal> - 被第二个作为十进制数（00-60）替换。
          </para>
<!-- pgdoc-cn_end sig_en=03b8ce29878de99776ea6574a3bd517e -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=f01c39994a2c1222665c8714216ebe6c sig_cn_org=9123b739fe21b4aaf91a360224191db2 source=15.7 
          <para>
           <literal>%s</literal> - is replaced by the number of seconds since
           the Epoch, UTC.
          </para>
________________________________________________________-->
          <para>
           <literal>%s</literal> - 被替换为自纪元时以来的秒数，协调世界时。
          </para>
<!-- pgdoc-cn_end sig_en=f01c39994a2c1222665c8714216ebe6c -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=494f9bed8b3a7f715321dd3bb1170cc6 sig_cn_org=7ec360b6f8ba1510f6f45414c01c07d1 source=15.7 
          <para>
           <literal>%T</literal> - is equivalent to <literal>%H:%M:%S</literal>
          </para>
________________________________________________________-->
          <para>
           <literal>%T</literal> - 等同于<literal>%H:%M:%S</literal>
          </para>
<!-- pgdoc-cn_end sig_en=494f9bed8b3a7f715321dd3bb1170cc6 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=d179336c3cba62b1fe82fe1739b9783d sig_cn_org=1935a095eb45f79b8ed01833e534e889 source=15.7 
          <para>
           <literal>%t</literal> - is replaced by a tab.
          </para>
________________________________________________________-->
          <para>
           <literal>%t</literal> - 被替换为一个制表符。
          </para>
<!-- pgdoc-cn_end sig_en=d179336c3cba62b1fe82fe1739b9783d -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=976a2b7a875ef864b2695498cdb74b8f sig_cn_org=3d109720c3d09895b0918ae1a024ce20 source=15.7 
          <para>
           <literal>%U</literal> - is replaced by the week number of the year
           (Sunday as the first day of the week) as a decimal number (00&ndash;53).
          </para>
________________________________________________________-->
          <para>
           <literal>%U</literal> - 被一年中的周数替换（以周日作为一周的第一天），表示为十进制数（00-53）。
          </para>
<!-- pgdoc-cn_end sig_en=976a2b7a875ef864b2695498cdb74b8f -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=b2a9dae7bf00ac2dcc45bcbdcd785c18 sig_cn_org=be648dd23ac2ced7df9c0cc7b973e169 source=15.7 
          <para>
           <literal>%u</literal> - is replaced by the weekday (Monday as the
           first day of the week) as a decimal number (1&ndash;7).
          </para>
________________________________________________________-->
          <para>
           <literal>%u</literal> - 被星期几（以星期一作为一周的第一天）替换为十进制数（1-7）。
          </para>
<!-- pgdoc-cn_end sig_en=b2a9dae7bf00ac2dcc45bcbdcd785c18 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=c7386b87523a56d18edce89fe1106d02 sig_cn_org=3f95de659781f0a21be83756a57737f7 source=15.7 
          <para>
           <literal>%V</literal> - is replaced by the week number of the year
           (Monday as the first day of the week) as a decimal number (01&ndash;53).
           If the week containing January 1 has four or more days in the new
           year, then it is week 1; otherwise it is the last week of the
           previous year, and the next week is week 1.
          </para>
________________________________________________________-->
          <para>
           <literal>%V</literal> - 被一年中的周数替换（以星期一作为一周的第一天），
           表示为十进制数（01-53）。如果包含1月1日的那一周在新年有四天或更多天，
           那么它是第1周；否则它是上一年的最后一周，下一周是第1周。
          </para>
<!-- pgdoc-cn_end sig_en=c7386b87523a56d18edce89fe1106d02 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=4ea097162bb9b25d0b49045a928bc924 sig_cn_org=5fdcd9e2593a257d944d6b8a563fbee9 source=15.7 
          <para>
           <literal>%v</literal> - is equivalent to
           <literal>%e-%b-%Y</literal>.
          </para>
________________________________________________________-->
          <para>
           <literal>%v</literal> - 等同于
           <literal>%e-%b-%Y</literal>。
          </para>
<!-- pgdoc-cn_end sig_en=4ea097162bb9b25d0b49045a928bc924 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=7555f9f7da10af38bbca971bf8003427 sig_cn_org=70e517d4195a345c9a7b75b72e066e18 source=15.7 
          <para>
           <literal>%W</literal> - is replaced by the week number of the year
           (Monday as the first day of the week) as a decimal number (00&ndash;53).
          </para>
________________________________________________________-->
          <para>
           <literal>%W</literal> - 被一年中的周数替换（以周一作为一周的第一天），表示为十进制数（00-53）。
          </para>
<!-- pgdoc-cn_end sig_en=7555f9f7da10af38bbca971bf8003427 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=45dbe48521fda8fcbb6598ba7881b674 sig_cn_org=53de56d21ea9513c9331d916df2f249c source=15.7 
          <para>
           <literal>%w</literal> - is replaced by the weekday (Sunday as the
           first day of the week) as a decimal number (0&ndash;6).
          </para>
________________________________________________________-->
          <para>
           <literal>%w</literal> - 被星期几替换（星期日作为一周的第一天）作为十进制数（0-6）。
          </para>
<!-- pgdoc-cn_end sig_en=45dbe48521fda8fcbb6598ba7881b674 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=ee599edec1b7fa4bd5c7a161df669fd1 sig_cn_org=59695de3cb746228db123fa78588fb95 source=15.7 
          <para>
           <literal>%X</literal> - is replaced by national representation of
           the time.
          </para>
________________________________________________________-->
          <para>
           <literal>%X</literal> - 被时间的国家表示替换。
          </para>
<!-- pgdoc-cn_end sig_en=ee599edec1b7fa4bd5c7a161df669fd1 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=32ad9f86bfc73b7d4c06a56c3a01d89f sig_cn_org=9004afcc32e6251c4c4f834e86ac97f8 source=15.7 
          <para>
           <literal>%x</literal> - is replaced by national representation of
           the date.
          </para>
________________________________________________________-->
          <para>
           <literal>%x</literal> - 被日期的国家表示形式替换。
          </para>
<!-- pgdoc-cn_end sig_en=32ad9f86bfc73b7d4c06a56c3a01d89f -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=66b494cc483d5b637eb5783c7882d084 sig_cn_org=3b82087f44a2692b2ce6e377a8415b85 source=15.7 
          <para>
           <literal>%Y</literal> - is replaced by the year with century as a
           decimal number.
          </para>
________________________________________________________-->
          <para>
           <literal>%Y</literal> - 被年份替换，包括世纪，以十进制数表示。
          </para>
<!-- pgdoc-cn_end sig_en=66b494cc483d5b637eb5783c7882d084 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=c3c71c29ba7eab68cc7cf43ed8e40e1f sig_cn_org=e2f27962083e7dce5fd122d7cff84bc5 source=15.7 
          <para>
           <literal>%y</literal> - is replaced by the year without century as a
           decimal number (00&ndash;99).
          </para>
________________________________________________________-->
          <para>
           <literal>%y</literal> - 被年份替换，不包括世纪，以十进制数表示（00-99）。
          </para>
<!-- pgdoc-cn_end sig_en=c3c71c29ba7eab68cc7cf43ed8e40e1f -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=53a467c4147c615748eb2c49c1285e2f sig_cn_org=d579dbd97fecc8de660558ceac860e63 source=15.7 
          <para>
           <literal>%Z</literal> - is replaced by the time zone name.
          </para>
________________________________________________________-->
          <para>
           <literal>%Z</literal> - 被时区名称替换。
          </para>
<!-- pgdoc-cn_end sig_en=53a467c4147c615748eb2c49c1285e2f -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=9a92d21432b1898ab4fae9929aaf5333 sig_cn_org=59f267145c93452e155b3d2c61f1ebbd source=15.7 
          <para>
           <literal>%z</literal> - is replaced by the time zone offset from
           UTC; a leading plus sign stands for east of UTC, a minus sign for
           west of UTC, hours and minutes follow with two digits each and no
           delimiter between them (common form for <ulink url="https://datatracker.ietf.org/doc/html/rfc822">RFC 822</ulink> date headers).
          </para>
________________________________________________________-->
          <para>
           <literal>%z</literal> - 被UTC时间偏移替换；前导加号表示UTC东部，减号表示UTC西部，后跟两位数字的小时和分钟，它们之间没有分隔符（<ulink url="https://datatracker.ietf.org/doc/html/rfc822">RFC 822</ulink>日期头的常见形式）。
          </para>
<!-- pgdoc-cn_end sig_en=9a92d21432b1898ab4fae9929aaf5333 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=c761dadcb0558eb1c20665685b39e9f2 sig_cn_org=1e5518e7d79ebc7a3258c702e31c3ab5 source=15.7 
          <para>
           <literal>%+</literal> - is replaced by national representation of
           the date and time.
          </para>
________________________________________________________-->
          <para>
           <literal>%+</literal> - 被日期和时间的国家表示所替换。
          </para>
<!-- pgdoc-cn_end sig_en=c761dadcb0558eb1c20665685b39e9f2 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=6ee2399b49b0e2652c1afde24c24a89c sig_cn_org=dc2b48273168a270e818c88ed844f726 source=15.7 
          <para>
           <literal>%-*</literal> - GNU libc extension. Do not do any padding
           when performing numerical outputs.
          </para>
________________________________________________________-->
          <para>
           <literal>%-*</literal> - GNU libc扩展。在执行数字输出时不进行任何填充。
          </para>
<!-- pgdoc-cn_end sig_en=6ee2399b49b0e2652c1afde24c24a89c -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=31200c1ab69544f5c40cf5b1c27dd07a sig_cn_org=8a60a2ab4b536c6d8392b54876f81c30 source=15.7 
          <para>
           $_* - GNU libc extension.    Explicitly specify space for padding.
          </para>
________________________________________________________-->
          <para>
           $_* - GNU libc扩展。明确指定填充空间。
          </para>
<!-- pgdoc-cn_end sig_en=31200c1ab69544f5c40cf5b1c27dd07a -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=05ee3693dec1e4312432833a957257e9 sig_cn_org=d01d9f9c53976251e46d32611e55ff30 source=15.7 
          <para>
           <literal>%0*</literal> - GNU libc extension. Explicitly specify zero
           for padding.
          </para>
________________________________________________________-->
          <para>
           <literal>%0*</literal> - GNU libc扩展。显式地指定零来填充。
          </para>
<!-- pgdoc-cn_end sig_en=05ee3693dec1e4312432833a957257e9 -->
         </listitem>
         <listitem>
<!-- pgdoc-cn_start sig_en=8f5c0800fa67426cbfa8ccd1c85d928d sig_cn_org=a2c91039fd491edbdb9aac79f56213da source=15.7 
          <para>
           <literal>%%</literal> - is replaced by <literal>%</literal>.
          </para>
________________________________________________________-->
          <para>
           <literal>%%</literal> - 被<literal>%</literal>替换。
          </para>
<!-- pgdoc-cn_end sig_en=8f5c0800fa67426cbfa8ccd1c85d928d -->
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypestimestampsub">
      <term><function>PGTYPEStimestamp_sub</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=4d37d03a222aee138a00930a033e254a sig_cn_org=c4e48b4406c9dc07dcd9b15ac11dcf13 source=15.7 
       <para>
        Subtract one timestamp from another one and save the result in a
        variable of type interval.
<synopsis>
int PGTYPEStimestamp_sub(timestamp *ts1, timestamp *ts2, interval *iv);
</synopsis>
        The function will subtract the timestamp variable that <literal>ts2</literal>
        points to from the timestamp variable that <literal>ts1</literal> points to
        and will store the result in the interval variable that <literal>iv</literal>
        points to.
       </para>
________________________________________________________-->
       <para>
        从一个时间戳减去另一个时间戳，并将结果保存在一个间隔类型的变量中。
<synopsis>
int PGTYPEStimestamp_sub(timestamp *ts1, timestamp *ts2, interval *iv);
</synopsis>
        该函数将从时间戳变量<literal>ts1</literal>指向的时间戳变量中减去时间戳变量<literal>ts2</literal>指向的时间戳变量，并将结果存储在间隔变量<literal>iv</literal>指向的间隔变量中。
       </para>
<!-- pgdoc-cn_end sig_en=4d37d03a222aee138a00930a033e254a -->
<!-- pgdoc-cn_start sig_en=e878766ff1009e018fed122a3ee838f2 sig_cn_org=d33969792e2e69de9d63bd993bf4f234 source=15.7 
       <para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
________________________________________________________-->
       <para>
        当成功时，该函数返回0，如果发生错误则返回负值。
       </para>
<!-- pgdoc-cn_end sig_en=e878766ff1009e018fed122a3ee838f2 -->
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypestimestampdefmtasc">
      <term><function>PGTYPEStimestamp_defmt_asc</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=9e1713f8dfa771df306c44284af6c62c sig_cn_org=d8f4cb2316e7b7e0b4c73291c10d5205 source=15.7 
       <para>
        Parse a timestamp value from its textual representation using a
        formatting mask.
<synopsis>
int PGTYPEStimestamp_defmt_asc(char *str, char *fmt, timestamp *d);
</synopsis>
        The function receives the textual representation of a timestamp in the
        variable <literal>str</literal> as well as the formatting mask to use in the
        variable <literal>fmt</literal>. The result will be stored in the variable
        that <literal>d</literal> points to.
       </para>
________________________________________________________-->
       <para>
        通过使用格式掩码从其文本表示中解析时间戳值。
<synopsis>
int PGTYPEStimestamp_defmt_asc(char *str, char *fmt, timestamp *d);
</synopsis>
        该函数接收时间戳的文本表示，存储在变量<literal>str</literal>中，以及要在变量<literal>fmt</literal>中使用的格式掩码。
        结果将存储在<literal>d</literal>指向的变量中。
       </para>
<!-- pgdoc-cn_end sig_en=9e1713f8dfa771df306c44284af6c62c -->
<!-- pgdoc-cn_start sig_en=833c68fcca8d5d4a7fec8ef1419b2d78 sig_cn_org=12e04e5781241cc17134b3c8342899ba source=15.7 
       <para>
        If the formatting mask <literal>fmt</literal> is NULL, the function will fall
        back to the default formatting mask which is <literal>%Y-%m-%d
        %H:%M:%S</literal>.
       </para>
________________________________________________________-->
       <para>
        如果格式掩码<literal>fmt</literal>为NULL，则函数将回退到默认的格式掩码，即<literal>%Y-%m-%d %H:%M:%S</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=833c68fcca8d5d4a7fec8ef1419b2d78 -->
<!-- pgdoc-cn_start sig_en=5cf35cde86eb440a96eaa67c7a2a8f7e sig_cn_org=81210ae855b2185a4f7e27e0c9955cc0 source=15.7 
       <para>
        This is the reverse function to <xref
        linkend="pgtypestimestampfmtasc"/>.  See the documentation there in
        order to find out about the possible formatting mask entries.
       </para>
________________________________________________________-->
       <para>
        这是与<xref linkend="pgtypestimestampfmtasc"/>相反的函数。请参阅那里的文档，以了解可能的格式掩码条目。
       </para>
<!-- pgdoc-cn_end sig_en=5cf35cde86eb440a96eaa67c7a2a8f7e -->
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypestimestampaddinterval">
      <term><function>PGTYPEStimestamp_add_interval</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=11cfabea760812acdd27213b770d4311 sig_cn_org=6edc21d4130daecee3eed851728b024f source=15.7 
       <para>
        Add an interval variable to a timestamp variable.
<synopsis>
int PGTYPEStimestamp_add_interval(timestamp *tin, interval *span, timestamp *tout);
</synopsis>
        The function receives a pointer to a timestamp variable <literal>tin</literal>
        and a pointer to an interval variable <literal>span</literal>. It adds the
        interval to the timestamp and saves the resulting timestamp in the
        variable that <literal>tout</literal> points to.
       </para>
________________________________________________________-->
       <para>
        向时间戳变量添加一个间隔变量。
<synopsis>
int PGTYPEStimestamp_add_interval(timestamp *tin, interval *span, timestamp *tout);
</synopsis>
        该函数接收一个指向时间戳变量<literal>tin</literal>的指针和一个指向间隔变量<literal>span</literal>的指针。
        它将间隔添加到时间戳中，并将结果时间戳保存在<literal>tout</literal>指向的变量中。
       </para>
<!-- pgdoc-cn_end sig_en=11cfabea760812acdd27213b770d4311 -->
<!-- pgdoc-cn_start sig_en=e878766ff1009e018fed122a3ee838f2 sig_cn_org=d33969792e2e69de9d63bd993bf4f234 source=15.7 
       <para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
________________________________________________________-->
       <para>
        当成功时，该函数返回0，如果发生错误则返回负值。
       </para>
<!-- pgdoc-cn_end sig_en=e878766ff1009e018fed122a3ee838f2 -->
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypestimestampsubinterval">
      <term><function>PGTYPEStimestamp_sub_interval</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=95cda93d12116fa133d89cbfec13e5f2 sig_cn_org=48ebc43f7d429c473513ca56f2f30b98 source=15.7 
       <para>
        Subtract an interval variable from a timestamp variable.
<synopsis>
int PGTYPEStimestamp_sub_interval(timestamp *tin, interval *span, timestamp *tout);
</synopsis>
        The function subtracts the interval variable that <literal>span</literal>
        points to from the timestamp variable that <literal>tin</literal> points to
        and saves the result into the variable that <literal>tout</literal> points
        to.
       </para>
________________________________________________________-->
       <para>
        从时间戳变量中减去一个时间间隔变量。
<synopsis>
int PGTYPEStimestamp_sub_interval(timestamp *tin, interval *span, timestamp *tout);
</synopsis>
        该函数从<literal>span</literal>指向的时间间隔变量中减去<literal>tin</literal>指向的时间戳变量，并将结果保存到<literal>tout</literal>指向的变量中。
       </para>
<!-- pgdoc-cn_end sig_en=95cda93d12116fa133d89cbfec13e5f2 -->
<!-- pgdoc-cn_start sig_en=e878766ff1009e018fed122a3ee838f2 sig_cn_org=d33969792e2e69de9d63bd993bf4f234 source=15.7 
       <para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
________________________________________________________-->
       <para>
        当成功时，该函数返回0，如果发生错误则返回负值。
       </para>
<!-- pgdoc-cn_end sig_en=e878766ff1009e018fed122a3ee838f2 -->
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-pgtypes-interval">
<!-- pgdoc-cn_start sig_en=cecf1e62bee9dc33c2e0657f9cb627c0 sig_cn_org=None source=14.1 
   <title>The interval Type</title>
________________________________________________________-->
   <title>区间类型</title>
<!-- pgdoc-cn_end sig_en=cecf1e62bee9dc33c2e0657f9cb627c0 -->
<!-- pgdoc-cn_start sig_en=33d238c5e68caddb30a6cd22508d0ffa sig_cn_org=None source=14.1 
   <para>
    The interval type in C enables your programs to deal with data of the SQL
    type interval. See <xref linkend="datatype-datetime"/> for the equivalent
    type in the <productname>PostgreSQL</productname> server.
   </para>
________________________________________________________-->
   <para>
    C 中的区间类型允许你的程序处理 SQL 区间类型的数据。<productname>PostgreSQL</productname>服务器的等效类型可见<xref linkend="datatype-datetime"/>。
   </para>
<!-- pgdoc-cn_end sig_en=33d238c5e68caddb30a6cd22508d0ffa -->
<!-- pgdoc-cn_start sig_en=7ddeb79f8a03fd994124564ebdd17ea1 sig_cn_org=None source=14.1 
   <para>
    The following functions can be used to work with the interval type:
    <variablelist>

     <varlistentry id="pgtypesintervalnew">
      <term><function>PGTYPESinterval_new</function></term>
      <listitem>
       <para>
        Return a pointer to a newly allocated interval variable.
<synopsis>
interval *PGTYPESinterval_new(void);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesintervalfree">
      <term><function>PGTYPESinterval_free</function></term>
      <listitem>
       <para>
        Release the memory of a previously allocated interval variable.
<synopsis>
void PGTYPESinterval_free(interval *intvl);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesintervalfromasc">
      <term><function>PGTYPESinterval_from_asc</function></term>
      <listitem>
       <para>
        Parse an interval from its textual representation.
<synopsis>
interval *PGTYPESinterval_from_asc(char *str, char **endptr);
</synopsis>
        The function parses the input string <literal>str</literal> and returns a
        pointer to an allocated interval variable.
        At the moment ECPG always parses
        the complete string and so it currently does not support to store the
        address of the first invalid character in <literal>*endptr</literal>.
        You can safely set <literal>endptr</literal> to NULL.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesintervaltoasc">
      <term><function>PGTYPESinterval_to_asc</function></term>
      <listitem>
       <para>
        Convert a variable of type interval to its textual representation.
<synopsis>
char *PGTYPESinterval_to_asc(interval *span);
</synopsis>
        The function converts the interval variable that <literal>span</literal>
        points to into a C char*. The output looks like this example:
        <literal>@ 1 day 12 hours 59 mins 10 secs</literal>.
        The result must be freed with <function>PGTYPESchar_free()</function>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesintervalcopy">
      <term><function>PGTYPESinterval_copy</function></term>
      <listitem>
       <para>
        Copy a variable of type interval.
<synopsis>
int PGTYPESinterval_copy(interval *intvlsrc, interval *intvldest);
</synopsis>
        The function copies the interval variable that <literal>intvlsrc</literal>
        points to into the variable that <literal>intvldest</literal> points to. Note
        that you need to allocate the memory for the destination variable
        before.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    下列函数可以用于区间类型：
    <variablelist>

     <varlistentry id="pgtypesintervalnew">
      <term><function>PGTYPESinterval_new</function></term>
      <listitem>
       <para>
        返回一个指向新分配的区间变量的指针。
<synopsis>
interval *PGTYPESinterval_new(void);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesintervalfree">
      <term><function>PGTYPESinterval_free</function></term>
      <listitem>
       <para>
        释放先前分配的区间变量的内存。
<synopsis>
void PGTYPESinterval_free(interval *intvl);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesintervalfromasc">
      <term><function>PGTYPESinterval_from_asc</function></term>
      <listitem>
       <para>
        从文本表达解析一个区间。
<synopsis>
interval *PGTYPESinterval_from_asc(char *str, char **endptr);
</synopsis>
        该函数解析输入字符串<literal>str</literal>并且返回一个已分配的区间变量的指针。目前 ECPG 总是解析整个字符串并且因此当前不支持把第一个非法字符的地址存储在<literal>*endptr</literal>中。你可以安全地把<literal>endptr</literal>设置为 NULL。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesintervaltoasc">
      <term><function>PGTYPESinterval_to_asc</function></term>
      <listitem>
       <para>
        将一个区间类型的变量转换成它的文本表达。
<synopsis>
char *PGTYPESinterval_to_asc(interval *span);
</synopsis>
        该函数将<literal>span</literal>指向的区间变量转换成一个 C char*。输出看起来像这个例子：
        <literal>@ 1 day 12 hours 59 mins 10 secs</literal>。结果必须用<function>PGTYPESchar_free()</function>释放。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="pgtypesintervalcopy">
      <term><function>PGTYPESinterval_copy</function></term>
      <listitem>
       <para>
        复制一个区间类型的变量。
<synopsis>
int PGTYPESinterval_copy(interval *intvlsrc, interval *intvldest);
</synopsis>
        该函数将<literal>intvlsrc</literal>指向的区间变量复制到<literal>intvldest</literal>指向的区间变量。注意你需要现为目标变量分配好内存。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=7ddeb79f8a03fd994124564ebdd17ea1 -->
  </sect2>

  <sect2 id="ecpg-pgtypes-decimal">
<!-- pgdoc-cn_start sig_en=93f9af651709b25b8159c47a47ac177e sig_cn_org=None source=14.1 
   <title>The decimal Type</title>
________________________________________________________-->
   <title>decimal类型</title>
<!-- pgdoc-cn_end sig_en=93f9af651709b25b8159c47a47ac177e -->
<!-- pgdoc-cn_start sig_en=3dd35bd6ed8729694ef5476b9124d470 sig_cn_org=None source=14.1 
   <para>
     The decimal type is similar to the numeric type. However it is limited to
     a maximum precision of 30 significant digits. In contrast to the numeric
     type which can be created on the heap only, the decimal type can be
     created either on the stack or on the heap (by means of the functions
     <function>PGTYPESdecimal_new</function> and
     <function>PGTYPESdecimal_free</function>).
     There are a lot of other functions that deal with the decimal type in the
     <productname>Informix</productname> compatibility mode described in <xref
     linkend="ecpg-informix-compat"/>.
   </para>
________________________________________________________-->
   <para>
     decimal类型和numeric类型相似。不过，它被限制为最大精度是 30 个有效位。与numeric类型只能在堆上创建相反，decimal类型既可以在栈上也可以在堆上创建（使用函数<function>PGTYPESdecimal_new</function> 和<function>PGTYPESdecimal_free</function>）。在<xref linkend="ecpg-informix-compat"/>中描述的<productname>Informix</productname>兼容模式中有很多其它函数可以处理decimal类型。
   </para>
<!-- pgdoc-cn_end sig_en=3dd35bd6ed8729694ef5476b9124d470 -->
<!-- pgdoc-cn_start sig_en=9c24dce18531bf9b9d365913c680d060 sig_cn_org=None source=14.1 
   <para>
    The following functions can be used to work with the decimal type and are
    not only contained in the <literal>libcompat</literal> library.
    <variablelist>
     <varlistentry>
      <term><function>PGTYPESdecimal_new</function></term>
      <listitem>
       <para>
       Request a pointer to a newly allocated decimal variable.
<synopsis>
decimal *PGTYPESdecimal_new(void);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESdecimal_free</function></term>
      <listitem>
       <para>
       Free a decimal type, release all of its memory.
<synopsis>
void PGTYPESdecimal_free(decimal *var);
</synopsis>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    下列函数可以被用于decimal类型并且不仅被包含于<literal>libcompat</literal>库中。
    <variablelist>
     <varlistentry>
      <term><function>PGTYPESdecimal_new</function></term>
      <listitem>
       <para>
       要求一个指向新分配的decimal变量的指针。
<synopsis>
decimal *PGTYPESdecimal_new(void);
</synopsis>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>PGTYPESdecimal_free</function></term>
      <listitem>
       <para>
       释放一个decimal类型，释放它的所有内存。
<synopsis>
void PGTYPESdecimal_free(decimal *var);
</synopsis>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=9c24dce18531bf9b9d365913c680d060 -->
  </sect2>

   <sect2 id="ecpg-pgtypes-errno">
<!-- pgdoc-cn_start sig_en=8a8d8c24862635553ffbce59f143a400 sig_cn_org=None source=14.1 
    <title>errno Values of pgtypeslib</title>
________________________________________________________-->
    <title>pgtypeslib 的 errno 值</title>
<!-- pgdoc-cn_end sig_en=8a8d8c24862635553ffbce59f143a400 -->
<!-- pgdoc-cn_start sig_en=a71d3f47292b59a51886f9f9203806de sig_cn_org=None source=14.1 
   <para>
    <variablelist>
     <varlistentry>
      <term><literal>PGTYPES_NUM_BAD_NUMERIC</literal></term>
      <listitem>
       <para>
        An argument should contain a numeric variable (or point to a numeric
        variable) but in fact its in-memory representation was invalid.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_OVERFLOW</literal></term>
      <listitem>
       <para>
        An overflow occurred. Since the numeric type can deal with almost
        arbitrary precision, converting a numeric variable into other types
        might cause overflow.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_UNDERFLOW</literal></term>
      <listitem>
       <para>
        An underflow occurred. Since the numeric type can deal with almost
        arbitrary precision, converting a numeric variable into other types
        might cause underflow.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_DIVIDE_ZERO</literal></term>
      <listitem>
       <para>
        A division by zero has been attempted.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_DATE</literal></term>
      <listitem>
       <para>
        An invalid date string was passed to
        the <function>PGTYPESdate_from_asc</function> function.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_EARGS</literal></term>
      <listitem>
       <para>
        Invalid arguments were passed to the
        <function>PGTYPESdate_defmt_asc</function> function.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_ENOSHORTDATE</literal></term>
      <listitem>
       <para>
        An invalid token in the input string was found by the
        <function>PGTYPESdate_defmt_asc</function> function.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_INTVL_BAD_INTERVAL</literal></term>
      <listitem>
       <para>
        An invalid interval string was passed to the
        <function>PGTYPESinterval_from_asc</function> function, or an
        invalid interval value was passed to the
        <function>PGTYPESinterval_to_asc</function> function.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_ENOTDMY</literal></term>
      <listitem>
       <para>
        There was a mismatch in the day/month/year assignment in the
        <function>PGTYPESdate_defmt_asc</function> function.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_DAY</literal></term>
      <listitem>
       <para>
        An invalid day of the month value was found by
        the <function>PGTYPESdate_defmt_asc</function> function.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_MONTH</literal></term>
      <listitem>
       <para>
        An invalid month value was found by
        the <function>PGTYPESdate_defmt_asc</function> function.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_TS_BAD_TIMESTAMP</literal></term>
      <listitem>
       <para>
        An invalid timestamp string pass passed to
        the <function>PGTYPEStimestamp_from_asc</function> function,
        or an invalid timestamp value was passed to
        the <function>PGTYPEStimestamp_to_asc</function> function.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_TS_ERR_EINFTIME</literal></term>
      <listitem>
       <para>
        An infinite timestamp value was encountered in a context that
        cannot handle it.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    <variablelist>
     <varlistentry>
      <term><literal>PGTYPES_NUM_BAD_NUMERIC</literal></term>
      <listitem>
       <para>
        一个参数应该包含一个numeric变量（或者指向一个numeric变量），但是实际上它的内存表达非法。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_OVERFLOW</literal></term>
      <listitem>
       <para>
        发生一次溢出。由于numeric类型可以处理几乎任何精度，将一个numeric变量转换成其他类型可能导致溢出。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_UNDERFLOW</literal></term>
      <listitem>
       <para>
        发生一次下溢。由于numeric类型可以处理几乎任何精度，将一个numeric变量转换成其他类型可能导致下溢。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_NUM_DIVIDE_ZERO</literal></term>
      <listitem>
       <para>
        尝试了一次除零。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_DATE</literal></term>
      <listitem>
       <para>
        一个非法的日期字符串被传给了<function>PGTYPESdate_from_asc</function>函数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_EARGS</literal></term>
      <listitem>
       <para>
        非法参数被传给了<function>PGTYPESdate_defmt_asc</function>函数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_ENOSHORTDATE</literal></term>
      <listitem>
       <para>
        <function>PGTYPESdate_defmt_asc</function>函数在输入字符串中发现了一个非法记号。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_INTVL_BAD_INTERVAL</literal></term>
      <listitem>
       <para>
        一个非法的区间字符串被传给了<function>PGTYPESinterval_from_asc</function>函数，或者一个非法的区间值被传给了<function>PGTYPESinterval_to_asc</function>函数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_ERR_ENOTDMY</literal></term>
      <listitem>
       <para>
        在<function>PGTYPESdate_defmt_asc</function>函数中有日/月/年不匹配的赋值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_DAY</literal></term>
      <listitem>
       <para>
        <function>PGTYPESdate_defmt_asc</function>函数发现了月中的一个非法日值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_DATE_BAD_MONTH</literal></term>
      <listitem>
       <para>
        <function>PGTYPESdate_defmt_asc</function>函数发现了一个非法的月值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_TS_BAD_TIMESTAMP</literal></term>
      <listitem>
       <para>
        一个非法的时间戳字符串被传给了<function>PGTYPEStimestamp_from_asc</function>函数，或者一个非法的时间戳值被传给了<function>PGTYPEStimestamp_to_asc</function>函数。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PGTYPES_TS_ERR_EINFTIME</literal></term>
      <listitem>
       <para>
        在一个无法处理无限时间戳值的环境中遇到了这样一个值。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=a71d3f47292b59a51886f9f9203806de -->
  </sect2>

   <sect2 id="ecpg-pgtypes-constants">
<!-- pgdoc-cn_start sig_en=92a38eb60c81bc8515f8e5487297758e sig_cn_org=None source=14.1 
    <title>Special Constants of pgtypeslib</title>
________________________________________________________-->
    <title>pgtypeslib 的特殊常量</title>
<!-- pgdoc-cn_end sig_en=92a38eb60c81bc8515f8e5487297758e -->
<!-- pgdoc-cn_start sig_en=35658ca3d6c1baac72a9549954c479d2 sig_cn_org=None source=14.1 
   <para>
    <variablelist>
     <varlistentry id="pgtypesinvalidtimestamp">
      <term><literal>PGTYPESInvalidTimestamp</literal></term>
      <listitem>
       <para>
        A value of type timestamp representing an invalid time stamp. This is
        returned by the function <function>PGTYPEStimestamp_from_asc</function> on
        parse error.
        Note that due to the internal representation of the <type>timestamp</type> data type,
        <literal>PGTYPESInvalidTimestamp</literal> is also a valid timestamp at
        the same time. It is set to <literal>1899-12-31 23:59:59</literal>. In order
        to detect errors, make sure that your application does not only test
        for <literal>PGTYPESInvalidTimestamp</literal> but also for
        <literal>errno != 0</literal> after each call to
        <function>PGTYPEStimestamp_from_asc</function>.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    <variablelist>
     <varlistentry id="pgtypesinvalidtimestamp">
      <term><literal>PGTYPESInvalidTimestamp</literal></term>
      <listitem>
       <para>
        表示一个非法时间戳的时间戳类型值。在解析错误时，函数<function>PGTYPEStimestamp_from_asc</function>会返回这个值。注意由于<type>timestamp</type>数据类型的内部表达，<literal>PGTYPESInvalidTimestamp</literal>在同时也是一个合法的时间戳。它被设置为<literal>1899-12-31 23:59:59</literal>。为了检测到错误，确认你的应用在每次调用<function>PGTYPEStimestamp_from_asc</function>后不仅仅测试<literal>PGTYPESInvalidTimestamp</literal>，还应该测试<literal>errno != 0</literal>。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=35658ca3d6c1baac72a9549954c479d2 -->
  </sect2>
 </sect1>

 <sect1 id="ecpg-descriptors">
<!-- pgdoc-cn_start sig_en=7a26e26097be88ba3fbe1b743ae0b20f sig_cn_org=None source=14.1 
  <title>Using Descriptor Areas</title>
________________________________________________________-->
  <title>使用描述符区域</title>
<!-- pgdoc-cn_end sig_en=7a26e26097be88ba3fbe1b743ae0b20f -->

<!-- pgdoc-cn_start sig_en=9178e44bcc0c5a18aa9b6c90b7f56d5d sig_cn_org=None source=14.1 
  <para>
   An SQL descriptor area is a more sophisticated method for processing
   the result of a <command>SELECT</command>, <command>FETCH</command> or
   a <command>DESCRIBE</command> statement. An SQL descriptor area groups
   the data of one row of data together with metadata items into one
   data structure.  The metadata is particularly useful when executing
   dynamic SQL statements, where the nature of the result columns might
   not be known ahead of time. PostgreSQL provides two ways to use
   Descriptor Areas: the named SQL Descriptor Areas and the C-structure
   SQLDAs.
  </para>
________________________________________________________-->
  <para>
   一个 SQL 描述符区域是一种处理<command>SELECT</command>、<command>FETCH</command>或者<command>DESCRIBE</command>语句结果的高级方法。一个 SQL 描述符区域把数据中一行的数据及元数据项组合到一个数据结构中。在执行动态 SQL 语句时（结果行的性质无法提前预知），元数据特别有用。PostgreSQL 提供两种方法来使用描述符区域：命名 SQL 描述符区域和 C 结构 SQLDA。
  </para>
<!-- pgdoc-cn_end sig_en=9178e44bcc0c5a18aa9b6c90b7f56d5d -->

  <sect2 id="ecpg-named-descriptors">
<!-- pgdoc-cn_start sig_en=2785d84b79ed6bca6d294fd44a4240e1 sig_cn_org=None source=14.1 
   <title>Named SQL Descriptor Areas</title>
________________________________________________________-->
   <title>命名 SQL 描述符区域</title>
<!-- pgdoc-cn_end sig_en=2785d84b79ed6bca6d294fd44a4240e1 -->

<!-- pgdoc-cn_start sig_en=f62ae095afb5bc9bbe6e89b2d49b495b sig_cn_org=None source=14.1 
   <para>
    A named SQL descriptor area consists of a header, which contains
    information concerning the entire descriptor, and one or more item
    descriptor areas, which basically each describe one column in the
    result row.
   </para>
________________________________________________________-->
   <para>
    一个命名 SQL 描述符区域由一个头部以及一个或多个条目描述符区域构成，头部包含与整个描述符相关的信息，而条目描述符区域则描述结果行中的每一列。
   </para>
<!-- pgdoc-cn_end sig_en=f62ae095afb5bc9bbe6e89b2d49b495b -->

<!-- pgdoc-cn_start sig_en=6b28047489bdc82cecd397a6743553ef sig_cn_org=None source=14.1 
   <para>
    Before you can use an SQL descriptor area, you need to allocate one:
<programlisting>
EXEC SQL ALLOCATE DESCRIPTOR <replaceable>identifier</replaceable>;
</programlisting>
    The identifier serves as the <quote>variable name</quote> of the
    descriptor area.  <!-&minus; The scope of the allocated descriptor is WHAT?. -&minus;>
    When you don't need the descriptor anymore, you should deallocate
    it:
<programlisting>
EXEC SQL DEALLOCATE DESCRIPTOR <replaceable>identifier</replaceable>;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    在使用 SQL 描述符区域之前，需要先分配一个：
<programlisting>
EXEC SQL ALLOCATE DESCRIPTOR <replaceable>identifier</replaceable>;
</programlisting>
    identifier 会作为该描述符区域的<quote>变量名</quote>。<!-- 分配的描述符的范围有多大？ -->当不再需要该描述符时，应当释放它：
<programlisting>
EXEC SQL DEALLOCATE DESCRIPTOR <replaceable>identifier</replaceable>;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=6b28047489bdc82cecd397a6743553ef -->

<!-- pgdoc-cn_start sig_en=3a8a8429f395a269971ccd475a64f464 sig_cn_org=None source=14.1 
   <para>
    To use a descriptor area, specify it as the storage target in an
    <literal>INTO</literal> clause, instead of listing host variables:
<programlisting>
EXEC SQL FETCH NEXT FROM mycursor INTO SQL DESCRIPTOR mydesc;
</programlisting>
    If the result set is empty, the Descriptor Area will still contain
    the metadata from the query, i.e., the field names.
   </para>
________________________________________________________-->
   <para>
    要使用一个描述符区域，把它指定为<literal>INTO</literal>子句的存储目标（而不是列出主变量）：
<programlisting>
EXEC SQL FETCH NEXT FROM mycursor INTO SQL DESCRIPTOR mydesc;
</programlisting>
    如果结果集为空，该描述符区域仍然会包含查询的元数据，即域的名称。
   </para>
<!-- pgdoc-cn_end sig_en=3a8a8429f395a269971ccd475a64f464 -->

<!-- pgdoc-cn_start sig_en=8aef8fa09bfaf996411eef70e6ecabe9 sig_cn_org=None source=14.1 
   <para>
    For not yet executed prepared queries, the <command>DESCRIBE</command>
    statement can be used to get the metadata of the result set:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char *sql_stmt = "SELECT * FROM table1";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE stmt1 FROM :sql_stmt;
EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    对于还没有执行的预备查询，<command>DESCRIBE</command>可以被用来得到其结果集的元数据：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char *sql_stmt = "SELECT * FROM table1";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE stmt1 FROM :sql_stmt;
EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=8aef8fa09bfaf996411eef70e6ecabe9 -->

<!-- pgdoc-cn_start sig_en=b0225cd55053392d8054faf0cc0dacb7 sig_cn_org=None source=14.1 
   <para>
    Before PostgreSQL 9.0, the <literal>SQL</literal> keyword was optional,
    so using <literal>DESCRIPTOR</literal> and <literal>SQL DESCRIPTOR</literal>
    produced named SQL Descriptor Areas. Now it is mandatory, omitting
    the <literal>SQL</literal> keyword produces SQLDA Descriptor Areas,
    see <xref linkend="ecpg-sqlda-descriptors"/>.
   </para>
________________________________________________________-->
   <para>
    在 PostgreSQL 9.0 之前，<literal>SQL</literal>关键词是可选的，因此使用<literal>DESCRIPTOR</literal>和<literal>SQL DESCRIPTOR</literal>都会产生命名 SQL 描述符区域。现在该关键词是强制性的，省略<literal>SQL</literal>关键词会产生 SQLDA 描述符区域（见<xref linkend="ecpg-sqlda-descriptors"/>）。
   </para>
<!-- pgdoc-cn_end sig_en=b0225cd55053392d8054faf0cc0dacb7 -->

<!-- pgdoc-cn_start sig_en=03a4572f8ab04e4473acc5dcfd4d668a sig_cn_org=None source=14.1 
   <para>
    In <command>DESCRIBE</command> and <command>FETCH</command> statements,
    the <literal>INTO</literal> and <literal>USING</literal> keywords can be
    used to similarly: they produce the result set and the metadata in a
    Descriptor Area.
   </para>
________________________________________________________-->
   <para>
    在<command>DESCRIBE</command>和<command>FETCH</command>语句中，<literal>INTO</literal>和<literal>USING</literal>关键词的使用相似：它们产生结果集以及一个描述符区域中的元数据。
   </para>
<!-- pgdoc-cn_end sig_en=03a4572f8ab04e4473acc5dcfd4d668a -->

<!-- pgdoc-cn_start sig_en=fc0179fb0f2f64c6d9c6c2a23593c88b sig_cn_org=None source=14.1 
   <para>
    Now how do you get the data out of the descriptor area?  You can
    think of the descriptor area as a structure with named fields.  To
    retrieve the value of a field from the header and store it into a
    host variable, use the following command:
<programlisting>
EXEC SQL GET DESCRIPTOR <replaceable>name</replaceable> :<replaceable>hostvar</replaceable> = <replaceable>field</replaceable>;
</programlisting>
    Currently, there is only one header field defined:
    <replaceable>COUNT</replaceable>, which tells how many item
    descriptor areas exist (that is, how many columns are contained in
    the result).  The host variable needs to be of an integer type.  To
    get a field from the item descriptor area, use the following
    command:
<programlisting>
EXEC SQL GET DESCRIPTOR <replaceable>name</replaceable> VALUE <replaceable>num</replaceable> :<replaceable>hostvar</replaceable> = <replaceable>field</replaceable>;
</programlisting>
    <replaceable>num</replaceable> can be a literal integer or a host
    variable containing an integer. Possible fields are:

    <variablelist>
     <varlistentry>
      <term><literal>CARDINALITY</literal> (integer)</term>
      <listitem>
       <para>
        number of rows in the result set
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATA</literal></term>
      <listitem>
       <para>
        actual data item (therefore, the data type of this field
        depends on the query)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATETIME_INTERVAL_CODE</literal> (integer)</term>
      <listitem>
       <para>
        When <literal>TYPE</literal> is <literal>9</literal>,
        <literal>DATETIME_INTERVAL_CODE</literal> will have a value of
        <literal>1</literal> for <literal>DATE</literal>,
        <literal>2</literal> for <literal>TIME</literal>,
        <literal>3</literal> for <literal>TIMESTAMP</literal>,
        <literal>4</literal> for <literal>TIME WITH TIME ZONE</literal>, or
        <literal>5</literal> for <literal>TIMESTAMP WITH TIME ZONE</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATETIME_INTERVAL_PRECISION</literal> (integer)</term>
      <listitem>
       <para>
        not implemented
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>INDICATOR</literal> (integer)</term>
      <listitem>
       <para>
        the indicator (indicating a null value or a value truncation)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>KEY_MEMBER</literal> (integer)</term>
      <listitem>
       <para>
        not implemented
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>LENGTH</literal> (integer)</term>
      <listitem>
       <para>
        length of the datum in characters
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NAME</literal> (string)</term>
      <listitem>
       <para>
        name of the column
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NULLABLE</literal> (integer)</term>
      <listitem>
       <para>
        not implemented
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>OCTET_LENGTH</literal> (integer)</term>
      <listitem>
       <para>
        length of the character representation of the datum in bytes
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PRECISION</literal> (integer)</term>
      <listitem>
       <para>
        precision (for type <type>numeric</type>)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RETURNED_LENGTH</literal> (integer)</term>
      <listitem>
       <para>
        length of the datum in characters
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RETURNED_OCTET_LENGTH</literal> (integer)</term>
      <listitem>
       <para>
        length of the character representation of the datum in bytes
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SCALE</literal> (integer)</term>
      <listitem>
       <para>
        scale (for type <type>numeric</type>)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>TYPE</literal> (integer)</term>
      <listitem>
       <para>
        numeric code of the data type of the column
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    现在我们如何从描述符区域得到数据呢？你可以把描述符区域看成是一个具有命名域的结构。要从头部检索一个域的值并且把它存储到一个主变量中，可使用下面的命令：
<programlisting>
EXEC SQL GET DESCRIPTOR <replaceable>name</replaceable> :<replaceable>hostvar</replaceable> = <replaceable>field</replaceable>;
</programlisting>
    当前，只定义了一个头部域：<replaceable>COUNT</replaceable>，它告诉我们有多少个条目描述符区域（也就是，结果中包含多少列）。主变量需要是一个整数类型。要从条目描述符区域中得到一个域，可使用下面的命令：
<programlisting>
EXEC SQL GET DESCRIPTOR <replaceable>name</replaceable> VALUE <replaceable>num</replaceable> :<replaceable>hostvar</replaceable> = <replaceable>field</replaceable>;
</programlisting>
    <replaceable>num</replaceable>可以是一个字面整数或者包含一个整数的主变量。可能的域有：

    <variablelist>
     <varlistentry>
      <term><literal>CARDINALITY</literal> （整数）</term>
      <listitem>
       <para>
        结果集中的行数
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATA</literal></term>
      <listitem>
       <para>
        实际的数据项（因此，这个域的数据类型取决于查询）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATETIME_INTERVAL_CODE</literal> （整数）</term>
      <listitem>
       <para>
        当<literal>TYPE</literal>是<literal>9</literal>时，
        <literal>DATETIME_INTERVAL_CODE</literal>将具有以下值之一：
        <literal>1</literal> 表示 <literal>DATE</literal>，
        <literal>2</literal> 表示 <literal>TIME</literal>，
        <literal>3</literal> 表示 <literal>TIMESTAMP</literal>，
        <literal>4</literal> 表示 <literal>TIME WITH TIME ZONE</literal>，
        <literal>5</literal> 表示 <literal>TIMESTAMP WITH TIME ZONE</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DATETIME_INTERVAL_PRECISION</literal> （整数）</term>
      <listitem>
       <para>
        没有实现
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>INDICATOR</literal> （整数）</term>
      <listitem>
       <para>
        指示符（表示一个空值或者一个值截断）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>KEY_MEMBER</literal> （整数）</term>
      <listitem>
       <para>
        没有实现
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>LENGTH</literal> （整数）</term>
      <listitem>
       <para>
        以字符计的数据长度
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NAME</literal> (string)</term>
      <listitem>
       <para>
        列名
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NULLABLE</literal> （整数）</term>
      <listitem>
       <para>
        没有实现
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>OCTET_LENGTH</literal> （整数）</term>
      <listitem>
       <para>
        以字节计的数据字符表达的长度
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>PRECISION</literal> （整数）</term>
      <listitem>
       <para>
        精度（用于类型<type>numeric</type>）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RETURNED_LENGTH</literal> （整数）</term>
      <listitem>
       <para>
        以字符计的数据长度
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RETURNED_OCTET_LENGTH</literal> （整数）</term>
      <listitem>
       <para>
        以字节计的数据字符表达的长度
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SCALE</literal> （整数）</term>
      <listitem>
       <para>
        比例（用于类型<type>numeric</type>）
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>TYPE</literal> （整数）</term>
      <listitem>
       <para>
        列的数据类型的数字编码
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=fc0179fb0f2f64c6d9c6c2a23593c88b -->

<!-- pgdoc-cn_start sig_en=3f752814cd433f0aebbbd50375c7df54 sig_cn_org=None source=14.1 
   <para>
    In <command>EXECUTE</command>, <command>DECLARE</command> and <command>OPEN</command>
    statements, the effect of the <literal>INTO</literal> and <literal>USING</literal>
    keywords are different. A Descriptor Area can also be manually built to
    provide the input parameters for a query or a cursor and
    <literal>USING SQL DESCRIPTOR <replaceable>name</replaceable></literal>
    is the way to pass the input parameters into a parameterized query. The statement
    to build a named SQL Descriptor Area is below:
<programlisting>
EXEC SQL SET DESCRIPTOR <replaceable>name</replaceable> VALUE <replaceable>num</replaceable> <replaceable>field</replaceable> = :<replaceable>hostvar</replaceable>;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    在<command>EXECUTE</command>、<command>DECLARE</command>以及<command>OPEN</command>语句中，<literal>INTO</literal>和<literal>USING</literal>关键词的效果不同。也可以手工建立一个描述符区域来为一个查询或者游标提供输入参数，并且<literal>USING SQL DESCRIPTOR <replaceable>name</replaceable></literal>是用来传递输入参数给参数化查询的方法。建立一个命名 SQL 描述符区域的语句如下：
<programlisting>
EXEC SQL SET DESCRIPTOR <replaceable>name</replaceable> VALUE <replaceable>num</replaceable> <replaceable>field</replaceable> = :<replaceable>hostvar</replaceable>;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=3f752814cd433f0aebbbd50375c7df54 -->

<!-- pgdoc-cn_start sig_en=a6c98548fb8bfb96a3ee414470ddd93b sig_cn_org=None source=14.1 
   <para>
    PostgreSQL supports retrieving more that one record in one <command>FETCH</command>
    statement and storing the data in host variables in this case assumes that the
    variable is an array. E.g.:
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int id[5];
EXEC SQL END DECLARE SECTION;

EXEC SQL FETCH 5 FROM mycursor INTO SQL DESCRIPTOR mydesc;

EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :id = DATA;
</programlisting>

   </para>
________________________________________________________-->
   <para>
    PostgreSQL 支持在一个<command>FETCH</command>语句中检索多于一个记录并且在这种情况下把主变量假定为一个数组来存储数据。例如：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int id[5];
EXEC SQL END DECLARE SECTION;

EXEC SQL FETCH 5 FROM mycursor INTO SQL DESCRIPTOR mydesc;

EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :id = DATA;
</programlisting>

   </para>
<!-- pgdoc-cn_end sig_en=a6c98548fb8bfb96a3ee414470ddd93b -->

  </sect2>

  <sect2 id="ecpg-sqlda-descriptors">
<!-- pgdoc-cn_start sig_en=f94cba53cffcfe04b02aed3b99a3ff79 sig_cn_org=None source=14.1 
   <title>SQLDA Descriptor Areas</title>
________________________________________________________-->
   <title>SQLDA 描述符区域</title>
<!-- pgdoc-cn_end sig_en=f94cba53cffcfe04b02aed3b99a3ff79 -->

<!-- pgdoc-cn_start sig_en=952bfbddad2a7275c0156467b8135155 sig_cn_org=None source=14.1 
   <para>
    An SQLDA Descriptor Area is a C language structure which can be also used
    to get the result set and the metadata of a query. One structure stores one
    record from the result set.
<programlisting>
EXEC SQL include sqlda.h;
sqlda_t         *mysqlda;

EXEC SQL FETCH 3 FROM mycursor INTO DESCRIPTOR mysqlda;
</programlisting>
    Note that the <literal>SQL</literal> keyword is omitted. The paragraphs about
    the use cases of the <literal>INTO</literal> and <literal>USING</literal>
    keywords in <xref linkend="ecpg-named-descriptors"/> also apply here with an addition.
    In a <command>DESCRIBE</command> statement the <literal>DESCRIPTOR</literal>
    keyword can be completely omitted if the <literal>INTO</literal> keyword is used:
<programlisting>
EXEC SQL DESCRIBE prepared_statement INTO mysqlda;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    SQLDA 描述符区域是一个 C 语言结构，它也能被用来得到一个查询的结果集和元数据。一个结构存储一个来自结果集的记录。
<programlisting>
EXEC SQL include sqlda.h;
sqlda_t         *mysqlda;

EXEC SQL FETCH 3 FROM mycursor INTO DESCRIPTOR mysqlda;
</programlisting>
    注意<literal>SQL</literal>关键词被省略了。<xref linkend="ecpg-named-descriptors"/>中关于<literal>INTO</literal>和<literal>USING</literal>关键词用例的段落在一定条件下也适用于这里。在一个<command>DESCRIBE</command>语句中，如果使用了<literal>INTO</literal>关键词，则<literal>DESCRIPTOR</literal>关键词可以完全被省略：
<programlisting>
EXEC SQL DESCRIBE prepared_statement INTO mysqlda;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=952bfbddad2a7275c0156467b8135155 -->

    <procedure>
<!-- pgdoc-cn_start sig_en=bf8d69f4bc9ec952d52ee0ebf3536f4f sig_cn_org=None source=14.1 
     <para>
      The general flow of a program that uses SQLDA is:
     </para>
________________________________________________________-->
     <para>
      使用 SQLDA 的程序的一般流程是：
     </para>
<!-- pgdoc-cn_end sig_en=bf8d69f4bc9ec952d52ee0ebf3536f4f -->
     <step>
<!-- pgdoc-cn_start sig_en=0ab4d31355ce8ddeb051b0f53be3a3df sig_cn_org=None source=14.1 
<simpara>Prepare a query, and declare a cursor for it.</simpara>
________________________________________________________-->
<simpara>准备一个查询，并且为它声明一个游标。</simpara>
<!-- pgdoc-cn_end sig_en=0ab4d31355ce8ddeb051b0f53be3a3df -->
</step>
     <step>
<!-- pgdoc-cn_start sig_en=7e818fa6fdb2adb393825e9101c3ea36 sig_cn_org=None source=14.1 
<simpara>Declare an SQLDA for the result rows.</simpara>
________________________________________________________-->
<simpara>为结果行声明一个 SQLDA 。</simpara>
<!-- pgdoc-cn_end sig_en=7e818fa6fdb2adb393825e9101c3ea36 -->
</step>
     <step>
<!-- pgdoc-cn_start sig_en=bfeb6db4ba3af996e347cf6fcbe46ddf sig_cn_org=None source=14.1 
<simpara>Declare an SQLDA for the input parameters, and initialize them (memory allocation, parameter settings).</simpara>
________________________________________________________-->
<simpara>为输入参数声明一个 SQLDA，并且初始化它们（内存分配、参数设置）。</simpara>
<!-- pgdoc-cn_end sig_en=bfeb6db4ba3af996e347cf6fcbe46ddf -->
</step>
     <step>
<!-- pgdoc-cn_start sig_en=ef7f96e901be3f21a73c5e0eaaa3abaf sig_cn_org=None source=14.1 
<simpara>Open a cursor with the input SQLDA.</simpara>
________________________________________________________-->
<simpara>用输入 SQLDA 打开一个游标。</simpara>
<!-- pgdoc-cn_end sig_en=ef7f96e901be3f21a73c5e0eaaa3abaf -->
</step>
     <step>
<!-- pgdoc-cn_start sig_en=daab5d50d142b1c6610a8cbd6837712d sig_cn_org=None source=14.1 
<simpara>Fetch rows from the cursor, and store them into an output SQLDA.</simpara>
________________________________________________________-->
<simpara>从游标中取得行，并且把它们存储到一个输出 SQLDA。</simpara>
<!-- pgdoc-cn_end sig_en=daab5d50d142b1c6610a8cbd6837712d -->
</step>
     <step>
<!-- pgdoc-cn_start sig_en=d6d21d0ea29d3ce8919731a44b371ccb sig_cn_org=None source=14.1 
<simpara>Read values from the output SQLDA into the host variables (with conversion if necessary).</simpara>
________________________________________________________-->
<simpara>从输出 SQLDA 读取值到主变量中（必要时使用转换）。</simpara>
<!-- pgdoc-cn_end sig_en=d6d21d0ea29d3ce8919731a44b371ccb -->
</step>
     <step>
<!-- pgdoc-cn_start sig_en=094934f0a44cea7daff6138b2a5e9d5a sig_cn_org=None source=14.1 
<simpara>Close the cursor.</simpara>
________________________________________________________-->
<simpara>关闭游标。</simpara>
<!-- pgdoc-cn_end sig_en=094934f0a44cea7daff6138b2a5e9d5a -->
</step>
     <step>
<!-- pgdoc-cn_start sig_en=9576a614e525d3a3535c8d67e4831543 sig_cn_org=None source=14.1 
<simpara>Free the memory area allocated for the input SQLDA.</simpara>
________________________________________________________-->
<simpara>关闭为输入 SQLDA 分配的内存区域。</simpara>
<!-- pgdoc-cn_end sig_en=9576a614e525d3a3535c8d67e4831543 -->
</step>
    </procedure>

   <sect3>
<!-- pgdoc-cn_start sig_en=263155a71e2bf1fa42e5a403ce9fbf8d sig_cn_org=None source=14.1 
    <title>SQLDA Data Structure</title>
________________________________________________________-->
    <title>SQLDA 数据结构</title>
<!-- pgdoc-cn_end sig_en=263155a71e2bf1fa42e5a403ce9fbf8d -->

<!-- pgdoc-cn_start sig_en=6e03d7093d1c3d178ebe429f204ef465 sig_cn_org=None source=14.1 
    <para>
     SQLDA uses three data structure
     types: <type>sqlda_t</type>, <type>sqlvar_t</type>,
     and <type>struct sqlname</type>.
    </para>
________________________________________________________-->
    <para>
     SQLDA 使用三种数据结构类型：<type>sqlda_t</type>、<type>sqlvar_t</type>以及<type>struct sqlname</type>。
    </para>
<!-- pgdoc-cn_end sig_en=6e03d7093d1c3d178ebe429f204ef465 -->

    <tip>
<!-- pgdoc-cn_start sig_en=33f426ea26439b4746be91ab97930913 sig_cn_org=None source=14.1 
     <para>
      PostgreSQL's SQLDA has a similar data structure to the one in
      IBM DB2 Universal Database, so some technical information on
      DB2's SQLDA could help understanding PostgreSQL's one better.
     </para>
________________________________________________________-->
     <para>
      PostgreSQL 的 SQLDA 与 IBM DB2 Unversal 数据库中相似的数据结构，因此一些 DB2 的 SQLDA 的技术信息有助于更好地理解 PostgreSQL 的 SQLDA。
     </para>
<!-- pgdoc-cn_end sig_en=33f426ea26439b4746be91ab97930913 -->
    </tip>

    <sect4 id="ecpg-sqlda-sqlda">
<!-- pgdoc-cn_start sig_en=afa04399ef5e4e76ffbdb3fd84c30e60 sig_cn_org=None source=14.1 
     <title>sqlda_t Structure</title>
________________________________________________________-->
     <title>sqlda_t 结构</title>
<!-- pgdoc-cn_end sig_en=afa04399ef5e4e76ffbdb3fd84c30e60 -->

<!-- pgdoc-cn_start sig_en=783b2810bbeee382e4ef1c5e549cbadb sig_cn_org=None source=14.1 
     <para>
      The structure type <type>sqlda_t</type> is the type of the
      actual SQLDA.  It holds one record.  And two or
      more <type>sqlda_t</type> structures can be connected in a
      linked list with the pointer in
      the <structfield>desc_next</structfield> field, thus
      representing an ordered collection of rows.  So, when two or
      more rows are fetched, the application can read them by
      following the <structfield>desc_next</structfield> pointer in
      each <type>sqlda_t</type> node.
     </para>
________________________________________________________-->
     <para>
      结构类型<type>sqlda_t</type>是实际 SQLDA 的类型。它保存一个记录。并且两个或者更多个<type>sqlda_t</type>结构能够以<structfield>desc_next</structfield>域中的指针连接成一个链表，这样可以表示一个有序的行集合。因此，当两个或多个行被取得时，应用可以通过沿着每一个<type>sqlda_t</type>节点中的<structfield>desc_next</structfield>指针读取它们。
     </para>
<!-- pgdoc-cn_end sig_en=783b2810bbeee382e4ef1c5e549cbadb -->

<!-- pgdoc-cn_start sig_en=40bb22b4f5d9291c01d5057e5b8f6f5e sig_cn_org=None source=14.1 
     <para>
      The definition of <type>sqlda_t</type> is:
<programlisting>
struct sqlda_struct
{
    char            sqldaid[8];
    long            sqldabc;
    short           sqln;
    short           sqld;
    struct sqlda_struct *desc_next;
    struct sqlvar_struct sqlvar[1];
};

typedef struct sqlda_struct sqlda_t;
</programlisting>

      The meaning of the fields is:

    <variablelist>
     <varlistentry>
      <term><literal>sqldaid</literal></term>
      <listitem>
       <para>
        It contains the literal string <literal>"SQLDA  "</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqldabc</literal></term>
      <listitem>
       <para>
        It contains the size of the allocated space in bytes.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqln</literal></term>
      <listitem>
       <para>
        It contains the number of input parameters for a parameterized query in
        case it's passed into <command>OPEN</command>, <command>DECLARE</command> or
        <command>EXECUTE</command> statements using the <literal>USING</literal>
        keyword. In case it's used as output of <command>SELECT</command>,
        <command>EXECUTE</command> or <command>FETCH</command> statements,
        its value is the same as <literal>sqld</literal>
        statement
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqld</literal></term>
      <listitem>
       <para>
        It contains the number of fields in a result set.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>desc_next</literal></term>
      <listitem>
       <para>
        If the query returns more than one record, multiple linked
        SQLDA structures are returned, and <literal>desc_next</literal> holds
        a pointer to the next entry in the list.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>sqlvar</literal></term>
      <listitem>
       <para>
        This is the array of the columns in the result set.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
     </para>
________________________________________________________-->
     <para>
      <type>sqlda_t</type>的定义是：
<programlisting>
struct sqlda_struct
{
    char            sqldaid[8];
    long            sqldabc;
    short           sqln;
    short           sqld;
    struct sqlda_struct *desc_next;
    struct sqlvar_struct sqlvar[1];
};

typedef struct sqlda_struct sqlda_t;
</programlisting>

      域的含义是：

    <variablelist>
     <varlistentry>
      <term><literal>sqldaid</literal></term>
      <listitem>
       <para>
        它包含一个字符串<literal>"SQLDA  "</literal>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqldabc</literal></term>
      <listitem>
       <para>
        它包含已分配空间的尺寸（以字节计）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqln</literal></term>
      <listitem>
       <para>
        当它被传递给使用<literal>USING</literal>关键词的<command>OPEN</command>、<command>DECLARE</command>或者<command>EXECUTE</command>语句时，它包含用于一个参数化查询实例的输入参数的数目。在它被用作<command>SELECT</command>、<command>EXECUTE</command>或<command>FETCH</command>语句的输出时，它的值和<literal>sqld</literal>一样
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>sqld</literal></term>
      <listitem>
       <para>
        它包含一个结果集中的域的数量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>desc_next</literal></term>
      <listitem>
       <para>
        如果查询返回不止一个记录，会返回多个链接在一起的 SQLDA 结构，并且<literal>desc_next</literal>保存一个指向下一个项的指针。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>sqlvar</literal></term>
      <listitem>
       <para>
        这是结果集中列的数组。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
     </para>
<!-- pgdoc-cn_end sig_en=40bb22b4f5d9291c01d5057e5b8f6f5e -->
    </sect4>

    <sect4 id="ecpg-sqlda-sqlvar">
<!-- pgdoc-cn_start sig_en=c810ac63c70cd2edf77834a792bda9a4 sig_cn_org=None source=14.1 
     <title>sqlvar_t Structure</title>
________________________________________________________-->
     <title>sqlvar_t 结构</title>
<!-- pgdoc-cn_end sig_en=c810ac63c70cd2edf77834a792bda9a4 -->

<!-- pgdoc-cn_start sig_en=c35a04c2e89e0829c16d6d0491e93933 sig_cn_org=None source=14.1 
     <para>
      The structure type <type>sqlvar_t</type> holds a column value
      and metadata such as type and length. The definition of the type
      is:

<programlisting>
struct sqlvar_struct
{
    short          sqltype;
    short          sqllen;
    char          *sqldata;
    short         *sqlind;
    struct sqlname sqlname;
};

typedef struct sqlvar_struct sqlvar_t;
</programlisting>

      The meaning of the fields is:

        <variablelist>
         <varlistentry>
         <term><literal>sqltype</literal></term>
          <listitem>
           <para>
            Contains the type identifier of the field. For values,
            see <literal>enum ECPGttype</literal> in <literal>ecpgtype.h</literal>.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqllen</literal></term>
          <listitem>
           <para>
            Contains the binary length of the field. e.g., 4 bytes for <type>ECPGt_int</type>.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqldata</literal></term>
          <listitem>
           <para>
            Points to the data.  The format of the data is described
            in <xref linkend="ecpg-variables-type-mapping"/>.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqlind</literal></term>
          <listitem>
           <para>
            Points to the null indicator.  0 means not null, -1 means
            null.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqlname</literal></term>
          <listitem>
           <para>
            The name of the field.
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
     </para>
________________________________________________________-->
     <para>
      结构类型<type>sqlvar_t</type>保存一个列值和元数据（例如类型和长度）。该类型的定义是：

<programlisting>
struct sqlvar_struct
{
    short          sqltype;
    short          sqllen;
    char          *sqldata;
    short         *sqlind;
    struct sqlname sqlname;
};

typedef struct sqlvar_struct sqlvar_t;
</programlisting>

      各个域的含义是：

        <variablelist>
         <varlistentry>
         <term><literal>sqltype</literal></term>
          <listitem>
           <para>
            包含该域的类型标识符。值可以参考<literal>ecpgtype.h</literal>中的<literal>enum ECPGttype</literal>。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqllen</literal></term>
          <listitem>
           <para>
            包含域的二进制长度，例如<type>ECPGt_int</type>是 4 字节。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqldata</literal></term>
          <listitem>
           <para>
            指向数据。数据的格式在<xref linkend="ecpg-variables-type-mapping"/>中描述。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqlind</literal></term>
          <listitem>
           <para>
            指向空指示符。0 表示非空，-1 表示空。
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
         <term><literal>sqlname</literal></term>
          <listitem>
           <para>
            域的名称。
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
     </para>
<!-- pgdoc-cn_end sig_en=c35a04c2e89e0829c16d6d0491e93933 -->
    </sect4>

    <sect4 id="ecpg-sqlda-sqlname">
<!-- pgdoc-cn_start sig_en=727ff4582177a33e1a98e74d25968d73 sig_cn_org=None source=14.1 
     <title>struct sqlname Structure</title>
________________________________________________________-->
     <title>struct sqlname 结构</title>
<!-- pgdoc-cn_end sig_en=727ff4582177a33e1a98e74d25968d73 -->

<!-- pgdoc-cn_start sig_en=d8589fb54dc41c053aa5326c7350739f sig_cn_org=None source=14.1 
     <para>
      A <type>struct sqlname</type> structure holds a column name.  It
      is used as a member of the <type>sqlvar_t</type> structure.  The
      definition of the structure is:
<programlisting>
#define NAMEDATALEN 64

struct sqlname
{
        short           length;
        char            data[NAMEDATALEN];
};
</programlisting>
      The meaning of the fields is:
            <variablelist>
             <varlistentry>
              <term><literal>length</literal></term>
               <listitem>
                <para>
                 Contains the length of the field name.
                </para>
               </listitem>
              </varlistentry>
             <varlistentry>
              <term><literal>data</literal></term>
               <listitem>
                <para>
                 Contains the actual field name.
                </para>
               </listitem>
              </varlistentry>
            </variablelist>
     </para>
________________________________________________________-->
     <para>
      一个<type>struct sqlname</type>结构保持一个列名。它被用作<type>sqlvar_t</type>结构的一个成员。该结构的定义是：
<programlisting>
#define NAMEDATALEN 64

struct sqlname
{
        short           length;
        char            data[NAMEDATALEN];
};
</programlisting>
      各个域的含义是：
            <variablelist>
             <varlistentry>
              <term><literal>length</literal></term>
               <listitem>
                <para>
                 包含域名称的长度。
                </para>
               </listitem>
              </varlistentry>
             <varlistentry>
              <term><literal>data</literal></term>
               <listitem>
                <para>
                 包含实际的域名称。
                </para>
               </listitem>
              </varlistentry>
            </variablelist>
     </para>
<!-- pgdoc-cn_end sig_en=d8589fb54dc41c053aa5326c7350739f -->
    </sect4>
   </sect3>

   <sect3 id="ecpg-sqlda-output">
<!-- pgdoc-cn_start sig_en=30bf08b18a752c5776d6fe828cfb4c33 sig_cn_org=None source=14.1 
    <title>Retrieving a Result Set Using an SQLDA</title>
________________________________________________________-->
    <title>使用一个 SQLDA 检索一个结果集</title>
<!-- pgdoc-cn_end sig_en=30bf08b18a752c5776d6fe828cfb4c33 -->

    <procedure>
<!-- pgdoc-cn_start sig_en=3709ae990a6ccebaee3413729bd743c7 sig_cn_org=None source=14.1 
     <para>
      The general steps to retrieve a query result set through an
      SQLDA are:
     </para>
________________________________________________________-->
     <para>
      通过一个 SQLDA 检索一个查询结果集的一般步骤是：
     </para>
<!-- pgdoc-cn_end sig_en=3709ae990a6ccebaee3413729bd743c7 -->
     <step>
<!-- pgdoc-cn_start sig_en=e7bf5c270c61efba153865fb7a17a292 sig_cn_org=None source=14.1 
<simpara>Declare an <type>sqlda_t</type> structure to receive the result set.</simpara>
________________________________________________________-->
<simpara>声明一个<type>sqlda_t</type>结构来接收结果集。</simpara>
<!-- pgdoc-cn_end sig_en=e7bf5c270c61efba153865fb7a17a292 -->
</step>
     <step>
<!-- pgdoc-cn_start sig_en=d57c46acf3d012d31565ce7954f24554 sig_cn_org=None source=14.1 
<simpara>Execute <command>FETCH</command>/<command>EXECUTE</command>/<command>DESCRIBE</command> commands to process a query specifying the declared SQLDA.</simpara>
________________________________________________________-->
<simpara>执行 <command>FETCH</command>/<command>EXECUTE</command>/<command>DESCRIBE</command> 命令来处理一个指定已声明 SQLDA 的查询。</simpara>
<!-- pgdoc-cn_end sig_en=d57c46acf3d012d31565ce7954f24554 -->
</step>
     <step>
<!-- pgdoc-cn_start sig_en=4b80617f6ac6e62827a156e94b5f0632 sig_cn_org=None source=14.1 
<simpara>Check the number of records in the result set by looking at <structfield>sqln</structfield>, a member of the <type>sqlda_t</type> structure.</simpara>
________________________________________________________-->
<simpara>通过查看<type>sqlda_t</type>结构的成员<structfield>sqln</structfield>来检查结果集中记录的数量。</simpara>
<!-- pgdoc-cn_end sig_en=4b80617f6ac6e62827a156e94b5f0632 -->
</step>
     <step>
<!-- pgdoc-cn_start sig_en=a89646f72394ee59fe256e38a85fe2cc sig_cn_org=None source=14.1 
<simpara>Get the values of each column from <literal>sqlvar[0]</literal>, <literal>sqlvar[1]</literal>, etc., members of the <type>sqlda_t</type> structure.</simpara>
________________________________________________________-->
<simpara>从<type>sqlda_t</type>结构的成员<literal>sqlvar[0]</literal>、<literal>sqlvar[1]</literal>等中得到每一列的值。</simpara>
<!-- pgdoc-cn_end sig_en=a89646f72394ee59fe256e38a85fe2cc -->
</step>
     <step>
<!-- pgdoc-cn_start sig_en=0ff4921ce6707d06fda34ba03175394a sig_cn_org=None source=14.1 
<simpara>Go to next row (<type>sqlda_t</type> structure) by following the <structfield>desc_next</structfield> pointer, a member of the <type>sqlda_t</type> structure.</simpara>
________________________________________________________-->
<simpara>沿着<type>sqlda_t</type>结构的成员<structfield>desc_next</structfield>指针到达下一行（<type>sqlda_t</type>）。</simpara>
<!-- pgdoc-cn_end sig_en=0ff4921ce6707d06fda34ba03175394a -->
</step>
     <step>
<!-- pgdoc-cn_start sig_en=c49d8435b2f680c083d40f37ec0f9556 sig_cn_org=None source=14.1 
<simpara>Repeat above as you need.</simpara>
________________________________________________________-->
<simpara>根据你的需要重复上述步骤。</simpara>
<!-- pgdoc-cn_end sig_en=c49d8435b2f680c083d40f37ec0f9556 -->
</step>
    </procedure>

<!-- pgdoc-cn_start sig_en=d6701c7f7c76ce7090349f534c9fe3e0 sig_cn_org=None source=14.1 
    <para>
     Here is an example retrieving a result set through an SQLDA.
    </para>
________________________________________________________-->
    <para>
     这里是一个通过 SQLDA 检索结果集的例子。
    </para>
<!-- pgdoc-cn_end sig_en=d6701c7f7c76ce7090349f534c9fe3e0 -->

<!-- pgdoc-cn_start sig_en=843bc6aae4f1d05ee291c26f695fb7e9 sig_cn_org=None source=14.1 
    <para>
     First, declare a <type>sqlda_t</type> structure to receive the result set.
<programlisting>
sqlda_t *sqlda1;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     首先，声明一个<type>sqlda_t</type>结构来接收结果集。
<programlisting>
sqlda_t *sqlda1;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=843bc6aae4f1d05ee291c26f695fb7e9 -->

<!-- pgdoc-cn_start sig_en=1c8eaa6db72f1c70eaec50b446c65b1c sig_cn_org=None source=14.1 
    <para>
     Next, specify the SQLDA in a command.  This is
     a <command>FETCH</command> command example.
<programlisting>
EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     接下来，指定一个命令中的 SQLDA。这是一个<command>FETCH</command>命令的例子。
<programlisting>
EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=1c8eaa6db72f1c70eaec50b446c65b1c -->

<!-- pgdoc-cn_start sig_en=4b36368005aa89d40f0daf73f5b81be4 sig_cn_org=None source=14.1 
    <para>
     Run a loop following the linked list to retrieve the rows.
<programlisting>
sqlda_t *cur_sqlda;

for (cur_sqlda = sqlda1;
     cur_sqlda != NULL;
     cur_sqlda = cur_sqlda->desc_next)
{
    ...
}
</programlisting>
    </para>
________________________________________________________-->
    <para>
     运行一个循环顺着链表来检索行。
<programlisting>
sqlda_t *cur_sqlda;

for (cur_sqlda = sqlda1;
     cur_sqlda != NULL;
     cur_sqlda = cur_sqlda->desc_next)
{
    ...
}
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=4b36368005aa89d40f0daf73f5b81be4 -->

<!-- pgdoc-cn_start sig_en=0ad566377531899b548b0380e355e689 sig_cn_org=None source=14.1 
    <para>
     Inside the loop, run another loop to retrieve each column data
     (<type>sqlvar_t</type> structure) of the row.
<programlisting>
for (i = 0; i &lt; cur_sqlda->sqld; i++)
{
    sqlvar_t v = cur_sqlda->sqlvar[i];
    char *sqldata = v.sqldata;
    short sqllen  = v.sqllen;
    ...
}
</programlisting>
    </para>
________________________________________________________-->
    <para>
     在循环内部，运行另一个循环来检索行中每一列的数据（<type>sqlvar_t</type>结构）。
<programlisting>
for (i = 0; i &lt; cur_sqlda->sqld; i++)
{
    sqlvar_t v = cur_sqlda->sqlvar[i];
    char *sqldata = v.sqldata;
    short sqllen  = v.sqllen;
    ...
}
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=0ad566377531899b548b0380e355e689 -->

<!-- pgdoc-cn_start sig_en=3c88e953e0ca916088261bfbe6e48942 sig_cn_org=None source=14.1 
    <para>
     To get a column value, check the <structfield>sqltype</structfield> value,
     a member of the <type>sqlvar_t</type> structure.  Then, switch
     to an appropriate way, depending on the column type, to copy
     data from the <structfield>sqlvar</structfield> field to a host variable.
<programlisting>
char var_buf[1024];

switch (v.sqltype)
{
    case ECPGt_char:
        memset(&amp;var_buf, 0, sizeof(var_buf));
        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf) - 1 : sqllen));
        break;

    case ECPGt_int: /* integer */
        memcpy(&amp;intval, sqldata, sqllen);
        snprintf(var_buf, sizeof(var_buf), "%d", intval);
        break;

    ...
}
</programlisting>
    </para>
________________________________________________________-->
    <para>
     要得到一列的值，应检查<type>sqlvar_t</type>结构的成员<structfield>sqltype</structfield>的值。然后，根据列类型切换到一种合适的方法从<structfield>sqlvar</structfield>域中复制数据到一个主变量。
<programlisting>
char var_buf[1024];

switch (v.sqltype)
{
    case ECPGt_char:
        memset(&amp;var_buf, 0, sizeof(var_buf));
        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf) - 1 : sqllen));
        break;

    case ECPGt_int: /* integer */
        memcpy(&amp;intval, sqldata, sqllen);
        snprintf(var_buf, sizeof(var_buf), "%d", intval);
        break;

    ...
}
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=3c88e953e0ca916088261bfbe6e48942 -->
   </sect3>

   <sect3 id="ecpg-sqlda-input">
<!-- pgdoc-cn_start sig_en=69f8b4b2e2fe4155cd7edc3ea0772a82 sig_cn_org=None source=14.1 
    <title>Passing Query Parameters Using an SQLDA</title>
________________________________________________________-->
    <title>使用一个 SQLDA 传递查询参数</title>
<!-- pgdoc-cn_end sig_en=69f8b4b2e2fe4155cd7edc3ea0772a82 -->

    <procedure>
<!-- pgdoc-cn_start sig_en=3b84eb833952b3f0a1fc9f605329aa6a sig_cn_org=None source=14.1 
     <para>
      The general steps to use an SQLDA to pass input
      parameters to a prepared query are:
     </para>
________________________________________________________-->
     <para>
      使用一个 SQLDA 传递输入参数给一个预备查询的一般步骤是：
     </para>
<!-- pgdoc-cn_end sig_en=3b84eb833952b3f0a1fc9f605329aa6a -->
     <step>
<!-- pgdoc-cn_start sig_en=ee8017e15831c8e742f3e2744ab7243c sig_cn_org=None source=14.1 
<simpara>Create a prepared query (prepared statement)</simpara>
________________________________________________________-->
<simpara>创建一个预备查询（预备语句）。</simpara>
<!-- pgdoc-cn_end sig_en=ee8017e15831c8e742f3e2744ab7243c -->
</step>
     <step>
<!-- pgdoc-cn_start sig_en=b44c27eb429ae8e33768a50559c87f6d sig_cn_org=None source=14.1 
<simpara>Declare an sqlda_t structure as an input SQLDA.</simpara>
________________________________________________________-->
<simpara>声明一个 sqlda_t 结构作为输入 SQLDA。</simpara>
<!-- pgdoc-cn_end sig_en=b44c27eb429ae8e33768a50559c87f6d -->
</step>
     <step>
<!-- pgdoc-cn_start sig_en=94e20ef09accf1eab455b6c9392d0aa2 sig_cn_org=None source=14.1 
<simpara>Allocate memory area (as sqlda_t structure) for the input SQLDA.</simpara>
________________________________________________________-->
<simpara>为输入 SQLDA 分配内存区域（作为 sqlda_t 结构）。</simpara>
<!-- pgdoc-cn_end sig_en=94e20ef09accf1eab455b6c9392d0aa2 -->
</step>
     <step>
<!-- pgdoc-cn_start sig_en=a0be38b9725ba25f521cbab3fc38b7e6 sig_cn_org=None source=14.1 
<simpara>Set (copy) input values in the allocated memory.</simpara>
________________________________________________________-->
<simpara>在分配好的内存中设置（复制）输入值。</simpara>
<!-- pgdoc-cn_end sig_en=a0be38b9725ba25f521cbab3fc38b7e6 -->
</step>
     <step>
<!-- pgdoc-cn_start sig_en=b11f8ccd868d30c5eeb802650d88dfa3 sig_cn_org=None source=14.1 
<simpara>Open a cursor with specifying the input SQLDA.</simpara>
________________________________________________________-->
<simpara>打开一个说明了输入 SQLDA 的游标。</simpara>
<!-- pgdoc-cn_end sig_en=b11f8ccd868d30c5eeb802650d88dfa3 -->
</step>
    </procedure>

<!-- pgdoc-cn_start sig_en=b7f891de498e5e005f0808335e338b3f sig_cn_org=None source=14.1 
    <para>
     Here is an example.
    </para>
________________________________________________________-->
    <para>
     这里是一个例子。
    </para>
<!-- pgdoc-cn_end sig_en=b7f891de498e5e005f0808335e338b3f -->

<!-- pgdoc-cn_start sig_en=bff8c246c1b34bcde58e08d6785f88c4 sig_cn_org=None source=14.1 
    <para>
     First, create a prepared statement.
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char query[1024] = "SELECT d.oid, * FROM pg_database d, pg_stat_database s WHERE d.oid = s.datid AND (d.datname = ? OR d.oid = ?)";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE stmt1 FROM :query;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     首先，创建一个预备语句。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
char query[1024] = "SELECT d.oid, * FROM pg_database d, pg_stat_database s WHERE d.oid = s.datid AND (d.datname = ? OR d.oid = ?)";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE stmt1 FROM :query;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=bff8c246c1b34bcde58e08d6785f88c4 -->

<!-- pgdoc-cn_start sig_en=5a739e8bd3c056b31c25587e84cddd9a sig_cn_org=None source=14.1 
    <para>
     Next, allocate memory for an SQLDA, and set the number of input
     parameters in <structfield>sqln</structfield>, a member variable of
     the <type>sqlda_t</type> structure.  When two or more input
     parameters are required for the prepared query, the application
     has to allocate additional memory space which is calculated by
     (nr. of params - 1) * sizeof(sqlvar_t).  The example shown here
     allocates memory space for two input parameters.
<programlisting>
sqlda_t *sqlda2;

sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));

sqlda2->sqln = 2; /* number of input variables */
</programlisting>
    </para>
________________________________________________________-->
    <para>
     接下来为一个 SQLDA 分配内存，并且在<type>sqlda_t</type>结构的<structfield>sqln</structfield>成员变量中设置输入参数的数量。当预备查询要求两个或多个输入参数时，应用必须分配额外的内存空间，空间的大小为 (参数数目 - 1) * sizeof(sqlvar_t)。这里的例子展示了为两个输入参数分配内存空间。
<programlisting>
sqlda_t *sqlda2;

sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));

sqlda2->sqln = 2; /* 输入变量的数目 */
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=5a739e8bd3c056b31c25587e84cddd9a -->

<!-- pgdoc-cn_start sig_en=f16b86ffc67730dad62fa0d74c647629 sig_cn_org=None source=14.1 
    <para>
     After memory allocation, store the parameter values into the
     <literal>sqlvar[]</literal> array.  (This is same array used for
     retrieving column values when the SQLDA is receiving a result
     set.)  In this example, the input parameters
     are <literal>"postgres"</literal>, having a string type,
     and <literal>1</literal>, having an integer type.
<programlisting>
sqlda2->sqlvar[0].sqltype = ECPGt_char;
sqlda2->sqlvar[0].sqldata = "postgres";
sqlda2->sqlvar[0].sqllen  = 8;

int intval = 1;
sqlda2->sqlvar[1].sqltype = ECPGt_int;
sqlda2->sqlvar[1].sqldata = (char *) &amp;intval;
sqlda2->sqlvar[1].sqllen  = sizeof(intval);
</programlisting>
    </para>
________________________________________________________-->
    <para>
     内存分配之后，把参数值存储到<literal>sqlvar[]</literal>数组（当 SQLDA 在接收结果集时，这也是用来检索列值的数组）。在这个例子中，输入参数是<literal>"postgres"</literal>（字符串类型）和<literal>1</literal>（整数类型）。
<programlisting>
sqlda2->sqlvar[0].sqltype = ECPGt_char;
sqlda2->sqlvar[0].sqldata = "postgres";
sqlda2->sqlvar[0].sqllen  = 8;

int intval = 1;
sqlda2->sqlvar[1].sqltype = ECPGt_int;
sqlda2->sqlvar[1].sqldata = (char *) &amp;intval;
sqlda2->sqlvar[1].sqllen  = sizeof(intval);
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=f16b86ffc67730dad62fa0d74c647629 -->

<!-- pgdoc-cn_start sig_en=fefc40d478de92e1673ae395b91d350c sig_cn_org=None source=14.1 
    <para>
     By opening a cursor and specifying the SQLDA that was set up
     beforehand, the input parameters are passed to the prepared
     statement.
<programlisting>
EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     通过打开一个游标并且说明之前已经建立好的 SQLDA，输入参数被传递给预备语句。
<programlisting>
EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=fefc40d478de92e1673ae395b91d350c -->

<!-- pgdoc-cn_start sig_en=496c0dce1c649e03ac2fc0cc9a2982f5 sig_cn_org=None source=14.1 
    <para>
     Finally, after using input SQLDAs, the allocated memory space
     must be freed explicitly, unlike SQLDAs used for receiving query
     results.
<programlisting>
free(sqlda2);
</programlisting>
    </para>
________________________________________________________-->
    <para>
     最后，用完输入 SQLDA 后必须显式地释放已分配的内存空间，这与用于接收查询结果的 SQLDA 不同。
<programlisting>
free(sqlda2);
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=496c0dce1c649e03ac2fc0cc9a2982f5 -->
   </sect3>

   <sect3 id="ecpg-sqlda-example">
<!-- pgdoc-cn_start sig_en=489198a0d62d2cdac60e601219d2435d sig_cn_org=None source=14.1 
    <title>A Sample Application Using SQLDA</title>
________________________________________________________-->
    <title>一个使用 SQLDA 的应用例子</title>
<!-- pgdoc-cn_end sig_en=489198a0d62d2cdac60e601219d2435d -->

<!-- pgdoc-cn_start sig_en=2c85bbecb1ff3aa2e6919abfbe45e9a2 sig_cn_org=None source=14.1 
    <para>
     Here is an example program, which describes how to fetch access
     statistics of the databases, specified by the input parameters,
     from the system catalogs.
    </para>
________________________________________________________-->
    <para>
     这里是一个例子程序，它描述了如何按照输入参数的指定从系统目录中取得数据库的访问统计。
    </para>
<!-- pgdoc-cn_end sig_en=2c85bbecb1ff3aa2e6919abfbe45e9a2 -->

<!-- pgdoc-cn_start sig_en=4d467f7a6bca9c9c3102ca3432f6c983 sig_cn_org=None source=14.1 
    <para>
     This application joins two system tables, pg_database and
     pg_stat_database on the database OID, and also fetches and shows
     the database statistics which are retrieved by two input
     parameters (a database <literal>postgres</literal>, and OID <literal>1</literal>).
    </para>
________________________________________________________-->
    <para>
     这个应用在数据库 OID 上连接两个系统表（pg_database 和 pg_stat_database），并且还取得和显示通过两个输入参数（一个数据库<literal>postgres</literal>和 OID <literal>1</literal>）检索到的数据库统计。
    </para>
<!-- pgdoc-cn_end sig_en=4d467f7a6bca9c9c3102ca3432f6c983 -->

<!-- pgdoc-cn_start sig_en=f924ffbbdcfd61fd34d879d876a666ad sig_cn_org=None source=14.1 
    <para>
     First, declare an SQLDA for input and an SQLDA for output.
<programlisting>
EXEC SQL include sqlda.h;

sqlda_t *sqlda1; /* an output descriptor */
sqlda_t *sqlda2; /* an input descriptor  */
</programlisting>
    </para>
________________________________________________________-->
    <para>
     首先，为输入和输出分别声明一个 SQLDA。
<programlisting>
EXEC SQL include sqlda.h;

sqlda_t *sqlda1; /* 一个输出描述符 */
sqlda_t *sqlda2; /* 一个输入描述符  */
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=f924ffbbdcfd61fd34d879d876a666ad -->

<!-- pgdoc-cn_start sig_en=f83f36520053d44b6d1db3b4ff58cd05 sig_cn_org=None source=14.1 
    <para>
     Next, connect to the database, prepare a statement, and declare a
     cursor for the prepared statement.
<programlisting>
int
main(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )";
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1 USER testuser;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    EXEC SQL PREPARE stmt1 FROM :query;
    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     接下来，连接到数据库，准备一个语句并且为预备语句声明一个游标。
<programlisting>
int
main(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )";
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1 USER testuser;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    EXEC SQL PREPARE stmt1 FROM :query;
    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=f83f36520053d44b6d1db3b4ff58cd05 -->

<!-- pgdoc-cn_start sig_en=7d9937cc6ef4b0c1d60bf73aa22c0322 sig_cn_org=None source=14.1 
    <para>
     Next, put some values in the input SQLDA for the input
     parameters.  Allocate memory for the input SQLDA, and set the
     number of input parameters to <literal>sqln</literal>.  Store
     type, value, and value length into <literal>sqltype</literal>,
     <literal>sqldata</literal>, and <literal>sqllen</literal> in the
     <literal>sqlvar</literal> structure.

<programlisting>
    /* Create SQLDA structure for input parameters. */
    sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
    sqlda2->sqln = 2; /* number of input variables */

    sqlda2->sqlvar[0].sqltype = ECPGt_char;
    sqlda2->sqlvar[0].sqldata = "postgres";
    sqlda2->sqlvar[0].sqllen  = 8;

    intval = 1;
    sqlda2->sqlvar[1].sqltype = ECPGt_int;
    sqlda2->sqlvar[1].sqldata = (char *)&amp;intval;
    sqlda2->sqlvar[1].sqllen  = sizeof(intval);
</programlisting>
    </para>
________________________________________________________-->
    <para>
     然后，为输入参数在输入 SQLDA 中放入一些值。为输入 SQLDA 分配内存，并且在<literal>sqln</literal>中设置输入参数的数目。在<literal>sqlvar</literal>结构的<literal>sqltype</literal>、<literal>sqldata</literal>和<literal>sqllen</literal>中存入类型、值和值长度。

<programlisting>
    /* 为输入参数创建 SQLDA 结构。 */
    sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
    sqlda2->sqln = 2; /* 输入变量的数量 */

    sqlda2->sqlvar[0].sqltype = ECPGt_char;
    sqlda2->sqlvar[0].sqldata = "postgres";
    sqlda2->sqlvar[0].sqllen  = 8;

    intval = 1;
    sqlda2->sqlvar[1].sqltype = ECPGt_int;
    sqlda2->sqlvar[1].sqldata = (char *)&amp;intval;
    sqlda2->sqlvar[1].sqllen  = sizeof(intval);
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=7d9937cc6ef4b0c1d60bf73aa22c0322 -->

<!-- pgdoc-cn_start sig_en=c743cb232c8bcba2465e4fb23e00e84a sig_cn_org=None source=14.1 
    <para>
     After setting up the input SQLDA, open a cursor with the input
     SQLDA.

<programlisting>
    /* Open a cursor with input parameters. */
    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     设置完输入 SQLDA 之后，用输入 SQLDA 打开一个游标。

<programlisting>
    /* 用输入参数打开一个游标。 */
    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=c743cb232c8bcba2465e4fb23e00e84a -->

<!-- pgdoc-cn_start sig_en=63f797b62b4473eebe38d92721311b38 sig_cn_org=None source=14.1 
    <para>
     Fetch rows into the output SQLDA from the opened cursor.
     (Generally, you have to call <command>FETCH</command> repeatedly
     in the loop, to fetch all rows in the result set.)
<programlisting>
    while (1)
    {
        sqlda_t *cur_sqlda;

        /* Assign descriptor to the cursor  */
        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     从打开的游标中取行到输出 SQLDA 中（通常，你不得不在循环中反复调用<command>FETCH</command>来取出结果集中的所有行）。
<programlisting>
    while (1)
    {
        sqlda_t *cur_sqlda;

        /* 分配描述符给游标  */
        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=63f797b62b4473eebe38d92721311b38 -->

<!-- pgdoc-cn_start sig_en=391c3b5050f21ed1ec6589da5dddc937 sig_cn_org=None source=14.1 
    <para>
     Next, retrieve the fetched records from the SQLDA, by following
     the linked list of the <type>sqlda_t</type> structure.
<programlisting>
    for (cur_sqlda = sqlda1 ;
         cur_sqlda != NULL ;
         cur_sqlda = cur_sqlda->desc_next)
    {
        ...
</programlisting>
    </para>
________________________________________________________-->
    <para>
     再后，沿着<type>sqlda_t</type>结构的链表从 SQLDA 中检索取得的记录。
<programlisting>
    for (cur_sqlda = sqlda1 ;
         cur_sqlda != NULL ;
         cur_sqlda = cur_sqlda->desc_next)
    {
        ...
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=391c3b5050f21ed1ec6589da5dddc937 -->

<!-- pgdoc-cn_start sig_en=55c5a7e6a673f425b0b4ceb91d1dac54 sig_cn_org=None source=14.1 
    <para>
     Read each columns in the first record.  The number of columns is
     stored in <structfield>sqld</structfield>, the actual data of the first
     column is stored in <literal>sqlvar[0]</literal>, both members of
     the <type>sqlda_t</type> structure.

<programlisting>
        /* Print every column in a row. */
        for (i = 0; i &lt; sqlda1-&gt;sqld; i++)
        {
            sqlvar_t v = sqlda1->sqlvar[i];
            char *sqldata = v.sqldata;
            short sqllen  = v.sqllen;

            strncpy(name_buf, v.sqlname.data, v.sqlname.length);
            name_buf[v.sqlname.length] = '\0';
</programlisting>
    </para>
________________________________________________________-->
    <para>
     读取第一个记录中的每一列。列的数量被存储在<structfield>sqld</structfield>中，第一列的实际数据被存储在<literal>sqlvar[0]</literal>中，两者都是<type>sqlda_t</type>结构的成员。

<programlisting>
        /* 打印一行中的每一列。 */
        for (i = 0; i &lt; sqlda1-&gt;sqld; i++)
        {
            sqlvar_t v = sqlda1->sqlvar[i];
            char *sqldata = v.sqldata;
            short sqllen  = v.sqllen;

            strncpy(name_buf, v.sqlname.data, v.sqlname.length);
            name_buf[v.sqlname.length] = '\0';
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=55c5a7e6a673f425b0b4ceb91d1dac54 -->

<!-- pgdoc-cn_start sig_en=7ce09497ba86899c074b4413eead4ffd sig_cn_org=None source=14.1 
    <para>
     Now, the column data is stored in the variable <varname>v</varname>.
     Copy every datum into host variables, looking
     at <literal>v.sqltype</literal> for the type of the column.
<programlisting>
            switch (v.sqltype) {
                int intval;
                double doubleval;
                unsigned long long int longlongval;

                case ECPGt_char:
                    memset(&amp;var_buf, 0, sizeof(var_buf));
                    memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf)-1 : sqllen));
                    break;

                case ECPGt_int: /* integer */
                    memcpy(&amp;intval, sqldata, sqllen);
                    snprintf(var_buf, sizeof(var_buf), "%d", intval);
                    break;

                ...

                default:
                    ...
            }

            printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
        }
</programlisting>
    </para>
________________________________________________________-->
    <para>
     现在，列数据已经被存在了变量<varname>v</varname>中。把每个数据复制到主变量中，列的类型可以查看。
<programlisting>
            switch (v.sqltype) {
                int intval;
                double doubleval;
                unsigned long long int longlongval;

                case ECPGt_char:
                    memset(&amp;var_buf, 0, sizeof(var_buf));
                    memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf)-1 : sqllen));
                    break;

                case ECPGt_int: /* 整数 */
                    memcpy(&amp;intval, sqldata, sqllen);
                    snprintf(var_buf, sizeof(var_buf), "%d", intval);
                    break;

                ...

                default:
                    ...
            }

            printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
        }
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=7ce09497ba86899c074b4413eead4ffd -->

<!-- pgdoc-cn_start sig_en=85fd5cb1083304b7cb45454a3d70a09b sig_cn_org=None source=14.1 
    <para>
     Close the cursor after processing all of records, and disconnect
     from the database.
<programlisting>
    EXEC SQL CLOSE cur1;
    EXEC SQL COMMIT;

    EXEC SQL DISCONNECT ALL;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     处理所有记录后关闭游标，并且从数据库断开连接。
<programlisting>
    EXEC SQL CLOSE cur1;
    EXEC SQL COMMIT;

    EXEC SQL DISCONNECT ALL;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=85fd5cb1083304b7cb45454a3d70a09b -->

<!-- pgdoc-cn_start sig_en=91be3d061614fc9f0c09569410371e3c sig_cn_org=None source=14.1 
    <para>
     The whole program is shown
     in <xref linkend="ecpg-sqlda-example-example"/>.
    </para>
________________________________________________________-->
    <para>
     整个程序显示在<xref linkend="ecpg-sqlda-example-example"/>中。
    </para>
<!-- pgdoc-cn_end sig_en=91be3d061614fc9f0c09569410371e3c -->

    <example id="ecpg-sqlda-example-example">
<!-- pgdoc-cn_start sig_en=172154d498359cb2f83ed0d9d269764d sig_cn_org=None source=14.1 
     <title>Example SQLDA Program</title>
________________________________________________________-->
     <title>示例 SQLDA 程序</title>
<!-- pgdoc-cn_end sig_en=172154d498359cb2f83ed0d9d269764d -->
<!-- pgdoc-cn_start sig_en=7ed4cb6298f2a5688b68ad5675dd9cb7 sig_cn_org=None source=14.1 
<programlisting>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;stdlib.h>
#include &lt;stdio.h>
#include &lt;unistd.h>

EXEC SQL include sqlda.h;

sqlda_t *sqlda1; /* descriptor for output */
sqlda_t *sqlda2; /* descriptor for input */

EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )";

    int intval;
    unsigned long long int longlongval;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO uptimedb AS con1 USER uptime;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    EXEC SQL PREPARE stmt1 FROM :query;
    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;

    /* Create an SQLDA structure for an input parameter */
    sqlda2 = (sqlda_t *)malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
    sqlda2->sqln = 2; /* a number of input variables */

    sqlda2->sqlvar[0].sqltype = ECPGt_char;
    sqlda2->sqlvar[0].sqldata = "postgres";
    sqlda2->sqlvar[0].sqllen  = 8;

    intval = 1;
    sqlda2->sqlvar[1].sqltype = ECPGt_int;
    sqlda2->sqlvar[1].sqldata = (char *) &amp;intval;
    sqlda2->sqlvar[1].sqllen  = sizeof(intval);

    /* Open a cursor with input parameters. */
    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;

    while (1)
    {
        sqlda_t *cur_sqlda;

        /* Assign descriptor to the cursor  */
        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;

        for (cur_sqlda = sqlda1 ;
             cur_sqlda != NULL ;
             cur_sqlda = cur_sqlda->desc_next)
        {
            int i;
            char name_buf[1024];
            char var_buf[1024];

            /* Print every column in a row. */
            for (i=0 ; i&lt;cur_sqlda->sqld ; i++)
            {
                sqlvar_t v = cur_sqlda->sqlvar[i];
                char *sqldata = v.sqldata;
                short sqllen  = v.sqllen;

                strncpy(name_buf, v.sqlname.data, v.sqlname.length);
                name_buf[v.sqlname.length] = '\0';

                switch (v.sqltype)
                {
                    case ECPGt_char:
                        memset(&amp;var_buf, 0, sizeof(var_buf));
                        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf)&lt;=sqllen ? sizeof(var_buf)-1 : sqllen) );
                        break;

                    case ECPGt_int: /* integer */
                        memcpy(&amp;intval, sqldata, sqllen);
                        snprintf(var_buf, sizeof(var_buf), "%d", intval);
                        break;

                    case ECPGt_long_long: /* bigint */
                        memcpy(&amp;longlongval, sqldata, sqllen);
                        snprintf(var_buf, sizeof(var_buf), "%lld", longlongval);
                        break;

                    default:
                    {
                        int i;
                        memset(var_buf, 0, sizeof(var_buf));
                        for (i = 0; i &lt; sqllen; i++)
                        {
                            char tmpbuf[16];
                            snprintf(tmpbuf, sizeof(tmpbuf), "%02x ", (unsigned char) sqldata[i]);
                            strncat(var_buf, tmpbuf, sizeof(var_buf));
                        }
                    }
                        break;
                }

                printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
            }

            printf("\n");
        }
    }

    EXEC SQL CLOSE cur1;
    EXEC SQL COMMIT;

    EXEC SQL DISCONNECT ALL;

    return 0;
}
</programlisting>
________________________________________________________-->
<programlisting>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;stdlib.h>
#include &lt;stdio.h>
#include &lt;unistd.h>

EXEC SQL include sqlda.h;

sqlda_t *sqlda1; /* 用于输出的描述符 */
sqlda_t *sqlda2; /* 用于输入的描述符 */

EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )";

    int intval;
    unsigned long long int longlongval;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO uptimedb AS con1 USER uptime;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    EXEC SQL PREPARE stmt1 FROM :query;
    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;

    /* 为一个输入参数创建一个 SQLDA 结构 */
    sqlda2 = (sqlda_t *)malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
    sqlda2->sqln = 2; /* 输入变量的数量 */

    sqlda2->sqlvar[0].sqltype = ECPGt_char;
    sqlda2->sqlvar[0].sqldata = "postgres";
    sqlda2->sqlvar[0].sqllen  = 8;

    intval = 1;
    sqlda2->sqlvar[1].sqltype = ECPGt_int;
    sqlda2->sqlvar[1].sqldata = (char *) &amp;intval;
    sqlda2->sqlvar[1].sqllen  = sizeof(intval);

    /* 用输入参数打开一个游标。 */
    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;

    while (1)
    {
        sqlda_t *cur_sqlda;

        /* 给游标分配描述符  */
        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;

        for (cur_sqlda = sqlda1 ;
             cur_sqlda != NULL ;
             cur_sqlda = cur_sqlda->desc_next)
        {
            int i;
            char name_buf[1024];
            char var_buf[1024];

            /* 打印一行中的每一列。 */
            for (i=0 ; i&lt;cur_sqlda->sqld ; i++)
            {
                sqlvar_t v = cur_sqlda->sqlvar[i];
                char *sqldata = v.sqldata;
                short sqllen  = v.sqllen;

                strncpy(name_buf, v.sqlname.data, v.sqlname.length);
                name_buf[v.sqlname.length] = '\0';

                switch (v.sqltype)
                {
                    case ECPGt_char:
                        memset(&amp;var_buf, 0, sizeof(var_buf));
                        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf)&lt;=sqllen ? sizeof(var_buf)-1 : sqllen) );
                        break;

                    case ECPGt_int: /* 整数 */
                        memcpy(&amp;intval, sqldata, sqllen);
                        snprintf(var_buf, sizeof(var_buf), "%d", intval);
                        break;

                    case ECPGt_long_long: /* 大整数 */
                        memcpy(&amp;longlongval, sqldata, sqllen);
                        snprintf(var_buf, sizeof(var_buf), "%lld", longlongval);
                        break;

                    default:
                    {
                        int i;
                        memset(var_buf, 0, sizeof(var_buf));
                        for (i = 0; i &lt; sqllen; i++)
                        {
                            char tmpbuf[16];
                            snprintf(tmpbuf, sizeof(tmpbuf), "%02x ", (unsigned char) sqldata[i]);
                            strncat(var_buf, tmpbuf, sizeof(var_buf));
                        }
                    }
                        break;
                }

                printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
            }

            printf("\n");
        }
    }

    EXEC SQL CLOSE cur1;
    EXEC SQL COMMIT;

    EXEC SQL DISCONNECT ALL;

    return 0;
}
</programlisting>
<!-- pgdoc-cn_end sig_en=7ed4cb6298f2a5688b68ad5675dd9cb7 -->

<!-- pgdoc-cn_start sig_en=0b94db7d53eb8ef224951c4f69e1a44f sig_cn_org=None source=14.1 
     <para>
      The output of this example should look something like the
      following (some numbers will vary).
     </para>
________________________________________________________-->
     <para>
      这个例子的输出应该看起来类似下面的结果（一些数字会变化）。
     </para>
<!-- pgdoc-cn_end sig_en=0b94db7d53eb8ef224951c4f69e1a44f -->

<!-- pgdoc-cn_start sig_en=dd574b2457c92a342ae2c1ff35e92465 sig_cn_org=dd574b2457c92a342ae2c1ff35e92465 source=15.7 
<screen>
oid = 1 (type: 1)
datname = template1 (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = t (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig =  (type: 1)
datacl = {=c/uptime,uptime=CTc/uptime} (type: 1)
datid = 1 (type: 1)
datname = template1 (type: 1)
numbackends = 0 (type: 5)
xact_commit = 113606 (type: 9)
xact_rollback = 0 (type: 9)
blks_read = 130 (type: 9)
blks_hit = 7341714 (type: 9)
tup_returned = 38262679 (type: 9)
tup_fetched = 1836281 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)

oid = 11511 (type: 1)
datname = postgres (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = f (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig =  (type: 1)
datacl =  (type: 1)
datid = 11511 (type: 1)
datname = postgres (type: 1)
numbackends = 0 (type: 5)
xact_commit = 221069 (type: 9)
xact_rollback = 18 (type: 9)
blks_read = 1176 (type: 9)
blks_hit = 13943750 (type: 9)
tup_returned = 77410091 (type: 9)
tup_fetched = 3253694 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)
</screen>
________________________________________________________-->
<screen>
oid = 1 (type: 1)
datname = template1 (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = t (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig =  (type: 1)
datacl = {=c/uptime,uptime=CTc/uptime} (type: 1)
datid = 1 (type: 1)
datname = template1 (type: 1)
numbackends = 0 (type: 5)
xact_commit = 113606 (type: 9)
xact_rollback = 0 (type: 9)
blks_read = 130 (type: 9)
blks_hit = 7341714 (type: 9)
tup_returned = 38262679 (type: 9)
tup_fetched = 1836281 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)

oid = 11511 (type: 1)
datname = postgres (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = f (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig =  (type: 1)
datacl =  (type: 1)
datid = 11511 (type: 1)
datname = postgres (type: 1)
numbackends = 0 (type: 5)
xact_commit = 221069 (type: 9)
xact_rollback = 18 (type: 9)
blks_read = 1176 (type: 9)
blks_hit = 13943750 (type: 9)
tup_returned = 77410091 (type: 9)
tup_fetched = 3253694 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)
</screen>
<!-- pgdoc-cn_end sig_en=dd574b2457c92a342ae2c1ff35e92465 -->
    </example>
   </sect3>
  </sect2>
 </sect1>

 <sect1 id="ecpg-errors">
<!-- pgdoc-cn_start sig_en=6886733ebecc00092d52eab7cd0aad90 sig_cn_org=None source=14.1 
  <title>Error Handling</title>
________________________________________________________-->
  <title>错误处理</title>
<!-- pgdoc-cn_end sig_en=6886733ebecc00092d52eab7cd0aad90 -->

<!-- pgdoc-cn_start sig_en=d495c9827bbc254a2f73ae495751be32 sig_cn_org=None source=14.1 
  <para>
   This section describes how you can handle exceptional conditions
   and warnings in an embedded SQL program.  There are two
   nonexclusive facilities for this.

   <itemizedlist>
    <listitem>
     <simpara>
      Callbacks can be configured to handle warning and error
      conditions using the <literal>WHENEVER</literal> command.
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      Detailed information about the error or warning can be obtained
      from the <varname>sqlca</varname> variable.
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
________________________________________________________-->
  <para>
   这一节描述在一个嵌入式 SQL 程序中如何处理异常情况和警告。有两种非互斥的工具可以用于这个目的。

   <itemizedlist>
    <listitem>
     <simpara>
      可以使用<literal>WHENEVER</literal>命令配置回调来处理警告和错误情况。
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      可以从<varname>sqlca</varname>变量中获得错误或警告的详细信息。
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
<!-- pgdoc-cn_end sig_en=d495c9827bbc254a2f73ae495751be32 -->

  <sect2 id="ecpg-whenever">
<!-- pgdoc-cn_start sig_en=0db4bda2bbd45a9c73cdd95d5b8c5b01 sig_cn_org=None source=14.1 
   <title>Setting Callbacks</title>
________________________________________________________-->
   <title>设置回调</title>
<!-- pgdoc-cn_end sig_en=0db4bda2bbd45a9c73cdd95d5b8c5b01 -->

<!-- pgdoc-cn_start sig_en=369b249509a86922415e09f0cdbb6e59 sig_cn_org=None source=14.1 
   <para>
    One simple method to catch errors and warnings is to set a
    specific action to be executed whenever a particular condition
    occurs.  In general:
<programlisting>
EXEC SQL WHENEVER <replaceable>condition</replaceable> <replaceable>action</replaceable>;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    一种捕捉错误和警告的简单方法是设置一个特殊的动作，只要一个特定情况发生就执行该动作。通常是这样：
<programlisting>
EXEC SQL WHENEVER <replaceable>condition</replaceable> <replaceable>action</replaceable>;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=369b249509a86922415e09f0cdbb6e59 -->

<!-- pgdoc-cn_start sig_en=fd1db2814e283cbd27c5676dffd4898b sig_cn_org=None source=14.1 
   <para>
    <replaceable>condition</replaceable> can be one of the following:

    <variablelist>
     <varlistentry>
      <term><literal>SQLERROR</literal></term>
      <listitem>
       <para>
        The specified action is called whenever an error occurs during
        the execution of an SQL statement.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SQLWARNING</literal></term>
      <listitem>
       <para>
        The specified action is called whenever a warning occurs
        during the execution of an SQL statement.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NOT FOUND</literal></term>
      <listitem>
       <para>
        The specified action is called whenever an SQL statement
        retrieves or affects zero rows.  (This condition is not an
        error, but you might be interested in handling it specially.)
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    <replaceable>condition</replaceable>可以是下列之一：

    <variablelist>
     <varlistentry>
      <term><literal>SQLERROR</literal></term>
      <listitem>
       <para>
        只要在 SQL 语句执行期间发生一个错误就调用指定的动作。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SQLWARNING</literal></term>
      <listitem>
       <para>
        只要在 SQL 语句执行期间发生一个警告就调用指定的动作。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NOT FOUND</literal></term>
      <listitem>
       <para>
        只要一个 SQL 语句检索或者影响零行就调用指定的动作（这种情况不是一个错误，但是你可能需要特别地处理它）。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=fd1db2814e283cbd27c5676dffd4898b -->

<!-- pgdoc-cn_start sig_en=05d292a496489b789b782f3644cfd84c sig_cn_org=None source=14.1 
   <para>
    <replaceable>action</replaceable> can be one of the following:

    <variablelist>
     <varlistentry>
      <term><literal>CONTINUE</literal></term>
      <listitem>
       <para>
        This effectively means that the condition is ignored.  This is
        the default.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>GOTO <replaceable>label</replaceable></literal></term>
      <term><literal>GO TO <replaceable>label</replaceable></literal></term>
      <listitem>
       <para>
        Jump to the specified label (using a C <literal>goto</literal>
        statement).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SQLPRINT</literal></term>
      <listitem>
       <para>
        Print a message to standard error.  This is useful for simple
        programs or during prototyping.  The details of the message
        cannot be configured.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>STOP</literal></term>
      <listitem>
       <para>
        Call <literal>exit(1)</literal>, which will terminate the
        program.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DO BREAK</literal></term>
      <listitem>
       <para>
        Execute the C statement <literal>break</literal>.  This should
        only be used in loops or <literal>switch</literal> statements.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DO CONTINUE</literal></term>
      <listitem>
       <para>
        Execute the C statement <literal>continue</literal>.  This should
        only be used in loops statements.  if executed, will cause the flow
        of control to return to the top of the loop.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CALL <replaceable>name</replaceable> (<replaceable>args</replaceable>)</literal></term>
      <term><literal>DO <replaceable>name</replaceable> (<replaceable>args</replaceable>)</literal></term>
      <listitem>
       <para>
        Call the specified C functions with the specified arguments.  (This
        use is different from the meaning of <literal>CALL</literal>
        and <literal>DO</literal> in the normal PostgreSQL grammar.)
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    The SQL standard only provides for the actions
    <literal>CONTINUE</literal> and <literal>GOTO</literal> (and
    <literal>GO TO</literal>).
   </para>
________________________________________________________-->
   <para>
    <replaceable>action</replaceable>可以是下列之一：

    <variablelist>
     <varlistentry>
      <term><literal>CONTINUE</literal></term>
      <listitem>
       <para>
        这实际上表示该情况被忽略。这是默认值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>GOTO <replaceable>label</replaceable></literal></term>
      <term><literal>GO TO <replaceable>label</replaceable></literal></term>
      <listitem>
       <para>
        调到指定的标签（使用一个 C <literal>goto</literal>语句）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SQLPRINT</literal></term>
      <listitem>
       <para>
        把一个消息打印到标准错误。对于简单程序或原型开发中这很有用。消息的细节无法配置。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>STOP</literal></term>
      <listitem>
       <para>
        调用<literal>exit(1)</literal>终止程序。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DO BREAK</literal></term>
      <listitem>
       <para>
        执行 C 语句<literal>break</literal>。只应被用在循环或<literal>switch</literal>语句中。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DO CONTINUE</literal></term>
      <listitem>
       <para>
        执行C语句<literal>continue</literal>。这应该只被用在循环语句中。如果被执行，将导致控制流返回到循环的顶层。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CALL <replaceable>name</replaceable> (<replaceable>args</replaceable>)</literal></term>
      <term><literal>DO <replaceable>name</replaceable> (<replaceable>args</replaceable>)</literal></term>
      <listitem>
       <para>
        用指定参数调用指定的C函数（这种用法不同于正常PostgreSQL语法中<literal>CALL</literal>和<literal>DO</literal>的含义）。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    SQL 标准只提供动作<literal>CONTINUE</literal>和<literal>GOTO</literal>（以及<literal>GO TO</literal>）。
   </para>
<!-- pgdoc-cn_end sig_en=05d292a496489b789b782f3644cfd84c -->

<!-- pgdoc-cn_start sig_en=ce70689da7e7f4c446d831b6024be25d sig_cn_org=None source=14.1 
   <para>
    Here is an example that you might want to use in a simple program.
    It prints a simple message when a warning occurs and aborts the
    program when an error happens:
<programlisting>
EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLERROR STOP;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    这里有一个可能会用在简单程序中的例子。当一个警告发生时它打印一个简单消息，而发生一个错误时它会中止程序：
<programlisting>
EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLERROR STOP;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=ce70689da7e7f4c446d831b6024be25d -->

<!-- pgdoc-cn_start sig_en=73b903a3bf4b16bfc8b2700c1217512c sig_cn_org=None source=14.1 
   <para>
    The statement <literal>EXEC SQL WHENEVER</literal> is a directive
    of the SQL preprocessor, not a C statement.  The error or warning
    actions that it sets apply to all embedded SQL statements that
    appear below the point where the handler is set, unless a
    different action was set for the same condition between the first
    <literal>EXEC SQL WHENEVER</literal> and the SQL statement causing
    the condition, regardless of the flow of control in the C program.
    So neither of the two following C program excerpts will have the
    desired effect:
<programlisting>
/*
 * WRONG
 */
int main(int argc, char *argv[])
{
    ...
    if (verbose) {
        EXEC SQL WHENEVER SQLWARNING SQLPRINT;
    }
    ...
    EXEC SQL SELECT ...;
    ...
}
</programlisting>

<programlisting>
/*
 * WRONG
 */
int main(int argc, char *argv[])
{
    ...
    set_error_handler();
    ...
    EXEC SQL SELECT ...;
    ...
}

static void set_error_handler(void)
{
    EXEC SQL WHENEVER SQLERROR STOP;
}
</programlisting>
   </para>
________________________________________________________-->
   <para>
    语句<literal>EXEC SQL WHENEVER</literal>是 SQL 预处理器的一个指令，而不是一个 C 语句。不管 C 程序的控制流程如何，该语句设置的错误或警告动作适用于所有位于处理程序设置点之后的嵌入式 SQL 语句，除非在第一个<literal>EXEC SQL WHENEVER</literal>和导致情况的 SQL 语句之间为同一个情况设置了不同的动作。因此下面的两个 C 程序都不会得到预期的效果：
<programlisting>
/*
 * 错误
 */
int main(int argc, char *argv[])
{
    ...
    if (verbose) {
        EXEC SQL WHENEVER SQLWARNING SQLPRINT;
    }
    ...
    EXEC SQL SELECT ...;
    ...
}
</programlisting>

<programlisting>
/*
 * 错误
 */
int main(int argc, char *argv[])
{
    ...
    set_error_handler();
    ...
    EXEC SQL SELECT ...;
    ...
}

static void set_error_handler(void)
{
    EXEC SQL WHENEVER SQLERROR STOP;
}
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=73b903a3bf4b16bfc8b2700c1217512c -->
  </sect2>

  <sect2 id="ecpg-sqlca">
<!-- pgdoc-cn_start sig_en=1a4e0cf2fe64e2b3d03da5dd2d5a6554 sig_cn_org=None source=14.1 
   <title>sqlca</title>
________________________________________________________-->
   <title>sqlca</title>
<!-- pgdoc-cn_end sig_en=1a4e0cf2fe64e2b3d03da5dd2d5a6554 -->

<!-- pgdoc-cn_start sig_en=497ba866c0a7601d62147c4d73caa4f3 sig_cn_org=None source=14.1 
   <para>
    For more powerful error handling, the embedded SQL interface
    provides a global variable with the name <varname>sqlca</varname>
    (SQL communication area)
    that has the following structure:
<programlisting>
struct
{
    char sqlcaid[8];
    long sqlabc;
    long sqlcode;
    struct
    {
        int sqlerrml;
        char sqlerrmc[SQLERRMC_LEN];
    } sqlerrm;
    char sqlerrp[8];
    long sqlerrd[6];
    char sqlwarn[8];
    char sqlstate[5];
} sqlca;
</programlisting>
    (In a multithreaded program, every thread automatically gets its
    own copy of <varname>sqlca</varname>.  This works similarly to the
    handling of the standard C global variable
    <varname>errno</varname>.)
   </para>
________________________________________________________-->
   <para>
    为了更强大的错误处理，嵌入式 SQL 接口提供了一个名为<varname>sqlca</varname>（SQL 通讯区域）的全局变量，它具有下面的结构：
<programlisting>
struct
{
    char sqlcaid[8];
    long sqlabc;
    long sqlcode;
    struct
    {
        int sqlerrml;
        char sqlerrmc[SQLERRMC_LEN];
    } sqlerrm;
    char sqlerrp[8];
    long sqlerrd[6];
    char sqlwarn[8];
    char sqlstate[5];
} sqlca;
</programlisting>
    （在一个多线程程序中，每一个线程会自动得到它自己的<varname>sqlca</varname>副本。这和对于标准 C 全局变量<varname>errno</varname>的处理相似。）
   </para>
<!-- pgdoc-cn_end sig_en=497ba866c0a7601d62147c4d73caa4f3 -->

<!-- pgdoc-cn_start sig_en=3516cb6dbb95071f51184c806ccd6c10 sig_cn_org=None source=14.1 
   <para>
    <varname>sqlca</varname> covers both warnings and errors.  If
    multiple warnings or errors occur during the execution of a
    statement, then <varname>sqlca</varname> will only contain
    information about the last one.
   </para>
________________________________________________________-->
   <para>
    <varname>sqlca</varname>覆盖了警告和错误。如果执行一个语句时发生了多个警告或错误，那么<varname>sqlca</varname>将只包含关于最后一个的信息。
   </para>
<!-- pgdoc-cn_end sig_en=3516cb6dbb95071f51184c806ccd6c10 -->

<!-- pgdoc-cn_start sig_en=4a2d4e5b71b01b1dcd3123328f26161b sig_cn_org=None source=14.1 
   <para>
    If no error occurred in the last <acronym>SQL</acronym> statement,
    <literal>sqlca.sqlcode</literal> will be 0 and
    <literal>sqlca.sqlstate</literal> will be
    <literal>"00000"</literal>.  If a warning or error occurred, then
    <literal>sqlca.sqlcode</literal> will be negative and
    <literal>sqlca.sqlstate</literal> will be different from
    <literal>"00000"</literal>.  A positive
    <literal>sqlca.sqlcode</literal> indicates a harmless condition,
    such as that the last query returned zero rows.
    <literal>sqlcode</literal> and <literal>sqlstate</literal> are two
    different error code schemes; details appear below.
   </para>
________________________________________________________-->
   <para>
    如果在上一个<acronym>SQL</acronym>语句中没有产生错误，<literal>sqlca.sqlcode</literal>将为 0 并且<literal>sqlca.sqlstate</literal>将为<literal>"00000"</literal>。如果发生一个警告或错误，则<literal>sqlca.sqlcode</literal>将为负并且<literal>sqlca.sqlstate</literal>将不为<literal>"00000"</literal>。一个正的<literal>sqlca.sqlcode</literal>表示一种无害的情况，例如上一个查询返回零行。<literal>sqlcode</literal>和<literal>sqlstate</literal>是两种不同的错误代码模式，详见下文。
   </para>
<!-- pgdoc-cn_end sig_en=4a2d4e5b71b01b1dcd3123328f26161b -->

<!-- pgdoc-cn_start sig_en=0e9632ec45d6dc52f13a9208f134465a sig_cn_org=None source=14.1 
   <para>
    If the last SQL statement was successful, then
    <literal>sqlca.sqlerrd[1]</literal> contains the OID of the
    processed row, if applicable, and
    <literal>sqlca.sqlerrd[2]</literal> contains the number of
    processed or returned rows, if applicable to the command.
   </para>
________________________________________________________-->
   <para>
    如果上一个 SQL 语句成功，那么<literal>sqlca.sqlerrd[1]</literal>包含被处理行的 OID （如果可用），并且<literal>sqlca.sqlerrd[2]</literal>包含被处理或被返回的行数（如果适用于该命令）。
   </para>
<!-- pgdoc-cn_end sig_en=0e9632ec45d6dc52f13a9208f134465a -->

<!-- pgdoc-cn_start sig_en=888e557817dff58f502dba3f1267e32c sig_cn_org=None source=14.1 
   <para>
    In case of an error or warning,
    <literal>sqlca.sqlerrm.sqlerrmc</literal> will contain a string
    that describes the error.  The field
    <literal>sqlca.sqlerrm.sqlerrml</literal> contains the length of
    the error message that is stored in
    <literal>sqlca.sqlerrm.sqlerrmc</literal> (the result of
    <function>strlen()</function>, not really interesting for a C
    programmer).  Note that some messages are too long to fit in the
    fixed-size <literal>sqlerrmc</literal> array; they will be truncated.
   </para>
________________________________________________________-->
   <para>
    在发生一个错误或警告的情况下，<literal>sqlca.sqlerrm.sqlerrmc</literal>将包含一个描述该错误的字符串。域<literal>sqlca.sqlerrm.sqlerrml</literal>包含存储在<literal>sqlca.sqlerrm.sqlerrmc</literal>中错误消息的长度（<function>strlen()</function>的结果，对于一个 C 程序员来说并不感兴趣）。注意一些消息可能太长不能适应定长的<literal>sqlerrmc</literal>数组，它们将被截断。
   </para>
<!-- pgdoc-cn_end sig_en=888e557817dff58f502dba3f1267e32c -->

<!-- pgdoc-cn_start sig_en=8ccd5bcd274349139e76f8fd2aba7ae1 sig_cn_org=None source=14.1 
   <para>
    In case of a warning, <literal>sqlca.sqlwarn[2]</literal> is set
    to <literal>W</literal>.  (In all other cases, it is set to
    something different from <literal>W</literal>.)  If
    <literal>sqlca.sqlwarn[1]</literal> is set to
    <literal>W</literal>, then a value was truncated when it was
    stored in a host variable.  <literal>sqlca.sqlwarn[0]</literal> is
    set to <literal>W</literal> if any of the other elements are set
    to indicate a warning.
   </para>
________________________________________________________-->
   <para>
    在发生一个警告的情况下，<literal>sqlca.sqlwarn[2]</literal>被设置为<literal>W</literal>（在所有其他情况中，它被设置为不同于<literal>W</literal>的东西）。如果<literal>sqlca.sqlwarn[1]</literal>被设置为<literal>W</literal>，那么一个值被存储在一个主变量中时会被截断。如果任意其他元素被设置为指示一个警告，<literal>sqlca.sqlwarn[0]</literal>会被设置为<literal>W</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=8ccd5bcd274349139e76f8fd2aba7ae1 -->

<!-- pgdoc-cn_start sig_en=800780d4287c413822919e197462b28e sig_cn_org=None source=14.1 
   <para>
    The fields <structfield>sqlcaid</structfield>,
    <structfield>sqlabc</structfield>,
    <structfield>sqlerrp</structfield>, and the remaining elements of
    <structfield>sqlerrd</structfield> and
    <structfield>sqlwarn</structfield> currently contain no useful
    information.
   </para>
________________________________________________________-->
   <para>
    域<structfield>sqlcaid</structfield>、
    <structfield>sqlabc</structfield>,
    <structfield>sqlerrp</structfield>以及
    <structfield>sqlerrd</structfield>的剩余元素还有
    <structfield>sqlwarn</structfield>当前不包含有用的信息。
   </para>
<!-- pgdoc-cn_end sig_en=800780d4287c413822919e197462b28e -->

<!-- pgdoc-cn_start sig_en=bc29bcba84acf8ff227675b6d7df3468 sig_cn_org=None source=14.1 
   <para>
    The structure <varname>sqlca</varname> is not defined in the SQL
    standard, but is implemented in several other SQL database
    systems.  The definitions are similar at the core, but if you want
    to write portable applications, then you should investigate the
    different implementations carefully.
   </para>
________________________________________________________-->
   <para>
    SQL 标准中没有定义<varname>sqlca</varname>结构，但是在一些其他的 SQL 数据系统中都有实现。在核心上这些定义都想死，但是如果你想要编写可移植的应用，那么你应该仔细研究不同的实现。
   </para>
<!-- pgdoc-cn_end sig_en=bc29bcba84acf8ff227675b6d7df3468 -->

<!-- pgdoc-cn_start sig_en=5b7d3c40c793bd602ee7b1a1f81a3316 sig_cn_org=None source=14.1 
   <para>
    Here is one example that combines the use of <literal>WHENEVER</literal>
    and <varname>sqlca</varname>, printing out the contents
    of <varname>sqlca</varname> when an error occurs.  This is perhaps
    useful for debugging or prototyping applications, before
    installing a more <quote>user-friendly</quote> error handler.

<programlisting>
EXEC SQL WHENEVER SQLERROR CALL print_sqlca();

void
print_sqlca()
{
    fprintf(stderr, "==== sqlca ====\n");
    fprintf(stderr, "sqlcode: %ld\n", sqlca.sqlcode);
    fprintf(stderr, "sqlerrm.sqlerrml: %d\n", sqlca.sqlerrm.sqlerrml);
    fprintf(stderr, "sqlerrm.sqlerrmc: %s\n", sqlca.sqlerrm.sqlerrmc);
    fprintf(stderr, "sqlerrd: %ld %ld %ld %ld %ld %ld\n", sqlca.sqlerrd[0],sqlca.sqlerrd[1],sqlca.sqlerrd[2],
                                                          sqlca.sqlerrd[3],sqlca.sqlerrd[4],sqlca.sqlerrd[5]);
    fprintf(stderr, "sqlwarn: %d %d %d %d %d %d %d %d\n", sqlca.sqlwarn[0], sqlca.sqlwarn[1], sqlca.sqlwarn[2],
                                                          sqlca.sqlwarn[3], sqlca.sqlwarn[4], sqlca.sqlwarn[5],
                                                          sqlca.sqlwarn[6], sqlca.sqlwarn[7]);
    fprintf(stderr, "sqlstate: %5s\n", sqlca.sqlstate);
    fprintf(stderr, "===============\n");
}
</programlisting>

    The result could look as follows (here an error due to a
    misspelled table name):

<screen>
==== sqlca ====
sqlcode: -400
sqlerrm.sqlerrml: 49
sqlerrm.sqlerrmc: relation "pg_databasep" does not exist on line 38
sqlerrd: 0 0 0 0 0 0
sqlwarn: 0 0 0 0 0 0 0 0
sqlstate: 42P01
===============
</screen>
   </para>
________________________________________________________-->
   <para>
    这里有一个整合使用<literal>WHENEVER</literal>和<varname>sqlca</varname>的例子，当一个错误发生时打印出<varname>sqlca</varname>的内容。在安装一个更<quote>用户友好</quote>的错误处理器之前，这可能对调试或开发原型应用有用。

<programlisting>
EXEC SQL WHENEVER SQLERROR CALL print_sqlca();

void
print_sqlca()
{
    fprintf(stderr, "==== sqlca ====\n");
    fprintf(stderr, "sqlcode: %ld\n", sqlca.sqlcode);
    fprintf(stderr, "sqlerrm.sqlerrml: %d\n", sqlca.sqlerrm.sqlerrml);
    fprintf(stderr, "sqlerrm.sqlerrmc: %s\n", sqlca.sqlerrm.sqlerrmc);
    fprintf(stderr, "sqlerrd: %ld %ld %ld %ld %ld %ld\n", sqlca.sqlerrd[0],sqlca.sqlerrd[1],sqlca.sqlerrd[2],
                                                          sqlca.sqlerrd[3],sqlca.sqlerrd[4],sqlca.sqlerrd[5]);
    fprintf(stderr, "sqlwarn: %d %d %d %d %d %d %d %d\n", sqlca.sqlwarn[0], sqlca.sqlwarn[1], sqlca.sqlwarn[2],
                                                          sqlca.sqlwarn[3], sqlca.sqlwarn[4], sqlca.sqlwarn[5],
                                                          sqlca.sqlwarn[6], sqlca.sqlwarn[7]);
    fprintf(stderr, "sqlstate: %5s\n", sqlca.sqlstate);
    fprintf(stderr, "===============\n");
}
</programlisting>

    结果看起来像（这里的错误是一个拼写错误的表名）：

<screen>
==== sqlca ====
sqlcode: -400
sqlerrm.sqlerrml: 49
sqlerrm.sqlerrmc: relation "pg_databasep" does not exist on line 38
sqlerrd: 0 0 0 0 0 0
sqlwarn: 0 0 0 0 0 0 0 0
sqlstate: 42P01
===============
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=5b7d3c40c793bd602ee7b1a1f81a3316 -->
  </sect2>

  <sect2 id="ecpg-sqlstate-sqlcode">
<!-- pgdoc-cn_start sig_en=cc325e0e375ccd32b3d00f5057b7a9f2 sig_cn_org=None source=14.1 
   <title><literal>SQLSTATE</literal> vs. <literal>SQLCODE</literal></title>
________________________________________________________-->
   <title><literal>SQLSTATE</literal> 与 <literal>SQLCODE</literal></title>
<!-- pgdoc-cn_end sig_en=cc325e0e375ccd32b3d00f5057b7a9f2 -->

<!-- pgdoc-cn_start sig_en=a8026759db32cd00639f74df1dc3033e sig_cn_org=None source=14.1 
   <para>
    The fields <literal>sqlca.sqlstate</literal> and
    <literal>sqlca.sqlcode</literal> are two different schemes that
    provide error codes.  Both are derived from the SQL standard, but
    <literal>SQLCODE</literal> has been marked deprecated in the SQL-92
    edition of the standard and has been dropped in later editions.
    Therefore, new applications are strongly encouraged to use
    <literal>SQLSTATE</literal>.
   </para>
________________________________________________________-->
   <para>
    域<literal>sqlca.sqlstate</literal>以及<literal>sqlca.sqlcode</literal>是提供错误代码的两种不同模式。两种都源自于 SQL 标准，但是在标准的 SQL-92 版本中<literal>SQLCODE</literal>已经被标记为弃用并且在后面的版本中被删除。因此，强烈建议新应用使用<literal>SQLSTATE</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=a8026759db32cd00639f74df1dc3033e -->

<!-- pgdoc-cn_start sig_en=62b8ab9be19bb881285f794912b19b33 sig_cn_org=None source=14.1 
   <para>
    <literal>SQLSTATE</literal> is a five-character array.  The five
    characters contain digits or upper-case letters that represent
    codes of various error and warning conditions.
    <literal>SQLSTATE</literal> has a hierarchical scheme: the first
    two characters indicate the general class of the condition, the
    last three characters indicate a subclass of the general
    condition.  A successful state is indicated by the code
    <literal>00000</literal>.  The <literal>SQLSTATE</literal> codes are for
    the most part defined in the SQL standard.  The
    <productname>PostgreSQL</productname> server natively supports
    <literal>SQLSTATE</literal> error codes; therefore a high degree
    of consistency can be achieved by using this error code scheme
    throughout all applications.  For further information see
    <xref linkend="errcodes-appendix"/>.
   </para>
________________________________________________________-->
   <para>
    <literal>SQLSTATE</literal>是一个五字符数组。这五个字符包含数字或大写字母，它表示多种错误或警告情况的代码。<literal>SQLSTATE</literal>具有一种层次模式：前两个字符表示情况的总体分类，后三个字符表示总体情况的子类。代码<literal>00000</literal>表示一种成功的状态。SQL 标准中的大部分都有对应的<literal>SQLSTATE</literal>代码。<productname>PostgreSQL</productname>服务器本地支持<literal>SQLSTATE</literal>错误代码，因此通过在所有应用中自始至终使用这种错误代码模式可以实现高度的一致性。进一步的信息请见<xref linkend="errcodes-appendix"/>。
   </para>
<!-- pgdoc-cn_end sig_en=62b8ab9be19bb881285f794912b19b33 -->

<!-- pgdoc-cn_start sig_en=b49dcacacbfc685ed18db1e5906995c6 sig_cn_org=None source=14.1 
   <para>
    <literal>SQLCODE</literal>, the deprecated error code scheme, is a
    simple integer.  A value of 0 indicates success, a positive value
    indicates success with additional information, a negative value
    indicates an error.  The SQL standard only defines the positive
    value +100, which indicates that the last command returned or
    affected zero rows, and no specific negative values.  Therefore,
    this scheme can only achieve poor portability and does not have a
    hierarchical code assignment.  Historically, the embedded SQL
    processor for <productname>PostgreSQL</productname> has assigned
    some specific <literal>SQLCODE</literal> values for its use, which
    are listed below with their numeric value and their symbolic name.
    Remember that these are not portable to other SQL implementations.
    To simplify the porting of applications to the
    <literal>SQLSTATE</literal> scheme, the corresponding
    <literal>SQLSTATE</literal> is also listed.  There is, however, no
    one-to-one or one-to-many mapping between the two schemes (indeed
    it is many-to-many), so you should consult the global
    <literal>SQLSTATE</literal> listing in <xref linkend="errcodes-appendix"/>
    in each case.
   </para>
________________________________________________________-->
   <para>
    被弃用的错误代码模式<literal>SQLCODE</literal>是一个简单的整数。值为 0 表示成功，一个正值表示带附加信息的成功，一个负值表示一个错误。SQL 标准只定义了正值 +100，它表示上一个命令返回或者影响了零行，并且没有特定的负值。因此，这种模式只能实现很可怜的可移植性并且不具有层次性的代码分配。历史上，<productname>PostgreSQL</productname>的嵌入式 SQL 处理器已经分配了一些特定的<literal>SQLCODE</literal>值供它使用，它们的数字值和符号名称被列在下文。记住这些对其他 SQL 实现不是可移植的。为了简化移植应用到<literal>SQLSTATE</literal>模式，对应的<literal>SQLSTATE</literal>也被列出。不过，在两种模式之间没有一对一或者一对多的映射（事实上是多对多），因此在每一种情况下你都应该参考<xref linkend="errcodes-appendix"/>中列出的全局<literal>SQLSTATE</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=b49dcacacbfc685ed18db1e5906995c6 -->

<!-- pgdoc-cn_start sig_en=9f17c25178913a78de5789f701159de8 sig_cn_org=None source=14.1 
   <para>
    These are the assigned <literal>SQLCODE</literal> values:

    <variablelist>
     <varlistentry>
      <term>0 (<symbol>ECPG_NO_ERROR</symbol>)</term>
      <listitem>
       <para>
        Indicates no error. (SQLSTATE 00000)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>100 (<symbol>ECPG_NOT_FOUND</symbol>)</term>
     <listitem>
      <para>
       This is a harmless condition indicating that the last command
       retrieved or processed zero rows, or that you are at the end of
       the cursor.  (SQLSTATE 02000)
      </para>

      <para>
       When processing a cursor in a loop, you could use this code as
       a way to detect when to abort the loop, like this:
<programlisting>
while (1)
{
    EXEC SQL FETCH ... ;
    if (sqlca.sqlcode == ECPG_NOT_FOUND)
        break;
}
</programlisting>
       But <literal>WHENEVER NOT FOUND DO BREAK</literal> effectively
       does this internally, so there is usually no advantage in
       writing this out explicitly.
      </para>
     </listitem>
    </varlistentry>

     <varlistentry>
      <term>-12 (<symbol>ECPG_OUT_OF_MEMORY</symbol>)</term>
      <listitem>
       <para>
        Indicates that your virtual memory is exhausted.  The numeric
        value is defined as <literal>-ENOMEM</literal>.  (SQLSTATE
        YE001)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-200 (<symbol>ECPG_UNSUPPORTED</symbol>)</term>
     <listitem>
      <para>
       Indicates the preprocessor has generated something that the
       library does not know about.  Perhaps you are running
       incompatible versions of the preprocessor and the
       library. (SQLSTATE YE002)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-201 (<symbol>ECPG_TOO_MANY_ARGUMENTS</symbol>)</term>
     <listitem>
      <para>
       This means that the command specified more host variables than
       the command expected.  (SQLSTATE 07001 or 07002)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-202 (<symbol>ECPG_TOO_FEW_ARGUMENTS</symbol>)</term>
     <listitem>
      <para>
       This means that the command specified fewer host variables than
       the command expected.  (SQLSTATE 07001 or 07002)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-203 (<symbol>ECPG_TOO_MANY_MATCHES</symbol>)</term>
     <listitem>
      <para>
       This means a query has returned multiple rows but the statement
       was only prepared to store one result row (for example, because
       the specified variables are not arrays).  (SQLSTATE 21000)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-204 (<symbol>ECPG_INT_FORMAT</symbol>)</term>
     <listitem>
      <para>
       The host variable is of type <type>int</type> and the datum in
       the database is of a different type and contains a value that
       cannot be interpreted as an <type>int</type>.  The library uses
       <function>strtol()</function> for this conversion.  (SQLSTATE
       42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-205 (<symbol>ECPG_UINT_FORMAT</symbol>)</term>
     <listitem>
      <para>
       The host variable is of type <type>unsigned int</type> and the
       datum in the database is of a different type and contains a
       value that cannot be interpreted as an <type>unsigned
       int</type>.  The library uses <function>strtoul()</function>
       for this conversion.  (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-206 (<symbol>ECPG_FLOAT_FORMAT</symbol>)</term>
     <listitem>
      <para>
       The host variable is of type <type>float</type> and the datum
       in the database is of another type and contains a value that
       cannot be interpreted as a <type>float</type>.  The library
       uses <function>strtod()</function> for this conversion.
       (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-207 (<symbol>ECPG_NUMERIC_FORMAT</symbol>)</term>
     <listitem>
      <para>
       The host variable is of type <type>numeric</type> and the datum
       in the database is of another type and contains a value that
       cannot be interpreted as a <type>numeric</type> value.
       (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-208 (<symbol>ECPG_INTERVAL_FORMAT</symbol>)</term>
     <listitem>
      <para>
       The host variable is of type <type>interval</type> and the datum
       in the database is of another type and contains a value that
       cannot be interpreted as an <type>interval</type> value.
       (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-209 (<symbol>ECPG_DATE_FORMAT</symbol>)</term>
     <listitem>
      <para>
       The host variable is of type <type>date</type> and the datum in
       the database is of another type and contains a value that
       cannot be interpreted as a <type>date</type> value.
       (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-210 (<symbol>ECPG_TIMESTAMP_FORMAT</symbol>)</term>
     <listitem>
      <para>
       The host variable is of type <type>timestamp</type> and the
       datum in the database is of another type and contains a value
       that cannot be interpreted as a <type>timestamp</type> value.
       (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-211 (<symbol>ECPG_CONVERT_BOOL</symbol>)</term>
     <listitem>
      <para>
       This means the host variable is of type <type>bool</type> and
       the datum in the database is neither <literal>'t'</literal> nor
       <literal>'f'</literal>.  (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-212 (<symbol>ECPG_EMPTY</symbol>)</term>
     <listitem>
      <para>
       The statement sent to the <productname>PostgreSQL</productname>
       server was empty.  (This cannot normally happen in an embedded
       SQL program, so it might point to an internal error.)  (SQLSTATE
       YE002)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-213 (<symbol>ECPG_MISSING_INDICATOR</symbol>)</term>
     <listitem>
      <para>
       A null value was returned and no null indicator variable was
       supplied.  (SQLSTATE 22002)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-214 (<symbol>ECPG_NO_ARRAY</symbol>)</term>
     <listitem>
      <para>
       An ordinary variable was used in a place that requires an
       array.  (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-215 (<symbol>ECPG_DATA_NOT_ARRAY</symbol>)</term>
     <listitem>
      <para>
       The database returned an ordinary variable in a place that
       requires array value.  (SQLSTATE 42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-216 (<symbol>ECPG_ARRAY_INSERT</symbol>)</term>
     <listitem>
      <para>
       The value could not be inserted into the array.  (SQLSTATE
       42804)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-220 (<symbol>ECPG_NO_CONN</symbol>)</term>
     <listitem>
      <para>
       The program tried to access a connection that does not exist.
       (SQLSTATE 08003)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-221 (<symbol>ECPG_NOT_CONN</symbol>)</term>
     <listitem>
      <para>
       The program tried to access a connection that does exist but is
       not open.  (This is an internal error.)  (SQLSTATE YE002)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-230 (<symbol>ECPG_INVALID_STMT</symbol>)</term>
     <listitem>
      <para>
       The statement you are trying to use has not been prepared.
       (SQLSTATE 26000)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-239 (<symbol>ECPG_INFORMIX_DUPLICATE_KEY</symbol>)</term>
     <listitem>
      <para>
       Duplicate key error, violation of unique constraint (Informix
       compatibility mode).  (SQLSTATE 23505)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-240 (<symbol>ECPG_UNKNOWN_DESCRIPTOR</symbol>)</term>
     <listitem>
      <para>
       The descriptor specified was not found.  The statement you are
       trying to use has not been prepared.  (SQLSTATE 33000)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-241 (<symbol>ECPG_INVALID_DESCRIPTOR_INDEX</symbol>)</term>
     <listitem>
      <para>
       The descriptor index specified was out of range.  (SQLSTATE
       07009)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-242 (<symbol>ECPG_UNKNOWN_DESCRIPTOR_ITEM</symbol>)</term>
     <listitem>
      <para>
       An invalid descriptor item was requested.  (This is an internal
       error.)  (SQLSTATE YE002)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-243 (<symbol>ECPG_VAR_NOT_NUMERIC</symbol>)</term>
     <listitem>
      <para>
       During the execution of a dynamic statement, the database
       returned a numeric value and the host variable was not numeric.
       (SQLSTATE 07006)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-244 (<symbol>ECPG_VAR_NOT_CHAR</symbol>)</term>
     <listitem>
      <para>
       During the execution of a dynamic statement, the database
       returned a non-numeric value and the host variable was numeric.
       (SQLSTATE 07006)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-284 (<symbol>ECPG_INFORMIX_SUBSELECT_NOT_ONE</symbol>)</term>
     <listitem>
      <para>
       A result of the subquery is not single row (Informix
       compatibility mode).  (SQLSTATE 21000)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-400 (<symbol>ECPG_PGSQL</symbol>)</term>
     <listitem>
      <para>
       Some error caused by the <productname>PostgreSQL</productname>
       server.  The message contains the error message from the
       <productname>PostgreSQL</productname> server.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-401 (<symbol>ECPG_TRANS</symbol>)</term>
     <listitem>
      <para>
       The <productname>PostgreSQL</productname> server signaled that
       we cannot start, commit, or rollback the transaction.
       (SQLSTATE 08007)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-402 (<symbol>ECPG_CONNECT</symbol>)</term>
     <listitem>
      <para>
       The connection attempt to the database did not succeed.
       (SQLSTATE 08001)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-403 (<symbol>ECPG_DUPLICATE_KEY</symbol>)</term>
     <listitem>
      <para>
       Duplicate key error, violation of unique constraint.  (SQLSTATE
       23505)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-404 (<symbol>ECPG_SUBSELECT_NOT_ONE</symbol>)</term>
     <listitem>
      <para>
       A result for the subquery is not single row. (SQLSTATE 21000)
      </para>
     </listitem>
    </varlistentry>

    <!-&minus; currently not used by the code -&minus;>
<!-&minus;
    <varlistentry>
     <term>-600 (<symbol>ECPG_WARNING_UNRECOGNIZED</symbol>)</term>
     <listitem>
      <para>
       An unrecognized warning was received from the server.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-601 (<symbol>ECPG_WARNING_QUERY_IGNORED</symbol>)</term>
     <listitem>
      <para>
       Current transaction is aborted.  Queries are ignored until the
       end of the transaction block.
      </para>
     </listitem>
    </varlistentry>
-&minus;>

    <varlistentry>
     <term>-602 (<symbol>ECPG_WARNING_UNKNOWN_PORTAL</symbol>)</term>
     <listitem>
      <para>
       An invalid cursor name was specified. (SQLSTATE 34000)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-603 (<symbol>ECPG_WARNING_IN_TRANSACTION</symbol>)</term>
     <listitem>
      <para>
       Transaction is in progress. (SQLSTATE 25001)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-604 (<symbol>ECPG_WARNING_NO_TRANSACTION</symbol>)</term>
     <listitem>
      <para>
       There is no active (in-progress) transaction. (SQLSTATE 25P01)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-605 (<symbol>ECPG_WARNING_PORTAL_EXISTS</symbol>)</term>
     <listitem>
      <para>
       An existing cursor name was specified. (SQLSTATE 42P03)
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>
________________________________________________________-->
   <para>
    这些是已分配的<literal>SQLCODE</literal>值：

    <variablelist>
     <varlistentry>
      <term>0 (<symbol>ECPG_NO_ERROR</symbol>)</term>
      <listitem>
       <para>
        表示没有错误（SQLSTATE 00000）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>100 (<symbol>ECPG_NOT_FOUND</symbol>)</term>
     <listitem>
      <para>
       这是一种无害情况，它表示上一个命令检索或者处理了零行，或者你到达了游标的末尾（SQLSTATE 02000）。
      </para>

      <para>
       在一个循环中处理一个游标时，你可以使用这个代码作为一种方法来检测何时中止该循环，像这样：
<programlisting>
while (1)
{
    EXEC SQL FETCH ... ;
    if (sqlca.sqlcode == ECPG_NOT_FOUND)
        break;
}
</programlisting>
       但是<literal>WHENEVER NOT FOUND DO BREAK</literal>实际上会在内部这样做，因此显式地把它写出来通常没有什么好处。
      </para>
     </listitem>
    </varlistentry>

     <varlistentry>
      <term>-12 (<symbol>ECPG_OUT_OF_MEMORY</symbol>)</term>
      <listitem>
       <para>
        表示你的虚拟内存已被耗尽。数字值被定义为<literal>-ENOMEM</literal>（SQLSTATE YE001）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-200 (<symbol>ECPG_UNSUPPORTED</symbol>)</term>
     <listitem>
      <para>
       表示预处理器已经产生了一些该库不知道的东西。也许你正在运行一个不兼容版本的预处理和库（SQLSTATE YE002）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-201 (<symbol>ECPG_TOO_MANY_ARGUMENTS</symbol>)</term>
     <listitem>
      <para>
       这表示命令指定了超过该命令预期数量的主变量（SQLSTATE 07001 或 07002）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-202 (<symbol>ECPG_TOO_FEW_ARGUMENTS</symbol>)</term>
     <listitem>
      <para>
       这表示命令指定的主变量数量低于该命令的预期（SQLSTATE 07001 或 07002）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-203 (<symbol>ECPG_TOO_MANY_MATCHES</symbol>)</term>
     <listitem>
      <para>
       这意味着一个查询已经返回了多个行，但是该语句只准备存储一个结果行（例如，因为指定的变量不是数组）（SQLSTATE 21000）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-204 (<symbol>ECPG_INT_FORMAT</symbol>)</term>
     <listitem>
      <para>
       主变量是类型<type>int</type>而数据库中的数据是一种不同的类型并且含有一个不能被解释为<type>int</type>的值。该库使用<function>strtol()</function>进行这种转换（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-205 (<symbol>ECPG_UINT_FORMAT</symbol>)</term>
     <listitem>
      <para>
       主变量是类型<type>unsigned int</type>而数据库中的数据是一种不同的类型并且含有一个不能被解释为<type>unsigned int</type>的值。该库使用<function>strtoul()</function>进行这种转换（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-206 (<symbol>ECPG_FLOAT_FORMAT</symbol>)</term>
     <listitem>
      <para>
       主变量是类型<type>float</type>而数据库中的数据是另一种类型并且含有一个不能被解释为<type>float</type>的值。该库使用<function>strtod()</function>进行这种转换（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-207 (<symbol>ECPG_NUMERIC_FORMAT</symbol>)</term>
     <listitem>
      <para>
       主变量是类型<type>numeric</type>而数据库中的数据是另一种类型并且含有一个不能被解释为<type>numeric</type>的值（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-208 (<symbol>ECPG_INTERVAL_FORMAT</symbol>)</term>
     <listitem>
      <para>
       主变量是类型<type>interval</type>而数据库中的数据是另一种类型并且含有一个不能被解释为<type>interval</type>的值（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-209 (<symbol>ECPG_DATE_FORMAT</symbol>)</term>
     <listitem>
      <para>
       主变量是类型<type>date</type>而数据库中的数据是另一种类型并且含有一个不能被解释为<type>date</type>的值（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-210 (<symbol>ECPG_TIMESTAMP_FORMAT</symbol>)</term>
     <listitem>
      <para>
       主变量是类型<type>timestamp</type>而数据库中的数据是另一种类型并且含有一个不能被解释为<type>timestamp</type>的值（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-211 (<symbol>ECPG_CONVERT_BOOL</symbol>)</term>
     <listitem>
      <para>
       这表示主变量是类型<type>bool</type>而数据库中的数据既不是<literal>'t'</literal>也不是<literal>'f'</literal>（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-212 (<symbol>ECPG_EMPTY</symbol>)</term>
     <listitem>
      <para>
       发送给<productname>PostgreSQL</productname>服务器的语句是空的（通常在一个嵌入式 SQL 程序中不会发生，因此它可能指向一个内部错误）（SQLSTATE YE002）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-213 (<symbol>ECPG_MISSING_INDICATOR</symbol>)</term>
     <listitem>
      <para>
       返回了一个空值并且没有提供空值指示符（SQLSTATE 22002）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-214 (<symbol>ECPG_NO_ARRAY</symbol>)</term>
     <listitem>
      <para>
       在要求一个数组的地方使用了一个普通变量（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-215 (<symbol>ECPG_DATA_NOT_ARRAY</symbol>)</term>
     <listitem>
      <para>
       在一个要求数组值的地方数据库返回了一个普通变量（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-216 (<symbol>ECPG_ARRAY_INSERT</symbol>)</term>
     <listitem>
      <para>
       该值不能被插入到数组（SQLSTATE 42804）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-220 (<symbol>ECPG_NO_CONN</symbol>)</term>
     <listitem>
      <para>
       程序尝试访问一个不存在的连接（SQLSTATE 08003）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-221 (<symbol>ECPG_NOT_CONN</symbol>)</term>
     <listitem>
      <para>
       程序尝试访问一个存在的连接但是它没有打开（这是一个内部错误）（SQLSTATE YE002）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-230 (<symbol>ECPG_INVALID_STMT</symbol>)</term>
     <listitem>
      <para>
       你尝试使用的语句还没有被准备好（SQLSTATE 26000）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-239 (<symbol>ECPG_INFORMIX_DUPLICATE_KEY</symbol>)</term>
     <listitem>
      <para>
       重复键错误，违背唯一约束（Informix 兼容模式）（SQLSTATE 23505）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-240 (<symbol>ECPG_UNKNOWN_DESCRIPTOR</symbol>)</term>
     <listitem>
      <para>
       没有找到指定的描述符。你尝试使用的语句还没有被准备好（SQLSTATE 33000）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-241 (<symbol>ECPG_INVALID_DESCRIPTOR_INDEX</symbol>)</term>
     <listitem>
      <para>
       指定的描述符超出范围（SQLSTATE 07009）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-242 (<symbol>ECPG_UNKNOWN_DESCRIPTOR_ITEM</symbol>)</term>
     <listitem>
      <para>
       请求了一个非法的描述符（这是一个内部错误）（SQLSTATE YE002）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-243 (<symbol>ECPG_VAR_NOT_NUMERIC</symbol>)</term>
     <listitem>
      <para>
       在执行一个动态语句期间，数据库返回了一个numeric值而主变量不是numeric的（SQLSTATE 07006）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-244 (<symbol>ECPG_VAR_NOT_CHAR</symbol>)</term>
     <listitem>
      <para>
       在执行一个动态语句期间，数据库返回了一个非numeric值而主变量是numeric的（SQLSTATE 07006）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-284 (<symbol>ECPG_INFORMIX_SUBSELECT_NOT_ONE</symbol>)</term>
     <listitem>
      <para>
       子查询的结果不是单一行（Informix 兼容模式）（SQLSTATE 21000）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-400 (<symbol>ECPG_PGSQL</symbol>)</term>
     <listitem>
      <para>
       <productname>PostgreSQL</productname>服务器导致了某个错误。该消息包含来自<productname>PostgreSQL</productname>服务器的错误消息。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-401 (<symbol>ECPG_TRANS</symbol>)</term>
     <listitem>
      <para>
       <productname>PostgreSQL</productname>服务器通知我们不能启动、提交或回滚事务（SQLSTATE 08007）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-402 (<symbol>ECPG_CONNECT</symbol>)</term>
     <listitem>
      <para>
       到数据库的连接尝试没有成功（SQLSTATE 08001）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-403 (<symbol>ECPG_DUPLICATE_KEY</symbol>)</term>
     <listitem>
      <para>
       重复键错误，违背唯一约束（SQLSTATE 23505）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-404 (<symbol>ECPG_SUBSELECT_NOT_ONE</symbol>)</term>
     <listitem>
      <para>
       子查询的结果不是单一行（SQLSTATE 21000）。
      </para>
     </listitem>
    </varlistentry>

    <!-- currently not used by the code -->
<!--
    <varlistentry>
     <term>-600 (<symbol>ECPG_WARNING_UNRECOGNIZED</symbol>)</term>
     <listitem>
      <para>
       从服务器接收到一个无法识别的警告。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-601 (<symbol>ECPG_WARNING_QUERY_IGNORED</symbol>)</term>
     <listitem>
      <para>
       当前事务被中止。到事务块末尾的查询被忽略。
      </para>
     </listitem>
    </varlistentry>
-->

    <varlistentry>
     <term>-602 (<symbol>ECPG_WARNING_UNKNOWN_PORTAL</symbol>)</term>
     <listitem>
      <para>
       指定了一个非法的游标名（SQLSTATE 34000）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-603 (<symbol>ECPG_WARNING_IN_TRANSACTION</symbol>)</term>
     <listitem>
      <para>
       事务正在进行（SQLSTATE 25001）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-604 (<symbol>ECPG_WARNING_NO_TRANSACTION</symbol>)</term>
     <listitem>
      <para>
       没有活动（正在进行）的事务（SQLSTATE 25P01）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term>-605 (<symbol>ECPG_WARNING_PORTAL_EXISTS</symbol>)</term>
     <listitem>
      <para>
       指定了一个现有的游标名（SQLSTATE 42P03）。
      </para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=9f17c25178913a78de5789f701159de8 -->
  </sect2>
 </sect1>

 <sect1 id="ecpg-preproc">
<!-- pgdoc-cn_start sig_en=b8b3491cca72778ce81db799d7b220a5 sig_cn_org=None source=14.1 
  <title>Preprocessor Directives</title>
________________________________________________________-->
  <title>预处理器指令</title>
<!-- pgdoc-cn_end sig_en=b8b3491cca72778ce81db799d7b220a5 -->

<!-- pgdoc-cn_start sig_en=45d8c8625b80f251c98f13a18027693c sig_cn_org=None source=14.1 
  <para>
   Several preprocessor directives are available that modify how
   the <command>ecpg</command> preprocessor parses and processes a
   file.
  </para>
________________________________________________________-->
  <para>
   一些预处理器指令可以用来改变<command>ecpg</command>预处理器解析和处理一个文件的方式。
  </para>
<!-- pgdoc-cn_end sig_en=45d8c8625b80f251c98f13a18027693c -->

  <sect2 id="ecpg-include">
<!-- pgdoc-cn_start sig_en=7e5eaa5a7c43169f6a57653e74453239 sig_cn_org=None source=14.1 
   <title>Including Files</title>
________________________________________________________-->
   <title>包括文件</title>
<!-- pgdoc-cn_end sig_en=7e5eaa5a7c43169f6a57653e74453239 -->

<!-- pgdoc-cn_start sig_en=1f8ee3407827c575c35758b25a65266e sig_cn_org=None source=14.1 
   <para>
    To include an external file into your embedded SQL program, use:
<programlisting>
EXEC SQL INCLUDE <replaceable>filename</replaceable>;
EXEC SQL INCLUDE &lt;<replaceable>filename</replaceable>&gt;;
EXEC SQL INCLUDE "<replaceable>filename</replaceable>";
</programlisting>
    The embedded SQL preprocessor will look for a file named
    <literal><replaceable>filename</replaceable>.h</literal>,
    preprocess it, and include it in the resulting C output.  Thus,
    embedded SQL statements in the included file are handled correctly.
   </para>
________________________________________________________-->
   <para>
    要包括一个外部文件到你的嵌入式 SQL 程序中，可以用：
<programlisting>
EXEC SQL INCLUDE <replaceable>filename</replaceable>;
EXEC SQL INCLUDE &lt;<replaceable>filename</replaceable>&gt;;
EXEC SQL INCLUDE "<replaceable>filename</replaceable>";
</programlisting>
    嵌入式 SQL 预处理器将查找一个名为<literal><replaceable>filename</replaceable>.h</literal>的文件，处理它并且把它包括在结果 C 输出中。这样，被包括文件中的嵌入式 SQL 语句会被正确地处理。
   </para>
<!-- pgdoc-cn_end sig_en=1f8ee3407827c575c35758b25a65266e -->

<!-- pgdoc-cn_start sig_en=197821a4cb5b8b6161c5462520924814 sig_cn_org=None source=14.1 
   <para>
    The <command>ecpg</command> preprocessor will search a file at
    several directories in following order:

    <itemizedlist>
     <listitem><simpara>current directory</simpara></listitem>
     <listitem><simpara><filename>/usr/local/include</filename></simpara></listitem>
     <listitem><simpara>PostgreSQL include directory, defined at build time (e.g., <filename>/usr/local/pgsql/include</filename>)</simpara></listitem>
     <listitem><simpara><filename>/usr/include</filename></simpara></listitem>
    </itemizedlist>

    But when <literal>EXEC SQL INCLUDE
    "<replaceable>filename</replaceable>"</literal> is used, only the
    current directory is searched.
   </para>
________________________________________________________-->
   <para>
    <command>ecpg</command>预处理器将以下列顺序在几个目录中搜索一个文件：

    <itemizedlist>
     <listitem><simpara>当前目录</simpara></listitem>
     <listitem><simpara><filename>/usr/local/include</filename></simpara></listitem>
     <listitem><simpara>PostgreSQL 的包括目录，在编译时定义（例如<filename>/usr/local/pgsql/include</filename>）</simpara></listitem>
     <listitem><simpara><filename>/usr/include</filename></simpara></listitem>
    </itemizedlist>

    但是当使用<literal>EXEC SQL INCLUDE "<replaceable>filename</replaceable>"</literal>时，只有当前目录会被搜索。
   </para>
<!-- pgdoc-cn_end sig_en=197821a4cb5b8b6161c5462520924814 -->

<!-- pgdoc-cn_start sig_en=87271b2f8bfafbc7b8a476f5f09caf8e sig_cn_org=None source=14.1 
   <para>
    In each directory, the preprocessor will first look for the file
    name as given, and if not found will append <literal>.h</literal>
    to the file name and try again (unless the specified file name
    already has that suffix).
   </para>
________________________________________________________-->
   <para>
    在每一个目录中，预处理器将首先按给定的文件名搜索，如果没有找到将会追加<literal>.h</literal>到文件名并且重试（除非指定的文件名已经具有该后缀）。
   </para>
<!-- pgdoc-cn_end sig_en=87271b2f8bfafbc7b8a476f5f09caf8e -->

<!-- pgdoc-cn_start sig_en=d183026efc51d625be44a1650acc12bd sig_cn_org=None source=14.1 
   <para>
    Note that <command>EXEC SQL INCLUDE</command> is <emphasis>not</emphasis> the same as:
<programlisting>
#include &lt;<replaceable>filename</replaceable>.h&gt;
</programlisting>
    because this file would not be subject to SQL command preprocessing.
    Naturally, you can continue to use the C
    <literal>#include</literal> directive to include other header
    files.
   </para>
________________________________________________________-->
   <para>
    注意<command>EXEC SQL INCLUDE</command><emphasis>不</emphasis>同于：
<programlisting>
#include &lt;<replaceable>filename</replaceable>.h&gt;
</programlisting>
    因为这个文件不服从 SQL 命令预处理。自然地，你可以继续使用 C 的<literal>#include</literal>指令来包括其他头文件。
   </para>
<!-- pgdoc-cn_end sig_en=d183026efc51d625be44a1650acc12bd -->

   <note>
<!-- pgdoc-cn_start sig_en=88fd0f0c9d25a5291d5fc44968fd2837 sig_cn_org=None source=14.1 
    <para>
     The include file name is case-sensitive, even though the rest of
     the <literal>EXEC SQL INCLUDE</literal> command follows the normal
     SQL case-sensitivity rules.
    </para>
________________________________________________________-->
    <para>
     包括文件名是大小写敏感的，即使<literal>EXEC SQL INCLUDE</literal>命令的剩余部分遵守通常的 SQL 大小写敏感规则。
    </para>
<!-- pgdoc-cn_end sig_en=88fd0f0c9d25a5291d5fc44968fd2837 -->
   </note>
  </sect2>

  <sect2 id="ecpg-define">
<!-- pgdoc-cn_start sig_en=1745b4b0cfe5f33a2c1c75b6c71ad494 sig_cn_org=None source=14.1 
   <title>The define and undef Directives</title>
________________________________________________________-->
   <title>define 和 undef 指令</title>
<!-- pgdoc-cn_end sig_en=1745b4b0cfe5f33a2c1c75b6c71ad494 -->
<!-- pgdoc-cn_start sig_en=dab132c111893cde836bb3a6cf7eebe9 sig_cn_org=None source=14.1 
   <para>
    Similar to the directive <literal>#define</literal> that is known from C,
    embedded SQL has a similar concept:
<programlisting>
EXEC SQL DEFINE <replaceable>name</replaceable>;
EXEC SQL DEFINE <replaceable>name</replaceable> <replaceable>value</replaceable>;
</programlisting>
    So you can define a name:
<programlisting>
EXEC SQL DEFINE HAVE_FEATURE;
</programlisting>
    And you can also define constants:
<programlisting>
EXEC SQL DEFINE MYNUMBER 12;
EXEC SQL DEFINE MYSTRING 'abc';
</programlisting>
    Use <literal>undef</literal> to remove a previous definition:
<programlisting>
EXEC SQL UNDEF MYNUMBER;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    与 C 中我们熟知的指令<literal>#define</literal>相似，嵌入式 SQL 具有类似的概念：
<programlisting>
EXEC SQL DEFINE <replaceable>name</replaceable>;
EXEC SQL DEFINE <replaceable>name</replaceable> <replaceable>value</replaceable>;
</programlisting>
    因此你可以定义一个名称：
<programlisting>
EXEC SQL DEFINE HAVE_FEATURE;
</programlisting>
    并且你也可以定义常量：
<programlisting>
EXEC SQL DEFINE MYNUMBER 12;
EXEC SQL DEFINE MYSTRING 'abc';
</programlisting>
    使用<literal>undef</literal>来移除一个之前的定义：
<programlisting>
EXEC SQL UNDEF MYNUMBER;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=dab132c111893cde836bb3a6cf7eebe9 -->

<!-- pgdoc-cn_start sig_en=d8bb1bf5bee87fb48dffae4f34d0fdbb sig_cn_org=None source=14.1 
   <para>
    Of course you can continue to use the C versions <literal>#define</literal>
    and <literal>#undef</literal> in your embedded SQL program. The difference
    is where your defined values get evaluated. If you use <literal>EXEC SQL
    DEFINE</literal> then the <command>ecpg</command> preprocessor evaluates the defines and substitutes
    the values. For example if you write:
<programlisting>
EXEC SQL DEFINE MYNUMBER 12;
...
EXEC SQL UPDATE Tbl SET col = MYNUMBER;
</programlisting>
    then <command>ecpg</command> will already do the substitution and your C compiler will never
    see any name or identifier <literal>MYNUMBER</literal>. Note that you cannot use
    <literal>#define</literal> for a constant that you are going to use in an
    embedded SQL query because in this case the embedded SQL precompiler is not
    able to see this declaration.
   </para>
________________________________________________________-->
   <para>
    当然在你的嵌入式 SQL 程序中你可以继续使用 C 版本的<literal>#define</literal>和<literal>#undef</literal>。区别在于你定义的值会在哪里被计算。如果你使用<literal>EXEC SQL DEFINE</literal>，那么<command>ecpg</command>预处理器会计算这些定义并且替换值。例如，如果你写：
<programlisting>
EXEC SQL DEFINE MYNUMBER 12;
...
EXEC SQL UPDATE Tbl SET col = MYNUMBER;
</programlisting>
    那么<command>ecpg</command>将已经做过替换并且你的 C 编译器将永远不会看见名为<literal>MYNUMBER</literal>的任何名称或标识符。注意你不能把<literal>#define</literal>用于一个将要在一个嵌入式 SQL 查询中使用的常量，因为在这种情况下嵌入式 SQL 预编译器不能看到这个声明。
   </para>
<!-- pgdoc-cn_end sig_en=d8bb1bf5bee87fb48dffae4f34d0fdbb -->

<!-- pgdoc-cn_start sig_en=ebf8f05546c9aaa130993af86b6eb7c4 sig_cn_org=35cc54b4fd11d40ccfd6f09854a0a8bb source=15.7 
   <para>
    If multiple input files are named on the <command>ecpg</command>
    preprocessor's command line, the effects of <literal>EXEC SQL
    DEFINE</literal> and <literal>EXEC SQL UNDEF</literal> do not carry
    across files: each file starts with only the symbols defined
    by <option>-D</option> switches on the command line.
   </para>
________________________________________________________-->
   <para>
    如果在<command>ecpg</command>预处理器的命令行上命名了多个输入文件，
    那么<literal>EXEC SQL DEFINE</literal>和<literal>EXEC SQL UNDEF</literal>的效果不会跨文件传递：
    每个文件都只使用命令行上<option>-D</option>开关定义的符号。
</para>
<!-- pgdoc-cn_end sig_en=ebf8f05546c9aaa130993af86b6eb7c4 -->
  </sect2>

  <sect2 id="ecpg-ifdef">
<!-- pgdoc-cn_start sig_en=349be21af29f39239d490008e81613cc sig_cn_org=None source=14.1 
   <title>ifdef, ifndef, elif, else, and endif Directives</title>
________________________________________________________-->
   <title>ifdef, ifndef, elif, else, 和 endif 指令</title>
<!-- pgdoc-cn_end sig_en=349be21af29f39239d490008e81613cc -->
<!-- pgdoc-cn_start sig_en=b34e56d9af28fac3da1b718f2cd7c3f7 sig_cn_org=None source=14.1 
   <para>
   You can use the following directives to compile code sections conditionally:

   <variablelist>
    <varlistentry>
     <term><literal>EXEC SQL ifdef <replaceable>name</replaceable>;</literal></term>
     <listitem>
     <para>
      Checks a <replaceable>name</replaceable> and processes subsequent lines if
      <replaceable>name</replaceable> has been defined via <literal>EXEC SQL define
      <replaceable>name</replaceable></literal>.
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL ifndef <replaceable>name</replaceable>;</literal></term>
     <listitem>
     <para>
      Checks a <replaceable>name</replaceable> and processes subsequent lines if
      <replaceable>name</replaceable> has <emphasis>not</emphasis> been defined via
      <literal>EXEC SQL define <replaceable>name</replaceable></literal>.
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL elif <replaceable>name</replaceable>;</literal></term>
     <listitem>
     <para>
      Begins an optional alternative section after an
      <literal>EXEC SQL ifdef <replaceable>name</replaceable></literal> or
      <literal>EXEC SQL ifndef <replaceable>name</replaceable></literal>
      directive.  Any number of <literal>elif</literal> sections can appear.
      Lines following an <literal>elif</literal> will be processed
      if <replaceable>name</replaceable> has been
      defined <emphasis>and</emphasis> no previous section of the same
      <literal>ifdef</literal>/<literal>ifndef</literal>...<literal>endif</literal>
      construct has been processed.
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL else;</literal></term>
     <listitem>
     <para>
      Begins an optional, final alternative section after an
      <literal>EXEC SQL ifdef <replaceable>name</replaceable></literal> or
      <literal>EXEC SQL ifndef <replaceable>name</replaceable></literal>
      directive.  Subsequent lines will be processed if no previous section
      of the same
      <literal>ifdef</literal>/<literal>ifndef</literal>...<literal>endif</literal>
      construct has been processed.
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL endif;</literal></term>
     <listitem>
     <para>
      Ends an
      <literal>ifdef</literal>/<literal>ifndef</literal>...<literal>endif</literal>
      construct.  Subsequent lines are processed normally.
     </para>
     </listitem>
    </varlistentry>
   </variablelist>
   </para>
________________________________________________________-->
   <para>
   你可以使用下列指定来有条件地编译代码小节：

   <variablelist>
    <varlistentry>
     <term><literal>EXEC SQL ifdef <replaceable>name</replaceable>;</literal></term>
     <listitem>
     <para>
      检查一个<replaceable>name</replaceable>，如果已经用<literal>EXEC SQL define <replaceable>name</replaceable></literal>定义了<replaceable>name</replaceable>就处理接下来的行。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL ifndef <replaceable>name</replaceable>;</literal></term>
     <listitem>
     <para>
      检查一个<replaceable>name</replaceable>，如果<emphasis>没有</emphasis>用<literal>EXEC SQL define <replaceable>name</replaceable></literal>定义<replaceable>name</replaceable>就处理接下来的行。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL elif <replaceable>name</replaceable>;</literal></term>
     <listitem>
     <para>
      在<literal>EXEC SQL ifdef <replaceable>name</replaceable></literal>或者<literal>EXEC SQL ifndef <replaceable>name</replaceable></literal>命令之后开始一个可选的备选小节。
      可以出现任意数量的<literal>elif</literal>小节。
      跟在<literal>elif</literal>后面的行将被处理，如果<replaceable>name</replaceable> 已经被定义<emphasis>并且</emphasis>
      在相同的<literal>ifdef</literal>/<literal>ifndef</literal>...<literal>endif</literal>结构中前面的小节没有被处理。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL else;</literal></term>
     <listitem>
     <para>
      开始一个可选的, 最终可以替代的小节在 <literal>EXEC SQL ifdef <replaceable>name</replaceable></literal> 或 <literal>EXEC SQL ifndef <replaceable>name</replaceable></literal>命令之后。
      后续的行将被处理，如果在相同的<literal>ifdef</literal>/<literal>ifndef</literal>...<literal>endif</literal>结构中没有前面的小节已经被处理。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>EXEC SQL endif;</literal></term>
     <listitem>
     <para>
      结束一个<literal>ifdef</literal>/<literal>ifndef</literal>...<literal>endif</literal>结构。后续的行正常处理。
     </para>
     </listitem>
    </varlistentry>
   </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=b34e56d9af28fac3da1b718f2cd7c3f7 -->

<!-- pgdoc-cn_start sig_en=bee1bc63caf5a7448e62a904bdee57a8 sig_cn_org=None source=14.1 
   <para>
    <literal>ifdef</literal>/<literal>ifndef</literal>...<literal>endif</literal>
    constructs can be nested, up to 127 levels deep.
   </para>
________________________________________________________-->
   <para>
    <literal>ifdef</literal>/<literal>ifndef</literal>...<literal>endif</literal>
    结构可以被嵌套, 可达127层深.
   </para>
<!-- pgdoc-cn_end sig_en=bee1bc63caf5a7448e62a904bdee57a8 -->

<!-- pgdoc-cn_start sig_en=50a973430ce5543dea84a16dda1d71cd sig_cn_org=None source=14.1 
   <para>
    This example will compile exactly one of the three <literal>SET
    TIMEZONE</literal> commands:
<programlisting>
EXEC SQL ifdef TZVAR;
EXEC SQL SET TIMEZONE TO TZVAR;
EXEC SQL elif TZNAME;
EXEC SQL SET TIMEZONE TO TZNAME;
EXEC SQL else;
EXEC SQL SET TIMEZONE TO 'GMT';
EXEC SQL endif;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    此示例将完全编译三个<literal>SET TIMEZONE</literal>命令之一:
<programlisting>
EXEC SQL ifdef TZVAR;
EXEC SQL SET TIMEZONE TO TZVAR;
EXEC SQL elif TZNAME;
EXEC SQL SET TIMEZONE TO TZNAME;
EXEC SQL else;
EXEC SQL SET TIMEZONE TO 'GMT';
EXEC SQL endif;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=50a973430ce5543dea84a16dda1d71cd -->

  </sect2>
 </sect1>

  <sect1 id="ecpg-process">
<!-- pgdoc-cn_start sig_en=6b0d9cd487e9a11959d5d7b3121cd7f6 sig_cn_org=None source=14.1 
  <title>Processing Embedded SQL Programs</title>
________________________________________________________-->
  <title>处理嵌入式 SQL 程序</title>
<!-- pgdoc-cn_end sig_en=6b0d9cd487e9a11959d5d7b3121cd7f6 -->

<!-- pgdoc-cn_start sig_en=407d9d5173b5ce187cd2823da81edcce sig_cn_org=None source=14.1 
  <para>
   Now that you have an idea how to form embedded SQL C programs, you
   probably want to know how to compile them.  Before compiling you
   run the file through the embedded <acronym>SQL</acronym>
   <acronym>C</acronym> preprocessor, which converts the
   <acronym>SQL</acronym> statements you used to special function
   calls.  After compiling, you must link with a special library that
   contains the needed functions. These functions fetch information
   from the arguments, perform the <acronym>SQL</acronym> command using
   the <application>libpq</application> interface, and put the result
   in the arguments specified for output.
  </para>
________________________________________________________-->
  <para>
   现在你已经对如何构造嵌入式 SQL C 程序有所了解了，你可能希望知道如何编译它们。在编译之前，你需要让该文件通过嵌入式<acronym>SQL</acronym> <acronym>C</acronym>预处理器，它会把你用到的<acronym>SQL</acronym>转换成特殊的函数调用。在编译之后，你必须链接一个包含所需函数的特殊库。这些函数从参数中取得信息、使用<application>libpq</application>执行<acronym>SQL</acronym>命令并且把结果放在指定的参数中用来输出。
  </para>
<!-- pgdoc-cn_end sig_en=407d9d5173b5ce187cd2823da81edcce -->

<!-- pgdoc-cn_start sig_en=fa03abc25ba9960296a71212a5fef15a sig_cn_org=None source=14.1 
  <para>
   The preprocessor program is called <filename>ecpg</filename> and is
   included in a normal <productname>PostgreSQL</productname> installation.
   Embedded SQL programs are typically named with an extension
   <filename>.pgc</filename>.  If you have a program file called
   <filename>prog1.pgc</filename>, you can preprocess it by simply
   calling:
<programlisting>
ecpg prog1.pgc
</programlisting>
   This will create a file called <filename>prog1.c</filename>.  If
   your input files do not follow the suggested naming pattern, you
   can specify the output file explicitly using the
   <option>-o</option> option.
  </para>
________________________________________________________-->
  <para>
   该预处理器程序被称作<filename>ecpg</filename>并且被包括在一个正常的<productname>PostgreSQL</productname>安装中。嵌入式 SQL 程序通常带有扩展名<filename>.pgc</filename>。如果你有一个程序文件<filename>prog1.pgc</filename>，你可以调用下面的命令对它进行预处理：
<programlisting>
ecpg prog1.pgc
</programlisting>
   这将创建一个文件<filename>prog1.c</filename>。如果你的输入文件不遵循建议的命名模式，你可以用<option>-o</option>选项显式地指定输出文件。
  </para>
<!-- pgdoc-cn_end sig_en=fa03abc25ba9960296a71212a5fef15a -->

<!-- pgdoc-cn_start sig_en=bdd61f5887a473c16c7c5497181c9ea1 sig_cn_org=None source=14.1 
  <para>
   The preprocessed file can be compiled normally, for example:
<programlisting>
cc -c prog1.c
</programlisting>
   The generated C source files include header files from the
   <productname>PostgreSQL</productname> installation, so if you installed
   <productname>PostgreSQL</productname> in a location that is not searched by
   default, you have to add an option such as
   <literal>-I/usr/local/pgsql/include</literal> to the compilation
   command line.
  </para>
________________________________________________________-->
  <para>
   预处理过的文件可以被正常地编译，例如：
<programlisting>
cc -c prog1.c
</programlisting>
   产生的 C 源文件从<productname>PostgreSQL</productname>安装中包括头文件，因此如果你把<productname>PostgreSQL</productname>安装在一个不被默认搜索的位置，你必须在编译命令行中增加一个选项（例如<literal>-I/usr/local/pgsql/include</literal>）。
  </para>
<!-- pgdoc-cn_end sig_en=bdd61f5887a473c16c7c5497181c9ea1 -->

<!-- pgdoc-cn_start sig_en=44588dd21974b23c8a878d002af9ad16 sig_cn_org=None source=14.1 
  <para>
   To link an embedded SQL program, you need to include the
   <filename>libecpg</filename> library, like so:
<programlisting>
cc -o myprog prog1.o prog2.o ... -lecpg
</programlisting>
   Again, you might have to add an option like
   <literal>-L/usr/local/pgsql/lib</literal> to that command line.
  </para>
________________________________________________________-->
  <para>
   要链接一个嵌入式 SQL 程序，你需要包括<filename>libecpg</filename>库，像这样：
<programlisting>
cc -o myprog prog1.o prog2.o ... -lecpg
</programlisting>
   再次，你可能不得不在命令行中增加类似<literal>-L/usr/local/pgsql/lib</literal>的选项。
  </para>
<!-- pgdoc-cn_end sig_en=44588dd21974b23c8a878d002af9ad16 -->

<!-- pgdoc-cn_start sig_en=03bc80fad974c2b8470e9fcafe5a4586 sig_cn_org=None source=14.1 
  <para>
   You can
   use <command>pg_config</command><indexterm><primary>pg_config</primary><secondary sortas="ecpg">with
   ecpg</secondary></indexterm>
   or <command>pkg-config</command><indexterm><primary>pkg-config</primary><secondary sortas="ecpg">with
   ecpg</secondary></indexterm> with package name <literal>libecpg</literal> to
   get the paths for your installation.
  </para>
________________________________________________________-->
  <para>
   你可以使用<command>pg_config</command><indexterm><primary>pg_config</primary><secondary sortas="ecpg">with
   ecpg</secondary></indexterm>
   或者<command>pkg-config</command><indexterm><primary>pkg-config</primary><secondary sortas="ecpg">with
   ecpg</secondary></indexterm> 加上包名<literal>libecpg</literal>来得到你的安装路径。
  </para>
<!-- pgdoc-cn_end sig_en=03bc80fad974c2b8470e9fcafe5a4586 -->

<!-- pgdoc-cn_start sig_en=170ca888c6bc77399548e1afdb160222 sig_cn_org=None source=14.1 
  <para>
   If you manage the build process of a larger project using
   <application>make</application>, it might be convenient to include
   the following implicit rule to your makefiles:
<programlisting>
ECPG = ecpg

%.c: %.pgc
        $(ECPG) $&lt;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   如果你使用<application>make</application>来管理一个大工程的构建过程，把下面的隐式规则包括在你的 makefile 中将会很方便：
<programlisting>
ECPG = ecpg

%.c: %.pgc
        $(ECPG) $&lt;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=170ca888c6bc77399548e1afdb160222 -->

<!-- pgdoc-cn_start sig_en=d8ca91f29f22f77c047082e852696e78 sig_cn_org=None source=14.1 
  <para>
   The complete syntax of the <command>ecpg</command> command is
   detailed in <xref linkend="app-ecpg"/>.
  </para>
________________________________________________________-->
  <para>
   <command>ecpg</command>命令的完整语法可见<xref linkend="app-ecpg"/>。
  </para>
<!-- pgdoc-cn_end sig_en=d8ca91f29f22f77c047082e852696e78 -->

<!-- pgdoc-cn_start sig_en=dbcc291d38b0c8d663d17d3cbd9d081b sig_cn_org=None source=14.1 
  <para>
   The <application>ecpg</application> library is thread-safe by
   default.  However, you might need to use some threading
   command-line options to compile your client code.
  </para>
________________________________________________________-->
  <para>
   <application>ecpg</application>库默认是线程安全的。不过，你可能需要使用一些线程命令行选项来编译你的客户端代码。
  </para>
<!-- pgdoc-cn_end sig_en=dbcc291d38b0c8d663d17d3cbd9d081b -->
 </sect1>

 <sect1 id="ecpg-library">
<!-- pgdoc-cn_start sig_en=00adb1bfe5a187160ccfa3e46771fadb sig_cn_org=None source=14.1 
  <title>Library Functions</title>
________________________________________________________-->
  <title>库函数</title>
<!-- pgdoc-cn_end sig_en=00adb1bfe5a187160ccfa3e46771fadb -->

<!-- pgdoc-cn_start sig_en=6981c8c02796f88f6163c3ea85d93c79 sig_cn_org=None source=14.1 
  <para>
   The <filename>libecpg</filename> library primarily contains
   <quote>hidden</quote> functions that are used to implement the
   functionality expressed by the embedded SQL commands.  But there
   are some functions that can usefully be called directly.  Note that
   this makes your code unportable.
  </para>
________________________________________________________-->
  <para>
   <filename>libecpg</filename>库主要包含用于实现嵌入式 SQL 命令所表达功能的<quote>隐藏</quote>函数。但是也有一些可以被直接调用的函数。但是注意这会让你的代码不可移植。
  </para>
<!-- pgdoc-cn_end sig_en=6981c8c02796f88f6163c3ea85d93c79 -->

  <itemizedlist>
   <listitem>
<!-- pgdoc-cn_start sig_en=cff38c1f0d7d1511f6d9b6ea1f6098b1 sig_cn_org=None source=14.1 
    <para>
     <function>ECPGdebug(int <replaceable>on</replaceable>, FILE
     *<replaceable>stream</replaceable>)</function> turns on debug
     logging if called with the first argument non-zero. Debug logging
     is done on <replaceable>stream</replaceable>.  The log contains
     all <acronym>SQL</acronym> statements with all the input
     variables inserted, and the results from the
     <productname>PostgreSQL</productname> server. This can be very
     useful when searching for errors in your <acronym>SQL</acronym>
     statements.
    </para>
________________________________________________________-->
    <para>
     如果调用时第一个参数非零，<function>ECPGdebug(int <replaceable>on</replaceable>, FILE *<replaceable>stream</replaceable>)</function>会打开调试日志。调试日志在<replaceable>流</replaceable>上完成。该日志包含所有插入了输入变量的<acronym>SQL</acronym>语句，以及来自于<productname>PostgreSQL</productname>服务器的结果。在你的<acronym>SQL</acronym>语句中查找错误时这会非常有用。
    </para>
<!-- pgdoc-cn_end sig_en=cff38c1f0d7d1511f6d9b6ea1f6098b1 -->
    <note>
<!-- pgdoc-cn_start sig_en=174ba373d0c14822ec5a46f6ada7f298 sig_cn_org=None source=14.1 
    <para>
    On Windows, if the <application>ecpg</application> libraries and an application are
    compiled with different flags, this function call will crash the
    application because the internal representation of the
    <literal>FILE</literal> pointers differ.  Specifically,
    multithreaded/single-threaded, release/debug, and static/dynamic
    flags should be the same for the library and all applications using
    that library.
    </para>
________________________________________________________-->
    <para>
    在 Windows 上，如果<application>ecpg</application>库和应用使用不同标志编译的，这个函数调用将会是应用崩溃，因为<literal>FILE</literal>指针的内部表达不同。特别地，库和使用库的应用应该使用相同的多线程/单线程、发行/调试以及静态/动态标志。
    </para>
<!-- pgdoc-cn_end sig_en=174ba373d0c14822ec5a46f6ada7f298 -->
    </note>
   </listitem>

   <listitem>
<!-- pgdoc-cn_start sig_en=84ed4b21a287da2c7912e7a392a5ef6d sig_cn_org=None source=14.1 
     <para>
       <function>ECPGget_PGconn(const char *<replaceable>connection_name</replaceable>)
       </function> returns the library database connection handle identified by the given name.
       If <replaceable>connection_name</replaceable> is set to <literal>NULL</literal>, the current
       connection handle is returned. If no connection handle can be identified, the function returns
       <literal>NULL</literal>. The returned connection handle can be used to call any other functions
       from <application>libpq</application>, if necessary.
     </para>
________________________________________________________-->
     <para>
       <function>ECPGget_PGconn(const char *<replaceable>connection_name</replaceable>)
       </function>返回由给定名称标识的库数据库连接句柄。如果<replaceable>connection_name</replaceable>被设置为<literal>NULL</literal>，当前连接句柄将被返回。如果无法定位到连接句柄，该函数返回<literal>NULL</literal>。如果需要，返回的连接句柄可以被用来调用任何其他来自于<application>libpq</application>的函数。
     </para>
<!-- pgdoc-cn_end sig_en=84ed4b21a287da2c7912e7a392a5ef6d -->
     <note>
<!-- pgdoc-cn_start sig_en=f5ec158a9f77cbaf275ee345ad60725b sig_cn_org=None source=14.1 
     <para>
       It is a bad idea to manipulate database connection handles made from <application>ecpg</application> directly
       with <application>libpq</application> routines.
     </para>
________________________________________________________-->
     <para>
       直接使用<application>libpq</application>例程来操纵<application>ecpg</application>中建立的数据库连接句柄是一种糟糕的做法。
     </para>
<!-- pgdoc-cn_end sig_en=f5ec158a9f77cbaf275ee345ad60725b -->
     </note>
   </listitem>

   <listitem>
<!-- pgdoc-cn_start sig_en=497bd2fbe9f9e3ce01ec1f981125fe56 sig_cn_org=None source=14.1 
     <para>
       <function>ECPGtransactionStatus(const char *<replaceable>connection_name</replaceable>)</function>
       returns the current transaction status of the given connection identified by <replaceable>connection_name</replaceable>.
       See <xref linkend="libpq-status"/> and libpq's <xref linkend="libpq-PQtransactionStatus"/> for details about the returned status codes.
     </para>
________________________________________________________-->
     <para>
       <function>ECPGtransactionStatus(const char *<replaceable>connection_name</replaceable>)</function>返回由<replaceable>connection_name</replaceable>标识的给定连接的当前事务状态。
       关于返回的状态代码请参考<xref linkend="libpq-status"/> 和 libpq的 <xref linkend="libpq-PQtransactionStatus"/>。
     </para>
<!-- pgdoc-cn_end sig_en=497bd2fbe9f9e3ce01ec1f981125fe56 -->
   </listitem>

   <listitem>
<!-- pgdoc-cn_start sig_en=8804ef07ebe7d6979205ac823f82414e sig_cn_org=None source=14.1 
    <para>
     <function>ECPGstatus(int <replaceable>lineno</replaceable>,
     const char* <replaceable>connection_name</replaceable>)</function>
     returns true if you are connected to a database and false if not.
     <replaceable>connection_name</replaceable> can be <literal>NULL</literal>
     if a single connection is being used.
    </para>
________________________________________________________-->
    <para>
     如果你连接到了一个数据库，<function>ECPGstatus(int <replaceable>lineno</replaceable>,
     const char* <replaceable>connection_name</replaceable>)</function>会返回真；否则返回假。
     如果使用的是一个单一连接，<replaceable>connection_name</replaceable>可以为<literal>NULL</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=8804ef07ebe7d6979205ac823f82414e -->
   </listitem>
  </itemizedlist>
 </sect1>

 <sect1 id="ecpg-lo">
<!-- pgdoc-cn_start sig_en=3c3d036ff793bd528a168222f712355b sig_cn_org=None source=14.1 
  <title>Large Objects</title>
________________________________________________________-->
  <title>大对象</title>
<!-- pgdoc-cn_end sig_en=3c3d036ff793bd528a168222f712355b -->

<!-- pgdoc-cn_start sig_en=68539ab2b5fc233bf1aad7f2f1cd3c5c sig_cn_org=None source=14.1 
  <para>
   Large objects are not directly supported by ECPG, but ECPG
   application can manipulate large objects through the libpq large
   object functions, obtaining the necessary <type>PGconn</type>
   object by calling the <function>ECPGget_PGconn()</function>
   function.  (However, use of
   the <function>ECPGget_PGconn()</function> function and touching
   <type>PGconn</type> objects directly should be done very carefully
   and ideally not mixed with other ECPG database access calls.)
  </para>
________________________________________________________-->
  <para>
   ECPG 并不直接支持大对象，在调用<function>ECPGget_PGconn()</function>函数获得所需的<type>PGconn</type>对象后，ECPG 应用能通过 libpq 大对象函数操纵大对象（不过，对<function>ECPGget_PGconn()</function>函数的使用以及直接接触<type>PGconn</type>对象都必须非常小心，并且最好不要与其他 ECPG 数据库访问调用混合在一起）。
  </para>
<!-- pgdoc-cn_end sig_en=68539ab2b5fc233bf1aad7f2f1cd3c5c -->

<!-- pgdoc-cn_start sig_en=97bbd05d6d99ec4a1fd71b8c623c4085 sig_cn_org=None source=14.1 
  <para>
   For more details about the <function>ECPGget_PGconn()</function>, see
   <xref linkend="ecpg-library"/>.  For information about the large
   object function interface, see <xref linkend="largeobjects"/>.
  </para>
________________________________________________________-->
  <para>
   更多关于<function>ECPGget_PGconn()</function>的细节可见<xref linkend="ecpg-library"/>。大对象函数接口的相关信息可见<xref linkend="largeobjects"/>。
  </para>
<!-- pgdoc-cn_end sig_en=97bbd05d6d99ec4a1fd71b8c623c4085 -->

<!-- pgdoc-cn_start sig_en=b424eec1b7ae3b62df8113bb9c1949ff sig_cn_org=None source=14.1 
  <para>
   Large object functions have to be called in a transaction block, so
   when autocommit is off, <command>BEGIN</command> commands have to
   be issued explicitly.
  </para>
________________________________________________________-->
  <para>
   大对象函数必须在一个事务块中被调用，因此当自动提交关闭时，必须显式地发出<command>BEGIN</command>命令。
  </para>
<!-- pgdoc-cn_end sig_en=b424eec1b7ae3b62df8113bb9c1949ff -->

<!-- pgdoc-cn_start sig_en=36483cde963f66a5116605ec0d4a3a6e sig_cn_org=None source=14.1 
  <para>
   <xref linkend="ecpg-lo-example"/> shows an example program that
   illustrates how to create, write, and read a large object in an
   ECPG application.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="ecpg-lo-example"/>给出了一个例子程序，它展示了在一个 ECPG 应用中如何创建、写入和读取一个大对象。
  </para>
<!-- pgdoc-cn_end sig_en=36483cde963f66a5116605ec0d4a3a6e -->

  <example id="ecpg-lo-example">
<!-- pgdoc-cn_start sig_en=ea7bdd6f82c295748dabbe93c8529d90 sig_cn_org=None source=14.1 
   <title>ECPG Program Accessing Large Objects</title>
________________________________________________________-->
   <title>访问大对象的 ECPG 程序</title>
<!-- pgdoc-cn_end sig_en=ea7bdd6f82c295748dabbe93c8529d90 -->
<programlisting><![CDATA[
#include <stdio.h>
#include <stdlib.h>
#include <libpq-fe.h>
#include <libpq/libpq-fs.h>

EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
    PGconn     *conn;
    Oid         loid;
    int         fd;
    char        buf[256];
    int         buflen = 256;
    char        buf2[256];
    int         rc;

    memset(buf, 1, buflen);

    EXEC SQL CONNECT TO testdb AS con1;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    conn = ECPGget_PGconn("con1");
    printf("conn = %p\n", conn);

    /* create */
    loid = lo_create(conn, 0);
    if (loid &lt; 0)
        printf("lo_create() failed: %s", PQerrorMessage(conn));

    printf("loid = %d\n", loid);

    /* write test */
    fd = lo_open(conn, loid, INV_READ|INV_WRITE);
    if (fd &lt; 0)
        printf("lo_open() failed: %s", PQerrorMessage(conn));

    printf("fd = %d\n", fd);

    rc = lo_write(conn, fd, buf, buflen);
    if (rc &lt; 0)
        printf("lo_write() failed\n");

    rc = lo_close(conn, fd);
    if (rc &lt; 0)
        printf("lo_close() failed: %s", PQerrorMessage(conn));

    /* read test */
    fd = lo_open(conn, loid, INV_READ);
    if (fd &lt; 0)
        printf("lo_open() failed: %s", PQerrorMessage(conn));

    printf("fd = %d\n", fd);

    rc = lo_read(conn, fd, buf2, buflen);
    if (rc &lt; 0)
        printf("lo_read() failed\n");

    rc = lo_close(conn, fd);
    if (rc &lt; 0)
        printf("lo_close() failed: %s", PQerrorMessage(conn));

    /* check */
    rc = memcmp(buf, buf2, buflen);
    printf("memcmp() = %d\n", rc);

    /* cleanup */
    rc = lo_unlink(conn, loid);
    if (rc &lt; 0)
        printf("lo_unlink() failed: %s", PQerrorMessage(conn));

    EXEC SQL COMMIT;
    EXEC SQL DISCONNECT ALL;
    return 0;
}
]]></programlisting>
  </example>
 </sect1>

 <sect1 id="ecpg-cpp">
<!-- pgdoc-cn_start sig_en=c13fdd746a27218fc8dc28d79a89ed2a sig_cn_org=None source=14.1 
  <title><acronym>C++</acronym> Applications</title>
________________________________________________________-->
  <title><acronym>C++</acronym> 应用</title>
<!-- pgdoc-cn_end sig_en=c13fdd746a27218fc8dc28d79a89ed2a -->

<!-- pgdoc-cn_start sig_en=b97403249754a6e1d78635b83ed9d399 sig_cn_org=None source=14.1 
  <para>
   ECPG has some limited support for C++ applications.  This section
   describes some caveats.
  </para>
________________________________________________________-->
  <para>
   ECPG 对于 C++ 应用提供了有限的支持。这一节描述了一些忠告。
  </para>
<!-- pgdoc-cn_end sig_en=b97403249754a6e1d78635b83ed9d399 -->

<!-- pgdoc-cn_start sig_en=5b9a24be1b8c03f3414bf7bf7b29b7ae sig_cn_org=None source=14.1 
  <para>
   The <command>ecpg</command> preprocessor takes an input file
   written in C (or something like C) and embedded SQL commands,
   converts the embedded SQL commands into C language chunks, and
   finally generates a <filename>.c</filename> file.  The header file
   declarations of the library functions used by the C language chunks
   that <command>ecpg</command> generates are wrapped
   in <literal>extern "C" { ... }</literal> blocks when used under
   C++, so they should work seamlessly in C++.
  </para>
________________________________________________________-->
  <para>
   <command>ecpg</command>预处理器采用一个用 C（或者类似 C 的东西）和嵌入式 SQL 命令编写的输入文件，把嵌入式 SQL 命令转换成 C 语言块，并且最终产生一个<filename>.c</filename>文件。在 C++ 下使用时，因此它们应该能在 C++ 中无缝地使用。
  </para>
<!-- pgdoc-cn_end sig_en=5b9a24be1b8c03f3414bf7bf7b29b7ae -->

<!-- pgdoc-cn_start sig_en=8438ddafe62c92b7ffed07b659c3e37f sig_cn_org=None source=14.1 
  <para>
   In general, however, the <command>ecpg</command> preprocessor only
   understands C; it does not handle the special syntax and reserved
   words of the C++ language.  So, some embedded SQL code written in
   C++ application code that uses complicated features specific to C++
   might fail to be preprocessed correctly or might not work as
   expected.
  </para>
________________________________________________________-->
  <para>
   不过，通常<command>ecpg</command>预处理器只理解 C，它无法处理 C++ 语言的特殊语法和保留词。因此，一些写在 C++ 应用代码中的使用了 C++ 特定复杂特性的嵌入式 SQL 代码可能无法被正确地预处理或者无法按预期工作。
  </para>
<!-- pgdoc-cn_end sig_en=8438ddafe62c92b7ffed07b659c3e37f -->

<!-- pgdoc-cn_start sig_en=5d480091d3c58b27f3871c01d27bba42 sig_cn_org=None source=14.1 
  <para>
   A safe way to use the embedded SQL code in a C++ application is
   hiding the ECPG calls in a C module, which the C++ application code
   calls into to access the database, and linking that together with
   the rest of the C++ code.  See <xref linkend="ecpg-cpp-and-c"/>
   about that.
  </para>
________________________________________________________-->
  <para>
   使用 C++ 应用中嵌入式 SQL 代码的安全方法是把 ECPG 调用隐藏在一个 C 模块中，C++ 应用代码会调用它来访问数据库，还要把它和剩余的 C++ 代码链接起来。详见<xref linkend="ecpg-cpp-and-c"/>。
  </para>
<!-- pgdoc-cn_end sig_en=5d480091d3c58b27f3871c01d27bba42 -->

  <sect2 id="ecpg-cpp-scope">
<!-- pgdoc-cn_start sig_en=2d4a4fe2e5c35ffe9a6162d240ca97ca sig_cn_org=None source=14.1 
   <title>Scope for Host Variables</title>
________________________________________________________-->
   <title>主变量的可见范围</title>
<!-- pgdoc-cn_end sig_en=2d4a4fe2e5c35ffe9a6162d240ca97ca -->

<!-- pgdoc-cn_start sig_en=97618e63c39d3f1ff2948f2762eb54d4 sig_cn_org=None source=14.1 
   <para>
    The <command>ecpg</command> preprocessor understands the scope of
    variables in C.  In the C language, this is rather simple because
    the scopes of variables is based on their code blocks.  In C++,
    however, the class member variables are referenced in a different
    code block from the declared position, so
    the <command>ecpg</command> preprocessor will not understand the
    scope of the class member variables.
   </para>
________________________________________________________-->
   <para>
    <command>ecpg</command>预处理器能理解 C 中变量的可见范围。在 C 语言中，这是相当简单的，因为变量的可见范围是基于它们的代码块的。不过在 C++ 中，引用类成员变量的代码块是不同于定义它的代码块的，因此<command>ecpg</command>预处理器将无法理解类成员变量的可见范围。
   </para>
<!-- pgdoc-cn_end sig_en=97618e63c39d3f1ff2948f2762eb54d4 -->

<!-- pgdoc-cn_start sig_en=2b06a1f3ca19421cf97aa79cb9537264 sig_cn_org=None source=14.1 
   <para>
    For example, in the following case, the <command>ecpg</command>
    preprocessor cannot find any declaration for the
    variable <literal>dbname</literal> in the <literal>test</literal>
    method, so an error will occur.

<programlisting>
class TestCpp
{
    EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
    EXEC SQL END DECLARE SECTION;

  public:
    TestCpp();
    void test();
    ~TestCpp();
};

TestCpp::TestCpp()
{
    EXEC SQL CONNECT TO testdb1;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
}

void Test::test()
{
    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current_database = %s\n", dbname);
}

TestCpp::~TestCpp()
{
    EXEC SQL DISCONNECT ALL;
}
</programlisting>

    This code will result in an error like this:
<screen>
<userinput>ecpg test_cpp.pgc</userinput>
test_cpp.pgc:28: ERROR: variable "dbname" is not declared
</screen>
   </para>
________________________________________________________-->
   <para>
    例如，在下面的情况中，<command>ecpg</command>预处理器无法为<literal>test</literal>方法中的变量<literal>dbname</literal>找到任何声明，因此将发生一个错误。

<programlisting>
class TestCpp
{
    EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
    EXEC SQL END DECLARE SECTION;

  public:
    TestCpp();
    void test();
    ~TestCpp();
};

TestCpp::TestCpp()
{
    EXEC SQL CONNECT TO testdb1;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
}

void Test::test()
{
    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current_database = %s\n", dbname);
}

TestCpp::~TestCpp()
{
    EXEC SQL DISCONNECT ALL;
}
</programlisting>

    这段代码将导致一个这样的错误：
<screen>
<userinput>ecpg test_cpp.pgc</userinput>
test_cpp.pgc:28: ERROR: variable "dbname" is not declared
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=2b06a1f3ca19421cf97aa79cb9537264 -->

<!-- pgdoc-cn_start sig_en=2742ff805e41809e81156cf73275edd5 sig_cn_org=None source=14.1 
   <para>
    To avoid this scope issue, the <literal>test</literal> method
    could be modified to use a local variable as intermediate storage.
    But this approach is only a poor workaround, because it uglifies
    the code and reduces performance.

<programlisting>
void TestCpp::test()
{
    EXEC SQL BEGIN DECLARE SECTION;
    char tmp[1024];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT current_database() INTO :tmp;
    strlcpy(dbname, tmp, sizeof(tmp));

    printf("current_database = %s\n", dbname);
}
</programlisting>
   </para>
________________________________________________________-->
   <para>
    为了避免这种可见性问题，可以修改<literal>test</literal>方法来把一个本地变量用作中间存储。但是这种方法只是一种比较差的变通方案，因为它让代码变得丑陋并且降低了性能。

<programlisting>
void TestCpp::test()
{
    EXEC SQL BEGIN DECLARE SECTION;
    char tmp[1024];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT current_database() INTO :tmp;
    strlcpy(dbname, tmp, sizeof(tmp));

    printf("current_database = %s\n", dbname);
}
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=2742ff805e41809e81156cf73275edd5 -->
  </sect2>

  <sect2 id="ecpg-cpp-and-c">
<!-- pgdoc-cn_start sig_en=2de738f114b0855edfc0d6f616f29f09 sig_cn_org=None source=14.1 
   <title>C++ Application Development with External C Module</title>
________________________________________________________-->
   <title>使用外部 C 模块的 C++ 应用开发</title>
<!-- pgdoc-cn_end sig_en=2de738f114b0855edfc0d6f616f29f09 -->

<!-- pgdoc-cn_start sig_en=a693e5f42109d94e1fb65d9b6a04abf1 sig_cn_org=None source=14.1 
   <para>
    If you understand these technical limitations of
    the <command>ecpg</command> preprocessor in C++, you might come to
    the conclusion that linking C objects and C++ objects at the link
    stage to enable C++ applications to use ECPG features could be
    better than writing some embedded SQL commands in C++ code
    directly.  This section describes a way to separate some embedded
    SQL commands from C++ application code with a simple example.  In
    this example, the application is implemented in C++, while C and
    ECPG is used to connect to the PostgreSQL server.
   </para>
________________________________________________________-->
   <para>
    如果你理解了 C++ 中<command>ecpg</command>预处理器的这些技术限制，你可能已经知道在链接阶段把 C 对象和 C++ 对象链接起来让 C++ 应用能使用 ECPG 特性比直接在 C++ 代码中写一些嵌入式 SQL 命令要更好。这一节用一个简单的例子描述了一种将嵌入式 SQL 命令从 C++ 应用代码中独立出去的方法。在这个例子中，应用由 C++ 实现，而 C 和 ECPG 被用来连接到 PostgreSQL 服务器。
   </para>
<!-- pgdoc-cn_end sig_en=a693e5f42109d94e1fb65d9b6a04abf1 -->

<!-- pgdoc-cn_start sig_en=00f0ee4c5c8ccde12807c3e4ffa2f350 sig_cn_org=None source=14.1 
   <para>
    Three kinds of files have to be created: a C file
    (<filename>*.pgc</filename>), a header file, and a C++ file:

    <variablelist>
     <varlistentry>
      <term><filename>test_mod.pgc</filename></term>
      <listitem>
       <para>
        A sub-routine module to execute SQL commands embedded in C.
        It is going to be converted
        into <filename>test_mod.c</filename> by the preprocessor.

<programlisting>
#include "test_mod.h"
#include &lt;stdio.h&gt;

void
db_connect()
{
    EXEC SQL CONNECT TO testdb1;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
}

void
db_test()
{
    EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current_database = %s\n", dbname);
}

void
db_disconnect()
{
    EXEC SQL DISCONNECT ALL;
}
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><filename>test_mod.h</filename></term>
      <listitem>
       <para>
        A header file with declarations of the functions in the C
        module (<filename>test_mod.pgc</filename>).  It is included by
        <filename>test_cpp.cpp</filename>.  This file has to have an
        <literal>extern "C"</literal> block around the declarations,
        because it will be linked from the C++ module.

<programlisting>
#ifdef __cplusplus
extern "C" {
#endif

void db_connect();
void db_test();
void db_disconnect();

#ifdef __cplusplus
}
#endif
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><filename>test_cpp.cpp</filename></term>
      <listitem>
       <para>
        The main code for the application, including
        the <function>main</function> routine, and in this example a
        C++ class.

<programlisting>
#include "test_mod.h"

class TestCpp
{
  public:
    TestCpp();
    void test();
    ~TestCpp();
};

TestCpp::TestCpp()
{
    db_connect();
}

void
TestCpp::test()
{
    db_test();
}

TestCpp::~TestCpp()
{
    db_disconnect();
}

int
main(void)
{
    TestCpp *t = new TestCpp();

    t->test();
    return 0;
}
</programlisting>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    需要创建三种文件：一个 C 文件（<filename>*.pgc</filename>）、一个头文件和一个 C++ 文件：

    <variablelist>
     <varlistentry>
      <term><filename>test_mod.pgc</filename></term>
      <listitem>
       <para>
        一个执行嵌入在 C 中的 SQL 命令的子例程模块。它将被预处理器转换成<filename>test_mod.c</filename>。

<programlisting>
#include "test_mod.h"
#include &lt;stdio.h&gt;

void
db_connect()
{
    EXEC SQL CONNECT TO testdb1;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
}

void
db_test()
{
    EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current_database = %s\n", dbname);
}

void
db_disconnect()
{
    EXEC SQL DISCONNECT ALL;
}
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><filename>test_mod.h</filename></term>
      <listitem>
       <para>
        包含 C 模块（<filename>test_mod.pgc</filename>）中函数定义的头文件。它会被<filename>test_cpp.cpp</filename>包括。这个文件必须在声明周围有一个<literal>extern "C"</literal>块，因为它将被链接到 C++ 模块。

<programlisting>
#ifdef __cplusplus
extern "C" {
#endif

void db_connect();
void db_test();
void db_disconnect();

#ifdef __cplusplus
}
#endif
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><filename>test_cpp.cpp</filename></term>
      <listitem>
       <para>
        应用的主代码，包括<function>main</function>例程以及这个例子中的一个 C++ 类。

<programlisting>
#include "test_mod.h"

class TestCpp
{
  public:
    TestCpp();
    void test();
    ~TestCpp();
};

TestCpp::TestCpp()
{
    db_connect();
}

void
TestCpp::test()
{
    db_test();
}

TestCpp::~TestCpp()
{
    db_disconnect();
}

int
main(void)
{
    TestCpp *t = new TestCpp();

    t->test();
    return 0;
}
</programlisting>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=00f0ee4c5c8ccde12807c3e4ffa2f350 -->

<!-- pgdoc-cn_start sig_en=860e8d1cb9c3b8636ce1d85b8b988096 sig_cn_org=None source=14.1 
   <para>
    To build the application, proceed as follows.  Convert
    <filename>test_mod.pgc</filename> into <filename>test_mod.c</filename> by
    running <command>ecpg</command>, and generate
    <filename>test_mod.o</filename> by compiling
    <filename>test_mod.c</filename> with the C compiler:
<programlisting>
ecpg -o test_mod.c test_mod.pgc
cc -c test_mod.c -o test_mod.o
</programlisting>
   </para>
________________________________________________________-->
   <para>
    要构建该应用，按以下步骤处理。通过运行<command>ecpg</command>将<filename>test_mod.pgc</filename>转换为<filename>test_mod.c</filename>，并且用 C 编译器将<filename>test_mod.c</filename>编译成<filename>test_mod.o</filename>：
<programlisting>
ecpg -o test_mod.c test_mod.pgc
cc -c test_mod.c -o test_mod.o
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=860e8d1cb9c3b8636ce1d85b8b988096 -->

<!-- pgdoc-cn_start sig_en=82f7c695b88c5292f7d3b81e99286499 sig_cn_org=None source=14.1 
   <para>
    Next, generate <filename>test_cpp.o</filename> by compiling
    <filename>test_cpp.cpp</filename> with the C++ compiler:
<programlisting>
c++ -c test_cpp.cpp -o test_cpp.o
</programlisting>
   </para>
________________________________________________________-->
   <para>
    接着，用 C++ 编译器把<filename>test_cpp.cpp</filename>编译成<filename>test_cpp.o</filename>：
<programlisting>
c++ -c test_cpp.cpp -o test_cpp.o
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=82f7c695b88c5292f7d3b81e99286499 -->

<!-- pgdoc-cn_start sig_en=98e8c1a53748879e7321ed3b53c53672 sig_cn_org=None source=14.1 
   <para>
    Finally, link these object files, <filename>test_cpp.o</filename>
    and <filename>test_mod.o</filename>, into one executable, using the C++
    compiler driver:
<programlisting>
c++ test_cpp.o test_mod.o -lecpg -o test_cpp
</programlisting>
   </para>
________________________________________________________-->
   <para>
    最后，使用 C++ 编译器链接这些对象文件（<filename>test_cpp.o</filename>和<filename>test_mod.o</filename>）成为一个可执行文件：
<programlisting>
c++ test_cpp.o test_mod.o -lecpg -o test_cpp
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=98e8c1a53748879e7321ed3b53c53672 -->
  </sect2>
 </sect1>

 <sect1 id="ecpg-sql-commands">
<!-- pgdoc-cn_start sig_en=c6b52a9bdd8ad2f9963699b90f1b9b4d sig_cn_org=None source=14.1 
  <title>Embedded SQL Commands</title>
________________________________________________________-->
  <title>嵌入式 SQL 命令</title>
<!-- pgdoc-cn_end sig_en=c6b52a9bdd8ad2f9963699b90f1b9b4d -->

<!-- pgdoc-cn_start sig_en=5b96b4196da2a86f9cbe903ca7e289eb sig_cn_org=None source=14.1 
  <para>
   This section describes all SQL commands that are specific to
   embedded SQL.  Also refer to the SQL commands listed
   in <xref linkend="sql-commands"/>, which can also be used in
   embedded SQL, unless stated otherwise.
  </para>
________________________________________________________-->
  <para>
   这一节描述嵌入式 SQL 所有特定的 SQL 命令。<xref linkend="sql-commands"/>中的 SQL 命令也能被用于嵌入式 SQL，如果有例外会特别说明。
  </para>
<!-- pgdoc-cn_end sig_en=5b96b4196da2a86f9cbe903ca7e289eb -->

  <refentry id="ecpg-sql-allocate-descriptor">
<!-- pgdoc-cn_start sig_en=639703e7e0f05b3bfea9a573fa4c6f7e sig_cn_org=None source=14.1 
   <refnamediv>
    <refname>ALLOCATE DESCRIPTOR</refname>
    <refpurpose>allocate an SQL descriptor area</refpurpose>
   </refnamediv>
________________________________________________________-->
   <refnamediv>
    <refname>ALLOCATE DESCRIPTOR</refname>
    <refpurpose>分配一个 SQL 描述符区域</refpurpose>
   </refnamediv>
<!-- pgdoc-cn_end sig_en=639703e7e0f05b3bfea9a573fa4c6f7e -->

   <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=3dca55d4a0ad9ebbf74f32af3aae3f2b sig_cn_org=None source=14.1 
<synopsis>
ALLOCATE DESCRIPTOR <replaceable class="parameter">name</replaceable>
</synopsis>
________________________________________________________-->
<synopsis>
ALLOCATE DESCRIPTOR <replaceable class="parameter">name</replaceable>
</synopsis>
<!-- pgdoc-cn_end sig_en=3dca55d4a0ad9ebbf74f32af3aae3f2b -->
   </refsynopsisdiv>

   <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
    <title>Description</title>
________________________________________________________-->
    <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=de86b68c2c743ffdf04b8fdb354f2d71 sig_cn_org=None source=14.1 
    <para>
     <command>ALLOCATE DESCRIPTOR</command> allocates a new named SQL
     descriptor area, which can be used to exchange data between the
     PostgreSQL server and the host program.
    </para>
________________________________________________________-->
    <para>
     <command>ALLOCATE DESCRIPTOR</command>分配一个新的命名 SQL 描述符区域，它能被用来在 PostgreSQL 服务器和主程序之间交换数据。
    </para>
<!-- pgdoc-cn_end sig_en=de86b68c2c743ffdf04b8fdb354f2d71 -->

<!-- pgdoc-cn_start sig_en=fa2479b1f957257aed84148e4120d7b5 sig_cn_org=None source=14.1 
    <para>
     Descriptor areas should be freed after use using
     the <command>DEALLOCATE DESCRIPTOR</command> command.
    </para>
________________________________________________________-->
    <para>
     以后可以使用<command>DEALLOCATE DESCRIPTOR</command>命令释放描述符区域。
    </para>
<!-- pgdoc-cn_end sig_en=fa2479b1f957257aed84148e4120d7b5 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
    <title>Parameters</title>
________________________________________________________-->
    <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=19beec84e5b9b8a6c2d23a9bb0595ca6 sig_cn_org=None source=14.1 
       <para>
        A name of SQL descriptor, case sensitive.  This can be an SQL
        identifier or a host variable.
       </para>
________________________________________________________-->
       <para>
        SQL 描述符的名称，大小写敏感。这可以是一个 SQL 标识符或者一个主变量。
       </para>
<!-- pgdoc-cn_end sig_en=19beec84e5b9b8a6c2d23a9bb0595ca6 -->
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
    <title>Examples</title>
________________________________________________________-->
    <title>例子</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=2b5c8fd6b3eca1229ac1e16c461ba532 sig_cn_org=None source=14.1 
<programlisting>
EXEC SQL ALLOCATE DESCRIPTOR mydesc;
</programlisting>
________________________________________________________-->
<programlisting>
EXEC SQL ALLOCATE DESCRIPTOR mydesc;
</programlisting>
<!-- pgdoc-cn_end sig_en=2b5c8fd6b3eca1229ac1e16c461ba532 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
    <title>Compatibility</title>
________________________________________________________-->
    <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=1d7ef1da0e729e9e0bf322b7597f0b32 sig_cn_org=None source=14.1 
    <para>
     <command>ALLOCATE DESCRIPTOR</command> is specified in the SQL
     standard.
    </para>
________________________________________________________-->
    <para>
     SQL 标准中说明了<command>ALLOCATE DESCRIPTOR</command>。
    </para>
<!-- pgdoc-cn_end sig_en=1d7ef1da0e729e9e0bf322b7597f0b32 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8b7cc214676b443e6527e3d6bf054420 sig_cn_org=None source=14.1 
    <title>See Also</title>
________________________________________________________-->
    <title>参见</title>
<!-- pgdoc-cn_end sig_en=8b7cc214676b443e6527e3d6bf054420 -->

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-deallocate-descriptor"/></member>
     <member><xref linkend="ecpg-sql-get-descriptor"/></member>
     <member><xref linkend="ecpg-sql-set-descriptor"/></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-connect">
<!-- pgdoc-cn_start sig_en=e794be0de9323a524e7a2273c240d4fd sig_cn_org=None source=14.1 
   <refnamediv>
    <refname>CONNECT</refname>
    <refpurpose>establish a database connection</refpurpose>
   </refnamediv>
________________________________________________________-->
   <refnamediv>
    <refname>CONNECT</refname>
    <refpurpose>建立一个数据库连接</refpurpose>
   </refnamediv>
<!-- pgdoc-cn_end sig_en=e794be0de9323a524e7a2273c240d4fd -->

   <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=5d2de64df5f537f82dfa6b4d9ee533b2 sig_cn_org=None source=14.1 
<synopsis>
CONNECT TO <replaceable>connection_target</replaceable> [ AS <replaceable>connection_name</replaceable> ] [ USER <replaceable>connection_user</replaceable> ]
CONNECT TO DEFAULT
CONNECT <replaceable>connection_user</replaceable>
DATABASE <replaceable>connection_target</replaceable>
</synopsis>
________________________________________________________-->
<synopsis>
CONNECT TO <replaceable>connection_target</replaceable> [ AS <replaceable>connection_name</replaceable> ] [ USER <replaceable>connection_user</replaceable> ]
CONNECT TO DEFAULT
CONNECT <replaceable>connection_user</replaceable>
DATABASE <replaceable>connection_target</replaceable>
</synopsis>
<!-- pgdoc-cn_end sig_en=5d2de64df5f537f82dfa6b4d9ee533b2 -->
   </refsynopsisdiv>

   <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
    <title>Description</title>
________________________________________________________-->
    <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=7f99fbf9b1ed606eead9085c26d113d5 sig_cn_org=None source=14.1 
    <para>
     The <command>CONNECT</command> command establishes a connection
     between the client and the PostgreSQL server.
    </para>
________________________________________________________-->
    <para>
     <command>CONNECT</command>命令在客户端和 PostgreSQL 服务器之间建立一个连接。
    </para>
<!-- pgdoc-cn_end sig_en=7f99fbf9b1ed606eead9085c26d113d5 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
    <title>Parameters</title>
________________________________________________________-->
    <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">connection_target</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=b6416fa284e2beeba15bfc75d8597ff3 sig_cn_org=None source=14.1 
       <para>
        <replaceable class="parameter">connection_target</replaceable>
        specifies the target server of the connection on one of
        several forms.

        <variablelist>
         <varlistentry>
          <term>[ <replaceable>database_name</replaceable> ] [ <literal>@</literal><replaceable>host</replaceable> ] [ <literal>:</literal><replaceable>port</replaceable> ]</term>
          <listitem>
           <para>
            Connect over TCP/IP
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>unix:postgresql://</literal><replaceable>host</replaceable> [ <literal>:</literal><replaceable>port</replaceable> ] <literal>/</literal> [ <replaceable>database_name</replaceable> ] [ <literal>?</literal><replaceable>connection_option</replaceable> ]</term>
          <listitem>
           <para>
            Connect over Unix-domain sockets
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>tcp:postgresql://</literal><replaceable>host</replaceable> [ <literal>:</literal><replaceable>port</replaceable> ] <literal>/</literal> [ <replaceable>database_name</replaceable> ] [ <literal>?</literal><replaceable>connection_option</replaceable> ]</term>
          <listitem>
           <para>
            Connect over TCP/IP
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term>SQL string constant</term>
          <listitem>
           <para>
            containing a value in one of the above forms
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term>host variable</term>
          <listitem>
           <para>
            host variable of type <type>char[]</type>
            or <type>VARCHAR[]</type> containing a value in one of the
            above forms
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
________________________________________________________-->
       <para>
        <replaceable class="parameter">connection_target</replaceable>以下列形式之一指定连接的目标服务器。

        <variablelist>
         <varlistentry>
          <term>[ <replaceable>database_name</replaceable> ] [ <literal>@</literal><replaceable>host</replaceable> ] [ <literal>:</literal><replaceable>port</replaceable> ]</term>
          <listitem>
           <para>
            通过 TCP/IP 连接
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>unix:postgresql://</literal><replaceable>host</replaceable> [ <literal>:</literal><replaceable>port</replaceable> ] <literal>/</literal> [ <replaceable>database_name</replaceable> ] [ <literal>?</literal><replaceable>connection_option</replaceable> ]</term>
          <listitem>
           <para>
            通过 Unix 域套接字
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>tcp:postgresql://</literal><replaceable>host</replaceable> [ <literal>:</literal><replaceable>port</replaceable> ] <literal>/</literal> [ <replaceable>database_name</replaceable> ] [ <literal>?</literal><replaceable>connection_option</replaceable> ]</term>
          <listitem>
           <para>
            通过 TCP/IP 连接
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term>SQL string constant</term>
          <listitem>
           <para>
            包含上述形式之一的一个值
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term>host variable</term>
          <listitem>
           <para>
            类型<type>char[]</type>或<type>VARCHAR[]</type>的主变量，它包含上述形式之一的一个值
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>
<!-- pgdoc-cn_end sig_en=b6416fa284e2beeba15bfc75d8597ff3 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">connection_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=3a69ca0c0fd189365211c68777907141 sig_cn_org=None source=14.1 
       <para>
        An optional identifier for the connection, so that it can be
        referred to in other commands.  This can be an SQL identifier
        or a host variable.
       </para>
________________________________________________________-->
       <para>
        用于该连接的一个可选标识符，这样可以在其他命令中引用它。这可以是一个 SQL 标识符或者一个主变量。
       </para>
<!-- pgdoc-cn_end sig_en=3a69ca0c0fd189365211c68777907141 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">connection_user</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=f50d977516f4648b893959509f46d29d sig_cn_org=None source=14.1 
       <para>
        The user name for the database connection.
       </para>
________________________________________________________-->
       <para>
        用于数据库连接的用户名。
       </para>
<!-- pgdoc-cn_end sig_en=f50d977516f4648b893959509f46d29d -->

<!-- pgdoc-cn_start sig_en=fca03168742d7abf51c44c965077572a sig_cn_org=None source=14.1 
       <para>
        This parameter can also specify user name and password, using one the forms
        <literal><replaceable>user_name</replaceable>/<replaceable>password</replaceable></literal>,
        <literal><replaceable>user_name</replaceable> IDENTIFIED BY <replaceable>password</replaceable></literal>, or
        <literal><replaceable>user_name</replaceable> USING <replaceable>password</replaceable></literal>.
       </para>
________________________________________________________-->
       <para>
        使用
        <literal><replaceable>user_name</replaceable>/<replaceable>password</replaceable></literal>、
        <literal><replaceable>user_name</replaceable> IDENTIFIED BY <replaceable>password</replaceable></literal>或者
        <literal><replaceable>user_name</replaceable> USING <replaceable>password</replaceable></literal>之一，这个参数也能指定用户名和口令.
       </para>
<!-- pgdoc-cn_end sig_en=fca03168742d7abf51c44c965077572a -->

<!-- pgdoc-cn_start sig_en=c68b414da6e1372311afee6b09853106 sig_cn_org=None source=14.1 
       <para>
        User name and password can be SQL identifiers, string
        constants, or host variables.
       </para>
________________________________________________________-->
       <para>
        用户名和口令可以是 SQL 标识符、字符串常量或者主变量。
       </para>
<!-- pgdoc-cn_end sig_en=c68b414da6e1372311afee6b09853106 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DEFAULT</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=1a1cfc3b9987c0634c2bb994003fdacd sig_cn_org=None source=14.1 
       <para>
        Use all default connection parameters, as defined by libpq.
       </para>
________________________________________________________-->
       <para>
        按 libpq 的定义使用所有默认连接参数。
       </para>
<!-- pgdoc-cn_end sig_en=1a1cfc3b9987c0634c2bb994003fdacd -->
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
    <title>Examples</title>
________________________________________________________-->
    <title>例子</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=3ef8bd7a61d03687f1c0461ef291f40a sig_cn_org=None source=14.1 
    <para>
     Here a several variants for specifying connection parameters:
<programlisting>
EXEC SQL CONNECT TO "connectdb" AS main;
EXEC SQL CONNECT TO "connectdb" AS second;
EXEC SQL CONNECT TO "unix:postgresql://200.46.204.71/connectdb" AS main USER connectuser;
EXEC SQL CONNECT TO "unix:postgresql://localhost/connectdb" AS main USER connectuser;
EXEC SQL CONNECT TO 'connectdb' AS main;
EXEC SQL CONNECT TO 'unix:postgresql://localhost/connectdb' AS main USER :user;
EXEC SQL CONNECT TO :db AS :id;
EXEC SQL CONNECT TO :db USER connectuser USING :pw;
EXEC SQL CONNECT TO @localhost AS main USER connectdb;
EXEC SQL CONNECT TO REGRESSDB1 as main;
EXEC SQL CONNECT TO AS main USER connectdb;
EXEC SQL CONNECT TO connectdb AS :id;
EXEC SQL CONNECT TO connectdb AS main USER connectuser/connectdb;
EXEC SQL CONNECT TO connectdb AS main;
EXEC SQL CONNECT TO connectdb@localhost AS main;
EXEC SQL CONNECT TO tcp:postgresql://localhost/ USER connectdb;
EXEC SQL CONNECT TO tcp:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY connectpw;
EXEC SQL CONNECT TO tcp:postgresql://localhost:20/connectdb USER connectuser IDENTIFIED BY connectpw;
EXEC SQL CONNECT TO unix:postgresql://localhost/ AS main USER connectdb;
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb AS main USER connectuser;
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY "connectpw";
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb USER connectuser USING "connectpw";
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb?connect_timeout=14 USER connectuser;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     这里是一些指定连接参数的变体：
<programlisting>
EXEC SQL CONNECT TO "connectdb" AS main;
EXEC SQL CONNECT TO "connectdb" AS second;
EXEC SQL CONNECT TO "unix:postgresql://200.46.204.71/connectdb" AS main USER connectuser;
EXEC SQL CONNECT TO "unix:postgresql://localhost/connectdb" AS main USER connectuser;
EXEC SQL CONNECT TO 'connectdb' AS main;
EXEC SQL CONNECT TO 'unix:postgresql://localhost/connectdb' AS main USER :user;
EXEC SQL CONNECT TO :db AS :id;
EXEC SQL CONNECT TO :db USER connectuser USING :pw;
EXEC SQL CONNECT TO @localhost AS main USER connectdb;
EXEC SQL CONNECT TO REGRESSDB1 as main;
EXEC SQL CONNECT TO AS main USER connectdb;
EXEC SQL CONNECT TO connectdb AS :id;
EXEC SQL CONNECT TO connectdb AS main USER connectuser/connectdb;
EXEC SQL CONNECT TO connectdb AS main;
EXEC SQL CONNECT TO connectdb@localhost AS main;
EXEC SQL CONNECT TO tcp:postgresql://localhost/ USER connectdb;
EXEC SQL CONNECT TO tcp:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY connectpw;
EXEC SQL CONNECT TO tcp:postgresql://localhost:20/connectdb USER connectuser IDENTIFIED BY connectpw;
EXEC SQL CONNECT TO unix:postgresql://localhost/ AS main USER connectdb;
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb AS main USER connectuser;
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb USER connectuser IDENTIFIED BY "connectpw";
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb USER connectuser USING "connectpw";
EXEC SQL CONNECT TO unix:postgresql://localhost/connectdb?connect_timeout=14 USER connectuser;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=3ef8bd7a61d03687f1c0461ef291f40a -->

<!-- pgdoc-cn_start sig_en=2db1c7a372585d49002e193ef8567059 sig_cn_org=None source=14.1 
    <para>
     Here is an example program that illustrates the use of host
     variables to specify connection parameters:
<programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    char *dbname     = "testdb";    /* database name */
    char *user       = "testuser";  /* connection user name */
    char *connection = "tcp:postgresql://localhost:5432/testdb";
                                    /* connection string */
    char ver[256];                  /* buffer to store the version string */
EXEC SQL END DECLARE SECTION;

    ECPGdebug(1, stderr);

    EXEC SQL CONNECT TO :dbname USER :user;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
    EXEC SQL SELECT version() INTO :ver;
    EXEC SQL DISCONNECT;

    printf("version: %s\n", ver);

    EXEC SQL CONNECT TO :connection USER :user;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
    EXEC SQL SELECT version() INTO :ver;
    EXEC SQL DISCONNECT;

    printf("version: %s\n", ver);

    return 0;
}
</programlisting>
    </para>
________________________________________________________-->
    <para>
     这里是一个展示使用主变量指定连接参数的例子程序：
<programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    char *dbname     = "testdb";    /* 数据库名 */
    char *user       = "testuser";  /* 连接用户名 */
    char *connection = "tcp:postgresql://localhost:5432/testdb";
                                    /* 连接字符串 */
    char ver[256];                  /* 存储版本字符串的缓冲区 */
EXEC SQL END DECLARE SECTION;

    ECPGdebug(1, stderr);

    EXEC SQL CONNECT TO :dbname USER :user;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
    EXEC SQL SELECT version() INTO :ver;
    EXEC SQL DISCONNECT;

    printf("version: %s\n", ver);

    EXEC SQL CONNECT TO :connection USER :user;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
    EXEC SQL SELECT version() INTO :ver;
    EXEC SQL DISCONNECT;

    printf("version: %s\n", ver);

    return 0;
}
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=2db1c7a372585d49002e193ef8567059 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
    <title>Compatibility</title>
________________________________________________________-->
    <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=e06c1ff357080a7150e05aef6cda880e sig_cn_org=None source=14.1 
    <para>
     <command>CONNECT</command> is specified in the SQL standard, but
     the format of the connection parameters is
     implementation-specific.
    </para>
________________________________________________________-->
    <para>
     SQL 标准中说明了<command>CONNECT</command>，但是连接参数的格式是与实现相关的。
    </para>
<!-- pgdoc-cn_end sig_en=e06c1ff357080a7150e05aef6cda880e -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8b7cc214676b443e6527e3d6bf054420 sig_cn_org=None source=14.1 
    <title>See Also</title>
________________________________________________________-->
    <title>参见</title>
<!-- pgdoc-cn_end sig_en=8b7cc214676b443e6527e3d6bf054420 -->

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-disconnect"/></member>
     <member><xref linkend="ecpg-sql-set-connection"/></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-deallocate-descriptor">
<!-- pgdoc-cn_start sig_en=88e78da66975813e612827885209067a sig_cn_org=None source=14.1 
   <refnamediv>
    <refname>DEALLOCATE DESCRIPTOR</refname>
    <refpurpose>deallocate an SQL descriptor area</refpurpose>
   </refnamediv>
________________________________________________________-->
   <refnamediv>
    <refname>DEALLOCATE DESCRIPTOR</refname>
    <refpurpose>释放一个 SQL 描述符区域</refpurpose>
   </refnamediv>
<!-- pgdoc-cn_end sig_en=88e78da66975813e612827885209067a -->

   <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=16316be4e95bee18ed08747063ad6ea3 sig_cn_org=None source=14.1 
<synopsis>
DEALLOCATE DESCRIPTOR <replaceable class="parameter">name</replaceable>
</synopsis>
________________________________________________________-->
<synopsis>
DEALLOCATE DESCRIPTOR <replaceable class="parameter">name</replaceable>
</synopsis>
<!-- pgdoc-cn_end sig_en=16316be4e95bee18ed08747063ad6ea3 -->
   </refsynopsisdiv>

   <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
    <title>Description</title>
________________________________________________________-->
    <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=685b5a820fd9973dbb96106f968d2e29 sig_cn_org=None source=14.1 
    <para>
     <command>DEALLOCATE DESCRIPTOR</command> deallocates a named SQL
     descriptor area.
    </para>
________________________________________________________-->
    <para>
     <command>DEALLOCATE DESCRIPTOR</command>释放一个命名的 SQL 描述符区域。
    </para>
<!-- pgdoc-cn_end sig_en=685b5a820fd9973dbb96106f968d2e29 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
    <title>Parameters</title>
________________________________________________________-->
    <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=5b1da14fb456c12c1864bfce19e63096 sig_cn_org=None source=14.1 
       <para>
        The name of the descriptor which is going to be deallocated.
        It is case sensitive.  This can be an SQL identifier or a host
        variable.
       </para>
________________________________________________________-->
       <para>
        要被释放的描述符的名称。它是大小写敏感的。这可以是一个 SQL 标识符或者一个主变量。
       </para>
<!-- pgdoc-cn_end sig_en=5b1da14fb456c12c1864bfce19e63096 -->
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
    <title>Examples</title>
________________________________________________________-->
    <title>例子</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=c0b51cddd383f0b8c79e81222226c42e sig_cn_org=None source=14.1 
<programlisting>
EXEC SQL DEALLOCATE DESCRIPTOR mydesc;
</programlisting>
________________________________________________________-->
<programlisting>
EXEC SQL DEALLOCATE DESCRIPTOR mydesc;
</programlisting>
<!-- pgdoc-cn_end sig_en=c0b51cddd383f0b8c79e81222226c42e -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
    <title>Compatibility</title>
________________________________________________________-->
    <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=97dcfa13a2e373bcb484b23330aa22ff sig_cn_org=None source=14.1 
    <para>
     <command>DEALLOCATE DESCRIPTOR</command> is specified in the SQL
     standard.
    </para>
________________________________________________________-->
    <para>
     SQL 标准说明了<command>DEALLOCATE DESCRIPTOR</command>。
    </para>
<!-- pgdoc-cn_end sig_en=97dcfa13a2e373bcb484b23330aa22ff -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8b7cc214676b443e6527e3d6bf054420 sig_cn_org=None source=14.1 
    <title>See Also</title>
________________________________________________________-->
    <title>参见</title>
<!-- pgdoc-cn_end sig_en=8b7cc214676b443e6527e3d6bf054420 -->

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"/></member>
     <member><xref linkend="ecpg-sql-get-descriptor"/></member>
     <member><xref linkend="ecpg-sql-set-descriptor"/></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-declare">
<!-- pgdoc-cn_start sig_en=cd3fcd78924ea3cf204a24b49c8c38f7 sig_cn_org=None source=14.1 
   <refnamediv>
    <refname>DECLARE</refname>
    <refpurpose>define a cursor</refpurpose>
   </refnamediv>
________________________________________________________-->
   <refnamediv>
    <refname>DECLARE</refname>
    <refpurpose>定义一个游标</refpurpose>
   </refnamediv>
<!-- pgdoc-cn_end sig_en=cd3fcd78924ea3cf204a24b49c8c38f7 -->

   <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=31c00a2611ff0e89b359455eb6ccc219 sig_cn_org=None source=14.1 
<synopsis>
DECLARE <replaceable class="parameter">cursor_name</replaceable> [ BINARY ] [ ASENSITIVE | INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH | WITHOUT } HOLD ] FOR <replaceable class="parameter">prepared_name</replaceable>
DECLARE <replaceable class="parameter">cursor_name</replaceable> [ BINARY ] [ ASENSITIVE | INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH | WITHOUT } HOLD ] FOR <replaceable class="parameter">query</replaceable>
</synopsis>
________________________________________________________-->
<synopsis>
DECLARE <replaceable class="parameter">cursor_name</replaceable> [ BINARY ] [ ASENSITIVE | INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH | WITHOUT } HOLD ] FOR <replaceable class="parameter">prepared_name</replaceable>
DECLARE <replaceable class="parameter">cursor_name</replaceable> [ BINARY ] [ ASENSITIVE | INSENSITIVE ] [ [ NO ] SCROLL ] CURSOR [ { WITH | WITHOUT } HOLD ] FOR <replaceable class="parameter">query</replaceable>
</synopsis>
<!-- pgdoc-cn_end sig_en=31c00a2611ff0e89b359455eb6ccc219 -->
   </refsynopsisdiv>

   <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
    <title>Description</title>
________________________________________________________-->
    <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=1821ebb26525760925294cdbfc3d071f sig_cn_org=None source=14.1 
    <para>
     <command>DECLARE</command> declares a cursor for iterating over
     the result set of a prepared statement.  This command has
     slightly different semantics from the direct SQL
     command <command>DECLARE</command>: Whereas the latter executes a
     query and prepares the result set for retrieval, this embedded
     SQL command merely declares a name as a <quote>loop
     variable</quote> for iterating over the result set of a query;
     the actual execution happens when the cursor is opened with
     the <command>OPEN</command> command.
    </para>
________________________________________________________-->
    <para>
     <command>DECLARE</command>声明一个游标用来在一个预备语句的结果集上迭代。这个命令与直接的 SQL 命令<command>DECLARE</command>在语义上有一点点区别：后者会执行一个查询并且准备结果集用于检索，而这个嵌入式 SQL 命令仅仅声明一个名称作为<quote>循环变量</quote>用于在一个查询的结果集上迭代，实际的执行在游标被<command>OPEN</command>命令打开时才发生。
    </para>
<!-- pgdoc-cn_end sig_en=1821ebb26525760925294cdbfc3d071f -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
    <title>Parameters</title>
________________________________________________________-->
    <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->
    <variablelist>

     <varlistentry>
      <term><replaceable class="parameter">cursor_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=519325009d8652d3425c4dc833d1b510 sig_cn_org=None source=14.1 
       <para>
        A cursor name, case sensitive.  This can be an SQL identifier
        or a host variable.
       </para>
________________________________________________________-->
       <para>
        一个游标名称，大小写敏感。这可以是一个 SQL 标识符或者一个主变量。
       </para>
<!-- pgdoc-cn_end sig_en=519325009d8652d3425c4dc833d1b510 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">prepared_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=52558cfac7a1520e01bd2a1b9e77c744 sig_cn_org=None source=14.1 
       <para>
        The name of a prepared query, either as an SQL identifier or a
        host variable.
       </para>
________________________________________________________-->
       <para>
        一个预备查询的名称，可以是一个 SQL 标识符或者一个主变量。
       </para>
<!-- pgdoc-cn_end sig_en=52558cfac7a1520e01bd2a1b9e77c744 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">query</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=f2d3380911de6e347633491cd2a77a2e sig_cn_org=None source=14.1 
       <para>
        A <xref linkend="sql-select"/> or
        <xref linkend="sql-values"/> command which will provide the
        rows to be returned by the cursor.
       </para>
________________________________________________________-->
       <para>
        一个提供游标要返回的行的<xref linkend="sql-select"/>或者<xref linkend="sql-values"/>命令。
       </para>
<!-- pgdoc-cn_end sig_en=f2d3380911de6e347633491cd2a77a2e -->
      </listitem>
     </varlistentry>
    </variablelist>

<!-- pgdoc-cn_start sig_en=34bb3a240601f713e809d6503448e4e0 sig_cn_org=None source=14.1 
    <para>
     For the meaning of the cursor options,
     see <xref linkend="sql-declare"/>.
    </para>
________________________________________________________-->
    <para>
     游标选项的含义请见<xref linkend="sql-declare"/>。
    </para>
<!-- pgdoc-cn_end sig_en=34bb3a240601f713e809d6503448e4e0 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
    <title>Examples</title>
________________________________________________________-->
    <title>例子</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=54c6e7629e8de03a1239544b479f8029 sig_cn_org=None source=14.1 
    <para>
     Examples declaring a cursor for a query:
<programlisting>
EXEC SQL DECLARE C CURSOR FOR SELECT * FROM My_Table;
EXEC SQL DECLARE C CURSOR FOR SELECT Item1 FROM T;
EXEC SQL DECLARE cur1 CURSOR FOR SELECT version();
</programlisting>
    </para>
________________________________________________________-->
    <para>
     为一个查询声明一个游标的例子：
<programlisting>
EXEC SQL DECLARE C CURSOR FOR SELECT * FROM My_Table;
EXEC SQL DECLARE C CURSOR FOR SELECT Item1 FROM T;
EXEC SQL DECLARE cur1 CURSOR FOR SELECT version();
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=54c6e7629e8de03a1239544b479f8029 -->

<!-- pgdoc-cn_start sig_en=b65dbd84dfd9bf3a28e791f089edfec9 sig_cn_org=None source=14.1 
    <para>
     An example declaring a cursor for a prepared statement:
<programlisting>
EXEC SQL PREPARE stmt1 AS SELECT version();
EXEC SQL DECLARE cur1 CURSOR FOR stmt1;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     为一个预备语句声明一个游标的例子：
<programlisting>
EXEC SQL PREPARE stmt1 AS SELECT version();
EXEC SQL DECLARE cur1 CURSOR FOR stmt1;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=b65dbd84dfd9bf3a28e791f089edfec9 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
    <title>Compatibility</title>
________________________________________________________-->
    <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=773f51c92ef3e84a041e017fd1911fa9 sig_cn_org=None source=14.1 
    <para>
     <command>DECLARE</command> is specified in the SQL standard.
    </para>
________________________________________________________-->
    <para>
     SQL 标准中说明了<command>DECLARE</command>。
    </para>
<!-- pgdoc-cn_end sig_en=773f51c92ef3e84a041e017fd1911fa9 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8b7cc214676b443e6527e3d6bf054420 sig_cn_org=None source=14.1 
    <title>See Also</title>
________________________________________________________-->
    <title>参见</title>
<!-- pgdoc-cn_end sig_en=8b7cc214676b443e6527e3d6bf054420 -->

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-open"/></member>
     <member><xref linkend="sql-close"/></member>
     <member><xref linkend="sql-declare"/></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-declare-statement">
<!-- pgdoc-cn_start sig_en=ce7c411ef4e65da28143faade2ca1df4 sig_cn_org=None source=14.1 
   <refnamediv>
    <refname>DECLARE STATEMENT</refname>
    <refpurpose>declare SQL statement identifier</refpurpose>
   </refnamediv>
________________________________________________________-->
   <refnamediv>
    <refname>DECLARE STATEMENT</refname>
    <refpurpose>声明SQL语句标识符</refpurpose>
   </refnamediv>
<!-- pgdoc-cn_end sig_en=ce7c411ef4e65da28143faade2ca1df4 -->

   <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=d28685a0d372b6b346c912c792d80477 sig_cn_org=None source=14.1 
<synopsis>
EXEC SQL [ AT <replaceable class="parameter">connection_name</replaceable> ] DECLARE <replaceable class="parameter">statement_name</replaceable> STATEMENT
</synopsis>
________________________________________________________-->
<synopsis>
EXEC SQL [ AT <replaceable class="parameter">connection_name</replaceable> ] DECLARE <replaceable class="parameter">statement_name</replaceable> STATEMENT
</synopsis>
<!-- pgdoc-cn_end sig_en=d28685a0d372b6b346c912c792d80477 -->
   </refsynopsisdiv>

   <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
    <title>Description</title>
________________________________________________________-->
    <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=e1e24aff37718d9cc43413f8c34c7f80 sig_cn_org=None source=14.1 
    <para>
     <command>DECLARE STATEMENT</command> declares an SQL statement identifier.
     SQL statement identifier can be associated with the connection.
     When the identifier is used by dynamic SQL statements, the statements
     are executed using the associated connection.
     The namespace of the declaration is the precompile unit, and multiple
     declarations to the same SQL statement identifier are not allowed.
     Note that if the precompiler runs in Informix compatibility mode and
     some SQL statement is declared, "database" can not be used as a cursor
     name.
    </para>
________________________________________________________-->
    <para>
     <command>DECLARE STATEMENT</command> 声明一个SQL语句标识符。
     SQL 语句标识符可以被关联到连接。
     当标识符被动态SQL语句使用，该语句使用关联连接执行。
     声明的名字空间是预编译单元，到相同SQL语句标识符的多个声明是不被允许的。
     注意如果预编译运行在Informix兼容模式并且一些SQL语句被声明，"database"不能被用于作为游标名称。
    </para>
<!-- pgdoc-cn_end sig_en=e1e24aff37718d9cc43413f8c34c7f80 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
    <title>Parameters</title>
________________________________________________________-->
    <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">connection_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=94091a0ff9549e2460042ef354db7bb9 sig_cn_org=None source=14.1 
       <para>
        A database connection name established by the <command>CONNECT</command> command.
       </para>
________________________________________________________-->
       <para>
        由 <command>CONNECT</command> 命令建立的数据库连接名称。
       </para>
<!-- pgdoc-cn_end sig_en=94091a0ff9549e2460042ef354db7bb9 -->
<!-- pgdoc-cn_start sig_en=be6468bd2653f058a01d2a2eadaa23d6 sig_cn_org=None source=14.1 
       <para>
        AT clause can be omitted, but such statement has no meaning.
       </para>
________________________________________________________-->
       <para>
        AT 子句可以被省略，但是这样的语句没有意义。
       </para>
<!-- pgdoc-cn_end sig_en=be6468bd2653f058a01d2a2eadaa23d6 -->
      </listitem>
     </varlistentry>
    </variablelist>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">statement_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=19bc3f4da14244dc05d4d5d2af72393d sig_cn_org=None source=14.1 
       <para>
        The name of an SQL statement identifier, either as an SQL identifier or a host variable.
       </para>
________________________________________________________-->
       <para>
        SQL语句的标识符，可以是SQL标识符或者主机变量。
       </para>
<!-- pgdoc-cn_end sig_en=19bc3f4da14244dc05d4d5d2af72393d -->
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
    <title>Notes</title>
________________________________________________________-->
    <title>Notes</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->
<!-- pgdoc-cn_start sig_en=fc5ffea6331b8babd3f1355675282473 sig_cn_org=None source=14.1 
    <para>
     This association is valid only if the declaration is physically placed on top of a dynamic statement.
    </para>
________________________________________________________-->
    <para>
     这个关联只在声明物理放置在动态语句顶部时生效。
    </para>
<!-- pgdoc-cn_end sig_en=fc5ffea6331b8babd3f1355675282473 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
    <title>Examples</title>
________________________________________________________-->
    <title>例子</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=933f6da443e46ca35053ac88d5c5bd05 sig_cn_org=None source=14.1 
<programlisting>
EXEC SQL CONNECT TO postgres AS con1;
EXEC SQL AT con1 DECLARE sql_stmt STATEMENT;
EXEC SQL DECLARE cursor_name CURSOR FOR sql_stmt;
EXEC SQL PREPARE sql_stmt FROM :dyn_string;
EXEC SQL OPEN cursor_name;
EXEC SQL FETCH cursor_name INTO :column1;
EXEC SQL CLOSE cursor_name;
</programlisting>
________________________________________________________-->
<programlisting>
EXEC SQL CONNECT TO postgres AS con1;
EXEC SQL AT con1 DECLARE sql_stmt STATEMENT;
EXEC SQL DECLARE cursor_name CURSOR FOR sql_stmt;
EXEC SQL PREPARE sql_stmt FROM :dyn_string;
EXEC SQL OPEN cursor_name;
EXEC SQL FETCH cursor_name INTO :column1;
EXEC SQL CLOSE cursor_name;
</programlisting>
<!-- pgdoc-cn_end sig_en=933f6da443e46ca35053ac88d5c5bd05 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
    <title>Compatibility</title>
________________________________________________________-->
    <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=2b5adb009908b2c7e9132280dc7d8d87 sig_cn_org=b6249e1241660d9015b79197a623ff24 source=15.7 
    <para>
     <command>DECLARE STATEMENT</command> is an extension of the SQL standard,
     but can be used in famous DBMSs.
    </para>
________________________________________________________-->
    <para>
     <command>DECLARE STATEMENT</command>是SQL标准的扩展，但可以在著名的DBMS中使用。
    </para>
<!-- pgdoc-cn_end sig_en=2b5adb009908b2c7e9132280dc7d8d87 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8b7cc214676b443e6527e3d6bf054420 sig_cn_org=None source=14.1 
    <title>See Also</title>
________________________________________________________-->
    <title>参见</title>
<!-- pgdoc-cn_end sig_en=8b7cc214676b443e6527e3d6bf054420 -->

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-connect"/></member>
     <member><xref linkend="ecpg-sql-declare"/></member>
     <member><xref linkend="ecpg-sql-open"/></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-describe">
<!-- pgdoc-cn_start sig_en=2830ab9efe6c46bbc9e5a2beb15173ac sig_cn_org=None source=14.1 
   <refnamediv>
    <refname>DESCRIBE</refname>
    <refpurpose>obtain information about a prepared statement or result set</refpurpose>
   </refnamediv>
________________________________________________________-->
   <refnamediv>
    <refname>DESCRIBE</refname>
    <refpurpose>得到有关一个预备语句或结果集的信息</refpurpose>
   </refnamediv>
<!-- pgdoc-cn_end sig_en=2830ab9efe6c46bbc9e5a2beb15173ac -->

   <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=91833bf57de7c1c325e2d99e7fcf4776 sig_cn_org=None source=14.1 
<synopsis>
DESCRIBE [ OUTPUT ] <replaceable class="parameter">prepared_name</replaceable> USING [ SQL ] DESCRIPTOR <replaceable class="parameter">descriptor_name</replaceable>
DESCRIBE [ OUTPUT ] <replaceable class="parameter">prepared_name</replaceable> INTO [ SQL ] DESCRIPTOR <replaceable class="parameter">descriptor_name</replaceable>
DESCRIBE [ OUTPUT ] <replaceable class="parameter">prepared_name</replaceable> INTO <replaceable class="parameter">sqlda_name</replaceable>
</synopsis>
________________________________________________________-->
<synopsis>
DESCRIBE [ OUTPUT ] <replaceable class="parameter">prepared_name</replaceable> USING [ SQL ] DESCRIPTOR <replaceable class="parameter">descriptor_name</replaceable>
DESCRIBE [ OUTPUT ] <replaceable class="parameter">prepared_name</replaceable> INTO [ SQL ] DESCRIPTOR <replaceable class="parameter">descriptor_name</replaceable>
DESCRIBE [ OUTPUT ] <replaceable class="parameter">prepared_name</replaceable> INTO <replaceable class="parameter">sqlda_name</replaceable>
</synopsis>
<!-- pgdoc-cn_end sig_en=91833bf57de7c1c325e2d99e7fcf4776 -->
   </refsynopsisdiv>

   <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
    <title>Description</title>
________________________________________________________-->
    <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=d153ccc3ad1cd68796a9e35dedbbd08d sig_cn_org=None source=14.1 
    <para>
     <command>DESCRIBE</command> retrieves metadata information about
     the result columns contained in a prepared statement, without
     actually fetching a row.
    </para>
________________________________________________________-->
    <para>
     <command>DESCRIBE</command>检索被一个预备语句所含的结果列的元信息，而不会实际取得一行。
    </para>
<!-- pgdoc-cn_end sig_en=d153ccc3ad1cd68796a9e35dedbbd08d -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
    <title>Parameters</title>
________________________________________________________-->
    <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">prepared_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=d127ed9205815b6abf0773e65f6925a6 sig_cn_org=None source=14.1 
       <para>
        The name of a prepared statement.  This can be an SQL
        identifier or a host variable.
       </para>
________________________________________________________-->
       <para>
        一个预备语句的名称。这可以是一个 SQL 标识符或者一个主变量。
       </para>
<!-- pgdoc-cn_end sig_en=d127ed9205815b6abf0773e65f6925a6 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">descriptor_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=3f9bc680fff94c1d1e0c719ca79bfbc3 sig_cn_org=None source=14.1 
       <para>
        A descriptor name. It is case sensitive.  It can be an SQL
        identifier or a host variable.
       </para>
________________________________________________________-->
       <para>
        一个描述符名称。它是大小写敏感的。它可以是一个 SQL 标识符或者一个主变量。
       </para>
<!-- pgdoc-cn_end sig_en=3f9bc680fff94c1d1e0c719ca79bfbc3 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">sqlda_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=62b53b18b271a5d6ea3488ea580373ff sig_cn_org=None source=14.1 
       <para>
        The name of an SQLDA variable.
       </para>
________________________________________________________-->
       <para>
        一个 SQLDA 变量的名称。
       </para>
<!-- pgdoc-cn_end sig_en=62b53b18b271a5d6ea3488ea580373ff -->
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
    <title>Examples</title>
________________________________________________________-->
    <title>例子</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=799687fb61fb1860c5d0d16030f9b9ad sig_cn_org=None source=14.1 
<programlisting>
EXEC SQL ALLOCATE DESCRIPTOR mydesc;
EXEC SQL PREPARE stmt1 FROM :sql_stmt;
EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;
EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :charvar = NAME;
EXEC SQL DEALLOCATE DESCRIPTOR mydesc;
</programlisting>
________________________________________________________-->
<programlisting>
EXEC SQL ALLOCATE DESCRIPTOR mydesc;
EXEC SQL PREPARE stmt1 FROM :sql_stmt;
EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;
EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :charvar = NAME;
EXEC SQL DEALLOCATE DESCRIPTOR mydesc;
</programlisting>
<!-- pgdoc-cn_end sig_en=799687fb61fb1860c5d0d16030f9b9ad -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
    <title>Compatibility</title>
________________________________________________________-->
    <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=6507a071d7b60c44a245f3e42c9b5c3d sig_cn_org=None source=14.1 
    <para>
     <command>DESCRIBE</command> is specified in the SQL standard.
    </para>
________________________________________________________-->
    <para>
     SQL 标准中说明了<command>DESCRIBE</command>。
    </para>
<!-- pgdoc-cn_end sig_en=6507a071d7b60c44a245f3e42c9b5c3d -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8b7cc214676b443e6527e3d6bf054420 sig_cn_org=None source=14.1 
    <title>See Also</title>
________________________________________________________-->
    <title>参见</title>
<!-- pgdoc-cn_end sig_en=8b7cc214676b443e6527e3d6bf054420 -->

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"/></member>
     <member><xref linkend="ecpg-sql-get-descriptor"/></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-disconnect">
<!-- pgdoc-cn_start sig_en=84e8ceb091a37cbbb047dff2ea60d82c sig_cn_org=None source=14.1 
   <refnamediv>
    <refname>DISCONNECT</refname>
    <refpurpose>terminate a database connection</refpurpose>
   </refnamediv>
________________________________________________________-->
   <refnamediv>
    <refname>DISCONNECT</refname>
    <refpurpose>终止一个数据库连接</refpurpose>
   </refnamediv>
<!-- pgdoc-cn_end sig_en=84e8ceb091a37cbbb047dff2ea60d82c -->

   <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=acab8091177fc419174ef86ae620e693 sig_cn_org=acab8091177fc419174ef86ae620e693 source=15.7 
<synopsis>
DISCONNECT <replaceable class="parameter">connection_name</replaceable>
DISCONNECT [ CURRENT ]
DISCONNECT ALL
</synopsis>
________________________________________________________-->
<synopsis>
DISCONNECT <replaceable class="parameter">connection_name</replaceable>
DISCONNECT [ CURRENT ]
DISCONNECT ALL
</synopsis>
<!-- pgdoc-cn_end sig_en=acab8091177fc419174ef86ae620e693 -->
   </refsynopsisdiv>

   <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
    <title>Description</title>
________________________________________________________-->
    <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=70500dced229e8f482aa16b1f465813c sig_cn_org=None source=14.1 
    <para>
     <command>DISCONNECT</command> closes a connection (or all
     connections) to the database.
    </para>
________________________________________________________-->
    <para>
     <command>DISCONNECT</command>关闭一个（或者所有）到数据库的连接。
    </para>
<!-- pgdoc-cn_end sig_en=70500dced229e8f482aa16b1f465813c -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
    <title>Parameters</title>
________________________________________________________-->
    <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">connection_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=3041bdc4081f5eaf145e0713bbdbb1d1 sig_cn_org=None source=14.1 
       <para>
        A database connection name established by
        the <command>CONNECT</command> command.
       </para>
________________________________________________________-->
       <para>
        一个由<command>CONNECT</command>命令建立的数据库连接名称。
       </para>
<!-- pgdoc-cn_end sig_en=3041bdc4081f5eaf145e0713bbdbb1d1 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CURRENT</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=6f8e7900edab202d34dd58227b05bd20 sig_cn_org=None source=14.1 
       <para>
        Close the <quote>current</quote> connection, which is either
        the most recently opened connection, or the connection set by
        the <command>SET CONNECTION</command> command.  This is also
        the default if no argument is given to
        the <command>DISCONNECT</command> command.
       </para>
________________________________________________________-->
       <para>
        关闭<quote>当前的</quote>连接，它可以是最近打开的连接或者是由<command>SET CONNECTION</command>命令设置的连接。如果没有参数被传给<command>DISCONNECT</command>命令，这将是默认值。
       </para>
<!-- pgdoc-cn_end sig_en=6f8e7900edab202d34dd58227b05bd20 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ALL</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=50eca498c58783f89896a5c91efc3038 sig_cn_org=None source=14.1 
       <para>
        Close all open connections.
       </para>
________________________________________________________-->
       <para>
        关闭所有打开的连接。
       </para>
<!-- pgdoc-cn_end sig_en=50eca498c58783f89896a5c91efc3038 -->
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
    <title>Examples</title>
________________________________________________________-->
    <title>例子</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=3e8bc470bafd4cfb5da9c4b62a6e9a6e sig_cn_org=3e8bc470bafd4cfb5da9c4b62a6e9a6e source=15.7 
<programlisting>
int
main(void)
{
    EXEC SQL CONNECT TO testdb AS con1 USER testuser;
    EXEC SQL CONNECT TO testdb AS con2 USER testuser;
    EXEC SQL CONNECT TO testdb AS con3 USER testuser;

    EXEC SQL DISCONNECT CURRENT;  /* close con3          */
    EXEC SQL DISCONNECT ALL;      /* close con2 and con1 */

    return 0;
}
</programlisting>
________________________________________________________-->
<programlisting>
int
main(void)
{
    EXEC SQL CONNECT TO testdb AS con1 USER testuser;
    EXEC SQL CONNECT TO testdb AS con2 USER testuser;
    EXEC SQL CONNECT TO testdb AS con3 USER testuser;

    EXEC SQL DISCONNECT CURRENT;  /* close con3          */
    EXEC SQL DISCONNECT ALL;      /* close con2 and con1 */

    return 0;
}
</programlisting>
<!-- pgdoc-cn_end sig_en=3e8bc470bafd4cfb5da9c4b62a6e9a6e -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
    <title>Compatibility</title>
________________________________________________________-->
    <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=919cc48c18d2bceef94247bc76c3c1aa sig_cn_org=None source=14.1 
    <para>
     <command>DISCONNECT</command> is specified in the SQL standard.
    </para>
________________________________________________________-->
    <para>
     SQL 标准中说明了<command>DISCONNECT</command>。
    </para>
<!-- pgdoc-cn_end sig_en=919cc48c18d2bceef94247bc76c3c1aa -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8b7cc214676b443e6527e3d6bf054420 sig_cn_org=None source=14.1 
    <title>See Also</title>
________________________________________________________-->
    <title>参见</title>
<!-- pgdoc-cn_end sig_en=8b7cc214676b443e6527e3d6bf054420 -->

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-connect"/></member>
     <member><xref linkend="ecpg-sql-set-connection"/></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-execute-immediate">
<!-- pgdoc-cn_start sig_en=c3b7d34f9416853e77f0c07719476d45 sig_cn_org=None source=14.1 
   <refnamediv>
    <refname>EXECUTE IMMEDIATE</refname>
    <refpurpose>dynamically prepare and execute a statement</refpurpose>
   </refnamediv>
________________________________________________________-->
   <refnamediv>
    <refname>EXECUTE IMMEDIATE</refname>
    <refpurpose>动态地准备和执行一个语句</refpurpose>
   </refnamediv>
<!-- pgdoc-cn_end sig_en=c3b7d34f9416853e77f0c07719476d45 -->

   <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=570b93be641e4c85f369cdc142dcfcc5 sig_cn_org=None source=14.1 
<synopsis>
EXECUTE IMMEDIATE <replaceable class="parameter">string</replaceable>
</synopsis>
________________________________________________________-->
<synopsis>
EXECUTE IMMEDIATE <replaceable class="parameter">string</replaceable>
</synopsis>
<!-- pgdoc-cn_end sig_en=570b93be641e4c85f369cdc142dcfcc5 -->
   </refsynopsisdiv>

   <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
    <title>Description</title>
________________________________________________________-->
    <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=32fb0153563fff60ab53f03ff8685141 sig_cn_org=None source=14.1 
    <para>
     <command>EXECUTE IMMEDIATE</command> immediately prepares and
     executes a dynamically specified SQL statement, without
     retrieving result rows.
    </para>
________________________________________________________-->
    <para>
     <command>EXECUTE IMMEDIATE</command>立刻预备并且执行一个动态指定的 SQL 语句，不检索结果行。
    </para>
<!-- pgdoc-cn_end sig_en=32fb0153563fff60ab53f03ff8685141 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
    <title>Parameters</title>
________________________________________________________-->
    <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">string</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=55f31315f4863e8b4c12abb94c5e62cb sig_cn_org=None source=14.1 
       <para>
        A literal string or a host variable containing the SQL
        statement to be executed.
       </para>
________________________________________________________-->
       <para>
        包含要被执行的 SQL 语句的一个字符串或者是一个主变量。
       </para>
<!-- pgdoc-cn_end sig_en=55f31315f4863e8b4c12abb94c5e62cb -->
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
    <title>Notes</title>
________________________________________________________-->
    <title>Notes</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->

<!-- pgdoc-cn_start sig_en=fc60b01c67f4d5d14737b3b947649728 sig_cn_org=None source=14.1 
    <para>
     In typical usage, the <replaceable>string</replaceable> is a host
     variable reference to a string containing a dynamically-constructed
     SQL statement.  The case of a literal string is not very useful;
     you might as well just write the SQL statement directly, without
     the extra typing of <command>EXECUTE IMMEDIATE</command>.
    </para>
________________________________________________________-->
    <para>
     在典型用法中，<replaceable>string</replaceable>是对包含动态构造SQL语句的字符串的主机变量引用。
     文字字符串的情况不是非常有用，你也可以直接写SQL语句，而无需<command>EXECUTE IMMEDIATE</command>的额外输入。
    </para>
<!-- pgdoc-cn_end sig_en=fc60b01c67f4d5d14737b3b947649728 -->

<!-- pgdoc-cn_start sig_en=1a93607438bafccfe635ff61674a5b6f sig_cn_org=None source=14.1 
    <para>
     If you do use a literal string, keep in mind that any double quotes
     you might wish to include in the SQL statement must be written as
     octal escapes (<literal>\042</literal>) not the usual C
     idiom <literal>\"</literal>.  This is because the string is inside
     an <literal>EXEC SQL</literal> section, so the ECPG lexer parses it
     according to SQL rules not C rules.  Any embedded backslashes will
     later be handled according to C rules; but <literal>\"</literal>
     causes an immediate syntax error because it is seen as ending the
     literal.
    </para>
________________________________________________________-->
    <para>
     如果你使用文字字符串，请注意任何你可能希望在SQL语句中包括的双引号必须写为八进制转义(<literal>\042</literal>) ，而不是通常的C惯语<literal>\"</literal>。
     这是因为字符串在<literal>EXEC SQL</literal>段里面，所以ECPG 语法分析器根据SQL规则而不是C规则来解析它。
     任何内嵌的反斜杠后续将按照C规格处理；但是<literal>\"</literal>会造成直接语法错误，因为它被视为文字的终结。
    </para>
<!-- pgdoc-cn_end sig_en=1a93607438bafccfe635ff61674a5b6f -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
    <title>Examples</title>
________________________________________________________-->
    <title>例子</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=2e4f35ede683304a1aa9f4fd7bf4e70f sig_cn_org=None source=14.1 
    <para>
     Here is an example that executes an <command>INSERT</command>
     statement using <command>EXECUTE IMMEDIATE</command> and a host
     variable named <varname>command</varname>:
<programlisting>
sprintf(command, "INSERT INTO test (name, amount, letter) VALUES ('db: ''r1''', 1, 'f')");
EXEC SQL EXECUTE IMMEDIATE :command;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     这里是一个用<command>EXECUTE IMMEDIATE</command>和一个名为<varname>command</varname>的主变量执行<command>INSERT</command>语句的例子：
<programlisting>
sprintf(command, "INSERT INTO test (name, amount, letter) VALUES ('db: ''r1''', 1, 'f')");
EXEC SQL EXECUTE IMMEDIATE :command;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=2e4f35ede683304a1aa9f4fd7bf4e70f -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
    <title>Compatibility</title>
________________________________________________________-->
    <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=a6317d2d713417d21ab564d40923ba45 sig_cn_org=None source=14.1 
    <para>
     <command>EXECUTE IMMEDIATE</command> is specified in the SQL standard.
    </para>
________________________________________________________-->
    <para>
     SQL 标准中说明了<command>EXECUTE IMMEDIATE</command>。
    </para>
<!-- pgdoc-cn_end sig_en=a6317d2d713417d21ab564d40923ba45 -->
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-get-descriptor">
<!-- pgdoc-cn_start sig_en=2fc259a893f03b13e030eebdc707f6ea sig_cn_org=None source=14.1 
   <refnamediv>
    <refname>GET DESCRIPTOR</refname>
    <refpurpose>get information from an SQL descriptor area</refpurpose>
   </refnamediv>
________________________________________________________-->
   <refnamediv>
    <refname>GET DESCRIPTOR</refname>
    <refpurpose>从一个 SQL 描述符区域得到信息</refpurpose>
   </refnamediv>
<!-- pgdoc-cn_end sig_en=2fc259a893f03b13e030eebdc707f6ea -->

   <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=4d61a8f8022574b11445aec09c50f0a1 sig_cn_org=None source=14.1 
<synopsis>
GET DESCRIPTOR <replaceable class="parameter">descriptor_name</replaceable> <replaceable class="parameter">:cvariable</replaceable> = <replaceable class="parameter">descriptor_header_item</replaceable> [, ... ]
GET DESCRIPTOR <replaceable class="parameter">descriptor_name</replaceable> VALUE <replaceable class="parameter">column_number</replaceable> <replaceable class="parameter">:cvariable</replaceable> = <replaceable class="parameter">descriptor_item</replaceable> [, ... ]
</synopsis>
________________________________________________________-->
<synopsis>
GET DESCRIPTOR <replaceable class="parameter">descriptor_name</replaceable> <replaceable class="parameter">:cvariable</replaceable> = <replaceable class="parameter">descriptor_header_item</replaceable> [, ... ]
GET DESCRIPTOR <replaceable class="parameter">descriptor_name</replaceable> VALUE <replaceable class="parameter">column_number</replaceable> <replaceable class="parameter">:cvariable</replaceable> = <replaceable class="parameter">descriptor_item</replaceable> [, ... ]
</synopsis>
<!-- pgdoc-cn_end sig_en=4d61a8f8022574b11445aec09c50f0a1 -->
   </refsynopsisdiv>

   <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
    <title>Description</title>
________________________________________________________-->
    <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=3d8100b999bf4bc78cc2cace1930810f sig_cn_org=None source=14.1 
    <para>
     <command>GET DESCRIPTOR</command> retrieves information about a
     query result set from an SQL descriptor area and stores it into
     host variables.  A descriptor area is typically populated
     using <command>FETCH</command> or <command>SELECT</command>
     before using this command to transfer the information into host
     language variables.
    </para>
________________________________________________________-->
    <para>
     <command>GET DESCRIPTOR</command>从一个 SQL 描述符区域检索关于一个查询结果集的信息并且把它存储在主变量中。在使用这个命令把信息传输到主语言变量之前，一个描述符区域通常是用<command>FETCH</command>或<command>SELECT</command>填充的。
    </para>
<!-- pgdoc-cn_end sig_en=3d8100b999bf4bc78cc2cace1930810f -->

<!-- pgdoc-cn_start sig_en=5cec35d51bf799d00444076c67ae31a9 sig_cn_org=None source=14.1 
    <para>
     This command has two forms: The first form retrieves
     descriptor <quote>header</quote> items, which apply to the result
     set in its entirety.  One example is the row count.  The second
     form, which requires the column number as additional parameter,
     retrieves information about a particular column.  Examples are
     the column name and the actual column value.
    </para>
________________________________________________________-->
    <para>
     这个命令有两种形式：第一种形式检索描述符的<quote>头部</quote>项，它适用于全面地查看结果集。一种例子是行计数。第二种形式要求列号作为附加参数，它检索有关一个特定列的信息。其例子是查看列名和实际列值。
    </para>
<!-- pgdoc-cn_end sig_en=5cec35d51bf799d00444076c67ae31a9 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
    <title>Parameters</title>
________________________________________________________-->
    <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">descriptor_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=58074bf544a620056afa2476b89a8a83 sig_cn_org=None source=14.1 
       <para>
        A descriptor name.
       </para>
________________________________________________________-->
       <para>
        一个描述符名称。
       </para>
<!-- pgdoc-cn_end sig_en=58074bf544a620056afa2476b89a8a83 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">descriptor_header_item</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=7908d902d5a3fc4c7dcd6772b61c1490 sig_cn_org=None source=14.1 
       <para>
        A token identifying which header information item to retrieve.
        Only <literal>COUNT</literal>, to get the number of columns in the
        result set, is currently supported.
       </para>
________________________________________________________-->
       <para>
        一个标识要检索哪一个头部信息项的记号。当前只支持用于得到结果集中列数的<literal>COUNT</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=7908d902d5a3fc4c7dcd6772b61c1490 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">column_number</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=a58798bca77673f9a3e082c8460fdb99 sig_cn_org=None source=14.1 
       <para>
        The number of the column about which information is to be
        retrieved.  The count starts at 1.
       </para>
________________________________________________________-->
       <para>
        要检索其信息的列号。计数从 1 开始。
       </para>
<!-- pgdoc-cn_end sig_en=a58798bca77673f9a3e082c8460fdb99 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">descriptor_item</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=faebbbf6116c7f500ae487624d548b0d sig_cn_org=None source=14.1 
       <para>
        A token identifying which item of information about a column
        to retrieve.  See <xref linkend="ecpg-named-descriptors"/> for
        a list of supported items.
       </para>
________________________________________________________-->
       <para>
        一个标识要检索哪一个有关一列信息的项的记号。被支持的项可见<xref linkend="ecpg-named-descriptors"/>。
       </para>
<!-- pgdoc-cn_end sig_en=faebbbf6116c7f500ae487624d548b0d -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">cvariable</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=02f4f1bb93bdb66448046fd2af35da6f sig_cn_org=None source=14.1 
       <para>
        A host variable that will receive the data retrieved from the
        descriptor area.
       </para>
________________________________________________________-->
       <para>
        接收从描述符区域检索到的数据的主变量。
       </para>
<!-- pgdoc-cn_end sig_en=02f4f1bb93bdb66448046fd2af35da6f -->
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
    <title>Examples</title>
________________________________________________________-->
    <title>例子</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=ca5980381ca7ac48e4d3568d3d3264bc sig_cn_org=None source=14.1 
    <para>
     An example to retrieve the number of columns in a result set:
<programlisting>
EXEC SQL GET DESCRIPTOR d :d_count = COUNT;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     检索一个结果集中列数的例子：
<programlisting>
EXEC SQL GET DESCRIPTOR d :d_count = COUNT;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=ca5980381ca7ac48e4d3568d3d3264bc -->

<!-- pgdoc-cn_start sig_en=1f32b8f34e7c89ce4f364e874eceacb6 sig_cn_org=None source=14.1 
    <para>
     An example to retrieve a data length in the first column:
<programlisting>
EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     检索第一列中数据长度的例子：
<programlisting>
EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=1f32b8f34e7c89ce4f364e874eceacb6 -->

<!-- pgdoc-cn_start sig_en=ea1aad882da1ec03c657380eccdca680 sig_cn_org=None source=14.1 
    <para>
     An example to retrieve the data body of the second column as a
     string:
<programlisting>
EXEC SQL GET DESCRIPTOR d VALUE 2 :d_data = DATA;
</programlisting>
    </para>
________________________________________________________-->
    <para>
     把第二列的数据体检索成一个字符串的例子：
<programlisting>
EXEC SQL GET DESCRIPTOR d VALUE 2 :d_data = DATA;
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=ea1aad882da1ec03c657380eccdca680 -->

<!-- pgdoc-cn_start sig_en=409856675fa3a2e0c7a012bf04b998d2 sig_cn_org=None source=14.1 
    <para>
     Here is an example for a whole procedure of
     executing <literal>SELECT current_database();</literal> and showing the number of
     columns, the column data length, and the column data:
<programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    int  d_count;
    char d_data[1024];
    int  d_returned_octet_length;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1 USER testuser;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
    EXEC SQL ALLOCATE DESCRIPTOR d;

    /* Declare, open a cursor, and assign a descriptor to the cursor  */
    EXEC SQL DECLARE cur CURSOR FOR SELECT current_database();
    EXEC SQL OPEN cur;
    EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;

    /* Get a number of total columns */
    EXEC SQL GET DESCRIPTOR d :d_count = COUNT;
    printf("d_count                 = %d\n", d_count);

    /* Get length of a returned column */
    EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;
    printf("d_returned_octet_length = %d\n", d_returned_octet_length);

    /* Fetch the returned column as a string */
    EXEC SQL GET DESCRIPTOR d VALUE 1 :d_data = DATA;
    printf("d_data                  = %s\n", d_data);

    /* Closing */
    EXEC SQL CLOSE cur;
    EXEC SQL COMMIT;

    EXEC SQL DEALLOCATE DESCRIPTOR d;
    EXEC SQL DISCONNECT ALL;

    return 0;
}
</programlisting>
     When the example is executed, the result will look like this:
<screen>
d_count                 = 1
d_returned_octet_length = 6
d_data                  = testdb
</screen>
    </para>
________________________________________________________-->
    <para>
     这里是执行<literal>SELECT current_database();</literal>并且显示列数、列数据长度和列数据的完整过程的例子：
<programlisting>
int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    int  d_count;
    char d_data[1024];
    int  d_returned_octet_length;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1 USER testuser;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
    EXEC SQL ALLOCATE DESCRIPTOR d;

    /* 描述、打开一个游标，并且分配一个描述符给该游标  */
    EXEC SQL DECLARE cur CURSOR FOR SELECT current_database();
    EXEC SQL OPEN cur;
    EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;

    /* 得到全部列的数量 */
    EXEC SQL GET DESCRIPTOR d :d_count = COUNT;
    printf("d_count                 = %d\n", d_count);

    /* 得到一个返回列的长度 */
    EXEC SQL GET DESCRIPTOR d VALUE 1 :d_returned_octet_length = RETURNED_OCTET_LENGTH;
    printf("d_returned_octet_length = %d\n", d_returned_octet_length);

    /* 将返回的列取出成一个字符串 */
    EXEC SQL GET DESCRIPTOR d VALUE 1 :d_data = DATA;
    printf("d_data                  = %s\n", d_data);

    /* 关闭 */
    EXEC SQL CLOSE cur;
    EXEC SQL COMMIT;

    EXEC SQL DEALLOCATE DESCRIPTOR d;
    EXEC SQL DISCONNECT ALL;

    return 0;
}
</programlisting>
     当该例子被执行时，结果看起来是：
<screen>
d_count                 = 1
d_returned_octet_length = 6
d_data                  = testdb
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=409856675fa3a2e0c7a012bf04b998d2 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
    <title>Compatibility</title>
________________________________________________________-->
    <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=80f21920ab41f16423f5c9612f856782 sig_cn_org=None source=14.1 
    <para>
     <command>GET DESCRIPTOR</command> is specified in the SQL standard.
    </para>
________________________________________________________-->
    <para>
     SQL 标准中说明了<command>GET DESCRIPTOR</command>。
    </para>
<!-- pgdoc-cn_end sig_en=80f21920ab41f16423f5c9612f856782 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8b7cc214676b443e6527e3d6bf054420 sig_cn_org=None source=14.1 
    <title>See Also</title>
________________________________________________________-->
    <title>参见</title>
<!-- pgdoc-cn_end sig_en=8b7cc214676b443e6527e3d6bf054420 -->

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"/></member>
     <member><xref linkend="ecpg-sql-set-descriptor"/></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-open">
<!-- pgdoc-cn_start sig_en=56784286aae9865876c122b9011e130a sig_cn_org=None source=14.1 
   <refnamediv>
    <refname>OPEN</refname>
    <refpurpose>open a dynamic cursor</refpurpose>
   </refnamediv>
________________________________________________________-->
   <refnamediv>
    <refname>OPEN</refname>
    <refpurpose>打开一个动态游标</refpurpose>
   </refnamediv>
<!-- pgdoc-cn_end sig_en=56784286aae9865876c122b9011e130a -->

   <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=cd8ed2dd2aaff5c754e4987da6ae756f sig_cn_org=None source=14.1 
<synopsis>
OPEN <replaceable class="parameter">cursor_name</replaceable>
OPEN <replaceable class="parameter">cursor_name</replaceable> USING <replaceable class="parameter">value</replaceable> [, ... ]
OPEN <replaceable class="parameter">cursor_name</replaceable> USING SQL DESCRIPTOR <replaceable class="parameter">descriptor_name</replaceable>
</synopsis>
________________________________________________________-->
<synopsis>
OPEN <replaceable class="parameter">cursor_name</replaceable>
OPEN <replaceable class="parameter">cursor_name</replaceable> USING <replaceable class="parameter">value</replaceable> [, ... ]
OPEN <replaceable class="parameter">cursor_name</replaceable> USING SQL DESCRIPTOR <replaceable class="parameter">descriptor_name</replaceable>
</synopsis>
<!-- pgdoc-cn_end sig_en=cd8ed2dd2aaff5c754e4987da6ae756f -->
   </refsynopsisdiv>

   <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
    <title>Description</title>
________________________________________________________-->
    <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=3bde29ccb5e9efb847d60e7454c4d11b sig_cn_org=None source=14.1 
    <para>
     <command>OPEN</command> opens a cursor and optionally binds
     actual values to the placeholders in the cursor's declaration.
     The cursor must previously have been declared with
     the <command>DECLARE</command> command.  The execution
     of <command>OPEN</command> causes the query to start executing on
     the server.
    </para>
________________________________________________________-->
    <para>
     <command>OPEN</command>打开一个游标并且可选地绑定实际值到游标声明中的占位符。该游标必须之前用<command>DECLARE</command>命令声明。<command>OPEN</command>的执行会导致查询开始在服务器上执行。
    </para>
<!-- pgdoc-cn_end sig_en=3bde29ccb5e9efb847d60e7454c4d11b -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
    <title>Parameters</title>
________________________________________________________-->
    <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">cursor_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=94c8e0581c28365b1a89d6b8d4dca81d sig_cn_org=None source=14.1 
       <para>
        The name of the cursor to be opened.  This can be an SQL
        identifier or a host variable.
       </para>
________________________________________________________-->
       <para>
        要被打开的游标的名称。这可以是一个 SQL 标识符或者一个主变量。
       </para>
<!-- pgdoc-cn_end sig_en=94c8e0581c28365b1a89d6b8d4dca81d -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">value</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=665573ad1c83d7d713fe4bb1ab8ad175 sig_cn_org=None source=14.1 
       <para>
        A value to be bound to a placeholder in the cursor.  This can
        be an SQL constant, a host variable, or a host variable with
        indicator.
       </para>
________________________________________________________-->
       <para>
        要被绑定到游标中一个占位符的值。这可以是一个 SQL 常量、一个主变量或者一个带有指示符的主变量。
       </para>
<!-- pgdoc-cn_end sig_en=665573ad1c83d7d713fe4bb1ab8ad175 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">descriptor_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=bc5356d3aeaa69f1cb0d806bd96a7dec sig_cn_org=None source=14.1 
       <para>
        The name of a descriptor containing values to be bound to the
        placeholders in the cursor.  This can be an SQL identifier or
        a host variable.
       </para>
________________________________________________________-->
       <para>
        包含要绑定到游标中占位符的值的描述符的名称。这可以是一个 SQL 标识符或者一个主变量。
       </para>
<!-- pgdoc-cn_end sig_en=bc5356d3aeaa69f1cb0d806bd96a7dec -->
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
    <title>Examples</title>
________________________________________________________-->
    <title>例子</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=e8e8ee4547a027ace6ccacaa9a12901a sig_cn_org=None source=14.1 
<programlisting>
EXEC SQL OPEN a;
EXEC SQL OPEN d USING 1, 'test';
EXEC SQL OPEN c1 USING SQL DESCRIPTOR mydesc;
EXEC SQL OPEN :curname1;
</programlisting>
________________________________________________________-->
<programlisting>
EXEC SQL OPEN a;
EXEC SQL OPEN d USING 1, 'test';
EXEC SQL OPEN c1 USING SQL DESCRIPTOR mydesc;
EXEC SQL OPEN :curname1;
</programlisting>
<!-- pgdoc-cn_end sig_en=e8e8ee4547a027ace6ccacaa9a12901a -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
    <title>Compatibility</title>
________________________________________________________-->
    <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=992527eb03755a94ce9d296c53932dd7 sig_cn_org=None source=14.1 
    <para>
     <command>OPEN</command> is specified in the SQL standard.
    </para>
________________________________________________________-->
    <para>
     SQL 标准中说明了<command>OPEN</command>。
    </para>
<!-- pgdoc-cn_end sig_en=992527eb03755a94ce9d296c53932dd7 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8b7cc214676b443e6527e3d6bf054420 sig_cn_org=None source=14.1 
    <title>See Also</title>
________________________________________________________-->
    <title>参见</title>
<!-- pgdoc-cn_end sig_en=8b7cc214676b443e6527e3d6bf054420 -->

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-declare"/></member>
     <member><xref linkend="sql-close"/></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-prepare">
<!-- pgdoc-cn_start sig_en=3a254b2146cc9e667be318a5013b4321 sig_cn_org=None source=14.1 
   <refnamediv>
    <refname>PREPARE</refname>
    <refpurpose>prepare a statement for execution</refpurpose>
   </refnamediv>
________________________________________________________-->
   <refnamediv>
    <refname>PREPARE</refname>
    <refpurpose>准备一个语句用于执行</refpurpose>
   </refnamediv>
<!-- pgdoc-cn_end sig_en=3a254b2146cc9e667be318a5013b4321 -->

   <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=cf91d1e2c6ea504a8740451fc61243b0 sig_cn_org=None source=14.1 
<synopsis>
PREPARE <replaceable class="parameter">prepared_name</replaceable> FROM <replaceable class="parameter">string</replaceable>
</synopsis>
________________________________________________________-->
<synopsis>
PREPARE <replaceable class="parameter">prepared_name</replaceable> FROM <replaceable class="parameter">string</replaceable>
</synopsis>
<!-- pgdoc-cn_end sig_en=cf91d1e2c6ea504a8740451fc61243b0 -->
   </refsynopsisdiv>

   <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
    <title>Description</title>
________________________________________________________-->
    <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=532d07108e742d6fb8c24d123d93a6c4 sig_cn_org=None source=14.1 
    <para>
     <command>PREPARE</command> prepares a statement dynamically
     specified as a string for execution.  This is different from the
     direct SQL statement <xref linkend="sql-prepare"/>, which can also
     be used in embedded programs.  The <xref linkend="sql-execute"/>
     command is used to execute either kind of prepared statement.
    </para>
________________________________________________________-->
    <para>
     <command>PREPARE</command>将一个作为字符串动态指定的语句准备好执行。这不同于直接的 SQL 语句<xref linkend="sql-prepare"/>（也可以用于嵌入式程序）。<xref linkend="sql-execute"/>命令被用来执行两种类型的预备语句。
    </para>
<!-- pgdoc-cn_end sig_en=532d07108e742d6fb8c24d123d93a6c4 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
    <title>Parameters</title>
________________________________________________________-->
    <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">prepared_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=e7783f40e8dea1905e056d6b2458a366 sig_cn_org=None source=14.1 
       <para>
        An identifier for the prepared query.
       </para>
________________________________________________________-->
       <para>
        预备查询的一个标识符。
       </para>
<!-- pgdoc-cn_end sig_en=e7783f40e8dea1905e056d6b2458a366 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">string</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=f86a58afc162feef2c40d996a2280604 sig_cn_org=None source=14.1 
       <para>
        A literal string or a host variable containing a preparable
        SQL statement, one of SELECT, INSERT, UPDATE, or DELETE.
        Use question marks (<literal>?</literal>) for parameter values
        to be supplied at execution.
       </para>
________________________________________________________-->
       <para>
        包含一个可预备语句的一个字符串或一个主变量，可预备语句是 SELECT、INSERT、UPDATE 或者 DELETE 之一。
        对于执行时提供的参数值，使用问号(<literal>?</literal>)。
       </para>
<!-- pgdoc-cn_end sig_en=f86a58afc162feef2c40d996a2280604 -->
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
    <title>Notes</title>
________________________________________________________-->
    <title>Notes</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->

<!-- pgdoc-cn_start sig_en=0ca3db7391224ebf59d49490473b9f3c sig_cn_org=None source=14.1 
    <para>
     In typical usage, the <replaceable>string</replaceable> is a host
     variable reference to a string containing a dynamically-constructed
     SQL statement.  The case of a literal string is not very useful;
     you might as well just write a direct SQL <command>PREPARE</command>
     statement.
    </para>
________________________________________________________-->
    <para>
     在典型用法中，<replaceable>string</replaceable>是对包含动态构造SQL语句的字符串的主机变量引用。
     文字字符串的情况不是很有用；你也可以写一条直接SQL <command>PREPARE</command>语句。
    </para>
<!-- pgdoc-cn_end sig_en=0ca3db7391224ebf59d49490473b9f3c -->

<!-- pgdoc-cn_start sig_en=1a93607438bafccfe635ff61674a5b6f sig_cn_org=None source=14.1 
    <para>
     If you do use a literal string, keep in mind that any double quotes
     you might wish to include in the SQL statement must be written as
     octal escapes (<literal>\042</literal>) not the usual C
     idiom <literal>\"</literal>.  This is because the string is inside
     an <literal>EXEC SQL</literal> section, so the ECPG lexer parses it
     according to SQL rules not C rules.  Any embedded backslashes will
     later be handled according to C rules; but <literal>\"</literal>
     causes an immediate syntax error because it is seen as ending the
     literal.
    </para>
________________________________________________________-->
    <para>
     如果你使用文字字符串，请注意任何你可能希望在SQL语句中包括的双引号必须写为八进制转义(<literal>\042</literal>) ，而不是通常的C惯语<literal>\"</literal>。
     这是因为字符串在<literal>EXEC SQL</literal>段里面，所以ECPG 语法分析器根据SQL规则而不是C规则来解析它。
     任何内嵌的反斜杠后续将按照C规格处理；但是<literal>\"</literal>会造成直接语法错误，因为它被视为文字的终结。
    </para>
<!-- pgdoc-cn_end sig_en=1a93607438bafccfe635ff61674a5b6f -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
    <title>Examples</title>
________________________________________________________-->
    <title>例子</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->
<!-- pgdoc-cn_start sig_en=842b61acde9c9aeb5ed34b8dc2097419 sig_cn_org=None source=14.1 
<programlisting>
char *stmt = "SELECT * FROM test1 WHERE a = ? AND b = ?";

EXEC SQL ALLOCATE DESCRIPTOR outdesc;
EXEC SQL PREPARE foo FROM :stmt;

EXEC SQL EXECUTE foo USING SQL DESCRIPTOR indesc INTO SQL DESCRIPTOR outdesc;
</programlisting>
________________________________________________________-->
<programlisting>
char *stmt = "SELECT * FROM test1 WHERE a = ? AND b = ?";

EXEC SQL ALLOCATE DESCRIPTOR outdesc;
EXEC SQL PREPARE foo FROM :stmt;

EXEC SQL EXECUTE foo USING SQL DESCRIPTOR indesc INTO SQL DESCRIPTOR outdesc;
</programlisting>
<!-- pgdoc-cn_end sig_en=842b61acde9c9aeb5ed34b8dc2097419 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
    <title>Compatibility</title>
________________________________________________________-->
    <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=50ca0e03f97e6354f4cf00d20bb91ee7 sig_cn_org=None source=14.1 
    <para>
     <command>PREPARE</command> is specified in the SQL standard.
    </para>
________________________________________________________-->
    <para>
     SQL 标准中说明了<command>PREPARE</command>。
    </para>
<!-- pgdoc-cn_end sig_en=50ca0e03f97e6354f4cf00d20bb91ee7 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8b7cc214676b443e6527e3d6bf054420 sig_cn_org=None source=14.1 
    <title>See Also</title>
________________________________________________________-->
    <title>参见</title>
<!-- pgdoc-cn_end sig_en=8b7cc214676b443e6527e3d6bf054420 -->

    <simplelist type="inline">
     <member><xref linkend="sql-execute"/></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-set-autocommit">
<!-- pgdoc-cn_start sig_en=df934d1dd8b6a384d384b5a038b82bc7 sig_cn_org=None source=14.1 
   <refnamediv>
    <refname>SET AUTOCOMMIT</refname>
    <refpurpose>set the autocommit behavior of the current session</refpurpose>
   </refnamediv>
________________________________________________________-->
   <refnamediv>
    <refname>SET AUTOCOMMIT</refname>
    <refpurpose>设置当前会话的自动提交行为</refpurpose>
   </refnamediv>
<!-- pgdoc-cn_end sig_en=df934d1dd8b6a384d384b5a038b82bc7 -->

   <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=7c18e215878bbc093e6dc42a7d590aba sig_cn_org=None source=14.1 
<synopsis>
SET AUTOCOMMIT { = | TO } { ON | OFF }
</synopsis>
________________________________________________________-->
<synopsis>
SET AUTOCOMMIT { = | TO } { ON | OFF }
</synopsis>
<!-- pgdoc-cn_end sig_en=7c18e215878bbc093e6dc42a7d590aba -->
   </refsynopsisdiv>

   <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
    <title>Description</title>
________________________________________________________-->
    <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=3b2d2c643c2bddff41543ccc59deebbc sig_cn_org=None source=14.1 
    <para>
     <command>SET AUTOCOMMIT</command> sets the autocommit behavior of
     the current database session.  By default, embedded SQL programs
     are <emphasis>not</emphasis> in autocommit mode,
     so <command>COMMIT</command> needs to be issued explicitly when
     desired.  This command can change the session to autocommit mode,
     where each individual statement is committed implicitly.
    </para>
________________________________________________________-->
    <para>
     <command>SET AUTOCOMMIT</command>设置当前数据库会话的自动提交行为。默认情况下，嵌入式 SQL 程序<emphasis>不</emphasis>在自动提交模式中，因此需要显式地发出<command>COMMIT</command>。这个命令可以把会话改成自动提交模式，这样每一个单独的语句都会被隐式提交。
    </para>
<!-- pgdoc-cn_end sig_en=3b2d2c643c2bddff41543ccc59deebbc -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
    <title>Compatibility</title>
________________________________________________________-->
    <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=02df5374a1455c2fac8993fe9d7c9e30 sig_cn_org=None source=14.1 
    <para>
     <command>SET AUTOCOMMIT</command> is an extension of PostgreSQL ECPG.
    </para>
________________________________________________________-->
    <para>
     <command>SET AUTOCOMMIT</command>是 PostgreSQL ECPG 的扩展。
    </para>
<!-- pgdoc-cn_end sig_en=02df5374a1455c2fac8993fe9d7c9e30 -->
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-set-connection">
<!-- pgdoc-cn_start sig_en=f919ee14dcccb04489f56a0a06e8d8f5 sig_cn_org=None source=14.1 
   <refnamediv>
    <refname>SET CONNECTION</refname>
    <refpurpose>select a database connection</refpurpose>
   </refnamediv>
________________________________________________________-->
   <refnamediv>
    <refname>SET CONNECTION</refname>
    <refpurpose>选择一个数据库连接</refpurpose>
   </refnamediv>
<!-- pgdoc-cn_end sig_en=f919ee14dcccb04489f56a0a06e8d8f5 -->

   <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=421fb095f16c0b846fe4710289077b98 sig_cn_org=None source=14.1 
<synopsis>
SET CONNECTION [ TO | = ] <replaceable class="parameter">connection_name</replaceable>
</synopsis>
________________________________________________________-->
<synopsis>
SET CONNECTION [ TO | = ] <replaceable class="parameter">connection_name</replaceable>
</synopsis>
<!-- pgdoc-cn_end sig_en=421fb095f16c0b846fe4710289077b98 -->
   </refsynopsisdiv>

   <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
    <title>Description</title>
________________________________________________________-->
    <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=236994cca50113d99fb951fa81162c90 sig_cn_org=None source=14.1 
    <para>
     <command>SET CONNECTION</command> sets the <quote>current</quote>
     database connection, which is the one that all commands use
     unless overridden.
    </para>
________________________________________________________-->
    <para>
     <command>SET CONNECTION</command>设置<quote>当前的</quote>数据库连接，除非被覆盖，所有命令都会使用这个连接。
    </para>
<!-- pgdoc-cn_end sig_en=236994cca50113d99fb951fa81162c90 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
    <title>Parameters</title>
________________________________________________________-->
    <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">connection_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=3041bdc4081f5eaf145e0713bbdbb1d1 sig_cn_org=None source=14.1 
       <para>
        A database connection name established by
        the <command>CONNECT</command> command.
       </para>
________________________________________________________-->
       <para>
        一个由<command>CONNECT</command>命令建立的数据库连接名称。
       </para>
<!-- pgdoc-cn_end sig_en=3041bdc4081f5eaf145e0713bbdbb1d1 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CURRENT</literal></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=ce9d4700f3c98e549df2a9f04aa2f6b8 sig_cn_org=fcb5044cb85d8264f34be46cff98146e source=15.7 
       <para>
        Set the connection to the current connection (thus, nothing happens).
       </para>
________________________________________________________-->
       <para>
        将连接设置为当前连接（因此，什么也不会发生）。
       </para>
<!-- pgdoc-cn_end sig_en=ce9d4700f3c98e549df2a9f04aa2f6b8 -->
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
    <title>Examples</title>
________________________________________________________-->
    <title>例子</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=6966282a44e1805423f40aaa0489a2cf sig_cn_org=None source=14.1 
<programlisting>
EXEC SQL SET CONNECTION TO con2;
EXEC SQL SET CONNECTION = con1;
</programlisting>
________________________________________________________-->
<programlisting>
EXEC SQL SET CONNECTION TO con2;
EXEC SQL SET CONNECTION = con1;
</programlisting>
<!-- pgdoc-cn_end sig_en=6966282a44e1805423f40aaa0489a2cf -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
    <title>Compatibility</title>
________________________________________________________-->
    <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=b6c13e550689dc4bd744b5e454bfc450 sig_cn_org=None source=14.1 
    <para>
     <command>SET CONNECTION</command> is specified in the SQL standard.
    </para>
________________________________________________________-->
    <para>
     SQL 标准中说明了<command>SET CONNECTION</command>。
    </para>
<!-- pgdoc-cn_end sig_en=b6c13e550689dc4bd744b5e454bfc450 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8b7cc214676b443e6527e3d6bf054420 sig_cn_org=None source=14.1 
    <title>See Also</title>
________________________________________________________-->
    <title>参见</title>
<!-- pgdoc-cn_end sig_en=8b7cc214676b443e6527e3d6bf054420 -->

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-connect"/></member>
     <member><xref linkend="ecpg-sql-disconnect"/></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-set-descriptor">
<!-- pgdoc-cn_start sig_en=4f7ce58ce57c365796b792e0a7155779 sig_cn_org=None source=14.1 
   <refnamediv>
    <refname>SET DESCRIPTOR</refname>
    <refpurpose>set information in an SQL descriptor area</refpurpose>
   </refnamediv>
________________________________________________________-->
   <refnamediv>
    <refname>SET DESCRIPTOR</refname>
    <refpurpose>在一个 SQL 描述符区域中设置信息</refpurpose>
   </refnamediv>
<!-- pgdoc-cn_end sig_en=4f7ce58ce57c365796b792e0a7155779 -->

   <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=3f23e912c5a06c3853f092033ace37c9 sig_cn_org=None source=14.1 
<synopsis>
SET DESCRIPTOR <replaceable class="parameter">descriptor_name</replaceable> <replaceable class="parameter">descriptor_header_item</replaceable> = <replaceable>value</replaceable> [, ... ]
SET DESCRIPTOR <replaceable class="parameter">descriptor_name</replaceable> VALUE <replaceable class="parameter">number</replaceable> <replaceable class="parameter">descriptor_item</replaceable> = <replaceable>value</replaceable> [, ...]
</synopsis>
________________________________________________________-->
<synopsis>
SET DESCRIPTOR <replaceable class="parameter">descriptor_name</replaceable> <replaceable class="parameter">descriptor_header_item</replaceable> = <replaceable>value</replaceable> [, ... ]
SET DESCRIPTOR <replaceable class="parameter">descriptor_name</replaceable> VALUE <replaceable class="parameter">number</replaceable> <replaceable class="parameter">descriptor_item</replaceable> = <replaceable>value</replaceable> [, ...]
</synopsis>
<!-- pgdoc-cn_end sig_en=3f23e912c5a06c3853f092033ace37c9 -->
   </refsynopsisdiv>

   <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
    <title>Description</title>
________________________________________________________-->
    <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=8d30f9bdf03de35f982b6dea26dbaa75 sig_cn_org=None source=14.1 
    <para>
     <command>SET DESCRIPTOR</command> populates an SQL descriptor
     area with values.  The descriptor area is then typically used to
     bind parameters in a prepared query execution.
    </para>
________________________________________________________-->
    <para>
     <command>SET DESCRIPTOR</command>用值填充一个 SQL 描述符区域。然后该描述符区域通常会被用来在一个预备查询执行中绑定参数。
    </para>
<!-- pgdoc-cn_end sig_en=8d30f9bdf03de35f982b6dea26dbaa75 -->

<!-- pgdoc-cn_start sig_en=3f71265b89d20329bcb91d9f1a7d0458 sig_cn_org=None source=14.1 
    <para>
     This command has two forms: The first form applies to the
     descriptor <quote>header</quote>, which is independent of a
     particular datum.  The second form assigns values to particular
     datums, identified by number.
    </para>
________________________________________________________-->
    <para>
     这个命令由两种形式：第一种形式适用于描述符<quote>头部</quote>，它独立于特定的数据。第二种形式为由数字标识的特定数据赋值。
    </para>
<!-- pgdoc-cn_end sig_en=3f71265b89d20329bcb91d9f1a7d0458 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
    <title>Parameters</title>
________________________________________________________-->
    <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">descriptor_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=58074bf544a620056afa2476b89a8a83 sig_cn_org=None source=14.1 
       <para>
        A descriptor name.
       </para>
________________________________________________________-->
       <para>
        一个描述符名称。
       </para>
<!-- pgdoc-cn_end sig_en=58074bf544a620056afa2476b89a8a83 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">descriptor_header_item</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=f9430dfc6379c18724677a41abf10018 sig_cn_org=None source=14.1 
       <para>
        A token identifying which header information item to set.
        Only <literal>COUNT</literal>, to set the number of descriptor
        items, is currently supported.
       </para>
________________________________________________________-->
       <para>
        一个标识要设置哪个头部信息项的记号。当前只有设置描述符项数量的<literal>COUNT</literal>被支持。
       </para>
<!-- pgdoc-cn_end sig_en=f9430dfc6379c18724677a41abf10018 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">number</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=a68601ffd79a8b478ae3e9eda8cfedd9 sig_cn_org=None source=14.1 
       <para>
        The number of the descriptor item to set.  The count starts at
        1.
       </para>
________________________________________________________-->
       <para>
        要设置的描述符项的编号。计数从 1 开始。
       </para>
<!-- pgdoc-cn_end sig_en=a68601ffd79a8b478ae3e9eda8cfedd9 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">descriptor_item</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=1432900d7a8e89c87a6985f888b26663 sig_cn_org=None source=14.1 
       <para>
        A token identifying which item of information to set in the
        descriptor.  See <xref linkend="ecpg-named-descriptors"/> for a
        list of supported items.
       </para>
________________________________________________________-->
       <para>
        一个标识在描述符中要设置哪个信息项的记号。受支持的项的列表可见<xref linkend="ecpg-named-descriptors"/>。
       </para>
<!-- pgdoc-cn_end sig_en=1432900d7a8e89c87a6985f888b26663 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">value</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=2ddcedc5c33529fd0f5706a518701fd1 sig_cn_org=None source=14.1 
       <para>
        A value to store into the descriptor item.  This can be an SQL
        constant or a host variable.
       </para>
________________________________________________________-->
       <para>
        一个要存储在描述符项中的值。这可以是一个 SQL 标识符或者一个主变量。
       </para>
<!-- pgdoc-cn_end sig_en=2ddcedc5c33529fd0f5706a518701fd1 -->
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
    <title>Examples</title>
________________________________________________________-->
    <title>例子</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->
<!-- pgdoc-cn_start sig_en=70b6f73978080e2f4fb18bf11360b112 sig_cn_org=None source=14.1 
<programlisting>
EXEC SQL SET DESCRIPTOR indesc COUNT = 1;
EXEC SQL SET DESCRIPTOR indesc VALUE 1 DATA = 2;
EXEC SQL SET DESCRIPTOR indesc VALUE 1 DATA = :val1;
EXEC SQL SET DESCRIPTOR indesc VALUE 2 INDICATOR = :val1, DATA = 'some string';
EXEC SQL SET DESCRIPTOR indesc VALUE 2 INDICATOR = :val2null, DATA = :val2;
</programlisting>
________________________________________________________-->
<programlisting>
EXEC SQL SET DESCRIPTOR indesc COUNT = 1;
EXEC SQL SET DESCRIPTOR indesc VALUE 1 DATA = 2;
EXEC SQL SET DESCRIPTOR indesc VALUE 1 DATA = :val1;
EXEC SQL SET DESCRIPTOR indesc VALUE 2 INDICATOR = :val1, DATA = 'some string';
EXEC SQL SET DESCRIPTOR indesc VALUE 2 INDICATOR = :val2null, DATA = :val2;
</programlisting>
<!-- pgdoc-cn_end sig_en=70b6f73978080e2f4fb18bf11360b112 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
    <title>Compatibility</title>
________________________________________________________-->
    <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=7b9fc250c216dc7def7174d8136e10d7 sig_cn_org=None source=14.1 
    <para>
     <command>SET DESCRIPTOR</command> is specified in the SQL standard.
    </para>
________________________________________________________-->
    <para>
     SQL 标准中说明了<command>SET DESCRIPTOR</command>。
    </para>
<!-- pgdoc-cn_end sig_en=7b9fc250c216dc7def7174d8136e10d7 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8b7cc214676b443e6527e3d6bf054420 sig_cn_org=None source=14.1 
    <title>See Also</title>
________________________________________________________-->
    <title>参见</title>
<!-- pgdoc-cn_end sig_en=8b7cc214676b443e6527e3d6bf054420 -->

    <simplelist type="inline">
     <member><xref linkend="ecpg-sql-allocate-descriptor"/></member>
     <member><xref linkend="ecpg-sql-get-descriptor"/></member>
    </simplelist>
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-type">
<!-- pgdoc-cn_start sig_en=8a02589a6c6e87bc78bd71444b7d1659 sig_cn_org=None source=14.1 
   <refnamediv>
    <refname>TYPE</refname>
    <refpurpose>define a new data type</refpurpose>
   </refnamediv>
________________________________________________________-->
   <refnamediv>
    <refname>TYPE</refname>
    <refpurpose>定义一种新数据类型</refpurpose>
   </refnamediv>
<!-- pgdoc-cn_end sig_en=8a02589a6c6e87bc78bd71444b7d1659 -->

   <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=bffc766d987846cc773a6d2765e121d6 sig_cn_org=None source=14.1 
<synopsis>
TYPE <replaceable class="parameter">type_name</replaceable> IS <replaceable class="parameter">ctype</replaceable>
</synopsis>
________________________________________________________-->
<synopsis>
TYPE <replaceable class="parameter">type_name</replaceable> IS <replaceable class="parameter">ctype</replaceable>
</synopsis>
<!-- pgdoc-cn_end sig_en=bffc766d987846cc773a6d2765e121d6 -->
   </refsynopsisdiv>

   <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
    <title>Description</title>
________________________________________________________-->
    <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=216720c9dc9956b39448ffa060962773 sig_cn_org=None source=14.1 
    <para>
     The <command>TYPE</command> command defines a new C type.  It is
     equivalent to putting a <literal>typedef</literal> into a declare
     section.
    </para>
________________________________________________________-->
    <para>
     <command>TYPE</command>命令定义一个新的 C 类型。它等效于把一个<literal>typedef</literal>放在声明节中。
    </para>
<!-- pgdoc-cn_end sig_en=216720c9dc9956b39448ffa060962773 -->

<!-- pgdoc-cn_start sig_en=7557733547d4024abb6c8b890f37c49a sig_cn_org=None source=14.1 
    <para>
     This command is only recognized when <command>ecpg</command> is
     run with the <option>-c</option> option.
    </para>
________________________________________________________-->
    <para>
     只有使用选项<option>-c</option>运行<command>ecpg</command>时才能识别这个命令。
    </para>
<!-- pgdoc-cn_end sig_en=7557733547d4024abb6c8b890f37c49a -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
    <title>Parameters</title>
________________________________________________________-->
    <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">type_name</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=5e124f7d11265760882c5720675df87c sig_cn_org=None source=14.1 
       <para>
        The name for the new type.  It must be a valid C type name.
       </para>
________________________________________________________-->
       <para>
        新类型的名称。这必须是一个合法的 C 类型名。
       </para>
<!-- pgdoc-cn_end sig_en=5e124f7d11265760882c5720675df87c -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">ctype</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=43968a4b79282ced20b8005d92e7483a sig_cn_org=None source=14.1 
       <para>
        A C type specification.
       </para>
________________________________________________________-->
       <para>
        一个 C 类型说明。
       </para>
<!-- pgdoc-cn_end sig_en=43968a4b79282ced20b8005d92e7483a -->
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
    <title>Examples</title>
________________________________________________________-->
    <title>例子</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=bb39fc3f4f7f17a02c249590aa6053d1 sig_cn_org=None source=14.1 
<programlisting>
EXEC SQL TYPE customer IS
    struct
    {
        varchar name[50];
        int     phone;
    };

EXEC SQL TYPE cust_ind IS
    struct ind
    {
        short   name_ind;
        short   phone_ind;
    };

EXEC SQL TYPE c IS char reference;
EXEC SQL TYPE ind IS union { int integer; short smallint; };
EXEC SQL TYPE intarray IS int[AMOUNT];
EXEC SQL TYPE str IS varchar[BUFFERSIZ];
EXEC SQL TYPE string IS char[11];
</programlisting>
________________________________________________________-->
<programlisting>
EXEC SQL TYPE customer IS
    struct
    {
        varchar name[50];
        int     phone;
    };

EXEC SQL TYPE cust_ind IS
    struct ind
    {
        short   name_ind;
        short   phone_ind;
    };

EXEC SQL TYPE c IS char reference;
EXEC SQL TYPE ind IS union { int integer; short smallint; };
EXEC SQL TYPE intarray IS int[AMOUNT];
EXEC SQL TYPE str IS varchar[BUFFERSIZ];
EXEC SQL TYPE string IS char[11];
</programlisting>
<!-- pgdoc-cn_end sig_en=bb39fc3f4f7f17a02c249590aa6053d1 -->

<!-- pgdoc-cn_start sig_en=7b8015e5d41bc59b6fe178f10cf89efa sig_cn_org=None source=14.1 
    <para>
     Here is an example program that uses <command>EXEC SQL
     TYPE</command>:
<programlisting>
EXEC SQL WHENEVER SQLERROR SQLPRINT;

EXEC SQL TYPE tt IS
    struct
    {
        varchar v[256];
        int     i;
    };

EXEC SQL TYPE tt_ind IS
    struct ind {
        short   v_ind;
        short   i_ind;
    };

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    tt t;
    tt_ind t_ind;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    EXEC SQL SELECT current_database(), 256 INTO :t:t_ind LIMIT 1;

    printf("t.v = %s\n", t.v.arr);
    printf("t.i = %d\n", t.i);

    printf("t_ind.v_ind = %d\n", t_ind.v_ind);
    printf("t_ind.i_ind = %d\n", t_ind.i_ind);

    EXEC SQL DISCONNECT con1;

    return 0;
}
</programlisting>

     The output from this program looks like this:
<screen>
t.v = testdb
t.i = 256
t_ind.v_ind = 0
t_ind.i_ind = 0
</screen>
    </para>
________________________________________________________-->
    <para>
     这里是一个使用<command>EXEC SQL TYPE</command>的例子程序：
<programlisting>
EXEC SQL WHENEVER SQLERROR SQLPRINT;

EXEC SQL TYPE tt IS
    struct
    {
        varchar v[256];
        int     i;
    };

EXEC SQL TYPE tt_ind IS
    struct ind {
        short   v_ind;
        short   i_ind;
    };

int
main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
    tt t;
    tt_ind t_ind;
EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    EXEC SQL SELECT current_database(), 256 INTO :t:t_ind LIMIT 1;

    printf("t.v = %s\n", t.v.arr);
    printf("t.i = %d\n", t.i);

    printf("t_ind.v_ind = %d\n", t_ind.v_ind);
    printf("t_ind.i_ind = %d\n", t_ind.i_ind);

    EXEC SQL DISCONNECT con1;

    return 0;
}
</programlisting>

     这个程序的输出看起来像：
<screen>
t.v = testdb
t.i = 256
t_ind.v_ind = 0
t_ind.i_ind = 0
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=7b8015e5d41bc59b6fe178f10cf89efa -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
    <title>Compatibility</title>
________________________________________________________-->
    <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=5689461faac80f05c7229168f29cc1e7 sig_cn_org=None source=14.1 
    <para>
     The <command>TYPE</command> command is a PostgreSQL extension.
    </para>
________________________________________________________-->
    <para>
     <command>TYPE</command>命令是一种 PostgreSQL 扩展。
    </para>
<!-- pgdoc-cn_end sig_en=5689461faac80f05c7229168f29cc1e7 -->
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-var">
<!-- pgdoc-cn_start sig_en=2a7d05b1760b55140b61e02683597b84 sig_cn_org=None source=14.1 
   <refnamediv>
    <refname>VAR</refname>
    <refpurpose>define a variable</refpurpose>
   </refnamediv>
________________________________________________________-->
   <refnamediv>
    <refname>VAR</refname>
    <refpurpose>定义一个变量</refpurpose>
   </refnamediv>
<!-- pgdoc-cn_end sig_en=2a7d05b1760b55140b61e02683597b84 -->

   <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=840982fa24a1619f0ff4b1dabb8a028a sig_cn_org=None source=14.1 
<synopsis>
VAR <replaceable>varname</replaceable> IS <replaceable>ctype</replaceable>
</synopsis>
________________________________________________________-->
<synopsis>
VAR <replaceable>varname</replaceable> IS <replaceable>ctype</replaceable>
</synopsis>
<!-- pgdoc-cn_end sig_en=840982fa24a1619f0ff4b1dabb8a028a -->
   </refsynopsisdiv>

   <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
    <title>Description</title>
________________________________________________________-->
    <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=bb6e2c5e387fbcc4024f683c341177d8 sig_cn_org=None source=14.1 
    <para>
     The <command>VAR</command> command assigns a new C data type
     to a host variable.  The host variable must be previously
     declared in a declare section.
    </para>
________________________________________________________-->
    <para>
     <command>VAR</command>命令分配一个新的 C 数据类型给一个主变量。主变量必须之前在一个声明节中声明过。
    </para>
<!-- pgdoc-cn_end sig_en=bb6e2c5e387fbcc4024f683c341177d8 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
    <title>Parameters</title>
________________________________________________________-->
    <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">varname</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=630fb5f52a8e5176c6b69a904b3fc7a5 sig_cn_org=None source=14.1 
       <para>
        A C variable name.
       </para>
________________________________________________________-->
       <para>
        一个 C 变量名。
       </para>
<!-- pgdoc-cn_end sig_en=630fb5f52a8e5176c6b69a904b3fc7a5 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">ctype</replaceable></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=43968a4b79282ced20b8005d92e7483a sig_cn_org=None source=14.1 
       <para>
        A C type specification.
       </para>
________________________________________________________-->
       <para>
        一个 C 类型说明。
       </para>
<!-- pgdoc-cn_end sig_en=43968a4b79282ced20b8005d92e7483a -->
      </listitem>
     </varlistentry>
    </variablelist>
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
    <title>Examples</title>
________________________________________________________-->
    <title>例子</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=92427bfda5db77b97beeea6a8574921f sig_cn_org=None source=14.1 
<programlisting>
Exec sql begin declare section;
short a;
exec sql end declare section;
EXEC SQL VAR a IS int;
</programlisting>
________________________________________________________-->
<programlisting>
Exec sql begin declare section;
short a;
exec sql end declare section;
EXEC SQL VAR a IS int;
</programlisting>
<!-- pgdoc-cn_end sig_en=92427bfda5db77b97beeea6a8574921f -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
    <title>Compatibility</title>
________________________________________________________-->
    <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=cc360844a75197f722c7b545ea3fa15b sig_cn_org=None source=14.1 
    <para>
     The <command>VAR</command> command is a PostgreSQL extension.
    </para>
________________________________________________________-->
    <para>
     <command>VAR</command>命令是一个 PostgreSQL 扩展。
    </para>
<!-- pgdoc-cn_end sig_en=cc360844a75197f722c7b545ea3fa15b -->
   </refsect1>
  </refentry>

  <refentry id="ecpg-sql-whenever">
<!-- pgdoc-cn_start sig_en=e72ff1277f132db76263df8df856397e sig_cn_org=None source=14.1 
   <refnamediv>
    <refname>WHENEVER</refname>
    <refpurpose>specify the action to be taken when an SQL statement causes a specific class condition to be raised</refpurpose>
   </refnamediv>
________________________________________________________-->
   <refnamediv>
    <refname>WHENEVER</refname>
    <refpurpose>指定一个要在一个 SQL 语句导致发生一个特定类别的情况时要采取的动作</refpurpose>
   </refnamediv>
<!-- pgdoc-cn_end sig_en=e72ff1277f132db76263df8df856397e -->

   <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=870b74d5de4c2f07952dc93637a46c3a sig_cn_org=None source=14.1 
<synopsis>
WHENEVER { NOT FOUND | SQLERROR | SQLWARNING } <replaceable class="parameter">action</replaceable>
</synopsis>
________________________________________________________-->
<synopsis>
WHENEVER { NOT FOUND | SQLERROR | SQLWARNING } <replaceable class="parameter">action</replaceable>
</synopsis>
<!-- pgdoc-cn_end sig_en=870b74d5de4c2f07952dc93637a46c3a -->
   </refsynopsisdiv>

   <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
    <title>Description</title>
________________________________________________________-->
    <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=54161ec75e581f9caacc4201ec3a6f72 sig_cn_org=None source=14.1 
    <para>
     Define a behavior which is called on the special cases (Rows not
     found, SQL warnings or errors) in the result of SQL execution.
    </para>
________________________________________________________-->
    <para>
     定义一个行为，它会在 SQL 执行结果的特殊情况（行未找到、SQL 警告或错误）中被调用。
    </para>
<!-- pgdoc-cn_end sig_en=54161ec75e581f9caacc4201ec3a6f72 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=55f21f3bddee6a8d223aa24ab57d80dc sig_cn_org=None source=14.1 
    <title>Parameters</title>
________________________________________________________-->
    <title>参数</title>
<!-- pgdoc-cn_end sig_en=55f21f3bddee6a8d223aa24ab57d80dc -->

<!-- pgdoc-cn_start sig_en=a3640526ff5ff0c35cc41efa7e36865c sig_cn_org=None source=14.1 
    <para>
     See <xref linkend="ecpg-whenever"/> for a description of the
     parameters.
    </para>
________________________________________________________-->
    <para>
     参数描述见<xref linkend="ecpg-whenever"/>。
    </para>
<!-- pgdoc-cn_end sig_en=a3640526ff5ff0c35cc41efa7e36865c -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
    <title>Examples</title>
________________________________________________________-->
    <title>例子</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=c0c352209afca91fadb68c8f120e492d sig_cn_org=None source=14.1 
<programlisting>
EXEC SQL WHENEVER NOT FOUND CONTINUE;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL WHENEVER NOT FOUND DO CONTINUE;
EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLWARNING DO warn();
EXEC SQL WHENEVER SQLERROR sqlprint;
EXEC SQL WHENEVER SQLERROR CALL print2();
EXEC SQL WHENEVER SQLERROR DO handle_error("select");
EXEC SQL WHENEVER SQLERROR DO sqlnotice(NULL, NONO);
EXEC SQL WHENEVER SQLERROR DO sqlprint();
EXEC SQL WHENEVER SQLERROR GOTO error_label;
EXEC SQL WHENEVER SQLERROR STOP;
</programlisting>
________________________________________________________-->
<programlisting>
EXEC SQL WHENEVER NOT FOUND CONTINUE;
EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL WHENEVER NOT FOUND DO CONTINUE;
EXEC SQL WHENEVER SQLWARNING SQLPRINT;
EXEC SQL WHENEVER SQLWARNING DO warn();
EXEC SQL WHENEVER SQLERROR sqlprint;
EXEC SQL WHENEVER SQLERROR CALL print2();
EXEC SQL WHENEVER SQLERROR DO handle_error("select");
EXEC SQL WHENEVER SQLERROR DO sqlnotice(NULL, NONO);
EXEC SQL WHENEVER SQLERROR DO sqlprint();
EXEC SQL WHENEVER SQLERROR GOTO error_label;
EXEC SQL WHENEVER SQLERROR STOP;
</programlisting>
<!-- pgdoc-cn_end sig_en=c0c352209afca91fadb68c8f120e492d -->

<!-- pgdoc-cn_start sig_en=39552323323437ad7e6e1c7da4358309 sig_cn_org=None source=14.1 
    <para>
     A typical application is the use of <literal>WHENEVER NOT FOUND
     BREAK</literal> to handle looping through result sets:
<programlisting>
int
main(void)
{
    EXEC SQL CONNECT TO testdb AS con1;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
    EXEC SQL ALLOCATE DESCRIPTOR d;
    EXEC SQL DECLARE cur CURSOR FOR SELECT current_database(), 'hoge', 256;
    EXEC SQL OPEN cur;

    /* when end of result set reached, break out of while loop */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;
        ...
    }

    EXEC SQL CLOSE cur;
    EXEC SQL COMMIT;

    EXEC SQL DEALLOCATE DESCRIPTOR d;
    EXEC SQL DISCONNECT ALL;

    return 0;
}
</programlisting>
    </para>
________________________________________________________-->
    <para>
     一个典型的应用是使用<literal>WHENEVER NOT FOUND BREAK</literal>来处理通过结果集的循环：
<programlisting>
int
main(void)
{
    EXEC SQL CONNECT TO testdb AS con1;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
    EXEC SQL ALLOCATE DESCRIPTOR d;
    EXEC SQL DECLARE cur CURSOR FOR SELECT current_database(), 'hoge', 256;
    EXEC SQL OPEN cur;

    /* 当到达结果集末尾时，跳出循环 */
    EXEC SQL WHENEVER NOT FOUND DO BREAK;

    while (1)
    {
        EXEC SQL FETCH NEXT FROM cur INTO SQL DESCRIPTOR d;
        ...
    }

    EXEC SQL CLOSE cur;
    EXEC SQL COMMIT;

    EXEC SQL DEALLOCATE DESCRIPTOR d;
    EXEC SQL DISCONNECT ALL;

    return 0;
}
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=39552323323437ad7e6e1c7da4358309 -->
   </refsect1>

   <refsect1>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
    <title>Compatibility</title>
________________________________________________________-->
    <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->

<!-- pgdoc-cn_start sig_en=fab2653d0d6127f6accb79f18a91ed3f sig_cn_org=None source=14.1 
    <para>
     <command>WHENEVER</command> is specified in the SQL standard, but
     most of the actions are PostgreSQL extensions.
    </para>
________________________________________________________-->
    <para>
     SQL 标准中说明了<command>WHENEVER</command>，但是大部分动作是 PostgreSQL 扩展。
    </para>
<!-- pgdoc-cn_end sig_en=fab2653d0d6127f6accb79f18a91ed3f -->
   </refsect1>
  </refentry>
 </sect1>

 <sect1 id="ecpg-informix-compat">
<!-- pgdoc-cn_start sig_en=ef02de999a64408e372c9ffe2ebdf2c1 sig_cn_org=None source=14.1 
  <title><productname>Informix</productname> Compatibility Mode</title>
________________________________________________________-->
  <title><productname>Informix</productname>兼容模式</title>
<!-- pgdoc-cn_end sig_en=ef02de999a64408e372c9ffe2ebdf2c1 -->
<!-- pgdoc-cn_start sig_en=c19edd58b58b5741cef5dd2d8f9319fa sig_cn_org=None source=14.1 
  <para>
   <command>ecpg</command> can be run in a so-called <firstterm>Informix compatibility mode</firstterm>. If
   this mode is active, it tries to behave as if it were the <productname>Informix</productname>
   precompiler for <productname>Informix</productname> E/SQL. Generally spoken this will allow you to use
   the dollar sign instead of the <literal>EXEC SQL</literal> primitive to introduce
   embedded SQL commands:
<programlisting>
$int j = 3;
$CONNECT TO :dbname;
$CREATE TABLE test(i INT PRIMARY KEY, j INT);
$INSERT INTO test(i, j) VALUES (7, :j);
$COMMIT;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   <command>ecpg</command>可以运行在一种所谓的<firstterm>Informix 兼容模式</firstterm>中。如果这种模式被激活，它的行为就好像它是一个用于<productname>Informix</productname> E/SQL 的<productname>Informix</productname>预编译器。一般而言，这将允许你使用美元符号替代<literal>EXEC SQL</literal>来引入嵌入式 SQL 命令：
<programlisting>
$int j = 3;
$CONNECT TO :dbname;
$CREATE TABLE test(i INT PRIMARY KEY, j INT);
$INSERT INTO test(i, j) VALUES (7, :j);
$COMMIT;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=c19edd58b58b5741cef5dd2d8f9319fa -->

  <note>
<!-- pgdoc-cn_start sig_en=1c550b43222173938372ea1383425f76 sig_cn_org=None source=14.1 
   <para>
    There must not be any white space between the <literal>$</literal>
    and a following preprocessor directive, that is,
    <literal>include</literal>, <literal>define</literal>, <literal>ifdef</literal>,
    etc.  Otherwise, the preprocessor will parse the token as a host
    variable.
   </para>
________________________________________________________-->
   <para>
    在<literal>$</literal>之间不能有任何空白以及下列之一的预处理器指令：<literal>include</literal>、<literal>define</literal>、<literal>ifdef</literal>等。否则，预处理器将把记号解析成一个主变量。
   </para>
<!-- pgdoc-cn_end sig_en=1c550b43222173938372ea1383425f76 -->
  </note>

<!-- pgdoc-cn_start sig_en=fc4a662bbb0a783cafb4d82ed4e3766a sig_cn_org=None source=14.1 
  <para>
   There are two compatibility modes: <literal>INFORMIX</literal>, <literal>INFORMIX_SE</literal>
  </para>
________________________________________________________-->
  <para>
   有两种兼容性模式：<literal>INFORMIX</literal>、<literal>INFORMIX_SE</literal>
  </para>
<!-- pgdoc-cn_end sig_en=fc4a662bbb0a783cafb4d82ed4e3766a -->
<!-- pgdoc-cn_start sig_en=52cfd1e1fcfba17d2cc7b627bcccb1e3 sig_cn_org=None source=14.1 
  <para>
   When linking programs that use this compatibility mode, remember to link
   against <literal>libcompat</literal> that is shipped with ECPG.
  </para>
________________________________________________________-->
  <para>
   在链接使用这种兼容性模式的程序时，要记得链接上和 ECPG 一起发布的<literal>libcompat</literal>。
  </para>
<!-- pgdoc-cn_end sig_en=52cfd1e1fcfba17d2cc7b627bcccb1e3 -->
<!-- pgdoc-cn_start sig_en=27c8b7ec2bc0965cafab0bdccd1c2d36 sig_cn_org=None source=14.1 
  <para>
   Besides the previously explained syntactic sugar, the <productname>Informix</productname> compatibility
   mode ports some functions for input, output and transformation of data as
   well as embedded SQL statements known from E/SQL to ECPG.
  </para>
________________________________________________________-->
  <para>
   除了之前解释过的语法糖，<productname>Informix</productname>兼容性模式从 E/SQL 中移植了一些用于输入、输出和数据转换的函数以及嵌入式 SQL 语句到 ECPG 中。
  </para>
<!-- pgdoc-cn_end sig_en=27c8b7ec2bc0965cafab0bdccd1c2d36 -->
<!-- pgdoc-cn_start sig_en=e7140e9a18a8adb2343f8e556ffbcdcb sig_cn_org=533514f64294c01356616d7510df27a8 source=15.7 
  <para>
   <productname>Informix</productname> compatibility mode is closely connected to the pgtypeslib library
   of ECPG. pgtypeslib maps SQL data types to data types within the C host
   program and most of the additional functions of the <productname>Informix</productname> compatibility
   mode allow you to operate on those C host program types. Note however that
   the extent of the compatibility is limited. It does not try to copy <productname>Informix</productname>
   behavior; it allows you to do more or less the same operations and gives
   you functions that have the same name and the same basic behavior but it is
   no drop-in replacement if you are using <productname>Informix</productname> at the moment. Moreover,
   some of the data types are different. For example,
   <productname>PostgreSQL</productname>'s datetime and interval types do not
   know about ranges like for example <literal>YEAR TO MINUTE</literal> so you won't
   find support in ECPG for that either.
  </para>
________________________________________________________-->
  <para>
   <productname>Informix</productname>兼容模式与ECPG的pgtypeslib库密切相关。pgtypeslib将SQL数据类型映射到C主机程序中的数据类型，
   <productname>Informix</productname>兼容模式的大多数附加功能允许您对这些C主机程序类型进行操作。但请注意，兼容性的范围是有限的。
   它不会尝试复制<productname>Informix</productname>的行为；它允许您执行更多或更少相同的操作，并提供具有相同名称和相同基本行为的函数，
   但如果您目前正在使用<productname>Informix</productname>，它不是一个完全可替代的替代品。此外，一些数据类型是不同的。例如，
   <productname>PostgreSQL</productname>的日期时间和间隔类型不了解像<literal>YEAR TO MINUTE</literal>这样的范围，因此在ECPG中也找不到对其的支持。
  </para>
<!-- pgdoc-cn_end sig_en=e7140e9a18a8adb2343f8e556ffbcdcb -->

  <sect2 id="ecpg-informix-types">
<!-- pgdoc-cn_start sig_en=1a645cbc898b4b634070fbbb3ade369f sig_cn_org=None source=14.1 
   <title>Additional Types</title>
________________________________________________________-->
   <title>附加类型</title>
<!-- pgdoc-cn_end sig_en=1a645cbc898b4b634070fbbb3ade369f -->
<!-- pgdoc-cn_start sig_en=83e788ce5a8b1295897c30f7d4d80b99 sig_cn_org=None source=14.1 
   <para>
    The Informix-special "string" pseudo-type for storing right-trimmed character string data is now
    supported in Informix-mode without using <literal>typedef</literal>. In fact, in Informix-mode,
    ECPG refuses to process source files that contain <literal>typedef sometype string;</literal>
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
string userid; /* this variable will contain trimmed data */
EXEC SQL END DECLARE SECTION;

EXEC SQL FETCH MYCUR INTO :userid;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    用于存储右切边字符串数据的 Informix-特殊的 "string" 伪类型现在在 Informix 模式中不用<literal>typedef</literal>就能支持。事实上，在 Informix 模式中，ECPG 拒绝处理包含<literal>typedef sometype string;</literal>的源文件。
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
string userid; /* 这个变量将包含切边过的数据 */
EXEC SQL END DECLARE SECTION;

EXEC SQL FETCH MYCUR INTO :userid;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=83e788ce5a8b1295897c30f7d4d80b99 -->
  </sect2>

  <sect2 id="ecpg-informix-statements">
<!-- pgdoc-cn_start sig_en=7cde39b889202b448aee601491a8249d sig_cn_org=None source=14.1 
   <title>Additional/Missing Embedded SQL Statements</title>
________________________________________________________-->
   <title>附加的/缺少的 嵌入式 SQL 语句</title>
<!-- pgdoc-cn_end sig_en=7cde39b889202b448aee601491a8249d -->
<!-- pgdoc-cn_start sig_en=a067bdd68c01235982df751648125664 sig_cn_org=206e59b52b49744e8293edd0017b1f87 source=15.7 
   <para>
    <variablelist>
     <varlistentry>
      <term><literal>CLOSE DATABASE</literal></term>
      <listitem>
       <para>
        This statement closes the current connection. In fact, this is a
        synonym for ECPG's <literal>DISCONNECT CURRENT</literal>:
<programlisting>
$CLOSE DATABASE;                /* close the current connection */
EXEC SQL CLOSE DATABASE;
</programlisting>
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>FREE cursor_name</literal></term>
      <listitem>
       <para>
        Due to differences in how ECPG works compared to Informix's ESQL/C (namely, which steps
        are purely grammar transformations and which steps rely on the underlying run-time library)
        there is no <literal>FREE cursor_name</literal> statement in ECPG. This is because in ECPG,
        <literal>DECLARE CURSOR</literal> doesn't translate to a function call into
        the run-time library that uses to the cursor name. This means that there's no run-time
        bookkeeping of SQL cursors in the ECPG run-time library, only in the PostgreSQL server.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>FREE statement_name</literal></term>
      <listitem>
       <para>
        <literal>FREE statement_name</literal> is a synonym for <literal>DEALLOCATE PREPARE statement_name</literal>.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    <variablelist>
     <varlistentry>
      <term><literal>关闭数据库</literal></term>
      <listitem>
       <para>
        这个语句关闭当前连接。实际上，这是ECPG的<literal>DISCONNECT CURRENT</literal>的同义词：
<programlisting>
$CLOSE DATABASE;                /* close the current connection */
EXEC SQL CLOSE DATABASE;
</programlisting>
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>释放游标名称</literal></term>
      <listitem>
       <para>
        由于ECPG的工作方式与Informix的ESQL/C有所不同（即，哪些步骤纯粹是语法转换，哪些步骤依赖于底层运行时库），
        在ECPG中没有<literal>FREE cursor_name</literal>语句。这是因为在ECPG中，
        <literal>DECLARE CURSOR</literal>不会转换为使用游标名称的运行时库的函数调用。
        这意味着在ECPG运行时库中没有SQL游标的运行时记录，只在PostgreSQL服务器中有。
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>释放语句名称</literal></term>
      <listitem>
       <para>
        <literal>FREE statement_name</literal>是<literal>DEALLOCATE PREPARE statement_name</literal>的同义词。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=a067bdd68c01235982df751648125664 -->
  </sect2>

  <sect2 id="ecpg-informix-sqlda">
<!-- pgdoc-cn_start sig_en=4863b1692c6801cf633d7c7a1681c7fe sig_cn_org=None source=14.1 
   <title>Informix-compatible SQLDA Descriptor Areas</title>
________________________________________________________-->
   <title>Informix-兼容的 SQLDA 描述符区域</title>
<!-- pgdoc-cn_end sig_en=4863b1692c6801cf633d7c7a1681c7fe -->
<!-- pgdoc-cn_start sig_en=9229ad014e398b451e4cf6f1d02a634f sig_cn_org=None source=14.1 
   <para>
    Informix-compatible mode supports a different structure than the one described in
    <xref linkend="ecpg-sqlda-descriptors"/>. See below:
<programlisting>
struct sqlvar_compat
{
    short   sqltype;
    int     sqllen;
    char   *sqldata;
    short  *sqlind;
    char   *sqlname;
    char   *sqlformat;
    short   sqlitype;
    short   sqlilen;
    char   *sqlidata;
    int     sqlxid;
    char   *sqltypename;
    short   sqltypelen;
    short   sqlownerlen;
    short   sqlsourcetype;
    char   *sqlownername;
    int     sqlsourceid;
    char   *sqlilongdata;
    int     sqlflags;
    void   *sqlreserved;
};

struct sqlda_compat
{
    short  sqld;
    struct sqlvar_compat *sqlvar;
    char   desc_name[19];
    short  desc_occ;
    struct sqlda_compat *desc_next;
    void  *reserved;
};

typedef struct sqlvar_compat    sqlvar_t;
typedef struct sqlda_compat     sqlda_t;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    Informix-兼容模式支持一种与<xref linkend="ecpg-sqlda-descriptors"/>中所述不同的结构。如下：
<programlisting>
struct sqlvar_compat
{
    short   sqltype;
    int     sqllen;
    char   *sqldata;
    short  *sqlind;
    char   *sqlname;
    char   *sqlformat;
    short   sqlitype;
    short   sqlilen;
    char   *sqlidata;
    int     sqlxid;
    char   *sqltypename;
    short   sqltypelen;
    short   sqlownerlen;
    short   sqlsourcetype;
    char   *sqlownername;
    int     sqlsourceid;
    char   *sqlilongdata;
    int     sqlflags;
    void   *sqlreserved;
};

struct sqlda_compat
{
    short  sqld;
    struct sqlvar_compat *sqlvar;
    char   desc_name[19];
    short  desc_occ;
    struct sqlda_compat *desc_next;
    void  *reserved;
};

typedef struct sqlvar_compat    sqlvar_t;
typedef struct sqlda_compat     sqlda_t;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=9229ad014e398b451e4cf6f1d02a634f -->

<!-- pgdoc-cn_start sig_en=4ec5ad179a6b5b2b0642b24d61206213 sig_cn_org=None source=14.1 
   <para>
    The global properties are:
    <variablelist>

     <varlistentry>
     <term><literal>sqld</literal></term>
      <listitem>
       <para>
        The number of fields in the <literal>SQLDA</literal> descriptor.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlvar</literal></term>
      <listitem>
       <para>
        Pointer to the per-field properties.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_name</literal></term>
      <listitem>
       <para>
        Unused, filled with zero-bytes.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_occ</literal></term>
      <listitem>
       <para>
        Size of the allocated structure.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_next</literal></term>
      <listitem>
       <para>
        Pointer to the next SQLDA structure if the result set contains more than one record.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>reserved</literal></term>
      <listitem>
       <para>
        Unused pointer, contains NULL. Kept for Informix-compatibility.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

    The per-field properties are below, they are stored in the <literal>sqlvar</literal> array:

    <variablelist>

     <varlistentry>
     <term><literal>sqltype</literal></term>
      <listitem>
       <para>
        Type of the field. Constants are in <literal>sqltypes.h</literal>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqllen</literal></term>
      <listitem>
       <para>
        Length of the field data.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqldata</literal></term>
      <listitem>
       <para>
        Pointer to the field data. The pointer is of <literal>char *</literal> type,
        the data pointed by it is in a binary format. Example:
<programlisting>
int intval;

switch (sqldata->sqlvar[i].sqltype)
{
    case SQLINTEGER:
        intval = *(int *)sqldata->sqlvar[i].sqldata;
        break;
  ...
}
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlind</literal></term>
      <listitem>
       <para>
        Pointer to the NULL indicator. If returned by DESCRIBE or FETCH then it's always a valid pointer.
        If used as input for <literal>EXECUTE ... USING sqlda;</literal> then NULL-pointer value means
        that the value for this field is non-NULL. Otherwise a valid pointer and <literal>sqlitype</literal>
        has to be properly set. Example:
<programlisting>
if (*(int2 *)sqldata->sqlvar[i].sqlind != 0)
    printf("value is NULL\n");
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlname</literal></term>
      <listitem>
       <para>
        Name of the field. 0-terminated string.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlformat</literal></term>
      <listitem>
       <para>
        Reserved in Informix, value of <xref linkend="libpq-PQfformat"/> for the field.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlitype</literal></term>
      <listitem>
       <para>
        Type of the NULL indicator data. It's always SQLSMINT when returning data from the server.
        When the <literal>SQLDA</literal> is used for a parameterized query, the data is treated
        according to the set type.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlilen</literal></term>
      <listitem>
       <para>
        Length of the NULL indicator data.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlxid</literal></term>
      <listitem>
       <para>
        Extended type of the field, result of <xref linkend="libpq-PQftype"/>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqltypename</literal></term>
     <term><literal>sqltypelen</literal></term>
     <term><literal>sqlownerlen</literal></term>
     <term><literal>sqlsourcetype</literal></term>
     <term><literal>sqlownername</literal></term>
     <term><literal>sqlsourceid</literal></term>
     <term><literal>sqlflags</literal></term>
     <term><literal>sqlreserved</literal></term>
      <listitem>
       <para>
        Unused.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlilongdata</literal></term>
      <listitem>
       <para>
        It equals to <literal>sqldata</literal> if <literal>sqllen</literal> is larger than 32kB.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

    Example:
<programlisting>
EXEC SQL INCLUDE sqlda.h;

    sqlda_t        *sqlda; /* This doesn't need to be under embedded DECLARE SECTION */

    EXEC SQL BEGIN DECLARE SECTION;
    char *prep_stmt = "select * from table1";
    int i;
    EXEC SQL END DECLARE SECTION;

    ...

    EXEC SQL PREPARE mystmt FROM :prep_stmt;

    EXEC SQL DESCRIBE mystmt INTO sqlda;

    printf("# of fields: %d\n", sqlda-&gt;sqld);
    for (i = 0; i &lt; sqlda-&gt;sqld; i++)
      printf("field %d: \"%s\"\n", sqlda-&gt;sqlvar[i]-&gt;sqlname);

    EXEC SQL DECLARE mycursor CURSOR FOR mystmt;
    EXEC SQL OPEN mycursor;
    EXEC SQL WHENEVER NOT FOUND GOTO out;

    while (1)
    {
      EXEC SQL FETCH mycursor USING sqlda;
    }

    EXEC SQL CLOSE mycursor;

    free(sqlda); /* The main structure is all to be free(),
                  * sqlda and sqlda-&gt;sqlvar is in one allocated area */
</programlisting>
    For more information, see the <literal>sqlda.h</literal> header and the
    <literal>src/interfaces/ecpg/test/compat_informix/sqlda.pgc</literal> regression test.
   </para>
________________________________________________________-->
   <para>
    全局属性是：
    <variablelist>

     <varlistentry>
     <term><literal>sqld</literal></term>
      <listitem>
       <para>
        <literal>SQLDA</literal>描述符中域的数量。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlvar</literal></term>
      <listitem>
       <para>
        每一个域属性的指针。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_name</literal></term>
      <listitem>
       <para>
        未使用，用零字节填充。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_occ</literal></term>
      <listitem>
       <para>
        已分配结构的尺寸。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>desc_next</literal></term>
      <listitem>
       <para>
        如果结果集包含多于一个记录，这个域是下一个 SQLDA 结构的指针。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>reserved</literal></term>
      <listitem>
       <para>
        未使用的指针，包含 NULL。为 Informix-兼容性而保留。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

    对每一个域的属性如下，它们被存储在<literal>sqlvar</literal>数组中：

    <variablelist>

     <varlistentry>
     <term><literal>sqltype</literal></term>
      <listitem>
       <para>
        域的类型。可以使用的常量定义在<literal>sqltypes.h</literal>中。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqllen</literal></term>
      <listitem>
       <para>
        域数据的长度。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqldata</literal></term>
      <listitem>
       <para>
        域数据的指针。该指针是<literal>char *</literal>类型，它所指向的数据是二进制个事。例子：
<programlisting>
int intval;

switch (sqldata->sqlvar[i].sqltype)
{
    case SQLINTEGER:
        intval = *(int *)sqldata->sqlvar[i].sqldata;
        break;
  ...
}
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlind</literal></term>
      <listitem>
       <para>
        NULL 指示符的指针。如果是由 DESCRIBE 或 FETCH 返回，那么它总是一个有效的指针。如果被用作<literal>EXECUTE ... USING sqlda;</literal>的输入，那么 NULL-指针值意味着这个域的值是非-NULL 的。否则必须正确地设置一个有效的指针和<literal>sqlitype</literal>。例子：
<programlisting>
if (*(int2 *)sqldata->sqlvar[i].sqlind != 0)
    printf("value is NULL\n");
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlname</literal></term>
      <listitem>
       <para>
        域的名称。以 0 终止的字符串。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlformat</literal></term>
      <listitem>
       <para>
        在 Informix 中保留，是该域的<xref linkend="libpq-PQfformat"/>的值。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlitype</literal></term>
      <listitem>
       <para>
        NULL 指示符数据的类型。当从服务器返回数据时，它总是 SQLSMINT。当<literal>SQLDA</literal>被用于一个参数化查询时，数据要根据设置的类型对待。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlilen</literal></term>
      <listitem>
       <para>
        NULL 指示符数据的长度。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlxid</literal></term>
      <listitem>
       <para>
        该域的扩展类型，<xref linkend="libpq-PQftype"/>的结果。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqltypename</literal></term>
     <term><literal>sqltypelen</literal></term>
     <term><literal>sqlownerlen</literal></term>
     <term><literal>sqlsourcetype</literal></term>
     <term><literal>sqlownername</literal></term>
     <term><literal>sqlsourceid</literal></term>
     <term><literal>sqlflags</literal></term>
     <term><literal>sqlreserved</literal></term>
      <listitem>
       <para>
        未使用。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
     <term><literal>sqlilongdata</literal></term>
      <listitem>
       <para>
        如果<literal>sqllen</literal>大于 32kB，它等于<literal>sqldata</literal>。
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

    例子：
<programlisting>
EXEC SQL INCLUDE sqlda.h;

    sqlda_t        *sqlda; /* 这不需要在嵌入式 DECLARE SECTION 下 */

    EXEC SQL BEGIN DECLARE SECTION;
    char *prep_stmt = "select * from table1";
    int i;
    EXEC SQL END DECLARE SECTION;

    ...

    EXEC SQL PREPARE mystmt FROM :prep_stmt;

    EXEC SQL DESCRIBE mystmt INTO sqlda;

    printf("# of fields: %d\n", sqlda-&gt;sqld);
    for (i = 0; i &lt; sqlda-&gt;sqld; i++)
      printf("field %d: \"%s\"\n", sqlda-&gt;sqlvar[i]-&gt;sqlname);

    EXEC SQL DECLARE mycursor CURSOR FOR mystmt;
    EXEC SQL OPEN mycursor;
    EXEC SQL WHENEVER NOT FOUND GOTO out;

    while (1)
    {
      EXEC SQL FETCH mycursor USING sqlda;
    }

    EXEC SQL CLOSE mycursor;

    free(sqlda); /* 主结构完全被 free()，sqlda 和 sqlda-&gt;sqlvar 在一个已分配区域中 */
</programlisting>
    更多信息可见<literal>sqlda.h</literal>头部和<literal>src/interfaces/ecpg/test/compat_informix/sqlda.pgc</literal>回归测试。
   </para>
<!-- pgdoc-cn_end sig_en=4ec5ad179a6b5b2b0642b24d61206213 -->
  </sect2>

  <sect2 id="ecpg-informix-functions">
<!-- pgdoc-cn_start sig_en=076ecfb571ad792744e0e5c06de2cf50 sig_cn_org=None source=14.1 
   <title>Additional Functions</title>
________________________________________________________-->
   <title>附加函数</title>
<!-- pgdoc-cn_end sig_en=076ecfb571ad792744e0e5c06de2cf50 -->
   <para>
    <variablelist>
     <varlistentry>
      <term><function>decadd</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=58407f67fc8c97d83ba3dbecbd8450d7 sig_cn_org=d4d3b026303c709dfba687d1f8fd8542 source=15.7 
       <para>
        Add two decimal type values.
<synopsis>
int decadd(decimal *arg1, decimal *arg2, decimal *sum);
</synopsis>
        The function receives a pointer to the first operand of type decimal
        (<literal>arg1</literal>), a pointer to the second operand of type decimal
        (<literal>arg2</literal>) and a pointer to a value of type decimal that will
        contain the sum (<literal>sum</literal>). On success, the function returns 0.
        <symbol>ECPG_INFORMIX_NUM_OVERFLOW</symbol> is returned in case of overflow and
        <symbol>ECPG_INFORMIX_NUM_UNDERFLOW</symbol> in case of underflow. -1 is returned for
        other failures and <varname>errno</varname> is set to the respective <varname>errno</varname> number of the
        pgtypeslib.
       </para>
________________________________________________________-->
       <para>
        添加两个十进制类型的值。
<synopsis>
int decadd(decimal *arg1, decimal *arg2, decimal *sum);
</synopsis>
        该函数接收一个指向十进制类型第一个操作数的指针
        (<literal>arg1</literal>)，一个指向十进制类型第二个操作数的指针
        (<literal>arg2</literal>)，以及一个指向将包含和的十进制类型值的指针
        (<literal>sum</literal>)。成功时，函数返回0。
        溢出时返回<symbol>ECPG_INFORMIX_NUM_OVERFLOW</symbol>，
        下溢时返回<symbol>ECPG_INFORMIX_NUM_UNDERFLOW</symbol>。
        其他故障返回-1，并将<varname>errno</varname>设置为相应的pgtypeslib的<varname>errno</varname>编号。
       </para>
<!-- pgdoc-cn_end sig_en=58407f67fc8c97d83ba3dbecbd8450d7 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccmp</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=689a61334b5b52bc9431df6011363d28 sig_cn_org=9cdfff65c0f7e4c9a678ddb3f5818b56 source=15.7 
       <para>
        Compare two variables of type decimal.
<synopsis>
int deccmp(decimal *arg1, decimal *arg2);
</synopsis>
        The function receives a pointer to the first decimal value
        (<literal>arg1</literal>), a pointer to the second decimal value
        (<literal>arg2</literal>) and returns an integer value that indicates which is
        the bigger value.
        <itemizedlist>
         <listitem>
          <para>
           1, if the value that <literal>arg1</literal> points to is bigger than the
           value that <literal>var2</literal> points to
          </para>
         </listitem>
         <listitem>
          <para>
           -1, if the value that <literal>arg1</literal> points to is smaller than the
           value that <literal>arg2</literal> points to </para>
         </listitem>
         <listitem>
          <para>
           0, if the value that <literal>arg1</literal> points to and the value that
           <literal>arg2</literal> points to are equal
          </para>
         </listitem>
        </itemizedlist>
       </para>
________________________________________________________-->
       <para>
        比较两个decimal类型的变量。
<synopsis>
int deccmp(decimal *arg1, decimal *arg2);
</synopsis>
        该函数接收第一个decimal值的指针
        (<literal>arg1</literal>)，第二个decimal值的指针
        (<literal>arg2</literal>)，并返回一个整数值，指示哪个值更大。
        <itemizedlist>
         <listitem>
          <para>
           1，如果<literal>arg1</literal>指向的值大于<literal>var2</literal>指向的值
          </para>
         </listitem>
         <listitem>
          <para>
           -1，如果<literal>arg1</literal>指向的值小于<literal>arg2</literal>指向的值
          </para>
         </listitem>
         <listitem>
          <para>
           0，如果<literal>arg1</literal>指向的值和<literal>arg2</literal>指向的值相等
          </para>
         </listitem>
        </itemizedlist>
       </para>
<!-- pgdoc-cn_end sig_en=689a61334b5b52bc9431df6011363d28 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccopy</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=dba61d70818c1242cca42274b412dc9b sig_cn_org=9e788d9cbd86ec18a3912b570d7628a7 source=15.7 
       <para>
        Copy a decimal value.
<synopsis>
void deccopy(decimal *src, decimal *target);
</synopsis>
        The function receives a pointer to the decimal value that should be
        copied as the first argument (<literal>src</literal>) and a pointer to the
        target structure of type decimal (<literal>target</literal>) as the second
        argument.
       </para>
________________________________________________________-->
       <para>
        复制一个十进制值。
<synopsis>
void deccopy(decimal *src, decimal *target);
</synopsis>
        该函数接收应该被复制的十进制值的指针作为第一个参数（<literal>src</literal>），
        并将目标类型为十进制的结构体的指针作为第二个参数（<literal>target</literal>）。
       </para>
<!-- pgdoc-cn_end sig_en=dba61d70818c1242cca42274b412dc9b -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvasc</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=760df5540d315d1d775f9c3f19b783ae sig_cn_org=467769515fb4be4eae4bf7b06390c546 source=15.7 
       <para>
        Convert a value from its ASCII representation into a decimal type.
<synopsis>
int deccvasc(char *cp, int len, decimal *np);
</synopsis>
        The function receives a pointer to string that contains the string
        representation of the number to be converted (<literal>cp</literal>) as well
        as its length <literal>len</literal>. <literal>np</literal> is a pointer to the
        decimal value that saves the result of the operation.
       </para>
________________________________________________________-->
       <para>
        将一个值从其ASCII表示转换为十进制类型。
<synopsis>
int deccvasc(char *cp, int len, decimal *np);
</synopsis>
        该函数接收一个指向包含要转换的数字的字符串表示的指针（<literal>cp</literal>），
        以及它的长度<literal>len</literal>。 <literal>np</literal>是一个指向保存操作结果的十进制值的指针。
       </para>
<!-- pgdoc-cn_end sig_en=760df5540d315d1d775f9c3f19b783ae -->
<!-- pgdoc-cn_start sig_en=7ca04d9a94ec5f0bcfaa3839f5f774e7 sig_cn_org=1f62710de4954ade69709a09eb978068 source=15.7 
       <para>
        Valid formats are for example:
         <literal>-2</literal>,
         <literal>.794</literal>,
         <literal>+3.44</literal>,
         <literal>592.49E07</literal> or
         <literal>-32.84e-4</literal>.
       </para>
________________________________________________________-->
       <para>
        例如，有效的格式包括：
         <literal>-2</literal>,
         <literal>.794</literal>,
         <literal>+3.44</literal>,
         <literal>592.49E07</literal>或
         <literal>-32.84e-4</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=7ca04d9a94ec5f0bcfaa3839f5f774e7 -->
<!-- pgdoc-cn_start sig_en=53d0b0654d1af4e51aa2f266fee5645c sig_cn_org=74c2dfb0d68c2883dfbee87873b035cd source=15.7 
       <para>
        The function returns 0 on success. If overflow or underflow occurred,
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> or
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal> is returned. If the ASCII
        representation could not be parsed,
        <literal>ECPG_INFORMIX_BAD_NUMERIC</literal> is returned or
        <literal>ECPG_INFORMIX_BAD_EXPONENT</literal> if this problem occurred while
        parsing the exponent.
       </para>
________________________________________________________-->
       <para>
        该函数成功返回0。如果发生溢出或下溢，则返回<literal>ECPG_INFORMIX_NUM_OVERFLOW</literal>或
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal>。如果ASCII表示无法解析，
        则返回<literal>ECPG_INFORMIX_BAD_NUMERIC</literal>，或者如果在解析指数时出现问题，则返回
        <literal>ECPG_INFORMIX_BAD_EXPONENT</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=53d0b0654d1af4e51aa2f266fee5645c -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvdbl</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=fe3234981b72f869d25a88456cff47dc sig_cn_org=8cd77b825ada327d0f69ce44e6ba76b1 source=15.7 
       <para>
        Convert a value of type double to a value of type decimal.
<synopsis>
int deccvdbl(double dbl, decimal *np);
</synopsis>
        The function receives the variable of type double that should be
        converted as its first argument (<literal>dbl</literal>). As the second
        argument (<literal>np</literal>), the function receives a pointer to the
        decimal variable that should hold the result of the operation.
       </para>
________________________________________________________-->
       <para>
        将double类型的值转换为decimal类型的值。
<synopsis>
int deccvdbl(double dbl, decimal *np);
</synopsis>
        该函数接收应该被转换的double类型变量作为其第一个参数（<literal>dbl</literal>）。
        作为第二个参数（<literal>np</literal>），该函数接收一个指向应该保存操作结果的decimal变量的指针。
       </para>
<!-- pgdoc-cn_end sig_en=fe3234981b72f869d25a88456cff47dc -->
<!-- pgdoc-cn_start sig_en=68434610608694f1cf3e46b60394c240 sig_cn_org=214ff2ffa985a8f1cf5bfa93ef29c121 source=15.7 
       <para>
        The function returns 0 on success and a negative value if the
        conversion failed.
       </para>
________________________________________________________-->
       <para>
        该函数在成功时返回0，在转换失败时返回负值。
       </para>
<!-- pgdoc-cn_end sig_en=68434610608694f1cf3e46b60394c240 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvint</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=5ffc6bf5b497620cf3c0577e6339c8f9 sig_cn_org=98d5f1c4a6e67552202e5bd9c2987c5c source=15.7 
       <para>
        Convert a value of type int to a value of type decimal.
<synopsis>
int deccvint(int in, decimal *np);
</synopsis>
        The function receives the variable of type int that should be
        converted as its first argument (<literal>in</literal>). As the second
        argument (<literal>np</literal>), the function receives a pointer to the
        decimal variable that should hold the result of the operation.
       </para>
________________________________________________________-->
       <para>
        将int类型的值转换为decimal类型的值。
<synopsis>
int deccvint(int in, decimal *np);
</synopsis>
        该函数接收应该被转换的int类型变量作为其第一个参数（<literal>in</literal>）。
        作为第二个参数（<literal>np</literal>），该函数接收一个指向应该保存操作结果的decimal变量的指针。
       </para>
<!-- pgdoc-cn_end sig_en=5ffc6bf5b497620cf3c0577e6339c8f9 -->
<!-- pgdoc-cn_start sig_en=68434610608694f1cf3e46b60394c240 sig_cn_org=214ff2ffa985a8f1cf5bfa93ef29c121 source=15.7 
       <para>
        The function returns 0 on success and a negative value if the
        conversion failed.
       </para>
________________________________________________________-->
       <para>
        该函数在成功时返回0，在转换失败时返回负值。
       </para>
<!-- pgdoc-cn_end sig_en=68434610608694f1cf3e46b60394c240 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>deccvlong</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=ca5caa89e31c0432823a1c8eff4d35e5 sig_cn_org=52b1f0beabaff95fb5eeabf42c2b8ab1 source=15.7 
       <para>
        Convert a value of type long to a value of type decimal.
<synopsis>
int deccvlong(long lng, decimal *np);
</synopsis>
        The function receives the variable of type long that should be
        converted as its first argument (<literal>lng</literal>). As the second
        argument (<literal>np</literal>), the function receives a pointer to the
        decimal variable that should hold the result of the operation.
       </para>
________________________________________________________-->
       <para>
        将类型为long的值转换为类型为decimal的值。
<synopsis>
int deccvlong(long lng, decimal *np);
</synopsis>
        该函数接收应该被转换的类型为long的变量作为其第一个参数（<literal>lng</literal>）。
        作为第二个参数（<literal>np</literal>），该函数接收一个指向应该保存操作结果的decimal变量的指针。
       </para>
<!-- pgdoc-cn_end sig_en=ca5caa89e31c0432823a1c8eff4d35e5 -->
<!-- pgdoc-cn_start sig_en=68434610608694f1cf3e46b60394c240 sig_cn_org=214ff2ffa985a8f1cf5bfa93ef29c121 source=15.7 
       <para>
        The function returns 0 on success and a negative value if the
        conversion failed.
       </para>
________________________________________________________-->
       <para>
        该函数在成功时返回0，在转换失败时返回负值。
       </para>
<!-- pgdoc-cn_end sig_en=68434610608694f1cf3e46b60394c240 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decdiv</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=846b5186b0f13f0ce54da8b55843e7bd sig_cn_org=ccf9b06cc6a3f283de3858becbf78092 source=15.7 
       <para>
        Divide two variables of type decimal.
<synopsis>
int decdiv(decimal *n1, decimal *n2, decimal *result);
</synopsis>
        The function receives pointers to the variables that are the first
        (<literal>n1</literal>) and the second (<literal>n2</literal>) operands and
        calculates <literal>n1</literal>/<literal>n2</literal>. <literal>result</literal> is a
        pointer to the variable that should hold the result of the operation.
       </para>
________________________________________________________-->
       <para>
        将两个decimal类型的变量相除。
<synopsis>
int decdiv(decimal *n1, decimal *n2, decimal *result);
</synopsis>
        该函数接收指向第一个（<literal>n1</literal>）和第二个（<literal>n2</literal>）操作数的变量的指针，
        并计算<literal>n1</literal>/<literal>n2</literal>。 <literal>result</literal>是应该保存操作结果的变量的指针。
       </para>
<!-- pgdoc-cn_end sig_en=846b5186b0f13f0ce54da8b55843e7bd -->
<!-- pgdoc-cn_start sig_en=4ec60072727d75cb4274f1f4807cdaed sig_cn_org=222c5cdb275cd52964595434e0b6932c source=15.7 
       <para>
        On success, 0 is returned and a negative value if the division fails.
        If overflow or underflow occurred, the function returns
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> or
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal> respectively. If an attempt to
        divide by zero is observed, the function returns
        <literal>ECPG_INFORMIX_DIVIDE_ZERO</literal>.
       </para>
________________________________________________________-->
       <para>
        在成功时返回0，如果除法失败则返回负值。
        如果发生溢出或下溢，则函数分别返回
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal>或
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal>。如果尝试
        除以零，则函数返回<literal>ECPG_INFORMIX_DIVIDE_ZERO</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=4ec60072727d75cb4274f1f4807cdaed -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decmul</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=ca0bcdb36c1524c3f983abd720ecf4e5 sig_cn_org=540868b00cc758fd9e8e0be232240c08 source=15.7 
       <para>
        Multiply two decimal values.
<synopsis>
int decmul(decimal *n1, decimal *n2, decimal *result);
</synopsis>
        The function receives pointers to the variables that are the first
        (<literal>n1</literal>) and the second (<literal>n2</literal>) operands and
        calculates <literal>n1</literal>*<literal>n2</literal>. <literal>result</literal> is a
        pointer to the variable that should hold the result of the operation.
       </para>
________________________________________________________-->
       <para>
        两个十进制值相乘。
<synopsis>
int decmul(decimal *n1, decimal *n2, decimal *result);
</synopsis>
        该函数接收指向第一个（<literal>n1</literal>）和第二个（<literal>n2</literal>）操作数的变量的指针，
        并计算<literal>n1</literal>*<literal>n2</literal>。 <literal>result</literal>是一个指向应该保存操作结果的变量的指针。
       </para>
<!-- pgdoc-cn_end sig_en=ca0bcdb36c1524c3f983abd720ecf4e5 -->
<!-- pgdoc-cn_start sig_en=6e146343b6cf8502f83a136dc069bd31 sig_cn_org=163172e7aa066f2ce6bad90f5af4db97 source=15.7 
       <para>
        On success, 0 is returned and a negative value if the multiplication
        fails. If overflow or underflow occurred, the function returns
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> or
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal> respectively.
       </para>
________________________________________________________-->
       <para>
        在成功时返回0，如果乘法失败则返回负值。如果发生溢出或下溢，函数分别返回
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal>或
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=6e146343b6cf8502f83a136dc069bd31 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>decsub</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=dbfbab5b8c7f1aee89752299bcd7723f sig_cn_org=16a3f56c409df9af3b84fde6a25d22e1 source=15.7 
       <para>
        Subtract one decimal value from another.
<synopsis>
int decsub(decimal *n1, decimal *n2, decimal *result);
</synopsis>
        The function receives pointers to the variables that are the first
        (<literal>n1</literal>) and the second (<literal>n2</literal>) operands and
        calculates <literal>n1</literal>-<literal>n2</literal>. <literal>result</literal> is a
        pointer to the variable that should hold the result of the operation.
       </para>
________________________________________________________-->
       <para>
        从另一个十进制值中减去一个十进制值。
<synopsis>
int decsub(decimal *n1, decimal *n2, decimal *result);
</synopsis>
        该函数接收指向第一个（<literal>n1</literal>）和第二个（<literal>n2</literal>）操作数的变量的指针，
        并计算<literal>n1</literal>-<literal>n2</literal>。 <literal>result</literal>是应该保存操作结果的变量的指针。
       </para>
<!-- pgdoc-cn_end sig_en=dbfbab5b8c7f1aee89752299bcd7723f -->
<!-- pgdoc-cn_start sig_en=6a9dd4262cc4fba483419d7827b161d6 sig_cn_org=0d939164116cc17d5d3b4f992fbb874d source=15.7 
       <para>
        On success, 0 is returned and a negative value if the subtraction
        fails. If overflow or underflow occurred, the function returns
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal> or
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal> respectively.
       </para>
________________________________________________________-->
       <para>
        在成功时返回0，如果减法失败则返回负值。如果发生溢出或下溢，函数分别返回
        <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal>或
        <literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=6a9dd4262cc4fba483419d7827b161d6 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectoasc</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=a24f205055851bffc9da330e95df13cb sig_cn_org=d057fc44fb6a03eb87799ff85507e2c2 source=15.7 
       <para>
        Convert a variable of type decimal to its ASCII representation in a C
        char* string.
<synopsis>
int dectoasc(decimal *np, char *cp, int len, int right)
</synopsis>
        The function receives a pointer to a variable of type decimal
        (<literal>np</literal>) that it converts to its textual representation.
        <literal>cp</literal> is the buffer that should hold the result of the
        operation. The parameter <literal>right</literal> specifies, how many digits
        right of the decimal point should be included in the output. The result
        will be rounded to this number of decimal digits. Setting
        <literal>right</literal> to -1 indicates that all available decimal digits
        should be included in the output. If the length of the output buffer,
        which is indicated by <literal>len</literal> is not sufficient to hold the
        textual representation including the trailing zero byte, only a
        single <literal>*</literal> character is stored in the result and -1 is
        returned.
       </para>
________________________________________________________-->
       <para>
        将decimal类型的变量转换为C char*字符串中的ASCII表示。
<synopsis>
int dectoasc(decimal *np, char *cp, int len, int right)
</synopsis>
        该函数接收一个指向decimal类型变量的指针（<literal>np</literal>），将其转换为文本表示。
        <literal>cp</literal>是应该保存操作结果的缓冲区。参数<literal>right</literal>指定输出中小数点右侧应包含的位数。
        结果将四舍五入到这个小数位数。将<literal>right</literal>设置为-1表示应在输出中包含所有可用的小数位数。
        如果输出缓冲区的长度，由<literal>len</literal>指示，不足以容纳包括尾随零字节在内的文本表示，
        则结果中仅存储一个<literal>*</literal>字符，并返回-1。
</para>
<!-- pgdoc-cn_end sig_en=a24f205055851bffc9da330e95df13cb -->
<!-- pgdoc-cn_start sig_en=efdf8e278e55aab82ab7f1d4c14a3d6a sig_cn_org=466438cdde92a82b54e89d55cf717ea1 source=15.7 
       <para>
        The function returns either -1 if the buffer <literal>cp</literal> was too
        small or <literal>ECPG_INFORMIX_OUT_OF_MEMORY</literal> if memory was
        exhausted.
       </para>
________________________________________________________-->
       <para>
        该函数返回-1，如果缓冲区<literal>cp</literal>太小，或者返回<literal>ECPG_INFORMIX_OUT_OF_MEMORY</literal>，
        如果内存耗尽。
       </para>
<!-- pgdoc-cn_end sig_en=efdf8e278e55aab82ab7f1d4c14a3d6a -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectodbl</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=0b72f23adb968001977ba7fc2cae7e9b sig_cn_org=b75903f5314c9a4afd47ffd9cf283119 source=15.7 
       <para>
        Convert a variable of type decimal to a double.
<synopsis>
int dectodbl(decimal *np, double *dblp);
</synopsis>
        The function receives a pointer to the decimal value to convert
        (<literal>np</literal>) and a pointer to the double variable that
        should hold the result of the operation (<literal>dblp</literal>).
       </para>
________________________________________________________-->
       <para>
        将类型为decimal的变量转换为double类型。
<synopsis>
int dectodbl(decimal *np, double *dblp);
</synopsis>
        该函数接收一个指向要转换的decimal值的指针
        (<literal>np</literal>)，以及一个指向应该保存操作结果的double变量的指针
        (<literal>dblp</literal>)。
       </para>
<!-- pgdoc-cn_end sig_en=0b72f23adb968001977ba7fc2cae7e9b -->
<!-- pgdoc-cn_start sig_en=9a876986f78df04f86d597299afe3118 sig_cn_org=6e3df2cdab843d8d834ec4f02fe4a8bf source=15.7 
       <para>
        On success, 0 is returned and a negative value if the conversion
        failed.
       </para>
________________________________________________________-->
       <para>
        当成功时，返回0；如果转换失败，则返回负值。
       </para>
<!-- pgdoc-cn_end sig_en=9a876986f78df04f86d597299afe3118 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectoint</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=2bf04e1613184f0766084b3dd80a6faa sig_cn_org=0ff38b4ffccaf4d1ff88bb59fa8e22c3 source=15.7 
       <para>
        Convert a variable of type decimal to an integer.
<synopsis>
int dectoint(decimal *np, int *ip);
</synopsis>
        The function receives a pointer to the decimal value to convert
        (<literal>np</literal>) and a pointer to the integer variable that
        should hold the result of the operation (<literal>ip</literal>).
       </para>
________________________________________________________-->
       <para>
        将类型为decimal的变量转换为整数。
<synopsis>
int dectoint(decimal *np, int *ip);
</synopsis>
        该函数接收一个指向要转换的decimal值的指针
        (<literal>np</literal>)，以及一个指向应该保存操作结果的整数变量的指针
        (<literal>ip</literal>)。
       </para>
<!-- pgdoc-cn_end sig_en=2bf04e1613184f0766084b3dd80a6faa -->
<!-- pgdoc-cn_start sig_en=c0bd27d7e30ad872576630af05b17fa9 sig_cn_org=9b11fc629e9985e4c278fe6fd1337bcd source=15.7 
       <para>
        On success, 0 is returned and a negative value if the conversion
        failed. If an overflow occurred, <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal>
        is returned.
       </para>
________________________________________________________-->
       <para>
        当成功时，返回0；如果转换失败，则返回负值。如果发生溢出，将返回<literal>ECPG_INFORMIX_NUM_OVERFLOW</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=c0bd27d7e30ad872576630af05b17fa9 -->
<!-- pgdoc-cn_start sig_en=c04b11684fc30f5c9f73f60470ad759a sig_cn_org=00fa842074d868615c8b2d0cda3e4af1 source=15.7 
       <para>
        Note that the ECPG implementation differs from the <productname>Informix</productname>
        implementation. <productname>Informix</productname> limits an integer to the range from -32767 to
        32767, while the limits in the ECPG implementation depend on the
        architecture (<literal>INT_MIN .. INT_MAX</literal>).
       </para>
________________________________________________________-->
       <para>
        请注意，ECPG实现与<productname>Informix</productname>实现不同。
        <productname>Informix</productname>将整数限制在-32767到32767的范围内，
        而ECPG实现中的限制取决于架构（<literal>INT_MIN .. INT_MAX</literal>）。
       </para>
<!-- pgdoc-cn_end sig_en=c04b11684fc30f5c9f73f60470ad759a -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dectolong</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=5e48404a0b70f4e2ab9e3adf909deb5b sig_cn_org=8753d02e911d4d92565fc6ecaf381bed source=15.7 
       <para>
        Convert a variable of type decimal to a long integer.
<synopsis>
int dectolong(decimal *np, long *lngp);
</synopsis>
        The function receives a pointer to the decimal value to convert
        (<literal>np</literal>) and a pointer to the long variable that
        should hold the result of the operation (<literal>lngp</literal>).
       </para>
________________________________________________________-->
       <para>
        将decimal类型的变量转换为长整型。
<synopsis>
int dectolong(decimal *np, long *lngp);
</synopsis>
        该函数接收一个指向要转换的decimal值的指针
        (<literal>np</literal>)，以及一个指向应该保存操作结果的长整型变量的指针
        (<literal>lngp</literal>)。
       </para>
<!-- pgdoc-cn_end sig_en=5e48404a0b70f4e2ab9e3adf909deb5b -->
<!-- pgdoc-cn_start sig_en=c0bd27d7e30ad872576630af05b17fa9 sig_cn_org=9b11fc629e9985e4c278fe6fd1337bcd source=15.7 
       <para>
        On success, 0 is returned and a negative value if the conversion
        failed. If an overflow occurred, <literal>ECPG_INFORMIX_NUM_OVERFLOW</literal>
        is returned.
       </para>
________________________________________________________-->
       <para>
        当成功时，返回0；如果转换失败，则返回负值。如果发生溢出，将返回<literal>ECPG_INFORMIX_NUM_OVERFLOW</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=c0bd27d7e30ad872576630af05b17fa9 -->
<!-- pgdoc-cn_start sig_en=3469524aae0b65c1c64710ea87f9b720 sig_cn_org=7e746945ac3956e625b4d3cb7d152662 source=15.7 
       <para>
        Note that the ECPG implementation differs from the <productname>Informix</productname>
        implementation. <productname>Informix</productname> limits a long integer to the range from
        -2,147,483,647 to 2,147,483,647, while the limits in the ECPG
        implementation depend on the architecture (<literal>-LONG_MAX ..
        LONG_MAX</literal>).
       </para>
________________________________________________________-->
       <para>
        请注意，ECPG实现与<productname>Informix</productname>实现不同。
        <productname>Informix</productname>将长整型限制在-2,147,483,647到2,147,483,647的范围内，
        而ECPG实现中的限制取决于架构（<literal>-LONG_MAX .. LONG_MAX</literal>）。
       </para>
<!-- pgdoc-cn_end sig_en=3469524aae0b65c1c64710ea87f9b720 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdatestr</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=1f47f0a34c6d24b78c61b805551a7934 sig_cn_org=7919efcc9ed5be237a0a947c90bb5f93 source=15.7 
       <para>
        Converts a date to a C char* string.
<synopsis>
int rdatestr(date d, char *str);
</synopsis>
        The function receives two arguments, the first one is the date to
        convert (<literal>d</literal>) and the second one is a pointer to the target
        string. The output format is always <literal>yyyy-mm-dd</literal>, so you need
        to allocate at least 11 bytes (including the zero-byte terminator) for the
        string.
       </para>
________________________________________________________-->
       <para>
        将日期转换为C char*字符串。
<synopsis>
int rdatestr(date d, char *str);
</synopsis>
        该函数接收两个参数，第一个是要转换的日期（<literal>d</literal>），第二个是指向目标字符串的指针。
        输出格式始终为<literal>yyyy-mm-dd</literal>，因此您需要为字符串分配至少11个字节（包括零字节终止符）。
       </para>
<!-- pgdoc-cn_end sig_en=1f47f0a34c6d24b78c61b805551a7934 -->
<!-- pgdoc-cn_start sig_en=7ad3114a40192a224b12bb7872b82512 sig_cn_org=90e72537e6db226d319deb73c37ce3d3 source=15.7 
       <para>
        The function returns 0 on success and a negative value in case of
        error.
       </para>
________________________________________________________-->
       <para>
        该函数在成功时返回0，在错误时返回负值。
       </para>
<!-- pgdoc-cn_end sig_en=7ad3114a40192a224b12bb7872b82512 -->
<!-- pgdoc-cn_start sig_en=e9b2d98a9c72aa8f1c675d96c15cbc36 sig_cn_org=9ca20f4b44d03328550446208bcafc44 source=15.7 
       <para>
        Note that ECPG's implementation differs from the <productname>Informix</productname>
        implementation. In <productname>Informix</productname> the format can be influenced by setting
        environment variables. In ECPG however, you cannot change the output
        format.
       </para>
________________________________________________________-->
       <para>
        请注意，ECPG的实现与<productname>Informix</productname>的实现不同。在<productname>Informix</productname>中，
        格式可以通过设置环境变量来影响。然而，在ECPG中，您无法更改输出格式。
       </para>
<!-- pgdoc-cn_end sig_en=e9b2d98a9c72aa8f1c675d96c15cbc36 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rstrdate</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=76980b96807ab058401e4dc2dc18abe5 sig_cn_org=fa0f3148b5222a94009ab06f783fd70e source=15.7 
       <para>
        Parse the textual representation of a date.
<synopsis>
int rstrdate(char *str, date *d);
</synopsis>
        The function receives the textual representation of the date to convert
        (<literal>str</literal>) and a pointer to a variable of type date
        (<literal>d</literal>). This function does not allow you to specify a format
        mask. It uses the default format mask of <productname>Informix</productname> which is
        <literal>mm/dd/yyyy</literal>. Internally, this function is implemented by
        means of <function>rdefmtdate</function>. Therefore, <function>rstrdate</function> is
        not faster and if you have the choice you should opt for
        <function>rdefmtdate</function> which allows you to specify the format mask
        explicitly.
       </para>
________________________________________________________-->
       <para>
        解析日期的文本表示。
<synopsis>
int rstrdate(char *str, date *d);
</synopsis>
        该函数接收要转换的日期的文本表示（<literal>str</literal>）和指向类型为date的变量的指针
        （<literal>d</literal>）。此函数不允许您指定格式掩码。它使用<productname>Informix</productname>的默认格式掩码，
        即<literal>mm/dd/yyyy</literal>。在内部，此函数通过<function>rdefmtdate</function>实现。
        因此，<function>rstrdate</function>不会更快，如果可以选择，应选择允许您显式指定格式掩码的
        <function>rdefmtdate</function>。
       </para>
<!-- pgdoc-cn_end sig_en=76980b96807ab058401e4dc2dc18abe5 -->
<!-- pgdoc-cn_start sig_en=4852b86f80bf31d20a21292fe6093752 sig_cn_org=181b697acfe769c8f9c1f013e0d8e8d9 source=15.7 
       <para>
        The function returns the same values as <function>rdefmtdate</function>.
       </para>
________________________________________________________-->
       <para>
        这个函数返回与<function>rdefmtdate</function>相同的值。
       </para>
<!-- pgdoc-cn_end sig_en=4852b86f80bf31d20a21292fe6093752 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtoday</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=2b8fce6e0cbb168f56f4fd83d99793c6 sig_cn_org=b69a012fd3d7a87928a03880e2aa2e47 source=15.7 
       <para>
        Get the current date.
<synopsis>
void rtoday(date *d);
</synopsis>
        The function receives a pointer to a date variable (<literal>d</literal>)
        that it sets to the current date.
       </para>
________________________________________________________-->
       <para>
        获取当前日期。
<synopsis>
void rtoday(date *d);
</synopsis>
        该函数接收一个指向日期变量（<literal>d</literal>）的指针，将其设置为当前日期。
       </para>
<!-- pgdoc-cn_end sig_en=2b8fce6e0cbb168f56f4fd83d99793c6 -->
<!-- pgdoc-cn_start sig_en=421a01ca47490056fbb441b552e4d0cc sig_cn_org=1e9b30a683bd01d9482264540de29273 source=15.7 
       <para>
        Internally this function uses the <xref linkend="pgtypesdatetoday"/>
        function.
       </para>
________________________________________________________-->
       <para>
        在内部，此函数使用<xref linkend="pgtypesdatetoday"/>函数。
       </para>
<!-- pgdoc-cn_end sig_en=421a01ca47490056fbb441b552e4d0cc -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rjulmdy</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=85a3e8b257f1689334b9ac8407634426 sig_cn_org=8f31373bc9c526faa6630d3c318d9891 source=15.7 
       <para>
        Extract the values for the day, the month and the year from a variable
        of type date.
<synopsis>
int rjulmdy(date d, short mdy[3]);
</synopsis>
        The function receives the date <literal>d</literal> and a pointer to an array
        of 3 short integer values <literal>mdy</literal>. The variable name indicates
        the sequential order: <literal>mdy[0]</literal> will be set to contain the
        number of the month, <literal>mdy[1]</literal> will be set to the value of the
        day and <literal>mdy[2]</literal> will contain the year.
       </para>
________________________________________________________-->
       <para>
        从一个类型为date的变量中提取日、月和年的值。
<synopsis>
int rjulmdy(date d, short mdy[3]);
</synopsis>
        该函数接收日期<literal>d</literal>和一个指向包含3个short整数值的数组<literal>mdy</literal>的指针。
        变量名指示了顺序：<literal>mdy[0]</literal>将被设置为包含月份的数字，
        <literal>mdy[1]</literal>将被设置为日期的值，<literal>mdy[2]</literal>将包含年份。
</para>
<!-- pgdoc-cn_end sig_en=85a3e8b257f1689334b9ac8407634426 -->
<!-- pgdoc-cn_start sig_en=268824c487bcff2be7d9ad27a7cad230 sig_cn_org=f49ba1d53a8fec2c268b6208c5c43d25 source=15.7 
       <para>
        The function always returns 0 at the moment.
       </para>
________________________________________________________-->
       <para>
        这个函数目前总是返回0。
       </para>
<!-- pgdoc-cn_end sig_en=268824c487bcff2be7d9ad27a7cad230 -->
<!-- pgdoc-cn_start sig_en=d34dd4e3307647827eaccdf2a464db10 sig_cn_org=8d85e414e01b1ab4fea80c397e336ed0 source=15.7 
       <para>
        Internally the function uses the <xref linkend="pgtypesdatejulmdy"/>
        function.
       </para>
________________________________________________________-->
       <para>
        在内部，该函数使用<xref linkend="pgtypesdatejulmdy"/>函数。
       </para>
<!-- pgdoc-cn_end sig_en=d34dd4e3307647827eaccdf2a464db10 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdefmtdate</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=f2f6b040f2bf69509f4f71da84c8676d sig_cn_org=3bee5f97a1ca0b27ac883f235870202f source=15.7 
       <para>
        Use a format mask to convert a character string to a value of type
        date.
<synopsis>
int rdefmtdate(date *d, char *fmt, char *str);
</synopsis>
        The function receives a pointer to the date value that should hold the
        result of the operation (<literal>d</literal>), the format mask to use for
        parsing the date (<literal>fmt</literal>) and the C char* string containing
        the textual representation of the date (<literal>str</literal>). The textual
        representation is expected to match the format mask. However you do not
        need to have a 1:1 mapping of the string to the format mask. The
        function only analyzes the sequential order and looks for the literals
        <literal>yy</literal> or <literal>yyyy</literal> that indicate the
        position of the year, <literal>mm</literal> to indicate the position of
        the month and <literal>dd</literal> to indicate the position of the
        day.
       </para>
________________________________________________________-->
       <para>
        使用格式掩码将字符字符串转换为日期类型的值。
<synopsis>
int rdefmtdate(date *d, char *fmt, char *str);
</synopsis>
        该函数接收一个指向应该保存操作结果的日期值的指针（<literal>d</literal>），
        用于解析日期的格式掩码（<literal>fmt</literal>）和包含日期文本表示的C char*字符串
        （<literal>str</literal>）。文本表示应与格式掩码匹配。但是，您不需要将字符串
        与格式掩码进行一一映射。该函数仅分析顺序顺序，并查找表示年份位置的文字
        <literal>yy</literal>或<literal>yyyy</literal>，表示月份位置的<literal>mm</literal>
        和表示日期位置的<literal>dd</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=f2f6b040f2bf69509f4f71da84c8676d -->
<!-- pgdoc-cn_start sig_en=355378b92be1fc42a666912918300121 sig_cn_org=92387ca861e6d08dc3bf36a8a1d88fb0 source=15.7 
       <para>
        The function returns the following values:
        <itemizedlist>
         <listitem>
          <para>
           0 - The function terminated successfully.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_ENOSHORTDATE</literal> - The date does not contain
           delimiters between day, month and year. In this case the input
           string must be exactly 6 or 8 bytes long but isn't.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_ENOTDMY</literal> - The format string did not
           correctly indicate the sequential order of year, month and day.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_BAD_DAY</literal> - The input string does not
           contain a valid day.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_BAD_MONTH</literal> - The input string does not
           contain a valid month.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_BAD_YEAR</literal> - The input string does not
           contain a valid year.
          </para>
         </listitem>
        </itemizedlist>
       </para>
________________________________________________________-->
       <para>
        该函数返回以下值:
        <itemizedlist>
         <listitem>
          <para>
           0 - 函数成功终止。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_ENOSHORTDATE</literal> - 日期不包含
           日、月和年之间的分隔符。在这种情况下，输入
           字符串必须恰好为6或8个字节长，但实际不是。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_ENOTDMY</literal> - 格式字符串未正确指示
           年、月和日的顺序。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_BAD_DAY</literal> - 输入字符串不包含
           有效的日。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_BAD_MONTH</literal> - 输入字符串不包含
           有效的月。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>ECPG_INFORMIX_BAD_YEAR</literal> - 输入字符串不包含
           有效的年。
          </para>
         </listitem>
        </itemizedlist>
       </para>
<!-- pgdoc-cn_end sig_en=355378b92be1fc42a666912918300121 -->
<!-- pgdoc-cn_start sig_en=b240c94f27bfd4cbbbdccb2b6430ff10 sig_cn_org=76f72cbd0390c4253b2bf72e76fb7052 source=15.7 
       <para>
        Internally this function is implemented to use the <xref
        linkend="pgtypesdatedefmtasc"/> function. See the reference there for a
        table of example input.
       </para>
________________________________________________________-->
       <para>
        在内部，此函数实现为使用<xref linkend="pgtypesdatedefmtasc"/>函数。请参阅那里的参考资料，了解示例输入表。
       </para>
<!-- pgdoc-cn_end sig_en=b240c94f27bfd4cbbbdccb2b6430ff10 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rfmtdate</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=8eed016dac4d7ee1f3d50101439bf10f sig_cn_org=168fb87bc670727290a87fd6a22faa86 source=15.7 
       <para>
        Convert a variable of type date to its textual representation using a
        format mask.
<synopsis>
int rfmtdate(date d, char *fmt, char *str);
</synopsis>
        The function receives the date to convert (<literal>d</literal>), the format
        mask (<literal>fmt</literal>) and the string that will hold the textual
        representation of the date (<literal>str</literal>).
       </para>
________________________________________________________-->
       <para>
        将日期类型的变量使用格式掩码转换为其文本表示形式。
<synopsis>
int rfmtdate(date d, char *fmt, char *str);
</synopsis>
        该函数接收要转换的日期（<literal>d</literal>）、格式掩码（<literal>fmt</literal>）和将保存日期文本表示的字符串（<literal>str</literal>）。
       </para>
<!-- pgdoc-cn_end sig_en=8eed016dac4d7ee1f3d50101439bf10f -->
<!-- pgdoc-cn_start sig_en=a377f921c202fc7b7c5b92e44c07b4b3 sig_cn_org=0f3548016b24e3cfdf8c58b01222ff2a source=15.7 
       <para>
        On success, 0 is returned and a negative value if an error occurred.
       </para>
________________________________________________________-->
       <para>
        当成功时，返回0；发生错误时返回负值。
       </para>
<!-- pgdoc-cn_end sig_en=a377f921c202fc7b7c5b92e44c07b4b3 -->
<!-- pgdoc-cn_start sig_en=680182f1a74fd38e96855f6e90da1974 sig_cn_org=86d1f6b7350a0c919bef2408b5583b90 source=15.7 
       <para>
        Internally this function uses the <xref linkend="pgtypesdatefmtasc"/>
        function, see the reference there for examples.
       </para>
________________________________________________________-->
       <para>
        在内部，此函数使用<xref linkend="pgtypesdatefmtasc"/>函数，有关示例，请参阅那里的参考资料。
       </para>
<!-- pgdoc-cn_end sig_en=680182f1a74fd38e96855f6e90da1974 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rmdyjul</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=ed672550f9165efcc72c89dc6f0fd79e sig_cn_org=661bad9babd35f231d6cc4f2bd0bb573 source=15.7 
       <para>
        Create a date value from an array of 3 short integers that specify the
        day, the month and the year of the date.
<synopsis>
int rmdyjul(short mdy[3], date *d);
</synopsis>
        The function receives the array of the 3 short integers
        (<literal>mdy</literal>) and a pointer to a variable of type date that should
        hold the result of the operation.
       </para>
________________________________________________________-->
       <para>
        从指定日期的一组3个短整数创建一个日期值，这些整数指定了日期的日、月和年。
<synopsis>
int rmdyjul(short mdy[3], date *d);
</synopsis>
        该函数接收一个包含3个短整数的数组（<literal>mdy</literal>）和一个指向应该保存操作结果的date类型变量的指针。
</para>
<!-- pgdoc-cn_end sig_en=ed672550f9165efcc72c89dc6f0fd79e -->
<!-- pgdoc-cn_start sig_en=d3e9c33c63f11ed30fb791185ecb84ce sig_cn_org=345995ad622a51a873e51ff4fe3b7e3d source=15.7 
       <para>
        Currently the function returns always 0.
       </para>
________________________________________________________-->
       <para>
        目前该函数始终返回0。
       </para>
<!-- pgdoc-cn_end sig_en=d3e9c33c63f11ed30fb791185ecb84ce -->
<!-- pgdoc-cn_start sig_en=a04136b54bab896da6c37730f0df0450 sig_cn_org=5f772e9e1271fcba27bb0f927740fae0 source=15.7 
       <para>
        Internally the function is implemented to use the function <xref
        linkend="pgtypesdatemdyjul"/>.
       </para>
________________________________________________________-->
       <para>
        在内部，该函数实现为使用函数<xref linkend="pgtypesdatemdyjul"/>。
       </para>
<!-- pgdoc-cn_end sig_en=a04136b54bab896da6c37730f0df0450 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rdayofweek</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=d3384ef9e7439d95ea6cc9214776296d sig_cn_org=cb7c5fa9a41109514ef9bd4710fc3a7a source=15.7 
       <para>
        Return a number representing the day of the week for a date value.
<synopsis>
int rdayofweek(date d);
</synopsis>
        The function receives the date variable <literal>d</literal> as its only
        argument and returns an integer that indicates the day of the week for
        this date.
        <itemizedlist>
         <listitem>
          <para>
           0 - Sunday
          </para>
         </listitem>
         <listitem>
          <para>
           1 - Monday
          </para>
         </listitem>
         <listitem>
          <para>
           2 - Tuesday
          </para>
         </listitem>
         <listitem>
          <para>
           3 - Wednesday
          </para>
         </listitem>
         <listitem>
          <para>
           4 - Thursday
          </para>
         </listitem>
         <listitem>
          <para>
           5 - Friday
          </para>
         </listitem>
         <listitem>
          <para>
           6 - Saturday
          </para>
         </listitem>
        </itemizedlist>
       </para>
________________________________________________________-->
       <para>
        返回表示日期值的星期几的数字。
<synopsis>
int rdayofweek(date d);
</synopsis>
        该函数接收日期变量<literal>d</literal>作为其唯一参数，并返回一个整数，表示该日期的星期几。
        <itemizedlist>
         <listitem>
          <para>
           0 - 星期日
          </para>
         </listitem>
         <listitem>
          <para>
           1 - 星期一
          </para>
         </listitem>
         <listitem>
          <para>
           2 - 星期二
          </para>
         </listitem>
         <listitem>
          <para>
           3 - 星期三
          </para>
         </listitem>
         <listitem>
          <para>
           4 - 星期四
          </para>
         </listitem>
         <listitem>
          <para>
           5 - 星期五
          </para>
         </listitem>
         <listitem>
          <para>
           6 - 星期六
          </para>
         </listitem>
        </itemizedlist>
       </para>
<!-- pgdoc-cn_end sig_en=d3384ef9e7439d95ea6cc9214776296d -->
<!-- pgdoc-cn_start sig_en=abdfccb684dcf5a38e6ecdc410c7f038 sig_cn_org=455552f42847bb6fe56b0a8692e25bbb source=15.7 
       <para>
        Internally the function is implemented to use the function <xref
        linkend="pgtypesdatedayofweek"/>.
       </para>
________________________________________________________-->
       <para>
        在内部，该函数被实现为使用函数<xref linkend="pgtypesdatedayofweek"/>。
       </para>
<!-- pgdoc-cn_end sig_en=abdfccb684dcf5a38e6ecdc410c7f038 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcurrent</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=22ad9f190989c75b885cfda86f5f89bb sig_cn_org=c49a36e37f7c11232bf47ae138bd0f8e source=15.7 
       <para>
        Retrieve the current timestamp.
<synopsis>
void dtcurrent(timestamp *ts);
</synopsis>
        The function retrieves the current timestamp and saves it into the
        timestamp variable that <literal>ts</literal> points to.
       </para>
________________________________________________________-->
       <para>
        检索当前时间戳。
<synopsis>
void dtcurrent(timestamp *ts);
</synopsis>
        该函数检索当前时间戳，并将其保存到<literal>ts</literal>指向的时间戳变量中。
</para>
<!-- pgdoc-cn_end sig_en=22ad9f190989c75b885cfda86f5f89bb -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcvasc</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=91036cad0e8ac48257d24f4ac3b1e19f sig_cn_org=93957c7e88d06ae336a65cb4587786be source=15.7 
       <para>
        Parses a timestamp from its textual representation
        into a timestamp variable.
<synopsis>
int dtcvasc(char *str, timestamp *ts);
</synopsis>
        The function receives the string to parse (<literal>str</literal>) and a
        pointer to the timestamp variable that should hold the result of the
        operation (<literal>ts</literal>).
       </para>
________________________________________________________-->
       <para>
        将时间戳从其文本表示解析为时间戳变量。
<synopsis>
int dtcvasc(char *str, timestamp *ts);
</synopsis>
        该函数接收要解析的字符串（<literal>str</literal>）和指向应该保存操作结果的时间戳变量的指针（<literal>ts</literal>）。
       </para>
<!-- pgdoc-cn_end sig_en=91036cad0e8ac48257d24f4ac3b1e19f -->
<!-- pgdoc-cn_start sig_en=7ad3114a40192a224b12bb7872b82512 sig_cn_org=90e72537e6db226d319deb73c37ce3d3 source=15.7 
       <para>
        The function returns 0 on success and a negative value in case of
        error.
       </para>
________________________________________________________-->
       <para>
        该函数在成功时返回0，在错误时返回负值。
       </para>
<!-- pgdoc-cn_end sig_en=7ad3114a40192a224b12bb7872b82512 -->
<!-- pgdoc-cn_start sig_en=24f82eaf19fc07a39a81b9f63cfe3adb sig_cn_org=1e4f09e0657223173d31ce0167eb4d9b source=15.7 
       <para>
        Internally this function uses the <xref
        linkend="pgtypestimestampfromasc"/> function. See the reference there
        for a table with example inputs.
       </para>
________________________________________________________-->
       <para>
        在内部，此函数使用<xref linkend="pgtypestimestampfromasc"/>函数。请参阅那里的参考资料，了解包含示例输入的表格。
       </para>
<!-- pgdoc-cn_end sig_en=24f82eaf19fc07a39a81b9f63cfe3adb -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtcvfmtasc</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=45ca6ce6358923707507543ea25ba0dd sig_cn_org=29d6b4399c86d5d5a4659c902f8869b2 source=15.7 
       <para>
        Parses a timestamp from its textual representation
        using a format mask into a timestamp variable.
<synopsis>
dtcvfmtasc(char *inbuf, char *fmtstr, timestamp *dtvalue)
</synopsis>
        The function receives the string to parse (<literal>inbuf</literal>), the
        format mask to use (<literal>fmtstr</literal>) and a pointer to the timestamp
        variable that should hold the result of the operation
        (<literal>dtvalue</literal>).
       </para>
________________________________________________________-->
       <para>
        从文本表示中使用格式掩码解析时间戳为时间戳变量。
<synopsis>
dtcvfmtasc(char *inbuf, char *fmtstr, timestamp *dtvalue)
</synopsis>
        该函数接收要解析的字符串（<literal>inbuf</literal>）、要使用的格式掩码
        （<literal>fmtstr</literal>）以及应该保存操作结果的时间戳变量的指针
        （<literal>dtvalue</literal>）。
       </para>
<!-- pgdoc-cn_end sig_en=45ca6ce6358923707507543ea25ba0dd -->
<!-- pgdoc-cn_start sig_en=a9c48563e1bab7678e2a86f3a482adc1 sig_cn_org=fd5c815d545ab561ef930e1ee07aba86 source=15.7 
       <para>
        This function is implemented by means of the <xref
        linkend="pgtypestimestampdefmtasc"/> function. See the documentation
        there for a list of format specifiers that can be used.
       </para>
________________________________________________________-->
       <para>
        这个函数是通过<xref linkend="pgtypestimestampdefmtasc"/>函数实现的。请参阅那里的文档，了解可用的格式说明符列表。
       </para>
<!-- pgdoc-cn_end sig_en=a9c48563e1bab7678e2a86f3a482adc1 -->
<!-- pgdoc-cn_start sig_en=7ad3114a40192a224b12bb7872b82512 sig_cn_org=90e72537e6db226d319deb73c37ce3d3 source=15.7 
       <para>
        The function returns 0 on success and a negative value in case of
        error.
       </para>
________________________________________________________-->
       <para>
        该函数在成功时返回0，在错误时返回负值。
       </para>
<!-- pgdoc-cn_end sig_en=7ad3114a40192a224b12bb7872b82512 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dtsub</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=1818b2a8d96cdf7e82606c530e64a8ac sig_cn_org=0b03e26be04c5b877cbf897157c1dce4 source=15.7 
       <para>
        Subtract one timestamp from another and return a variable of type
        interval.
<synopsis>
int dtsub(timestamp *ts1, timestamp *ts2, interval *iv);
</synopsis>
        The function will subtract the timestamp variable that <literal>ts2</literal>
        points to from the timestamp variable that <literal>ts1</literal> points to
        and will store the result in the interval variable that <literal>iv</literal>
        points to.
       </para>
________________________________________________________-->
       <para>
        从一个时间戳减去另一个时间戳，并返回一个间隔类型的变量。
<synopsis>
int dtsub(timestamp *ts1, timestamp *ts2, interval *iv);
</synopsis>
        该函数将从<literal>ts1</literal>指向的时间戳变量中减去<literal>ts2</literal>指向的时间戳变量，
        并将结果存储在<literal>iv</literal>指向的间隔变量中。
       </para>
<!-- pgdoc-cn_end sig_en=1818b2a8d96cdf7e82606c530e64a8ac -->
<!-- pgdoc-cn_start sig_en=e878766ff1009e018fed122a3ee838f2 sig_cn_org=d33969792e2e69de9d63bd993bf4f234 source=15.7 
       <para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
________________________________________________________-->
       <para>
        当成功时，该函数返回0，如果发生错误则返回负值。
       </para>
<!-- pgdoc-cn_end sig_en=e878766ff1009e018fed122a3ee838f2 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dttoasc</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=f652878a376f3f4f8de1e08eb08badd3 sig_cn_org=3c2ca8779c31e08ce50730ab86eab999 source=15.7 
       <para>
        Convert a timestamp variable to a C char* string.
<synopsis>
int dttoasc(timestamp *ts, char *output);
</synopsis>
        The function receives a pointer to the timestamp variable to convert
        (<literal>ts</literal>) and the string that should hold the result of the
        operation (<literal>output</literal>). It converts <literal>ts</literal> to its
        textual representation according to the SQL standard, which is
        be <literal>YYYY-MM-DD HH:MM:SS</literal>.
       </para>
________________________________________________________-->
       <para>
        将时间戳变量转换为C char*字符串。
<synopsis>
int dttoasc(timestamp *ts, char *output);
</synopsis>
        该函数接收一个指向要转换的时间戳变量的指针
        (<literal>ts</literal>)和应该保存操作结果的字符串
        (<literal>output</literal>)。它根据SQL标准将<literal>ts</literal>转换为其
        文本表示，格式为<literal>YYYY-MM-DD HH:MM:SS</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=f652878a376f3f4f8de1e08eb08badd3 -->
<!-- pgdoc-cn_start sig_en=e878766ff1009e018fed122a3ee838f2 sig_cn_org=d33969792e2e69de9d63bd993bf4f234 source=15.7 
       <para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
________________________________________________________-->
       <para>
        当成功时，该函数返回0，如果发生错误则返回负值。
       </para>
<!-- pgdoc-cn_end sig_en=e878766ff1009e018fed122a3ee838f2 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>dttofmtasc</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=acc2a5d749e7a47a1f10be6c65915cec sig_cn_org=ae6855cba5b09d7785a80f68631907fa source=15.7 
       <para>
        Convert a timestamp variable to a C char* using a format mask.
<synopsis>
int dttofmtasc(timestamp *ts, char *output, int str_len, char *fmtstr);
</synopsis>
        The function receives a pointer to the timestamp to convert as its
        first argument (<literal>ts</literal>), a pointer to the output buffer
        (<literal>output</literal>), the maximal length that has been allocated for
        the output buffer (<literal>str_len</literal>) and the format mask to
        use for the conversion (<literal>fmtstr</literal>).
       </para>
________________________________________________________-->
       <para>
        将时间戳变量转换为C char*，使用格式掩码。
<synopsis>
int dttofmtasc(timestamp *ts, char *output, int str_len, char *fmtstr);
</synopsis>
        该函数接收一个指向要转换的时间戳的指针作为第一个参数（<literal>ts</literal>），
        一个指向输出缓冲区的指针（<literal>output</literal>），
        为输出缓冲区分配的最大长度（<literal>str_len</literal>），
        以及用于转换的格式掩码（<literal>fmtstr</literal>）。
       </para>
<!-- pgdoc-cn_end sig_en=acc2a5d749e7a47a1f10be6c65915cec -->
<!-- pgdoc-cn_start sig_en=e878766ff1009e018fed122a3ee838f2 sig_cn_org=d33969792e2e69de9d63bd993bf4f234 source=15.7 
       <para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
________________________________________________________-->
       <para>
        当成功时，该函数返回0，如果发生错误则返回负值。
       </para>
<!-- pgdoc-cn_end sig_en=e878766ff1009e018fed122a3ee838f2 -->
<!-- pgdoc-cn_start sig_en=af23fceecaa0567d78ef5a7917b32ec3 sig_cn_org=d1d4cd48733869400720eceb604b6f6e source=15.7 
       <para>
        Internally, this function uses the <xref
        linkend="pgtypestimestampfmtasc"/> function. See the reference there for
        information on what format mask specifiers can be used.
       </para>
________________________________________________________-->
       <para>
        在内部，此函数使用<xref linkend="pgtypestimestampfmtasc"/>函数。请参阅那里的参考资料，了解可以使用哪些格式掩码说明符。
       </para>
<!-- pgdoc-cn_end sig_en=af23fceecaa0567d78ef5a7917b32ec3 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>intoasc</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=17ef1f437b2fdb9b4ce6ae42108b8eaf sig_cn_org=7fb82dcf6666d1ba3722c4582cd51d9b source=15.7 
       <para>
        Convert an interval variable to a C char* string.
<synopsis>
int intoasc(interval *i, char *str);
</synopsis>
        The function receives a pointer to the interval variable to convert
        (<literal>i</literal>) and the string that should hold the result of the
        operation (<literal>str</literal>). It converts <literal>i</literal> to its
        textual representation according to the SQL standard, which is
        be <literal>YYYY-MM-DD HH:MM:SS</literal>.
       </para>
________________________________________________________-->
       <para>
        将一个区间变量转换为C char*字符串。
<synopsis>
int intoasc(interval *i, char *str);
</synopsis>
        该函数接收一个指向要转换的区间变量的指针
        (<literal>i</literal>)和应该保存操作结果的字符串
        (<literal>str</literal>)。它根据SQL标准将<literal>i</literal>转换为其文本表示，
        即<literal>YYYY-MM-DD HH:MM:SS</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=17ef1f437b2fdb9b4ce6ae42108b8eaf -->
<!-- pgdoc-cn_start sig_en=e878766ff1009e018fed122a3ee838f2 sig_cn_org=d33969792e2e69de9d63bd993bf4f234 source=15.7 
       <para>
        Upon success, the function returns 0 and a negative value if an
        error occurred.
       </para>
________________________________________________________-->
       <para>
        当成功时，该函数返回0，如果发生错误则返回负值。
       </para>
<!-- pgdoc-cn_end sig_en=e878766ff1009e018fed122a3ee838f2 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rfmtlong</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=711c8811949655246adf50bb888831d5 sig_cn_org=03760dbbb14c9c3de5f9bccfc0d7fd44 source=15.7 
       <para>
        Convert a long integer value to its textual representation using a
        format mask.
<synopsis>
int rfmtlong(long lng_val, char *fmt, char *outbuf);
</synopsis>
        The function receives the long value <literal>lng_val</literal>, the format
        mask <literal>fmt</literal> and a pointer to the output buffer
        <literal>outbuf</literal>. It converts the long value according to the format
        mask to its textual representation.
       </para>
________________________________________________________-->
       <para>
        将长整型值使用格式掩码转换为其文本表示形式。
<synopsis>
int rfmtlong(long lng_val, char *fmt, char *outbuf);
</synopsis>
        该函数接收长整型值<literal>lng_val</literal>，格式掩码<literal>fmt</literal>和指向输出缓冲区<literal>outbuf</literal>的指针。
        它根据格式掩码将长整型值转换为其文本表示形式。
</para>
<!-- pgdoc-cn_end sig_en=711c8811949655246adf50bb888831d5 -->
<!-- pgdoc-cn_start sig_en=46436be657bde9fce66280bf7121fadd sig_cn_org=ae76cb18cc2df0bedfb1d71250943ea2 source=15.7 
       <para>
        The format mask can be composed of the following format specifying
        characters:
        <itemizedlist>
         <listitem>
          <para>
           <literal>*</literal> (asterisk) - if this position would be blank
           otherwise, fill it with an asterisk.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>&amp;</literal> (ampersand) - if this position would be
           blank otherwise, fill it with a zero.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>#</literal> - turn leading zeroes into blanks.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>&lt;</literal> - left-justify the number in the string.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>,</literal> (comma) - group numbers of four or more digits
           into groups of three digits separated by a comma.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>.</literal> (period) - this character separates the
           whole-number part of the number from the fractional part.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>-</literal> (minus) - the minus sign appears if the number
           is a negative value.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>+</literal> (plus) - the plus sign appears if the number is
           a positive value.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>(</literal> - this replaces the minus sign in front of the
           negative number. The minus sign will not appear.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>)</literal> - this character replaces the minus and is
           printed behind the negative value.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>$</literal> - the currency symbol.
          </para>
         </listitem>
        </itemizedlist>
       </para>
________________________________________________________-->
       <para>
        格式掩码可以由以下格式指定字符组成：
        <itemizedlist>
         <listitem>
          <para>
           <literal>*</literal>（星号）- 如果此位置为空白，用星号填充。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>&amp;</literal>（和号）- 如果此位置为空白，用零填充。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>#</literal> - 将前导零转换为空格。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>&lt;</literal> - 将数字左对齐在字符串中。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>,</literal>（逗号）- 将四位或更多位数的数字分组为以逗号分隔的三位数组。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>.</literal>（句点）- 此字符将整数部分与小数部分分隔开。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>-</literal>（减号）- 如果数字是负值，则显示减号。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>+</literal>（加号）- 如果数字是正值，则显示加号。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>(</literal> - 这个字符替换负数前面的减号。减号不会显示。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>)</literal> - 这个字符替换减号，并打印在负值后面。
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>$</literal> - 货币符号。
          </para>
         </listitem>
        </itemizedlist>
       </para>
<!-- pgdoc-cn_end sig_en=46436be657bde9fce66280bf7121fadd -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rupshift</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=2e7061d8df5aee47bc31bfb54762f985 sig_cn_org=c3eb229fa7edd8de278aeff8022efa87 source=15.7 
       <para>
        Convert a string to upper case.
<synopsis>
void rupshift(char *str);
</synopsis>
        The function receives a pointer to the string and transforms every
        lower case character to upper case.
       </para>
________________________________________________________-->
       <para>
        将字符串转换为大写。
<synopsis>
void rupshift(char *str);
</synopsis>
        该函数接收一个指向字符串的指针，并将每个小写字符转换为大写。
       </para>
<!-- pgdoc-cn_end sig_en=2e7061d8df5aee47bc31bfb54762f985 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>byleng</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=90a6e8bc72d4fdbe3aa068eb3dd1bb38 sig_cn_org=082e061390b948d70c515fd056e7b2ab source=15.7 
       <para>
        Return the number of characters in a string without counting trailing
        blanks.
<synopsis>
int byleng(char *str, int len);
</synopsis>
        The function expects a fixed-length string as its first argument
        (<literal>str</literal>) and its length as its second argument
        (<literal>len</literal>). It returns the number of significant characters,
        that is the length of the string without trailing blanks.
       </para>
________________________________________________________-->
       <para>
        返回字符串中字符的数量，不包括末尾的空格。
<synopsis>
int byleng(char *str, int len);
</synopsis>
        该函数期望一个固定长度的字符串作为第一个参数
        (<literal>str</literal>)，并将其长度作为第二个参数
        (<literal>len</literal>)。它返回有效字符的数量，即不包括末尾空格的字符串长度。
       </para>
<!-- pgdoc-cn_end sig_en=90a6e8bc72d4fdbe3aa068eb3dd1bb38 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>ldchar</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=d6da8ce8c33aa679087e94eb6a81cd82 sig_cn_org=31b4fd91f8c0c136b417b4f888a80b17 source=15.7 
       <para>
        Copy a fixed-length string into a null-terminated string.
<synopsis>
void ldchar(char *src, int len, char *dest);
</synopsis>
        The function receives the fixed-length string to copy
        (<literal>src</literal>), its length (<literal>len</literal>) and a pointer to the
        destination memory (<literal>dest</literal>). Note that you need to reserve at
        least <literal>len+1</literal> bytes for the string that <literal>dest</literal>
        points to. The function copies at most <literal>len</literal> bytes to the new
        location (less if the source string has trailing blanks) and adds the
        null-terminator.
       </para>
________________________________________________________-->
       <para>
        将固定长度的字符串复制到以空字符结尾的字符串中。
<synopsis>
void ldchar(char *src, int len, char *dest);
</synopsis>
        该函数接收要复制的固定长度字符串（<literal>src</literal>）、其长度（<literal>len</literal>）和指向目标内存的指针（<literal>dest</literal>）。
        请注意，您需要为<literal>dest</literal>指向的字符串保留至少<literal>len+1</literal>字节。
        该函数最多复制<literal>len</literal>字节到新位置（如果源字符串具有尾随空格，则会少一些），并添加空字符终止符。
       </para>
<!-- pgdoc-cn_end sig_en=d6da8ce8c33aa679087e94eb6a81cd82 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rgetmsg</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=2b9dc2f4342350c6e380ec71055d70e6 sig_cn_org=b217a75ff68a2bb507e98e18a882b61b source=15.7 
       <para>
<synopsis>
int rgetmsg(int msgnum, char *s, int maxsize);
</synopsis>
        This function exists but is not implemented at the moment!
       </para>
________________________________________________________-->
       <para>
<synopsis>
int rgetmsg(int msgnum, char *s, int maxsize);
</synopsis>
        这个函数存在，但目前尚未实现！
       </para>
<!-- pgdoc-cn_end sig_en=2b9dc2f4342350c6e380ec71055d70e6 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypalign</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=922db03921ff654e3bdc553b697023d1 sig_cn_org=f19673d0c30435f3a27845fdb937328e source=15.7 
       <para>
<synopsis>
int rtypalign(int offset, int type);
</synopsis>
        This function exists but is not implemented at the moment!
       </para>
________________________________________________________-->
       <para>
<synopsis>
int rtypalign(int offset, int type);
</synopsis>
        这个函数存在，但目前尚未实现！
       </para>
<!-- pgdoc-cn_end sig_en=922db03921ff654e3bdc553b697023d1 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypmsize</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=aea7d931447699d5d92d025d95d7963e sig_cn_org=cb7d79606f157e5e4a2eff1844630cf6 source=15.7 
       <para>
<synopsis>
int rtypmsize(int type, int len);
</synopsis>
        This function exists but is not implemented at the moment!
       </para>
________________________________________________________-->
       <para>
<synopsis>
int rtypmsize(int type, int len);
</synopsis>
        这个函数存在，但目前尚未实现！
       </para>
<!-- pgdoc-cn_end sig_en=aea7d931447699d5d92d025d95d7963e -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>rtypwidth</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=7f86624ba483c5d351a712b528bf09a7 sig_cn_org=3be0703ea23bc57c4f85f0552f9760fc source=15.7 
       <para>
<synopsis>
int rtypwidth(int sqltype, int sqllen);
</synopsis>
        This function exists but is not implemented at the moment!
       </para>
________________________________________________________-->
       <para>
<synopsis>
int rtypwidth(int sqltype, int sqllen);
</synopsis>
        这个函数存在，但目前尚未实现！
       </para>
<!-- pgdoc-cn_end sig_en=7f86624ba483c5d351a712b528bf09a7 -->
      </listitem>
     </varlistentry>

     <varlistentry id="rsetnull">
      <term><function>rsetnull</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=5965406b0d59dd020ccc533bef54e236 sig_cn_org=70dad9a543dc7581b50632dadb79347e source=15.7 
       <para>
        Set a variable to NULL.
<synopsis>
int rsetnull(int t, char *ptr);
</synopsis>
        The function receives an integer that indicates the type of the
        variable and a pointer to the variable itself that is cast to a C
        char* pointer.
       </para>
________________________________________________________-->
       <para>
        将一个变量设置为NULL。
<synopsis>
int rsetnull(int t, char *ptr);
</synopsis>
        该函数接收一个整数，表示变量的类型，以及一个指向变量本身的指针，该指针被转换为C中的char*指针。
       </para>
<!-- pgdoc-cn_end sig_en=5965406b0d59dd020ccc533bef54e236 -->
<!-- pgdoc-cn_start sig_en=610bffd001b08accadee3f79c610ddb6 sig_cn_org=725aeebc3eca9abe78fe3b6f2886b498 source=15.7 
       <para>
        The following types exist:
        <itemizedlist>
         <listitem>
          <para>
           <literal>CCHARTYPE</literal> - For a variable of type <type>char</type> or <type>char*</type>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CSHORTTYPE</literal> - For a variable of type <type>short int</type>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CINTTYPE</literal> - For a variable of type <type>int</type>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CBOOLTYPE</literal> - For a variable of type <type>boolean</type>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CFLOATTYPE</literal> - For a variable of type <type>float</type>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CLONGTYPE</literal> - For a variable of type <type>long</type>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CDOUBLETYPE</literal> - For a variable of type <type>double</type>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CDECIMALTYPE</literal> - For a variable of type <type>decimal</type>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CDATETYPE</literal> - For a variable of type <type>date</type>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CDTIMETYPE</literal> - For a variable of type <type>timestamp</type>
          </para>
         </listitem>
        </itemizedlist>
       </para>
________________________________________________________-->
       <para>
        下列类型存在：
        <itemizedlist>
         <listitem>
          <para>
           <literal>CCHARTYPE</literal> - 用于<type>char</type>或<type>char*</type>类型的变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CSHORTTYPE</literal> - 用于<type>short int</type>类型的变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CINTTYPE</literal> - 用于<type>int</type>类型的变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CBOOLTYPE</literal> - 用于<type>boolean</type>类型的变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CFLOATTYPE</literal> - 用于<type>float</type>类型的变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CLONGTYPE</literal> - 用于<type>long</type>类型的变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CDOUBLETYPE</literal> - 用于<type>double</type>类型的变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CDECIMALTYPE</literal> - 用于<type>decimal</type>类型的变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CDATETYPE</literal> - 用于<type>date</type>类型的变量
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>CDTIMETYPE</literal> - 用于<type>timestamp</type>类型的变量
          </para>
         </listitem>
        </itemizedlist>
       </para>
<!-- pgdoc-cn_end sig_en=610bffd001b08accadee3f79c610ddb6 -->

<!-- pgdoc-cn_start sig_en=4d637b3761a19ebc2784e6ec6575c7a0 sig_cn_org=712be60f8bf531a34949e003841832ef source=15.7 
       <para>
        Here is an example of a call to this function:
<programlisting><![CDATA[
$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

rsetnull(CCHARTYPE, (char *) c);
rsetnull(CSHORTTYPE, (char *) &s);
rsetnull(CINTTYPE, (char *) &i);
]]>
</programlisting>
       </para>
________________________________________________________-->
       <para>
        这是调用此函数的示例：
<programlisting><![CDATA[
$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

rsetnull(CCHARTYPE, (char *) c);
rsetnull(CSHORTTYPE, (char *) &s);
rsetnull(CINTTYPE, (char *) &i);
]]>
</programlisting>
       </para>
<!-- pgdoc-cn_end sig_en=4d637b3761a19ebc2784e6ec6575c7a0 -->
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>risnull</function></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=3589d93231f9f03850535845c7b955a4 sig_cn_org=a98e9a2091cbe100ac21aac0dede097b source=15.7 
       <para>
        Test if a variable is NULL.
<synopsis>
int risnull(int t, char *ptr);
</synopsis>
        The function receives the type of the variable to test (<literal>t</literal>)
        as well a pointer to this variable (<literal>ptr</literal>). Note that the
        latter needs to be cast to a char*. See the function <xref
        linkend="rsetnull"/> for a list of possible variable types.
       </para>
________________________________________________________-->
       <para>
        测试变量是否为NULL。
<synopsis>
int risnull(int t, char *ptr);
</synopsis>
        该函数接收要测试的变量类型（<literal>t</literal>）以及指向该变量的指针（<literal>ptr</literal>）。
        请注意，后者需要转换为char*类型。查看函数<xref linkend="rsetnull"/>以获取可能的变量类型列表。
</para>
<!-- pgdoc-cn_end sig_en=3589d93231f9f03850535845c7b955a4 -->
<!-- pgdoc-cn_start sig_en=9bd2b67ed545dfdf6ee893453b7e184c sig_cn_org=e6a914aec168120836f92b3fd7131284 source=15.7 
       <para>
        Here is an example of how to use this function:
<programlisting><![CDATA[
$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

risnull(CCHARTYPE, (char *) c);
risnull(CSHORTTYPE, (char *) &s);
risnull(CINTTYPE, (char *) &i);
]]>
</programlisting>
       </para>
________________________________________________________-->
       <para>
        这是如何使用这个函数的示例：
<programlisting><![CDATA[
$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

risnull(CCHARTYPE, (char *) c);
risnull(CSHORTTYPE, (char *) &s);
risnull(CINTTYPE, (char *) &i);
]]>
</programlisting>
       </para>
<!-- pgdoc-cn_end sig_en=9bd2b67ed545dfdf6ee893453b7e184c -->
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
  </sect2>

  <sect2 id="ecpg-informix-constants">
<!-- pgdoc-cn_start sig_en=0c2149fa6b2756e7c99a27ad51cc1ac8 sig_cn_org=None source=14.1 
   <title>Additional Constants</title>
________________________________________________________-->
   <title>额外的常量</title>
<!-- pgdoc-cn_end sig_en=0c2149fa6b2756e7c99a27ad51cc1ac8 -->
<!-- pgdoc-cn_start sig_en=e5b1d183ff5f4b6785ff9690f0a2846c sig_cn_org=None source=14.1 
   <para>
    Note that all constants here describe errors and all of them are defined
    to represent negative values. In the descriptions of the different
    constants you can also find the value that the constants represent in the
    current implementation. However you should not rely on this number. You can
    however rely on the fact all of them are defined to represent negative
    values.
    <variablelist>
     <varlistentry>
      <term><literal>ECPG_INFORMIX_NUM_OVERFLOW</literal></term>
      <listitem>
       <para>
        Functions return this value if an overflow occurred in a
        calculation. Internally it is defined as -1200 (the <productname>Informix</productname>
        definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal></term>
      <listitem>
       <para>
        Functions return this value if an underflow occurred in a calculation.
        Internally it is defined as -1201 (the <productname>Informix</productname> definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_DIVIDE_ZERO</literal></term>
      <listitem>
       <para>
        Functions return this value if an attempt to divide by zero is
        observed. Internally it is defined as -1202 (the <productname>Informix</productname> definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_YEAR</literal></term>
      <listitem>
       <para>
        Functions return this value if a bad value for a year was found while
        parsing a date. Internally it is defined as -1204 (the <productname>Informix</productname>
        definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_MONTH</literal></term>
      <listitem>
       <para>
        Functions return this value if a bad value for a month was found while
        parsing a date. Internally it is defined as -1205 (the <productname>Informix</productname>
        definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_DAY</literal></term>
      <listitem>
       <para>
        Functions return this value if a bad value for a day was found while
        parsing a date. Internally it is defined as -1206 (the <productname>Informix</productname>
        definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_ENOSHORTDATE</literal></term>
      <listitem>
       <para>
        Functions return this value if a parsing routine needs a short date
        representation but did not get the date string in the right length.
        Internally it is defined as -1209 (the <productname>Informix</productname> definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_DATE_CONVERT</literal></term>
      <listitem>
       <para>
        Functions return this value if an error occurred during date
        formatting.  Internally it is defined as -1210 (the
        <productname>Informix</productname> definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_OUT_OF_MEMORY</literal></term>
      <listitem>
       <para>
        Functions return this value if memory was exhausted during
        their operation.  Internally it is defined as -1211 (the
        <productname>Informix</productname> definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_ENOTDMY</literal></term>
      <listitem>
       <para>
        Functions return this value if a parsing routine was supposed to get a
        format mask (like <literal>mmddyy</literal>) but not all fields were listed
        correctly. Internally it is defined as -1212 (the <productname>Informix</productname> definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_NUMERIC</literal></term>
      <listitem>
       <para>
        Functions return this value either if a parsing routine cannot parse
        the textual representation for a numeric value because it contains
        errors or if a routine cannot complete a calculation involving numeric
        variables because at least one of the numeric variables is invalid.
        Internally it is defined as -1213 (the <productname>Informix</productname> definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_EXPONENT</literal></term>
      <listitem>
       <para>
        Functions return this value if a parsing routine cannot parse
        an exponent.  Internally it is defined as -1216 (the
        <productname>Informix</productname> definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_DATE</literal></term>
      <listitem>
       <para>
        Functions return this value if a parsing routine cannot parse
        a date.  Internally it is defined as -1218 (the
        <productname>Informix</productname> definition).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_EXTRA_CHARS</literal></term>
      <listitem>
       <para>
        Functions return this value if a parsing routine is passed extra
        characters it cannot parse.  Internally it is defined as -1264 (the
        <productname>Informix</productname> definition).
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    注意这里所有的常量都描述错误并且它们都被定义为表示负值。在每一种不同常量的描述中，你还可以找到在当前实现中该常量表示的值。不过你不应该依赖于这个数字。但是你可以相信所有的这些常量都是被定义为表示负值。
    <variablelist>
     <varlistentry>
      <term><literal>ECPG_INFORMIX_NUM_OVERFLOW</literal></term>
      <listitem>
       <para>
        如果在一次计算中发生了溢出，函数会返回这个值。在内部它被定义为 -1200（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_NUM_UNDERFLOW</literal></term>
      <listitem>
       <para>
        如果在一次计算中发生了下溢，函数会返回这个值。在内部它被定义为 -1201（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_DIVIDE_ZERO</literal></term>
      <listitem>
       <para>
        如果发现尝试除零，函数会返回这个值。在内部它被定义为 -1202（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_YEAR</literal></term>
      <listitem>
       <para>
        如果在解析一个日期时为年找到了一个坏的值，函数会返回这个值。在内部它被定义为 -1204（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_MONTH</literal></term>
      <listitem>
       <para>
        如果在解析一个日期时为月找到了一个坏的值，函数会返回这个值。在内部它被定义为 -1205（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_DAY</literal></term>
      <listitem>
       <para>
        如果在解析一个日期时为日找到了一个坏的值，函数会返回这个值。在内部它被定义为 -1206（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_ENOSHORTDATE</literal></term>
      <listitem>
       <para>
        如果一个解析例程需要一个短日期表示但是却没有得到正确长度的日期自如穿，函数会返回这个值。在内部它被定义为 -1209（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_DATE_CONVERT</literal></term>
      <listitem>
       <para>
        如果在日期格式化时产生了一个错误，函数会返回这个值。在内部它被定义为 -1210（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_OUT_OF_MEMORY</literal></term>
      <listitem>
       <para>
        如果在操作时内存被耗尽，函数会返回这个值。在内部它被定义为 -1211（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_ENOTDMY</literal></term>
      <listitem>
       <para>
        如果一个解析例程被假定为得到一个格式掩码（如<literal>mmddyy</literal>）但是列出的域并不是全部正确，函数会返回这个值。在内部它被定义为 -1212（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_NUMERIC</literal></term>
      <listitem>
       <para>
        如果一个解析例程因为一个numeric值的文本表达包含错误而不能解析它或者一个例程因为至少一个numeric变量非法而无法完成一次涉及numeric变量的计算，函数会返回这个值。在内部它被定义为 -1213（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_EXPONENT</literal></term>
      <listitem>
       <para>
        如果一个解析例程不能解析一个指数，函数会返回这个值。在内部它被定义为 -1216（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_BAD_DATE</literal></term>
      <listitem>
       <para>
        如果一个解析例程不能解析一个日期，函数会返回这个值。在内部它被定义为 -1218（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ECPG_INFORMIX_EXTRA_CHARS</literal></term>
      <listitem>
       <para>
        如果一个解析例程被传递了它不能解析的额外字符，函数会返回这个值。在内部它被定义为 -1264（<productname>Informix</productname>定义）。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=e5b1d183ff5f4b6785ff9690f0a2846c -->
  </sect2>
 </sect1>

 <sect1 id="ecpg-oracle-compat">
<!-- pgdoc-cn_start sig_en=59800370b517bf118df82e020f477b78 sig_cn_org=d60c0ee42d0eee69e526173781acd0c9 source=15.7 
  <title><productname>Oracle</productname> Compatibility Mode</title>
________________________________________________________-->
  <title><productname>Oracle</productname> 兼容模式</title>
<!-- pgdoc-cn_end sig_en=59800370b517bf118df82e020f477b78 -->
<!-- pgdoc-cn_start sig_en=945c817e6a4204e8f8e294468cc008b4 sig_cn_org=938639a72245e6288bc7447626e8c792 source=15.7 
  <para>
   <command>ecpg</command> can be run in a so-called <firstterm>Oracle
   compatibility mode</firstterm>. If this mode is active, it tries to
   behave as if it were Oracle <productname>Pro*C</productname>.
  </para>
________________________________________________________-->
  <para>
   <command>ecpg</command>可以在所谓的<firstterm>Oracle兼容模式</firstterm>下运行。如果此模式激活，
   它会尝试表现得好像它是Oracle的<productname>Pro*C</productname>。
</para>
<!-- pgdoc-cn_end sig_en=945c817e6a4204e8f8e294468cc008b4 -->

<!-- pgdoc-cn_start sig_en=ba8ef2db53906c76489245c59f592546 sig_cn_org=2d9f44d6b5225c6d2af05c2f3b9594f5 source=15.7 
  <para>
   Specifically, this mode changes <command>ecpg</command> in three ways:

   <itemizedlist>
    <listitem>
     <para>
      Pad character arrays receiving character string types with
      trailing spaces to the specified length
     </para>
    </listitem>

    <listitem>
     <para>
      Zero byte terminate these character arrays, and set the indicator
      variable if truncation occurs
     </para>
    </listitem>

    <listitem>
     <para>
      Set the null indicator to <literal>-1</literal> when character
      arrays receive empty character string types
     </para>
    </listitem>
   </itemizedlist>
  </para>
________________________________________________________-->
  <para>
   具体来说，此模式以三种方式更改<command>ecpg</command>：

   <itemizedlist>
    <listitem>
     <para>
      用尾随空格填充接收字符字符串类型的字符数组，直到指定长度
     </para>
    </listitem>

    <listitem>
     <para>
      以零字节终止这些字符数组，并在截断发生时设置指示变量
     </para>
    </listitem>

    <listitem>
     <para>
      当字符数组接收空字符字符串类型时，将空指示器设置为<literal>-1</literal>
     </para>
    </listitem>
   </itemizedlist>
  </para>
<!-- pgdoc-cn_end sig_en=ba8ef2db53906c76489245c59f592546 -->
 </sect1>

 <sect1 id="ecpg-develop">
<!-- pgdoc-cn_start sig_en=da79f7620377da4850782b0e3cf65ef0 sig_cn_org=None source=14.1 
  <title>Internals</title>
________________________________________________________-->
  <title>内部</title>
<!-- pgdoc-cn_end sig_en=da79f7620377da4850782b0e3cf65ef0 -->

<!-- pgdoc-cn_start sig_en=ca67f76a1630466c58662112b892e0c4 sig_cn_org=None source=14.1 
  <para>
   This section explains how <application>ECPG</application> works
   internally. This information can occasionally be useful to help
   users understand how to use <application>ECPG</application>.
  </para>
________________________________________________________-->
  <para>
   这一节解释<application>ECPG</application>在内部如何工作。这些信息有时有助于用户理解如何使用<application>ECPG</application>。
  </para>
<!-- pgdoc-cn_end sig_en=ca67f76a1630466c58662112b892e0c4 -->

<!-- pgdoc-cn_start sig_en=34b305c0599cd3071980a33f80c3392f sig_cn_org=None source=14.1 
   <para>
    The first four lines written by <command>ecpg</command> to the
    output are fixed lines.  Two are comments and two are include
    lines necessary to interface to the library.  Then the
    preprocessor reads through the file and writes output.  Normally
    it just echoes everything to the output.
   </para>
________________________________________________________-->
   <para>
    <command>ecpg</command>写到输出的头四行是固定行。两行是注释，两行是与库接口必须的包括行。然后预处理器会从文件读取并且写输出。通常它会把所有东西回显在输出上。
   </para>
<!-- pgdoc-cn_end sig_en=34b305c0599cd3071980a33f80c3392f -->

<!-- pgdoc-cn_start sig_en=36723fe33dc4e9a306c4c20a165c574a sig_cn_org=None source=14.1 
   <para>
    When it sees an <command>EXEC SQL</command> statement, it
    intervenes and changes it. The command starts with <command>EXEC
    SQL</command> and ends with <command>;</command>. Everything in
    between is treated as an <acronym>SQL</acronym> statement and
    parsed for variable substitution.
   </para>
________________________________________________________-->
   <para>
    当它看见一个<command>EXEC SQL</command>语句时，它会干预并且改变它。命令开始于<command>EXEC SQL</command> 并且结束于<command>;</command>。之间的任何东西都被视作一个<acronym>SQL</acronym>语句，并且会被解析进行变量替换。
   </para>
<!-- pgdoc-cn_end sig_en=36723fe33dc4e9a306c4c20a165c574a -->

<!-- pgdoc-cn_start sig_en=d9d10392a5d619e49d4a24c15c100a97 sig_cn_org=None source=14.1 
   <para>
    Variable substitution occurs when a symbol starts with a colon
    (<literal>:</literal>). The variable with that name is looked up
    among the variables that were previously declared within a
    <literal>EXEC SQL DECLARE</literal> section.
   </para>
________________________________________________________-->
   <para>
    当一个符号开始于一个冒号（<literal>:</literal>）时，变量替换会发生。有该名称的变量会被在之前声明于<literal>EXEC SQL DECLARE</literal>小节中的变量中搜索。
   </para>
<!-- pgdoc-cn_end sig_en=d9d10392a5d619e49d4a24c15c100a97 -->

<!-- pgdoc-cn_start sig_en=80f1f1e05b8f21ddb08c7e76a149b35a sig_cn_org=None source=14.1 
   <para>
    The most important function in the library is
    <function>ECPGdo</function>, which takes care of executing most
    commands. It takes a variable number of arguments. This can easily
    add up to 50 or so arguments, and we hope this will not be a
    problem on any platform.
   </para>
________________________________________________________-->
   <para>
    该库中最重要的函数是<function>ECPGdo</function>，它负责执行大部分命令。它采用可变数量的参数。可以很容易地增加到最多 50 个左右的参数，并且我们希望在任何平台上这都不会成为问题。
   </para>
<!-- pgdoc-cn_end sig_en=80f1f1e05b8f21ddb08c7e76a149b35a -->

<!-- pgdoc-cn_start sig_en=5ab3883349696b6192d40070a79d28da sig_cn_org=None source=14.1 
   <para>
    The arguments are:

    <variablelist>
     <varlistentry>
      <term>A line number</term>
      <listitem>
       <para>
        This is the line number of the original line; used in error
        messages only.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>A string</term>
      <listitem>
       <para>
        This is the <acronym>SQL</acronym> command that is to be issued.
        It is modified by the input variables, i.e., the variables that
        where not known at compile time but are to be entered in the
        command. Where the variables should go the string contains
        <literal>?</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Input variables</term>
      <listitem>
       <para>
        Every input variable causes ten arguments to be created.  (See below.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><parameter>ECPGt_EOIT</parameter></term>
      <listitem>
       <para>
        An <type>enum</type> telling that there are no more input
        variables.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>Output variables</term>
      <listitem>
       <para>
        Every output variable causes ten arguments to be created.
        (See below.)  These variables are filled by the function.
       </para>
      </listitem>
     </varlistentry>

      <varlistentry>
       <term><parameter>ECPGt_EORT</parameter></term>
       <listitem>
       <para>
        An <type>enum</type> telling that there are no more variables.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    参数是：

    <variablelist>
     <varlistentry>
      <term>一个行号</term>
      <listitem>
       <para>
        这是原始行的行号，只用于错误消息。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>一个字符串</term>
      <listitem>
       <para>
        这是要被发出的<acronym>SQL</acronym>命令。它会被输入变量修改，即在编译时不知道但是要在命令中被输入的变量。其中变量应该去到包含<literal>?</literal>的字符串中。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>输入变量</term>
      <listitem>
       <para>
        每一个输入参数导致十个参数被创建（见下文）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><parameter>ECPGt_EOIT</parameter></term>
      <listitem>
       <para>
        一个说明没有更多输入变量的<type>enum</type>。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>输出变量</term>
      <listitem>
       <para>
        每一个输出变量导致十个参数被创建（见下文）。这些变量由该函数填充。
       </para>
      </listitem>
     </varlistentry>

      <varlistentry>
       <term><parameter>ECPGt_EORT</parameter></term>
       <listitem>
       <para>
        一个说明没有更多变量的<type>enum</type>。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=5ab3883349696b6192d40070a79d28da -->

<!-- pgdoc-cn_start sig_en=75a7939b27490f15a0cdfff1c6f395ff sig_cn_org=None source=14.1 
   <para>
    For every variable that is part of the <acronym>SQL</acronym>
    command, the function gets ten arguments:

    <orderedlist>
     <listitem>
      <para>
       The type as a special symbol.
      </para>
     </listitem>

     <listitem>
      <para>
       A pointer to the value or a pointer to the pointer.
      </para>
     </listitem>

     <listitem>
      <para>
       The size of the variable if it is a <type>char</type> or <type>varchar</type>.
      </para>
     </listitem>

     <listitem>
      <para>
       The number of elements in the array (for array fetches).
      </para>
     </listitem>

     <listitem>
      <para>
       The offset to the next element in the array (for array fetches).
      </para>
     </listitem>

     <listitem>
      <para>
       The type of the indicator variable as a special symbol.
      </para>
     </listitem>

     <listitem>
      <para>
       A pointer to the indicator variable.
      </para>
     </listitem>

     <listitem>
      <para>
       0
      </para>
     </listitem>

     <listitem>
      <para>
       The number of elements in the indicator array (for array fetches).
      </para>
     </listitem>

     <listitem>
      <para>
       The offset to the next element in the indicator array (for
       array fetches).
      </para>
     </listitem>
    </orderedlist>
   </para>
________________________________________________________-->
   <para>
    对于每一个作为<acronym>SQL</acronym>命令一部分的变量，该函数得到十个参数：

    <orderedlist>
     <listitem>
      <para>
       作为一个特殊符号的类型。
      </para>
     </listitem>

     <listitem>
      <para>
       一个值的指针或者一个指针的指针。
      </para>
     </listitem>

     <listitem>
      <para>
       如果变量是一个<type>char</type>或者<type>varchar</type>，这是它的尺寸。
      </para>
     </listitem>

     <listitem>
      <para>
       数组中元素的数量（用于数组获取）。
      </para>
     </listitem>

     <listitem>
      <para>
       数组中下一个元素的偏移量（用于数组获取）。
      </para>
     </listitem>

     <listitem>
      <para>
       作为一个特别符号的指示符变量的类型。
      </para>
     </listitem>

     <listitem>
      <para>
       一个指示符变量的指针。
      </para>
     </listitem>

     <listitem>
      <para>
       0
      </para>
     </listitem>

     <listitem>
      <para>
       指示符数组中的元素数量（用于数组获取）。
      </para>
     </listitem>

     <listitem>
      <para>
       到指示符数组中下一个元素的偏移量（用于数组取得）。
      </para>
     </listitem>
    </orderedlist>
   </para>
<!-- pgdoc-cn_end sig_en=75a7939b27490f15a0cdfff1c6f395ff -->

<!-- pgdoc-cn_start sig_en=fcebefec36b18290c5e3bc0ebda21bc7 sig_cn_org=None source=14.1 
   <para>
    Note that not all SQL commands are treated in this way.  For
    instance, an open cursor statement like:
<programlisting>
EXEC SQL OPEN <replaceable>cursor</replaceable>;
</programlisting>
    is not copied to the output. Instead, the cursor's
    <command>DECLARE</command> command is used at the position of the <command>OPEN</command> command
    because it indeed opens the cursor.
   </para>
________________________________________________________-->
   <para>
    注意并非所有 SQL 命令都被以这种方式对待。例如，一个打开游标语句：
<programlisting>
EXEC SQL OPEN <replaceable>cursor</replaceable>;
</programlisting>
    不会被复制到输出。反而，游标的<command>DECLARE</command>命令被用在<command>OPEN</command>命令的位置上，因为它事实上会打开该游标。
   </para>
<!-- pgdoc-cn_end sig_en=fcebefec36b18290c5e3bc0ebda21bc7 -->

<!-- pgdoc-cn_start sig_en=b9df3a6b86181625b1a3f80155ce66b1 sig_cn_org=None source=14.1 
   <para>
    Here is a complete example describing the output of the
    preprocessor of a file <filename>foo.pgc</filename> (details might
    change with each particular version of the preprocessor):
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int index;
int result;
EXEC SQL END DECLARE SECTION;
...
EXEC SQL SELECT res INTO :result FROM mytable WHERE index = :index;
</programlisting>
    is translated into:
<programlisting><![CDATA[
/* Processed by ecpg (2.6.0) */
/* These two include files are added by the preprocessor */
#include <ecpgtype.h>;
#include <ecpglib.h>;

/* exec sql begin declare section */

#line 1 "foo.pgc"

 int index;
 int result;
/* exec sql end declare section */
...
ECPGdo(__LINE__, NULL, "SELECT res FROM mytable WHERE index = ?     ",
        ECPGt_int,&(index),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EOIT,
        ECPGt_int,&(result),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EORT);
#line 147 "foo.pgc"
]]>
</programlisting>
    (The indentation here is added for readability and not
    something the preprocessor does.)
   </para>
________________________________________________________-->
   <para>
    这里有一个完整的例子，它描述了一个文件<filename>foo.pgc</filename>的预处理器输出（对预处理器的每一个特定版本细节可能不同）：
<programlisting>
EXEC SQL BEGIN DECLARE SECTION;
int index;
int result;
EXEC SQL END DECLARE SECTION;
...
EXEC SQL SELECT res INTO :result FROM mytable WHERE index = :index;
</programlisting>
    会被翻译成：
<programlisting><![CDATA[
/* 由 ecpg (2.6.0) 处理 */
/* 这两个头文件由预处理器增加 */
#include <ecpgtype.h>;
#include <ecpglib.h>;

/* 声明节开始 */

#line 1 "foo.pgc"

 int index;
 int result;
/* 声明节结束 */
...
ECPGdo(__LINE__, NULL, "SELECT res FROM mytable WHERE index = ?     ",
        ECPGt_int,&(index),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EOIT,
        ECPGt_int,&(result),1L,1L,sizeof(int),
        ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EORT);
#line 147 "foo.pgc"
]]>
</programlisting>
    （这里的缩进是为了可读性而添加的，并非是预处理器做的处理）。
   </para>
<!-- pgdoc-cn_end sig_en=b9df3a6b86181625b1a3f80155ce66b1 -->
 </sect1>
</chapter>
