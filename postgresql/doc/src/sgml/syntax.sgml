<!-- doc/src/sgml/syntax.sgml -->

<chapter id="sql-syntax">
<!-- pgdoc-cn_start sig_en=bd04e5bafb71282efe390fbd0a41898e sig_cn_org=None source=14.1 
 <title>SQL Syntax</title>
________________________________________________________-->
 <title>SQL语法</title>
<!-- pgdoc-cn_end sig_en=bd04e5bafb71282efe390fbd0a41898e -->

<!-- pgdoc-cn_start sig_en=80ff47fd8710ada965ca1cde5b47c96b sig_cn_org=None source=14.1 
 <indexterm zone="sql-syntax">
  <primary>syntax</primary>
  <secondary>SQL</secondary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="sql-syntax">
  <primary>syntax</primary>
  <secondary>SQL</secondary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=80ff47fd8710ada965ca1cde5b47c96b -->

<!-- pgdoc-cn_start sig_en=eebda581824845048f4311ff0092e329 sig_cn_org=None source=14.1 
 <para>
  This chapter describes the syntax of SQL.  It forms the foundation
  for understanding the following chapters which will go into detail
  about how SQL commands are applied to define and modify data.
 </para>
________________________________________________________-->
 <para>
  这一章描述了SQL的语法。它构成了理解后续具体介绍如何使用SQL定义和修改数据的章节的基础 。
 </para>
<!-- pgdoc-cn_end sig_en=eebda581824845048f4311ff0092e329 -->

<!-- pgdoc-cn_start sig_en=7c4b21198723946ae74d8acaa1ec60a3 sig_cn_org=None source=14.1 
 <para>
  We also advise users who are already familiar with SQL to read this
  chapter carefully because it contains several rules and concepts that
  are implemented inconsistently among SQL databases or that are
  specific to <productname>PostgreSQL</productname>.
 </para>
________________________________________________________-->
 <para>
  我们同时建议已经熟悉SQL的用户仔细阅读本章，因为本章包含一些在SQL数据库中实现得不一致的以及<productname>PostgreSQL</productname>中特有的规则和概念。
 </para>
<!-- pgdoc-cn_end sig_en=7c4b21198723946ae74d8acaa1ec60a3 -->

 <sect1 id="sql-syntax-lexical">
<!-- pgdoc-cn_start sig_en=72cd119193d3f4952977c80fe662d09a sig_cn_org=None source=14.1 
  <title>Lexical Structure</title>
________________________________________________________-->
  <title>词法结构</title>
<!-- pgdoc-cn_end sig_en=72cd119193d3f4952977c80fe662d09a -->

<!-- pgdoc-cn_start sig_en=639f0d96d3859b5ccc61d90b056be56d sig_cn_org=None source=14.1 
  <indexterm>
   <primary>token</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>token</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=639f0d96d3859b5ccc61d90b056be56d -->

<!-- pgdoc-cn_start sig_en=21aa5fa3271dbc1d98b31eaa310b2e7c sig_cn_org=None source=14.1 
  <para>
   SQL input consists of a sequence of
   <firstterm>commands</firstterm>.  A command is composed of a
   sequence of <firstterm>tokens</firstterm>, terminated by a
   semicolon (<quote>;</quote>).  The end of the input stream also
   terminates a command.  Which tokens are valid depends on the syntax
   of the particular command.
  </para>
________________________________________________________-->
  <para>
   SQL输入由一个<firstterm>命令</firstterm>序列组成。一个命令由一个<firstterm>记号</firstterm>的序列构成，并由一个分号（<quote>;</quote>）终结。输入流的末端也会标志一个命令的结束。具体哪些记号是合法的与具体命令的语法有关。
  </para>
<!-- pgdoc-cn_end sig_en=21aa5fa3271dbc1d98b31eaa310b2e7c -->

<!-- pgdoc-cn_start sig_en=2ff5f4b5b3ec3bca0fe5fd02356b02ae sig_cn_org=None source=14.1 
  <para>
   A token can be a <firstterm>key word</firstterm>, an
   <firstterm>identifier</firstterm>, a <firstterm>quoted
   identifier</firstterm>, a <firstterm>literal</firstterm> (or
   constant), or a special character symbol.  Tokens are normally
   separated by whitespace (space, tab, newline), but need not be if
   there is no ambiguity (which is generally only the case if a
   special character is adjacent to some other token type).
  </para>
________________________________________________________-->
  <para>
   一个记号可以是一个<firstterm>关键词</firstterm>、一个<firstterm>标识符</firstterm>、一个<firstterm>带引号的标识符</firstterm>、一个<firstterm>literal</firstterm>（或常量）或者一个特殊字符符号。记号通常以空白（空格、制表符、新行）来分隔，但在无歧义时并不强制要求如此（唯一的例子是一个特殊字符紧挨着其他记号）。
  </para>
<!-- pgdoc-cn_end sig_en=2ff5f4b5b3ec3bca0fe5fd02356b02ae -->

<!-- pgdoc-cn_start sig_en=4982794bf4a4f7129e851029020c8dbb sig_cn_org=None source=14.1 
   <para>
    For example, the following is (syntactically) valid SQL input:
<programlisting>
SELECT * FROM MY_TABLE;
UPDATE MY_TABLE SET A = 5;
INSERT INTO MY_TABLE VALUES (3, 'hi there');
</programlisting>
    This is a sequence of three commands, one per line (although this
    is not required; more than one command can be on a line, and
    commands can usefully be split across lines).
   </para>
________________________________________________________-->
   <para>
    例如，下面是一个（语法上）合法的SQL输入：
<programlisting>
SELECT * FROM MY_TABLE;
UPDATE MY_TABLE SET A = 5;
INSERT INTO MY_TABLE VALUES (3, 'hi there');
</programlisting>
    这是一个由三个命令组成的序列，每一行一个命令（尽管这不是必须地，在同一行中可以有超过一个命令，而且命令还可以被跨行分割）。
   </para>
<!-- pgdoc-cn_end sig_en=4982794bf4a4f7129e851029020c8dbb -->

<!-- pgdoc-cn_start sig_en=28384389c15cccbd6a67023bff43cccd sig_cn_org=None source=14.1 
  <para>
   Additionally, <firstterm>comments</firstterm> can occur in SQL
   input.  They are not tokens, they are effectively equivalent to
   whitespace.
  </para>
________________________________________________________-->
  <para>
   另外，<firstterm>注释</firstterm>也可以出现在SQL输入中。它们不是记号，它们和空白完全一样。
  </para>
<!-- pgdoc-cn_end sig_en=28384389c15cccbd6a67023bff43cccd -->

<!-- pgdoc-cn_start sig_en=caa293808969d4b6597f5cf15117236c sig_cn_org=None source=14.1 
  <para>
   The SQL syntax is not very consistent regarding what tokens
   identify commands and which are operands or parameters.  The first
   few tokens are generally the command name, so in the above example
   we would usually speak of a <quote>SELECT</quote>, an
   <quote>UPDATE</quote>, and an <quote>INSERT</quote> command.  But
   for instance the <command>UPDATE</command> command always requires
   a <token>SET</token> token to appear in a certain position, and
   this particular variation of <command>INSERT</command> also
   requires a <token>VALUES</token> in order to be complete.  The
   precise syntax rules for each command are described in <xref linkend="reference"/>.
  </para>
________________________________________________________-->
  <para>
   根据标识命令、操作符、参数的记号不同，SQL的语法不很一致。最前面的一些记号通常是命令名，因此在上面的例子中我们通常会说一个<quote>SELECT</quote>、一个<quote>UPDATE</quote>和一个<quote>INSERT</quote>命令。但是例如<command>UPDATE</command>命令总是要求一个<token>SET</token>记号出现在一个特定位置，而<command>INSERT</command>则要求一个<token>VALUES</token>来完成命令。每个命令的精确语法规则在<xref linkend="reference"/>中介绍。
  </para>
<!-- pgdoc-cn_end sig_en=caa293808969d4b6597f5cf15117236c -->

  <sect2 id="sql-syntax-identifiers">
<!-- pgdoc-cn_start sig_en=e0594c4cee6437c5ff16456c0fcd0b9e sig_cn_org=None source=14.1 
   <title>Identifiers and Key Words</title>
________________________________________________________-->
   <title>标识符和关键词</title>
<!-- pgdoc-cn_end sig_en=e0594c4cee6437c5ff16456c0fcd0b9e -->

<!-- pgdoc-cn_start sig_en=459ed15e74b006c2d1d4b0eee8b37c60 sig_cn_org=None source=14.1 
   <indexterm zone="sql-syntax-identifiers">
    <primary>identifier</primary>
    <secondary>syntax of</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="sql-syntax-identifiers">
    <primary>identifier</primary>
    <secondary>syntax of</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=459ed15e74b006c2d1d4b0eee8b37c60 -->

<!-- pgdoc-cn_start sig_en=27df08871d8fa4bee57dfeb27ab9f06e sig_cn_org=None source=14.1 
   <indexterm zone="sql-syntax-identifiers">
    <primary>name</primary>
    <secondary>syntax of</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="sql-syntax-identifiers">
    <primary>name</primary>
    <secondary>syntax of</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=27df08871d8fa4bee57dfeb27ab9f06e -->

<!-- pgdoc-cn_start sig_en=b9c2085e2eff638ef4006956951c84fe sig_cn_org=None source=14.1 
   <indexterm zone="sql-syntax-identifiers">
    <primary>key word</primary>
    <secondary>syntax of</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="sql-syntax-identifiers">
    <primary>key word</primary>
    <secondary>syntax of</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=b9c2085e2eff638ef4006956951c84fe -->

<!-- pgdoc-cn_start sig_en=de9706e500f59c553e2fb8408fcd9e72 sig_cn_org=None source=14.1 
   <para>
    Tokens such as <token>SELECT</token>, <token>UPDATE</token>, or
    <token>VALUES</token> in the example above are examples of
    <firstterm>key words</firstterm>, that is, words that have a fixed
    meaning in the SQL language.  The tokens <token>MY_TABLE</token>
    and <token>A</token> are examples of
    <firstterm>identifiers</firstterm>.  They identify names of
    tables, columns, or other database objects, depending on the
    command they are used in.  Therefore they are sometimes simply
    called <quote>names</quote>.  Key words and identifiers have the
    same lexical structure, meaning that one cannot know whether a
    token is an identifier or a key word without knowing the language.
    A complete list of key words can be found in <xref
    linkend="sql-keywords-appendix"/>.
   </para>
________________________________________________________-->
   <para>
    上例中的<token>SELECT</token>、<token>UPDATE</token>或<token>VALUES</token>记号是<firstterm>关键词</firstterm>的例子，即SQL语言中具有特定意义的词。记号<token>MY_TABLE</token>和<token>A</token>则是<firstterm>标识符</firstterm>的例子。它们标识表、列或者其他数据库对象的名字，取决于使用它们的命令。因此它们有时也被简称为<quote>名字</quote>。关键词和标识符具有相同的词法结构，这意味着我们无法在没有语言知识的前提下区分一个标识符和关键词。一个关键词的完整列表可以在<xref
    linkend="sql-keywords-appendix"/>中找到。
   </para>
<!-- pgdoc-cn_end sig_en=de9706e500f59c553e2fb8408fcd9e72 -->

<!-- pgdoc-cn_start sig_en=fcf11aecd957d3c2b3c4a7fc7626e234 sig_cn_org=None source=14.1 
   <para>
    SQL identifiers and key words must begin with a letter
    (<literal>a</literal>-<literal>z</literal>, but also letters with
    diacritical marks and non-Latin letters) or an underscore
    (<literal>_</literal>).  Subsequent characters in an identifier or
    key word can be letters, underscores, digits
    (<literal>0</literal>-<literal>9</literal>), or dollar signs
    (<literal>$</literal>).  Note that dollar signs are not allowed in identifiers
    according to the letter of the SQL standard, so their use might render
    applications less portable.
    The SQL standard will not define a key word that contains
    digits or starts or ends with an underscore, so identifiers of this
    form are safe against possible conflict with future extensions of the
    standard.
   </para>
________________________________________________________-->
   <para>
    SQL标识符和关键词必须以一个字母（<literal>a</literal>-<literal>z</literal>，也可以是带变音符的字母和非拉丁字母）或一个下划线（_）开始。后续字符可以是字母、下划线（<literal>_</literal>）、数字（<literal>0</literal>-<literal>9</literal>）或美元符号（<literal>$</literal>）。注意根据SQL标准的字母规定，美元符号是不允许出现在标识符中的，因此它们的使用可能会降低应用的可移植性。SQL标准不会定义包含数字或者以下划线开头或结尾的关键词，因此这种形式的标识符不会与未来可能的标准扩展冲突 。
   </para>
<!-- pgdoc-cn_end sig_en=fcf11aecd957d3c2b3c4a7fc7626e234 -->

<!-- pgdoc-cn_start sig_en=33bc25fd48cb96288844c6cf1f3dbbf7 sig_cn_org=None source=14.1 
   <para>
    <indexterm><primary>identifier</primary><secondary>length</secondary></indexterm>
    The system uses no more than <symbol>NAMEDATALEN</symbol>-1
    bytes of an identifier; longer names can be written in
    commands, but they will be truncated.  By default,
    <symbol>NAMEDATALEN</symbol> is 64 so the maximum identifier
    length is 63 bytes. If this limit is problematic, it can be raised by
    changing the <symbol>NAMEDATALEN</symbol> constant in
    <filename>src/include/pg_config_manual.h</filename>.
   </para>
________________________________________________________-->
   <para>
    <indexterm><primary>identifier</primary><secondary>length</secondary></indexterm>
    系统中一个标识符的长度不能超过 <symbol>NAMEDATALEN</symbol>-1 字节，在命令中可以写超过此长度的标识符，但是它们会被截断。默认情况下，<symbol>NAMEDATALEN</symbol> 的值为64，因此标识符的长度上限为63字节。如果这个限制有问题，可以在<filename>src/include/pg_config_manual.h</filename>中修改 <symbol>NAMEDATALEN</symbol> 常量。
   </para>
<!-- pgdoc-cn_end sig_en=33bc25fd48cb96288844c6cf1f3dbbf7 -->

<!-- pgdoc-cn_start sig_en=5c23e531c74e33f8e3e438bfe6164099 sig_cn_org=None source=14.1 
   <para>
    <indexterm>
     <primary>case sensitivity</primary>
     <secondary>of SQL commands</secondary>
    </indexterm>
    Key words and unquoted identifiers are case insensitive.  Therefore:
<programlisting>
UPDATE MY_TABLE SET A = 5;
</programlisting>
    can equivalently be written as:
<programlisting>
uPDaTE my_TabLE SeT a = 5;
</programlisting>
    A convention often used is to write key words in upper
    case and names in lower case, e.g.:
<programlisting>
UPDATE my_table SET a = 5;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    <indexterm>
     <primary>case sensitivity</primary>
     <secondary>of SQL commands</secondary>
    </indexterm>
    关键词和不被引号修饰的标识符是大小写不敏感的。因此：
<programlisting>
UPDATE MY_TABLE SET A = 5;
</programlisting>
    可以等价地写成：
<programlisting>
uPDaTE my_TabLE SeT a = 5;
</programlisting>
    一个常见的习惯是将关键词写成大写，而名称写成小写，例如：
<programlisting>
UPDATE my_table SET a = 5;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=5c23e531c74e33f8e3e438bfe6164099 -->

<!-- pgdoc-cn_start sig_en=3791c4865b8ea4cf1fc9fec28547a69f sig_cn_org=None source=14.1 
   <para>
    <indexterm>
     <primary>quotation marks</primary>
     <secondary>and identifiers</secondary>
    </indexterm>
    There is a second kind of identifier:  the <firstterm>delimited
    identifier</firstterm> or <firstterm>quoted
    identifier</firstterm>.  It is formed by enclosing an arbitrary
    sequence of characters in double-quotes
    (<literal>"</literal>). <!-&minus; " font-lock mania -&minus;> A delimited
    identifier is always an identifier, never a key word.  So
    <literal>"select"</literal> could be used to refer to a column or
    table named <quote>select</quote>, whereas an unquoted
    <literal>select</literal> would be taken as a key word and
    would therefore provoke a parse error when used where a table or
    column name is expected.  The example can be written with quoted
    identifiers like this:
<programlisting>
UPDATE "my_table" SET "a" = 5;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    <indexterm>
     <primary>quotation marks</primary>
     <secondary>and identifiers</secondary>
    </indexterm>
    这里还有第二种形式的标识符：<firstterm>受限标识符</firstterm>或<firstterm>被引号修饰的标识符</firstterm>。它是由双引号（<literal>"</literal>）包围的一个任意字符序列。一个受限标识符总是一个标识符而不会是一个关键字。因此<literal>"select"</literal>可以用于引用一个名为<quote>select</quote>的列或者表，而一个没有引号修饰的<literal>select</literal>则会被当作一个关键词，从而在本应使用表或列名的地方引起解析错误。在上例中使用受限标识符的例子如下：
<programlisting>
UPDATE "my_table" SET "a" = 5;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=3791c4865b8ea4cf1fc9fec28547a69f -->

<!-- pgdoc-cn_start sig_en=5c7edeef5bde5c8dda6aeca68f654aa7 sig_cn_org=None source=14.1 
   <para>
    Quoted identifiers can contain any character, except the character
    with code zero.  (To include a double quote, write two double quotes.)
    This allows constructing table or column names that would
    otherwise not be possible, such as ones containing spaces or
    ampersands.  The length limitation still applies.
   </para>
________________________________________________________-->
   <para>
    受限标识符可以包含任何字符，除了代码为0的字符（如果要包含一个双引号，则写两个双引号）。这使得可以构建原本不被允许的表或列的名称，例如包含空格或花号的名字。但是长度限制依然有效。
   </para>
<!-- pgdoc-cn_end sig_en=5c7edeef5bde5c8dda6aeca68f654aa7 -->

<!-- pgdoc-cn_start sig_en=d3812ea55db8189e50f30cb1380ccdf1 sig_cn_org=None source=14.1 
   <para>
    Quoting an identifier also makes it case-sensitive, whereas
    unquoted names are always folded to lower case.  For example, the
    identifiers <literal>FOO</literal>, <literal>foo</literal>, and
    <literal>"foo"</literal> are considered the same by
    <productname>PostgreSQL</productname>, but
    <literal>"Foo"</literal> and <literal>"FOO"</literal> are
    different from these three and each other.  (The folding of
    unquoted names to lower case in <productname>PostgreSQL</productname> is
    incompatible with the SQL standard, which says that unquoted names
    should be folded to upper case.  Thus, <literal>foo</literal>
    should be equivalent to <literal>"FOO"</literal> not
    <literal>"foo"</literal> according to the standard.  If you want
    to write portable applications you are advised to always quote a
    particular name or never quote it.)
   </para>
________________________________________________________-->
   <para>
    引用标识符也使其区分大小写，而未引用的名称总是折叠成小写。例如，标识符<literal>FOO</literal>、<literal>foo</literal>和<literal>"foo"</literal>在<productname>PostgreSQL</productname>中被认为是相同的，但是<literal>"Foo"</literal> 和 <literal>"FOO"</literal>与这三个不同，并且彼此不同。(在<productname>PostgreSQL</productname>中，将不带引号的名称折叠为小写与SQL标准不兼容，SQL标准规定不带引号的名称应折叠为大写。因此，根据标准，<literal>foo</literal>应等同于<literal>"FOO"</literal>而不是<literal>"foo"</literal>。如果您想编写可移植应用程序，建议您始终引用某个特定的名称，或者永远不要引用它。）
   </para>
<!-- pgdoc-cn_end sig_en=d3812ea55db8189e50f30cb1380ccdf1 -->

<!-- pgdoc-cn_start sig_en=42ff661dcfc456395b46af4e731f4a28 sig_cn_org=None source=14.1 
   <indexterm>
     <primary>Unicode escape</primary>
     <secondary>in identifiers</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
     <primary>Unicode escape</primary>
     <secondary>in identifiers</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=42ff661dcfc456395b46af4e731f4a28 -->

<!-- pgdoc-cn_start sig_en=110d1fa0f8e3f147f7c112be5816dbce sig_cn_org=None source=14.1 
   <para>
    A variant of quoted
    identifiers allows including escaped Unicode characters identified
    by their code points.  This variant starts
    with <literal>U&amp;</literal> (upper or lower case U followed by
    ampersand) immediately before the opening double quote, without
    any spaces in between, for example <literal>U&amp;"foo"</literal>.
    (Note that this creates an ambiguity with the
    operator <literal>&amp;</literal>.  Use spaces around the operator to
    avoid this problem.)  Inside the quotes, Unicode characters can be
    specified in escaped form by writing a backslash followed by the
    four-digit hexadecimal code point number or alternatively a
    backslash followed by a plus sign followed by a six-digit
    hexadecimal code point number.  For example, the
    identifier <literal>"data"</literal> could be written as
<programlisting>
U&amp;"d\0061t\+000061"
</programlisting>
    The following less trivial example writes the Russian
    word <quote>slon</quote> (elephant) in Cyrillic letters:
<programlisting>
U&amp;"\0441\043B\043E\043D"
</programlisting>
   </para>
________________________________________________________-->
   <para>
    一种受限标识符的变体允许包括转义的用代码点标识的Unicode字符。这种变体以<literal>U&amp;</literal>（大写或小写U跟上一个花号）开始，后面紧跟双引号修饰的名称，两者之间没有任何空白，如<literal>U&amp;"foo"</literal>（注意这里与操作符<literal>&amp;</literal>似乎有一些混淆，但是在<literal>&amp;</literal>操作符周围使用空白避免了这个问题） 。在引号内，Unicode字符可以以转义的形式指定：反斜线接上4位16进制代码点号码或者反斜线和加号接上6位16进制代码点号码。例如，标识符<literal>"data"</literal>可以写成：
<programlisting>
U&amp;"d\0061t\+000061"
</programlisting>
    下面的例子用斯拉夫语字母写出了俄语单词 <quote>slon</quote>（大象）：
<programlisting>
U&amp;"\0441\043B\043E\043D"
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=110d1fa0f8e3f147f7c112be5816dbce -->

<!-- pgdoc-cn_start sig_en=48494ccf61069c477df54fbe6fdd5b51 sig_cn_org=None source=14.1 
   <para>
    If a different escape character than backslash is desired, it can
    be specified using
    the <literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm>
    clause after the string, for example:
<programlisting>
U&amp;"d!0061t!+000061" UESCAPE '!'
</programlisting>
    The escape character can be any single character other than a
    hexadecimal digit, the plus sign, a single quote, a double quote,
    or a whitespace character.  Note that the escape character is
    written in single quotes, not double quotes,
    after <literal>UESCAPE</literal>.
   </para>
________________________________________________________-->
   <para>
    如果希望使用其他转义字符来代替反斜线，可以在字符串后使用<literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm>子句，例如：
<programlisting>
U&amp;"d!0061t!+000061" UESCAPE '!'
</programlisting>
    转义字符可以是除了16进制位、加号、单引号、双引号、空白字符之外的任意单个字符。请注意，转义字符在 <literal>UESCAPE</literal> 之后用单引号而不是双引号书写。
   </para>
<!-- pgdoc-cn_end sig_en=48494ccf61069c477df54fbe6fdd5b51 -->

<!-- pgdoc-cn_start sig_en=45a1510adf61c9fd5afe4515df265bcf sig_cn_org=None source=14.1 
   <para>
    To include the escape character in the identifier literally, write
    it twice.
   </para>
________________________________________________________-->
   <para>
    为了在标识符中包括转义字符本身，将其写两次即可。
   </para>
<!-- pgdoc-cn_end sig_en=45a1510adf61c9fd5afe4515df265bcf -->

<!-- pgdoc-cn_start sig_en=210251c57517c3f977a572192feaa0d0 sig_cn_org=None source=14.1 
   <para>
    Either the 4-digit or the 6-digit escape form can be used to
    specify UTF-16 surrogate pairs to compose characters with code
    points larger than U+FFFF, although the availability of the
    6-digit form technically makes this unnecessary.  (Surrogate
    pairs are not stored directly, but are combined into a single
    code point.)
   </para>
________________________________________________________-->
   <para>
    4位或6位转义形式都可以被用来定义UTF-16代理对来组成代码点大于U+FFFF的字符，尽管6位形式的存在使得这种做法变得不必要（代理对并不被直接存储，而是绑定成一个单独的代码点）。
   </para>
<!-- pgdoc-cn_end sig_en=210251c57517c3f977a572192feaa0d0 -->

<!-- pgdoc-cn_start sig_en=892f956b65f7162f54729cd9f42bb406 sig_cn_org=None source=14.1 
   <para>
    If the server encoding is not UTF-8, the Unicode code point identified
    by one of these escape sequences is converted to the actual server
    encoding; an error is reported if that's not possible.
   </para>
________________________________________________________-->
   <para>
    如果服务器编码不是UTF-8，则由其中一个转义序列标识的Unicode代码点转换为实际的服务器编码；如果不可能，则报告错误。
   </para>
<!-- pgdoc-cn_end sig_en=892f956b65f7162f54729cd9f42bb406 -->
  </sect2>


  <sect2 id="sql-syntax-constants">
<!-- pgdoc-cn_start sig_en=f6454fc5438c64a18139bfe56aa31858 sig_cn_org=None source=14.1 
   <title>Constants</title>
________________________________________________________-->
   <title>常量</title>
<!-- pgdoc-cn_end sig_en=f6454fc5438c64a18139bfe56aa31858 -->

<!-- pgdoc-cn_start sig_en=72cbc063a7005c54306ef1250c455f47 sig_cn_org=None source=14.1 
   <indexterm zone="sql-syntax-constants">
    <primary>constant</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="sql-syntax-constants">
    <primary>constant</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=72cbc063a7005c54306ef1250c455f47 -->

<!-- pgdoc-cn_start sig_en=8b4f891d4a67c6833eb5a2ef9befae00 sig_cn_org=None source=14.1 
   <para>
    There are three kinds of <firstterm>implicitly-typed
    constants</firstterm> in <productname>PostgreSQL</productname>:
    strings, bit strings, and numbers.
    Constants can also be specified with explicit types, which can
    enable more accurate representation and more efficient handling by
    the system. These alternatives are discussed in the following
    subsections.
   </para>
________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname>中有三种<firstterm>隐式类型常量</firstterm>：字符串、位串和数字。常量也可以被指定显式类型，这可以使得它被更精确地展示以及更有效地处理。这些选择将会在后续小节中讨论。
   </para>
<!-- pgdoc-cn_end sig_en=8b4f891d4a67c6833eb5a2ef9befae00 -->

   <sect3 id="sql-syntax-strings">
<!-- pgdoc-cn_start sig_en=2220b0822fa585f5c9acbfd595ebc7a8 sig_cn_org=None source=14.1 
    <title>String Constants</title>
________________________________________________________-->
    <title>字符串常量</title>
<!-- pgdoc-cn_end sig_en=2220b0822fa585f5c9acbfd595ebc7a8 -->

<!-- pgdoc-cn_start sig_en=d67887e33bc3822c72710b23c02023d2 sig_cn_org=None source=14.1 
    <indexterm zone="sql-syntax-strings">
     <primary>character string</primary>
     <secondary>constant</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="sql-syntax-strings">
     <primary>character string</primary>
     <secondary>constant</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=d67887e33bc3822c72710b23c02023d2 -->

<!-- pgdoc-cn_start sig_en=1a6365670760784a628aaaf3b433712c sig_cn_org=None source=14.1 
    <para>
     <indexterm>
      <primary>quotation marks</primary>
      <secondary>escaping</secondary>
     </indexterm>
     A string constant in SQL is an arbitrary sequence of characters
     bounded by single quotes (<literal>'</literal>), for example
     <literal>'This is a string'</literal>.  To include
     a single-quote character within a string constant,
     write two adjacent single quotes, e.g.,
     <literal>'Dianne''s horse'</literal>.
     Note that this is <emphasis>not</emphasis> the same as a double-quote
     character (<literal>"</literal>). <!-&minus; font-lock sanity: " -&minus;>
    </para>
________________________________________________________-->
    <para>
     <indexterm>
      <primary>quotation marks</primary>
      <secondary>escaping</secondary>
     </indexterm>
     
     在SQL中，一个字符串常量是一个由单引号（<literal>'</literal>）包围的任意字符序列，例如<literal>'This is a string'</literal>。为了在一个字符串中包括一个单引号，可以写两个相连的单引号，例如<literal>'Dianne''s horse'</literal>。注意这和一个双引号（<literal>"</literal>）<emphasis>不</emphasis>同。
    </para>
<!-- pgdoc-cn_end sig_en=1a6365670760784a628aaaf3b433712c -->

<!-- pgdoc-cn_start sig_en=09e85557f940c04f79b837788a7a288f sig_cn_org=None source=14.1 
    <para>
     Two string constants that are only separated by whitespace
     <emphasis>with at least one newline</emphasis> are concatenated
     and effectively treated as if the string had been written as one
     constant.  For example:
<programlisting>
SELECT 'foo'
'bar';
</programlisting>
     is equivalent to:
<programlisting>
SELECT 'foobar';
</programlisting>
     but:
<programlisting>
SELECT 'foo'      'bar';
</programlisting>
     is not valid syntax.  (This slightly bizarre behavior is specified
     by <acronym>SQL</acronym>; <productname>PostgreSQL</productname> is
     following the standard.)
    </para>
________________________________________________________-->
    <para>
     两个只由空白及<emphasis>至少一个新行</emphasis>分隔的字符串常量会被连接在一起，并且将作为一个写在一起的字符串常量来对待。例如：
<programlisting>
SELECT 'foo'
'bar';
</programlisting>
     等同于：
<programlisting>
SELECT 'foobar';
</programlisting>
     但是：
<programlisting>
SELECT 'foo'      'bar';
</programlisting>
     则不是合法的语法（这种有些奇怪的行为是<acronym>SQL</acronym>指定的，<productname>PostgreSQL</productname>遵循了该标准）。
    </para>
<!-- pgdoc-cn_end sig_en=09e85557f940c04f79b837788a7a288f -->
   </sect3>

   <sect3 id="sql-syntax-strings-escape">
<!-- pgdoc-cn_start sig_en=7646a3cbff37fe30c70fa0e8dd1ded4d sig_cn_org=None source=14.1 
    <title>String Constants with C-Style Escapes</title>
________________________________________________________-->
    <title>C风格转义的字符串常量</title>
<!-- pgdoc-cn_end sig_en=7646a3cbff37fe30c70fa0e8dd1ded4d -->

<!-- pgdoc-cn_start sig_en=ef4b0b1a187d74c76487ae5422ea6952 sig_cn_org=None source=14.1 
     <indexterm zone="sql-syntax-strings-escape">
      <primary>escape string syntax</primary>
     </indexterm>
________________________________________________________-->
     <indexterm zone="sql-syntax-strings-escape">
      <primary>escape string syntax</primary>
     </indexterm>
<!-- pgdoc-cn_end sig_en=ef4b0b1a187d74c76487ae5422ea6952 -->
<!-- pgdoc-cn_start sig_en=994d18b12e991d28ddb69ed18f06a940 sig_cn_org=None source=14.1 
     <indexterm zone="sql-syntax-strings-escape">
      <primary>backslash escapes</primary>
     </indexterm>
________________________________________________________-->
     <indexterm zone="sql-syntax-strings-escape">
      <primary>backslash escapes</primary>
     </indexterm>
<!-- pgdoc-cn_end sig_en=994d18b12e991d28ddb69ed18f06a940 -->

<!-- pgdoc-cn_start sig_en=04ce1566710a66276094e7f720a87521 sig_cn_org=None source=14.1 
    <para>
     <productname>PostgreSQL</productname> also accepts <quote>escape</quote>
     string constants, which are an extension to the SQL standard.
     An escape string constant is specified by writing the letter
     <literal>E</literal> (upper or lower case) just before the opening single
     quote, e.g., <literal>E'foo'</literal>.  (When continuing an escape string
     constant across lines, write <literal>E</literal> only before the first opening
     quote.)
     Within an escape string, a backslash character (<literal>\</literal>) begins a
     C-like <firstterm>backslash escape</firstterm> sequence, in which the combination
     of backslash and following character(s) represent a special byte
     value, as shown in <xref linkend="sql-backslash-table"/>.
    </para>
________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>也接受<quote>转义</quote>字符串常量，这也是SQL标准的一个扩展。一个转义字符串常量可以通过在开单引号前面写一个字母<literal>E</literal>（大写或小写形式）来指定，例如<literal>E'foo'</literal>（当一个转义字符串常量跨行时，只在第一个开引号之前写<literal>E</literal>）。在一个转义字符串内部，一个反斜线字符（<literal>\</literal>）会开始一个 C 风格的<firstterm>反斜线转义</firstterm>序列，在其中反斜线和后续字符的组合表示一个特殊的字节值（如<xref linkend="sql-backslash-table"/>中所示）。
    </para>
<!-- pgdoc-cn_end sig_en=04ce1566710a66276094e7f720a87521 -->

     <table id="sql-backslash-table">
<!-- pgdoc-cn_start sig_en=a024c0d0727022e234599b126c688e52 sig_cn_org=None source=14.1 
      <title>Backslash Escape Sequences</title>
________________________________________________________-->
      <title>反斜线转义序列</title>
<!-- pgdoc-cn_end sig_en=a024c0d0727022e234599b126c688e52 -->
      <tgroup cols="2">
      <thead>
<!-- pgdoc-cn_start sig_en=94dcef2c587915d022add63c5a15e887 sig_cn_org=None source=14.1 
       <row>
        <entry>Backslash Escape Sequence</entry>
        <entry>Interpretation</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>反斜线转义序列</entry>
        <entry>解释</entry>
       </row>
<!-- pgdoc-cn_end sig_en=94dcef2c587915d022add63c5a15e887 -->
      </thead>

      <tbody>
<!-- pgdoc-cn_start sig_en=df177ec6a3f5fb0b18a63bebe34d12dc sig_cn_org=None source=14.1 
       <row>
        <entry><literal>\b</literal></entry>
        <entry>backspace</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>\b</literal></entry>
        <entry>退格</entry>
       </row>
<!-- pgdoc-cn_end sig_en=df177ec6a3f5fb0b18a63bebe34d12dc -->
<!-- pgdoc-cn_start sig_en=e5a5a9e6e88cc440a137c63f7eddc6f6 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>\f</literal></entry>
        <entry>form feed</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>\f</literal></entry>
        <entry>换页</entry>
       </row>
<!-- pgdoc-cn_end sig_en=e5a5a9e6e88cc440a137c63f7eddc6f6 -->
<!-- pgdoc-cn_start sig_en=8c80ff86916eb3d5284d4b4ab28f4076 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>\n</literal></entry>
        <entry>newline</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>\n</literal></entry>
        <entry>换行</entry>
       </row>
<!-- pgdoc-cn_end sig_en=8c80ff86916eb3d5284d4b4ab28f4076 -->
<!-- pgdoc-cn_start sig_en=3c8c35fb44e5a134165b32fafd276c69 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>\r</literal></entry>
        <entry>carriage return</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>\r</literal></entry>
        <entry>回车</entry>
       </row>
<!-- pgdoc-cn_end sig_en=3c8c35fb44e5a134165b32fafd276c69 -->
<!-- pgdoc-cn_start sig_en=85cb2e7132021cc8d530890337c4eb61 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>\t</literal></entry>
        <entry>tab</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>\t</literal></entry>
        <entry>制表符</entry>
       </row>
<!-- pgdoc-cn_end sig_en=85cb2e7132021cc8d530890337c4eb61 -->
<!-- pgdoc-cn_start sig_en=d4a30a9a2a288b4039199a8458ef69ce sig_cn_org=None source=14.1 
       <row>
        <entry>
         <literal>\<replaceable>o</replaceable></literal>,
         <literal>\<replaceable>oo</replaceable></literal>,
         <literal>\<replaceable>ooo</replaceable></literal>
         (<replaceable>o</replaceable> = 0&ndash;7)
        </entry>
        <entry>octal byte value</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>
         <literal>\<replaceable>o</replaceable></literal>,
         <literal>\<replaceable>oo</replaceable></literal>,
         <literal>\<replaceable>ooo</replaceable></literal>
         (<replaceable>o</replaceable> = 0&ndash;7)
        </entry>
        <entry>八进制字节值</entry>
       </row>
<!-- pgdoc-cn_end sig_en=d4a30a9a2a288b4039199a8458ef69ce -->
<!-- pgdoc-cn_start sig_en=a592728b1e106e0500f2cf955b96e35b sig_cn_org=None source=14.1 
       <row>
        <entry>
         <literal>\x<replaceable>h</replaceable></literal>,
         <literal>\x<replaceable>hh</replaceable></literal>
         (<replaceable>h</replaceable> = 0&ndash;9, A&ndash;F)
        </entry>
        <entry>hexadecimal byte value</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>
         <literal>\x<replaceable>h</replaceable></literal>,
         <literal>\x<replaceable>hh</replaceable></literal>
         (<replaceable>h</replaceable> = 0&ndash;9, A&ndash;F)
        </entry>
        <entry>十六进制字节值</entry>
       </row>
<!-- pgdoc-cn_end sig_en=a592728b1e106e0500f2cf955b96e35b -->
<!-- pgdoc-cn_start sig_en=753d436af453b611408bb8fb8b95a811 sig_cn_org=None source=14.1 
       <row>
        <entry>
         <literal>\u<replaceable>xxxx</replaceable></literal>,
         <literal>\U<replaceable>xxxxxxxx</replaceable></literal>
         (<replaceable>x</replaceable> = 0&ndash;9, A&ndash;F)
        </entry>
        <entry>16 or 32-bit hexadecimal Unicode character value</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>
         <literal>\u<replaceable>xxxx</replaceable></literal>,
         <literal>\U<replaceable>xxxxxxxx</replaceable></literal>
         (<replaceable>x</replaceable> = 0&ndash;9, A&ndash;F)
        </entry>
        <entry>16 或 32-位十六进制 Unicode 字符值</entry>
       </row>
<!-- pgdoc-cn_end sig_en=753d436af453b611408bb8fb8b95a811 -->
      </tbody>
      </tgroup>
     </table>

<!-- pgdoc-cn_start sig_en=72347ec622f3dc45b73e566407ce2ee3 sig_cn_org=None source=14.1 
    <para>
     Any other
     character following a backslash is taken literally. Thus, to
     include a backslash character, write two backslashes (<literal>\\</literal>).
     Also, a single quote can be included in an escape string by writing
     <literal>\'</literal>, in addition to the normal way of <literal>''</literal>.
    </para>
________________________________________________________-->
    <para>
     跟随在一个反斜线后面的任何其他字符被当做其字面意思。因此，要包括一个反斜线字符，请写两个反斜线（<literal>\\</literal>）。在一个转义字符串中包括一个单引号除了普通方法<literal>''</literal>之外，还可以写成<literal>\'</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=72347ec622f3dc45b73e566407ce2ee3 -->

<!-- pgdoc-cn_start sig_en=ec13268d86492f210236ef34b56fa98a sig_cn_org=None source=14.1 
    <para>
     It is your responsibility that the byte sequences you create,
     especially when using the octal or hexadecimal escapes, compose
     valid characters in the server character set encoding.
     A useful alternative is to use Unicode escapes or the
     alternative Unicode escape syntax, explained
     in <xref linkend="sql-syntax-strings-uescape"/>; then the server
     will check that the character conversion is possible.
    </para>
________________________________________________________-->
    <para>
     你要负责保证你创建的字节序列由服务器字符集编码中合法的字符组成，特别是在使用八进制或十六进制转义时。一个有用的替代方法是使用Unicode转义或替代的Unicode转义语法，如<xref linkend="sql-syntax-strings-uescape"/>中所述；然后服务器将检查字符转换是否可行。
    </para>
<!-- pgdoc-cn_end sig_en=ec13268d86492f210236ef34b56fa98a -->

    <caution>
<!-- pgdoc-cn_start sig_en=2c49a6d601fc91aa83fd2075a10e94fb sig_cn_org=None source=14.1 
    <para>
     If the configuration parameter
     <xref linkend="guc-standard-conforming-strings"/> is <literal>off</literal>,
     then <productname>PostgreSQL</productname> recognizes backslash escapes
     in both regular and escape string constants.  However, as of
     <productname>PostgreSQL</productname> 9.1, the default is <literal>on</literal>, meaning
     that backslash escapes are recognized only in escape string constants.
     This behavior is more standards-compliant, but might break applications
     which rely on the historical behavior, where backslash escapes
     were always recognized.  As a workaround, you can set this parameter
     to <literal>off</literal>, but it is better to migrate away from using backslash
     escapes.  If you need to use a backslash escape to represent a special
     character, write the string constant with an <literal>E</literal>.
    </para>
________________________________________________________-->
    <para>
     如果配置参数<xref linkend="guc-standard-conforming-strings"/>为<literal>off</literal>，那么<productname>PostgreSQL</productname>对常规字符串常量和转义字符串常量中的反斜线转义都识别。不过，从<productname>PostgreSQL</productname> 9.1 开始，该参数的默认值为<literal>on</literal>，意味着只在转义字符串常量中识别反斜线转义。这种行为更兼容标准，但是可能打断依赖于历史行为（反斜线转义总是会被识别）的应用。作为一种变通，你可以设置该参数为<literal>off</literal>，但是最好迁移到符合新的行为。如果你需要使用一个反斜线转义来表示一个特殊字符，为该字符串常量写上一个<literal>E</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=2c49a6d601fc91aa83fd2075a10e94fb -->

<!-- pgdoc-cn_start sig_en=0469e84836cecae9c6b9670f98e19952 sig_cn_org=None source=14.1 
    <para>
     In addition to <varname>standard_conforming_strings</varname>, the configuration
     parameters <xref linkend="guc-escape-string-warning"/> and
     <xref linkend="guc-backslash-quote"/> govern treatment of backslashes
     in string constants.
    </para>
________________________________________________________-->
    <para>
     在<varname>standard_conforming_strings</varname>之外，配置参数<xref linkend="guc-escape-string-warning"/>和<xref linkend="guc-backslash-quote"/>也决定了如何对待字符串常量中的反斜线。
    </para>
<!-- pgdoc-cn_end sig_en=0469e84836cecae9c6b9670f98e19952 -->
    </caution>

<!-- pgdoc-cn_start sig_en=9be5283ed1aa13ac1b03e5bd9522d033 sig_cn_org=None source=14.1 
    <para>
     The character with the code zero cannot be in a string constant.
    </para>
________________________________________________________-->
    <para>
     代码零的字符不能出现在一个字符串常量中。
    </para>
<!-- pgdoc-cn_end sig_en=9be5283ed1aa13ac1b03e5bd9522d033 -->
   </sect3>

   <sect3 id="sql-syntax-strings-uescape">
<!-- pgdoc-cn_start sig_en=cec3b0194568ea71645cf3d5f6319c2a sig_cn_org=None source=14.1 
    <title>String Constants with Unicode Escapes</title>
________________________________________________________-->
    <title>带有 Unicode 转义的字符串常量</title>
<!-- pgdoc-cn_end sig_en=cec3b0194568ea71645cf3d5f6319c2a -->

<!-- pgdoc-cn_start sig_en=cd48654cb04df06ecf904d308e6e995f sig_cn_org=None source=14.1 
    <indexterm  zone="sql-syntax-strings-uescape">
     <primary>Unicode escape</primary>
     <secondary>in string constants</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm  zone="sql-syntax-strings-uescape">
     <primary>Unicode escape</primary>
     <secondary>in string constants</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=cd48654cb04df06ecf904d308e6e995f -->

<!-- pgdoc-cn_start sig_en=6d3f350a77628c705f08b1862d1cb4c6 sig_cn_org=None source=14.1 
    <para>
     <productname>PostgreSQL</productname> also supports another type
     of escape syntax for strings that allows specifying arbitrary
     Unicode characters by code point.  A Unicode escape string
     constant starts with <literal>U&amp;</literal> (upper or lower case
     letter U followed by ampersand) immediately before the opening
     quote, without any spaces in between, for
     example <literal>U&amp;'foo'</literal>.  (Note that this creates an
     ambiguity with the operator <literal>&amp;</literal>.  Use spaces
     around the operator to avoid this problem.)  Inside the quotes,
     Unicode characters can be specified in escaped form by writing a
     backslash followed by the four-digit hexadecimal code point
     number or alternatively a backslash followed by a plus sign
     followed by a six-digit hexadecimal code point number.  For
     example, the string <literal>'data'</literal> could be written as
<programlisting>
U&amp;'d\0061t\+000061'
</programlisting>
     The following less trivial example writes the Russian
     word <quote>slon</quote> (elephant) in Cyrillic letters:
<programlisting>
U&amp;'\0441\043B\043E\043D'
</programlisting>
    </para>
________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>也支持另一种类型的字符串转义语法，它允许用代码点指定任意 Unicode 字符。一个 Unicode 转义字符串常量开始于<literal>U&amp;</literal>（大写或小写形式的字母 U，后跟花号），后面紧跟着开引号，之间没有任何空白，例如<literal>U&amp;'foo'</literal>（注意这产生了与操作符<literal>&amp;</literal>的混淆。在操作符周围使用空白来避免这个问题）。在引号内，Unicode 字符可以通过写一个后跟 4 位十六进制代码点编号或者一个前面有加号的 6 位十六进制代码点编号的反斜线来指定。例如，字符串<literal>'data'</literal>可以被写为
<programlisting>
U&amp;'d\0061t\+000061'
</programlisting>
     下面的例子用斯拉夫字母写出了俄语的单词<quote>slon</quote>（大象）：
<programlisting>
U&amp;'\0441\043B\043E\043D'
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=6d3f350a77628c705f08b1862d1cb4c6 -->

<!-- pgdoc-cn_start sig_en=0c135a85d9cead407512c019927aa6a8 sig_cn_org=None source=14.1 
    <para>
     If a different escape character than backslash is desired, it can
     be specified using
     the <literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm>
     clause after the string, for example:
<programlisting>
U&amp;'d!0061t!+000061' UESCAPE '!'
</programlisting>
     The escape character can be any single character other than a
     hexadecimal digit, the plus sign, a single quote, a double quote,
     or a whitespace character.
    </para>
________________________________________________________-->
    <para>
     如果想要一个不是反斜线的转义字符，可以在字符串之后使用<literal>UESCAPE</literal><indexterm><primary>UESCAPE</primary></indexterm>子句来指定，例如：
<programlisting>
U&amp;'d!0061t!+000061' UESCAPE '!'
</programlisting>
     转义字符可以是出一个十六进制位、加号、单引号、双引号或空白字符之外的任何单一字符。
    </para>
<!-- pgdoc-cn_end sig_en=0c135a85d9cead407512c019927aa6a8 -->

<!-- pgdoc-cn_start sig_en=11eb2eb38a47ad2022102a9dd84d1f94 sig_cn_org=None source=14.1 
    <para>
     To include the escape character in the string literally, write
     it twice.
    </para>
________________________________________________________-->
    <para>
     要在一个字符串中包括一个表示其字面意思的转义字符，把它写两次。
    </para>
<!-- pgdoc-cn_end sig_en=11eb2eb38a47ad2022102a9dd84d1f94 -->

<!-- pgdoc-cn_start sig_en=830c4a28043554e80d1565ec66a265e0 sig_cn_org=None source=14.1 
    <para>
     Either the 4-digit or the 6-digit escape form can be used to
     specify UTF-16 surrogate pairs to compose characters with code
     points larger than U+FFFF, although the availability of the
     6-digit form technically makes this unnecessary.  (Surrogate
     pairs are not stored directly, but are combined into a single
     code point.)
    </para>
________________________________________________________-->
    <para>
     4位或6位转义形式可用于指定UTF-16代理项对，以组成代码点大于U+FFFF的字符，尽管从技术上讲，6位形式的可用性使得这是不必要的(代理项对不是直接存储的，而是合并到单个代码点中。）
    </para>
<!-- pgdoc-cn_end sig_en=830c4a28043554e80d1565ec66a265e0 -->

<!-- pgdoc-cn_start sig_en=e551f4e8402a68ff94b09e727836db0d sig_cn_org=None source=14.1 
    <para>
     If the server encoding is not UTF-8, the Unicode code point identified
     by one of these escape sequences is converted to the actual server
     encoding; an error is reported if that's not possible.
    </para>
________________________________________________________-->
    <para>
     如果服务器编码不是 UTF-8，则由这些转义序列之一标识的 Unicode 代码点将转换为实际的服务器编码； 如果不可能，则会报告错误。
    </para>
<!-- pgdoc-cn_end sig_en=e551f4e8402a68ff94b09e727836db0d -->

<!-- pgdoc-cn_start sig_en=01fd53af1dfea5486a980e5d4a61bb13 sig_cn_org=None source=14.1 
    <para>
     Also, the Unicode escape syntax for string constants only works
     when the configuration
     parameter <xref linkend="guc-standard-conforming-strings"/> is
     turned on.  This is because otherwise this syntax could confuse
     clients that parse the SQL statements to the point that it could
     lead to SQL injections and similar security issues.  If the
     parameter is set to off, this syntax will be rejected with an
     error message.
    </para>
________________________________________________________-->
    <para>
     此外，字符串常量的 Unicode 转义语法仅在配置参数 <xref linkend="guc-standard-conforming-strings"/> 开启时才有效。 这是因为否则这种语法可能会混淆解析 SQL 语句的客户端，可能导致 SQL 注入和类似的安全问题。 如果该参数设置为 off，则此语法将被拒绝并显示错误消息。
    </para>
<!-- pgdoc-cn_end sig_en=01fd53af1dfea5486a980e5d4a61bb13 -->
   </sect3>

   <sect3 id="sql-syntax-dollar-quoting">
<!-- pgdoc-cn_start sig_en=cf4450b9dfae50501f9eef5e52a528fa sig_cn_org=None source=14.1 
    <title>Dollar-Quoted String Constants</title>
________________________________________________________-->
    <title>美元引用的字符串常量</title>
<!-- pgdoc-cn_end sig_en=cf4450b9dfae50501f9eef5e52a528fa -->

<!-- pgdoc-cn_start sig_en=f1ba07b8077305c3d2e71a7c88a1f0d4 sig_cn_org=None source=14.1 
     <indexterm>
      <primary>dollar quoting</primary>
     </indexterm>
________________________________________________________-->
     <indexterm>
      <primary>dollar quoting</primary>
     </indexterm>
<!-- pgdoc-cn_end sig_en=f1ba07b8077305c3d2e71a7c88a1f0d4 -->

<!-- pgdoc-cn_start sig_en=660f7bd53fde15de458df955cc5e46ab sig_cn_org=bf9cf16b144e21413c98e680c0ffdd1e source=15.7 
    <para>
     While the standard syntax for specifying string constants is usually
     convenient, it can be difficult to understand when the desired string
     contains many single quotes, since each of those must
     be doubled. To allow more readable queries in such situations,
     <productname>PostgreSQL</productname> provides another way, called
     <quote>dollar quoting</quote>, to write string constants.
     A dollar-quoted string constant
     consists of a dollar sign (<literal>$</literal>), an optional
     <quote>tag</quote> of zero or more characters, another dollar
     sign, an arbitrary sequence of characters that makes up the
     string content, a dollar sign, the same tag that began this
     dollar quote, and a dollar sign. For example, here are two
     different ways to specify the string <quote>Dianne's horse</quote>
     using dollar quoting:
<programlisting>
$$Dianne's horse$$
$SomeTag$Dianne's horse$SomeTag$
</programlisting>
     Notice that inside the dollar-quoted string, single quotes can be
     used without needing to be escaped.  Indeed, no characters inside
     a dollar-quoted string are ever escaped: the string content is always
     written literally.  Backslashes are not special, and neither are
     dollar signs, unless they are part of a sequence matching the opening
     tag.
    </para>
________________________________________________________-->
    <para>
     当通常情况下指定字符串常量的标准语法通常很方便，但当所需字符串包含许多单引号时，很难理解，因为每个单引号都必须加倍。
     为了在这种情况下允许更易读的查询，<productname>PostgreSQL</productname>提供了另一种方式，称为<quote>dollar quoting</quote>，用于编写字符串常量。
     一个dollar-quoted字符串常量由一个美元符号(<literal>$</literal>)，一个可选的<quote>tag</quote>，另一个美元符号，一个组成字符串内容的任意字符序列，一个美元符号，开始此dollar引用的相同标记，和一个美元符号组成。例如，这里有两种不同的方式来指定字符串<quote>Dianne's horse</quote>使用dollar quoting:
<programlisting>
$$Dianne's horse$$
$SomeTag$Dianne's horse$SomeTag$
</programlisting>
     请注意，在dollar-quoted字符串内部，单引号可以使用而无需转义。实际上，在dollar-quoted字符串内部从不转义任何字符：字符串内容始终以字面方式编写。反斜杠不是特殊字符，美元符号也不是，除非它们是匹配开头标记的序列的一部分。
    </para>
<!-- pgdoc-cn_end sig_en=660f7bd53fde15de458df955cc5e46ab -->

<!-- pgdoc-cn_start sig_en=cf9137020b4806f5cd3b8e740ff32466 sig_cn_org=None source=14.1 
    <para>
     It is possible to nest dollar-quoted string constants by choosing
     different tags at each nesting level.  This is most commonly used in
     writing function definitions.  For example:
<programlisting>
$function$
BEGIN
    RETURN ($1 ~ $q$[\t\r\n\v\\]$q$);
END;
$function$
</programlisting>
     Here, the sequence <literal>$q$[\t\r\n\v\\]$q$</literal> represents a
     dollar-quoted literal string <literal>[\t\r\n\v\\]</literal>, which will
     be recognized when the function body is executed by
     <productname>PostgreSQL</productname>.  But since the sequence does not match
     the outer dollar quoting delimiter <literal>$function$</literal>, it is
     just some more characters within the constant so far as the outer
     string is concerned.
    </para>
________________________________________________________-->
    <para>
     可以通过在每一个嵌套级别上选择不同的标签来嵌套美元引用字符串常量。这最常被用在编写函数定义上。例如：
<programlisting>
$function$
BEGIN
    RETURN ($1 ~ $q$[\t\r\n\v\\]$q$);
END;
$function$
</programlisting>
     这里，序列<literal>$q$[\t\r\n\v\\]$q$</literal>表示一个美元引用的文字串<literal>[\t\r\n\v\\]</literal>，当该函数体被<productname>PostgreSQL</productname>执行时它将被识别。但是因为该序列不匹配外层的美元引用的定界符<literal>$function$</literal>，它只是一些在外层字符串所关注的常量中的字符而已。
    </para>
<!-- pgdoc-cn_end sig_en=cf9137020b4806f5cd3b8e740ff32466 -->

<!-- pgdoc-cn_start sig_en=3ee19cd4c4875655c44d07c38739c62d sig_cn_org=None source=14.1 
    <para>
     The tag, if any, of a dollar-quoted string follows the same rules
     as an unquoted identifier, except that it cannot contain a dollar sign.
     Tags are case sensitive, so <literal>$tag$String content$tag$</literal>
     is correct, but <literal>$TAG$String content$tag$</literal> is not.
    </para>
________________________________________________________-->
    <para>
     一个美元引用字符串的标签（如果有）遵循一个未被引用标识符的相同规则，除了它不能包含一个美元符号之外。标签是大小写敏感的，因此<literal>$tag$String content$tag$</literal>是正确的，但是<literal>$TAG$String content$tag$</literal>不正确。
    </para>
<!-- pgdoc-cn_end sig_en=3ee19cd4c4875655c44d07c38739c62d -->

<!-- pgdoc-cn_start sig_en=f4bcc63ad2e965717e1fc904423a5885 sig_cn_org=None source=14.1 
    <para>
     A dollar-quoted string that follows a keyword or identifier must
     be separated from it by whitespace; otherwise the dollar quoting
     delimiter would be taken as part of the preceding identifier.
    </para>
________________________________________________________-->
    <para>
     一个跟着一个关键词或标识符的美元引用字符串必须用空白与之分隔开，否则美元引用定界符可能会被作为前面标识符的一部分。
    </para>
<!-- pgdoc-cn_end sig_en=f4bcc63ad2e965717e1fc904423a5885 -->

<!-- pgdoc-cn_start sig_en=9c01d7b6cf69a12f2a84f9cf998ef57c sig_cn_org=None source=14.1 
    <para>
     Dollar quoting is not part of the SQL standard, but it is often a more
     convenient way to write complicated string literals than the
     standard-compliant single quote syntax.  It is particularly useful when
     representing string constants inside other constants, as is often needed
     in procedural function definitions.  With single-quote syntax, each
     backslash in the above example would have to be written as four
     backslashes, which would be reduced to two backslashes in parsing the
     original string constant, and then to one when the inner string constant
     is re-parsed during function execution.
    </para>
________________________________________________________-->
    <para>
     美元引用不是 SQL 标准的一部分，但是在书写复杂字符串文字方面，它常常是一种比兼容标准的单引号语法更方便的方法。当要表示的字符串常量位于其他常量中时它特别有用，这种情况常常在过程函数定义中出现。如果用单引号语法，上一个例子中的每个反斜线将必须被写成四个反斜线，这在解析原始字符串常量时会被缩减到两个反斜线，并且接着在函数执行期间重新解析内层字符串常量时变成一个。
    </para>
<!-- pgdoc-cn_end sig_en=9c01d7b6cf69a12f2a84f9cf998ef57c -->
   </sect3>

   <sect3 id="sql-syntax-bit-strings">
<!-- pgdoc-cn_start sig_en=e2c2956dce4614fc493824ac1a4cdb7a sig_cn_org=None source=14.1 
    <title>Bit-String Constants</title>
________________________________________________________-->
    <title>位串常量</title>
<!-- pgdoc-cn_end sig_en=e2c2956dce4614fc493824ac1a4cdb7a -->

<!-- pgdoc-cn_start sig_en=891d9f10663ba700732d9093e37c488e sig_cn_org=None source=14.1 
    <indexterm zone="sql-syntax-bit-strings">
     <primary>bit string</primary>
     <secondary>constant</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="sql-syntax-bit-strings">
     <primary>bit string</primary>
     <secondary>constant</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=891d9f10663ba700732d9093e37c488e -->

<!-- pgdoc-cn_start sig_en=0dfb3d6b265ea5df10731b3332d53d56 sig_cn_org=None source=14.1 
    <para>
     Bit-string constants look like regular string constants with a
     <literal>B</literal> (upper or lower case) immediately before the
     opening quote (no intervening whitespace), e.g.,
     <literal>B'1001'</literal>.  The only characters allowed within
     bit-string constants are <literal>0</literal> and
     <literal>1</literal>.
    </para>
________________________________________________________-->
    <para>
     位串常量看起来像常规字符串常量在开引号之前（中间无空白）加了一个<literal>B</literal>（大写或小写形式），例如<literal>B'1001'</literal>。位串常量中允许的字符只有<literal>0</literal>和<literal>1</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=0dfb3d6b265ea5df10731b3332d53d56 -->

<!-- pgdoc-cn_start sig_en=f67ed6f5e2247b9a3b3e2f9abd6aca16 sig_cn_org=None source=14.1 
    <para>
     Alternatively, bit-string constants can be specified in hexadecimal
     notation, using a leading <literal>X</literal> (upper or lower case),
     e.g., <literal>X'1FF'</literal>.  This notation is equivalent to
     a bit-string constant with four binary digits for each hexadecimal digit.
    </para>
________________________________________________________-->
    <para>
     作为一种选择，位串常量可以用十六进制记号法指定，使用一个前导<literal>X</literal>（大写或小写形式）,例如<literal>X'1FF'</literal>。这种记号法等价于一个用四个二进制位取代每个十六进制位的位串常量。
    </para>
<!-- pgdoc-cn_end sig_en=f67ed6f5e2247b9a3b3e2f9abd6aca16 -->

<!-- pgdoc-cn_start sig_en=898469c8488655238758d1e73121bc6b sig_cn_org=None source=14.1 
    <para>
     Both forms of bit-string constant can be continued
     across lines in the same way as regular string constants.
     Dollar quoting cannot be used in a bit-string constant.
    </para>
________________________________________________________-->
    <para>
     两种形式的位串常量可以以常规字符串常量相同的方式跨行继续。美元引用不能被用在位串常量中。
    </para>
<!-- pgdoc-cn_end sig_en=898469c8488655238758d1e73121bc6b -->
   </sect3>

   <sect3 id="sql-syntax-constants-numeric">
<!-- pgdoc-cn_start sig_en=275849b21d45f6b4d688b1743880f1d6 sig_cn_org=None source=14.1 
    <title>Numeric Constants</title>
________________________________________________________-->
    <title>数字常量</title>
<!-- pgdoc-cn_end sig_en=275849b21d45f6b4d688b1743880f1d6 -->

<!-- pgdoc-cn_start sig_en=2a1645059265b7a6a231bde5be696b1c sig_cn_org=None source=14.1 
    <indexterm>
     <primary>number</primary>
     <secondary>constant</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>number</primary>
     <secondary>constant</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=2a1645059265b7a6a231bde5be696b1c -->

<!-- pgdoc-cn_start sig_en=9b8e5b3bcf12714cbf5e97b93c90e3cd sig_cn_org=None source=14.1 
    <para>
     Numeric constants are accepted in these general forms:
<synopsis>
<replaceable>digits</replaceable>
<replaceable>digits</replaceable>.<optional><replaceable>digits</replaceable></optional><optional>e<optional>+-</optional><replaceable>digits</replaceable></optional>
<optional><replaceable>digits</replaceable></optional>.<replaceable>digits</replaceable><optional>e<optional>+-</optional><replaceable>digits</replaceable></optional>
<replaceable>digits</replaceable>e<optional>+-</optional><replaceable>digits</replaceable>
</synopsis>
     where <replaceable>digits</replaceable> is one or more decimal
     digits (0 through 9).  At least one digit must be before or after the
     decimal point, if one is used.  At least one digit must follow the
     exponent marker (<literal>e</literal>), if one is present.
     There cannot be any spaces or other characters embedded in the
     constant.  Note that any leading plus or minus sign is not actually
     considered part of the constant; it is an operator applied to the
     constant.
    </para>
________________________________________________________-->
    <para>
     在这些一般形式中可以接受数字常量：
<synopsis>
<replaceable>digits</replaceable>
<replaceable>digits</replaceable>.<optional><replaceable>digits</replaceable></optional><optional>e<optional>+-</optional><replaceable>digits</replaceable></optional>
<optional><replaceable>digits</replaceable></optional>.<replaceable>digits</replaceable><optional>e<optional>+-</optional><replaceable>digits</replaceable></optional>
<replaceable>digits</replaceable>e<optional>+-</optional><replaceable>digits</replaceable>
</synopsis>
     其中<replaceable>digits</replaceable>是一个或多个十进制数字（0 到 9）。如果使用了小数点，在小数点前面或后面必须至少有一个数字。如果存在一个指数标记（<literal>e</literal>），在其后必须跟着至少一个数字。在该常量中不能嵌入任何空白或其他字符。注意任何前导的加号或减号并不实际被考虑为常量的一部分，它是一个应用到该常量的操作符。
    </para>
<!-- pgdoc-cn_end sig_en=9b8e5b3bcf12714cbf5e97b93c90e3cd -->

<!-- pgdoc-cn_start sig_en=fd6fcb50031db80828ddcbd4553737ca sig_cn_org=None source=14.1 
    <para>
     These are some examples of valid numeric constants:
<literallayout>
42
3.5
4.
.001
5e2
1.925e-3
</literallayout>
    </para>
________________________________________________________-->
    <para>
     这些是合法数字常量的例子：
<literallayout>
42
3.5
4.
.001
5e2
1.925e-3
</literallayout>
    </para>
<!-- pgdoc-cn_end sig_en=fd6fcb50031db80828ddcbd4553737ca -->

<!-- pgdoc-cn_start sig_en=2cfdafc81f3e1530254a05a1b917ea4f sig_cn_org=None source=14.1 
    <para>
     <indexterm><primary>integer</primary></indexterm>
     <indexterm><primary>bigint</primary></indexterm>
     <indexterm><primary>numeric</primary></indexterm>
     A numeric constant that contains neither a decimal point nor an
     exponent is initially presumed to be type <type>integer</type> if its
     value fits in type <type>integer</type> (32 bits); otherwise it is
     presumed to be type <type>bigint</type> if its
     value fits in type <type>bigint</type> (64 bits); otherwise it is
     taken to be type <type>numeric</type>.  Constants that contain decimal
     points and/or exponents are always initially presumed to be type
     <type>numeric</type>.
    </para>
________________________________________________________-->
    <para>
     <indexterm><primary>integer</primary></indexterm>
     <indexterm><primary>bigint</primary></indexterm>
     <indexterm><primary>numeric</primary></indexterm>
     如果一个不包含小数点和指数的数字常量的值适合类型<type>integer</type>（32 位），它首先被假定为类型<type>integer</type>。否则如果它的值适合类型<type>bigint</type>（64 位），它被假定为类型<type>bigint</type>。再否则它会被取做类型<type>numeric</type>。包含小数点和/或指数的常量总是首先被假定为类型<type>numeric</type>。
    </para>
<!-- pgdoc-cn_end sig_en=2cfdafc81f3e1530254a05a1b917ea4f -->

<!-- pgdoc-cn_start sig_en=11bebfec38007a59eb1ceeac9bd544d7 sig_cn_org=None source=14.1 
    <para>
     The initially assigned data type of a numeric constant is just a
     starting point for the type resolution algorithms.  In most cases
     the constant will be automatically coerced to the most
     appropriate type depending on context.  When necessary, you can
     force a numeric value to be interpreted as a specific data type
     by casting it.<indexterm><primary>type cast</primary></indexterm>
     For example, you can force a numeric value to be treated as type
     <type>real</type> (<type>float4</type>) by writing:

<programlisting>
REAL '1.23'  -&minus; string style
1.23::REAL   -&minus; PostgreSQL (historical) style
</programlisting>

     These are actually just special cases of the general casting
     notations discussed next.
    </para>
________________________________________________________-->
    <para>
     一个数字常量初始指派的数据类型只是类型转换算法的一个开始点。在大部分情况中，常量将被根据上下文自动被强制到最合适的类型。必要时，你可以通过造型它来强制一个数字值被解释为一种指定数据类型。<indexterm><primary>type cast</primary></indexterm>例如，你可以这样强制一个数字值被当做类型<type>real</type>（<type>float4</type>）：

<programlisting>
REAL '1.23'  -- string style
1.23::REAL   -- PostgreSQL (historical) style
</programlisting>

     这些实际上只是接下来要讨论的一般造型记号的特例。
    </para>
<!-- pgdoc-cn_end sig_en=11bebfec38007a59eb1ceeac9bd544d7 -->
   </sect3>

   <sect3 id="sql-syntax-constants-generic">
<!-- pgdoc-cn_start sig_en=9f629fee0a16966e7c983abfc097a5df sig_cn_org=None source=14.1 
    <title>Constants of Other Types</title>
________________________________________________________-->
    <title>其他类型的常量</title>
<!-- pgdoc-cn_end sig_en=9f629fee0a16966e7c983abfc097a5df -->

<!-- pgdoc-cn_start sig_en=fe4379c69054a74d928ea26afa36a276 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>data type</primary>
     <secondary>constant</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>data type</primary>
     <secondary>constant</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=fe4379c69054a74d928ea26afa36a276 -->

<!-- pgdoc-cn_start sig_en=84a7f47a91acc9679d23763fd5f83d32 sig_cn_org=None source=14.1 
    <para>
     A constant of an <emphasis>arbitrary</emphasis> type can be
     entered using any one of the following notations:
<synopsis>
<replaceable>type</replaceable> '<replaceable>string</replaceable>'
'<replaceable>string</replaceable>'::<replaceable>type</replaceable>
CAST ( '<replaceable>string</replaceable>' AS <replaceable>type</replaceable> )
</synopsis>
     The string constant's text is passed to the input conversion
     routine for the type called <replaceable>type</replaceable>. The
     result is a constant of the indicated type.  The explicit type
     cast can be omitted if there is no ambiguity as to the type the
     constant must be (for example, when it is assigned directly to a
     table column), in which case it is automatically coerced.
    </para>
________________________________________________________-->
    <para>
      一种<emphasis>任意</emphasis>类型的一个常量可以使用下列记号中的任意一种输入：
<synopsis>
<replaceable>type</replaceable> '<replaceable>string</replaceable>'
'<replaceable>string</replaceable>'::<replaceable>type</replaceable>
CAST ( '<replaceable>string</replaceable>' AS <replaceable>type</replaceable> )
</synopsis>
     字符串常量的文本被传递到名为<replaceable>type</replaceable>的类型的输入转换例程中。其结果是指定类型的一个常量。如果对该常量的类型没有歧义（例如，当它被直接指派给一个表列时），显式类型造型可以被忽略，在那种情况下它会被自动强制。
    </para>
<!-- pgdoc-cn_end sig_en=84a7f47a91acc9679d23763fd5f83d32 -->

<!-- pgdoc-cn_start sig_en=9cf035ef932a1dad2a215f8b56267acf sig_cn_org=None source=14.1 
    <para>
     The string constant can be written using either regular SQL
     notation or dollar-quoting.
    </para>
________________________________________________________-->
    <para>
     字符串常量可以使用常规 SQL 记号或美元引用书写。
    </para>
<!-- pgdoc-cn_end sig_en=9cf035ef932a1dad2a215f8b56267acf -->

<!-- pgdoc-cn_start sig_en=53642b754275a0c7d7967d2244874b69 sig_cn_org=None source=14.1 
    <para>
     It is also possible to specify a type coercion using a function-like
     syntax:
<synopsis>
<replaceable>typename</replaceable> ( '<replaceable>string</replaceable>' )
</synopsis>
     but not all type names can be used in this way; see <xref
     linkend="sql-syntax-type-casts"/> for details.
    </para>
________________________________________________________-->
    <para>
     也可以使用一个类似函数的语法来指定一个类型强制：
<synopsis>
<replaceable>typename</replaceable> ( '<replaceable>string</replaceable>' )
</synopsis>
     但是并非所有类型名都可以用在这种方法中，详见<xref linkend="sql-syntax-type-casts"/>。
    </para>
<!-- pgdoc-cn_end sig_en=53642b754275a0c7d7967d2244874b69 -->

<!-- pgdoc-cn_start sig_en=302f810db0154c15b8d1db7b99f390fa sig_cn_org=None source=14.1 
    <para>
     The <literal>::</literal>, <literal>CAST()</literal>, and
     function-call syntaxes can also be used to specify run-time type
     conversions of arbitrary expressions, as discussed in <xref
     linkend="sql-syntax-type-casts"/>.  To avoid syntactic ambiguity, the
     <literal><replaceable>type</replaceable> '<replaceable>string</replaceable>'</literal>
     syntax can only be used to specify the type of a simple literal constant.
     Another restriction on the
     <literal><replaceable>type</replaceable> '<replaceable>string</replaceable>'</literal>
     syntax is that it does not work for array types; use <literal>::</literal>
     or <literal>CAST()</literal> to specify the type of an array constant.
    </para>
________________________________________________________-->
    <para>
     如<xref linkend="sql-syntax-type-casts"/>中讨论的，<literal>::</literal>、<literal>CAST()</literal>以及函数调用语法也可以被用来指定任意表达式的运行时类型转换。要避免语法歧义，<literal><replaceable>type</replaceable> '<replaceable>string</replaceable>'</literal>语法只能被用来指定简单文字常量的类型。<literal><replaceable>type</replaceable> '<replaceable>string</replaceable>'</literal>语法上的另一个限制是它无法对数组类型工作，指定一个数组常量的类型可使用<literal>::</literal>或<literal>CAST()</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=302f810db0154c15b8d1db7b99f390fa -->

<!-- pgdoc-cn_start sig_en=fcac56330b14104d000047c61dc4d0c5 sig_cn_org=None source=14.1 
    <para>
     The <literal>CAST()</literal> syntax conforms to SQL.  The
     <literal><replaceable>type</replaceable> '<replaceable>string</replaceable>'</literal>
     syntax is a generalization of the standard: SQL specifies this syntax only
     for a few data types, but <productname>PostgreSQL</productname> allows it
     for all types.  The syntax with
     <literal>::</literal> is historical <productname>PostgreSQL</productname>
     usage, as is the function-call syntax.
    </para>
________________________________________________________-->
    <para>
     <literal>CAST()</literal>语法符合 SQL。<literal><replaceable>type</replaceable> '<replaceable>string</replaceable>'</literal>语法是该标准的一般化：SQL 指定这种语法只用于一些数据类型，但是<productname>PostgreSQL</productname>允许它用于所有类型。带有<literal>::</literal>的语法是<productname>PostgreSQL</productname>的历史用法，就像函数调用语法一样。
    </para>
<!-- pgdoc-cn_end sig_en=fcac56330b14104d000047c61dc4d0c5 -->
   </sect3>
  </sect2>

  <sect2 id="sql-syntax-operators">
<!-- pgdoc-cn_start sig_en=5cc1df9101362b5f55ab8c0b6ad1c736 sig_cn_org=None source=14.1 
   <title>Operators</title>
________________________________________________________-->
   <title>操作符</title>
<!-- pgdoc-cn_end sig_en=5cc1df9101362b5f55ab8c0b6ad1c736 -->

<!-- pgdoc-cn_start sig_en=d1d01508ab715eb0ffa00f24b6743c91 sig_cn_org=None source=14.1 
   <indexterm zone="sql-syntax-operators">
    <primary>operator</primary>
    <secondary>syntax</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="sql-syntax-operators">
    <primary>operator</primary>
    <secondary>syntax</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=d1d01508ab715eb0ffa00f24b6743c91 -->

<!-- pgdoc-cn_start sig_en=eb1b6a0714b66e3ca6426f3c1e985fca sig_cn_org=None source=14.1 
   <para>
    An operator name is a sequence of up to <symbol>NAMEDATALEN</symbol>-1
    (63 by default) characters from the following list:
<literallayout>
+ - * / &lt; &gt; = ~ ! @ # % ^ &amp; | ` ?
</literallayout>

    There are a few restrictions on operator names, however:
    <itemizedlist>
     <listitem>
      <para>
       <literal>-&minus;</literal> and <literal>/*</literal> cannot appear
       anywhere in an operator name, since they will be taken as the
       start of a comment.
      </para>
     </listitem>

     <listitem>
      <para>
       A multiple-character operator name cannot end in <literal>+</literal> or <literal>-</literal>,
       unless the name also contains at least one of these characters:
<literallayout>
~ ! @ # % ^ &amp; | ` ?
</literallayout>
       For example, <literal>@-</literal> is an allowed operator name,
       but <literal>*-</literal> is not.  This restriction allows
       <productname>PostgreSQL</productname> to parse SQL-compliant
       queries without requiring spaces between tokens.
      </para>
     </listitem>
    </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    一个操作符名是最多<symbol>NAMEDATALEN</symbol>-1（默认为 63）的一个字符序列，其中的字符来自下面的列表：
<literallayout>
+ - * / &lt; &gt; = ~ ! @ # % ^ &amp; | ` ?
</literallayout>

    不过，在操作符名上有一些限制：
    <itemizedlist>
     <listitem>
      <para>
       <literal>--</literal> and <literal>/*</literal>不能在一个操作符名的任何地方出现，因为它们将被作为一段注释的开始。
      </para>
     </listitem>

     <listitem>
      <para>
       一个多字符操作符名不能以<literal>+</literal>或<literal>-</literal>结尾，除非该名称也至少包含这些字符中的一个：
<literallayout>
~ ! @ # % ^ &amp; | ` ?
</literallayout>
       例如，<literal>@-</literal>是一个被允许的操作符名，但<literal>*-</literal>不是。这些限制允许<productname>PostgreSQL</productname>解析 SQL 兼容的查询而不需要在记号之间有空格。
      </para>
     </listitem>
    </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=eb1b6a0714b66e3ca6426f3c1e985fca -->

<!-- pgdoc-cn_start sig_en=8b745eb51af74fdd68febdd6cc32eedc sig_cn_org=None source=14.1 
   <para>
    When working with non-SQL-standard operator names, you will usually
    need to separate adjacent operators with spaces to avoid ambiguity.
    For example, if you have defined a prefix operator named <literal>@</literal>,
    you cannot write <literal>X*@Y</literal>; you must write
    <literal>X* @Y</literal> to ensure that
    <productname>PostgreSQL</productname> reads it as two operator names
    not one.
   </para>
________________________________________________________-->
   <para>
    当使用非 SQL 标准的操作符名时，你通常需要用空格分隔相邻的操作符来避免歧义。例如，如果你定义了一个名为<literal>@</literal>的前缀操作符，你不能写<literal>X*@Y</literal>，你必须写<literal>X* @Y</literal>来确保<productname>PostgreSQL</productname>把它读作两个操作符名而不是一个。
   </para>
<!-- pgdoc-cn_end sig_en=8b745eb51af74fdd68febdd6cc32eedc -->
  </sect2>

  <sect2 id="sql-syntax-special-chars">
<!-- pgdoc-cn_start sig_en=622a1f005516364ec09e488a514bc19c sig_cn_org=None source=14.1 
   <title>Special Characters</title>
________________________________________________________-->
   <title>特殊字符</title>
<!-- pgdoc-cn_end sig_en=622a1f005516364ec09e488a514bc19c -->

<!-- pgdoc-cn_start sig_en=e271c8030b17fbceba6b2670cc09831b sig_cn_org=None source=14.1 
  <para>
   Some characters that are not alphanumeric have a special meaning
   that is different from being an operator.  Details on the usage can
   be found at the location where the respective syntax element is
   described.  This section only exists to advise the existence and
   summarize the purposes of these characters.

   <itemizedlist>
    <listitem>
     <para>
      A dollar sign (<literal>$</literal>) followed by digits is used
      to represent a positional parameter in the body of a function
      definition or a prepared statement.  In other contexts the
      dollar sign can be part of an identifier or a dollar-quoted string
      constant.
     </para>
    </listitem>

    <listitem>
     <para>
      Parentheses (<literal>()</literal>) have their usual meaning to
      group expressions and enforce precedence.  In some cases
      parentheses are required as part of the fixed syntax of a
      particular SQL command.
     </para>
    </listitem>

    <listitem>
     <para>
      Brackets (<literal>[]</literal>) are used to select the elements
      of an array.  See <xref linkend="arrays"/> for more information
      on arrays.
     </para>
    </listitem>

    <listitem>
     <para>
      Commas (<literal>,</literal>) are used in some syntactical
      constructs to separate the elements of a list.
     </para>
    </listitem>

    <listitem>
     <para>
      The semicolon (<literal>;</literal>) terminates an SQL command.
      It cannot appear anywhere within a command, except within a
      string constant or quoted identifier.
     </para>
    </listitem>

    <listitem>
     <para>
      The colon (<literal>:</literal>) is used to select
      <quote>slices</quote> from arrays. (See <xref
      linkend="arrays"/>.)  In certain SQL dialects (such as Embedded
      SQL), the colon is used to prefix variable names.
     </para>
    </listitem>

    <listitem>
     <para>
      The asterisk (<literal>*</literal>) is used in some contexts to denote
      all the fields of a table row or composite value.  It also
      has a special meaning when used as the argument of an
      aggregate function, namely that the aggregate does not require
      any explicit parameter.
     </para>
    </listitem>

    <listitem>
     <para>
      The period (<literal>.</literal>) is used in numeric
      constants, and to separate schema, table, and column names.
     </para>
    </listitem>
   </itemizedlist>

   </para>
________________________________________________________-->
  <para>
   一些不是数字字母的字符有一种不同于作为操作符的特殊含义。这些字符的详细用法可以在描述相应语法元素的地方找到。这一节只是为了告知它们的存在以及总结这些字符的目的。

   <itemizedlist>
    <listitem>
     <para>
      跟随在一个美元符号（<literal>$</literal>）后面的数字被用来表示在一个函数定义或一个预备语句中的位置参数。在其他上下文中该美元符号可以作为一个标识符或者一个美元引用字符串常量的一部分。
     </para>
    </listitem>

    <listitem>
     <para>
      圆括号（<literal>()</literal>）具有它们通常的含义，用来分组表达式并且强制优先。在某些情况中，圆括号被要求作为一个特定 SQL 命令的固定语法的一部分。
     </para>
    </listitem>

    <listitem>
     <para>
      方括号（<literal>[]</literal>）被用来选择一个数组中的元素。更多关于数组的信息见<xref linkend="arrays"/>。
     </para>
    </listitem>

    <listitem>
     <para>
      逗号（<literal>,</literal>）被用在某些语法结构中来分割一个列表的元素。
     </para>
    </listitem>

    <listitem>
     <para>
      分号（<literal>;</literal>）结束一个 SQL 命令。它不能出现在一个命令中间的任何位置，除了在一个字符串常量中或者一个被引用的标识符中。
     </para>
    </listitem>

    <listitem>
     <para>
      冒号（<literal>:</literal>）被用来从数组中选择<quote>切片</quote>（见<xref linkend="arrays"/>）。在某些 SQL 的“方言”（例如嵌入式 SQL）中，冒号被用来作为变量名的前缀。
     </para>
    </listitem>

    <listitem>
     <para>
      星号（<literal>*</literal>）被用在某些上下文中标记一个表的所有域或者组合值。当它被用作一个聚集函数的参数时，它还有一种特殊的含义，即该聚集不要求任何显式参数。
     </para>
    </listitem>

    <listitem>
     <para>
      句点（<literal>.</literal>）被用在数字常量中，并且被用来分割模式、表和列名。
     </para>
    </listitem>
   </itemizedlist>

   </para>
<!-- pgdoc-cn_end sig_en=e271c8030b17fbceba6b2670cc09831b -->
  </sect2>

  <sect2 id="sql-syntax-comments">
<!-- pgdoc-cn_start sig_en=a176c509a3546bfe53242c355f3284fb sig_cn_org=None source=14.1 
   <title>Comments</title>
________________________________________________________-->
   <title>注释</title>
<!-- pgdoc-cn_end sig_en=a176c509a3546bfe53242c355f3284fb -->

<!-- pgdoc-cn_start sig_en=d71c0638bdb7ef0d6581abdc59967a43 sig_cn_org=None source=14.1 
   <indexterm zone="sql-syntax-comments">
    <primary>comment</primary>
    <secondary sortas="SQL">in SQL</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="sql-syntax-comments">
    <primary>comment</primary>
    <secondary sortas="SQL">in SQL</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=d71c0638bdb7ef0d6581abdc59967a43 -->

<!-- pgdoc-cn_start sig_en=7ecbfecd28759f6e24b8c9373e791787 sig_cn_org=None source=14.1 
   <para>
    A comment is a sequence of characters beginning with
    double dashes and extending to the end of the line, e.g.:
<programlisting>
-&minus; This is a standard SQL comment
</programlisting>
   </para>
________________________________________________________-->
   <para>
    一段注释是以双横杠开始并且延伸到行结尾的一个字符序列，例如：
<programlisting>
-- This is a standard SQL comment
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=7ecbfecd28759f6e24b8c9373e791787 -->

<!-- pgdoc-cn_start sig_en=0b5fc8423582054d7c8bad693a8abf64 sig_cn_org=None source=14.1 
   <para>
    Alternatively, C-style block comments can be used:
<programlisting>
/* multiline comment
 * with nesting: /* nested block comment */
 */
</programlisting>
    where the comment begins with <literal>/*</literal> and extends to
    the matching occurrence of <literal>*/</literal>. These block
    comments nest, as specified in the SQL standard but unlike C, so that one can
    comment out larger blocks of code that might contain existing block
    comments.
   </para>
________________________________________________________-->
   <para>
    另外，也可以使用 C 风格注释块：
<programlisting>
/* multiline comment
 * with nesting: /* nested block comment */
 */
</programlisting>
    这里该注释开始于<literal>/*</literal>并且延伸到匹配出现的<literal>*/</literal>。这些注释块可按照 SQL 标准中指定的方式嵌套，但和 C 中不同。这样我们可以注释掉一大段可能包含注释块的代码。
   </para>
<!-- pgdoc-cn_end sig_en=0b5fc8423582054d7c8bad693a8abf64 -->

<!-- pgdoc-cn_start sig_en=1a0de686303cc84876509d8f184ba183 sig_cn_org=None source=14.1 
   <para>
    A comment is removed from the input stream before further syntax
    analysis and is effectively replaced by whitespace.
   </para>
________________________________________________________-->
   <para>
    在进一步的语法分析前，注释会被从输入流中被移除并且实际被替换为空白。
   </para>
<!-- pgdoc-cn_end sig_en=1a0de686303cc84876509d8f184ba183 -->
  </sect2>

  <sect2 id="sql-precedence">
<!-- pgdoc-cn_start sig_en=2b4a217ac025542af3223945b060cdd3 sig_cn_org=None source=14.1 
   <title>Operator Precedence</title>
________________________________________________________-->
   <title>操作符优先级</title>
<!-- pgdoc-cn_end sig_en=2b4a217ac025542af3223945b060cdd3 -->

<!-- pgdoc-cn_start sig_en=322a6016ad186b5ab8766a42146682be sig_cn_org=None source=14.1 
   <indexterm zone="sql-precedence">
    <primary>operator</primary>
    <secondary>precedence</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="sql-precedence">
    <primary>operator</primary>
    <secondary>precedence</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=322a6016ad186b5ab8766a42146682be -->

<!-- pgdoc-cn_start sig_en=a28d24e638593ad1ed7eeccddb70f4b4 sig_cn_org=None source=14.1 
   <para>
    <xref linkend="sql-precedence-table"/> shows the precedence and
    associativity of the operators in <productname>PostgreSQL</productname>.
    Most operators have the same precedence and are left-associative.
    The precedence and associativity of the operators is hard-wired
    into the parser.
    Add parentheses if you want an expression with multiple operators
    to be parsed in some other way than what the precedence rules imply.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="sql-precedence-table"/>显示了<productname>PostgreSQL</productname>中操作符的优先级和结合性。大部分操作符具有相同的优先并且是左结合的。操作符的优先级和结合性被硬写在解析器中。
    如果您希望以不同于优先级规则所暗示的方式解析具有多个运算符的表达式，请添加括号。
</para>
<!-- pgdoc-cn_end sig_en=a28d24e638593ad1ed7eeccddb70f4b4 -->

   <table id="sql-precedence-table">
<!-- pgdoc-cn_start sig_en=661ae48910017c03cf206b5328c73193 sig_cn_org=None source=14.1 
    <title>Operator Precedence (highest to lowest)</title>
________________________________________________________-->
    <title>操作符优先级（从高到低）</title>
<!-- pgdoc-cn_end sig_en=661ae48910017c03cf206b5328c73193 -->

    <tgroup cols="3">
     <colspec colname="col1" colwidth="2*"/>
     <colspec colname="col2" colwidth="1*"/>
     <colspec colname="col3" colwidth="2*"/>
     <thead>
<!-- pgdoc-cn_start sig_en=47395123180b693bbf3ae07f6e8aabf8 sig_cn_org=None source=14.1 
      <row>
       <entry>Operator/Element</entry>
       <entry>Associativity</entry>
       <entry>Description</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>操作符/元素</entry>
       <entry>结合性</entry>
       <entry>描述</entry>
      </row>
<!-- pgdoc-cn_end sig_en=47395123180b693bbf3ae07f6e8aabf8 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=fcaed0068ab9e44457ef3d6cb4b633d3 sig_cn_org=None source=14.1 
      <row>
       <entry><token>.</token></entry>
       <entry>left</entry>
       <entry>table/column name separator</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><token>.</token></entry>
       <entry>左</entry>
       <entry>表/列名分隔符</entry>
      </row>
<!-- pgdoc-cn_end sig_en=fcaed0068ab9e44457ef3d6cb4b633d3 -->

<!-- pgdoc-cn_start sig_en=11f2ac49141e7bc506c6b379d6255b77 sig_cn_org=None source=14.1 
      <row>
       <entry><token>::</token></entry>
       <entry>left</entry>
       <entry><productname>PostgreSQL</productname>-style typecast</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><token>::</token></entry>
       <entry>左</entry>
       <entry><productname>PostgreSQL</productname>-风格的类型转换</entry>
      </row>
<!-- pgdoc-cn_end sig_en=11f2ac49141e7bc506c6b379d6255b77 -->

<!-- pgdoc-cn_start sig_en=c9fc3c656247d2b717d6cb1d407ea811 sig_cn_org=None source=14.1 
      <row>
       <entry><token>[</token> <token>]</token></entry>
       <entry>left</entry>
       <entry>array element selection</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><token>[</token> <token>]</token></entry>
       <entry>左</entry>
       <entry>数组元素选择</entry>
      </row>
<!-- pgdoc-cn_end sig_en=c9fc3c656247d2b717d6cb1d407ea811 -->

<!-- pgdoc-cn_start sig_en=83df65c393e1d6ed829e08c9b59a7379 sig_cn_org=None source=14.1 
      <row>
       <entry><token>+</token> <token>-</token></entry>
       <entry>right</entry>
       <entry>unary plus, unary minus</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><token>+</token> <token>-</token></entry>
       <entry>右</entry>
       <entry>一元加、一元减</entry>
      </row>
<!-- pgdoc-cn_end sig_en=83df65c393e1d6ed829e08c9b59a7379 -->

<!-- pgdoc-cn_start sig_en=dfcc2201f1cfb9968fab0e568b8fd12f sig_cn_org=a0c555070da2406c113f0282d419cf9a source=15.7 
      <row>
       <entry><token>COLLATE</token></entry>
       <entry>left</entry>
       <entry>collation selection</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><token>COLLATE</token></entry>
       <entry>左</entry>
       <entry>排序选择</entry>
      </row>
<!-- pgdoc-cn_end sig_en=dfcc2201f1cfb9968fab0e568b8fd12f -->

<!-- pgdoc-cn_start sig_en=293e8ead5be452b5f35a818b7fd6a312 sig_cn_org=a4d95b4359cdc93da0d64dbbfa3b9431 source=15.7 
      <row>
       <entry><token>AT</token></entry>
       <entry>left</entry>
       <entry><literal>AT TIME ZONE</literal></entry>
      </row>
________________________________________________________-->
      <row>
       <entry><token>AT</token></entry>
       <entry>左</entry>
       <entry><literal>AT TIME ZONE</literal></entry>
      </row>
<!-- pgdoc-cn_end sig_en=293e8ead5be452b5f35a818b7fd6a312 -->

<!-- pgdoc-cn_start sig_en=a6e15b5688a8f93411bfaaf5d98bd202 sig_cn_org=None source=14.1 
      <row>
       <entry><token>^</token></entry>
       <entry>left</entry>
       <entry>exponentiation</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><token>^</token></entry>
       <entry>左</entry>
       <entry>指数</entry>
      </row>
<!-- pgdoc-cn_end sig_en=a6e15b5688a8f93411bfaaf5d98bd202 -->

<!-- pgdoc-cn_start sig_en=df8da6157ed916f1c00e4c261d2a8e54 sig_cn_org=None source=14.1 
      <row>
       <entry><token>*</token> <token>/</token> <token>%</token></entry>
       <entry>left</entry>
       <entry>multiplication, division, modulo</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><token>*</token> <token>/</token> <token>%</token></entry>
       <entry>左</entry>
       <entry>乘、除、模</entry>
      </row>
<!-- pgdoc-cn_end sig_en=df8da6157ed916f1c00e4c261d2a8e54 -->

<!-- pgdoc-cn_start sig_en=a2599aefea2f386c18df1695a9f344aa sig_cn_org=None source=14.1 
      <row>
       <entry><token>+</token> <token>-</token></entry>
       <entry>left</entry>
       <entry>addition, subtraction</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><token>+</token> <token>-</token></entry>
       <entry>左</entry>
       <entry>加、减</entry>
      </row>
<!-- pgdoc-cn_end sig_en=a2599aefea2f386c18df1695a9f344aa -->

<!-- pgdoc-cn_start sig_en=cd35f3f1869da65f30173b3358db7c08 sig_cn_org=None source=14.1 
      <row>
       <entry>(any other operator)</entry>
       <entry>left</entry>
       <entry>all other native and user-defined operators</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>（任意其他操作符）</entry>
       <entry>左</entry>
       <entry>所有其他本地以及用户定义的操作符</entry>
      </row>
<!-- pgdoc-cn_end sig_en=cd35f3f1869da65f30173b3358db7c08 -->

<!-- pgdoc-cn_start sig_en=dbf3743c1ee682b856399d1f2ed2568c sig_cn_org=None source=14.1 
      <row>
       <entry><token>BETWEEN</token> <token>IN</token> <token>LIKE</token> <token>ILIKE</token> <token>SIMILAR</token></entry>
       <entry></entry>
       <entry>range containment, set membership, string matching</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><token>BETWEEN</token> <token>IN</token> <token>LIKE</token> <token>ILIKE</token> <token>SIMILAR</token></entry>
       <entry></entry>
       <entry>范围包含、集合成员关系、字符串匹配</entry>
      </row>
<!-- pgdoc-cn_end sig_en=dbf3743c1ee682b856399d1f2ed2568c -->

<!-- pgdoc-cn_start sig_en=870725860656a26d46238c58c92c51e8 sig_cn_org=None source=14.1 
      <row>
       <entry><token>&lt;</token> <token>&gt;</token> <token>=</token> <token>&lt;=</token> <token>&gt;=</token> <token>&lt;&gt;</token>
</entry>
       <entry></entry>
       <entry>comparison operators</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><token>&lt;</token> <token>&gt;</token> <token>=</token> <token>&lt;=</token> <token>&gt;=</token> <token>&lt;&gt;</token>
</entry>
       <entry></entry>
       <entry>比较操作符</entry>
      </row>
<!-- pgdoc-cn_end sig_en=870725860656a26d46238c58c92c51e8 -->

<!-- pgdoc-cn_start sig_en=16756e90b74f8f70ceb9876248576787 sig_cn_org=ba6afa4e725011e1fe10d9e2cda2785a source=15.7 
      <row>
       <entry><token>IS</token> <token>ISNULL</token> <token>NOTNULL</token></entry>
       <entry></entry>
       <entry><literal>IS TRUE</literal>, <literal>IS FALSE</literal>, <literal>IS
       NULL</literal>, <literal>IS DISTINCT FROM</literal>, etc.</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><token>IS</token> <token>ISNULL</token> <token>NOTNULL</token></entry>
       <entry></entry>
       <entry><literal>IS TRUE</literal>, <literal>IS FALSE</literal>, <literal>IS
       NULL</literal>, <literal>IS DISTINCT FROM</literal>, 等。</entry>
      </row>
<!-- pgdoc-cn_end sig_en=16756e90b74f8f70ceb9876248576787 -->

<!-- pgdoc-cn_start sig_en=1d10596a69ff7ab57fde61a25c879a95 sig_cn_org=None source=14.1 
      <row>
       <entry><token>NOT</token></entry>
       <entry>right</entry>
       <entry>logical negation</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><token>NOT</token></entry>
       <entry>右</entry>
       <entry>逻辑否定</entry>
      </row>
<!-- pgdoc-cn_end sig_en=1d10596a69ff7ab57fde61a25c879a95 -->

<!-- pgdoc-cn_start sig_en=ed84ff27db913d3cca67fb1eab369817 sig_cn_org=None source=14.1 
      <row>
       <entry><token>AND</token></entry>
       <entry>left</entry>
       <entry>logical conjunction</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><token>AND</token></entry>
       <entry>左</entry>
       <entry>逻辑合取</entry>
      </row>
<!-- pgdoc-cn_end sig_en=ed84ff27db913d3cca67fb1eab369817 -->

<!-- pgdoc-cn_start sig_en=6f1f104b6cbda937111a5ff293fc3d29 sig_cn_org=None source=14.1 
      <row>
       <entry><token>OR</token></entry>
       <entry>left</entry>
       <entry>logical disjunction</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><token>OR</token></entry>
       <entry>左</entry>
       <entry>逻辑析取</entry>
      </row>
<!-- pgdoc-cn_end sig_en=6f1f104b6cbda937111a5ff293fc3d29 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=f86d041a344ea74bb2f19d2d003dd927 sig_cn_org=None source=14.1 
   <para>
    Note that the operator precedence rules also apply to user-defined
    operators that have the same names as the built-in operators
    mentioned above.  For example, if you define a
    <quote>+</quote> operator for some custom data type it will have
    the same precedence as the built-in <quote>+</quote> operator, no
    matter what yours does.
   </para>
________________________________________________________-->
   <para>
    注意该操作符有限规则也适用于与上述内建操作符具有相同名称的用户定义的操作符。例如，如果你为某种自定义数据类型定义了一个<quote>+</quote>操作符，它将具有和内建的<quote>+</quote>操作符相同的优先级，不管你的操作符要做什么。
   </para>
<!-- pgdoc-cn_end sig_en=f86d041a344ea74bb2f19d2d003dd927 -->

<!-- pgdoc-cn_start sig_en=cd834c95b37b9a90b2f1dacfd8e2be4b sig_cn_org=None source=14.1 
   <para>
    When a schema-qualified operator name is used in the
    <literal>OPERATOR</literal> syntax, as for example in:
<programlisting>
SELECT 3 OPERATOR(pg_catalog.+) 4;
</programlisting>
    the <literal>OPERATOR</literal> construct is taken to have the default precedence
    shown in <xref linkend="sql-precedence-table"/> for
    <quote>any other operator</quote>.  This is true no matter
    which specific operator appears inside <literal>OPERATOR()</literal>.
   </para>
________________________________________________________-->
   <para>
    当一个模式限定的操作符名被用在<literal>OPERATOR</literal>语法中时，如下面的例子：
<programlisting>
SELECT 3 OPERATOR(pg_catalog.+) 4;
</programlisting>
    <literal>OPERATOR</literal>结构被用来为<quote>任意其他操作符</quote>获得<xref linkend="sql-precedence-table"/>中默认的优先级。不管出现在<literal>OPERATOR()</literal>中的是哪个指定操作符，这都是真的。
   </para>
<!-- pgdoc-cn_end sig_en=cd834c95b37b9a90b2f1dacfd8e2be4b -->

   <note>
<!-- pgdoc-cn_start sig_en=96e42039d9bb4fe310aa51c20ca9861a sig_cn_org=None source=14.1 
    <para>
     <productname>PostgreSQL</productname> versions before 9.5 used slightly different
     operator precedence rules.  In particular, <token>&lt;=</token>
     <token>&gt;=</token> and <token>&lt;&gt;</token> used to be treated as
     generic operators; <literal>IS</literal> tests used to have higher priority;
     and <literal>NOT BETWEEN</literal> and related constructs acted inconsistently,
     being taken in some cases as having the precedence of <literal>NOT</literal>
     rather than <literal>BETWEEN</literal>.  These rules were changed for better
     compliance with the SQL standard and to reduce confusion from
     inconsistent treatment of logically equivalent constructs.  In most
     cases, these changes will result in no behavioral change, or perhaps
     in <quote>no such operator</quote> failures which can be resolved by adding
     parentheses.  However there are corner cases in which a query might
     change behavior without any parsing error being reported.
    </para>
________________________________________________________-->
    <para>
     版本 9.5 之前的<productname>PostgreSQL</productname>使用的操作符优先级
     规则略有不同。特别是，<token>&lt;=</token>、<token>&gt;=</token>
     和<token>&lt;&gt;</token>习惯于被当作普通操作符，<literal>IS</literal>
     测试习惯于具有较高的优先级。并且在一些认为<literal>NOT</literal>比
     <literal>BETWEEN</literal>优先级高的情况下，<literal>NOT BETWEEN</literal>
     和相关的结构的行为不一致。为了更好地兼容 SQL 标准并且减少对
     逻辑上等价的结构不一致的处理，这些规则也得到了修改。在大部分情况下，
     这些变化不会导致行为上的变化，或者可能会产生<quote>no such operator</quote>
     错误，但可以通过增加圆括号解决。不过在一些极端情况中，查询可能在
     没有被报告解析错误的情况下发生行为的改变。
    </para>
<!-- pgdoc-cn_end sig_en=96e42039d9bb4fe310aa51c20ca9861a -->
   </note>
  </sect2>
 </sect1>

 <sect1 id="sql-expressions">
<!-- pgdoc-cn_start sig_en=c2f27ea3d7af6d646b9b985ad01f98c0 sig_cn_org=None source=14.1 
  <title>Value Expressions</title>
________________________________________________________-->
  <title>值表达式</title>
<!-- pgdoc-cn_end sig_en=c2f27ea3d7af6d646b9b985ad01f98c0 -->

<!-- pgdoc-cn_start sig_en=e1ae0f3211658ab2e74f0a0256e4e4e4 sig_cn_org=None source=14.1 
  <indexterm zone="sql-expressions">
   <primary>expression</primary>
   <secondary>syntax</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="sql-expressions">
   <primary>表达式</primary>
   <secondary>语法</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=e1ae0f3211658ab2e74f0a0256e4e4e4 -->

<!-- pgdoc-cn_start sig_en=fc64a8968621596eb1a440cf1f22e944 sig_cn_org=None source=14.1 
  <indexterm zone="sql-expressions">
   <primary>value expression</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="sql-expressions">
   <primary>值表达式</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=fc64a8968621596eb1a440cf1f22e944 -->

<!-- pgdoc-cn_start sig_en=3ba177022561003987b7a384d8f66d7a sig_cn_org=None source=14.1 
  <indexterm>
   <primary>scalar</primary>
   <see>expression</see>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>标量</primary>
   <see>表达式</see>
  </indexterm>
<!-- pgdoc-cn_end sig_en=3ba177022561003987b7a384d8f66d7a -->

<!-- pgdoc-cn_start sig_en=1130e6d2d87704456c55536102807e9b sig_cn_org=None source=14.1 
  <para>
   Value expressions are used in a variety of contexts, such
   as in the target list of the <command>SELECT</command> command, as
   new column values in <command>INSERT</command> or
   <command>UPDATE</command>, or in search conditions in a number of
   commands.  The result of a value expression is sometimes called a
   <firstterm>scalar</firstterm>, to distinguish it from the result of
   a table expression (which is a table).  Value expressions are
   therefore also called <firstterm>scalar expressions</firstterm> (or
   even simply <firstterm>expressions</firstterm>).  The expression
   syntax allows the calculation of values from primitive parts using
   arithmetic, logical, set, and other operations.
  </para>
________________________________________________________-->
  <para>
   值表达式被用于各种各样的环境中，例如在<command>SELECT</command>命令的目标列表中、作为<command>INSERT</command>或<command>UPDATE</command>中的新列值或者若干命令中的搜索条件。为了区别于一个表表达式（是一个表）的结果，一个值表达式的结果有时候被称为一个<firstterm>标量</firstterm>。值表达式因此也被称为<firstterm>标量表达式</firstterm>（或者甚至简称为<firstterm>表达式</firstterm>）。表达式语法允许使用算数、逻辑、集合和其他操作从原始部分计算值。
  </para>
<!-- pgdoc-cn_end sig_en=1130e6d2d87704456c55536102807e9b -->

<!-- pgdoc-cn_start sig_en=845c1e5612e0ebeb4e7ad77e5c4df749 sig_cn_org=None source=14.1 
  <para>
   A value expression is one of the following:

   <itemizedlist>
    <listitem>
     <para>
      A constant or literal value
     </para>
    </listitem>

    <listitem>
     <para>
      A column reference
     </para>
    </listitem>

    <listitem>
     <para>
      A positional parameter reference, in the body of a function definition
      or prepared statement
     </para>
    </listitem>

    <listitem>
     <para>
      A subscripted expression
     </para>
    </listitem>

    <listitem>
     <para>
      A field selection expression
     </para>
    </listitem>

    <listitem>
     <para>
      An operator invocation
     </para>
    </listitem>

    <listitem>
     <para>
      A function call
     </para>
    </listitem>

    <listitem>
     <para>
      An aggregate expression
     </para>
    </listitem>

    <listitem>
     <para>
      A window function call
     </para>
    </listitem>

    <listitem>
     <para>
      A type cast
     </para>
    </listitem>

    <listitem>
     <para>
      A collation expression
     </para>
    </listitem>

    <listitem>
     <para>
      A scalar subquery
     </para>
    </listitem>

    <listitem>
     <para>
      An array constructor
     </para>
    </listitem>

    <listitem>
     <para>
      A row constructor
     </para>
    </listitem>

    <listitem>
     <para>
      Another value expression in parentheses (used to group
      subexpressions and override
      precedence<indexterm><primary>parenthesis</primary></indexterm>)
     </para>
    </listitem>
   </itemizedlist>
  </para>
________________________________________________________-->
  <para>
   一个值表达式是下列之一：

   <itemizedlist>
    <listitem>
     <para>
      一个常量或文字值
     </para>
    </listitem>

    <listitem>
     <para>
      一个列引用
     </para>
    </listitem>

    <listitem>
     <para>
      在一个函数定义体或预备语句中的一个位置参数引用
     </para>
    </listitem>

    <listitem>
     <para>
      一个下标表达式
     </para>
    </listitem>

    <listitem>
     <para>
      一个域选择表达式
     </para>
    </listitem>

    <listitem>
     <para>
      一个操作符调用
     </para>
    </listitem>

    <listitem>
     <para>
      一个函数调用
     </para>
    </listitem>

    <listitem>
     <para>
      一个聚集表达式
     </para>
    </listitem>

    <listitem>
     <para>
      一个窗口函数调用
     </para>
    </listitem>

    <listitem>
     <para>
      一个类型转换
     </para>
    </listitem>

    <listitem>
     <para>
      一个排序规则表达式
     </para>
    </listitem>

    <listitem>
     <para>
      一个标量子查询
     </para>
    </listitem>

    <listitem>
     <para>
      一个数组构造器
     </para>
    </listitem>

    <listitem>
     <para>
      一个行构造器
     </para>
    </listitem>

    <listitem>
     <para>
      另一个在圆括号（用来分组子表达式以及重载优先级<indexterm><primary>圆括号</primary></indexterm>）中的值表达式
     </para>
    </listitem>
   </itemizedlist>
  </para>
<!-- pgdoc-cn_end sig_en=845c1e5612e0ebeb4e7ad77e5c4df749 -->

<!-- pgdoc-cn_start sig_en=961b76a28c0048172d558a361f493158 sig_cn_org=None source=14.1 
  <para>
   In addition to this list, there are a number of constructs that can
   be classified as an expression but do not follow any general syntax
   rules.  These generally have the semantics of a function or
   operator and are explained in the appropriate location in <xref
   linkend="functions"/>.  An example is the <literal>IS NULL</literal>
   clause.
  </para>
________________________________________________________-->
  <para>
   在这个列表之外，还有一些结构可以被分类为一个表达式，但是它们不遵循任何一般语法规则。这些通常具有一个函数或操作符的语义并且在<xref linkend="functions"/>中的合适位置解释。一个例子是<literal>IS NULL</literal>子句。
  </para>
<!-- pgdoc-cn_end sig_en=961b76a28c0048172d558a361f493158 -->

<!-- pgdoc-cn_start sig_en=9a5f878309c5d863da2d0b6888201eec sig_cn_org=None source=14.1 
  <para>
   We have already discussed constants in <xref
   linkend="sql-syntax-constants"/>.  The following sections discuss
   the remaining options.
  </para>
________________________________________________________-->
  <para>
   我们已经在<xref linkend="sql-syntax-constants"/>中讨论过常量。下面的小节会讨论剩下的选项。
  </para>
<!-- pgdoc-cn_end sig_en=9a5f878309c5d863da2d0b6888201eec -->

  <sect2 id="sql-expressions-column-refs">
<!-- pgdoc-cn_start sig_en=be18839eb4d175d1094c3b4cd3598aa9 sig_cn_org=None source=14.1 
   <title>Column References</title>
________________________________________________________-->
   <title>列引用</title>
<!-- pgdoc-cn_end sig_en=be18839eb4d175d1094c3b4cd3598aa9 -->

<!-- pgdoc-cn_start sig_en=a35b33d637fde0aa8fb0ce4fe7ed0c29 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>column reference</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>列引用</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=a35b33d637fde0aa8fb0ce4fe7ed0c29 -->

<!-- pgdoc-cn_start sig_en=76aef8a2edce39f3206b4d3a77525002 sig_cn_org=None source=14.1 
   <para>
    A column can be referenced in the form:
<synopsis>
<replaceable>correlation</replaceable>.<replaceable>columnname</replaceable>
</synopsis>
   </para>
________________________________________________________-->
   <para>
    一个列可以以下面的形式被引用：
<synopsis>
<replaceable>correlation</replaceable>.<replaceable>columnname</replaceable>
</synopsis>
   </para>
<!-- pgdoc-cn_end sig_en=76aef8a2edce39f3206b4d3a77525002 -->

<!-- pgdoc-cn_start sig_en=0f2bd429f92e0da9122b906563e58320 sig_cn_org=None source=14.1 
   <para>
    <replaceable>correlation</replaceable> is the name of a
    table (possibly qualified with a schema name), or an alias for a table
    defined by means of a <literal>FROM</literal> clause.
    The correlation name and separating dot can be omitted if the column name
    is unique across all the tables being used in the current query.  (See also <xref linkend="queries"/>.)
   </para>
________________________________________________________-->
   <para>
    <replaceable>correlation</replaceable>是一个表（有可能以一个模式名限定）的名字，或者是在<literal>FROM</literal>子句中为一个表定义的别名。如果列名在当前索引所使用的表中都是唯一的，关联名称和分隔用的句点可以被忽略（另见<xref linkend="queries"/>）。
   </para>
<!-- pgdoc-cn_end sig_en=0f2bd429f92e0da9122b906563e58320 -->
  </sect2>

  <sect2 id="sql-expressions-parameters-positional">
<!-- pgdoc-cn_start sig_en=75c6128d997b728b4e7f10aace77fe1d sig_cn_org=None source=14.1 
   <title>Positional Parameters</title>
________________________________________________________-->
   <title>位置参数</title>
<!-- pgdoc-cn_end sig_en=75c6128d997b728b4e7f10aace77fe1d -->

<!-- pgdoc-cn_start sig_en=d8ee2a3d73454c016e67c5e609bb342a sig_cn_org=None source=14.1 
   <indexterm>
    <primary>parameter</primary>
    <secondary>syntax</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>参数</primary>
    <secondary>语法</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=d8ee2a3d73454c016e67c5e609bb342a -->

<!-- pgdoc-cn_start sig_en=22fb09f37a6054b5e5265d54c0a40780 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>$</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>$</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=22fb09f37a6054b5e5265d54c0a40780 -->

<!-- pgdoc-cn_start sig_en=6d593ded4a2d17e2b4e14bcffd200909 sig_cn_org=None source=14.1 
   <para>
    A positional parameter reference is used to indicate a value
    that is supplied externally to an SQL statement.  Parameters are
    used in SQL function definitions and in prepared queries.  Some
    client libraries also support specifying data values separately
    from the SQL command string, in which case parameters are used to
    refer to the out-of-line data values.
    The form of a parameter reference is:
<synopsis>
$<replaceable>number</replaceable>
</synopsis>
   </para>
________________________________________________________-->
   <para>
    一个位置参数引用被用来指示一个由 SQL 语句外部提供的值。参数被用于 SQL 函数定义和预备查询中。某些客户端库还支持独立于 SQL 命令字符串来指定数据值，在这种情况中参数被用来引用那些线外数据值。一个参数引用的形式是：
<synopsis>
$<replaceable>number</replaceable>
</synopsis>
   </para>
<!-- pgdoc-cn_end sig_en=6d593ded4a2d17e2b4e14bcffd200909 -->

<!-- pgdoc-cn_start sig_en=cf5debf44f5c5bdf179af4a695c16510 sig_cn_org=None source=14.1 
   <para>
    For example, consider the definition of a function,
    <function>dept</function>, as:

<programlisting>
CREATE FUNCTION dept(text) RETURNS dept
    AS $$ SELECT * FROM dept WHERE name = $1 $$
    LANGUAGE SQL;
</programlisting>

    Here the <literal>$1</literal> references the value of the first
    function argument whenever the function is invoked.
   </para>
________________________________________________________-->
   <para>
    例如，考虑一个函数<function>dept</function>的定义：

<programlisting>
CREATE FUNCTION dept(text) RETURNS dept
    AS $$ SELECT * FROM dept WHERE name = $1 $$
    LANGUAGE SQL;
</programlisting>

    这里<literal>$1</literal>引用函数被调用时第一个函数参数的值。
   </para>
<!-- pgdoc-cn_end sig_en=cf5debf44f5c5bdf179af4a695c16510 -->
  </sect2>

  <sect2 id="sql-expressions-subscripts">
<!-- pgdoc-cn_start sig_en=79fb6fbf0b19185534355bd8ce4bd9dc sig_cn_org=None source=14.1 
   <title>Subscripts</title>
________________________________________________________-->
   <title>下标</title>
<!-- pgdoc-cn_end sig_en=79fb6fbf0b19185534355bd8ce4bd9dc -->

<!-- pgdoc-cn_start sig_en=1cd3544b1fe0f2311356337cd116038b sig_cn_org=None source=14.1 
   <indexterm>
    <primary>subscript</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>下标</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=1cd3544b1fe0f2311356337cd116038b -->

<!-- pgdoc-cn_start sig_en=bd5fb0ed7b9cf014ef6e5fe71b3e257f sig_cn_org=None source=14.1 
   <para>
    If an expression yields a value of an array type, then a specific
    element of the array value can be extracted by writing
<synopsis>
<replaceable>expression</replaceable>[<replaceable>subscript</replaceable>]
</synopsis>
    or multiple adjacent elements (an <quote>array slice</quote>) can be extracted
    by writing
<synopsis>
<replaceable>expression</replaceable>[<replaceable>lower_subscript</replaceable>:<replaceable>upper_subscript</replaceable>]
</synopsis>
    (Here, the brackets <literal>[ ]</literal> are meant to appear literally.)
    Each <replaceable>subscript</replaceable> is itself an expression,
    which will be rounded to the nearest integer value.
   </para>
________________________________________________________-->
   <para>
    如果一个表达式得到了一个数组类型的值，那么可以抽取出该数组值的一个特定元素：
<synopsis>
<replaceable>expression</replaceable>[<replaceable>subscript</replaceable>]
</synopsis>
    或者抽取出多个相邻元素（一个<quote>数组切片</quote>）：
<synopsis>
<replaceable>expression</replaceable>[<replaceable>lower_subscript</replaceable>:<replaceable>upper_subscript</replaceable>]
</synopsis>
    （这里，方括号<literal>[ ]</literal>表示其字面意思）。每一个<replaceable>下标</replaceable>自身是一个表达式，它将四舍五入到最接近的整数值。
   </para>
<!-- pgdoc-cn_end sig_en=bd5fb0ed7b9cf014ef6e5fe71b3e257f -->

<!-- pgdoc-cn_start sig_en=fa0eeb31f216af1598b28dd77afb16de sig_cn_org=None source=14.1 
   <para>
    In general the array <replaceable>expression</replaceable> must be
    parenthesized, but the parentheses can be omitted when the expression
    to be subscripted is just a column reference or positional parameter.
    Also, multiple subscripts can be concatenated when the original array
    is multidimensional.
    For example:

<programlisting>
mytable.arraycolumn[4]
mytable.two_d_column[17][34]
$1[10:42]
(arrayfunction(a,b))[42]
</programlisting>

    The parentheses in the last example are required.
    See <xref linkend="arrays"/> for more about arrays.
   </para>
________________________________________________________-->
   <para>
    通常，数组<replaceable>表达式</replaceable>必须被加上括号，但是当要被加下标的表达式只是一个列引用或位置参数时，括号可以被忽略。还有，当原始数组是多维时，多个下标可以被连接起来。例如：

<programlisting>
mytable.arraycolumn[4]
mytable.two_d_column[17][34]
$1[10:42]
(arrayfunction(a,b))[42]
</programlisting>

    最后一个例子中的圆括号是必需的。详见<xref linkend="arrays"/>。
   </para>
<!-- pgdoc-cn_end sig_en=fa0eeb31f216af1598b28dd77afb16de -->
  </sect2>

  <sect2 id="field-selection">
<!-- pgdoc-cn_start sig_en=7ed25cc7ed4fa0444c858213ddb4743f sig_cn_org=None source=14.1 
   <title>Field Selection</title>
________________________________________________________-->
   <title>域选择</title>
<!-- pgdoc-cn_end sig_en=7ed25cc7ed4fa0444c858213ddb4743f -->

<!-- pgdoc-cn_start sig_en=5caf1c1c472267b71109188a38587964 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>field selection</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>域选择</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=5caf1c1c472267b71109188a38587964 -->

<!-- pgdoc-cn_start sig_en=dad558c8af80262f9f212ffcfc24a998 sig_cn_org=None source=14.1 
   <para>
    If an expression yields a value of a composite type (row type), then a
    specific field of the row can be extracted by writing
<synopsis>
<replaceable>expression</replaceable>.<replaceable>fieldname</replaceable>
</synopsis>
   </para>
________________________________________________________-->
   <para>
    如果一个表达式得到一个组合类型（行类型）的值，那么可以抽取该行的指定域
<synopsis>
<replaceable>expression</replaceable>.<replaceable>fieldname</replaceable>
</synopsis>
   </para>
<!-- pgdoc-cn_end sig_en=dad558c8af80262f9f212ffcfc24a998 -->

<!-- pgdoc-cn_start sig_en=0bb116b79a20f8697c07e7495105a3c6 sig_cn_org=None source=14.1 
   <para>
    In general the row <replaceable>expression</replaceable> must be
    parenthesized, but the parentheses can be omitted when the expression
    to be selected from is just a table reference or positional parameter.
    For example:

<programlisting>
mytable.mycolumn
$1.somecolumn
(rowfunction(a,b)).col3
</programlisting>

    (Thus, a qualified column reference is actually just a special case
    of the field selection syntax.)  An important special case is
    extracting a field from a table column that is of a composite type:

<programlisting>
(compositecol).somefield
(mytable.compositecol).somefield
</programlisting>

    The parentheses are required here to show that
    <structfield>compositecol</structfield> is a column name not a table name,
    or that <structname>mytable</structname> is a table name not a schema name
    in the second case.
   </para>
________________________________________________________-->
   <para>
    通常行<replaceable>表达式</replaceable>必须被加上括号，但是当该表达式是仅从一个表引用或位置参数选择时，圆括号可以被忽略。例如：

<programlisting>
mytable.mycolumn
$1.somecolumn
(rowfunction(a,b)).col3
</programlisting>

    （因此，一个被限定的列引用实际上只是域选择语法的一种特例）。一种重要的特例是从一个组合类型的表列中抽取一个域：

<programlisting>
(compositecol).somefield
(mytable.compositecol).somefield
</programlisting>

    这里需要圆括号来显示<structfield>compositecol</structfield>是一个列名而不是一个表名，在第二种情况中则是显示<structname>mytable</structname>是一个表名而不是一个模式名。
   </para>
<!-- pgdoc-cn_end sig_en=0bb116b79a20f8697c07e7495105a3c6 -->

<!-- pgdoc-cn_start sig_en=63bd114eb0c2dcd82c5ad84820b5eac5 sig_cn_org=None source=14.1 
   <para>
    You can ask for all fields of a composite value by
    writing <literal>.*</literal>:
<programlisting>
(compositecol).*
</programlisting>
    This notation behaves differently depending on context;
    see <xref linkend="rowtypes-usage"/> for details.
   </para>
________________________________________________________-->
   <para>
    你可以通过书写<literal>.*</literal>来请求一个组合值的所有域：
<programlisting>
(compositecol).*
</programlisting>
    这种记法的行为根据上下文会有不同，详见<xref linkend="rowtypes-usage"/>。
   </para>
<!-- pgdoc-cn_end sig_en=63bd114eb0c2dcd82c5ad84820b5eac5 -->
  </sect2>

  <sect2 id="sql-expressions-operator-calls">
<!-- pgdoc-cn_start sig_en=0fedae1c31e03e52df6a7dd137545743 sig_cn_org=None source=14.1 
   <title>Operator Invocations</title>
________________________________________________________-->
   <title>操作符调用</title>
<!-- pgdoc-cn_end sig_en=0fedae1c31e03e52df6a7dd137545743 -->

<!-- pgdoc-cn_start sig_en=dee27b0804ce1a9fee198b5e5d629dc6 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>operator</primary>
    <secondary>invocation</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>操作符</primary>
    <secondary>调用</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=dee27b0804ce1a9fee198b5e5d629dc6 -->

<!-- pgdoc-cn_start sig_en=c87cf396e4fc3b17cdd6b9202d64cd73 sig_cn_org=None source=14.1 
   <para>
    There are two possible syntaxes for an operator invocation:
    <simplelist>
     <member><replaceable>expression</replaceable> <replaceable>operator</replaceable> <replaceable>expression</replaceable> (binary infix operator)</member>
     <member><replaceable>operator</replaceable> <replaceable>expression</replaceable> (unary prefix operator)</member>
    </simplelist>
    where the <replaceable>operator</replaceable> token follows the syntax
    rules of <xref linkend="sql-syntax-operators"/>, or is one of the
    key words <token>AND</token>, <token>OR</token>, and
    <token>NOT</token>, or is a qualified operator name in the form:
<synopsis>
<literal>OPERATOR(</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>operatorname</replaceable><literal>)</literal>
</synopsis>
    Which particular operators exist and whether
    they are unary or binary depends on what operators have been
    defined by the system or the user.  <xref linkend="functions"/>
    describes the built-in operators.
   </para>
________________________________________________________-->
   <para>
    对于一次操作符调用，有两种可能的语法：
    <simplelist>
     <member><replaceable>expression</replaceable> <replaceable>operator</replaceable> <replaceable>expression</replaceable>（二元中缀操作符）</member>
     <member><replaceable>operator</replaceable> <replaceable>expression</replaceable>（一元前缀操作符）</member>
    </simplelist>
    其中<replaceable>operator</replaceable>记号遵循<xref linkend="sql-syntax-operators"/>的语法规则，或者是关键词<token>AND</token>、<token>OR</token>和<token>NOT</token>之一，或者是一个如下形式的受限定操作符名：
<synopsis>
<literal>OPERATOR(</literal><replaceable>schema</replaceable><literal>.</literal><replaceable>operatorname</replaceable><literal>)</literal>
</synopsis>
    哪个特定操作符存在以及它们是一元的还是二元的取决于由系统或用户定义的那些操作符。<xref linkend="functions"/>描述了内建操作符。
   </para>
<!-- pgdoc-cn_end sig_en=c87cf396e4fc3b17cdd6b9202d64cd73 -->
  </sect2>

  <sect2 id="sql-expressions-function-calls">
<!-- pgdoc-cn_start sig_en=03d72bd37dc52314bba84ffe347bf230 sig_cn_org=None source=14.1 
   <title>Function Calls</title>
________________________________________________________-->
   <title>函数调用</title>
<!-- pgdoc-cn_end sig_en=03d72bd37dc52314bba84ffe347bf230 -->

<!-- pgdoc-cn_start sig_en=a2699265fc8810069f7c5432834ea98a sig_cn_org=None source=14.1 
   <indexterm>
    <primary>function</primary>
    <secondary>invocation</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>函数</primary>
    <secondary>调用</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=a2699265fc8810069f7c5432834ea98a -->

<!-- pgdoc-cn_start sig_en=bcb11a58179db92ceb46825b541878a5 sig_cn_org=None source=14.1 
   <para>
    The syntax for a function call is the name of a function
    (possibly qualified with a schema name), followed by its argument list
    enclosed in parentheses:

<synopsis>
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional> )
</synopsis>
   </para>
________________________________________________________-->
   <para>
    一个函数调用的语法是一个函数的名称（可能受限于一个模式名）后面跟上封闭于圆括号中的参数列表：

<synopsis>
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional> )
</synopsis>
   </para>
<!-- pgdoc-cn_end sig_en=bcb11a58179db92ceb46825b541878a5 -->

<!-- pgdoc-cn_start sig_en=ea2f2dbfe53701ca3bc1dbdca812c6e4 sig_cn_org=None source=14.1 
   <para>
    For example, the following computes the square root of 2:
<programlisting>
sqrt(2)
</programlisting>
   </para>
________________________________________________________-->
   <para>
    例如，下面会计算 2 的平方根：
<programlisting>
sqrt(2)
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=ea2f2dbfe53701ca3bc1dbdca812c6e4 -->

<!-- pgdoc-cn_start sig_en=289e75c61e5869faeafb25f0c8c14f2c sig_cn_org=None source=14.1 
   <para>
    The list of built-in functions is in <xref linkend="functions"/>.
    Other functions can be added by the user.
   </para>
________________________________________________________-->
   <para>
    当在一个某些用户不信任其他用户的数据库中发出查询时，在编写函数调用时应遵守<xref linkend="typeconv-func"/>中的安全防范措施。
   </para>
<!-- pgdoc-cn_end sig_en=289e75c61e5869faeafb25f0c8c14f2c -->

<!-- pgdoc-cn_start sig_en=ee30240b83f0b621999b0c605780161a sig_cn_org=None source=14.1 
   <para>
    When issuing queries in a database where some users mistrust other users,
    observe security precautions from <xref linkend="typeconv-func"/> when
    writing function calls.
   </para>
________________________________________________________-->
   <para>
    内建函数的列表在<xref linkend="functions"/>中。其他函数可以由用户增加。
   </para>
<!-- pgdoc-cn_end sig_en=ee30240b83f0b621999b0c605780161a -->

<!-- pgdoc-cn_start sig_en=3bd09991051299214273017b0ab20129 sig_cn_org=None source=14.1 
   <para>
    The arguments can optionally have names attached.
    See <xref linkend="sql-syntax-calling-funcs"/> for details.
   </para>
________________________________________________________-->
   <para>
    参数可以有选择地被附加名称。详见<xref linkend="sql-syntax-calling-funcs"/>。
   </para>
<!-- pgdoc-cn_end sig_en=3bd09991051299214273017b0ab20129 -->

   <note>
<!-- pgdoc-cn_start sig_en=4fa6472c59d1cbea450b1fec52bebbd9 sig_cn_org=None source=14.1 
    <para>
     A function that takes a single argument of composite type can
     optionally be called using field-selection syntax, and conversely
     field selection can be written in functional style.  That is, the
     notations <literal>col(table)</literal> and <literal>table.col</literal> are
     interchangeable.  This behavior is not SQL-standard but is provided
     in <productname>PostgreSQL</productname> because it allows use of functions to
     emulate <quote>computed fields</quote>.  For more information see
     <xref linkend="rowtypes-usage"/>.
    </para>
________________________________________________________-->
    <para>
     一个采用单一组合类型参数的函数可以被有选择地称为域选择语法，并且反过来域选择可以被写成函数的风格。也就是说，记号<literal>col(table)</literal>和<literal>table.col</literal>是可以互换的。这种行为是非 SQL 标准的但是在<productname>PostgreSQL</productname>中被提供，因为它允许函数的使用来模拟<quote>计算域</quote>。详见<xref linkend="rowtypes-usage"/>。
    </para>
<!-- pgdoc-cn_end sig_en=4fa6472c59d1cbea450b1fec52bebbd9 -->
   </note>
  </sect2>

  <sect2 id="syntax-aggregates">
<!-- pgdoc-cn_start sig_en=80c1f0e12ba2eeb04285b014689f8cd2 sig_cn_org=None source=14.1 
   <title>Aggregate Expressions</title>
________________________________________________________-->
   <title>聚集表达式</title>
<!-- pgdoc-cn_end sig_en=80c1f0e12ba2eeb04285b014689f8cd2 -->

<!-- pgdoc-cn_start sig_en=d70e6fe43d321ca86c469b12e981a97c sig_cn_org=None source=14.1 
   <indexterm zone="syntax-aggregates">
    <primary>aggregate function</primary>
    <secondary>invocation</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="syntax-aggregates">
    <primary>聚集函数</primary>
    <secondary>调用</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=d70e6fe43d321ca86c469b12e981a97c -->

<!-- pgdoc-cn_start sig_en=004177efe5969775ffad24edb8fc33b2 sig_cn_org=None source=14.1 
   <indexterm zone="syntax-aggregates">
    <primary>ordered-set aggregate</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="syntax-aggregates">
    <primary>有序集聚集</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=004177efe5969775ffad24edb8fc33b2 -->

<!-- pgdoc-cn_start sig_en=e4b5b9d80d735916f3ee5fd8af61c75a sig_cn_org=None source=14.1 
   <indexterm zone="syntax-aggregates">
    <primary>WITHIN GROUP</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="syntax-aggregates">
    <primary>WITHIN GROUP</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=e4b5b9d80d735916f3ee5fd8af61c75a -->

<!-- pgdoc-cn_start sig_en=63c91483275c38a3c218c985a2b58179 sig_cn_org=None source=14.1 
   <indexterm zone="syntax-aggregates">
    <primary>FILTER</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="syntax-aggregates">
    <primary>FILTER</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=63c91483275c38a3c218c985a2b58179 -->

<!-- pgdoc-cn_start sig_en=be2b6d55619fdbc62e9f001d662aac59 sig_cn_org=None source=14.1 
   <para>
    An <firstterm>aggregate expression</firstterm> represents the
    application of an aggregate function across the rows selected by a
    query.  An aggregate function reduces multiple inputs to a single
    output value, such as the sum or average of the inputs.  The
    syntax of an aggregate expression is one of the following:

<synopsis>
<replaceable>aggregate_name</replaceable> (<replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> (ALL <replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> (DISTINCT <replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> ( * ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> ( [ <replaceable>expression</replaceable> [ , ... ] ] ) WITHIN GROUP ( <replaceable>order_by_clause</replaceable> ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
</synopsis>

    where <replaceable>aggregate_name</replaceable> is a previously
    defined aggregate (possibly qualified with a schema name) and
    <replaceable>expression</replaceable> is
    any value expression that does not itself contain an aggregate
    expression or a window function call.  The optional
    <replaceable>order_by_clause</replaceable> and
    <replaceable>filter_clause</replaceable> are described below.
   </para>
________________________________________________________-->
   <para>
    一个<firstterm>聚集表达式</firstterm>表示在由一个查询选择的行上应用一个聚集函数。一个聚集函数将多个输入减少到一个单一输出值，例如对输入的求和或平均。一个聚集表达式的语法是下列之一：

<synopsis>
<replaceable>aggregate_name</replaceable> (<replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> (ALL <replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> (DISTINCT <replaceable>expression</replaceable> [ , ... ] [ <replaceable>order_by_clause</replaceable> ] ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> ( * ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
<replaceable>aggregate_name</replaceable> ( [ <replaceable>expression</replaceable> [ , ... ] ] ) WITHIN GROUP ( <replaceable>order_by_clause</replaceable> ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ]
</synopsis>

    这里<replaceable>aggregate_name</replaceable>是一个之前定义的聚集（可能带有一个模式名限定），并且<replaceable>expression</replaceable>是任意自身不包含聚集表达式的值表达式或一个窗口函数调用。可选的<replaceable>order_by_clause</replaceable>和<replaceable>filter_clause</replaceable>描述如下。
   </para>
<!-- pgdoc-cn_end sig_en=be2b6d55619fdbc62e9f001d662aac59 -->

<!-- pgdoc-cn_start sig_en=27dc7e25c1852c44bc870e19f0d23419 sig_cn_org=None source=14.1 
   <para>
    The first form of aggregate expression invokes the aggregate
    once for each input row.
    The second form is the same as the first, since
    <literal>ALL</literal> is the default.
    The third form invokes the aggregate once for each distinct value
    of the expression (or distinct set of values, for multiple expressions)
    found in the input rows.
    The fourth form invokes the aggregate once for each input row; since no
    particular input value is specified, it is generally only useful
    for the <function>count(*)</function> aggregate function.
    The last form is used with <firstterm>ordered-set</firstterm> aggregate
    functions, which are described below.
   </para>
________________________________________________________-->
   <para>
    第一种形式的聚集表达式为每一个输入行调用一次聚集。第二种形式和第一种相同，因为<literal>ALL</literal>是默认选项。第三种形式为输入行中表达式的每一个可区分值（或者对于多个表达式是值的可区分集合）调用一次聚集。第四种形式为每一个输入行调用一次聚集，因为没有特定的输入值被指定，它通常只对于<function>count(*)</function>聚集函数有用。最后一种形式被用于<firstterm>有序集</firstterm>聚集函数，其描述如下。
   </para>
<!-- pgdoc-cn_end sig_en=27dc7e25c1852c44bc870e19f0d23419 -->

<!-- pgdoc-cn_start sig_en=9d01f0a6b9469388102dd6bd53a34ae4 sig_cn_org=None source=14.1 
   <para>
    Most aggregate functions ignore null inputs, so that rows in which
    one or more of the expression(s) yield null are discarded.  This
    can be assumed to be true, unless otherwise specified, for all
    built-in aggregates.
   </para>
________________________________________________________-->
   <para>
    大部分聚集函数忽略空输入，这样其中一个或多个表达式得到空值的行将被丢弃。除非另有说明，对于所有内建聚集都是这样。
   </para>
<!-- pgdoc-cn_end sig_en=9d01f0a6b9469388102dd6bd53a34ae4 -->

<!-- pgdoc-cn_start sig_en=2a6bc5e97be20b7ee3f8eb4d5b741b00 sig_cn_org=None source=14.1 
   <para>
    For example, <literal>count(*)</literal> yields the total number
    of input rows; <literal>count(f1)</literal> yields the number of
    input rows in which <literal>f1</literal> is non-null, since
    <function>count</function> ignores nulls; and
    <literal>count(distinct f1)</literal> yields the number of
    distinct non-null values of <literal>f1</literal>.
   </para>
________________________________________________________-->
   <para>
    例如，<literal>count(*)</literal>得到输入行的总数。<literal>count(f1)</literal>得到输入行中<literal>f1</literal>为非空的数量，因为<function>count</function>忽略空值。而<literal>count(distinct f1)</literal>得到<literal>f1</literal>的非空可区分值的数量。
   </para>
<!-- pgdoc-cn_end sig_en=2a6bc5e97be20b7ee3f8eb4d5b741b00 -->

<!-- pgdoc-cn_start sig_en=101a17e37d4eb4a108a9345f5349736a sig_cn_org=None source=14.1 
   <para>
    Ordinarily, the input rows are fed to the aggregate function in an
    unspecified order.  In many cases this does not matter; for example,
    <function>min</function> produces the same result no matter what order it
    receives the inputs in.  However, some aggregate functions
    (such as <function>array_agg</function> and <function>string_agg</function>) produce
    results that depend on the ordering of the input rows.  When using
    such an aggregate, the optional <replaceable>order_by_clause</replaceable> can be
    used to specify the desired ordering.  The <replaceable>order_by_clause</replaceable>
    has the same syntax as for a query-level <literal>ORDER BY</literal> clause, as
    described in <xref linkend="queries-order"/>, except that its expressions
    are always just expressions and cannot be output-column names or numbers.
    For example:
<programlisting>
SELECT array_agg(a ORDER BY b DESC) FROM table;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    一般地，交给聚集函数的输入行是未排序的。在很多情况中这没有关系，例如不管接收到什么样的输入，<function>min</function>总是产生相同的结果。但是，某些聚集函数（例如<function>array_agg</function> 和<function>string_agg</function>）依据输入行的排序产生结果。当使用这类聚集时，可选的<replaceable>order_by_clause</replaceable>可以被用来指定想要的顺序。<replaceable>order_by_clause</replaceable>与查询级别的<literal>ORDER BY</literal>子句（如<xref linkend="queries-order"/>所述）具有相同的语法，除非它的表达式总是仅有表达式并且不能是输出列名称或编号。例如：
<programlisting>
SELECT array_agg(a ORDER BY b DESC) FROM table;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=101a17e37d4eb4a108a9345f5349736a -->

<!-- pgdoc-cn_start sig_en=13feb5380da53aaf1d1dc24178e93628 sig_cn_org=None source=14.1 
   <para>
    When dealing with multiple-argument aggregate functions, note that the
    <literal>ORDER BY</literal> clause goes after all the aggregate arguments.
    For example, write this:
<programlisting>
SELECT string_agg(a, ',' ORDER BY a) FROM table;
</programlisting>
    not this:
<programlisting>
SELECT string_agg(a ORDER BY a, ',') FROM table;  -&minus; incorrect
</programlisting>
    The latter is syntactically valid, but it represents a call of a
    single-argument aggregate function with two <literal>ORDER BY</literal> keys
    (the second one being rather useless since it's a constant).
   </para>
________________________________________________________-->
   <para>
    在处理多参数聚集函数时，注意<literal>ORDER BY</literal>出现在所有聚集参数之后。例如，要这样写：
<programlisting>
SELECT string_agg(a, ',' ORDER BY a) FROM table;
</programlisting>
    而不能这样写：
<programlisting>
SELECT string_agg(a ORDER BY a, ',') FROM table;  -- 不正确
</programlisting>
    后者在语法上是合法的，但是它表示用两个<literal>ORDER BY</literal>键来调用一个单一参数聚集函数（第二个是无用的，因为它是一个常量）。
   </para>
<!-- pgdoc-cn_end sig_en=13feb5380da53aaf1d1dc24178e93628 -->

<!-- pgdoc-cn_start sig_en=a9fc3678ab2affd7d3c20443561c21e5 sig_cn_org=None source=14.1 
   <para>
    If <literal>DISTINCT</literal> is specified in addition to an
    <replaceable>order_by_clause</replaceable>, then all the <literal>ORDER BY</literal>
    expressions must match regular arguments of the aggregate; that is,
    you cannot sort on an expression that is not included in the
    <literal>DISTINCT</literal> list.
   </para>
________________________________________________________-->
   <para>
    如果在<replaceable>order_by_clause</replaceable>之外指定了<literal>DISTINCT</literal>，那么所有的<literal>ORDER BY</literal>表达式必须匹配聚集的常规参数。也就是说，你不能在<literal>DISTINCT</literal>列表没有包括的表达式上排序。
   </para>
<!-- pgdoc-cn_end sig_en=a9fc3678ab2affd7d3c20443561c21e5 -->

   <note>
<!-- pgdoc-cn_start sig_en=6ba5cbab7b8ea48b32c180ee8c5aec0a sig_cn_org=None source=14.1 
    <para>
     The ability to specify both <literal>DISTINCT</literal> and <literal>ORDER BY</literal>
     in an aggregate function is a <productname>PostgreSQL</productname> extension.
    </para>
________________________________________________________-->
    <para>
     在一个聚集函数中指定<literal>DISTINCT</literal>以及<literal>ORDER BY</literal>的能力是一种<productname>PostgreSQL</productname>扩展。
    </para>
<!-- pgdoc-cn_end sig_en=6ba5cbab7b8ea48b32c180ee8c5aec0a -->
   </note>

<!-- pgdoc-cn_start sig_en=3cb13e3ef3036eda2708e27dbde73fc7 sig_cn_org=None source=14.1 
   <para>
    Placing <literal>ORDER BY</literal> within the aggregate's regular argument
    list, as described so far, is used when ordering the input rows for
    general-purpose and statistical aggregates, for which ordering is
    optional.  There is a
    subclass of aggregate functions called <firstterm>ordered-set
    aggregates</firstterm> for which an <replaceable>order_by_clause</replaceable>
    is <emphasis>required</emphasis>, usually because the aggregate's computation is
    only sensible in terms of a specific ordering of its input rows.
    Typical examples of ordered-set aggregates include rank and percentile
    calculations.  For an ordered-set aggregate,
    the <replaceable>order_by_clause</replaceable> is written
    inside <literal>WITHIN GROUP (...)</literal>, as shown in the final syntax
    alternative above.  The expressions in
    the <replaceable>order_by_clause</replaceable> are evaluated once per
    input row just like regular aggregate arguments, sorted as per
    the <replaceable>order_by_clause</replaceable>'s requirements, and fed
    to the aggregate function as input arguments.  (This is unlike the case
    for a non-<literal>WITHIN GROUP</literal> <replaceable>order_by_clause</replaceable>,
    which is not treated as argument(s) to the aggregate function.)  The
    argument expressions preceding <literal>WITHIN GROUP</literal>, if any, are
    called <firstterm>direct arguments</firstterm> to distinguish them from
    the <firstterm>aggregated arguments</firstterm> listed in
    the <replaceable>order_by_clause</replaceable>.  Unlike regular aggregate
    arguments, direct arguments are evaluated only once per aggregate call,
    not once per input row.  This means that they can contain variables only
    if those variables are grouped by <literal>GROUP BY</literal>; this restriction
    is the same as if the direct arguments were not inside an aggregate
    expression at all.  Direct arguments are typically used for things like
    percentile fractions, which only make sense as a single value per
    aggregation calculation.  The direct argument list can be empty; in this
    case, write just <literal>()</literal> not <literal>(*)</literal>.
    (<productname>PostgreSQL</productname> will actually accept either spelling, but
    only the first way conforms to the SQL standard.)
   </para>
________________________________________________________-->
   <para>
    按照到目前为止的描述，如果一般目的和统计性聚集中
    排序是可选的，在要为它排序输入行时可以在该聚集的常规参数
    列表中放置<literal>ORDER BY</literal>。有一个聚集函数的子集叫
    做<firstterm>有序集聚集</firstterm>，它<emphasis>要求</emphasis>一个
    <replaceable>order_by_clause</replaceable>，通常是因为
    该聚集的计算只对其输入行的特定顺序有意义。有序集聚集的典
    型例子包括排名和百分位计算。按照上文的最后一种语法，对于
    一个有序集聚集，
    <replaceable>order_by_clause</replaceable>被写在
    <literal>WITHIN GROUP (...)</literal>中。
     <replaceable>order_by_clause</replaceable>中的表达式
     会像普通聚集参数一样对每一个输入行计算一次，按照每个
     <replaceable>order_by_clause</replaceable>的要求排序并
     且交给该聚集函数作为输入参数（这和非
     <literal>WITHIN GROUP</literal> 
     <replaceable>order_by_clause</replaceable>的情况不同，在其中表达
     式的结果不会被作为聚集函数的参数）。如果有在
     <literal>WITHIN GROUP</literal>之前的参数表达式，会把它们称
     为<firstterm>直接参数</firstterm>以便与列在
     <replaceable>order_by_clause</replaceable>中的
     <firstterm>聚集参数</firstterm>相区分。与普通聚集参数不同，针对
     每次聚集调用只会计算一次直接参数，而不是为每一个输入行
     计算一次。这意味着只有那些变量被<literal>GROUP BY</literal>
     分组时，它们才能包含这些变量。这个限制同样适用于根本不在
     一个聚集表达式内部的直接参数。直接参数通常被用于百分数
     之类的东西，它们只有作为每次聚集计算用一次的单一值才有意
     义。直接参数列表可以为空，在这种情况下，写成<literal>()</literal>
     而不是<literal>(*)</literal>（实际上
     <productname>PostgreSQL</productname>接受两种拼写，但是只有第一
     种符合 SQL 标准）。
   </para>
<!-- pgdoc-cn_end sig_en=3cb13e3ef3036eda2708e27dbde73fc7 -->

<!-- pgdoc-cn_start sig_en=956468a85f64ce56a1da1d548c0d2843 sig_cn_org=None source=14.1 
   <para>
    <indexterm>
     <primary>median</primary>
     <seealso>percentile</seealso>
    </indexterm>
    An example of an ordered-set aggregate call is:

<programlisting>
SELECT percentile_cont(0.5) WITHIN GROUP (ORDER BY income) FROM households;
 percentile_cont
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
           50489
</programlisting>

   which obtains the 50th percentile, or median, value of
   the <structfield>income</structfield> column from table <structname>households</structname>.
   Here, <literal>0.5</literal> is a direct argument; it would make no sense
   for the percentile fraction to be a value varying across rows.
   </para>
________________________________________________________-->
   <para>
    <indexterm>
     <primary>median</primary>
     <seealso>percentile</seealso>
    </indexterm>
     有序集聚集的调用例子：

<programlisting>
SELECT percentile_cont(0.5) WITHIN GROUP (ORDER BY income) FROM households;
 percentile_cont
-----------------
           50489
</programlisting>

   这会从表<structname>households</structname>的
   <structfield>income</structfield>列得到第 50 个百分位或者中位的值。
   这里<literal>0.5</literal>是一个直接参数，对于百分位部分是一个
   在不同行之间变化的值的情况它没有意义。
   </para>
<!-- pgdoc-cn_end sig_en=956468a85f64ce56a1da1d548c0d2843 -->

<!-- pgdoc-cn_start sig_en=e6759991997f2690ec4ee70af428fe36 sig_cn_org=None source=14.1 
   <para>
    If <literal>FILTER</literal> is specified, then only the input
    rows for which the <replaceable>filter_clause</replaceable>
    evaluates to true are fed to the aggregate function; other rows
    are discarded.  For example:
<programlisting>
SELECT
    count(*) AS unfiltered,
    count(*) FILTER (WHERE i &lt; 5) AS filtered
FROM generate_series(1,10) AS s(i);
 unfiltered | filtered
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;
         10 |        4
(1 row)
</programlisting>
   </para>
________________________________________________________-->
   <para>
    如果指定了<literal>FILTER</literal>，那么只有对<replaceable>filter_clause</replaceable>计算为真的输入行会被交给该聚集函数，其他行会被丢弃。例如：
<programlisting>
SELECT
    count(*) AS unfiltered,
    count(*) FILTER (WHERE i &lt; 5) AS filtered
FROM generate_series(1,10) AS s(i);
 unfiltered | filtered
------------+----------
         10 |        4
(1 row)
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=e6759991997f2690ec4ee70af428fe36 -->

<!-- pgdoc-cn_start sig_en=d89e979437fb0334c2ccdbe49f7c49d8 sig_cn_org=None source=14.1 
   <para>
    The predefined aggregate functions are described in <xref
    linkend="functions-aggregate"/>.  Other aggregate functions can be added
    by the user.
   </para>
________________________________________________________-->
   <para>
    预定义的聚集函数在<xref linkend="functions-aggregate"/>中描述。其他聚集函数可以由用户增加。
   </para>
<!-- pgdoc-cn_end sig_en=d89e979437fb0334c2ccdbe49f7c49d8 -->

<!-- pgdoc-cn_start sig_en=98f5b0348c5f459a8db38ea2a73fe48a sig_cn_org=None source=14.1 
   <para>
    An aggregate expression can only appear in the result list or
    <literal>HAVING</literal> clause of a <command>SELECT</command> command.
    It is forbidden in other clauses, such as <literal>WHERE</literal>,
    because those clauses are logically evaluated before the results
    of aggregates are formed.
   </para>
________________________________________________________-->
   <para>
    一个聚集表达式只能出现在<command>SELECT</command>命令的结果列表或是<literal>HAVING</literal>子句中。在其他子句（如<literal>WHERE</literal>）中禁止使用它，因为那些子句的计算在逻辑上是在聚集的结果被形成之前。
   </para>
<!-- pgdoc-cn_end sig_en=98f5b0348c5f459a8db38ea2a73fe48a -->

<!-- pgdoc-cn_start sig_en=66013fa5a82e6cccb66a07bc3c9a3547 sig_cn_org=None source=14.1 
   <para>
    When an aggregate expression appears in a subquery (see
    <xref linkend="sql-syntax-scalar-subqueries"/> and
    <xref linkend="functions-subquery"/>), the aggregate is normally
    evaluated over the rows of the subquery.  But an exception occurs
    if the aggregate's arguments (and <replaceable>filter_clause</replaceable>
    if any) contain only outer-level variables:
    the aggregate then belongs to the nearest such outer level, and is
    evaluated over the rows of that query.  The aggregate expression
    as a whole is then an outer reference for the subquery it appears in,
    and acts as a constant over any one evaluation of that subquery.
    The restriction about
    appearing only in the result list or <literal>HAVING</literal> clause
    applies with respect to the query level that the aggregate belongs to.
   </para>
________________________________________________________-->
   <para>
    当一个聚集表达式出现在一个子查询中（见<xref linkend="sql-syntax-scalar-subqueries"/>和<xref linkend="functions-subquery"/>），聚集通常在该子查询的行上被计算。但是如果该聚集的参数（以及<replaceable>filter_clause</replaceable>，如果有）只包含外层变量则会产生一个异常：该聚集则属于最近的那个外层，并且会在那个查询的行上被计算。该聚集表达式从整体上则是对其所出现于的子查询的一种外层引用，并且在那个子查询的任意一次计算中都作为一个常量。只出现在结果列表或<literal>HAVING</literal>子句的限制适用于该聚集所属的查询层次。
   </para>
<!-- pgdoc-cn_end sig_en=66013fa5a82e6cccb66a07bc3c9a3547 -->
  </sect2>

  <sect2 id="syntax-window-functions">
<!-- pgdoc-cn_start sig_en=f7507ffa6eec89f45e6722a6ac47692f sig_cn_org=None source=14.1 
   <title>Window Function Calls</title>
________________________________________________________-->
   <title>窗口函数调用</title>
<!-- pgdoc-cn_end sig_en=f7507ffa6eec89f45e6722a6ac47692f -->

<!-- pgdoc-cn_start sig_en=463b6a5c47b689580eb0aa416edce71f sig_cn_org=None source=14.1 
   <indexterm zone="syntax-window-functions">
    <primary>window function</primary>
    <secondary>invocation</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="syntax-window-functions">
    <primary>窗口函数</primary>
    <secondary>invocation</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=463b6a5c47b689580eb0aa416edce71f -->

<!-- pgdoc-cn_start sig_en=ec3cdce68989a8ea68e749fa5fdef649 sig_cn_org=None source=14.1 
   <indexterm zone="syntax-window-functions">
    <primary>OVER clause</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="syntax-window-functions">
    <primary>OVER clause</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=ec3cdce68989a8ea68e749fa5fdef649 -->

<!-- pgdoc-cn_start sig_en=360e417c06efcf3f74f784b2219c5991 sig_cn_org=None source=14.1 
   <para>
    A <firstterm>window function call</firstterm> represents the application
    of an aggregate-like function over some portion of the rows selected
    by a query.  Unlike non-window aggregate calls, this is not tied
    to grouping of the selected rows into a single output row &mdash; each
    row remains separate in the query output.  However the window function
    has access to all the rows that would be part of the current row's
    group according to the grouping specification (<literal>PARTITION BY</literal>
    list) of the window function call.
    The syntax of a window function call is one of the following:

<synopsis>
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional>) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER <replaceable>window_name</replaceable>
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional>) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER ( <replaceable class="parameter">window_definition</replaceable> )
<replaceable>function_name</replaceable> ( * ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER <replaceable>window_name</replaceable>
<replaceable>function_name</replaceable> ( * ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER ( <replaceable class="parameter">window_definition</replaceable> )
</synopsis>
    where <replaceable class="parameter">window_definition</replaceable>
    has the syntax
<synopsis>
[ <replaceable class="parameter">existing_window_name</replaceable> ]
[ PARTITION BY <replaceable class="parameter">expression</replaceable> [, ...] ]
[ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operator</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <replaceable class="parameter">frame_clause</replaceable> ]
</synopsis>
    The optional <replaceable class="parameter">frame_clause</replaceable>
    can be one of
<synopsis>
{ RANGE | ROWS | GROUPS } <replaceable>frame_start</replaceable> [ <replaceable>frame_exclusion</replaceable> ]
{ RANGE | ROWS | GROUPS } BETWEEN <replaceable>frame_start</replaceable> AND <replaceable>frame_end</replaceable> [ <replaceable>frame_exclusion</replaceable> ]
</synopsis>
    where <replaceable>frame_start</replaceable>
    and <replaceable>frame_end</replaceable> can be one of
<synopsis>
UNBOUNDED PRECEDING
<replaceable>offset</replaceable> PRECEDING
CURRENT ROW
<replaceable>offset</replaceable> FOLLOWING
UNBOUNDED FOLLOWING
</synopsis>
    and <replaceable>frame_exclusion</replaceable> can be one of
<synopsis>
EXCLUDE CURRENT ROW
EXCLUDE GROUP
EXCLUDE TIES
EXCLUDE NO OTHERS
</synopsis>
   </para>
________________________________________________________-->
   <para>
    一个<firstterm>窗口函数调用</firstterm>表示在一个查询选择的行的某个部分上应用一个聚集类的函数。和非窗口聚集函数调用不同，这不会被约束为将被选择的行分组为一个单一的输出行 &mdash; 在查询输出中每一个行仍保持独立。不过，窗口函数能够根据窗口函数调用的分组声明（<literal>PARTITION BY</literal>列表）访问属于当前行所在分组中的所有行。一个窗口函数调用的语法是下列之一：

<synopsis>
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional>) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER <replaceable>window_name</replaceable>
<replaceable>function_name</replaceable> (<optional><replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> ... </optional></optional>) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER ( <replaceable class="parameter">window_definition</replaceable> )
<replaceable>function_name</replaceable> ( * ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER <replaceable>window_name</replaceable>
<replaceable>function_name</replaceable> ( * ) [ FILTER ( WHERE <replaceable>filter_clause</replaceable> ) ] OVER ( <replaceable class="parameter">window_definition</replaceable> )
</synopsis>
    其中<replaceable class="parameter">window_definition</replaceable>的语法是
<synopsis>
[ <replaceable class="parameter">existing_window_name</replaceable> ]
[ PARTITION BY <replaceable class="parameter">expression</replaceable> [, ...] ]
[ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operator</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <replaceable class="parameter">frame_clause</replaceable> ]
</synopsis>
    可选的<replaceable class="parameter">frame_clause</replaceable>是下列之一
<synopsis>
{ RANGE | ROWS | GROUPS } <replaceable>frame_start</replaceable> [ <replaceable>frame_exclusion</replaceable> ]
{ RANGE | ROWS | GROUPS } BETWEEN <replaceable>frame_start</replaceable> AND <replaceable>frame_end</replaceable> [ <replaceable>frame_exclusion</replaceable> ]
</synopsis>
    其中<replaceable>frame_start</replaceable>和<replaceable>frame_end</replaceable>可以是下面形式中的一种
<synopsis>
UNBOUNDED PRECEDING
<replaceable>offset</replaceable> PRECEDING
CURRENT ROW
<replaceable>offset</replaceable> FOLLOWING
UNBOUNDED FOLLOWING
</synopsis>
    而<replaceable>frame_exclusion</replaceable>可以是下列之一
<synopsis>
EXCLUDE CURRENT ROW
EXCLUDE GROUP
EXCLUDE TIES
EXCLUDE NO OTHERS
</synopsis>
   </para>
<!-- pgdoc-cn_end sig_en=360e417c06efcf3f74f784b2219c5991 -->

<!-- pgdoc-cn_start sig_en=6df36452a458f81f005ab501eaa79313 sig_cn_org=None source=14.1 
   <para>
    Here, <replaceable>expression</replaceable> represents any value
    expression that does not itself contain window function calls.
   </para>
________________________________________________________-->
   <para>
    这里，<replaceable>expression</replaceable>表示任何自身不含有窗口函数调用的值表达式。
   </para>
<!-- pgdoc-cn_end sig_en=6df36452a458f81f005ab501eaa79313 -->

<!-- pgdoc-cn_start sig_en=6be124cb9b7b962d6b3904bd3e711801 sig_cn_org=None source=14.1 
   <para>
    <replaceable>window_name</replaceable> is a reference to a named window
    specification defined in the query's <literal>WINDOW</literal> clause.
    Alternatively, a full <replaceable>window_definition</replaceable> can
    be given within parentheses, using the same syntax as for defining a
    named window in the <literal>WINDOW</literal> clause; see the
    <xref linkend="sql-select"/> reference page for details.  It's worth
    pointing out that <literal>OVER wname</literal> is not exactly equivalent to
    <literal>OVER (wname ...)</literal>; the latter implies copying and modifying the
    window definition, and will be rejected if the referenced window
    specification includes a frame clause.
   </para>
________________________________________________________-->
   <para>
    <replaceable>window_name</replaceable>是对定义在查询的<literal>WINDOW</literal>子句中的一个命名窗口声明的引用。还可以使用在<literal>WINDOW</literal>子句中定义命名窗口的相同语法在圆括号内给定一个完整的<replaceable>window_definition</replaceable>，详见<xref linkend="sql-select"/>参考页。值得指出的是，<literal>OVER wname</literal>并不严格地等价于<literal>OVER (wname ...)</literal>，后者表示复制并修改窗口定义，并且在被引用窗口声明包括一个帧子句时会被拒绝。
   </para>
<!-- pgdoc-cn_end sig_en=6be124cb9b7b962d6b3904bd3e711801 -->

<!-- pgdoc-cn_start sig_en=e1148dc6a32ee719ea976b590c1fdc33 sig_cn_org=None source=14.1 
   <para>
    The <literal>PARTITION BY</literal> clause groups the rows of the query into
    <firstterm>partitions</firstterm>, which are processed separately by the window
    function.  <literal>PARTITION BY</literal> works similarly to a query-level
    <literal>GROUP BY</literal> clause, except that its expressions are always just
    expressions and cannot be output-column names or numbers.
    Without <literal>PARTITION BY</literal>, all rows produced by the query are
    treated as a single partition.
    The <literal>ORDER BY</literal> clause determines the order in which the rows
    of a partition are processed by the window function.  It works similarly
    to a query-level <literal>ORDER BY</literal> clause, but likewise cannot use
    output-column names or numbers.  Without <literal>ORDER BY</literal>, rows are
    processed in an unspecified order.
   </para>
________________________________________________________-->
   <para>
    <literal>PARTITION BY</literal>选项将查询的行分组成为<firstterm>分区</firstterm>，窗口函数会独立地处理它们。<literal>PARTITION BY</literal>工作起来类似于一个查询级别的<literal>GROUP BY</literal>子句，不过它的表达式总是只是表达式并且不能是输出列的名称或编号。如果没有<literal>PARTITION BY</literal>，该查询产生的所有行被当作一个单一分区来处理。<literal>ORDER BY</literal>选项决定被窗口函数处理的一个分区中的行的顺序。它工作起来类似于一个查询级别的<literal>ORDER BY</literal>子句，但是同样不能使用输出列的名称或编号。如果没有<literal>ORDER BY</literal>，行将被以未指定的顺序被处理。
   </para>
<!-- pgdoc-cn_end sig_en=e1148dc6a32ee719ea976b590c1fdc33 -->

<!-- pgdoc-cn_start sig_en=37ce1345644a52ecba6115263d2f1464 sig_cn_org=None source=14.1 
   <para>
    The <replaceable class="parameter">frame_clause</replaceable> specifies
    the set of rows constituting the <firstterm>window frame</firstterm>, which is a
    subset of the current partition, for those window functions that act on
    the frame instead of the whole partition.  The set of rows in the frame
    can vary depending on which row is the current row.  The frame can be
    specified in <literal>RANGE</literal>, <literal>ROWS</literal>
    or <literal>GROUPS</literal> mode; in each case, it runs from
    the <replaceable>frame_start</replaceable> to
    the <replaceable>frame_end</replaceable>.
    If <replaceable>frame_end</replaceable> is omitted, the end defaults
    to <literal>CURRENT ROW</literal>.
   </para>
________________________________________________________-->
   <para>
    <replaceable class="parameter">frame_clause</replaceable>指定构成<firstterm>窗口帧</firstterm>的行集合，它是当前分区的一个子集，窗口函数将作用在该帧而不是整个分区。帧中的行集合会随着哪一行是当前行而变化。在<literal>RANGE</literal>、<literal>ROWS</literal>或者<literal>GROUPS</literal>模式中可以指定帧，在每一种情况下，帧的范围都是从<replaceable>frame_start</replaceable>到<replaceable>frame_end</replaceable>。如果<replaceable>frame_end</replaceable>被省略，则末尾默认为<literal>CURRENT ROW</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=37ce1345644a52ecba6115263d2f1464 -->

<!-- pgdoc-cn_start sig_en=f8bd9d15886064c6b9961c8239c4d90b sig_cn_org=None source=14.1 
   <para>
    A <replaceable>frame_start</replaceable> of <literal>UNBOUNDED PRECEDING</literal> means
    that the frame starts with the first row of the partition, and similarly
    a <replaceable>frame_end</replaceable> of <literal>UNBOUNDED FOLLOWING</literal> means
    that the frame ends with the last row of the partition.
   </para>
________________________________________________________-->
   <para>
    <literal>UNBOUNDED PRECEDING</literal>的一个<replaceable>frame_start</replaceable>表示该帧开始于分区的第一行，类似地<literal>UNBOUNDED FOLLOWING</literal>的一个<replaceable>frame_end</replaceable>表示该帧结束于分区的最后一行。
   </para>
<!-- pgdoc-cn_end sig_en=f8bd9d15886064c6b9961c8239c4d90b -->

<!-- pgdoc-cn_start sig_en=ac9a0f6ae14f779b4995de5bac907dd2 sig_cn_org=None source=14.1 
   <para>
    In <literal>RANGE</literal> or <literal>GROUPS</literal> mode,
    a <replaceable>frame_start</replaceable> of
    <literal>CURRENT ROW</literal> means the frame starts with the current
    row's first <firstterm>peer</firstterm> row (a row that the
    window's <literal>ORDER BY</literal> clause sorts as equivalent to the
    current row), while a <replaceable>frame_end</replaceable> of
    <literal>CURRENT ROW</literal> means the frame ends with the current
    row's last peer row.
    In <literal>ROWS</literal> mode, <literal>CURRENT ROW</literal> simply
    means the current row.
   </para>
________________________________________________________-->
   <para>
    在<literal>RANGE</literal>或<literal>GROUPS</literal>模式中，<literal>CURRENT ROW</literal>的一个<replaceable>frame_start</replaceable>表示帧开始于当前行的第一个<firstterm>平级</firstterm>行（被窗口的<literal>ORDER BY</literal>子句排序为与当前行等效的行），而<literal>CURRENT ROW</literal>的一个<replaceable>frame_end</replaceable>表示帧结束于当前行的最后一个平级行。在<literal>ROWS</literal>模式中，<literal>CURRENT ROW</literal>就表示当前行。
   </para>
<!-- pgdoc-cn_end sig_en=ac9a0f6ae14f779b4995de5bac907dd2 -->

<!-- pgdoc-cn_start sig_en=3cd4fc7f092b63447c07a436b6f2cee4 sig_cn_org=None source=14.1 
   <para>
    In the <replaceable>offset</replaceable> <literal>PRECEDING</literal>
    and <replaceable>offset</replaceable> <literal>FOLLOWING</literal> frame
    options, the <replaceable>offset</replaceable> must be an expression not
    containing any variables, aggregate functions, or window functions.
    The meaning of the <replaceable>offset</replaceable> depends on the
    frame mode:
    <itemizedlist>
     <listitem>
      <para>
       In <literal>ROWS</literal> mode,
       the <replaceable>offset</replaceable> must yield a non-null,
       non-negative integer, and the option means that the frame starts or
       ends the specified number of rows before or after the current row.
      </para>
     </listitem>
     <listitem>
      <para>
       In <literal>GROUPS</literal> mode,
       the <replaceable>offset</replaceable> again must yield a non-null,
       non-negative integer, and the option means that the frame starts or
       ends the specified number of <firstterm>peer groups</firstterm>
       before or after the current row's peer group, where a peer group is a
       set of rows that are equivalent in the <literal>ORDER BY</literal>
       ordering.  (There must be an <literal>ORDER BY</literal> clause
       in the window definition to use <literal>GROUPS</literal> mode.)
      </para>
     </listitem>
     <listitem>
      <para>
       In <literal>RANGE</literal> mode, these options require that
       the <literal>ORDER BY</literal> clause specify exactly one column.
       The <replaceable>offset</replaceable> specifies the maximum
       difference between the value of that column in the current row and
       its value in preceding or following rows of the frame.  The data type
       of the <replaceable>offset</replaceable> expression varies depending
       on the data type of the ordering column.  For numeric ordering
       columns it is typically of the same type as the ordering column,
       but for datetime ordering columns it is an <type>interval</type>.
       For example, if the ordering column is of type <type>date</type>
       or <type>timestamp</type>, one could write <literal>RANGE BETWEEN
       '1 day' PRECEDING AND '10 days' FOLLOWING</literal>.
       The <replaceable>offset</replaceable> is still required to be
       non-null and non-negative, though the meaning
       of <quote>non-negative</quote> depends on its data type.
      </para>
     </listitem>
    </itemizedlist>
    In any case, the distance to the end of the frame is limited by the
    distance to the end of the partition, so that for rows near the partition
    ends the frame might contain fewer rows than elsewhere.
   </para>
________________________________________________________-->
   <para>
    在<replaceable>offset</replaceable> <literal>PRECEDING</literal>以及<replaceable>offset</replaceable> <literal>FOLLOWING</literal>帧选项中，<replaceable>offset</replaceable>必须是一个不包含任何变量、聚集函数或者窗口函数的表达式。<replaceable>offset</replaceable>的含义取决于帧模式：
    <itemizedlist>
     <listitem>
      <para>
       在<literal>ROWS</literal>模式中，<replaceable>offset</replaceable>必须得到一个非空、非负的整数，并且该选项表示帧开始于当前行之前或者之后指定数量的行。
      </para>
     </listitem>
     <listitem>
      <para>
       在<literal>GROUPS</literal>模式中，<replaceable>offset</replaceable>也必须得到一个非空、非负的整数，并且该选项表示帧开始于当前行的平级组之前或者之后指定数量的<firstterm>平级组</firstterm>，这里平级组是在<literal>ORDER BY</literal>顺序中等效的行集合（要使用<literal>GROUPS</literal>模式，在窗口定义中就必须有一个<literal>ORDER BY</literal>子句）。
      </para>
     </listitem>
     <listitem>
      <para>
       在<literal>RANGE</literal>模式中，这些选项要求<literal>ORDER BY</literal>子句正好指定一列。<replaceable>offset</replaceable>指定当前行中那一列的值与它在该帧中前面或后面的行中的列值的最大差值。<replaceable>offset</replaceable>表达式的数据类型会随着排序列的数据类型而变化。对于数字的排序列，它通常是与排序列相同的类型，但对于日期时间排序列它是一个<type>interval</type>。例如，如果排序列是类型<type>date</type>或者<type>timestamp</type>，我们可以写<literal>RANGE BETWEEN '1 day' PRECEDING AND '10 days' FOLLOWING</literal>。<replaceable>offset</replaceable>仍然要求是非空且非负，不过<quote>非负</quote>的含义取决于它的数据类型。
      </para>
     </listitem>
    </itemizedlist>
    在任何一种情况下，到帧末尾的距离都受限于到分区末尾的距离，因此对于离分区末尾比较近的行来说，帧可能会包含比较少的行。
   </para>
<!-- pgdoc-cn_end sig_en=3cd4fc7f092b63447c07a436b6f2cee4 -->

<!-- pgdoc-cn_start sig_en=26157c103e60eb5d9381db6d62104118 sig_cn_org=None source=14.1 
   <para>
    Notice that in both <literal>ROWS</literal> and <literal>GROUPS</literal>
    mode, <literal>0 PRECEDING</literal> and <literal>0 FOLLOWING</literal>
    are equivalent to <literal>CURRENT ROW</literal>.  This normally holds
    in <literal>RANGE</literal> mode as well, for an appropriate
    data-type-specific meaning of <quote>zero</quote>.
   </para>
________________________________________________________-->
   <para>
    注意在<literal>ROWS</literal>以及<literal>GROUPS</literal>模式中，<literal>0 PRECEDING</literal>和<literal>0 FOLLOWING</literal>与<literal>CURRENT ROW</literal>等效。通常在<literal>RANGE</literal>模式中，这个结论也成立（只要有一种合适的、与数据类型相关的<quote>零</quote>的含义）。
   </para>
<!-- pgdoc-cn_end sig_en=26157c103e60eb5d9381db6d62104118 -->

<!-- pgdoc-cn_start sig_en=15386d9382630abfcab114a363366871 sig_cn_org=None source=14.1 
   <para>
    The <replaceable>frame_exclusion</replaceable> option allows rows around
    the current row to be excluded from the frame, even if they would be
    included according to the frame start and frame end options.
    <literal>EXCLUDE CURRENT ROW</literal> excludes the current row from the
    frame.
    <literal>EXCLUDE GROUP</literal> excludes the current row and its
    ordering peers from the frame.
    <literal>EXCLUDE TIES</literal> excludes any peers of the current
    row from the frame, but not the current row itself.
    <literal>EXCLUDE NO OTHERS</literal> simply specifies explicitly the
    default behavior of not excluding the current row or its peers.
   </para>
________________________________________________________-->
   <para>
    <replaceable>frame_exclusion</replaceable>选项允许当前行周围的行被排除在帧之外，即便根据帧的开始和结束选项应该把它们包括在帧中。<literal>EXCLUDE CURRENT ROW</literal>会把当前行排除在帧之外。<literal>EXCLUDE GROUP</literal>会把当前行以及它在顺序上的平级行都排除在帧之外。<literal>EXCLUDE TIES</literal>把当前行的任何平级行都从帧中排除，但不排除当前行本身。<literal>EXCLUDE NO OTHERS</literal>只是明确地指定不排除当前行或其平级行的这种默认行为。
   </para>
<!-- pgdoc-cn_end sig_en=15386d9382630abfcab114a363366871 -->

<!-- pgdoc-cn_start sig_en=995d37514882a805c781680f942ab1a3 sig_cn_org=None source=14.1 
   <para>
    The default framing option is <literal>RANGE UNBOUNDED PRECEDING</literal>,
    which is the same as <literal>RANGE BETWEEN UNBOUNDED PRECEDING AND
    CURRENT ROW</literal>.  With <literal>ORDER BY</literal>, this sets the frame to be
    all rows from the partition start up through the current row's last
    <literal>ORDER BY</literal> peer.  Without <literal>ORDER BY</literal>,
    this means all rows of the partition are included in the window frame,
    since all rows become peers of the current row.
   </para>
________________________________________________________-->
   <para>
    默认的帧选项是<literal>RANGE UNBOUNDED PRECEDING</literal>，它和<literal>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</literal>相同。如果使用<literal>ORDER BY</literal>，这会把该帧设置为从分区开始一直到当前行的最后一个<literal>ORDER BY</literal>平级行的所有行。如果不使用<literal>ORDER BY</literal>，就意味着分区中所有的行都被包括在窗口帧中，因为所有行都成为了当前行的平级行。
   </para>
<!-- pgdoc-cn_end sig_en=995d37514882a805c781680f942ab1a3 -->

<!-- pgdoc-cn_start sig_en=89eb8aa87618b0d87a91ad486a3eff81 sig_cn_org=None source=14.1 
   <para>
    Restrictions are that
    <replaceable>frame_start</replaceable> cannot be <literal>UNBOUNDED FOLLOWING</literal>,
    <replaceable>frame_end</replaceable> cannot be <literal>UNBOUNDED PRECEDING</literal>,
    and the <replaceable>frame_end</replaceable> choice cannot appear earlier in the
    above list of <replaceable>frame_start</replaceable>
    and <replaceable>frame_end</replaceable> options than
    the <replaceable>frame_start</replaceable> choice does &mdash; for example
    <literal>RANGE BETWEEN CURRENT ROW AND <replaceable>offset</replaceable>
    PRECEDING</literal> is not allowed.
    But, for example, <literal>ROWS BETWEEN 7 PRECEDING AND 8
    PRECEDING</literal> is allowed, even though it would never select any
    rows.
   </para>
________________________________________________________-->
   <para>
    限制是<replaceable>frame_start</replaceable>不能是<literal>UNBOUNDED FOLLOWING</literal>、<replaceable>frame_end</replaceable>不能是<literal>UNBOUNDED PRECEDING</literal>，并且在上述<replaceable>frame_start</replaceable>和<replaceable>frame_end</replaceable>选项的列表中<replaceable>frame_end</replaceable>选择不能早于<replaceable>frame_start</replaceable>选择出现 &mdash; 例如不允许<literal>RANGE BETWEEN CURRENT ROW AND <replaceable>offset</replaceable> PRECEDING</literal>，但允许<literal>ROWS BETWEEN 7 PRECEDING AND 8 PRECEDING</literal>，虽然它不会选择任何行。
   </para>
<!-- pgdoc-cn_end sig_en=89eb8aa87618b0d87a91ad486a3eff81 -->

<!-- pgdoc-cn_start sig_en=350d035ba92c9ae5fdcc811b6eda6dd1 sig_cn_org=None source=14.1 
   <para>
    If <literal>FILTER</literal> is specified, then only the input
    rows for which the <replaceable>filter_clause</replaceable>
    evaluates to true are fed to the window function; other rows
    are discarded.  Only window functions that are aggregates accept
    a <literal>FILTER</literal> clause.
   </para>
________________________________________________________-->
   <para>
    如果指定了<literal>FILTER</literal>，那么只有对<replaceable>filter_clause</replaceable>计算为真的输入行会被交给该窗口函数，其他行会被丢弃。只有是聚集的窗口函数才接受<literal>FILTER</literal> 。
   </para>
<!-- pgdoc-cn_end sig_en=350d035ba92c9ae5fdcc811b6eda6dd1 -->

<!-- pgdoc-cn_start sig_en=bfb91010f140ea7600eb003e2c5e853b sig_cn_org=None source=14.1 
   <para>
    The built-in window functions are described in <xref
    linkend="functions-window-table"/>.  Other window functions can be added by
    the user.  Also, any built-in or user-defined general-purpose or
    statistical aggregate can be used as a window function.  (Ordered-set
    and hypothetical-set aggregates cannot presently be used as window functions.)
   </para>
________________________________________________________-->
   <para>
    内建的窗口函数在<xref linkend="functions-window-table"/>中介绍。用户可以加入其他窗口函数。此外，任何内建的或者用户定义的通用聚集或者统计性聚集都可以被用作窗口函数（有序集和假想集聚集当前不能被用作窗口函数）。
   </para>
<!-- pgdoc-cn_end sig_en=bfb91010f140ea7600eb003e2c5e853b -->

<!-- pgdoc-cn_start sig_en=0cff0c4dcd15dc95362a4374ec2a570e sig_cn_org=None source=14.1 
   <para>
    The syntaxes using <literal>*</literal> are used for calling parameter-less
    aggregate functions as window functions, for example
    <literal>count(*) OVER (PARTITION BY x ORDER BY y)</literal>.
    The asterisk (<literal>*</literal>) is customarily not used for
    window-specific functions.  Window-specific functions do not
    allow <literal>DISTINCT</literal> or <literal>ORDER BY</literal> to be used within the
    function argument list.
   </para>
________________________________________________________-->
   <para>
    使用<literal>*</literal>的语法被用来把参数较少的聚集函数当作窗口函数调用，例如<literal>count(*) OVER (PARTITION BY x ORDER BY y)</literal>。星号（<literal>*</literal>）通常不被用于窗口相关的函数。窗口相关的函数不允许在函数参数列表中使用<literal>DISTINCT</literal>或<literal>ORDER BY</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=0cff0c4dcd15dc95362a4374ec2a570e -->

<!-- pgdoc-cn_start sig_en=50383dc9e499fd70d1b3d2b1bcbf171d sig_cn_org=None source=14.1 
   <para>
    Window function calls are permitted only in the <literal>SELECT</literal>
    list and the <literal>ORDER BY</literal> clause of the query.
   </para>
________________________________________________________-->
   <para>
    只有在<literal>SELECT</literal>列表和查询的<literal>ORDER BY</literal>子句中才允许窗口函数调用。
   </para>
<!-- pgdoc-cn_end sig_en=50383dc9e499fd70d1b3d2b1bcbf171d -->

<!-- pgdoc-cn_start sig_en=7317ea6a5eed232dd79eeedc833e1070 sig_cn_org=None source=14.1 
   <para>
    More information about window functions can be found in
    <xref linkend="tutorial-window"/>,
    <xref linkend="functions-window"/>, and
    <xref linkend="queries-window"/>.
   </para>
________________________________________________________-->
   <para>
    更多关于窗口函数的信息可以在<xref linkend="tutorial-window"/>、<xref linkend="functions-window"/>以及<xref linkend="queries-window"/>中找到。
   </para>
<!-- pgdoc-cn_end sig_en=7317ea6a5eed232dd79eeedc833e1070 -->
  </sect2>

  <sect2 id="sql-syntax-type-casts">
<!-- pgdoc-cn_start sig_en=247acfbdfdd1d3a5560d84a8b5c5147c sig_cn_org=None source=14.1 
   <title>Type Casts</title>
________________________________________________________-->
   <title>类型转换</title>
<!-- pgdoc-cn_end sig_en=247acfbdfdd1d3a5560d84a8b5c5147c -->

<!-- pgdoc-cn_start sig_en=753d40288d2b9120e7762d7f80a21ad5 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>data type</primary>
    <secondary>type cast</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>data type</primary>
    <secondary>type cast</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=753d40288d2b9120e7762d7f80a21ad5 -->

<!-- pgdoc-cn_start sig_en=82d8bf1cdf223c23d9cef6b6bcf93263 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>type cast</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>type cast</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=82d8bf1cdf223c23d9cef6b6bcf93263 -->

<!-- pgdoc-cn_start sig_en=c2a753ebc529ee27a63931ccbd0a306a sig_cn_org=None source=14.1 
   <indexterm>
    <primary>::</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>::</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=c2a753ebc529ee27a63931ccbd0a306a -->

<!-- pgdoc-cn_start sig_en=27f7984caed2f3ec8d4abfb1e803e35d sig_cn_org=None source=14.1 
   <para>
    A type cast specifies a conversion from one data type to another.
    <productname>PostgreSQL</productname> accepts two equivalent syntaxes
    for type casts:
<synopsis>
CAST ( <replaceable>expression</replaceable> AS <replaceable>type</replaceable> )
<replaceable>expression</replaceable>::<replaceable>type</replaceable>
</synopsis>
    The <literal>CAST</literal> syntax conforms to SQL; the syntax with
    <literal>::</literal> is historical <productname>PostgreSQL</productname>
    usage.
   </para>
________________________________________________________-->
   <para>
    一个类型造型指定从一种数据类型到另一种数据类型的转换。<productname>PostgreSQL</productname>接受两种等价的类型造型语法：
<synopsis>
CAST ( <replaceable>expression</replaceable> AS <replaceable>type</replaceable> )
<replaceable>expression</replaceable>::<replaceable>type</replaceable>
</synopsis>
    <literal>CAST</literal>语法遵从 SQL，而用<literal>::</literal>的语法是<productname>PostgreSQL</productname>的历史用法。
   </para>
<!-- pgdoc-cn_end sig_en=27f7984caed2f3ec8d4abfb1e803e35d -->

<!-- pgdoc-cn_start sig_en=dfe03a3a36aa702e712e0dd3d5d6f5b6 sig_cn_org=None source=14.1 
   <para>
    When a cast is applied to a value expression of a known type, it
    represents a run-time type conversion.  The cast will succeed only
    if a suitable type conversion operation has been defined.  Notice that this
    is subtly different from the use of casts with constants, as shown in
    <xref linkend="sql-syntax-constants-generic"/>.  A cast applied to an
    unadorned string literal represents the initial assignment of a type
    to a literal constant value, and so it will succeed for any type
    (if the contents of the string literal are acceptable input syntax for the
    data type).
   </para>
________________________________________________________-->
   <para>
    当一个造型被应用到一种未知类型的值表达式上时，它表示一种运行时类型转换。只有已经定义了一种合适的类型转换操作时，该造型才会成功。注意这和常量的造型（如<xref linkend="sql-syntax-constants-generic"/>中所示）使用不同。应用于一个未修饰串文字的造型表示一种类型到一个文字常量值的初始赋值，并且因此它将对任意类型都成功（如果该串文字的内容对于该数据类型的输入语法是可接受的）。
   </para>
<!-- pgdoc-cn_end sig_en=dfe03a3a36aa702e712e0dd3d5d6f5b6 -->

<!-- pgdoc-cn_start sig_en=bd724c86fe4434cbfd0126480a36da55 sig_cn_org=None source=14.1 
   <para>
    An explicit type cast can usually be omitted if there is no ambiguity as
    to the type that a value expression must produce (for example, when it is
    assigned to a table column); the system will automatically apply a
    type cast in such cases.  However, automatic casting is only done for
    casts that are marked <quote>OK to apply implicitly</quote>
    in the system catalogs.  Other casts must be invoked with
    explicit casting syntax.  This restriction is intended to prevent
    surprising conversions from being applied silently.
   </para>
________________________________________________________-->
   <para>
    如果一个值表达式必须产生的类型没有歧义（例如当它被指派给一个表列），通常可以省略显式类型造型，在这种情况下系统会自动应用一个类型造型。但是，只有对在系统目录中被标记为<quote>OK to apply implicitly</quote>的造型才会执行自动造型。其他造型必须使用显式造型语法调用。这种限制是为了防止出人意料的转换被无声无息地应用。
   </para>
<!-- pgdoc-cn_end sig_en=bd724c86fe4434cbfd0126480a36da55 -->

<!-- pgdoc-cn_start sig_en=2a2cf5e779fb5ca0c4428e0966626418 sig_cn_org=None source=14.1 
   <para>
    It is also possible to specify a type cast using a function-like
    syntax:
<synopsis>
<replaceable>typename</replaceable> ( <replaceable>expression</replaceable> )
</synopsis>
    However, this only works for types whose names are also valid as
    function names.  For example, <literal>double precision</literal>
    cannot be used this way, but the equivalent <literal>float8</literal>
    can.  Also, the names <literal>interval</literal>, <literal>time</literal>, and
    <literal>timestamp</literal> can only be used in this fashion if they are
    double-quoted, because of syntactic conflicts.  Therefore, the use of
    the function-like cast syntax leads to inconsistencies and should
    probably be avoided.
   </para>
________________________________________________________-->
   <para>
    还可以用像函数的语法来指定一次类型造型：
<synopsis>
<replaceable>typename</replaceable> ( <replaceable>expression</replaceable> )
</synopsis>
    不过，这只对那些名字也作为函数名可用的类型有效。例如，<literal>double precision</literal>不能以这种方式使用，但是等效的<literal>float8</literal>可以。还有，如果名称<literal>interval</literal>、<literal>time</literal>和<literal>timestamp</literal>被用双引号引用，那么由于语法冲突的原因，它们只能以这种风格使用。因此，函数风格的造型语法的使用会导致不一致性并且应该尽可能被避免。
   </para>
<!-- pgdoc-cn_end sig_en=2a2cf5e779fb5ca0c4428e0966626418 -->

   <note>
<!-- pgdoc-cn_start sig_en=3f16a7dc5f6431f00026eae6518abfc1 sig_cn_org=None source=14.1 
    <para>
     The function-like syntax is in fact just a function call.  When
     one of the two standard cast syntaxes is used to do a run-time
     conversion, it will internally invoke a registered function to
     perform the conversion.  By convention, these conversion functions
     have the same name as their output type, and thus the <quote>function-like
     syntax</quote> is nothing more than a direct invocation of the underlying
     conversion function.  Obviously, this is not something that a portable
     application should rely on.  For further details see
     <xref linkend="sql-createcast"/>.
    </para>
________________________________________________________-->
    <para>
     函数风格的语法事实上只是一次函数调用。当两种标准造型语法之一被用来做一次运行时转换时，它将在内部调用一个已注册的函数来执行该转换。简而言之，这些转换函数具有和它们的输出类型相同的名字，并且因此<quote>函数风格的语法</quote>无非是对底层转换函数的一次直接调用。显然，一个可移植的应用不应当依赖于它。详见<xref linkend="sql-createcast"/>。
    </para>
<!-- pgdoc-cn_end sig_en=3f16a7dc5f6431f00026eae6518abfc1 -->
   </note>
  </sect2>

  <sect2 id="sql-syntax-collate-exprs">
<!-- pgdoc-cn_start sig_en=3a519b9c192450b66afd7c8134bb1742 sig_cn_org=None source=14.1 
   <title>Collation Expressions</title>
________________________________________________________-->
   <title>排序规则表达式</title>
<!-- pgdoc-cn_end sig_en=3a519b9c192450b66afd7c8134bb1742 -->

<!-- pgdoc-cn_start sig_en=e163efb646eb324121927ef7e5ba6179 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>COLLATE</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>COLLATE</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=e163efb646eb324121927ef7e5ba6179 -->

<!-- pgdoc-cn_start sig_en=144701713148748406b635dc1c3be140 sig_cn_org=None source=14.1 
   <para>
    The <literal>COLLATE</literal> clause overrides the collation of
    an expression.  It is appended to the expression it applies to:
<synopsis>
<replaceable>expr</replaceable> COLLATE <replaceable>collation</replaceable>
</synopsis>
    where <replaceable>collation</replaceable> is a possibly
    schema-qualified identifier.  The <literal>COLLATE</literal>
    clause binds tighter than operators; parentheses can be used when
    necessary.
   </para>
________________________________________________________-->
   <para>
    <literal>COLLATE</literal>子句会重载一个表达式的排序规则。它被追加到它适用的表达式：
<synopsis>
<replaceable>expr</replaceable> COLLATE <replaceable>collation</replaceable>
</synopsis>
    这里<replaceable>collation</replaceable>可能是一个受模式限定的标识符。<literal>COLLATE</literal>子句比操作符绑得更紧，需要时可以使用圆括号。
   </para>
<!-- pgdoc-cn_end sig_en=144701713148748406b635dc1c3be140 -->

<!-- pgdoc-cn_start sig_en=5cd260e0c023a1c24492c264d74f926f sig_cn_org=None source=14.1 
   <para>
    If no collation is explicitly specified, the database system
    either derives a collation from the columns involved in the
    expression, or it defaults to the default collation of the
    database if no column is involved in the expression.
   </para>
________________________________________________________-->
   <para>
    如果没有显式指定排序规则，数据库系统会从表达式所涉及的列中得到一个排序规则，如果该表达式没有涉及列，则会默认采用数据库的默认排序规则。
   </para>
<!-- pgdoc-cn_end sig_en=5cd260e0c023a1c24492c264d74f926f -->

<!-- pgdoc-cn_start sig_en=dadca6629ee5540369fb4ed01660a045 sig_cn_org=None source=14.1 
   <para>
    The two common uses of the <literal>COLLATE</literal> clause are
    overriding the sort order in an <literal>ORDER BY</literal> clause, for
    example:
<programlisting>
SELECT a, b, c FROM tbl WHERE ... ORDER BY a COLLATE "C";
</programlisting>
    and overriding the collation of a function or operator call that
    has locale-sensitive results, for example:
<programlisting>
SELECT * FROM tbl WHERE a &gt; 'foo' COLLATE "C";
</programlisting>
    Note that in the latter case the <literal>COLLATE</literal> clause is
    attached to an input argument of the operator we wish to affect.
    It doesn't matter which argument of the operator or function call the
    <literal>COLLATE</literal> clause is attached to, because the collation that is
    applied by the operator or function is derived by considering all
    arguments, and an explicit <literal>COLLATE</literal> clause will override the
    collations of all other arguments.  (Attaching non-matching
    <literal>COLLATE</literal> clauses to more than one argument, however, is an
    error.  For more details see <xref linkend="collation"/>.)
    Thus, this gives the same result as the previous example:
<programlisting>
SELECT * FROM tbl WHERE a COLLATE "C" &gt; 'foo';
</programlisting>
    But this is an error:
<programlisting>
SELECT * FROM tbl WHERE (a &gt; 'foo') COLLATE "C";
</programlisting>
    because it attempts to apply a collation to the result of the
    <literal>&gt;</literal> operator, which is of the non-collatable data type
    <type>boolean</type>.
   </para>
________________________________________________________-->
   <para>
    <literal>COLLATE</literal>子句的两种常见使用是重载<literal>ORDER BY</literal>子句中的排序顺序，例如：
<programlisting>
SELECT a, b, c FROM tbl WHERE ... ORDER BY a COLLATE "C";
</programlisting>
    以及重载具有区域敏感结果的函数或操作符调用的排序规则，例如：
<programlisting>
SELECT * FROM tbl WHERE a &gt; 'foo' COLLATE "C";
</programlisting>
    注意在后一种情况中，<literal>COLLATE</literal>子句被附加到我们希望影响的操作符的一个输入参数上。<literal>COLLATE</literal>子句被附加到该操作符或函数调用的哪个参数上无关紧要，因为被操作符或函数应用的排序规则是考虑所有参数得来的，并且一个显式的<literal>COLLATE</literal>子句将重载所有其他参数的排序规则（不过，附加非匹配<literal>COLLATE</literal>子句到多于一个参数是一种错误。详见<xref linkend="collation"/>）。因此，这会给出和前一个例子相同的结果：
<programlisting>
SELECT * FROM tbl WHERE a COLLATE "C" &gt; 'foo';
</programlisting>
    但是这是一个错误：
<programlisting>
SELECT * FROM tbl WHERE (a &gt; 'foo') COLLATE "C";
</programlisting>
    因为它尝试把一个排序规则应用到<literal>&gt;</literal>操作符的结果，而它的数据类型是非可排序数据类型<type>boolean</type>。
   </para>
<!-- pgdoc-cn_end sig_en=dadca6629ee5540369fb4ed01660a045 -->
  </sect2>

  <sect2 id="sql-syntax-scalar-subqueries">
<!-- pgdoc-cn_start sig_en=ad92641a295c137242102b68eb9f641e sig_cn_org=None source=14.1 
   <title>Scalar Subqueries</title>
________________________________________________________-->
   <title>标量子查询</title>
<!-- pgdoc-cn_end sig_en=ad92641a295c137242102b68eb9f641e -->

<!-- pgdoc-cn_start sig_en=7436ee9b682d78ad0ae2c5be71ed5422 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>subquery</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>子查询</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=7436ee9b682d78ad0ae2c5be71ed5422 -->

<!-- pgdoc-cn_start sig_en=cfe16383e760a7cf2bd8ab9f482db210 sig_cn_org=None source=14.1 
   <para>
    A scalar subquery is an ordinary
    <command>SELECT</command> query in parentheses that returns exactly one
    row with one column.  (See <xref linkend="queries"/> for information about writing queries.)
    The <command>SELECT</command> query is executed
    and the single returned value is used in the surrounding value expression.
    It is an error to use a query that
    returns more than one row or more than one column as a scalar subquery.
    (But if, during a particular execution, the subquery returns no rows,
    there is no error; the scalar result is taken to be null.)
    The subquery can refer to variables from the surrounding query,
    which will act as constants during any one evaluation of the subquery.
    See also <xref linkend="functions-subquery"/> for other expressions involving subqueries.
   </para>
________________________________________________________-->
   <para>
    一个标量子查询是一种圆括号内的普通<command>SELECT</command>查询，它刚好返回一行一列（关于书写查询可见<xref linkend="queries"/>）。<command>SELECT</command>查询被执行并且该单一返回值被使用在周围的值表达式中。将一个返回超过一行或一列的查询作为一个标量子查询使用是一种错误（但是如果在一次特定执行期间该子查询没有返回行则不是错误，该标量结果被当做为空）。该子查询可以从周围的查询中引用变量，这些变量在该子查询的任何一次计算中都将作为常量。对于其他涉及子查询的表达式还可见<xref linkend="functions-subquery"/>。
   </para>
<!-- pgdoc-cn_end sig_en=cfe16383e760a7cf2bd8ab9f482db210 -->

<!-- pgdoc-cn_start sig_en=f9cd39bf2589750577565392dff5768f sig_cn_org=None source=14.1 
   <para>
    For example, the following finds the largest city population in each
    state:
<programlisting>
SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name)
    FROM states;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    例如，下列语句会寻找每个州中最大的城市人口：
<programlisting>
SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name)
    FROM states;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=f9cd39bf2589750577565392dff5768f -->
  </sect2>

  <sect2 id="sql-syntax-array-constructors">
<!-- pgdoc-cn_start sig_en=da6c580975a82093c6f8e42c9dd1a81a sig_cn_org=None source=14.1 
   <title>Array Constructors</title>
________________________________________________________-->
   <title>数组构造器</title>
<!-- pgdoc-cn_end sig_en=da6c580975a82093c6f8e42c9dd1a81a -->

<!-- pgdoc-cn_start sig_en=13525ebbe2f97946cb5ea3f8d458f111 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>array</primary>
    <secondary>constructor</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>数组</primary>
    <secondary>构造器</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=13525ebbe2f97946cb5ea3f8d458f111 -->

<!-- pgdoc-cn_start sig_en=89209b2e67db6948f41343165ed31358 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>ARRAY</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>ARRAY</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=89209b2e67db6948f41343165ed31358 -->

<!-- pgdoc-cn_start sig_en=f007a544996305e9e510e197e4e6a29e sig_cn_org=None source=14.1 
   <para>
    An array constructor is an expression that builds an
    array value using values for its member elements.  A simple array
    constructor
    consists of the key word <literal>ARRAY</literal>, a left square bracket
    <literal>[</literal>, a list of expressions (separated by commas) for the
    array element values, and finally a right square bracket <literal>]</literal>.
    For example:
<programlisting>
SELECT ARRAY[1,2,3+4];
  array
-&minus;-&minus;-&minus;-&minus;-
 {1,2,7}
(1 row)
</programlisting>
    By default,
    the array element type is the common type of the member expressions,
    determined using the same rules as for <literal>UNION</literal> or
    <literal>CASE</literal> constructs (see <xref linkend="typeconv-union-case"/>).
    You can override this by explicitly casting the array constructor to the
    desired type, for example:
<programlisting>
SELECT ARRAY[1,2,22.7]::integer[];
  array
-&minus;-&minus;-&minus;-&minus;-&minus;
 {1,2,23}
(1 row)
</programlisting>
    This has the same effect as casting each expression to the array
    element type individually.
    For more on casting, see <xref linkend="sql-syntax-type-casts"/>.
   </para>
________________________________________________________-->
   <para>
    一个数组构造器是一个能构建一个数组值并且将值用于它的成员元素的表达式。一个简单的数组构造器由关键词<literal>ARRAY</literal>、一个左方括号<literal>[</literal>、一个用于数组元素值的表达式列表（用逗号分隔）以及最后的一个右方括号<literal>]</literal>组成。例如：
<programlisting>
SELECT ARRAY[1,2,3+4];
  array
---------
 {1,2,7}
(1 row)
</programlisting>
    默认情况下，数组元素类型是成员表达式的公共类型，使用和<literal>UNION</literal>或<literal>CASE</literal>结构（见<xref linkend="typeconv-union-case"/>）相同的规则决定。你可以通过显式将数组构造器造型为想要的类型来重载，例如：
<programlisting>
SELECT ARRAY[1,2,22.7]::integer[];
  array
----------
 {1,2,23}
(1 row)
</programlisting>
    这和把每一个表达式单独地造型为数组元素类型的效果相同。关于造型的更多信息请见<xref linkend="sql-syntax-type-casts"/>。
   </para>
<!-- pgdoc-cn_end sig_en=f007a544996305e9e510e197e4e6a29e -->

<!-- pgdoc-cn_start sig_en=8c6477e2027db0fb4cd004f993a908e2 sig_cn_org=None source=14.1 
   <para>
    Multidimensional array values can be built by nesting array
    constructors.
    In the inner constructors, the key word <literal>ARRAY</literal> can
    be omitted.  For example, these produce the same result:

<programlisting>
SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
     array
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {{1,2},{3,4}}
(1 row)

SELECT ARRAY[[1,2],[3,4]];
     array
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {{1,2},{3,4}}
(1 row)
</programlisting>

    Since multidimensional arrays must be rectangular, inner constructors
    at the same level must produce sub-arrays of identical dimensions.
    Any cast applied to the outer <literal>ARRAY</literal> constructor propagates
    automatically to all the inner constructors.
  </para>
________________________________________________________-->
   <para>
    多维数组值可以通过嵌套数组构造器来构建。在内层的构造器中，关键词<literal>ARRAY</literal>可以被忽略。例如，这些语句产生相同的结果：

<programlisting>
SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)

SELECT ARRAY[[1,2],[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)
</programlisting>

    因为多维数组必须是矩形的，处于同一层次的内层构造器必须产生相同维度的子数组。任何被应用于外层<literal>ARRAY</literal>构造器的造型会自动传播到所有的内层构造器。
  </para>
<!-- pgdoc-cn_end sig_en=8c6477e2027db0fb4cd004f993a908e2 -->

<!-- pgdoc-cn_start sig_en=036c72c6af719bbcba5d5331ba7fd609 sig_cn_org=None source=14.1 
  <para>
    Multidimensional array constructor elements can be anything yielding
    an array of the proper kind, not only a sub-<literal>ARRAY</literal> construct.
    For example:
<programlisting>
CREATE TABLE arr(f1 int[], f2 int[]);

INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);

SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr;
                     array
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}
(1 row)
</programlisting>
  </para>
________________________________________________________-->
  <para>
    多维数组构造器元素可以是任何得到一个正确种类数组的任何东西，而不仅仅是一个子-<literal>ARRAY</literal>结构。例如：
<programlisting>
CREATE TABLE arr(f1 int[], f2 int[]);

INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);

SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr;
                     array
------------------------------------------------
 {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}
(1 row)
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=036c72c6af719bbcba5d5331ba7fd609 -->

<!-- pgdoc-cn_start sig_en=014fd7d0174779532551b91bb1de7ade sig_cn_org=None source=14.1 
  <para>
   You can construct an empty array, but since it's impossible to have an
   array with no type, you must explicitly cast your empty array to the
   desired type.  For example:
<programlisting>
SELECT ARRAY[]::integer[];
 array
-&minus;-&minus;-&minus;-
 {}
(1 row)
</programlisting>
  </para>
________________________________________________________-->
  <para>
   你可以构造一个空数组，但是因为无法得到一个无类型的数组，你必须显式地把你的空数组造型成想要的类型。例如：
<programlisting>
SELECT ARRAY[]::integer[];
 array
-------
 {}
(1 row)
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=014fd7d0174779532551b91bb1de7ade -->

<!-- pgdoc-cn_start sig_en=38935b3ecc4dc91243d068fc8be99dbf sig_cn_org=None source=14.1 
  <para>
   It is also possible to construct an array from the results of a
   subquery.  In this form, the array constructor is written with the
   key word <literal>ARRAY</literal> followed by a parenthesized (not
   bracketed) subquery. For example:
<programlisting>
SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
                              array
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31,2412}
(1 row)

SELECT ARRAY(SELECT ARRAY[i, i*2] FROM generate_series(1,5) AS a(i));
              array
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {{1,2},{2,4},{3,6},{4,8},{5,10}}
(1 row)
</programlisting>
   The subquery must return a single column.
   If the subquery's output column is of a non-array type, the resulting
   one-dimensional array will have an element for each row in the
   subquery result, with an element type matching that of the
   subquery's output column.
   If the subquery's output column is of an array type, the result will be
   an array of the same type but one higher dimension; in this case all
   the subquery rows must yield arrays of identical dimensionality, else
   the result would not be rectangular.
  </para>
________________________________________________________-->
  <para>
   也可以从一个子查询的结果构建一个数组。在这种形式中，数组构造器被写为关键词<literal>ARRAY</literal>后跟着一个加了圆括号（不是方括号）的子查询。例如：
<programlisting>
SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
                              array
------------------------------------------------------------------
 {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31,2412}
(1 row)

SELECT ARRAY(SELECT ARRAY[i, i*2] FROM generate_series(1,5) AS a(i));
              array
----------------------------------
 {{1,2},{2,4},{3,6},{4,8},{5,10}}
(1 row)
</programlisting>
   子查询必须返回一个单一列。如果子查询的输出列是非数组类型，
   结果的一维数组将为该子查询结果中的每一行有一个元素，
   并且有一个与子查询的输出列匹配的元素类型。如果子查询的输出列
   是一种数组类型，结果将是同类型的一个数组，但是要高一个维度。
   在这种情况下，该子查询的所有行必须产生同样维度的数组，否则结果
   就不会是矩形形式。
  </para>
<!-- pgdoc-cn_end sig_en=38935b3ecc4dc91243d068fc8be99dbf -->

<!-- pgdoc-cn_start sig_en=9ae906a102a5f8dbe822c9659d7e8b13 sig_cn_org=None source=14.1 
  <para>
   The subscripts of an array value built with <literal>ARRAY</literal>
   always begin with one.  For more information about arrays, see
   <xref linkend="arrays"/>.
  </para>
________________________________________________________-->
  <para>
   用<literal>ARRAY</literal>构建的一个数组值的下标总是从一开始。更多关于数组的信息，请见<xref linkend="arrays"/>。
  </para>
<!-- pgdoc-cn_end sig_en=9ae906a102a5f8dbe822c9659d7e8b13 -->

  </sect2>

  <sect2 id="sql-syntax-row-constructors">
<!-- pgdoc-cn_start sig_en=786f9f47836ba91147745412f14aaf95 sig_cn_org=None source=14.1 
   <title>Row Constructors</title>
________________________________________________________-->
   <title>行构造器</title>
<!-- pgdoc-cn_end sig_en=786f9f47836ba91147745412f14aaf95 -->

<!-- pgdoc-cn_start sig_en=8864a4a205982dce89310d7cebe9f77a sig_cn_org=None source=14.1 
   <indexterm>
    <primary>composite type</primary>
    <secondary>constructor</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>组合类型</primary>
    <secondary>构造器</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=8864a4a205982dce89310d7cebe9f77a -->

<!-- pgdoc-cn_start sig_en=0e1d0530c435e69a32897d85269aa951 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>row type</primary>
    <secondary>constructor</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>行类型</primary>
    <secondary>构造器</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=0e1d0530c435e69a32897d85269aa951 -->

<!-- pgdoc-cn_start sig_en=c48c3888865d9a1773ee55d607010d7f sig_cn_org=None source=14.1 
   <indexterm>
    <primary>ROW</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>ROW</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=c48c3888865d9a1773ee55d607010d7f -->

<!-- pgdoc-cn_start sig_en=643535952b48b5feadcba5466ba09dd6 sig_cn_org=None source=14.1 
   <para>
    A row constructor is an expression that builds a row value (also
    called a composite value) using values
    for its member fields.  A row constructor consists of the key word
    <literal>ROW</literal>, a left parenthesis, zero or more
    expressions (separated by commas) for the row field values, and finally
    a right parenthesis.  For example:
<programlisting>
SELECT ROW(1,2.5,'this is a test');
</programlisting>
    The key word <literal>ROW</literal> is optional when there is more than one
    expression in the list.
   </para>
________________________________________________________-->
   <para>
    一个行构造器是能够构建一个行值（也称作一个组合类型）并用值作为其成员域的表达式。一个行构造器由关键词<literal>ROW</literal>、一个左圆括号、用于行的域值的零个或多个表达式（用逗号分隔）以及最后的一个右圆括号组成。例如：
<programlisting>
SELECT ROW(1,2.5,'this is a test');
</programlisting>
    当在列表中有超过一个表达式时，关键词<literal>ROW</literal>是可选的。
   </para>
<!-- pgdoc-cn_end sig_en=643535952b48b5feadcba5466ba09dd6 -->

<!-- pgdoc-cn_start sig_en=ff59bb4d3327ea4ad7a1cf17178ad0bd sig_cn_org=None source=14.1 
   <para>
    A row constructor can include the syntax
    <replaceable>rowvalue</replaceable><literal>.*</literal>,
    which will be expanded to a list of the elements of the row value,
    just as occurs when the <literal>.*</literal> syntax is used at the top level
    of a <command>SELECT</command> list (see <xref linkend="rowtypes-usage"/>).
    For example, if table <literal>t</literal> has
    columns <literal>f1</literal> and <literal>f2</literal>, these are the same:
<programlisting>
SELECT ROW(t.*, 42) FROM t;
SELECT ROW(t.f1, t.f2, 42) FROM t;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    一个行构造器可以包括语法<replaceable>rowvalue</replaceable><literal>.*</literal>，它将被扩展为该行值的元素的一个列表，就像在一个顶层<command>SELECT</command>列表（见<xref linkend="rowtypes-usage"/>）中使用<literal>.*</literal>时发生的事情一样。例如，如果表<literal>t</literal>有列<literal>f1</literal>和<literal>f2</literal>，那么这些是相同的：
<programlisting>
SELECT ROW(t.*, 42) FROM t;
SELECT ROW(t.f1, t.f2, 42) FROM t;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=ff59bb4d3327ea4ad7a1cf17178ad0bd -->

   <note>
<!-- pgdoc-cn_start sig_en=fd0a7e682b7f06a1f7ceb22894afed03 sig_cn_org=None source=14.1 
    <para>
     Before <productname>PostgreSQL</productname> 8.2, the
     <literal>.*</literal> syntax was not expanded in row constructors, so
     that writing <literal>ROW(t.*, 42)</literal> created a two-field row whose first
     field was another row value.  The new behavior is usually more useful.
     If you need the old behavior of nested row values, write the inner
     row value without <literal>.*</literal>, for instance
     <literal>ROW(t, 42)</literal>.
    </para>
________________________________________________________-->
    <para>
     在<productname>PostgreSQL</productname> 8.2 以前，<literal>.*</literal>语法不会在行构造器中被扩展，这样写<literal>ROW(t.*, 42)</literal>会创建一个有两个域的行，其第一个域是另一个行值。新的行为通常更有用。如果你需要嵌套行值的旧行为，写内层行值时不要用<literal>.*</literal>，例如<literal>ROW(t, 42)</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=fd0a7e682b7f06a1f7ceb22894afed03 -->
   </note>

<!-- pgdoc-cn_start sig_en=cbf6cda986547111f5f5993776b6144d sig_cn_org=None source=14.1 
   <para>
    By default, the value created by a <literal>ROW</literal> expression is of
    an anonymous record type.  If necessary, it can be cast to a named
    composite type &mdash; either the row type of a table, or a composite type
    created with <command>CREATE TYPE AS</command>.  An explicit cast might be needed
    to avoid ambiguity.  For example:
<programlisting>
CREATE TABLE mytable(f1 int, f2 float, f3 text);

CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-&minus; No cast needed since only one getf1() exists
SELECT getf1(ROW(1,2.5,'this is a test'));
 getf1
-&minus;-&minus;-&minus;-
     1
(1 row)

CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);

CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-&minus; Now we need a cast to indicate which function to call:
SELECT getf1(ROW(1,2.5,'this is a test'));
ERROR:  function getf1(record) is not unique

SELECT getf1(ROW(1,2.5,'this is a test')::mytable);
 getf1
-&minus;-&minus;-&minus;-
     1
(1 row)

SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));
 getf1
-&minus;-&minus;-&minus;-
    11
(1 row)
</programlisting>
  </para>
________________________________________________________-->
   <para>
    默认情况下，由一个<literal>ROW</literal>表达式创建的值是一种匿名记录类型。如果必要，它可以被造型为一种命名的组合类型 &mdash; 或者是一个表的行类型，或者是一种用<command>CREATE TYPE AS</command>创建的组合类型。为了避免歧义，可能需要一个显式造型。例如：
<programlisting>
CREATE TABLE mytable(f1 int, f2 float, f3 text);

CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-- 不需要造型因为只有一个 getf1() 存在
SELECT getf1(ROW(1,2.5,'this is a test'));
 getf1
-------
     1
(1 row)

CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);

CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-- 现在我们需要一个造型来指示要调用哪个函数：
SELECT getf1(ROW(1,2.5,'this is a test'));
ERROR:  function getf1(record) is not unique

SELECT getf1(ROW(1,2.5,'this is a test')::mytable);
 getf1
-------
     1
(1 row)

SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));
 getf1
-------
    11
(1 row)
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=cbf6cda986547111f5f5993776b6144d -->

<!-- pgdoc-cn_start sig_en=7e59a1d201af360790cb794cedc9d6c9 sig_cn_org=None source=14.1 
  <para>
   Row constructors can be used to build composite values to be stored
   in a composite-type table column, or to be passed to a function that
   accepts a composite parameter.  Also,
   it is possible to compare two row values or test a row with
   <literal>IS NULL</literal> or <literal>IS NOT NULL</literal>, for example:
<programlisting>
SELECT ROW(1,2.5,'this is a test') = ROW(1, 3, 'not the same');

SELECT ROW(table.*) IS NULL FROM table;  -&minus; detect all-null rows
</programlisting>
   For more detail see <xref linkend="functions-comparisons"/>.
   Row constructors can also be used in connection with subqueries,
   as discussed in <xref linkend="functions-subquery"/>.
  </para>
________________________________________________________-->
  <para>
   行构造器可以被用来构建存储在一个组合类型表列中的组合值，或者被传递给一个接受组合参数的函数。还有，可以比较两个行值，或者用<literal>IS NULL</literal>或<literal>IS NOT NULL</literal>测试一个行，例如：
<programlisting>
SELECT ROW(1,2.5,'this is a test') = ROW(1, 3, 'not the same');

SELECT ROW(table.*) IS NULL FROM table;  -- detect all-null rows
</programlisting>
   详见<xref linkend="functions-comparisons"/>。如<xref linkend="functions-subquery"/>中所讨论的，行构造器也可以被用来与子查询相连接。
  </para>
<!-- pgdoc-cn_end sig_en=7e59a1d201af360790cb794cedc9d6c9 -->

  </sect2>

  <sect2 id="syntax-express-eval">
<!-- pgdoc-cn_start sig_en=5799fbb4a1d35c584ab2475a8e425eff sig_cn_org=None source=14.1 
   <title>Expression Evaluation Rules</title>
________________________________________________________-->
   <title>表达式计算规则</title>
<!-- pgdoc-cn_end sig_en=5799fbb4a1d35c584ab2475a8e425eff -->

<!-- pgdoc-cn_start sig_en=efd1353ee4852d5be73ce63086c92a75 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>expression</primary>
    <secondary>order of evaluation</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>表达式</primary>
    <secondary>计算的顺序</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=efd1353ee4852d5be73ce63086c92a75 -->

<!-- pgdoc-cn_start sig_en=7d662a681f4d9ee6300e2c2761cf1fb9 sig_cn_org=None source=14.1 
   <para>
    The order of evaluation of subexpressions is not defined.  In
    particular, the inputs of an operator or function are not necessarily
    evaluated left-to-right or in any other fixed order.
   </para>
________________________________________________________-->
   <para>
    子表达式的计算顺序没有被定义。特别地，一个操作符或函数的输入不必按照从左至右或其他任何固定顺序进行计算。
   </para>
<!-- pgdoc-cn_end sig_en=7d662a681f4d9ee6300e2c2761cf1fb9 -->

<!-- pgdoc-cn_start sig_en=d5c3d91ef3bd6da8413111ee30348395 sig_cn_org=None source=14.1 
   <para>
    Furthermore, if the result of an expression can be determined by
    evaluating only some parts of it, then other subexpressions
    might not be evaluated at all.  For instance, if one wrote:
<programlisting>
SELECT true OR somefunc();
</programlisting>
    then <literal>somefunc()</literal> would (probably) not be called
    at all. The same would be the case if one wrote:
<programlisting>
SELECT somefunc() OR true;
</programlisting>
    Note that this is not the same as the left-to-right
    <quote>short-circuiting</quote> of Boolean operators that is found
    in some programming languages.
   </para>
________________________________________________________-->
   <para>
    此外，如果一个表达式的结果可以通过只计算其一部分来决定，那么其他子表达式可能完全不需要被计算。例如，如果我们写：
<programlisting>
SELECT true OR somefunc();
</programlisting>
    那么<literal>somefunc()</literal>将（可能）完全不被调用。如果我们写成下面这样也是一样：
<programlisting>
SELECT somefunc() OR true;
</programlisting>
    注意这和一些编程语言中布尔操作符从左至右的<quote>短路</quote>不同。
   </para>
<!-- pgdoc-cn_end sig_en=d5c3d91ef3bd6da8413111ee30348395 -->

<!-- pgdoc-cn_start sig_en=4a4e55347cb28b95c27e4d9e5b66d14d sig_cn_org=None source=14.1 
   <para>
    As a consequence, it is unwise to use functions with side effects
    as part of complex expressions.  It is particularly dangerous to
    rely on side effects or evaluation order in <literal>WHERE</literal> and <literal>HAVING</literal> clauses,
    since those clauses are extensively reprocessed as part of
    developing an execution plan.  Boolean
    expressions (<literal>AND</literal>/<literal>OR</literal>/<literal>NOT</literal> combinations) in those clauses can be reorganized
    in any manner allowed by the laws of Boolean algebra.
   </para>
________________________________________________________-->
   <para>
    因此，在复杂表达式中使用带有副作用的函数是不明智的。在<literal>WHERE</literal>和<literal>HAVING</literal>子句中依赖副作用或计算顺序尤其危险，因为在建立一个执行计划时这些子句会被广泛地重新处理。这些子句中布尔表达式（<literal>AND</literal>/<literal>OR</literal>/<literal>NOT</literal>的组合）可能会以布尔代数定律所允许的任何方式被重组。
   </para>
<!-- pgdoc-cn_end sig_en=4a4e55347cb28b95c27e4d9e5b66d14d -->

<!-- pgdoc-cn_start sig_en=49b1bd99ff1a99c126c2dbdd2f262ab4 sig_cn_org=None source=14.1 
   <para>
    When it is essential to force evaluation order, a <literal>CASE</literal>
    construct (see <xref linkend="functions-conditional"/>) can be
    used.  For example, this is an untrustworthy way of trying to
    avoid division by zero in a <literal>WHERE</literal> clause:
<programlisting>
SELECT ... WHERE x &gt; 0 AND y/x &gt; 1.5;
</programlisting>
    But this is safe:
<programlisting>
SELECT ... WHERE CASE WHEN x &gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</programlisting>
    A <literal>CASE</literal> construct used in this fashion will defeat optimization
    attempts, so it should only be done when necessary.  (In this particular
    example, it would be better to sidestep the problem by writing
    <literal>y &gt; 1.5*x</literal> instead.)
   </para>
________________________________________________________-->
   <para>
    当有必要强制计算顺序时，可以使用一个<literal>CASE</literal>结构（见<xref linkend="functions-conditional"/>）。例如，在一个<literal>WHERE</literal>子句中使用下面的方法尝试避免除零是不可靠的：
<programlisting>
SELECT ... WHERE x &gt; 0 AND y/x &gt; 1.5;
</programlisting>
    但是这是安全的：
<programlisting>
SELECT ... WHERE CASE WHEN x &gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</programlisting>
    一个以这种风格使用的<literal>CASE</literal>结构将使得优化尝试失败，因此只有必要时才这样做（在这个特别的例子中，最好通过写<literal>y &gt; 1.5*x</literal>来回避这个问题）。
   </para>
<!-- pgdoc-cn_end sig_en=49b1bd99ff1a99c126c2dbdd2f262ab4 -->

<!-- pgdoc-cn_start sig_en=1b14fa4a644d62ddc80c8ee1c18a584d sig_cn_org=None source=14.1 
   <para>
    <literal>CASE</literal> is not a cure-all for such issues, however.
    One limitation of the technique illustrated above is that it does not
    prevent early evaluation of constant subexpressions.
    As described in <xref linkend="xfunc-volatility"/>, functions and
    operators marked <literal>IMMUTABLE</literal> can be evaluated when
    the query is planned rather than when it is executed.  Thus for example
<programlisting>
SELECT CASE WHEN x &gt; 0 THEN x ELSE 1/0 END FROM tab;
</programlisting>
    is likely to result in a division-by-zero failure due to the planner
    trying to simplify the constant subexpression,
    even if every row in the table has <literal>x &gt; 0</literal> so that the
    <literal>ELSE</literal> arm would never be entered at run time.
   </para>
________________________________________________________-->
   <para>
    不过，<literal>CASE</literal>不是这类问题的万灵药。上述技术的一个限制是，
    它无法阻止常量子表达式的提早计算。如<xref linkend="xfunc-volatility"/>
    中所述，当查询被规划而不是被执行时，被标记成
    <literal>IMMUTABLE</literal>的函数和操作符可以被计算。因此
<programlisting>
SELECT CASE WHEN x &gt; 0 THEN x ELSE 1/0 END FROM tab;
</programlisting>
    很可能会导致一次除零失败，因为规划器尝试简化常量子表达式。即便是
    表中的每一行都有<literal>x &gt; 0</literal>（这样运行时永远不会进入到
    <literal>ELSE</literal>分支）也是这样。
   </para>
<!-- pgdoc-cn_end sig_en=1b14fa4a644d62ddc80c8ee1c18a584d -->

<!-- pgdoc-cn_start sig_en=e264497066e0ba2498bd9f0b225e16d3 sig_cn_org=None source=14.1 
   <para>
    While that particular example might seem silly, related cases that don't
    obviously involve constants can occur in queries executed within
    functions, since the values of function arguments and local variables
    can be inserted into queries as constants for planning purposes.
    Within <application>PL/pgSQL</application> functions, for example, using an
    <literal>IF</literal>-<literal>THEN</literal>-<literal>ELSE</literal> statement to protect
    a risky computation is much safer than just nesting it in a
    <literal>CASE</literal> expression.
   </para>
________________________________________________________-->
   <para>
    虽然这个特别的例子可能看起来愚蠢，没有明显涉及常量的情况可能会发生
    在函数内执行的查询中，因为因为函数参数的值和本地变量可以作为常量
    被插入到查询中用于规划目的。例如，在<application>PL/pgSQL</application>函数
    中，使用一个<literal>IF</literal>-<literal>THEN</literal>-<literal>ELSE</literal>语句来
    保护一种有风险的计算比把它嵌在一个<literal>CASE</literal>表达式中要安全得多。
   </para>
<!-- pgdoc-cn_end sig_en=e264497066e0ba2498bd9f0b225e16d3 -->

<!-- pgdoc-cn_start sig_en=45892886d1a51b95cbd2e3f9c1fb2b38 sig_cn_org=None source=14.1 
   <para>
    Another limitation of the same kind is that a <literal>CASE</literal> cannot
    prevent evaluation of an aggregate expression contained within it,
    because aggregate expressions are computed before other
    expressions in a <literal>SELECT</literal> list or <literal>HAVING</literal> clause
    are considered.  For example, the following query can cause a
    division-by-zero error despite seemingly having protected against it:
<programlisting>
SELECT CASE WHEN min(employees) > 0
            THEN avg(expenses / employees)
       END
    FROM departments;
</programlisting>
    The <function>min()</function> and <function>avg()</function> aggregates are computed
    concurrently over all the input rows, so if any row
    has <structfield>employees</structfield> equal to zero, the division-by-zero error
    will occur before there is any opportunity to test the result of
    <function>min()</function>.  Instead, use a <literal>WHERE</literal>
    or <literal>FILTER</literal> clause to prevent problematic input rows from
    reaching an aggregate function in the first place.
   </para>
________________________________________________________-->
   <para>
    另一个同类型的限制是，一个<literal>CASE</literal>无法阻止其所包含的聚集表达式
    的计算，因为在考虑<literal>SELECT</literal>列表或<literal>HAVING</literal>子句中的
    其他表达式之前，会先计算聚集表达式。例如，下面的查询会导致一个除零错误，
    虽然看起来好像已经这种情况加以了保护：
<programlisting>
SELECT CASE WHEN min(employees) > 0
            THEN avg(expenses / employees)
       END
    FROM departments;
</programlisting>
    <function>min()</function>和<function>avg()</function>聚集会在所有输入行上并行地计算，
    因此如果任何行有<structfield>employees</structfield>等于零，在有机会测试
    <function>min()</function>的结果之前，就会发生除零错误。取而代之的是，可以使用
    一个<literal>WHERE</literal>或<literal>FILTER</literal>子句来首先阻止有问题的输入行到达
    一个聚集函数。
   </para>
<!-- pgdoc-cn_end sig_en=45892886d1a51b95cbd2e3f9c1fb2b38 -->
  </sect2>
 </sect1>

 <sect1 id="sql-syntax-calling-funcs">
<!-- pgdoc-cn_start sig_en=0be924212e963fab3f54199b93e5e123 sig_cn_org=None source=14.1 
  <title>Calling Functions</title>
________________________________________________________-->
  <title>调用函数</title>
<!-- pgdoc-cn_end sig_en=0be924212e963fab3f54199b93e5e123 -->

<!-- pgdoc-cn_start sig_en=c538e58fc81e0ba7e7e4a47b39745513 sig_cn_org=None source=14.1 
   <indexterm zone="sql-syntax-calling-funcs">
    <primary>notation</primary>
    <secondary>functions</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="sql-syntax-calling-funcs">
    <primary>notation</primary>
    <secondary>functions</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=c538e58fc81e0ba7e7e4a47b39745513 -->

<!-- pgdoc-cn_start sig_en=c453b6d5d6000ee8aa0b2e14532b32a0 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> allows functions that have named
    parameters to be called using either <firstterm>positional</firstterm> or
    <firstterm>named</firstterm> notation.  Named notation is especially
    useful for functions that have a large number of parameters, since it
    makes the associations between parameters and actual arguments more
    explicit and reliable.
    In positional notation, a function call is written with
    its argument values in the same order as they are defined in the function
    declaration.  In named notation, the arguments are matched to the
    function parameters by name and can be written in any order.
    For each notation, also consider the effect of function argument types,
    documented in <xref linkend="typeconv-func"/>.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>允许带有命名参数的函数被使用<firstterm>位置</firstterm>或<firstterm>命名</firstterm>记号法调用。命名记号法对于有大量参数的函数特别有用，因为它让参数和实际参数之间的关联更明显和可靠。在位置记号法中，书写一个函数调用时，其参数值要按照它们在函数声明中被定义的顺序书写。在命名记号法中，参数根据名称匹配函数参数，并且可以以任何顺序书写。对于每一种记法，还要考虑函数参数类型的效果，这些在<xref linkend="typeconv-func"/>有介绍。
   </para>
<!-- pgdoc-cn_end sig_en=c453b6d5d6000ee8aa0b2e14532b32a0 -->

<!-- pgdoc-cn_start sig_en=0d4516bbedfd5b5fc0db857f72aa902b sig_cn_org=None source=14.1 
   <para>
    In either notation, parameters that have default values given in the
    function declaration need not be written in the call at all.  But this
    is particularly useful in named notation, since any combination of
    parameters can be omitted; while in positional notation parameters can
    only be omitted from right to left.
   </para>
________________________________________________________-->
   <para>
    在任意一种记号法中，在函数声明中给出了默认值的参数根本不需要在调用中写出。但是这在命名记号法中特别有用，因为任何参数的组合都可以被忽略。而在位置记号法中参数只能从右往左忽略。
   </para>
<!-- pgdoc-cn_end sig_en=0d4516bbedfd5b5fc0db857f72aa902b -->

<!-- pgdoc-cn_start sig_en=00f16ded2f2f4b7db5cac6de86318a0d sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> also supports
    <firstterm>mixed</firstterm> notation, which combines positional and
    named notation.  In this case, positional parameters are written first
    and named parameters appear after them.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>也支持<firstterm>混合</firstterm>记号法，它组合了位置和命名记号法。在这种情况中，位置参数被首先写出并且命名参数出现在其后。
   </para>
<!-- pgdoc-cn_end sig_en=00f16ded2f2f4b7db5cac6de86318a0d -->

<!-- pgdoc-cn_start sig_en=0c05e495cae59d7b568768ec4b459883 sig_cn_org=None source=14.1 
   <para>
    The following examples will illustrate the usage of all three
    notations, using the following function definition:
<programlisting>
CREATE FUNCTION concat_lower_or_upper(a text, b text, uppercase boolean DEFAULT false)
RETURNS text
AS
$$
 SELECT CASE
        WHEN $3 THEN UPPER($1 || ' ' || $2)
        ELSE LOWER($1 || ' ' || $2)
        END;
$$
LANGUAGE SQL IMMUTABLE STRICT;
</programlisting>
    Function <function>concat_lower_or_upper</function> has two mandatory
    parameters, <literal>a</literal> and <literal>b</literal>.  Additionally
    there is one optional parameter <literal>uppercase</literal> which defaults
    to <literal>false</literal>.  The <literal>a</literal> and
    <literal>b</literal> inputs will be concatenated, and forced to either
    upper or lower case depending on the <literal>uppercase</literal>
    parameter.  The remaining details of this function
    definition are not important here (see <xref linkend="extend"/> for
    more information).
   </para>
________________________________________________________-->
   <para>
    下列例子将展示所有三种记号法的用法：
<programlisting>
CREATE FUNCTION concat_lower_or_upper(a text, b text, uppercase boolean DEFAULT false)
RETURNS text
AS
$$
 SELECT CASE
        WHEN $3 THEN UPPER($1 || ' ' || $2)
        ELSE LOWER($1 || ' ' || $2)
        END;
$$
LANGUAGE SQL IMMUTABLE STRICT;
</programlisting>
    函数<function>concat_lower_or_upper</function>有两个强制参数，<literal>a</literal>和<literal>b</literal>。此外，有一个可选的参数<literal>uppercase</literal>，其默认值为<literal>false</literal>。<literal>a</literal>和<literal>b</literal>输入将被串接，并且根据<literal>uppercase</literal>参数被强制为大写或小写形式。这个函数的剩余细节对这里并不重要（详见<xref linkend="extend"/>）。
   </para>
<!-- pgdoc-cn_end sig_en=0c05e495cae59d7b568768ec4b459883 -->

   <sect2 id="sql-syntax-calling-funcs-positional">
<!-- pgdoc-cn_start sig_en=38cf7b8060b9843674917a9b66c887ad sig_cn_org=None source=14.1 
    <title>Using Positional Notation</title>
________________________________________________________-->
    <title>使用位置记号</title>
<!-- pgdoc-cn_end sig_en=38cf7b8060b9843674917a9b66c887ad -->

<!-- pgdoc-cn_start sig_en=020ab0ef141c47de86874255a947e8dd sig_cn_org=None source=14.1 
    <indexterm>
     <primary>function</primary>
     <secondary>positional notation</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>函数</primary>
     <secondary>位置记号法</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=020ab0ef141c47de86874255a947e8dd -->

<!-- pgdoc-cn_start sig_en=206a1816c0def67182662593d6a86245 sig_cn_org=e93823b92eb6ced45f782e4db9211bca source=15.7 
    <para>
     Positional notation is the traditional mechanism for passing arguments
     to functions in <productname>PostgreSQL</productname>.  An example is:
<screen>
SELECT concat_lower_or_upper('Hello', 'World', true);
 concat_lower_or_upper
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 HELLO WORLD
(1 row)
</screen>
     All arguments are specified in order.  The result is upper case since
     <literal>uppercase</literal> is specified as <literal>true</literal>.
     Another example is:
<screen>
SELECT concat_lower_or_upper('Hello', 'World');
 concat_lower_or_upper
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 hello world
(1 row)
</screen>
     Here, the <literal>uppercase</literal> parameter is omitted, so it
     receives its default value of <literal>false</literal>, resulting in
     lower case output.  In positional notation, arguments can be omitted
     from right to left so long as they have defaults.
    </para>
________________________________________________________-->
    <para>
     位置表示法是在<productname>PostgreSQL</productname>中将参数传递给函数的传统机制。一个例子是：
<screen>
SELECT concat_lower_or_upper('Hello', 'World', true);
 concat_lower_or_upper
-----------------------
 HELLO WORLD
(1 row)
</screen>
     所有参数按顺序指定。结果是大写，因为指定了<literal>true</literal>作为参数。
     另一个例子是：
<screen>
SELECT concat_lower_or_upper('Hello', 'World');
 concat_lower_or_upper
-----------------------
 hello world
(1 row)
</screen>
     这里，<literal>uppercase</literal>有参数被省略，因此它接收其默认值<literal>false</literal>，导致输出为小写。在位置表示法中，参数可以从右到左省略，只要它们有默认值。
</para>
<!-- pgdoc-cn_end sig_en=206a1816c0def67182662593d6a86245 -->
   </sect2>

   <sect2 id="sql-syntax-calling-funcs-named">
<!-- pgdoc-cn_start sig_en=b1f9e2f00c195efdd3bb0015e8ca10cf sig_cn_org=None source=14.1 
    <title>Using Named Notation</title>
________________________________________________________-->
    <title>使用命名记号</title>
<!-- pgdoc-cn_end sig_en=b1f9e2f00c195efdd3bb0015e8ca10cf -->

<!-- pgdoc-cn_start sig_en=4c9f5e5b7e675af6c372920d744c5a32 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>function</primary>
     <secondary>named notation</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>函数</primary>
     <secondary>命名记号法</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=4c9f5e5b7e675af6c372920d744c5a32 -->

<!-- pgdoc-cn_start sig_en=f5325e45b86f37cb6729af6a467baee8 sig_cn_org=69fa7dcee49d20fa6db3433f322f889c source=15.7 
    <para>
     In named notation, each argument's name is specified using
     <literal>=&gt;</literal> to separate it from the argument expression.
     For example:
<screen>
SELECT concat_lower_or_upper(a =&gt; 'Hello', b =&gt; 'World');
 concat_lower_or_upper
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 hello world
(1 row)
</screen>
     Again, the argument <literal>uppercase</literal> was omitted
     so it is set to <literal>false</literal> implicitly.  One advantage of
     using named notation is that the arguments may be specified in any
     order, for example:
<screen>
SELECT concat_lower_or_upper(a =&gt; 'Hello', b =&gt; 'World', uppercase =&gt; true);
 concat_lower_or_upper
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 HELLO WORLD
(1 row)

SELECT concat_lower_or_upper(a =&gt; 'Hello', uppercase =&gt; true, b =&gt; 'World');
 concat_lower_or_upper
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 HELLO WORLD
(1 row)
</screen>
    </para>
________________________________________________________-->
    <para>
     在命名表示法中，每个参数的名称都使用<literal>=&gt;</literal>来与参数表达式分隔开来。
     例如：
<screen>
SELECT concat_lower_or_upper(a =&gt; 'Hello', b =&gt; 'World');
 concat_lower_or_upper
-----------------------
 hello world
(1 row)
</screen>
     再次，参数<literal>uppercase</literal>被省略了，因此它隐式地设置为<literal>false</literal>。
     使用命名表示法的一个优点是参数可以以任何顺序指定，例如：
<screen>
SELECT concat_lower_or_upper(a =&gt; 'Hello', b =&gt; 'World', uppercase =&gt; true);
 concat_lower_or_upper
-----------------------
 HELLO WORLD
(1 row)

SELECT concat_lower_or_upper(a =&gt; 'Hello', uppercase =&gt; true, b =&gt; 'World');
 concat_lower_or_upper
-----------------------
 HELLO WORLD
(1 row)
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=f5325e45b86f37cb6729af6a467baee8 -->

<!-- pgdoc-cn_start sig_en=65e8d9d44af96f8061dbddcdb1e86aa9 sig_cn_org=b8a3b31e88de2518af12b02ff2714ebf source=15.7 
    <para>
      An older syntax based on ":=" is supported for backward compatibility:
<screen>
SELECT concat_lower_or_upper(a := 'Hello', uppercase := true, b := 'World');
 concat_lower_or_upper
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 HELLO WORLD
(1 row)
</screen>
    </para>
________________________________________________________-->
    <para>
      为了向后兼容，仍支持基于":="的旧语法：
<screen>
SELECT concat_lower_or_upper(a := 'Hello', uppercase := true, b := 'World');
 concat_lower_or_upper
-----------------------
 HELLO WORLD
(1 row)
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=65e8d9d44af96f8061dbddcdb1e86aa9 -->
   </sect2>

  <sect2 id="sql-syntax-calling-funcs-mixed">
<!-- pgdoc-cn_start sig_en=327deabc9496ec1c7ae9ab62779a3646 sig_cn_org=None source=14.1 
   <title>Using Mixed Notation</title>
________________________________________________________-->
   <title>使用混合记号</title>
<!-- pgdoc-cn_end sig_en=327deabc9496ec1c7ae9ab62779a3646 -->

<!-- pgdoc-cn_start sig_en=204dad7d3ccce50bc0b308fc50fdae42 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>function</primary>
    <secondary>mixed notation</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>函数</primary>
    <secondary>混合记号法</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=204dad7d3ccce50bc0b308fc50fdae42 -->

<!-- pgdoc-cn_start sig_en=99c5eedd64fe47852375eded9ee41384 sig_cn_org=b61fa133835a0e57b3780b480f00967b source=15.7 
   <para>
    The mixed notation combines positional and named notation. However, as
    already mentioned, named arguments cannot precede positional arguments.
    For example:
<screen>
SELECT concat_lower_or_upper('Hello', 'World', uppercase =&gt; true);
 concat_lower_or_upper
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 HELLO WORLD
(1 row)
</screen>
    In the above query, the arguments <literal>a</literal> and
    <literal>b</literal> are specified positionally, while
    <literal>uppercase</literal> is specified by name.  In this example,
    that adds little except documentation.  With a more complex function
    having numerous parameters that have default values, named or mixed
    notation can save a great deal of writing and reduce chances for error.
   </para>
________________________________________________________-->
   <para>
    混合表示法结合了位置表示法和命名表示法。然而，正如前面提到的，命名参数不能在位置参数之前。
    例如：
<screen>
SELECT concat_lower_or_upper('Hello', 'World', uppercase =&gt; true);
 concat_lower_or_upper
-----------------------
 HELLO WORLD
(1 row)
</screen>
    在上面的查询中，参数<literal>a</literal>和<literal>b</literal>是按位置指定的，而<literal>uppercase</literal>是按名称指定的。
    在这个例子中，这只是增加了一点文档说明。对于具有许多具有默认值的参数的更复杂函数，命名或混合表示法可以节省大量编写工作，并减少错误的机会。
   </para>
<!-- pgdoc-cn_end sig_en=99c5eedd64fe47852375eded9ee41384 -->

   <note>
<!-- pgdoc-cn_start sig_en=ef058e11d95f735a446a9f29adb28655 sig_cn_org=None source=14.1 
    <para>
     Named and mixed call notations currently cannot be used when calling an
     aggregate function (but they do work when an aggregate function is used
     as a window function).
    </para>
________________________________________________________-->
    <para>
     命名的和混合的调用记号法当前不能在调用聚集函数时使用（但是当聚集函数被用作窗口函数时它们可以被使用）。
    </para>
<!-- pgdoc-cn_end sig_en=ef058e11d95f735a446a9f29adb28655 -->
   </note>
  </sect2>
 </sect1>

</chapter>
