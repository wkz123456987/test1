<!-- doc/src/sgml/json.sgml -->

<sect1 id="datatype-json">
<!-- pgdoc-cn_start sig_en=a3d4f3a943e8d654fce62c1c8231ccf9 sig_cn_org=None source=14.1 
 <title><acronym>JSON</acronym> Types</title>
________________________________________________________-->
 <title><acronym>JSON</acronym> 类型</title>
<!-- pgdoc-cn_end sig_en=a3d4f3a943e8d654fce62c1c8231ccf9 -->

<!-- pgdoc-cn_start sig_en=9fc22f568ffe945acdac9f64cb74c807 sig_cn_org=None source=14.1 
 <indexterm zone="datatype-json">
  <primary>JSON</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="datatype-json">
  <primary>JSON</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=9fc22f568ffe945acdac9f64cb74c807 -->

<!-- pgdoc-cn_start sig_en=258b63c71e16cad8d5eef49308a022f8 sig_cn_org=None source=14.1 
 <indexterm zone="datatype-json">
  <primary>JSONB</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="datatype-json">
  <primary>JSONB</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=258b63c71e16cad8d5eef49308a022f8 -->

<!-- pgdoc-cn_start sig_en=2f05a6ed56ec05d2ceae734fb150e919 sig_cn_org=ee757a69087dc83d7a0bcb340134315a source=15.7 
 <para>
  JSON data types are for storing JSON (JavaScript Object Notation)
  data, as specified in <ulink url="https://datatracker.ietf.org/doc/html/rfc7159">RFC
  7159</ulink>. Such data can also be stored as <type>text</type>, but
  the JSON data types have the advantage of enforcing that each
  stored value is valid according to the JSON rules.  There are also
  assorted JSON-specific functions and operators available for data stored
  in these data types; see <xref linkend="functions-json"/>.
 </para>
________________________________________________________-->
 <para>
  JSON数据类型用于存储JSON（JavaScript对象表示法）数据，如在
  <ulink url="https://datatracker.ietf.org/doc/html/rfc7159">RFC
  7159</ulink>中指定的。这样的数据也可以存储为<type>文本</type>，但
  JSON数据类型具有强制执行每个
  存储值符合JSON规则的优势。此外，还有各种各样的针对存储在这些数据类型中的数据
  提供的特定于JSON的函数和运算符；请参见<xref linkend="functions-json"/>。
</para>
<!-- pgdoc-cn_end sig_en=2f05a6ed56ec05d2ceae734fb150e919 -->

<!-- pgdoc-cn_start sig_en=6599ada16b48f3f63a250319f17650bf sig_cn_org=None source=14.1 
 <para>
  <productname>PostgreSQL</productname> offers two types for storing JSON
  data: <type>json</type> and <type>jsonb</type>. To implement efficient query
  mechanisms for these data types, <productname>PostgreSQL</productname>
  also provides the <type>jsonpath</type> data type described in
  <xref linkend="datatype-jsonpath"/>.
 </para>
________________________________________________________-->
 <para>
  <productname>PostgreSQL</productname> 提供存储JSON数据的两种类型：<type>json</type> 和 <type>jsonb</type>。
  为了实现这些数据类型高效的查询机制， <productname>PostgreSQL</productname>还在<xref linkend="datatype-jsonpath"/>中提供了<type>jsonpath</type>数据类型描述。
 </para>
<!-- pgdoc-cn_end sig_en=6599ada16b48f3f63a250319f17650bf -->

<!-- pgdoc-cn_start sig_en=48487b5a019ef69b7b64384684599215 sig_cn_org=None source=14.1 
 <para>
  The <type>json</type> and <type>jsonb</type> data types
  accept <emphasis>almost</emphasis> identical sets of values as
  input.  The major practical difference is one of efficiency.  The
  <type>json</type> data type stores an exact copy of the input text,
  which processing functions must reparse on each execution; while
  <type>jsonb</type> data is stored in a decomposed binary format that
  makes it slightly slower to input due to added conversion
  overhead, but significantly faster to process, since no reparsing
  is needed.  <type>jsonb</type> also supports indexing, which can be a
  significant advantage.
 </para>
________________________________________________________-->
 <para>
  <type>json</type> 和 <type>jsonb</type>数据类型接受<emphasis>几乎</emphasis>完全相同的值集合作为输入。
  主要的实际区别之一是效率。<type>json</type>数据类型存储输入文本的精准拷贝，处理函数必须在每
  次执行时必须重新解析该数据。而<type>jsonb</type>数据被存储在一种分解好的
  二进制格式中，它在输入时要稍慢一些，因为需要做附加的转换。但是
  <type>jsonb</type>在处理时要快很多，因为不需要解析。<type>jsonb</type>也支
  持索引，这也是一个令人瞩目的优势。
 </para>
<!-- pgdoc-cn_end sig_en=48487b5a019ef69b7b64384684599215 -->

<!-- pgdoc-cn_start sig_en=81ff58d65e7c12fe1c390023fdb32fcf sig_cn_org=None source=14.1 
 <para>
  Because the <type>json</type> type stores an exact copy of the input text, it
  will preserve semantically-insignificant white space between tokens, as
  well as the order of keys within JSON objects. Also, if a JSON object
  within the value contains the same key more than once, all the key/value
  pairs are kept.  (The processing functions consider the last value as the
  operative one.)  By contrast, <type>jsonb</type> does not preserve white
  space, does not preserve the order of object keys, and does not keep
  duplicate object keys.  If duplicate keys are specified in the input,
  only the last value is kept.
 </para>
________________________________________________________-->
 <para>
  由于<type>json</type>类型存储的是输入文本的准确拷贝，其中可能会保留在语法
  上不明显的、存在于记号之间的空格，还有 JSON 对象内部的键的顺序。还有，
  如果一个值中的 JSON 对象包含同一个键超过一次，所有的键/值对都会被保留（
  处理函数会把最后的值当作有效值）。相反，<type>jsonb</type>不保留空格、不
  保留对象键的顺序并且不保留重复的对象键。如果在输入中指定了重复的键，只有
  最后一个值会被保留。
 </para>
<!-- pgdoc-cn_end sig_en=81ff58d65e7c12fe1c390023fdb32fcf -->

<!-- pgdoc-cn_start sig_en=290428c75ec7c0c0ca315df0d5c799d3 sig_cn_org=None source=14.1 
 <para>
  In general, most applications should prefer to store JSON data as
  <type>jsonb</type>, unless there are quite specialized needs, such as
  legacy assumptions about ordering of object keys.
 </para>
________________________________________________________-->
 <para>
  通常，除非有特别特殊的需要（例如遗留的对象键顺序假设），大多数应用应该
  更愿意把 JSON 数据存储为<type>jsonb</type>。
 </para>
<!-- pgdoc-cn_end sig_en=290428c75ec7c0c0ca315df0d5c799d3 -->

<!-- pgdoc-cn_start sig_en=92ee39003dfb53b84f12ca94e23d2e7c sig_cn_org=None source=14.1 
 <para>
  <acronym>RFC</acronym> 7159 specifies that JSON strings should be encoded in UTF8.
  It is therefore not possible for the JSON
  types to conform rigidly to the JSON specification unless the database
  encoding is UTF8. Attempts to directly include characters that
  cannot be represented in the database encoding will fail; conversely,
  characters that can be represented in the database encoding but not
  in UTF8 will be allowed.
 </para>
________________________________________________________-->
 <para>
  <acronym>RFC</acronym> 7159 指定 JSON 字符串应以 UTF8 编码。因此 JSON 类型不可能严格遵守 JSON 规范，除非数据库编码
  是 UTF8。尝试直接包括数据库编码中无法表示的字符将会失败。反过来，能
  在数据库编码中表示但是不在 UTF8 中的字符是被允许的。
 </para>
<!-- pgdoc-cn_end sig_en=92ee39003dfb53b84f12ca94e23d2e7c -->

<!-- pgdoc-cn_start sig_en=9146c7be79ee3ea493780b3132f47530 sig_cn_org=None source=14.1 
 <para>
  <acronym>RFC</acronym> 7159 permits JSON strings to contain Unicode escape sequences
  denoted by <literal>\u<replaceable>XXXX</replaceable></literal>.  In the input
  function for the <type>json</type> type, Unicode escapes are allowed
  regardless of the database encoding, and are checked only for syntactic
  correctness (that is, that four hex digits follow <literal>\u</literal>).
  However, the input function for <type>jsonb</type> is stricter: it disallows
  Unicode escapes for characters that cannot be represented in the database
  encoding.  The <type>jsonb</type> type also
  rejects <literal>\u0000</literal> (because that cannot be represented in
  <productname>PostgreSQL</productname>'s <type>text</type> type), and it insists
  that any use of Unicode surrogate pairs to designate characters outside
  the Unicode Basic Multilingual Plane be correct.  Valid Unicode escapes
  are converted to the equivalent single character for storage;
  this includes folding surrogate pairs into a single character.
 </para>
________________________________________________________-->
 <para>
  <acronym>RFC</acronym> 7159 允许 JSON 字符串包含<literal>\u<replaceable>XXXX</replaceable></literal>
  所标记的 Unicode 转义序列。在<type>json</type>类型的输入函数中，不管数据库
  编码如何都允许 Unicode 转义，并且只检查语法正确性（即，跟在<literal>\u</literal>
  后面的四个十六进制位）。但是，<type>jsonb</type>的输入函数更加严格：它不允许对无法在数据库
  编码中表示的字符进行 Unicode 转义。<type>jsonb</type>类型也拒绝<literal>\u0000</literal>（因为
  <productname>PostgreSQL</productname>的<type>text</type>类型无法表示
  它），并且它坚持使用 Unicode 代理对来标记位于 Unicode 基本多语言平面之外
  的字符是正确的。合法的 Unicode 转义会被转换成等价的单个字符进
  行存储，这包括把代理对折叠成一个单一字符。
 </para>
<!-- pgdoc-cn_end sig_en=9146c7be79ee3ea493780b3132f47530 -->

 <note>
<!-- pgdoc-cn_start sig_en=695628808664d00092b20bb7b4c70c95 sig_cn_org=None source=14.1 
  <para>
   Many of the JSON processing functions described
   in <xref linkend="functions-json"/> will convert Unicode escapes to
   regular characters, and will therefore throw the same types of errors
   just described even if their input is of type <type>json</type>
   not <type>jsonb</type>. The fact that the <type>json</type> input function does
   not make these checks may be considered a historical artifact, although
   it does allow for simple storage (without processing) of JSON Unicode
   escapes in a database encoding that does not support the represented
   characters.
  </para>
________________________________________________________-->
  <para>
   很多<xref linkend="functions-json"/>中描述的 JSON 处理函数将把 Unicode 
   转义转换成常规字符，并且将因此抛出和刚才所描述的同样类型的错误（即使它们
   的输入是类型<type>json</type>而不是<type>jsonb</type>）。<type>json</type>的
   输入函数不做这些检查是由来已久的，不过它确实允许将 JSON Unicode 转义简单
   的（不经处理）存储在一个不支持所表示字符的数据库编码中。
  </para>
<!-- pgdoc-cn_end sig_en=695628808664d00092b20bb7b4c70c95 -->
 </note>

<!-- pgdoc-cn_start sig_en=1d9fb08d6e471df3e9708f03d8e5ec3e sig_cn_org=None source=14.1 
 <para>
  When converting textual JSON input into <type>jsonb</type>, the primitive
  types described by <acronym>RFC</acronym> 7159 are effectively mapped onto
  native <productname>PostgreSQL</productname> types, as shown
  in <xref linkend="json-type-mapping-table"/>.
  Therefore, there are some minor additional constraints on what
  constitutes valid <type>jsonb</type> data that do not apply to
  the <type>json</type> type, nor to JSON in the abstract, corresponding
  to limits on what can be represented by the underlying data type.
  Notably, <type>jsonb</type> will reject numbers that are outside the
  range of the <productname>PostgreSQL</productname> <type>numeric</type> data
  type, while <type>json</type> will not.  Such implementation-defined
  restrictions are permitted by <acronym>RFC</acronym> 7159.  However, in
  practice such problems are far more likely to occur in other
  implementations, as it is common to represent JSON's <type>number</type>
  primitive type as IEEE 754 double precision floating point
  (which <acronym>RFC</acronym> 7159 explicitly anticipates and allows for).
  When using JSON as an interchange format with such systems, the danger
  of losing numeric precision compared to data originally stored
  by <productname>PostgreSQL</productname> should be considered.
 </para>
________________________________________________________-->
 <para>
  在把文本 JSON 输入转换成<type>jsonb</type>时，<acronym>RFC</acronym> 7159描述
  的基本类型会被有效地映射到原生的
  <productname>PostgreSQL</productname>类型（如
  <xref linkend="json-type-mapping-table"/>中所示）。因此，在合法
  <type>jsonb</type>数据的组成上有一些次要额外约束，它们不适合
  <type>json</type>类型和抽象意义上的 JSON，这些约束对应于有关哪些东西不
  能被底层数据类型表示的限制。尤其是，<type>jsonb</type>将拒绝位于
  <productname>PostgreSQL</productname> <type>numeric</type>数据类型范
  围之外的数字，而<type>json</type>则不会。这类实现定义的限制是
  <acronym>RFC</acronym> 7159 所允许的。不过，实际上这类问题更可能发生在其他实
  现中，因为把 JSON 的<type>number</type>基本类型表示为 IEEE 754 双精度浮点
  是很常见的（这也是<acronym>RFC</acronym> 7159 明确期待和允许的）。当在这类系
  统间使用 JSON 作为一种交换格式时，应该考虑丢失数字精度的风险。
 </para>
<!-- pgdoc-cn_end sig_en=1d9fb08d6e471df3e9708f03d8e5ec3e -->

<!-- pgdoc-cn_start sig_en=57112e4a6a94974a0e40a7b118f0e2ea sig_cn_org=None source=14.1 
 <para>
  Conversely, as noted in the table there are some minor restrictions on
  the input format of JSON primitive types that do not apply to
  the corresponding <productname>PostgreSQL</productname> types.
 </para>
________________________________________________________-->
 <para>
  相反地，如表中所述，有一些 JSON 基本类型输入格式上的次要限制并不适用于相
  应的<productname>PostgreSQL</productname>类型。
 </para>
<!-- pgdoc-cn_end sig_en=57112e4a6a94974a0e40a7b118f0e2ea -->

  <table id="json-type-mapping-table">
<!-- pgdoc-cn_start sig_en=004bcd47bf9852ac836c167351bd6139 sig_cn_org=None source=14.1 
     <title>JSON Primitive Types and Corresponding <productname>PostgreSQL</productname> Types</title>
________________________________________________________-->
     <title>JSON 基本类型和相应的<productname>PostgreSQL</productname>类型</title>
<!-- pgdoc-cn_end sig_en=004bcd47bf9852ac836c167351bd6139 -->
     <tgroup cols="3">
      <colspec colname="col1" colwidth="1*"/>
      <colspec colname="col2" colwidth="1*"/>
      <colspec colname="col3" colwidth="2*"/>
      <thead>
<!-- pgdoc-cn_start sig_en=9045764f2419c4f52cb3713d30d22ee8 sig_cn_org=None source=14.1 
       <row>
        <entry>JSON primitive type</entry>
        <entry><productname>PostgreSQL</productname> type</entry>
        <entry>Notes</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>JSON 基本类型</entry>
        <entry><productname>PostgreSQL</productname>类型</entry>
        <entry>注释</entry>
       </row>
<!-- pgdoc-cn_end sig_en=9045764f2419c4f52cb3713d30d22ee8 -->
      </thead>
      <tbody>
<!-- pgdoc-cn_start sig_en=21f4ae3610cda388c55fc45331f3817d sig_cn_org=None source=14.1 
       <row>
        <entry><type>string</type></entry>
        <entry><type>text</type></entry>
        <entry><literal>\u0000</literal> is disallowed, as are Unicode escapes
         representing characters not available in the database encoding</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>string</type></entry>
        <entry><type>text</type></entry>
        <entry><literal>\u0000</literal>是不允许的，因为 Unicode 转义表示数据库编码中不可用的字符</entry>
       </row>
<!-- pgdoc-cn_end sig_en=21f4ae3610cda388c55fc45331f3817d -->
<!-- pgdoc-cn_start sig_en=6966612e02d3f5e91c8c603c6eec930c sig_cn_org=None source=14.1 
       <row>
        <entry><type>number</type></entry>
        <entry><type>numeric</type></entry>
        <entry><literal>NaN</literal> and <literal>infinity</literal> values are disallowed</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>number</type></entry>
        <entry><type>numeric</type></entry>
        <entry>不允许<literal>NaN</literal> 和 <literal>infinity</literal>值</entry>
       </row>
<!-- pgdoc-cn_end sig_en=6966612e02d3f5e91c8c603c6eec930c -->
<!-- pgdoc-cn_start sig_en=fd81aae79ec56b9456ca3c32b5cfc342 sig_cn_org=None source=14.1 
       <row>
        <entry><type>boolean</type></entry>
        <entry><type>boolean</type></entry>
        <entry>Only lowercase <literal>true</literal> and <literal>false</literal> spellings are accepted</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>boolean</type></entry>
        <entry><type>boolean</type></entry>
        <entry>只接受小写<literal>true</literal>和<literal>false</literal>拼写</entry>
       </row>
<!-- pgdoc-cn_end sig_en=fd81aae79ec56b9456ca3c32b5cfc342 -->
<!-- pgdoc-cn_start sig_en=027984603fe04f7b8bc0910013ae5e27 sig_cn_org=None source=14.1 
       <row>
        <entry><type>null</type></entry>
        <entry>(none)</entry>
        <entry>SQL <literal>NULL</literal> is a different concept</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>null</type></entry>
        <entry>(无)</entry>
        <entry>SQL <literal>NULL</literal>是一个不同的概念</entry>
       </row>
<!-- pgdoc-cn_end sig_en=027984603fe04f7b8bc0910013ae5e27 -->
      </tbody>
     </tgroup>
   </table>

 <sect2 id="json-keys-elements">
<!-- pgdoc-cn_start sig_en=361f043fc9c3feefa344dce1895caec9 sig_cn_org=None source=14.1 
  <title>JSON Input and Output Syntax</title>
________________________________________________________-->
  <title>JSON 输入和输出语法</title>
<!-- pgdoc-cn_end sig_en=361f043fc9c3feefa344dce1895caec9 -->
<!-- pgdoc-cn_start sig_en=aaf3070083b6935d1e5bbc93ef3457d9 sig_cn_org=None source=14.1 
  <para>
   The input/output syntax for the JSON data types is as specified in
   <acronym>RFC</acronym> 7159.
  </para>
________________________________________________________-->
  <para>
   <acronym>RFC</acronym> 7159 中定义了 JSON 数据类型的输入/输出语法。
  </para>
<!-- pgdoc-cn_end sig_en=aaf3070083b6935d1e5bbc93ef3457d9 -->
<!-- pgdoc-cn_start sig_en=a096fff3f09337e0fbc60042483ea7ca sig_cn_org=None source=14.1 
  <para>
   The following are all valid <type>json</type> (or <type>jsonb</type>) expressions:
<programlisting>
-&minus; Simple scalar/primitive value
-&minus; Primitive values can be numbers, quoted strings, true, false, or null
SELECT '5'::json;

-&minus; Array of zero or more elements (elements need not be of same type)
SELECT '[1, 2, "foo", null]'::json;

-&minus; Object containing pairs of keys and values
-&minus; Note that object keys must always be quoted strings
SELECT '{"bar": "baz", "balance": 7.77, "active": false}'::json;

-&minus; Arrays and objects can be nested arbitrarily
SELECT '{"foo": [true, "bar"], "tags": {"a": 1, "b": null}}'::json;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   下列都是合法的<type>json</type>（或者<type>jsonb</type>）表达式：
<programlisting>
-- 简单标量/基本值
-- 基本值可以是数字、带引号的字符串、true、false或者null
SELECT '5'::json;

-- 有零个或者更多元素的数组（元素不需要为同一类型）
SELECT '[1, 2, "foo", null]'::json;

-- 包含键值对的对象
-- 注意对象键必须总是带引号的字符串
SELECT '{"bar": "baz", "balance": 7.77, "active": false}'::json;

-- 数组和对象可以被任意嵌套
SELECT '{"foo": [true, "bar"], "tags": {"a": 1, "b": null}}'::json;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=a096fff3f09337e0fbc60042483ea7ca -->

<!-- pgdoc-cn_start sig_en=1ea7d9fe8846faafdf5b1a59d7dbf840 sig_cn_org=ed60c9210bdefc931fde3f29e04cfeff source=15.7 
  <para>
   As previously stated, when a JSON value is input and then printed without
   any additional processing, <type>json</type> outputs the same text that was
   input, while <type>jsonb</type> does not preserve semantically-insignificant
   details such as whitespace.  For example, note the differences here:
<programlisting>
SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::json;
                      json
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {"bar": "baz", "balance": 7.77, "active":false}
(1 row)

SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::jsonb;
                      jsonb
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 {"bar": "baz", "active": false, "balance": 7.77}
(1 row)
</programlisting>
   One semantically-insignificant detail worth noting is that
   in <type>jsonb</type>, numbers will be printed according to the behavior of the
   underlying <type>numeric</type> type.  In practice this means that numbers
   entered with <literal>E</literal> notation will be printed without it, for
   example:
<programlisting>
SELECT '{"reading": 1.230e-5}'::json, '{"reading": 1.230e-5}'::jsonb;
         json          |          jsonb
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 {"reading": 1.230e-5} | {"reading": 0.00001230}
(1 row)
</programlisting>
   However, <type>jsonb</type> will preserve trailing fractional zeroes, as seen
   in this example, even though those are semantically insignificant for
   purposes such as equality checks.
  </para>
________________________________________________________-->
  <para>
   如前所述，当输入一个JSON值并且没有进行额外处理时，<type>json</type>输出与输入相同的文本，而<type>jsonb</type>不保留语义上无关紧要的细节，如空格。例如，请注意这里的差异：
<programlisting>
SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::json;
                      json
-------------------------------------------------
 {"bar": "baz", "balance": 7.77, "active":false}
(1 row)

SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::jsonb;
                      jsonb
--------------------------------------------------
 {"bar": "baz", "active": false, "balance": 7.77}
(1 row)
</programlisting>
   一个值得注意的语义上无关紧要的细节是，在<type>jsonb</type>中，数字将根据底层的<type>numeric</type>类型的行为进行打印。实际上，这意味着使用<literal>E</literal>表示法输入的数字将被打印为没有该表示法，例如：
<programlisting>
SELECT '{"reading": 1.230e-5}'::json, '{"reading": 1.230e-5}'::jsonb;
         json          |          jsonb
-----------------------+-------------------------
 {"reading": 1.230e-5} | {"reading": 0.00001230}
(1 row)
</programlisting>
   然而，<type>jsonb</type>将保留尾部的小数零，如这个例子所示，即使对于诸如相等性检查之类的目的，这些零在语义上是无关紧要的。
</para>
<!-- pgdoc-cn_end sig_en=1ea7d9fe8846faafdf5b1a59d7dbf840 -->

<!-- pgdoc-cn_start sig_en=21a4224ac3281b0ac62bbdd5e4c3559e sig_cn_org=None source=14.1 
  <para>
    For the list of built-in functions and operators available for
    constructing and processing JSON values, see <xref linkend="functions-json"/>.
  </para>
________________________________________________________-->
  <para>
    对于可用于构造和处理 JSON 值的内置函数和运算符的列表，参见 <xref linkend="functions-json"/>。
  </para>
<!-- pgdoc-cn_end sig_en=21a4224ac3281b0ac62bbdd5e4c3559e -->
 </sect2>

 <sect2 id="json-doc-design">
<!-- pgdoc-cn_start sig_en=6ebb80ddb5ccde2b97cbf9b376a7d9c5 sig_cn_org=None source=14.1 
  <title>Designing JSON Documents</title>
________________________________________________________-->
  <title>设计 JSON 文档</title>
<!-- pgdoc-cn_end sig_en=6ebb80ddb5ccde2b97cbf9b376a7d9c5 -->
<!-- pgdoc-cn_start sig_en=629b72f61a56316be7026c14d583dfc2 sig_cn_org=None source=14.1 
  <para>
   Representing data as JSON can be considerably more flexible than
   the traditional relational data model, which is compelling in
   environments where requirements are fluid.  It is quite possible
   for both approaches to co-exist and complement each other within
   the same application.  However, even for applications where maximal
   flexibility is desired, it is still recommended that JSON documents
   have a somewhat fixed structure.  The structure is typically
   unenforced (though enforcing some business rules declaratively is
   possible), but having a predictable structure makes it easier to write
   queries that usefully summarize a set of <quote>documents</quote> (datums)
   in a table.
  </para>
________________________________________________________-->
  <para>
   将数据表示为 JSON 比传统关系数据模型要灵活得多，在需求不固定时
   这种优势更加令人感兴趣。在同一个应用里非常有可能有两种方法共存
   并且互补。不过，即便是在要求最大灵活性的应用中，我们还是推荐
   JSON 文档有固定的结构。该结构通常是非强制的（尽管可能会强制一
   些业务规则），但是有一个可预测的结构会使书写概括一个表中的
   <quote>文档</quote>（数据）集合的查询更容易。
  </para>
<!-- pgdoc-cn_end sig_en=629b72f61a56316be7026c14d583dfc2 -->
<!-- pgdoc-cn_start sig_en=285822e2b03802ef3619889cc500e8f8 sig_cn_org=None source=14.1 
  <para>
   JSON data is subject to the same concurrency-control
   considerations as any other data type when stored in a table.
   Although storing large documents is practicable, keep in mind that
   any update acquires a row-level lock on the whole row.
   Consider limiting JSON documents to a
   manageable size in order to decrease lock contention among updating
   transactions.  Ideally, JSON documents should each
   represent an atomic datum that business rules dictate cannot
   reasonably be further subdivided into smaller datums that
   could be modified independently.
  </para>
________________________________________________________-->
  <para>
   当被存储在表中时，JSON 数据也像其他数据类型一样服从相同的并发
   控制考虑。尽管存储大型文档是可行的，但是要记住任何更新都在整行
   上要求一个行级锁。为了在更新事务之间减少锁争夺，可考虑把 JSON
   文档限制到一个可管理的尺寸。理想情况下，JSON 文档应该每个表示
   一个原子数据，业务规则命令不会进一步把它们划分成更小的可独立修
   改的数据。
  </para>
<!-- pgdoc-cn_end sig_en=285822e2b03802ef3619889cc500e8f8 -->
 </sect2>

 <sect2 id="json-containment">
<!-- pgdoc-cn_start sig_en=ddce65bf3668ccdb201f134b28c03894 sig_cn_org=None source=14.1 
  <title><type>jsonb</type> Containment and Existence</title>
________________________________________________________-->
  <title><type>jsonb</type> 包含和存在</title>
<!-- pgdoc-cn_end sig_en=ddce65bf3668ccdb201f134b28c03894 -->
<!-- pgdoc-cn_start sig_en=0d9fb460132f065d404c275c6dbeb465 sig_cn_org=None source=14.1 
  <indexterm>
    <primary>jsonb</primary>
    <secondary>containment</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm>
    <primary>jsonb</primary>
    <secondary>containment</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=0d9fb460132f065d404c275c6dbeb465 -->
<!-- pgdoc-cn_start sig_en=06e9d2928ed2b2cee2e68c0940753f20 sig_cn_org=None source=14.1 
  <indexterm>
    <primary>jsonb</primary>
    <secondary>existence</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm>
    <primary>jsonb</primary>
    <secondary>existence</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=06e9d2928ed2b2cee2e68c0940753f20 -->
<!-- pgdoc-cn_start sig_en=167f3b76f1228d9a1757f0361597defe sig_cn_org=None source=14.1 
  <para>
    Testing <firstterm>containment</firstterm> is an important capability of
    <type>jsonb</type>.  There is no parallel set of facilities for the
    <type>json</type> type.  Containment tests whether
    one <type>jsonb</type> document has contained within it another one.
    These examples return true except as noted:
  </para>
________________________________________________________-->
  <para>
    测试<firstterm>包含</firstterm>是<type>jsonb</type>的一种重要能力。对
    <type>json</type>类型没有平行的功能集。包含测试会测试一个
    <type>jsonb</type>文档是否被包含在另一个文档中。除了特别注解
    之外，这些例子都会返回真：
  </para>
<!-- pgdoc-cn_end sig_en=167f3b76f1228d9a1757f0361597defe -->
<!-- pgdoc-cn_start sig_en=e0ca2f282dda54fa0a8a334ee313f11e sig_cn_org=None source=14.1 
<programlisting>
-&minus; Simple scalar/primitive values contain only the identical value:
SELECT '"foo"'::jsonb @&gt; '"foo"'::jsonb;

-&minus; The array on the right side is contained within the one on the left:
SELECT '[1, 2, 3]'::jsonb @&gt; '[1, 3]'::jsonb;

-&minus; Order of array elements is not significant, so this is also true:
SELECT '[1, 2, 3]'::jsonb @&gt; '[3, 1]'::jsonb;

-&minus; Duplicate array elements don't matter either:
SELECT '[1, 2, 3]'::jsonb @&gt; '[1, 2, 2]'::jsonb;

-&minus; The object with a single pair on the right side is contained
-&minus; within the object on the left side:
SELECT '{"product": "PostgreSQL", "version": 9.4, "jsonb": true}'::jsonb @&gt; '{"version": 9.4}'::jsonb;

-&minus; The array on the right side is <emphasis>not</emphasis> considered contained within the
-&minus; array on the left, even though a similar array is nested within it:
SELECT '[1, 2, [1, 3]]'::jsonb @&gt; '[1, 3]'::jsonb;  -&minus; yields false

-&minus; But with a layer of nesting, it is contained:
SELECT '[1, 2, [1, 3]]'::jsonb @&gt; '[[1, 3]]'::jsonb;

-&minus; Similarly, containment is not reported here:
SELECT '{"foo": {"bar": "baz"}}'::jsonb @&gt; '{"bar": "baz"}'::jsonb;  -&minus; yields false

-&minus; A top-level key and an empty object is contained:
SELECT '{"foo": {"bar": "baz"}}'::jsonb @&gt; '{"foo": {}}'::jsonb;
</programlisting>
________________________________________________________-->
<programlisting>
-- 简单的标量/基本值只包含相同的值：
SELECT '"foo"'::jsonb @&gt; '"foo"'::jsonb;

-- 右边的数字被包含在左边的数组中：
SELECT '[1, 2, 3]'::jsonb @&gt; '[1, 3]'::jsonb;

-- 数组元素的顺序没有意义，因此这个例子也返回真：
SELECT '[1, 2, 3]'::jsonb @&gt; '[3, 1]'::jsonb;

-- 重复的数组元素也没有关系：
SELECT '[1, 2, 3]'::jsonb @&gt; '[1, 2, 2]'::jsonb;

-- 右边具有一个单一键值对的对象被包含在左边的对象中：
SELECT '{"product": "PostgreSQL", "version": 9.4, "jsonb": true}'::jsonb @&gt; '{"version": 9.4}'::jsonb;

-- 右边的数组<emphasis>不</emphasis>会被认为包含在左边的数组中，
-- 即使其中嵌入了一个相似的数组：
SELECT '[1, 2, [1, 3]]'::jsonb @&gt; '[1, 3]'::jsonb;  -- 得到假

-- 但是如果同样也有嵌套，包含就成立：
SELECT '[1, 2, [1, 3]]'::jsonb @&gt; '[[1, 3]]'::jsonb;

-- 类似的，这个例子也不会被认为是包含：
SELECT '{"foo": {"bar": "baz"}}'::jsonb @> '{"bar": "baz"}'::jsonb;  -- 得到假

-- 包含一个顶层键和一个空对象：
SELECT '{"foo": {"bar": "baz"}}'::jsonb @&gt; '{"foo": {}}'::jsonb;
</programlisting>
<!-- pgdoc-cn_end sig_en=e0ca2f282dda54fa0a8a334ee313f11e -->

<!-- pgdoc-cn_start sig_en=1cce3ac1e667b3edc3e07b525d642094 sig_cn_org=None source=14.1 
  <para>
   The general principle is that the contained object must match the
   containing object as to structure and data contents, possibly after
   discarding some non-matching array elements or object key/value pairs
   from the containing object.
   But remember that the order of array elements is not significant when
   doing a containment match, and duplicate array elements are effectively
   considered only once.
  </para>
________________________________________________________-->
  <para>
   一般原则是被包含的对象必须在结构和数据内容上匹配包含对象，这种匹配
   可以是从包含对象中丢弃了不匹配的数组元素或者对象键值对之后成立。但
   是记住做包含匹配时数组元素的顺序是没有意义的，并且重复的数组元素实
   际也只会考虑一次。
  </para>
<!-- pgdoc-cn_end sig_en=1cce3ac1e667b3edc3e07b525d642094 -->

<!-- pgdoc-cn_start sig_en=2100a4f716274a2774620cb5fd5e44a1 sig_cn_org=None source=14.1 
  <para>
   As a special exception to the general principle that the structures
   must match, an array may contain a primitive value:
  </para>
________________________________________________________-->
  <para>
   结构必须匹配的一般原则有一种特殊情况，一个数组可以包含一个基本值：
  </para>
<!-- pgdoc-cn_end sig_en=2100a4f716274a2774620cb5fd5e44a1 -->
<!-- pgdoc-cn_start sig_en=bd114ca78f6bef411e928a9ac96dd451 sig_cn_org=None source=14.1 
<programlisting>
-&minus; This array contains the primitive string value:
SELECT '["foo", "bar"]'::jsonb @&gt; '"bar"'::jsonb;

-&minus; This exception is not reciprocal -&minus; non-containment is reported here:
SELECT '"bar"'::jsonb @&gt; '["bar"]'::jsonb;  -&minus; yields false
</programlisting>
________________________________________________________-->
<programlisting>
-- 这个数组包含基本字符串值：
SELECT '["foo", "bar"]'::jsonb @&gt; '"bar"'::jsonb;

-- 反之不然，下面的例子会报告“不包含”：
SELECT '"bar"'::jsonb @&gt; '["bar"]'::jsonb;  -- 得到假
</programlisting>
<!-- pgdoc-cn_end sig_en=bd114ca78f6bef411e928a9ac96dd451 -->

<!-- pgdoc-cn_start sig_en=b90d76f79ab96613f4e126a6e947354c sig_cn_org=None source=14.1 
  <para>
    <type>jsonb</type> also has an <firstterm>existence</firstterm> operator, which is
    a variation on the theme of containment: it tests whether a string
    (given as a <type>text</type> value) appears as an object key or array
    element at the top level of the <type>jsonb</type> value.
    These examples return true except as noted:
  </para>
________________________________________________________-->
  <para>
    <type>jsonb</type>还有一个<firstterm>存在</firstterm>操作符，它是包含的一种
    变体：它测试一个字符串（以一个<type>text</type>值的形式给出）是否出
    现在<type>jsonb</type>值顶层的一个对象键或者数组元素中。除非特别注解，
    下面这些例子返回真：
  </para>
<!-- pgdoc-cn_end sig_en=b90d76f79ab96613f4e126a6e947354c -->
<!-- pgdoc-cn_start sig_en=7e9bdd8944c3c22ec972cfd748a0d61f sig_cn_org=None source=14.1 
<programlisting>
-&minus; String exists as array element:
SELECT '["foo", "bar", "baz"]'::jsonb ? 'bar';

-&minus; String exists as object key:
SELECT '{"foo": "bar"}'::jsonb ? 'foo';

-&minus; Object values are not considered:
SELECT '{"foo": "bar"}'::jsonb ? 'bar';  -&minus; yields false

-&minus; As with containment, existence must match at the top level:
SELECT '{"foo": {"bar": "baz"}}'::jsonb ? 'bar'; -&minus; yields false

-&minus; A string is considered to exist if it matches a primitive JSON string:
SELECT '"foo"'::jsonb ? 'foo';
</programlisting>
________________________________________________________-->
<programlisting>
-- 字符串作为一个数组元素存在：
SELECT '["foo", "bar", "baz"]'::jsonb ? 'bar';

-- 字符串作为一个对象键存在：
SELECT '{"foo": "bar"}'::jsonb ? 'foo';

-- 不考虑对象值：
SELECT '{"foo": "bar"}'::jsonb ? 'bar';  -- 得到假

-- 和包含一样，存在必须在顶层匹配：
SELECT '{"foo": {"bar": "baz"}}'::jsonb ? 'bar'; -- 得到假

-- 如果一个字符串匹配一个基本 JSON 字符串，它就被认为存在：
SELECT '"foo"'::jsonb ? 'foo';
</programlisting>
<!-- pgdoc-cn_end sig_en=7e9bdd8944c3c22ec972cfd748a0d61f -->

<!-- pgdoc-cn_start sig_en=150d995f28545488e843686f6e482248 sig_cn_org=None source=14.1 
  <para>
    JSON objects are better suited than arrays for testing containment or
    existence when there are many keys or elements involved, because
    unlike arrays they are internally optimized for searching, and do not
    need to be searched linearly.
  </para>
________________________________________________________-->
  <para>
    当涉及很多键或元素时，JSON 对象比数组更适合于做包含或存在测试，
    因为它们不像数组，进行搜索时会进行内部优化，并且不需要被线性搜索。
  </para>
<!-- pgdoc-cn_end sig_en=150d995f28545488e843686f6e482248 -->

  <tip>
<!-- pgdoc-cn_start sig_en=0260107f2c197b99b9da88f7bb2c7420 sig_cn_org=None source=14.1 
   <para>
    Because JSON containment is nested, an appropriate query can skip
    explicit selection of sub-objects.  As an example, suppose that we have
    a <structfield>doc</structfield> column containing objects at the top level, with
    most objects containing <literal>tags</literal> fields that contain arrays of
    sub-objects.  This query finds entries in which sub-objects containing
    both <literal>"term":"paris"</literal> and <literal>"term":"food"</literal> appear,
    while ignoring any such keys outside the <literal>tags</literal> array:
<programlisting>
SELECT doc-&gt;'site_name' FROM websites
  WHERE doc @&gt; '{"tags":[{"term":"paris"}, {"term":"food"}]}';
</programlisting>
    One could accomplish the same thing with, say,
<programlisting>
SELECT doc-&gt;'site_name' FROM websites
  WHERE doc-&gt;'tags' @&gt; '[{"term":"paris"}, {"term":"food"}]';
</programlisting>
    but that approach is less flexible, and often less efficient as well.
   </para>
________________________________________________________-->
   <para>
    由于 JSON 的包含是嵌套的，因此一个恰当的查询可以跳过对子对象的显式选择。
    例如，假设我们在顶层有一个<structfield>doc</structfield>列包含着对象，大部分对象
    包含着<literal>tags</literal>域，其中有子对象的数组。这个查询会找到其中出现了
    同时包含<literal>"term":"paris"</literal>和<literal>"term":"food"</literal>的子对象
    的项，而忽略任何位于<literal>tags</literal>数组之外的这类键：
<programlisting>
SELECT doc-&gt;'site_name' FROM websites
  WHERE doc @&gt; '{"tags":[{"term":"paris"}, {"term":"food"}]}';
</programlisting>
    可以用下面的查询完成同样的事情：
<programlisting>
SELECT doc-&gt;'site_name' FROM websites
  WHERE doc-&gt;'tags' @&gt; '[{"term":"paris"}, {"term":"food"}]';
</programlisting>
    但是后一种方法灵活性较差，并且常常也效率更低。
   </para>
<!-- pgdoc-cn_end sig_en=0260107f2c197b99b9da88f7bb2c7420 -->

<!-- pgdoc-cn_start sig_en=f890f36e9db1cd232f8c21b20b184dc4 sig_cn_org=None source=14.1 
   <para>
    On the other hand, the JSON existence operator is not nested: it will
    only look for the specified key or array element at top level of the
    JSON value.
   </para>
________________________________________________________-->
   <para>
    在另一方面，JSON 的存在操作符不是嵌套的：它将只在 JSON 值的顶层
    查找指定的键或数组元素。
   </para>
<!-- pgdoc-cn_end sig_en=f890f36e9db1cd232f8c21b20b184dc4 -->
  </tip>

<!-- pgdoc-cn_start sig_en=3beb43896105809856d6c289fa1960e5 sig_cn_org=None source=14.1 
  <para>
    The various containment and existence operators, along with all other
    JSON operators and functions are documented
    in <xref linkend="functions-json"/>.
  </para>
________________________________________________________-->
  <para>
    <xref linkend="functions-json"/>中记录了多个包含和存在操作符，以及
    所有其他 JSON 操作符和函数。
  </para>
<!-- pgdoc-cn_end sig_en=3beb43896105809856d6c289fa1960e5 -->
 </sect2>

 <sect2 id="json-indexing">
<!-- pgdoc-cn_start sig_en=8d60078f322fe9cea1ed590bf68dfacb sig_cn_org=None source=14.1 
  <title><type>jsonb</type> Indexing</title>
________________________________________________________-->
  <title><type>jsonb</type> 索引</title>
<!-- pgdoc-cn_end sig_en=8d60078f322fe9cea1ed590bf68dfacb -->
<!-- pgdoc-cn_start sig_en=5b427f2b9a86b6de793278dd3c6a2614 sig_cn_org=None source=14.1 
  <indexterm>
    <primary>jsonb</primary>
    <secondary>indexes on</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm>
    <primary>jsonb</primary>
    <secondary>indexes on</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=5b427f2b9a86b6de793278dd3c6a2614 -->

<!-- pgdoc-cn_start sig_en=b6617b36103059ac14258005b501da67 sig_cn_org=None source=14.1 
  <para>
    GIN indexes can be used to efficiently search for
    keys or key/value pairs occurring within a large number of
    <type>jsonb</type> documents (datums).
    Two GIN <quote>operator classes</quote> are provided, offering different
    performance and flexibility trade-offs.
  </para>
________________________________________________________-->
  <para>
    GIN 索引可以被用来有效地搜索在大量<type>jsonb</type>文档（数据）中出现
    的键或者键值对。提供了两种 GIN <quote>操作符类</quote>，它们在性能和灵活
    性方面做出了不同的平衡。
  </para>
<!-- pgdoc-cn_end sig_en=b6617b36103059ac14258005b501da67 -->
<!-- pgdoc-cn_start sig_en=f02bfb91075a1d3f0c3004712b887426 sig_cn_org=4a7690c2ea628b8bf3005c3520f15655 source=15.7 
  <para>
    The default GIN operator class for <type>jsonb</type> supports queries with
    the key-exists operators <literal>?</literal>, <literal>?|</literal>
    and <literal>?&amp;</literal>, the containment operator
    <literal>@&gt;</literal>, and the <type>jsonpath</type> match
    operators <literal>@?</literal> and <literal>@@</literal>.
    (For details of the semantics that these operators
    implement, see <xref linkend="functions-jsonb-op-table"/>.)
    An example of creating an index with this operator class is:
<programlisting>
CREATE INDEX idxgin ON api USING GIN (jdoc);
</programlisting>
    The non-default GIN operator class <literal>jsonb_path_ops</literal>
    does not support the key-exists operators, but it does support
    <literal>@&gt;</literal>, <literal>@?</literal> and <literal>@@</literal>.
    An example of creating an index with this operator class is:
<programlisting>
CREATE INDEX idxginp ON api USING GIN (jdoc jsonb_path_ops);
</programlisting>
  </para>
________________________________________________________-->
  <para>
    默认的<type>jsonb</type> GIN操作符类支持使用键存在操作符<literal>?</literal>、<literal>?|</literal>和<literal>?&amp;</literal>、包含操作符<literal>@&gt;</literal>，以及<type>jsonpath</type>匹配操作符<literal>@?</literal>和<literal>@@</literal>。
    （有关这些操作符实现的语义细节，请参见<xref linkend="functions-jsonb-op-table"/>。）
    使用此操作符类创建索引的示例为：
<programlisting>
CREATE INDEX idxgin ON api USING GIN (jdoc);
</programlisting>
    非默认的GIN操作符类<literal>jsonb_path_ops</literal>不支持键存在操作符，但支持<literal>@&gt;</literal>、<literal>@?</literal>和<literal>@@</literal>。
    使用此操作符类创建索引的示例为：
<programlisting>
CREATE INDEX idxginp ON api USING GIN (jdoc jsonb_path_ops);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=f02bfb91075a1d3f0c3004712b887426 -->

<!-- pgdoc-cn_start sig_en=0410b38b7a8ff89bd33f594681e77427 sig_cn_org=None source=14.1 
  <para>
    Consider the example of a table that stores JSON documents
    retrieved from a third-party web service, with a documented schema
    definition.  A typical document is:
<programlisting>
{
    "guid": "9c36adc1-7fb5-4d5b-83b4-90356a46061a",
    "name": "Angela Barton",
    "is_active": true,
    "company": "Magnafone",
    "address": "178 Howard Place, Gulf, Washington, 702",
    "registered": "2009-11-07T08:53:22 +08:00",
    "latitude": 19.793713,
    "longitude": 86.513373,
    "tags": [
        "enim",
        "aliquip",
        "qui"
    ]
}
</programlisting>
    We store these documents in a table named <structname>api</structname>,
    in a <type>jsonb</type> column named <structfield>jdoc</structfield>.
    If a GIN index is created on this column,
    queries like the following can make use of the index:
<programlisting>
-&minus; Find documents in which the key "company" has value "Magnafone"
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @&gt; '{"company": "Magnafone"}';
</programlisting>
    However, the index could not be used for queries like the
    following, because though the operator <literal>?</literal> is indexable,
    it is not applied directly to the indexed column <structfield>jdoc</structfield>:
<programlisting>
-&minus; Find documents in which the key "tags" contains key or array element "qui"
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc -&gt; 'tags' ? 'qui';
</programlisting>
    Still, with appropriate use of expression indexes, the above
    query can use an index.  If querying for particular items within
    the <literal>"tags"</literal> key is common, defining an index like this
    may be worthwhile:
<programlisting>
CREATE INDEX idxgintags ON api USING GIN ((jdoc -&gt; 'tags'));
</programlisting>
    Now, the <literal>WHERE</literal> clause <literal>jdoc -&gt; 'tags' ? 'qui'</literal>
    will be recognized as an application of the indexable
    operator <literal>?</literal> to the indexed
    expression <literal>jdoc -&gt; 'tags'</literal>.
    (More information on expression indexes can be found in <xref
    linkend="indexes-expressional"/>.)
  </para>
________________________________________________________-->
  <para>
    考虑这样一个例子：一个表存储了从一个第三方 Web 服务检索到的 JSON
    文档，并且有一个模式定义。一个典型的文档：
<programlisting>
{
    "guid": "9c36adc1-7fb5-4d5b-83b4-90356a46061a",
    "name": "Angela Barton",
    "is_active": true,
    "company": "Magnafone",
    "address": "178 Howard Place, Gulf, Washington, 702",
    "registered": "2009-11-07T08:53:22 +08:00",
    "latitude": 19.793713,
    "longitude": 86.513373,
    "tags": [
        "enim",
        "aliquip",
        "qui"
    ]
}
</programlisting>
    我们把这些文档存储在一个名为<structname>api</structname>的表的名为
    <structfield>jdoc</structfield>的<type>jsonb</type>列中。如果在这个列上创建一个
    GIN 索引，下面这样的查询就能利用该索引：
<programlisting>
-- 寻找键 "company" 有值 "Magnafone" 的文档
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @&gt; '{"company": "Magnafone"}';
</programlisting>
    不过，该索引不能被用于下面这样的查询，因为尽管操作符<literal>?</literal>
    是可索引的，但它不能直接被应用于被索引列<structfield>jdoc</structfield>：
<programlisting>
-- 寻找这样的文档：其中的键 "tags" 包含键或数组元素 "qui"
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc -&gt; 'tags' ? 'qui';
</programlisting>
    但是，通过适当地使用表达式索引，上述查询也能使用一个索引。
    如果对<literal>"tags"</literal>键中的特定项的查询很常见，可能值得
    定义一个这样的索引：
<programlisting>
CREATE INDEX idxgintags ON api USING gin ((jdoc -&gt; 'tags'));
</programlisting>
    现在，<literal>WHERE</literal> 子句 <literal>jdoc -&gt; 'tags' ? 'qui'</literal>
    将被识别为可索引操作符<literal>?</literal>在索引表达式<literal>jdoc -&gt; 'tags'</literal>
    上的应用（更多有关表达式索引的信息可见<xref
    linkend="indexes-expressional"/>）。
  </para>
<!-- pgdoc-cn_end sig_en=0410b38b7a8ff89bd33f594681e77427 -->

<!-- pgdoc-cn_start sig_en=8dd6b819638464b0100a1575ad9a1aae sig_cn_org=None source=14.1 
  <para>
    Another approach to querying is to exploit containment, for example:
<programlisting>
-&minus; Find documents in which the key "tags" contains array element "qui"
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @&gt; '{"tags": ["qui"]}';
</programlisting>
    A simple GIN index on the <structfield>jdoc</structfield> column can support this
    query.  But note that such an index will store copies of every key and
    value in the <structfield>jdoc</structfield> column, whereas the expression index
    of the previous example stores only data found under
    the <literal>tags</literal> key.  While the simple-index approach is far more
    flexible (since it supports queries about any key), targeted expression
    indexes are likely to be smaller and faster to search than a simple
    index.
  </para>
________________________________________________________-->
  <para>
    另一种查询的方法是利用包含，例如：
<programlisting>
-- 寻找这样的文档：其中键 "tags" 包含数组元素 "qui"
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @&gt; '{"tags": ["qui"]}';
</programlisting>
    <structfield>jdoc</structfield>列上的一个简单 GIN 索引就能支持这个查询。
    但是注意这样一个索引将会存储<structfield>jdoc</structfield>列中每一个键
    和值的拷贝，然而前一个例子的表达式索引只存储<literal>tags</literal>
    键下找到的数据。虽然简单索引的方法更加灵活（因为它支持有关任
    意键的查询），定向的表达式索引更小并且搜索速度比简单索引更快。
  </para>
<!-- pgdoc-cn_end sig_en=8dd6b819638464b0100a1575ad9a1aae -->

<!-- pgdoc-cn_start sig_en=63ed811714b6e89fb1d0122dc03df601 sig_cn_org=8dd83f9bfb3fec756a9364e79f619dd9 source=15.7 
  <para>
    GIN indexes also support the <literal>@?</literal>
    and <literal>@@</literal> operators, which
    perform <type>jsonpath</type> matching.  Examples are
<programlisting>
SELECT jdoc->'guid', jdoc->'name' FROM api WHERE jdoc @? '$.tags[*] ? (@ == "qui")';
</programlisting>
<programlisting>
SELECT jdoc->'guid', jdoc->'name' FROM api WHERE jdoc @@ '$.tags[*] == "qui"';
</programlisting>
    For these operators, a GIN index extracts clauses of the form
    <literal><replaceable>accessors_chain</replaceable>
    = <replaceable>constant</replaceable></literal> out of
    the <type>jsonpath</type> pattern, and does the index search based on
    the keys and values mentioned in these clauses.  The accessors chain
    may include <literal>.<replaceable>key</replaceable></literal>,
    <literal>[*]</literal>,
    and <literal>[<replaceable>index</replaceable>]</literal> accessors.
    The <literal>jsonb_ops</literal> operator class also
    supports <literal>.*</literal> and <literal>.**</literal> accessors,
    but the <literal>jsonb_path_ops</literal> operator class does not.
  </para>
________________________________________________________-->
  <para>
    GIN索引还支持<literal>@?</literal>和<literal>@@</literal>操作符，执行<type>jsonpath</type>匹配。示例为
<programlisting>
SELECT jdoc->'guid', jdoc->'name' FROM api WHERE jdoc @? '$.tags[*] ? (@ == "qui")';
</programlisting>
<programlisting>
SELECT jdoc->'guid', jdoc->'name' FROM api WHERE jdoc @@ '$.tags[*] == "qui"';
</programlisting>
    对于这些操作符，GIN索引从<type>jsonpath</type>模式中提取形如
    <literal><replaceable>accessors_chain</replaceable>
    = <replaceable>constant</replaceable></literal>的子句，并基于这些子句中提到的键和值进行索引搜索。访问器链
    可能包括<literal>.<replaceable>key</replaceable></literal>、
    <literal>[*]</literal>和
    <literal>[<replaceable>index</replaceable>]</literal>访问器。
    <literal>jsonb_ops</literal>操作符类还支持<literal>.*</literal>和<literal>.**</literal>访问器，
    但<literal>jsonb_path_ops</literal>操作符类不支持。
  </para>
<!-- pgdoc-cn_end sig_en=63ed811714b6e89fb1d0122dc03df601 -->

<!-- pgdoc-cn_start sig_en=5f965778c75002945a3e1de4222ab6cc sig_cn_org=43e8811fe9c548293966d38c495c5420 source=15.7 
  <para>
    Although the <literal>jsonb_path_ops</literal> operator class supports
    only queries with the <literal>@&gt;</literal>, <literal>@?</literal>
    and <literal>@@</literal> operators, it has notable
    performance advantages over the default operator
    class <literal>jsonb_ops</literal>.  A <literal>jsonb_path_ops</literal>
    index is usually much smaller than a <literal>jsonb_ops</literal>
    index over the same data, and the specificity of searches is better,
    particularly when queries contain keys that appear frequently in the
    data.  Therefore search operations typically perform better
    than with the default operator class.
  </para>
________________________________________________________-->
  <para>
    尽管<literal>jsonb_path_ops</literal>操作符类仅支持使用<literal>@&gt;</literal>、
    <literal>@?</literal>和<literal>@@</literal>操作符的查询，但与默认操作符类
    <literal>jsonb_ops</literal>相比，它具有显著的性能优势。通常，<literal>jsonb_path_ops</literal>
    索引比相同数据上的<literal>jsonb_ops</literal>索引要小得多，并且搜索的特异性更好，
    特别是当查询包含在数据中频繁出现的键时。因此，搜索操作通常比使用默认操作符类时性能更好。
  </para>
<!-- pgdoc-cn_end sig_en=5f965778c75002945a3e1de4222ab6cc -->

<!-- pgdoc-cn_start sig_en=fa8365d02bc5a6f2dad71f573a23b8f4 sig_cn_org=None source=14.1 
  <para>
    The technical difference between a <literal>jsonb_ops</literal>
    and a <literal>jsonb_path_ops</literal> GIN index is that the former
    creates independent index items for each key and value in the data,
    while the latter creates index items only for each value in the
    data.
    <footnote>
     <para>
      For this purpose, the term <quote>value</quote> includes array elements,
      though JSON terminology sometimes considers array elements distinct
      from values within objects.
     </para>
    </footnote>
    Basically, each <literal>jsonb_path_ops</literal> index item is
    a hash of the value and the key(s) leading to it; for example to index
    <literal>{"foo": {"bar": "baz"}}</literal>, a single index item would
    be created incorporating all three of <literal>foo</literal>, <literal>bar</literal>,
    and <literal>baz</literal> into the hash value.  Thus a containment query
    looking for this structure would result in an extremely specific index
    search; but there is no way at all to find out whether <literal>foo</literal>
    appears as a key.  On the other hand, a <literal>jsonb_ops</literal>
    index would create three index items representing <literal>foo</literal>,
    <literal>bar</literal>, and <literal>baz</literal> separately; then to do the
    containment query, it would look for rows containing all three of
    these items.  While GIN indexes can perform such an AND search fairly
    efficiently, it will still be less specific and slower than the
    equivalent <literal>jsonb_path_ops</literal> search, especially if
    there are a very large number of rows containing any single one of the
    three index items.
  </para>
________________________________________________________-->
  <para>
    <literal>jsonb_ops</literal>和<literal>jsonb_path_ops</literal> 
    GIN 索引之间的技术区别是前者为数据中的每一个键和值创建独立的索引项，
    而后者值为该数据中的每个值创建索引项。
    <footnote>
     <para>
      对于这种目的，术语<quote>值</quote>包括数组元素，尽管 JSON 的术语有时
      认为数组元素与对象内的值不同。
     </para>
    </footnote>
    基本上，每一个<literal>jsonb_path_ops</literal>索引项是其所对应的值和
    键的哈希。例如要索引<literal>{"foo": {"bar": "baz"}}</literal>，将创建一个
    单一的索引项，它把所有三个<literal>foo</literal>、<literal>bar</literal>、
    和<literal>baz</literal>合并到哈希值中。因此一个查找这个结构的包含查询可能
    导致极度详细的索引搜索。但是根本没有办法找到<literal>foo</literal>是否作为
    一个键出现。在另一方面，一个<literal>jsonb_ops</literal>会创建三个索引
    项分别表示<literal>foo</literal>、<literal>bar</literal>和<literal>baz</literal>。那么要
    做同样的包含查询，它将会查找包含所有三个项的行。虽然 GIN 索引能够相当
    有效地执行这种 AND 搜索，它仍然不如等效的
    <literal>jsonb_path_ops</literal>搜索那样详细和快速（特别是如果有大量
    行包含三个索引项中的任意一个时）。
  </para>
<!-- pgdoc-cn_end sig_en=fa8365d02bc5a6f2dad71f573a23b8f4 -->

<!-- pgdoc-cn_start sig_en=83b987e94ac09e670e50b2230540f264 sig_cn_org=None source=14.1 
  <para>
    A disadvantage of the <literal>jsonb_path_ops</literal> approach is
    that it produces no index entries for JSON structures not containing
    any values, such as <literal>{"a": {}}</literal>.  If a search for
    documents containing such a structure is requested, it will require a
    full-index scan, which is quite slow.  <literal>jsonb_path_ops</literal> is
    therefore ill-suited for applications that often perform such searches.
  </para>
________________________________________________________-->
  <para>
    <literal>jsonb_path_ops</literal>方法的一个不足是它不会为不包含任何值
    的 JSON 结构创建索引项，例如<literal>{"a": {}}</literal>。如果需要搜索包
    含这样一种结构的文档，它将要求一次全索引扫描，那就非常慢。
    因此<literal>jsonb_path_ops</literal>不适合经常执行这类搜索的应用。
  </para>
<!-- pgdoc-cn_end sig_en=83b987e94ac09e670e50b2230540f264 -->

<!-- pgdoc-cn_start sig_en=891b19fe8212cb4c3cdd37a1a755a2bc sig_cn_org=None source=14.1 
  <para>
    <type>jsonb</type> also supports <literal>btree</literal> and <literal>hash</literal>
    indexes.  These are usually useful only if it's important to check
    equality of complete JSON documents.
    The <literal>btree</literal> ordering for <type>jsonb</type> datums is seldom
    of great interest, but for completeness it is:
<synopsis>
<replaceable>Object</replaceable> > <replaceable>Array</replaceable> > <replaceable>Boolean</replaceable> > <replaceable>Number</replaceable> > <replaceable>String</replaceable> > <replaceable>Null</replaceable>

<replaceable>Object with n pairs</replaceable> > <replaceable>object with n - 1 pairs</replaceable>

<replaceable>Array with n elements</replaceable> > <replaceable>array with n - 1 elements</replaceable>
</synopsis>
      Objects with equal numbers of pairs are compared in the order:
<synopsis>
<replaceable>key-1</replaceable>, <replaceable>value-1</replaceable>, <replaceable>key-2</replaceable> ...
</synopsis>
      Note that object keys are compared in their storage order;
      in particular, since shorter keys are stored before longer keys, this
      can lead to results that might be unintuitive, such as:
<programlisting>
{ "aa": 1, "c": 1} > {"b": 1, "d": 1}
</programlisting>
      Similarly, arrays with equal numbers of elements are compared in the
      order:
<synopsis>
<replaceable>element-1</replaceable>, <replaceable>element-2</replaceable> ...
</synopsis>
      Primitive JSON values are compared using the same
      comparison rules as for the underlying
      <productname>PostgreSQL</productname> data type.  Strings are
      compared using the default database collation.
  </para>
________________________________________________________-->
  <para>
    <type>jsonb</type>也支持<literal>btree</literal>和<literal>hash</literal>索引。
    这通常值用于检查完整 JSON 文档等值非常重要的场合。<type>jsonb</type>
    数据的<literal>btree</literal>顺序很少有人关系，但是为了完整性其顺序是：
<synopsis>
<replaceable>对象</replaceable> > <replaceable>数组</replaceable> > <replaceable>布尔</replaceable> > <replaceable>数字</replaceable> > <replaceable>字符串</replaceable> > <replaceable>空值</replaceable>

<replaceable>带有 n 对的对象</replaceable> > <replaceable>带有 n - 1 对的对象</replaceable>

<replaceable>带有 n 个元素的数组</replaceable> > <replaceable>带有 n - 1 个元素的数组</replaceable>
</synopsis>
      具有相同数量对的对象这样比较：
<synopsis>
<replaceable>key-1</replaceable>, <replaceable>value-1</replaceable>, <replaceable>key-2</replaceable> ...
</synopsis>
      注意对象键被按照它们的存储顺序进行比较，特别是由于较短的键被存储在
      较长的键之前，这可能导致结果不直观，例如：
<programlisting>
{ "aa": 1, "c": 1} > {"b": 1, "d": 1}
</programlisting>
      相似地，具有相同元素数量的数组按照以下顺序比较：
<synopsis>
<replaceable>element-1</replaceable>, <replaceable>element-2</replaceable> ...
</synopsis>
      基本 JSON 值的比较会使用低层<productname>PostgreSQL</productname>
      数据类型相同的比较规则进行。字符串的比较会使用默认的数据库排序规则。
  </para>
<!-- pgdoc-cn_end sig_en=891b19fe8212cb4c3cdd37a1a755a2bc -->
 </sect2>

 <sect2 id="jsonb-subscripting">
<!-- pgdoc-cn_start sig_en=44bfa766a49aa901e40234401b60bcbb sig_cn_org=None source=14.1 
  <title><type>jsonb</type> Subscripting</title>
________________________________________________________-->
  <title><type>jsonb</type> 下标</title>
<!-- pgdoc-cn_end sig_en=44bfa766a49aa901e40234401b60bcbb -->
<!-- pgdoc-cn_start sig_en=7540641a7e69942bacfa544ab88ab879 sig_cn_org=None source=14.1 
  <para>
   The <type>jsonb</type> data type supports array-style subscripting expressions
   to extract and modify elements. Nested values can be indicated by chaining
   subscripting expressions, following the same rules as the <literal>path</literal>
   argument in the <literal>jsonb_set</literal> function. If a <type>jsonb</type>
   value is an array, numeric subscripts start at zero, and negative integers count
   backwards from the last element of the array. Slice expressions are not supported.
   The result of a subscripting expression is always of the jsonb data type.
  </para>
________________________________________________________-->
  <para>
   <type>jsonb</type> 数据类型支持用于检索和修改元素的数组样式索引。 嵌套值与 <literal>jsonb_set</literal> 函数中<literal>path</literal>参数规则相同，可以被链式下标表达式指定。如果<type>jsonb</type>
   类型的值是一个数组，数值下标从零开始，负整数从数组的最后的元素倒数。 不支持切片表达式。下标表达式的结果始终是 jsonb 数据类型。
  </para>
<!-- pgdoc-cn_end sig_en=7540641a7e69942bacfa544ab88ab879 -->

<!-- pgdoc-cn_start sig_en=322f4e81b2e9ee18767913b91f2294c2 sig_cn_org=None source=14.1 
  <para>
   <command>UPDATE</command> statements may use subscripting in the
   <literal>SET</literal> clause to modify <type>jsonb</type> values. Subscript
   paths must be traversable for all affected values insofar as they exist. For
   instance, the path <literal>val['a']['b']['c']</literal> can be traversed all
   the way to <literal>c</literal> if every <literal>val</literal>,
   <literal>val['a']</literal>, and <literal>val['a']['b']</literal> is an
   object. If any <literal>val['a']</literal> or <literal>val['a']['b']</literal>
   is not defined, it will be created as an empty object and filled as
   necessary. However, if any <literal>val</literal> itself or one of the
   intermediary values is defined as a non-object such as a string, number, or
   <literal>jsonb</literal> <literal>null</literal>, traversal cannot proceed so
   an error is raised and the transaction aborted.
  </para>
________________________________________________________-->
  <para>
   <command>UPDATE</command> 语句或许在
   <literal>SET</literal> 子句中使用下标来修改 <type>jsonb</type> 值。下标路径必须对它存在范围内的所有受影响的值都是可遍历的。 例如，<literal>val</literal>,<literal>val['a']</literal>,和 <literal>val['a']['b']</literal>如果每个路径都是一个对象，  则<literal>val['a']['b']['c']</literal>路径可以一直被遍历访问到 <literal>c</literal>， 如果 <literal>val['a']</literal> 或者 <literal>val['a']['b']</literal>
   中任何一个没有定义， 将创建为空对象并根据需要进行填充。 但是， 如果 <literal>val</literal> 本身或者其中任何一个中间值被定义为非对象， 例如 字符串， 数字，或者<literal>jsonb</literal> <literal>null</literal>等，将无法访问并发生错误，事务将中止。
  </para>
<!-- pgdoc-cn_end sig_en=322f4e81b2e9ee18767913b91f2294c2 -->

<!-- pgdoc-cn_start sig_en=c7833954a37e4b9bd5f6c3327ed63526 sig_cn_org=af41989028271bc59b94c32192f0d7db source=15.7 
  <para>
   An example of subscripting syntax:

<programlisting>

-&minus; Extract object value by key
SELECT ('{"a": 1}'::jsonb)['a'];

-&minus; Extract nested object value by key path
SELECT ('{"a": {"b": {"c": 1}}}'::jsonb)['a']['b']['c'];

-&minus; Extract array element by index
SELECT ('[1, "2", null]'::jsonb)[1];

-&minus; Update object value by key. Note the quotes around '1': the assigned
-&minus; value must be of the jsonb type as well
UPDATE table_name SET jsonb_field['key'] = '1';

-&minus; This will raise an error if any record's jsonb_field['a']['b'] is something
-&minus; other than an object. For example, the value {"a": 1} has a numeric value
-&minus; of the key 'a'.
UPDATE table_name SET jsonb_field['a']['b']['c'] = '1';

-&minus; Filter records using a WHERE clause with subscripting. Since the result of
-&minus; subscripting is jsonb, the value we compare it against must also be jsonb.
-&minus; The double quotes make "value" also a valid jsonb string.
SELECT * FROM table_name WHERE jsonb_field['key'] = '"value"';
</programlisting>

   <type>jsonb</type> assignment via subscripting handles a few edge cases
   differently from <literal>jsonb_set</literal>. When a source <type>jsonb</type>
   value is <literal>NULL</literal>, assignment via subscripting will proceed
   as if it was an empty JSON value of the type (object or array) implied by the
   subscript key:

<programlisting>
-&minus; Where jsonb_field was NULL, it is now {"a": 1}
UPDATE table_name SET jsonb_field['a'] = '1';

-&minus; Where jsonb_field was NULL, it is now [1]
UPDATE table_name SET jsonb_field[0] = '1';
</programlisting>

   If an index is specified for an array containing too few elements,
   <literal>NULL</literal> elements will be appended until the index is reachable
   and the value can be set.

<programlisting>
-&minus; Where jsonb_field was [], it is now [null, null, 2];
-&minus; where jsonb_field was [0], it is now [0, null, 2]
UPDATE table_name SET jsonb_field[2] = '2';
</programlisting>

   A <type>jsonb</type> value will accept assignments to nonexistent subscript
   paths as long as the last existing element to be traversed is an object or
   array, as implied by the corresponding subscript (the element indicated by
   the last subscript in the path is not traversed and may be anything). Nested
   array and object structures will be created, and in the former case
   <literal>null</literal>-padded, as specified by the subscript path until the
   assigned value can be placed.

<programlisting>
-&minus; Where jsonb_field was {}, it is now {"a": [{"b": 1}]}
UPDATE table_name SET jsonb_field['a'][0]['b'] = '1';

-&minus; Where jsonb_field was [], it is now [null, {"a": 1}]
UPDATE table_name SET jsonb_field[1]['a'] = '1';
</programlisting>

  </para>
________________________________________________________-->
  <para>
   下面是下标语法的一个示例：

<programlisting>

-- 通过键提取对象值
SELECT ('{"a": 1}'::jsonb)['a'];

-- 通过键路径提取嵌套对象值
SELECT ('{"a": {"b": {"c": 1}}}'::jsonb)['a']['b']['c'];

-- 通过索引提取数组元素
SELECT ('[1, "2", null]'::jsonb)[1];

-- 通过键更新对象值。注意'1'周围的引号：分配的值也必须是jsonb类型
UPDATE table_name SET jsonb_field['key'] = '1';

-- 如果任何记录的jsonb_field['a']['b']不是对象，则会引发错误。例如，值{"a": 1}具有键'a'的数值。
UPDATE table_name SET jsonb_field['a']['b']['c'] = '1';

-- 使用下标的WHERE子句过滤记录。由于下标的结果是jsonb，我们比较的值也必须是jsonb。双引号使"value"也成为有效的jsonb字符串。
SELECT * FROM table_name WHERE jsonb_field['key'] = '"value"';
</programlisting>

   通过下标赋值<type>jsonb</type>处理一些边缘情况与<literal>jsonb_set</literal>不同。当源<type>jsonb</type>值为<literal>NULL</literal>时，通过下标赋值将继续进行，就好像它是由下标键隐含的类型（对象或数组）的空JSON值：

<programlisting>
-- 其中jsonb_field为NULL，现在是{"a": 1}
UPDATE table_name SET jsonb_field['a'] = '1';

-- 其中jsonb_field为NULL，现在是[1]
UPDATE table_name SET jsonb_field[0] = '1';
</programlisting>

   如果为包含太少元素的数组指定了索引，将附加<literal>NULL</literal>元素，直到达到索引并且可以设置值。

<programlisting>
-- 其中jsonb_field为[]，现在是[null, null, 2];
-- 其中jsonb_field为[0]，现在是[0, null, 2]
UPDATE table_name SET jsonb_field[2] = '2';
</programlisting>

   只要要遍历的最后一个现有元素是对象或数组（由相应的下标隐含），<type>jsonb</type>值将接受对不存在的下标路径的赋值，直到可以放置分配的值为止，将创建嵌套的数组和对象结构，在前一种情况下，根据下标路径填充<literal>null</literal>。

<programlisting>
-- 其中jsonb_field为{}，现在是{"a": [{"b": 1}]}
UPDATE table_name SET jsonb_field['a'][0]['b'] = '1';

-- 其中jsonb_field为[]，现在是[null, {"a": 1}]
UPDATE table_name SET jsonb_field[1]['a'] = '1';
</programlisting>

  </para>
<!-- pgdoc-cn_end sig_en=c7833954a37e4b9bd5f6c3327ed63526 -->
 </sect2>

 <sect2>
<!-- pgdoc-cn_start sig_en=86ddd9561f97c5e93df34c49b9e90ef8 sig_cn_org=None source=14.1 
  <title>Transforms</title>
________________________________________________________-->
  <title>转换</title>
<!-- pgdoc-cn_end sig_en=86ddd9561f97c5e93df34c49b9e90ef8 -->

<!-- pgdoc-cn_start sig_en=fc305f2b574aa9ab910ed939c74655b1 sig_cn_org=None source=14.1 
  <para>
   Additional extensions are available that implement transforms for the
   <type>jsonb</type> type for different procedural languages.
  </para>
________________________________________________________-->
  <para>
   有一些附加的扩展可以为不同的过程语言实现<type>jsonb</type>类型的转换。
  </para>
<!-- pgdoc-cn_end sig_en=fc305f2b574aa9ab910ed939c74655b1 -->

<!-- pgdoc-cn_start sig_en=b598c051f45c041d0d7437b58ff8c4ed sig_cn_org=None source=14.1 
  <para>
   The extensions for PL/Perl are called <literal>jsonb_plperl</literal> and
   <literal>jsonb_plperlu</literal>.  If you use them, <type>jsonb</type>
   values are mapped to Perl arrays, hashes, and scalars, as appropriate.
  </para>
________________________________________________________-->
  <para>
   PL/Perl的扩展被称作<literal>jsonb_plperl</literal>和<literal>jsonb_plperlu</literal>。如果使用它们，<type>jsonb</type>值会视情况被映射为Perl的数组、哈希和标量。
  </para>
<!-- pgdoc-cn_end sig_en=b598c051f45c041d0d7437b58ff8c4ed -->

<!-- pgdoc-cn_start sig_en=39bf28d4951aa67b76ce68c8ad8c25ef sig_cn_org=0d41edabcc489a3890106a883b8e8760 source=15.7 
  <para>
   The extension for PL/Python is called <literal>jsonb_plpython3u</literal>.
   If you use it, <type>jsonb</type> values are mapped to Python
   dictionaries, lists, and scalars, as appropriate.
  </para>
________________________________________________________-->
  <para>
   PL/Python的扩展名为<literal>jsonb_plpython3u</literal>。
   如果您使用它，<type>jsonb</type>值将被映射到Python字典、列表和标量，适当地。
</para>
<!-- pgdoc-cn_end sig_en=39bf28d4951aa67b76ce68c8ad8c25ef -->

<!-- pgdoc-cn_start sig_en=5ec8cccb93098319e24469cf9d3f2eb4 sig_cn_org=None source=14.1 
  <para>
   Of these extensions, <literal>jsonb_plperl</literal> is
   considered <quote>trusted</quote>, that is, it can be installed by
   non-superusers who have <literal>CREATE</literal> privilege on the
   current database.  The rest require superuser privilege to install.
  </para>
________________________________________________________-->
  <para>
   在这些扩展中，<literal>jsonb_plperl</literal>被认为是<quote>trusted</quote>，
   也就是说，它可以由对当前数据库具有<literal>CREATE</literal>权限的非超级用户安装。
   其余的需要超级用户权限才能安装。
  </para>
<!-- pgdoc-cn_end sig_en=5ec8cccb93098319e24469cf9d3f2eb4 -->
 </sect2>

 <sect2 id="datatype-jsonpath">
<!-- pgdoc-cn_start sig_en=aeb19fa27706e4eb2089214228166891 sig_cn_org=None source=14.1 
  <title>jsonpath Type</title>
________________________________________________________-->
  <title>jsonpath Type</title>
<!-- pgdoc-cn_end sig_en=aeb19fa27706e4eb2089214228166891 -->

<!-- pgdoc-cn_start sig_en=f5209bf2b2b8d7274fdcb98bd3da7679 sig_cn_org=None source=14.1 
  <indexterm zone="datatype-jsonpath">
   <primary>jsonpath</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="datatype-jsonpath">
   <primary>jsonpath</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=f5209bf2b2b8d7274fdcb98bd3da7679 -->

<!-- pgdoc-cn_start sig_en=d496b2990431710f14fa88db5dbf2611 sig_cn_org=None source=14.1 
  <para>
   The <type>jsonpath</type> type implements support for the SQL/JSON path language
   in <productname>PostgreSQL</productname> to efficiently query JSON data.
   It provides a binary representation of the parsed SQL/JSON path
   expression that specifies the items to be retrieved by the path
   engine from the JSON data for further processing with the
   SQL/JSON query functions.
  </para>
________________________________________________________-->
  <para>
   在<productname>PostgreSQL</productname>中，<type>jsonpath</type>类型实现支持SQL/JSON 路径语言以有效地查询 JSON 数据。
   它提供了已解析的SQL/JSON路径表达式的二进制表示，该表达式指定路径引擎从JSON数据中检索的项，以便使用SQL/JSON查询函数进行进一步处理。
  </para>
<!-- pgdoc-cn_end sig_en=d496b2990431710f14fa88db5dbf2611 -->

<!-- pgdoc-cn_start sig_en=54131055dac91c8e8a9b9c24994aede8 sig_cn_org=None source=14.1 
  <para>
   The semantics of SQL/JSON path predicates and operators generally follow SQL.
   At the same time, to provide a natural way of working with JSON data,
   SQL/JSON path syntax uses some JavaScript conventions:
  </para>
________________________________________________________-->
  <para>
   SQL/JSON 路径谓词和运算符的语义通常遵循 SQL。同时，为了提供使用 JSON 数据的自然方法，SQL/JSON 路径语法使用一些 JavaScript 约定：
  </para>
<!-- pgdoc-cn_end sig_en=54131055dac91c8e8a9b9c24994aede8 -->

  <itemizedlist>
   <listitem>
<!-- pgdoc-cn_start sig_en=0ea2ff39564530b2ff7d77df725aee73 sig_cn_org=None source=14.1 
    <para>
     Dot (<literal>.</literal>) is used for member access.
    </para>
________________________________________________________-->
    <para>
     小数点 (<literal>.</literal>) 用于成员访问.
    </para>
<!-- pgdoc-cn_end sig_en=0ea2ff39564530b2ff7d77df725aee73 -->
   </listitem>
   <listitem>
<!-- pgdoc-cn_start sig_en=0ef321a472f40b440ab13c42c4e57486 sig_cn_org=None source=14.1 
    <para>
     Square brackets (<literal>[]</literal>) are used for array access.
    </para>
________________________________________________________-->
    <para>
     方括号 (<literal>[]</literal>) 用于数组访问.
    </para>
<!-- pgdoc-cn_end sig_en=0ef321a472f40b440ab13c42c4e57486 -->
   </listitem>
   <listitem>
<!-- pgdoc-cn_start sig_en=cc2ae27ea81c2a8a841f2358841d1052 sig_cn_org=None source=14.1 
    <para>
     SQL/JSON arrays are 0-relative, unlike regular SQL arrays that start from 1.
    </para>
________________________________________________________-->
    <para>
     与从 1 开始的常规 SQL 数组不同，SQL/JSON 数组是 0 相对的。
    </para>
<!-- pgdoc-cn_end sig_en=cc2ae27ea81c2a8a841f2358841d1052 -->
   </listitem>
  </itemizedlist>

<!-- pgdoc-cn_start sig_en=b67ca68eabca3c7af73098c903f74d01 sig_cn_org=37f06a3766b2ba2035d406b20a36c6c2 source=15.7 
  <para>
   An SQL/JSON path expression is typically written in an SQL query as an
   SQL character string literal, so it must be enclosed in single quotes,
   and any single quotes desired within the value must be doubled
   (see <xref linkend="sql-syntax-strings"/>).
   Some forms of path expressions require string literals within them.
   These embedded string literals follow JavaScript/ECMAScript conventions:
   they must be surrounded by double quotes, and backslash escapes may be
   used within them to represent otherwise-hard-to-type characters.
   In particular, the way to write a double quote within an embedded string
   literal is <literal>\"</literal>, and to write a backslash itself, you
   must write <literal>\\</literal>.  Other special backslash sequences
   include those recognized in JavaScript strings:
   <literal>\b</literal>,
   <literal>\f</literal>,
   <literal>\n</literal>,
   <literal>\r</literal>,
   <literal>\t</literal>,
   <literal>\v</literal>
   for various ASCII control characters,
   <literal>\x<replaceable>NN</replaceable></literal> for a character code
   written with only two hex digits,
   <literal>\u<replaceable>NNNN</replaceable></literal> for a Unicode
   character identified by its 4-hex-digit code point, and
   <literal>\u{<replaceable>N...</replaceable>}</literal> for a Unicode
   character code point written with 1 to 6 hex digits.
  </para>
________________________________________________________-->
  <para>
   SQL/JSON路径表达式通常在SQL查询中以SQL字符串文字的形式编写，因此必须用单引号括起，
   并且值中所需的任何单引号必须加倍（参见<xref linkend="sql-syntax-strings"/>）。
   某些形式的路径表达式需要其中的字符串文字。
   这些嵌入式字符串文字遵循JavaScript/ECMAScript约定：
   它们必须用双引号括起，并且可以在其中使用反斜杠转义来表示其他难以输入的字符。
   特别是，在嵌入式字符串文字中写入双引号的方法是<literal>\"</literal>，
   而要写入反斜杠本身，必须写为<literal>\\</literal>。其他特殊的反斜杠序列
   包括JavaScript字符串中识别的那些：
   <literal>\b</literal>、
   <literal>\f</literal>、
   <literal>\n</literal>、
   <literal>\r</literal>、
   <literal>\t</literal>、
   <literal>\v</literal>
   用于各种ASCII控制字符，
   <literal>\x<replaceable>NN</replaceable></literal>表示用仅两个十六进制数字编写的字符代码，
   <literal>\u<replaceable>NNNN</replaceable></literal>表示由其4个十六进制代码点标识的Unicode字符，
   以及<literal>\u{<replaceable>N...</replaceable>}</literal>表示用1至6个十六进制数字编写的Unicode字符代码点。
</para>
<!-- pgdoc-cn_end sig_en=b67ca68eabca3c7af73098c903f74d01 -->

<!-- pgdoc-cn_start sig_en=a344e1d8904ea8e96e9c792c51339dfe sig_cn_org=None source=14.1 
  <para>
   A path expression consists of a sequence of path elements,
   which can be any of the following:
   <itemizedlist>
    <listitem>
     <para>
      Path literals of JSON primitive types:
      Unicode text, numeric, true, false, or null.
     </para>
    </listitem>
    <listitem>
     <para>
      Path variables listed in <xref linkend="type-jsonpath-variables"/>.
     </para>
    </listitem>
    <listitem>
     <para>
      Accessor operators listed in <xref linkend="type-jsonpath-accessors"/>.
     </para>
    </listitem>
    <listitem>
     <para>
      <type>jsonpath</type> operators and methods listed
      in <xref linkend="functions-sqljson-path-operators"/>.
     </para>
    </listitem>
    <listitem>
     <para>
      Parentheses, which can be used to provide filter expressions
      or define the order of path evaluation.
     </para>
    </listitem>
   </itemizedlist>
  </para>
________________________________________________________-->
  <para>
   路径表达式由一系列路径元素组成，可以是以下任何一种：
   <itemizedlist>
    <listitem>
     <para>
      JSON基本类型的路径文字:Unicode文本、数字、真、假或空.
     </para>
    </listitem>
    <listitem>
     <para>
      Path variables listed in <xref linkend="type-jsonpath-variables"/>中列出的路径变量。
     </para>
    </listitem>
    <listitem>
     <para>
      <xref linkend="type-jsonpath-accessors"/>中列出的访问器运算符。
     </para>
    </listitem>
    <listitem>
     <para>
      <xref linkend="functions-sqljson-path-operators"/>中列出的<type>jsonpath</type> 运算符和方法。 
     </para>
    </listitem>
    <listitem>
     <para>
      括号，可用于提供筛选器表达式或定义路径计算的顺序。
     </para>
    </listitem>
   </itemizedlist>
  </para>
<!-- pgdoc-cn_end sig_en=a344e1d8904ea8e96e9c792c51339dfe -->

<!-- pgdoc-cn_start sig_en=602a1ebbaba85bb501a3bc5287044442 sig_cn_org=None source=14.1 
  <para>
   For details on using <type>jsonpath</type> expressions with SQL/JSON
   query functions, see <xref linkend="functions-sqljson-path"/>.
  </para>
________________________________________________________-->
  <para>
   有关使用<type>jsonpath</type>具有 SQL/JSON 查询函数的表达式的详细信息，参见<xref linkend="functions-sqljson-path"/>。
  </para>
<!-- pgdoc-cn_end sig_en=602a1ebbaba85bb501a3bc5287044442 -->

  <table id="type-jsonpath-variables">
<!-- pgdoc-cn_start sig_en=fff137c96fe6085bedf373f1472a78f1 sig_cn_org=None source=14.1 
   <title><type>jsonpath</type> Variables</title>
________________________________________________________-->
   <title><type>jsonpath</type> 变量</title>
<!-- pgdoc-cn_end sig_en=fff137c96fe6085bedf373f1472a78f1 -->
   <tgroup cols="2">
    <colspec colname="col1" colwidth="1*"/>
    <colspec colname="col2" colwidth="2*"/>
    <thead>
<!-- pgdoc-cn_start sig_en=f89a2aeb15163eb4b99b2d2c61fe222a sig_cn_org=None source=14.1 
     <row>
      <entry>Variable</entry>
      <entry>Description</entry>
     </row>
________________________________________________________-->
     <row>
      <entry>变量</entry>
      <entry>描述</entry>
     </row>
<!-- pgdoc-cn_end sig_en=f89a2aeb15163eb4b99b2d2c61fe222a -->
    </thead>
    <tbody>
<!-- pgdoc-cn_start sig_en=ff5b57aa8486c25e0ca4fdbecc42f73b sig_cn_org=None source=14.1 
     <row>
      <entry><literal>$</literal></entry>
      <entry>A variable representing the JSON value being queried
      (the <firstterm>context item</firstterm>).
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>$</literal></entry>
      <entry>表示被查询的 JSON 值的变量(<firstterm>context item</firstterm>).
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=ff5b57aa8486c25e0ca4fdbecc42f73b -->
<!-- pgdoc-cn_start sig_en=f5975a790c1b71ce7d64b45c304b87df sig_cn_org=None source=14.1 
     <row>
      <entry><literal>$varname</literal></entry>
      <entry>
        A named variable. Its value can be set by the parameter
        <parameter>vars</parameter> of several JSON processing functions;
        see <xref linkend="functions-json-processing-table"/> for details.
        <!-&minus; TODO: describe PASSING clause once implemented !-&minus;>
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>$varname</literal></entry>
      <entry>
        命名变量。其值可以由参数<parameter>vars</parameter>多个JSON处理函数设置。
        详细信息请参见 <xref linkend="functions-json-processing-table"/>。
        <!-- TODO: describe PASSING clause once implemented !-->
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=f5975a790c1b71ce7d64b45c304b87df -->
<!-- pgdoc-cn_start sig_en=af8fee2823abf263e496da3f9859e763 sig_cn_org=None source=14.1 
     <row>
      <entry><literal>@</literal></entry>
      <entry>A variable representing the result of path evaluation
      in filter expressions.
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry><literal>@</literal></entry>
      <entry>表示筛选器表达式中路径计算结果的变量。
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=af8fee2823abf263e496da3f9859e763 -->
    </tbody>
   </tgroup>
  </table>

  <table id="type-jsonpath-accessors">
<!-- pgdoc-cn_start sig_en=b529136bcee8108e665ef323c8e75822 sig_cn_org=None source=14.1 
   <title><type>jsonpath</type> Accessors</title>
________________________________________________________-->
   <title><type>jsonpath</type> Accessors</title>
<!-- pgdoc-cn_end sig_en=b529136bcee8108e665ef323c8e75822 -->
   <tgroup cols="2">
    <colspec colname="col1" colwidth="1*"/>
    <colspec colname="col2" colwidth="2*"/>
    <thead>
<!-- pgdoc-cn_start sig_en=650386b0b8846e82604a752632ed7cfe sig_cn_org=None source=14.1 
     <row>
      <entry>Accessor Operator</entry>
      <entry>Description</entry>
     </row>
________________________________________________________-->
     <row>
      <entry>访问器运算符</entry>
      <entry>描述</entry>
     </row>
<!-- pgdoc-cn_end sig_en=650386b0b8846e82604a752632ed7cfe -->
    </thead>
    <tbody>
<!-- pgdoc-cn_start sig_en=ffa5ab1170c0448687a0958217212eb2 sig_cn_org=None source=14.1 
     <row>
      <entry>
       <para>
        <literal>.<replaceable>key</replaceable></literal>
       </para>
       <para>
        <literal>."$<replaceable>varname</replaceable>"</literal>
       </para>
      </entry>
      <entry>
       <para>
        Member accessor that returns an object member with
        the specified key. If the key name matches some named variable
        starting with <literal>$</literal> or does not meet the
        JavaScript rules for an identifier, it must be enclosed in
        double quotes to make it a string literal.
       </para>
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry>
       <para>
        <literal>.<replaceable>key</replaceable></literal>
       </para>
       <para>
        <literal>."$<replaceable>varname</replaceable>"</literal>
       </para>
      </entry>
      <entry>
       <para>
        返回具有指定密钥的对象成员的成员访问器。
        如果键名称是以 <literal>$</literal> 开头的命名变量，或者不符合标识符的 JavaScript 规则，则必须将其括在双引号中以使其成为字符串文字。
       </para>
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=ffa5ab1170c0448687a0958217212eb2 -->
<!-- pgdoc-cn_start sig_en=a9f669cbf3cec0f0c7f36c614a4e0e99 sig_cn_org=None source=14.1 
     <row>
      <entry>
       <para>
        <literal>.*</literal>
       </para>
      </entry>
      <entry>
       <para>
        Wildcard member accessor that returns the values of all
        members located at the top level of the current object.
       </para>
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry>
       <para>
        <literal>.*</literal>
       </para>
      </entry>
      <entry>
       <para>
        通配符成员访问器，该访问器返回位于当前对象顶层的所有成员的值。
       </para>
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=a9f669cbf3cec0f0c7f36c614a4e0e99 -->
<!-- pgdoc-cn_start sig_en=24f84e12e46d0db5f4f0a29d1e9affc0 sig_cn_org=None source=14.1 
     <row>
      <entry>
       <para>
        <literal>.**</literal>
       </para>
      </entry>
      <entry>
       <para>
        Recursive wildcard member accessor that processes all levels
        of the JSON hierarchy of the current object and returns all
        the member values, regardless of their nesting level. This
        is a <productname>PostgreSQL</productname> extension of
        the SQL/JSON standard.
       </para>
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry>
       <para>
        <literal>.**</literal>
       </para>
      </entry>
      <entry>
       <para>
        递归通配符成员访问器，它处理当前对象JSON层次结构的所有级别，并返回所有成员值，而不管它们的嵌套级别如何。
        这是 <productname>PostgreSQL</productname> SQL/JSON 标准的扩展。
       </para>
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=24f84e12e46d0db5f4f0a29d1e9affc0 -->
<!-- pgdoc-cn_start sig_en=161d3db4b3b6889a3080dd79ae829d55 sig_cn_org=None source=14.1 
     <row>
      <entry>
       <para>
        <literal>.**{<replaceable>level</replaceable>}</literal>
       </para>
       <para>
        <literal>.**{<replaceable>start_level</replaceable> to
        <replaceable>end_level</replaceable>}</literal>
       </para>
      </entry>
      <entry>
       <para>
        Like <literal>.**</literal>, but selects only the specified
        levels of the JSON hierarchy. Nesting levels are specified as integers.
        Level zero corresponds to the current object. To access the lowest
        nesting level, you can use the <literal>last</literal> keyword.
        This is a <productname>PostgreSQL</productname> extension of
        the SQL/JSON standard.
       </para>
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry>
       <para>
        <literal>.**{<replaceable>level</replaceable>}</literal>
       </para>
       <para>
        <literal>.**{<replaceable>start_level</replaceable> to
        <replaceable>end_level</replaceable>}</literal>
       </para>
      </entry>
      <entry>
       <para>
        与 <literal>.**</literal> 类似，但仅选择 JSON 层次结构的指定级别。嵌套级别指定为整数。
        零级别对应于当前对象。要访问最低嵌套级别，可以使用<literal>last</literal>关键字。
        这是 <productname>PostgreSQL</productname> SQL/JSON 标准的扩展。
       </para>
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=161d3db4b3b6889a3080dd79ae829d55 -->
<!-- pgdoc-cn_start sig_en=be6a120bcb812949f76995ff018cd791 sig_cn_org=None source=14.1 
     <row>
      <entry>
       <para>
        <literal>[<replaceable>subscript</replaceable>, ...]</literal>
       </para>
      </entry>
      <entry>
       <para>
        Array element accessor.
        <literal><replaceable>subscript</replaceable></literal> can be
        given in two forms: <literal><replaceable>index</replaceable></literal>
        or <literal><replaceable>start_index</replaceable> to <replaceable>end_index</replaceable></literal>.
        The first form returns a single array element by its index. The second
        form returns an array slice by the range of indexes, including the
        elements that correspond to the provided
        <replaceable>start_index</replaceable> and <replaceable>end_index</replaceable>.
       </para>
       <para>
        The specified <replaceable>index</replaceable> can be an integer, as
        well as an expression returning a single numeric value, which is
        automatically cast to integer. Index zero corresponds to the first
        array element. You can also use the <literal>last</literal> keyword
        to denote the last array element, which is useful for handling arrays
        of unknown length.
       </para>
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry>
       <para>
        <literal>[<replaceable>subscript</replaceable>, ...]</literal>
       </para>
      </entry>
      <entry>
       <para>
        数组元素访问器.
        <literal><replaceable>subscript</replaceable></literal> 能够以两种形式给出: <literal><replaceable>index</replaceable></literal> 或 <literal><replaceable>start_index</replaceable> 到 <replaceable>end_index</replaceable></literal>。
        第一个窗体按其索引返回单个数组元素。第二个窗体按索引范围返回数组切片，包括对应于提供的元素<replaceable>start_index</replaceable><replaceable>end_index</replaceable>。
       </para>
       <para>
        指定的<replaceable>index</replaceable>可以是整数，也可以是返回单个数值的表达式，该数值将自动转换为整数。
        零索引对应于第一个数组元素。你还可以使用<literal>last</literal> 关键字来表示最后一个数组元素，这对于处理未知长度的数组很有用。
       </para>
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=be6a120bcb812949f76995ff018cd791 -->
<!-- pgdoc-cn_start sig_en=79d87315417268a1707aed2df5676299 sig_cn_org=None source=14.1 
     <row>
      <entry>
       <para>
        <literal>[*]</literal>
       </para>
      </entry>
      <entry>
       <para>
        Wildcard array element accessor that returns all array elements.
       </para>
      </entry>
     </row>
________________________________________________________-->
     <row>
      <entry>
       <para>
        <literal>[*]</literal>
       </para>
      </entry>
      <entry>
       <para>
        返回所有数组元素的通配符数组元素访问器。
       </para>
      </entry>
     </row>
<!-- pgdoc-cn_end sig_en=79d87315417268a1707aed2df5676299 -->
    </tbody>
   </tgroup>
  </table>

 </sect2>
</sect1>
