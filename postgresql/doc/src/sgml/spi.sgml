<!-- doc/src/sgml/spi.sgml -->

<chapter id="spi">
<!-- pgdoc-cn_start sig_en=3d7532d54a5323835f57d6c9aee9c662 sig_cn_org=None source=14.1 
 <title>Server Programming Interface</title>
________________________________________________________-->
 <title>服务器编程接口</title>
<!-- pgdoc-cn_end sig_en=3d7532d54a5323835f57d6c9aee9c662 -->

<!-- pgdoc-cn_start sig_en=014d8f52f8fda1ecef19e3d15b302aea sig_cn_org=None source=14.1 
 <indexterm zone="spi">
  <primary>SPI</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="spi">
  <primary>SPI</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=014d8f52f8fda1ecef19e3d15b302aea -->

<!-- pgdoc-cn_start sig_en=d7d40b4f16ca12525a90c728eefc10a1 sig_cn_org=None source=14.1 
 <para>
  The <firstterm>Server Programming Interface</firstterm>
  (<acronym>SPI</acronym>) gives writers of user-defined
  <acronym>C</acronym> functions the ability to run
  <acronym>SQL</acronym> commands inside their functions or procedures.
  <acronym>SPI</acronym> is a set of
  interface functions to simplify access to the parser, planner,
  and executor. <acronym>SPI</acronym> also does some
  memory management.
 </para>
________________________________________________________-->
 <para>
  <firstterm>服务器编程接口</firstterm>（<acronym>SPI</acronym>）给予用户定义<acronym>C</acronym>函数编写者在其函数或程序内运行<acronym>SQL</acronym>命令的能力。
  <acronym>SPI</acronym>是一组接口函数，它们可以简化对解析器、规划器和执行器的访问。
  <acronym>SPI</acronym>也做一些内存管理。
 </para>
<!-- pgdoc-cn_end sig_en=d7d40b4f16ca12525a90c728eefc10a1 -->

 <note>
<!-- pgdoc-cn_start sig_en=f03c11a785a87cbb5adffe6e56663baf sig_cn_org=None source=14.1 
  <para>
   The available procedural languages provide various means to
   execute SQL commands from functions.  Most of these facilities are
   based on SPI, so this documentation might be of use for users
   of those languages as well.
  </para>
________________________________________________________-->
  <para>
   可用的过程语言提供了多种方法从函数中执行 SQL 命令。大部分这些设施都是基于 SPI 的，因此这个文档也对那些语言的用户有用。
  </para>
<!-- pgdoc-cn_end sig_en=f03c11a785a87cbb5adffe6e56663baf -->
 </note>

<!-- pgdoc-cn_start sig_en=12432d80e8b6e4dbbc1e4938870d9818 sig_cn_org=None source=14.1 
 <para>
  Note that if a command invoked via SPI fails, then control will not be
  returned to your C function.  Rather, the
  transaction or subtransaction in which your C function executes will be
  rolled back.  (This might seem surprising given that the SPI functions mostly
  have documented error-return conventions.  Those conventions only apply
  for errors detected within the SPI functions themselves, however.)
  It is possible to recover control after an error by establishing your own
  subtransaction surrounding SPI calls that might fail.
 </para>
________________________________________________________-->
 <para>
  注意如果一个通过 SPI 调用的命令失败，那么控制将会返回到你的C函数中。当然啦，你的C函数所在的事务或者子事务将被回滚（这可能看起来令人惊讶，因为据文档所说 SPI 函数大多数都有错误返回约定。但是那些约定只适用于在 SPI 函数本身内部检测到的错误）。通过在可能失败的 SPI 调用周围建立自己的子事务可以在错误之后恢复控制。
 </para>
<!-- pgdoc-cn_end sig_en=12432d80e8b6e4dbbc1e4938870d9818 -->

<!-- pgdoc-cn_start sig_en=b73df53ef11ec4c8633c9f347b5c91cb sig_cn_org=None source=14.1 
 <para>
  <acronym>SPI</acronym> functions return a nonnegative result on
  success (either via a returned integer value or in the global
  variable <varname>SPI_result</varname>, as described below).  On
  error, a negative result or <symbol>NULL</symbol> will be returned.
 </para>
________________________________________________________-->
 <para>
  <acronym>SPI</acronym>成功时返回一个非负结果（要么通过一个返回的整数值，要么如下所述放在全局变量<varname>SPI_result</varname>中）。错误时，将会返回一个负结果或者<symbol>NULL</symbol>。
 </para>
<!-- pgdoc-cn_end sig_en=b73df53ef11ec4c8633c9f347b5c91cb -->

<!-- pgdoc-cn_start sig_en=955e6c735478df6e35d2a5bfe82b49ab sig_cn_org=None source=14.1 
 <para>
  Source code files that use SPI must include the header file
  <filename>executor/spi.h</filename>.
 </para>
________________________________________________________-->
 <para>
  使用 SPI 的源代码文件必须包括头文件<filename>executor/spi.h</filename>。
 </para>
<!-- pgdoc-cn_end sig_en=955e6c735478df6e35d2a5bfe82b49ab -->


<sect1 id="spi-interface">
<!-- pgdoc-cn_start sig_en=8ee608f7717687cc6a5926f715abae65 sig_cn_org=None source=14.1 
 <title>Interface Functions</title>
________________________________________________________-->
 <title>接口函数</title>
<!-- pgdoc-cn_end sig_en=8ee608f7717687cc6a5926f715abae65 -->

 <refentry id="spi-spi-connect">
<!-- pgdoc-cn_start sig_en=4a0936ee69c23bd2d2d1c124fa1e0c44 sig_cn_org=None source=14.1 
  <indexterm><primary>SPI_connect</primary></indexterm>
________________________________________________________-->
  <indexterm><primary>SPI_connect</primary></indexterm>
<!-- pgdoc-cn_end sig_en=4a0936ee69c23bd2d2d1c124fa1e0c44 -->
<!-- pgdoc-cn_start sig_en=49a791a8b6c3f0b57a41c97609043ed1 sig_cn_org=None source=14.1 
  <indexterm><primary>SPI_connect_ext</primary></indexterm>
________________________________________________________-->
  <indexterm><primary>SPI_connect_ext</primary></indexterm>
<!-- pgdoc-cn_end sig_en=49a791a8b6c3f0b57a41c97609043ed1 -->

  <refmeta>
   <refentrytitle>SPI_connect</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

<!-- pgdoc-cn_start sig_en=0afdd601f93b9a5920f8242393f9c664 sig_cn_org=None source=14.1 
  <refnamediv>
   <refname>SPI_connect</refname>
   <refname>SPI_connect_ext</refname>
   <refpurpose>connect a C function to the SPI manager</refpurpose>
 </refnamediv>
________________________________________________________-->
  <refnamediv>
   <refname>SPI_connect</refname>
   <refname>SPI_connect_ext</refname>
   <refpurpose>连接一个C函数到 SPI 管理器</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=0afdd601f93b9a5920f8242393f9c664 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=067f70a1a23328321aa8ae88c8eea227 sig_cn_org=None source=14.1 
<synopsis>
int SPI_connect(void)
</synopsis>
________________________________________________________-->
<synopsis>
int SPI_connect(void)
</synopsis>
<!-- pgdoc-cn_end sig_en=067f70a1a23328321aa8ae88c8eea227 -->

<!-- pgdoc-cn_start sig_en=2159e9c4475ab7b0cfcb0cad753ec37a sig_cn_org=None source=14.1 
 <synopsis>
int SPI_connect_ext(int <parameter>options</parameter>)
</synopsis>
________________________________________________________-->
 <synopsis>
int SPI_connect_ext(int <parameter>options</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=2159e9c4475ab7b0cfcb0cad753ec37a -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=2e6e763b94008513d7717b9b9a0c5b84 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_connect</function> opens a connection from a
   C function invocation to the SPI manager.  You must call this
   function if you want to execute commands through SPI.  Some utility
   SPI functions can be called from unconnected C functions.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_connect</function>从一个C函数调用中打开一个到 SPI 管理器的连接。如果你想要通过 SPI 执行命令，你必须调用这个函数。有一些功能性 SPI 函数可以从未连接的C函数中调用。
  </para>
<!-- pgdoc-cn_end sig_en=2e6e763b94008513d7717b9b9a0c5b84 -->

<!-- pgdoc-cn_start sig_en=01a8ae408cdd3cb7ab5c017470363a67 sig_cn_org=09a431a1972f27ae3b88eacbb4a8b02a source=15.7 
  <para>
   <function>SPI_connect_ext</function> does the same but has an argument that
   allows passing option flags.  Currently, the following option values are
   available:
   <variablelist>
    <varlistentry>
     <term><symbol>SPI_OPT_NONATOMIC</symbol></term>
     <listitem>
      <para>
       Sets the SPI connection to be <firstterm>nonatomic</firstterm>, which
       means that transaction control calls (<function>SPI_commit</function>,
       <function>SPI_rollback</function>) are allowed.  Otherwise,
       calling those functions will result in an immediate error.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   <function>SPI_connect_ext</function>执行相同的操作，但有一个参数允许传递选项标志。目前，以下选项值可用：
   <variablelist>
    <varlistentry>
     <term><symbol>SPI_OPT_NONATOMIC</symbol></term>
     <listitem>
      <para>
       将SPI连接设置为<firstterm>nonatomic</firstterm>，这意味着事务控制调用（<function>SPI_commit</function>、
       <function>SPI_rollback</function>）是允许的。否则，调用这些函数将立即导致错误。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=01a8ae408cdd3cb7ab5c017470363a67 -->

<!-- pgdoc-cn_start sig_en=0fe5e4b07ce1313eb16a8529e4440f02 sig_cn_org=None source=14.1 
  <para>
   <literal>SPI_connect()</literal> is equivalent to
   <literal>SPI_connect_ext(0)</literal>.
  </para>
________________________________________________________-->
  <para>
   <literal>SPI_connect()</literal>等效于<literal>SPI_connect_ext(0)</literal>。
  </para>
<!-- pgdoc-cn_end sig_en=0fe5e4b07ce1313eb16a8529e4440f02 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

  <variablelist>
   <varlistentry>
    <term><symbol>SPI_OK_CONNECT</symbol></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=774346bfe7a35e06269990c0b91e180a sig_cn_org=None source=14.1 
     <para>
      on success
     </para>
________________________________________________________-->
     <para>
      成功时
     </para>
<!-- pgdoc-cn_end sig_en=774346bfe7a35e06269990c0b91e180a -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><symbol>SPI_ERROR_CONNECT</symbol></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=5ed1a7cc2edb4af84f47933d56acb124 sig_cn_org=None source=14.1 
     <para>
      on error
     </para>
________________________________________________________-->
     <para>
      错误时
     </para>
<!-- pgdoc-cn_end sig_en=5ed1a7cc2edb4af84f47933d56acb124 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-finish">
<!-- pgdoc-cn_start sig_en=e810aaa269211adb4902faed4245aad0 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_finish</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_finish</primary></indexterm>
<!-- pgdoc-cn_end sig_en=e810aaa269211adb4902faed4245aad0 -->

 <refmeta>
  <refentrytitle>SPI_finish</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=c467463d9085f334f1a6a122b0e14357 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_finish</refname>
  <refpurpose>disconnect a C function from the SPI manager</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_finish</refname>
  <refpurpose>将一个C函数从 SPI 管理器断开</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=c467463d9085f334f1a6a122b0e14357 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=43ce1b093af94d9ac0c292c63349f848 sig_cn_org=None source=14.1 
<synopsis>
int SPI_finish(void)
</synopsis>
________________________________________________________-->
<synopsis>
int SPI_finish(void)
</synopsis>
<!-- pgdoc-cn_end sig_en=43ce1b093af94d9ac0c292c63349f848 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=e4cfd2640c18eae291bb4133d36aa9a9 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_finish</function> closes an existing connection to
   the SPI manager.  You must call this function after completing the
   SPI operations needed during your C function's current invocation.
   You do not need to worry about making this happen, however, if you
   abort the transaction via <literal>elog(ERROR)</literal>.  In that
   case SPI will clean itself up automatically.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_finish</function>关闭一个到 SPI 管理器的现有连接。你必须在完成你的C函数的当前调用中所需的 SPI 操作之后必须调用这个函数。不过，如果你通过<literal>elog(ERROR)</literal>中断了事务，你无须担心这个函数的调用。在那种情况下，SPI 将自己自动进行清理。
  </para>
<!-- pgdoc-cn_end sig_en=e4cfd2640c18eae291bb4133d36aa9a9 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

  <variablelist>
   <varlistentry>
    <term><symbol>SPI_OK_FINISH</symbol></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=b83386834e71c5c439f56d5451c61546 sig_cn_org=None source=14.1 
     <para>
      if properly disconnected
     </para>
________________________________________________________-->
     <para>
      如果正确地断开连接
     </para>
<!-- pgdoc-cn_end sig_en=b83386834e71c5c439f56d5451c61546 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=24da743e7a32540ad877c3b4dac97fe7 sig_cn_org=None source=14.1 
     <para>
      if called from an unconnected C function
     </para>
________________________________________________________-->
     <para>
      如果从一个未连接的C函数中调用
     </para>
<!-- pgdoc-cn_end sig_en=24da743e7a32540ad877c3b4dac97fe7 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute">
<!-- pgdoc-cn_start sig_en=bf9da02156b5bcf8126f66114a2dc9e4 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_execute</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_execute</primary></indexterm>
<!-- pgdoc-cn_end sig_en=bf9da02156b5bcf8126f66114a2dc9e4 -->

 <refmeta>
  <refentrytitle>SPI_execute</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=d1f9ef7b286c1b8c844a5ca26ae3033f sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_execute</refname>
  <refpurpose>execute a command</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_execute</refname>
  <refpurpose>执行一个命令</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=d1f9ef7b286c1b8c844a5ca26ae3033f -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=81bdc65f4a1d6ea42001dfa600abc088 sig_cn_org=None source=14.1 
<synopsis>
int SPI_execute(const char * <parameter>command</parameter>, bool <parameter>read_only</parameter>, long <parameter>count</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
int SPI_execute(const char * <parameter>command</parameter>, bool <parameter>read_only</parameter>, long <parameter>count</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=81bdc65f4a1d6ea42001dfa600abc088 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=bf5de642850b5ab0034ad970288d6b86 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_execute</function> executes the specified SQL command
   for <parameter>count</parameter> rows.  If <parameter>read_only</parameter>
   is <literal>true</literal>, the command must be read-only, and execution overhead
   is somewhat reduced.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_execute</function>执行指定的 SQL 命令以获得<parameter>count</parameter>行。如果<parameter>read_only</parameter>为<literal>true</literal>，该命令必须是只读的，并且执行开销也会有所降低。
  </para>
<!-- pgdoc-cn_end sig_en=bf5de642850b5ab0034ad970288d6b86 -->

<!-- pgdoc-cn_start sig_en=261124318a6f877d18f44282af231079 sig_cn_org=None source=14.1 
  <para>
   This function can only be called from a connected C function.
  </para>
________________________________________________________-->
  <para>
   只能从一个已连接的C函数中调用这个函数。
  </para>
<!-- pgdoc-cn_end sig_en=261124318a6f877d18f44282af231079 -->

<!-- pgdoc-cn_start sig_en=368975e753404ffebd9d0463c65aa3ab sig_cn_org=None source=14.1 
  <para>
   If <parameter>count</parameter> is zero then the command is executed
   for all rows that it applies to.  If <parameter>count</parameter>
   is greater than zero, then no more than <parameter>count</parameter> rows
   will be retrieved; execution stops when the count is reached, much like
   adding a <literal>LIMIT</literal> clause to the query. For example,
<programlisting>
SPI_execute("SELECT * FROM foo", true, 5);
</programlisting>
   will retrieve at most 5 rows from the table.  Note that such a limit
   is only effective when the command actually returns rows.  For example,
<programlisting>
SPI_execute("INSERT INTO foo SELECT * FROM bar", false, 5);
</programlisting>
   inserts all rows from <structname>bar</structname>, ignoring the
   <parameter>count</parameter> parameter.  However, with
<programlisting>
SPI_execute("INSERT INTO foo SELECT * FROM bar RETURNING *", false, 5);
</programlisting>
   at most 5 rows would be inserted, since execution would stop after the
   fifth <literal>RETURNING</literal> result row is retrieved.
  </para>
________________________________________________________-->
  <para>
   如果<parameter>count</parameter>为零，那么该命令会为其所适用的所有行执行。如果<parameter>count</parameter>大于零，那么会检索不超过<parameter>count</parameter>行，当到达该计数时执行会停止，这很像为查询增加一个<literal>LIMIT</literal>子句。例如：
<programlisting>
SPI_execute("SELECT * FROM foo", true, 5);
</programlisting>
   会从表中检索至多 5 行。注意这样一个限制只有当命令真正返回行时才有效。例如：
<programlisting>
SPI_execute("INSERT INTO foo SELECT * FROM bar", false, 5);
</programlisting>
   插入所有来自于<structname>bar</structname>的行，而忽略<parameter>count</parameter>参数。不过，通过
<programlisting>
SPI_execute("INSERT INTO foo SELECT * FROM bar RETURNING *", false, 5);
</programlisting>
   将插入至多 5 行，因为在第五个<literal>RETURNING</literal>结果行被检索到后执行就会停止。
  </para>
<!-- pgdoc-cn_end sig_en=368975e753404ffebd9d0463c65aa3ab -->

<!-- pgdoc-cn_start sig_en=7a9a7912ca4841bf492dece0c74439f1 sig_cn_org=None source=14.1 
  <para>
   You can pass multiple commands in one string;
   <function>SPI_execute</function> returns the
   result for the command executed last.  The <parameter>count</parameter>
   limit applies to each command separately (even though only the last
   result will actually be returned).  The limit is not applied to any
   hidden commands generated by rules.
  </para>
________________________________________________________-->
  <para>
   你可以在一个字符串中传递多个命令，<function>SPI_execute</function>会返回最后一个被执行的命令的结果。
   <parameter>count</parameter>限制单独适用于每一个命令（即便只有最后一个结果会被实际返回）。该限制
   不适用于由规则产生的任何隐藏命令。
  </para>
<!-- pgdoc-cn_end sig_en=7a9a7912ca4841bf492dece0c74439f1 -->

<!-- pgdoc-cn_start sig_en=b676463fd81f3bbae958f836eb72d906 sig_cn_org=None source=14.1 
  <para>
   When <parameter>read_only</parameter> is <literal>false</literal>,
   <function>SPI_execute</function> increments the command
   counter and computes a new <firstterm>snapshot</firstterm> before executing each
   command in the string.  The snapshot does not actually change if the
   current transaction isolation level is <literal>SERIALIZABLE</literal> or <literal>REPEATABLE READ</literal>, but in
   <literal>READ COMMITTED</literal> mode the snapshot update allows each command to
   see the results of newly committed transactions from other sessions.
   This is essential for consistent behavior when the commands are modifying
   the database.
  </para>
________________________________________________________-->
  <para>
   当<parameter>read_only</parameter>是<literal>false</literal>时，
   <function>SPI_execute</function>增加命令计数器并且在执行字符串中每一个命令之前
   计算一个新的<firstterm>snapshot</firstterm>。如果当前事务隔离级别是<literal>SERIALIZABLE</literal>或<literal>REPEATABLE READ</literal>，
   该快照并不会实际改变。但是在<literal>READ COMMITTED</literal>模式中，快照更新允许每个命令看到来自其他会话中新近已提交事务
   的结果。当命令正在修改数据库时，这对一致性行为非常重要。
  </para>
<!-- pgdoc-cn_end sig_en=b676463fd81f3bbae958f836eb72d906 -->

<!-- pgdoc-cn_start sig_en=1832165c3f8cd03bf2b4a0450695ca83 sig_cn_org=None source=14.1 
  <para>
   When <parameter>read_only</parameter> is <literal>true</literal>,
   <function>SPI_execute</function> does not update either the snapshot
   or the command counter, and it allows only plain <command>SELECT</command>
   commands to appear in the command string.  The commands are executed
   using the snapshot previously established for the surrounding query.
   This execution mode is somewhat faster than the read/write mode due
   to eliminating per-command overhead.  It also allows genuinely
   <firstterm>stable</firstterm> functions to be built: since successive executions
   will all use the same snapshot, there will be no change in the results.
  </para>
________________________________________________________-->
  <para>
   当<parameter>read_only</parameter>是<literal>true</literal>时，
   <function>SPI_execute</function>不更新快照或者命令计数器，并且它只允许纯
   <command>SELECT</command>命令出现在命令字符串中。这些命令被使用之前为周围查询
   建立的快照来执行。这种执行模式要比读/写模式更快，因为消除了每个命令跟新快照的开销。
   它也允许建立真正<firstterm>stable</firstterm>的函数：因为连续执行将会使用同一个快照，因此结果不会有改变。
  </para>
<!-- pgdoc-cn_end sig_en=1832165c3f8cd03bf2b4a0450695ca83 -->

<!-- pgdoc-cn_start sig_en=c7e72d6c058d54c38599f6d4b3ea8cab sig_cn_org=None source=14.1 
  <para>
   It is generally unwise to mix read-only and read-write commands within
   a single function using SPI; that could result in very confusing behavior,
   since the read-only queries would not see the results of any database
   updates done by the read-write queries.
  </para>
________________________________________________________-->
  <para>
   在一个使用 SPI 的单一函数中混合只读和读写命令通常是不明智的，
   这样可能会导致非常令人困惑的行为，因为只读查询将看不到任何
   由读写查询完成的数据库更新结果。
  </para>
<!-- pgdoc-cn_end sig_en=c7e72d6c058d54c38599f6d4b3ea8cab -->

<!-- pgdoc-cn_start sig_en=0fd9e319a7e6d947c68efa63509b442e sig_cn_org=None source=14.1 
  <para>
   The actual number of rows for which the (last) command was executed
   is returned in the global variable <varname>SPI_processed</varname>.
   If the return value of the function is <symbol>SPI_OK_SELECT</symbol>,
   <symbol>SPI_OK_INSERT_RETURNING</symbol>,
   <symbol>SPI_OK_DELETE_RETURNING</symbol>, or
   <symbol>SPI_OK_UPDATE_RETURNING</symbol>,
   then you can use the
   global pointer <literal>SPITupleTable *SPI_tuptable</literal> to
   access the result rows.  Some utility commands (such as
   <command>EXPLAIN</command>) also return row sets, and <literal>SPI_tuptable</literal>
   will contain the result in these cases too. Some utility commands
   (<command>COPY</command>, <command>CREATE TABLE AS</command>) don't return a row set, so
   <literal>SPI_tuptable</literal> is NULL, but they still return the number of
   rows processed in <varname>SPI_processed</varname>.
  </para>
________________________________________________________-->
  <para>
   被执行的（最后一个）命令的实际行数使用全局变量<varname>SPI_processed</varname>返回。
   如果该函数的返回值是<symbol>SPI_OK_SELECT</symbol>、
   <symbol>SPI_OK_INSERT_RETURNING</symbol>、
   <symbol>SPI_OK_DELETE_RETURNING</symbol>或者
   <symbol>SPI_OK_UPDATE_RETURNING</symbol>，
   那么你可以使用全局指针<literal>SPITupleTable *SPI_tuptable</literal>来访问结果行。
   某些工具命令（例如<command>EXPLAIN</command>）也返回行集合，并且在这些情况中<literal>SPI_tuptable</literal>
   也会包含该结果。某些工具命令（<command>COPY</command>、<command>CREATE TABLE AS</command>）不返回一个行集合，
   因此<literal>SPI_tuptable</literal>为 NULL，但是它们仍然会在<varname>SPI_processed</varname>中返回被处理的行数。
  </para>
<!-- pgdoc-cn_end sig_en=0fd9e319a7e6d947c68efa63509b442e -->

<!-- pgdoc-cn_start sig_en=abb480de066775ff40dcafc885c53004 sig_cn_org=None source=14.1 
  <para>
   The structure <structname>SPITupleTable</structname> is defined
   thus:
<programlisting>
typedef struct SPITupleTable
{
    /* Public members */
    TupleDesc   tupdesc;        /* tuple descriptor */
    HeapTuple  *vals;           /* array of tuples */
    uint64      numvals;        /* number of valid tuples */

    /* Private members, not intended for external callers */
    uint64      alloced;        /* allocated length of vals array */
    MemoryContext tuptabcxt;    /* memory context of result table */
    slist_node  next;           /* link for internal bookkeeping */
    SubTransactionId subid;     /* subxact in which tuptable was created */
} SPITupleTable;
</programlisting>
   The fields <structfield>tupdesc</structfield>,
   <structfield>vals</structfield>, and
   <structfield>numvals</structfield>
   can be used by SPI callers; the remaining fields are internal.
   <structfield>vals</structfield> is an array of pointers to rows.
   The number of rows is given by <structfield>numvals</structfield>
   (for somewhat historical reasons, this count is also returned
   in <varname>SPI_processed</varname>).
   <structfield>tupdesc</structfield> is a row descriptor which you can pass to
   SPI functions dealing with rows.
  </para>
________________________________________________________-->
  <para>
   结构<structname>SPITupleTable</structname>被定义为：
<programlisting>
typedef struct SPITupleTable
{
    /* Public members */
    TupleDesc   tupdesc;        /* tuple descriptor */
    HeapTuple  *vals;           /* array of tuples */
    uint64      numvals;        /* number of valid tuples */

    /* Private members, not intended for external callers */
    uint64      alloced;        /* allocated length of vals array */
    MemoryContext tuptabcxt;    /* memory context of result table */
    slist_node  next;           /* link for internal bookkeeping */
    SubTransactionId subid;     /* subxact in which tuptable was created */
} SPITupleTable;
</programlisting>
   SPI 调用者可以使用字段<structfield>tupdesc</structfield>、<structfield>vals</structfield>和<structfield>numvals</structfield>； 其余字段是内部的。 <structfield>vals</structfield> 是一个指向行的指针数组。 行数由 <structfield>numvals</structfield> 给出（由于某些历史原因，这个计数也在 <varname>SPI_processed</varname> 中返回）。 <structfield>tupdesc</structfield> 是一个行描述符，您可以将其传递给处理行的 SPI 函数。
  </para>
<!-- pgdoc-cn_end sig_en=abb480de066775ff40dcafc885c53004 -->

<!-- pgdoc-cn_start sig_en=7c2123a186f4e992eb19aa2bb59d8e78 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_finish</function> frees all
   <structname>SPITupleTable</structname>s allocated during the current
   C function.  You can free a particular result table earlier, if you
   are done with it, by calling <function>SPI_freetuptable</function>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_finish</function>释放在当前的C函数中已分配的所有<structname>SPITupleTable</structname>。
   如果你已经用完了一个结果表，你可以通过调用<function>SPI_freetuptable</function>提早释放它。
  </para>
<!-- pgdoc-cn_end sig_en=7c2123a186f4e992eb19aa2bb59d8e78 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=46320af8f64498547aefb470bbe1f695 sig_cn_org=None source=14.1 
     <para>
      string containing command to execute
     </para>
________________________________________________________-->
     <para>
      包含要执行命令的字符串
     </para>
<!-- pgdoc-cn_end sig_en=46320af8f64498547aefb470bbe1f695 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=b4631d77e109c42543b5ede7350ea3c6 sig_cn_org=None source=14.1 
     <para><literal>true</literal> for read-only execution</para>
________________________________________________________-->
     <para>对只读执行为<literal>true</literal></para>
<!-- pgdoc-cn_end sig_en=b4631d77e109c42543b5ede7350ea3c6 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=40ca4421fc90d088c0476e49929d6da0 sig_cn_org=None source=14.1 
     <para>
      maximum number of rows to return,
      or <literal>0</literal> for no limit
     </para>
________________________________________________________-->
     <para>
      要返回的最大行数，或者用<literal>0</literal>表示没有限制
     </para>
<!-- pgdoc-cn_end sig_en=40ca4421fc90d088c0476e49929d6da0 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=9277148afda015f0f380fcee1a4e2f85 sig_cn_org=a1d7b0ff75db0cbf1ecbcbe238f1113a source=15.7 
  <para>
   If the execution of the command was successful then one of the
   following (nonnegative) values will be returned:

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_OK_SELECT</symbol></term>
     <listitem>
      <para>
       if a <command>SELECT</command> (but not <command>SELECT
       INTO</command>) was executed
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_SELINTO</symbol></term>
     <listitem>
      <para>
       if a <command>SELECT INTO</command> was executed
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_INSERT</symbol></term>
     <listitem>
      <para>
       if an <command>INSERT</command> was executed
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_DELETE</symbol></term>
     <listitem>
      <para>
       if a <command>DELETE</command> was executed
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_UPDATE</symbol></term>
     <listitem>
      <para>
       if an <command>UPDATE</command> was executed
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_MERGE</symbol></term>
     <listitem>
      <para>
       if a <command>MERGE</command> was executed
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_INSERT_RETURNING</symbol></term>
     <listitem>
      <para>
       if an <command>INSERT RETURNING</command> was executed
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_DELETE_RETURNING</symbol></term>
     <listitem>
      <para>
       if a <command>DELETE RETURNING</command> was executed
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_UPDATE_RETURNING</symbol></term>
     <listitem>
      <para>
       if an <command>UPDATE RETURNING</command> was executed
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_UTILITY</symbol></term>
     <listitem>
      <para>
       if a utility command (e.g., <command>CREATE TABLE</command>)
       was executed
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_REWRITTEN</symbol></term>
     <listitem>
      <para>
       if the command was rewritten into another kind of command (e.g.,
       <command>UPDATE</command> became an <command>INSERT</command>) by a <link linkend="rules">rule</link>.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   如果命令执行成功，则将返回以下（非负）值：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_OK_SELECT</symbol></term>
     <listitem>
      <para>
       如果执行了<command>SELECT</command>（但不是<command>SELECT INTO</command>）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_SELINTO</symbol></term>
     <listitem>
      <para>
       如果执行了<command>SELECT INTO</command>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_INSERT</symbol></term>
     <listitem>
      <para>
       如果执行了<command>INSERT</command>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_DELETE</symbol></term>
     <listitem>
      <para>
       如果执行了<command>DELETE</command>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_UPDATE</symbol></term>
     <listitem>
      <para>
       如果执行了<command>UPDATE</command>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_MERGE</symbol></term>
     <listitem>
      <para>
       如果执行了<command>MERGE</command>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_INSERT_RETURNING</symbol></term>
     <listitem>
      <para>
       如果执行了<command>INSERT RETURNING</command>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_DELETE_RETURNING</symbol></term>
     <listitem>
      <para>
       如果执行了<command>DELETE RETURNING</command>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_UPDATE_RETURNING</symbol></term>
     <listitem>
      <para>
       如果执行了<command>UPDATE RETURNING</command>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_UTILITY</symbol></term>
     <listitem>
      <para>
       如果执行了实用命令（例如，<command>CREATE TABLE</command>）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_OK_REWRITTEN</symbol></term>
     <listitem>
      <para>
       如果命令被<link linkend="rules">rule</link>重写为另一种命令（例如，<command>UPDATE</command>变成了<command>INSERT</command>）
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=9277148afda015f0f380fcee1a4e2f85 -->

<!-- pgdoc-cn_start sig_en=68c037c98b685e3ba51824889df50c96 sig_cn_org=None source=14.1 
  <para>
   On error, one of the following negative values is returned:

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       if <parameter>command</parameter> is <symbol>NULL</symbol> or
       <parameter>count</parameter> is less than 0
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_COPY</symbol></term>
     <listitem>
      <para>
       if <command>COPY TO stdout</command> or <command>COPY FROM stdin</command>
       was attempted
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_TRANSACTION</symbol></term>
     <listitem>
      <para>
       if a transaction manipulation command was attempted
       (<command>BEGIN</command>,
       <command>COMMIT</command>,
       <command>ROLLBACK</command>,
       <command>SAVEPOINT</command>,
       <command>PREPARE TRANSACTION</command>,
       <command>COMMIT PREPARED</command>,
       <command>ROLLBACK PREPARED</command>,
       or any variant thereof)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_OPUNKNOWN</symbol></term>
     <listitem>
      <para>
       if the command type is unknown (shouldn't happen)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       if called from an unconnected C function
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   发生错误时，将会返回下列负值之一：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       如果<parameter>command</parameter>为<symbol>NULL</symbol>或者<parameter>count</parameter>小于 0
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_COPY</symbol></term>
     <listitem>
      <para>
       如果尝试<command>COPY TO stdout</command>或者<command>COPY FROM stdin</command>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_TRANSACTION</symbol></term>
     <listitem>
      <para>
       如果尝试了一个事务操纵命令（
       <command>BEGIN</command>、
       <command>COMMIT</command>、
       <command>ROLLBACK</command>、
       <command>SAVEPOINT</command>、
       <command>PREPARE TRANSACTION</command>、
       <command>COMMIT PREPARED</command>、
       <command>ROLLBACK PREPARED</command>或者其他变体）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_OPUNKNOWN</symbol></term>
     <listitem>
      <para>
       如果命令类型位置（不应该会发生）
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       如果从未连接的C函数中调用
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=68c037c98b685e3ba51824889df50c96 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
  <title>Notes</title>
________________________________________________________-->
  <title>注解</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->

<!-- pgdoc-cn_start sig_en=21ed038fc2c692b31a5eff12f432e610 sig_cn_org=None source=14.1 
  <para>
   All SPI query-execution functions set both
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> (just the pointer, not the contents
   of the structure).  Save these two global variables into local
   C function variables if you need to access the result table of
   <function>SPI_execute</function> or another query-execution function
   across later calls.
  </para>
________________________________________________________-->
  <para>
   所有 SPI 查询执行函数都会设置<varname>SPI_processed</varname>和<varname>SPI_tuptable</varname>（只是指针，
   而不是结构的内容）。如果你需要在以后访问<function>SPI_execute</function>或另一个查询执行函数的结果表，
   请将这两个全局变量保存到本地的C函数变量中。
  </para>
<!-- pgdoc-cn_end sig_en=21ed038fc2c692b31a5eff12f432e610 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-exec">
<!-- pgdoc-cn_start sig_en=67c7cda3bb90f10d2ee555df870d0baf sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_exec</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_exec</primary></indexterm>
<!-- pgdoc-cn_end sig_en=67c7cda3bb90f10d2ee555df870d0baf -->

 <refmeta>
  <refentrytitle>SPI_exec</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=be22807901b8495cf5c6ae168993098a sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_exec</refname>
  <refpurpose>execute a read/write command</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_exec</refname>
  <refpurpose>执行一个读/写命令</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=be22807901b8495cf5c6ae168993098a -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=5e60f0a676d2301ca46b9eb3376aec1c sig_cn_org=None source=14.1 
<synopsis>
int SPI_exec(const char * <parameter>command</parameter>, long <parameter>count</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
int SPI_exec(const char * <parameter>command</parameter>, long <parameter>count</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=5e60f0a676d2301ca46b9eb3376aec1c -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=d6753692b46ad01d1d23ef717dc17634 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_exec</function> is the same as
   <function>SPI_execute</function>, with the latter's
   <parameter>read_only</parameter> parameter always taken as
   <literal>false</literal>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_exec</function>和
   <function>SPI_execute</function>相同，但后者的
   <parameter>read_only</parameter>参数的值总是取
   <literal>false</literal>。
  </para>
<!-- pgdoc-cn_end sig_en=d6753692b46ad01d1d23ef717dc17634 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=46320af8f64498547aefb470bbe1f695 sig_cn_org=None source=14.1 
     <para>
      string containing command to execute
     </para>
________________________________________________________-->
     <para>
      包含要执行命令的字符串
     </para>
<!-- pgdoc-cn_end sig_en=46320af8f64498547aefb470bbe1f695 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=40ca4421fc90d088c0476e49929d6da0 sig_cn_org=None source=14.1 
     <para>
      maximum number of rows to return,
      or <literal>0</literal> for no limit
     </para>
________________________________________________________-->
     <para>
      要返回的最大行数，或者用<literal>0</literal>表示没有限制
     </para>
<!-- pgdoc-cn_end sig_en=40ca4421fc90d088c0476e49929d6da0 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=70aa52e00901c78474ddd2e97378e639 sig_cn_org=None source=14.1 
  <para>
   See <function>SPI_execute</function>.
  </para>
________________________________________________________-->
  <para>
   见<function>SPI_execute</function>。
  </para>
<!-- pgdoc-cn_end sig_en=70aa52e00901c78474ddd2e97378e639 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute-extended">
<!-- pgdoc-cn_start sig_en=0d0051d415efed7b1b976a75064b2e54 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_execute_extended</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_execute_extended</primary></indexterm>
<!-- pgdoc-cn_end sig_en=0d0051d415efed7b1b976a75064b2e54 -->

 <refmeta>
  <refentrytitle>SPI_execute_extended</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=259ee8d5e829d2e9d9fe0a0ab34d623e sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_execute_extended</refname>
  <refpurpose>execute a command with out-of-line parameters</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_execute_extended</refname>
  <refpurpose>执行带线外参数的命令</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=259ee8d5e829d2e9d9fe0a0ab34d623e -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=77faff0979291e1041a3657c3780aa58 sig_cn_org=None source=14.1 
<synopsis>
int SPI_execute_extended(const char *<parameter>command</parameter>,
                         const SPIExecuteOptions * <parameter>options</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
int SPI_execute_extended(const char *<parameter>command</parameter>,
                         const SPIExecuteOptions * <parameter>options</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=77faff0979291e1041a3657c3780aa58 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=77ee510e31c2a595bc77aa65f69c306a sig_cn_org=None source=14.1 
  <para>
   <function>SPI_execute_extended</function> executes a command that might
   include references to externally supplied parameters.  The command text
   refers to a parameter as <literal>$<replaceable>n</replaceable></literal>,
   and the <parameter>options-&gt;params</parameter> object (if supplied)
   provides values and type information for each such symbol.
   Various execution options can be specified
   in the <parameter>options</parameter> struct, too.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_execute_extended</function>执行一个可能包括关于外部支持参数的命令。
   命令文本引用参数为<literal>$<replaceable>n</replaceable></literal>，以及<parameter>options-&gt;params</parameter>对象(如果支持)提供值和类型信息，对于每个符号。
   不同的执行选项也可以在<parameter>options</parameter>结构中指定。
  </para>
<!-- pgdoc-cn_end sig_en=77ee510e31c2a595bc77aa65f69c306a -->

<!-- pgdoc-cn_start sig_en=010ceb3204beecfbb23f26367d071bff sig_cn_org=None source=14.1 
  <para>
   The <parameter>options-&gt;params</parameter> object should normally
   mark each parameter with the <literal>PARAM_FLAG_CONST</literal> flag,
   since a one-shot plan is always used for the query.
  </para>
________________________________________________________-->
  <para>
   <parameter>options-&gt;params</parameter> 对象将通常以<literal>PARAM_FLAG_CONST</literal>特征位标记每个参数，因为一个一次性计划总是用于查询。
  </para>
<!-- pgdoc-cn_end sig_en=010ceb3204beecfbb23f26367d071bff -->

<!-- pgdoc-cn_start sig_en=fe5dd573bce5372077bb99b197d55691 sig_cn_org=None source=14.1 
  <para>
   If <parameter>options-&gt;dest</parameter> is not NULL, then result
   tuples are passed to that object as they are generated by the executor,
   instead of being accumulated in <varname>SPI_tuptable</varname>.  Using
   a caller-supplied <literal>DestReceiver</literal> object is particularly
   helpful for queries that might generate many tuples, since the data can
   be processed on-the-fly instead of being accumulated in memory.
  </para>
________________________________________________________-->
  <para>
   如果<parameter>options-&gt;dest</parameter>为非NULL，则结果元组被传递到执行器产生的对象，而不是积累在<varname>SPI_tuptable</varname>里。
   使用调用器支持的<literal>DestReceiver</literal>对象特别有帮助，对于可能产生多个元组的查询，因为数据可以在过程中处理而不是积累在内存里。
  </para>
<!-- pgdoc-cn_end sig_en=fe5dd573bce5372077bb99b197d55691 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=a12067418fb7474b146adb5a862771c0 sig_cn_org=None source=14.1 
     <para>
      command string
     </para>
________________________________________________________-->
     <para>
      命令字符串
     </para>
<!-- pgdoc-cn_end sig_en=a12067418fb7474b146adb5a862771c0 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const SPIExecuteOptions * <parameter>options</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=5a8ac1b553b4ce7a64f94f1bf9604635 sig_cn_org=None source=14.1 
     <para>
      struct containing optional arguments
     </para>
________________________________________________________-->
     <para>
      包含可选参数的结构体
     </para>
<!-- pgdoc-cn_end sig_en=5a8ac1b553b4ce7a64f94f1bf9604635 -->
    </listitem>
   </varlistentry>
  </variablelist>

<!-- pgdoc-cn_start sig_en=507f26acb20bb94c84d36715775669fc sig_cn_org=None source=14.1 
  <para>
   Callers should always zero out the entire <parameter>options</parameter>
   struct, then fill whichever fields they want to set.  This ensures forward
   compatibility of code, since any fields that are added to the struct in
   future will be defined to behave backwards-compatibly if they are zero.
   The currently available <parameter>options</parameter> fields are:
  </para>
________________________________________________________-->
  <para>
   调用器将总是将整个<parameter>options</parameter>结构体归零，然后填充他们想设置的任何字段。
   这确保代码的向前兼容性，因为在未来添加到结构体中的任何字段将被定义成行为向后兼容，如果他们为零。
   当前有效的<parameter>options</parameter>字段为：
  </para>
<!-- pgdoc-cn_end sig_en=507f26acb20bb94c84d36715775669fc -->

  <variablelist>
   <varlistentry>
    <term><literal>ParamListInfo <parameter>params</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=d463c39cdaff23f00b44fef84727bd66 sig_cn_org=None source=14.1 
     <para>
      data structure containing query parameter types and values; NULL if none
     </para>
________________________________________________________-->
     <para>
      包含查询参数类型和值的数据结构；没有则为NULL
     </para>
<!-- pgdoc-cn_end sig_en=d463c39cdaff23f00b44fef84727bd66 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=b4631d77e109c42543b5ede7350ea3c6 sig_cn_org=None source=14.1 
     <para><literal>true</literal> for read-only execution</para>
________________________________________________________-->
     <para>对只读执行为<literal>true</literal></para>
<!-- pgdoc-cn_end sig_en=b4631d77e109c42543b5ede7350ea3c6 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>allow_nonatomic</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=6ecdf023cae3b289793e459472f9d5a9 sig_cn_org=None source=14.1 
     <para>
      <literal>true</literal> allows non-atomic execution of CALL and DO
      statements
     </para>
________________________________________________________-->
     <para>
      <literal>true</literal> 允许CALL和DO语句的非原子执行。
     </para>
<!-- pgdoc-cn_end sig_en=6ecdf023cae3b289793e459472f9d5a9 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>must_return_tuples</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=426f037fdd895a60e99b16c93e37b151 sig_cn_org=None source=14.1 
     <para>
      if <literal>true</literal>, raise error if the query is not of a kind
      that returns tuples (this does not forbid the case where it happens to
      return zero tuples)
     </para>
________________________________________________________-->
     <para>
      如果为<literal>true</literal>，如果查询不是一种返回元组时抛出错误(这不禁止发生返回零元组的情况) 
     </para>
<!-- pgdoc-cn_end sig_en=426f037fdd895a60e99b16c93e37b151 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>uint64 <parameter>tcount</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=40ca4421fc90d088c0476e49929d6da0 sig_cn_org=None source=14.1 
     <para>
      maximum number of rows to return,
      or <literal>0</literal> for no limit
     </para>
________________________________________________________-->
     <para>
      要返回的最大行数，或者用<literal>0</literal>表示没有限制
     </para>
<!-- pgdoc-cn_end sig_en=40ca4421fc90d088c0476e49929d6da0 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DestReceiver * <parameter>dest</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=d14985a229b99f797887fab9fb82fbee sig_cn_org=None source=14.1 
     <para>
      <literal>DestReceiver</literal> object that will receive any tuples
      emitted by the query; if NULL, result tuples are accumulated into
      a <varname>SPI_tuptable</varname> structure, as
      in <function>SPI_execute</function>
     </para>
________________________________________________________-->
     <para>
      <literal>DestReceiver</literal> 对象将接收查询发出的任何元组；如果为NULL，结果元组积累到<varname>SPI_tuptable</varname>结构之中，就像在<function>SPI_execute</function>中一样。
     </para>
<!-- pgdoc-cn_end sig_en=d14985a229b99f797887fab9fb82fbee -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ResourceOwner <parameter>owner</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=1131a291c67c9010fa2a2a8bdd9dd4d0 sig_cn_org=None source=14.1 
     <para>
      This field is present for consistency
      with <function>SPI_execute_plan_extended</function>, but it is
      ignored, since the plan used
      by <function>SPI_execute_extended</function> is never saved.
     </para>
________________________________________________________-->
     <para>
      这个字段表现和<function>SPI_execute_plan_extended</function>一致，但是它被忽略，因为被<function>SPI_execute_extended</function>使用的计划从来不保存。
     </para>
<!-- pgdoc-cn_end sig_en=1131a291c67c9010fa2a2a8bdd9dd4d0 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=3ae1401856f0b20f060f9af13a110d50 sig_cn_org=None source=14.1 
  <para>
   The return value is the same as for <function>SPI_execute</function>.
  </para>
________________________________________________________-->
  <para>
   返回值同<function>SPI_execute</function>一样。
  </para>
<!-- pgdoc-cn_end sig_en=3ae1401856f0b20f060f9af13a110d50 -->

<!-- pgdoc-cn_start sig_en=1a3209d34c95c1ae7c45057c784cfa4c sig_cn_org=None source=14.1 
  <para>
   When <parameter>options-&gt;dest</parameter> is NULL,
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute</function>.
   When <parameter>options-&gt;dest</parameter> is not NULL,
   <varname>SPI_processed</varname> is set to zero and
   <varname>SPI_tuptable</varname> is set to NULL.  If a tuple count
   is required, the caller's <literal>DestReceiver</literal> object must
   calculate it.
  </para>
________________________________________________________-->
  <para>
   当<parameter>options-&gt;dest</parameter>为NULL时，<varname>SPI_processed</varname> 和 <varname>SPI_tuptable</varname>设置为在<function>SPI_execute</function>中。
   当<parameter>options-&gt;dest</parameter>不为NULL时，<varname>SPI_processed</varname>被设置为零，并且<varname>SPI_tuptable</varname>被设置为NULL。
   如果需要元组计数，调度器的<literal>DestReceiver</literal>对象必须计算它。
  </para>
<!-- pgdoc-cn_end sig_en=1a3209d34c95c1ae7c45057c784cfa4c -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute-with-args">
<!-- pgdoc-cn_start sig_en=aaacc23c6a4769b09a6ff31bdc6cc395 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_execute_with_args</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_execute_with_args</primary></indexterm>
<!-- pgdoc-cn_end sig_en=aaacc23c6a4769b09a6ff31bdc6cc395 -->

 <refmeta>
  <refentrytitle>SPI_execute_with_args</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=2fbdc08ec0c6b167055eeff33e062757 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_execute_with_args</refname>
  <refpurpose>execute a command with out-of-line parameters</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_execute_with_args</refname>
  <refpurpose>用线外参数执行一个命令</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=2fbdc08ec0c6b167055eeff33e062757 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=39dfe6f975b795bfb84a41cd14ede478 sig_cn_org=None source=14.1 
<synopsis>
int SPI_execute_with_args(const char *<parameter>command</parameter>,
                          int <parameter>nargs</parameter>, Oid *<parameter>argtypes</parameter>,
                          Datum *<parameter>values</parameter>, const char *<parameter>nulls</parameter>,
                          bool <parameter>read_only</parameter>, long <parameter>count</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
int SPI_execute_with_args(const char *<parameter>command</parameter>,
                          int <parameter>nargs</parameter>, Oid *<parameter>argtypes</parameter>,
                          Datum *<parameter>values</parameter>, const char *<parameter>nulls</parameter>,
                          bool <parameter>read_only</parameter>, long <parameter>count</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=39dfe6f975b795bfb84a41cd14ede478 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=1821bb1d447e4dd8fc05a978fce4fcd0 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_execute_with_args</function> executes a command that might
   include references to externally supplied parameters.  The command text
   refers to a parameter as <literal>$<replaceable>n</replaceable></literal>, and
   the call specifies data types and values for each such symbol.
   <parameter>read_only</parameter> and <parameter>count</parameter> have
   the same interpretation as in <function>SPI_execute</function>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_execute_with_args</function>执行一个可能包括
   对外部提供的参数引用的命令。命令文本用
   <literal>$<replaceable>n</replaceable></literal>引用一个参数，并且调用
   会为每一个这种符号指定数据类型和值。
   <parameter>read_only</parameter>和
   <parameter>count</parameter>的解释与
   <function>SPI_execute</function>中相同。
  </para>
<!-- pgdoc-cn_end sig_en=1821bb1d447e4dd8fc05a978fce4fcd0 -->

<!-- pgdoc-cn_start sig_en=88f5f26f34958e3516e74c5222da6a41 sig_cn_org=None source=14.1 
  <para>
   The main advantage of this routine compared to
   <function>SPI_execute</function> is that data values can be inserted
   into the command without tedious quoting/escaping, and thus with much
   less risk of SQL-injection attacks.
  </para>
________________________________________________________-->
  <para>
   相对于<function>SPI_execute</function>，这个例程的主要优
   点是数据值可以被插入到命令中而无需冗长的引用/转义，并且因此
   减少了 SQL 注入攻击的风险。
  </para>
<!-- pgdoc-cn_end sig_en=88f5f26f34958e3516e74c5222da6a41 -->

<!-- pgdoc-cn_start sig_en=bdb15660b3132b76201b74c879824877 sig_cn_org=None source=14.1 
  <para>
   Similar results can be achieved with <function>SPI_prepare</function> followed by
   <function>SPI_execute_plan</function>; however, when using this function
   the query plan is always customized to the specific parameter values
   provided.
   For one-time query execution, this function should be preferred.
   If the same command is to be executed with many different parameters,
   either method might be faster, depending on the cost of re-planning
   versus the benefit of custom plans.
  </para>
________________________________________________________-->
  <para>
   可以通过在<function>SPI_prepare</function>后面跟上
   <function>SPI_execute_plan</function>达到相似的结果。但是，
   使用这个函数时查询计划总是被定制成提供的指定参数值。对于一次
   性的查询执行，这个函数应该更好。如果同样的命令需要用很多不同
   的参数执行，两种方法都可能会更快，这取决于重新做规划的代价与
   定制计划带来的好处之间的对比。
  </para>
<!-- pgdoc-cn_end sig_en=bdb15660b3132b76201b74c879824877 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=a12067418fb7474b146adb5a862771c0 sig_cn_org=None source=14.1 
     <para>
      command string
     </para>
________________________________________________________-->
     <para>
      命令字符串
     </para>
<!-- pgdoc-cn_end sig_en=a12067418fb7474b146adb5a862771c0 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>nargs</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=91d8128269766936120f242347d2e9ab sig_cn_org=None source=14.1 
     <para>
      number of input parameters (<literal>$1</literal>, <literal>$2</literal>, etc.)
     </para>
________________________________________________________-->
     <para>
      输入参数的数量（<literal>$1</literal>、<literal>$2</literal>等等）。
     </para>
<!-- pgdoc-cn_end sig_en=91d8128269766936120f242347d2e9ab -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=25168306c917bc4fa2ac1a794d0acbd6 sig_cn_org=None source=14.1 
     <para>
      an array of length <parameter>nargs</parameter>, containing the
      <acronym>OID</acronym>s of the data types of the parameters
     </para>
________________________________________________________-->
     <para>
      一个长度为<parameter>nargs</parameter>的数组，
      包含参数的数据类型的<acronym>OID</acronym>
     </para>
<!-- pgdoc-cn_end sig_en=25168306c917bc4fa2ac1a794d0acbd6 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=9162abcaa4afd84b6c714e9110e102fb sig_cn_org=None source=14.1 
     <para>
      an array of length <parameter>nargs</parameter>, containing the actual
      parameter values
     </para>
________________________________________________________-->
     <para>
      一个长度为<parameter>nargs</parameter>的数组，
      包含实际的参数值
     </para>
<!-- pgdoc-cn_end sig_en=9162abcaa4afd84b6c714e9110e102fb -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=c45f3ae0214af534c266875d73016440 sig_cn_org=None source=14.1 
     <para>
      an array of length <parameter>nargs</parameter>, describing which
      parameters are null
     </para>
________________________________________________________-->
     <para>
      一个长度为<parameter>nargs</parameter>的数组，
      描述哪些参数为空值
     </para>
<!-- pgdoc-cn_end sig_en=c45f3ae0214af534c266875d73016440 -->

<!-- pgdoc-cn_start sig_en=2269a2e587d0c3d76f3f8f626838ad67 sig_cn_org=None source=14.1 
     <para>
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_execute_with_args</function> assumes that no parameters
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</literal> if the corresponding parameter
      value is non-null, or <literal>'n'</literal> if the corresponding parameter
      value is null.  (In the latter case, the actual value in the
      corresponding <parameter>values</parameter> entry doesn't matter.)  Note
      that <parameter>nulls</parameter> is not a text string, just an array:
      it does not need a <literal>'\0'</literal> terminator.
     </para>
________________________________________________________-->
     <para>
      如果<parameter>nulls</parameter>为<symbol>NULL</symbol>，
      那么<function>SPI_execute_with_args</function>会假设没有参数
      为空值。否则，如果对应的参数值为非空，
      <parameter>nulls</parameter>
      数组的每一个项都应该是<literal>'&nbsp;'</literal>；如果对应参数值为空，
      <parameter>nulls</parameter>数组的项应为<literal>'n'</literal>（在后
      面的情况中，对应的<parameter>values</parameter>项中的值没有
      关系）。注意<parameter>nulls</parameter>不是一个文本字符串，
      它只是一个数组：它不需要一个<literal>'\0'</literal>终止符。
     </para>
<!-- pgdoc-cn_end sig_en=2269a2e587d0c3d76f3f8f626838ad67 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=b4631d77e109c42543b5ede7350ea3c6 sig_cn_org=None source=14.1 
     <para><literal>true</literal> for read-only execution</para>
________________________________________________________-->
     <para>对只读执行为<literal>true</literal></para>
<!-- pgdoc-cn_end sig_en=b4631d77e109c42543b5ede7350ea3c6 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=40ca4421fc90d088c0476e49929d6da0 sig_cn_org=None source=14.1 
     <para>
      maximum number of rows to return,
      or <literal>0</literal> for no limit
     </para>
________________________________________________________-->
     <para>
      要返回的最大行数，或者用<literal>0</literal>表示没有限制
     </para>
<!-- pgdoc-cn_end sig_en=40ca4421fc90d088c0476e49929d6da0 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=3ae1401856f0b20f060f9af13a110d50 sig_cn_org=None source=14.1 
  <para>
   The return value is the same as for <function>SPI_execute</function>.
  </para>
________________________________________________________-->
  <para>
   返回值同<function>SPI_execute</function>一样。
  </para>
<!-- pgdoc-cn_end sig_en=3ae1401856f0b20f060f9af13a110d50 -->

<!-- pgdoc-cn_start sig_en=f501eb9c4097f782a68f87c3eed6fb6e sig_cn_org=None source=14.1 
  <para>
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute</function> if successful.
  </para>
________________________________________________________-->
  <para>
   如果成功<function>SPI_execute</function>会设置
   <varname>SPI_processed</varname>和
   <varname>SPI_tuptable</varname>。
  </para>
<!-- pgdoc-cn_end sig_en=f501eb9c4097f782a68f87c3eed6fb6e -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-prepare">
<!-- pgdoc-cn_start sig_en=806009787e203110c1b9f9b7d43b8e44 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_prepare</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_prepare</primary></indexterm>
<!-- pgdoc-cn_end sig_en=806009787e203110c1b9f9b7d43b8e44 -->

 <refmeta>
  <refentrytitle>SPI_prepare</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=f780bf4d438827ad28350e617a0f20a0 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_prepare</refname>
  <refpurpose>prepare a statement, without executing it yet</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_prepare</refname>
  <refpurpose>准备一个语句，但不执行它</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=f780bf4d438827ad28350e617a0f20a0 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=54d349158617614962171c0e78a95543 sig_cn_org=None source=14.1 
<synopsis>
SPIPlanPtr SPI_prepare(const char * <parameter>command</parameter>, int <parameter>nargs</parameter>, Oid * <parameter>argtypes</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
SPIPlanPtr SPI_prepare(const char * <parameter>command</parameter>, int <parameter>nargs</parameter>, Oid * <parameter>argtypes</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=54d349158617614962171c0e78a95543 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=366bbf4c4deb188fdf8721adeb339fa8 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_prepare</function> creates and returns a prepared
   statement for the specified command, but doesn't execute the command.
   The prepared statement can later be executed repeatedly using
   <function>SPI_execute_plan</function>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_prepare</function>为指定的命令创建并且返回一个
   预备语句，但是并不执行该命令。该预备语句会在稍后使用
   <function>SPI_execute_plan</function>重复执行。
  </para>
<!-- pgdoc-cn_end sig_en=366bbf4c4deb188fdf8721adeb339fa8 -->

<!-- pgdoc-cn_start sig_en=2ea07190658fab26c8a009d8cdb423e3 sig_cn_org=None source=14.1 
  <para>
   When the same or a similar command is to be executed repeatedly, it
   is generally advantageous to perform parse analysis only once, and
   might furthermore be advantageous to re-use an execution plan for the
   command.
   <function>SPI_prepare</function> converts a command string into a
   prepared statement that encapsulates the results of parse analysis.
   The prepared statement also provides a place for caching an execution plan
   if it is found that generating a custom plan for each execution is not
   helpful.
  </para>
________________________________________________________-->
  <para>
   当相同的或者相似的命令要被重复执行时，通常来说只执行一次解析分
   析是有利的，并且更有利的是重用该命令的执行计划。
   <function>SPI_prepare</function>把一个命令字符串转换成一个预
   备语句，它包装了解析分析的结果。如果发现为每一次执行都生成一个
   定制计划没有帮助，该预备语句也提供了一个地方缓存执行计划。
  </para>
<!-- pgdoc-cn_end sig_en=2ea07190658fab26c8a009d8cdb423e3 -->

<!-- pgdoc-cn_start sig_en=76f7899b14186179bf4ec1485eeae6b6 sig_cn_org=None source=14.1 
  <para>
   A prepared command can be generalized by writing parameters
   (<literal>$1</literal>, <literal>$2</literal>, etc.) in place of what would be
   constants in a normal command.  The actual values of the parameters
   are then specified when <function>SPI_execute_plan</function> is called.
   This allows the prepared command to be used over a wider range of
   situations than would be possible without parameters.
  </para>
________________________________________________________-->
  <para>
   一个预备命令可以被一般化为在一个普通命令中应该出现常量的地方写
   上参数（<literal>$1</literal>、<literal>$2</literal>等等）。参数的实际值在
   <function>SPI_execute_plan</function>被调用时指定。这让该预备
   语句可以比没有参数的形式用户与更广泛的情况。
  </para>
<!-- pgdoc-cn_end sig_en=76f7899b14186179bf4ec1485eeae6b6 -->

<!-- pgdoc-cn_start sig_en=703ee33f7abea4fe780ae968d4a6dfaf sig_cn_org=None source=14.1 
  <para>
   The statement returned by <function>SPI_prepare</function> can be used
   only in the current invocation of the C function, since
   <function>SPI_finish</function> frees memory allocated for such a
   statement.  But the statement can be saved for longer using the functions
   <function>SPI_keepplan</function> or <function>SPI_saveplan</function>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_prepare</function>返回的语句只能在当前的C过程调用
   中使用，因为<function>SPI_finish</function>会释放为这样一个语句
   分配的内存。但是可以使用函数<function>SPI_keepplan</function>
   或<function>SPI_saveplan</function>把该语句保存更久。
  </para>
<!-- pgdoc-cn_end sig_en=703ee33f7abea4fe780ae968d4a6dfaf -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=a12067418fb7474b146adb5a862771c0 sig_cn_org=None source=14.1 
     <para>
      command string
     </para>
________________________________________________________-->
     <para>
      命令字符串
     </para>
<!-- pgdoc-cn_end sig_en=a12067418fb7474b146adb5a862771c0 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>nargs</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=91d8128269766936120f242347d2e9ab sig_cn_org=None source=14.1 
     <para>
      number of input parameters (<literal>$1</literal>, <literal>$2</literal>, etc.)
     </para>
________________________________________________________-->
     <para>
      输入参数的数量（<literal>$1</literal>、<literal>$2</literal>等等）。
     </para>
<!-- pgdoc-cn_end sig_en=91d8128269766936120f242347d2e9ab -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=dfdb731eb593fd66e0f9d766b5968cea sig_cn_org=None source=14.1 
     <para>
      pointer to an array containing the <acronym>OID</acronym>s of
      the data types of the parameters
     </para>
________________________________________________________-->
     <para>
      一个数组指针，它指向的数组包含参数的数据类型的
      <acronym>OID</acronym>
     </para>
<!-- pgdoc-cn_end sig_en=dfdb731eb593fd66e0f9d766b5968cea -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=822edde20929e875dd3537ca1d8a764d sig_cn_org=None source=14.1 
  <para>
   <function>SPI_prepare</function> returns a non-null pointer to an
   <type>SPIPlan</type>, which is an opaque struct representing a prepared
   statement.  On error, <symbol>NULL</symbol> will be returned,
   and <varname>SPI_result</varname> will be set to one of the same
   error codes used by <function>SPI_execute</function>, except that
   it is set to <symbol>SPI_ERROR_ARGUMENT</symbol> if
   <parameter>command</parameter> is <symbol>NULL</symbol>, or if
   <parameter>nargs</parameter> is less than 0, or if <parameter>nargs</parameter> is
   greater than 0 and <parameter>argtypes</parameter> is <symbol>NULL</symbol>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_prepare</function>返回一个指向<type>SPIPlan</type>
   的非空指针，它是一个表示一个预备语句的不透明结构。发生错误时，
   将会返回<symbol>NULL</symbol>，并且
   <varname>SPI_result</varname>将被设置为一个也被
   <function>SPI_execute</function>使用的错误码，不过当
   <parameter>command</parameter>为<symbol>NULL</symbol>、
   或者<parameter>nargs</parameter>小于零、或者<parameter>nargs</parameter>大于
   零但是<parameter>argtypes</parameter>为<symbol>NULL</symbol>
   时它会被设置为<symbol>SPI_ERROR_ARGUMENT</symbol>。
  </para>
<!-- pgdoc-cn_end sig_en=822edde20929e875dd3537ca1d8a764d -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
  <title>Notes</title>
________________________________________________________-->
  <title>注解</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->

<!-- pgdoc-cn_start sig_en=6c48af069412a54aaa4859946d60b120 sig_cn_org=None source=14.1 
  <para>
   If no parameters are defined, a generic plan will be created at the
   first use of <function>SPI_execute_plan</function>, and used for all
   subsequent executions as well.  If there are parameters, the first few uses
   of <function>SPI_execute_plan</function> will generate custom plans
   that are specific to the supplied parameter values.  After enough uses
   of the same prepared statement, <function>SPI_execute_plan</function> will
   build a generic plan, and if that is not too much more expensive than the
   custom plans, it will start using the generic plan instead of re-planning
   each time.  If this default behavior is unsuitable, you can alter it by
   passing the <literal>CURSOR_OPT_GENERIC_PLAN</literal> or
   <literal>CURSOR_OPT_CUSTOM_PLAN</literal> flag to
   <function>SPI_prepare_cursor</function>, to force use of generic or custom
   plans respectively.
  </para>
________________________________________________________-->
  <para>
   如果没有定义参数，在第一次使用<function>SPI_execute_plan</function>
   时将会创建一个一般的计划，并且把它用于所有的后续执行。如果有参数，
   <function>SPI_execute_plan</function>的前几次使用将根据提供的参数值
   产生定制计划。在使用同一个预备语句足够多次后，
   <function>SPI_execute_plan</function>将构建一个一般计划，并且如果它
   并不比定制计划昂贵太多， <function>SPI_execute_plan</function>将开始
   使用一般计划来取代每次都进行重新规划。如果这种默认的行为不合适，你可以
   通过传递<literal>CURSOR_OPT_GENERIC_PLAN</literal>或
   <literal>CURSOR_OPT_CUSTOM_PLAN</literal>标志给
   <function>SPI_prepare_cursor</function>，以分别强制使用一般或者定制
   计划。
  </para>
<!-- pgdoc-cn_end sig_en=6c48af069412a54aaa4859946d60b120 -->

<!-- pgdoc-cn_start sig_en=bbcff2d20b3c23e14a0c8ac7224a488e sig_cn_org=None source=14.1 
  <para>
   Although the main point of a prepared statement is to avoid repeated parse
   analysis and planning of the statement, <productname>PostgreSQL</productname> will
   force re-analysis and re-planning of the statement before using it
   whenever database objects used in the statement have undergone
   definitional (DDL) changes since the previous use of the prepared
   statement.  Also, if the value of <xref linkend="guc-search-path"/> changes
   from one use to the next, the statement will be re-parsed using the new
   <varname>search_path</varname>.  (This latter behavior is new as of
   <productname>PostgreSQL</productname> 9.3.)  See <xref
   linkend="sql-prepare"/> for more information about the behavior of prepared
   statements.
  </para>
________________________________________________________-->
  <para>
   尽管一个预备语句的要点是避免对语句的重复解析分析以及规划，只要语句中
   用到的数据库对象从上一次使用该预备语句以来经历过定义性（DDL）改变，
   <productname>PostgreSQL</productname>将会强制重新分析和重新规划该语句。还有，
   如果<xref linkend="guc-search-path"/>的值从一个改变成下一个，该语句将
   会使用新的<varname>search_path</varname>进行重新解析（后一种行为是从
   <productname>PostgreSQL</productname> 9.3 开始的新行为）。更多
   有关预备语句行为的信息请见<xref linkend="sql-prepare"/>。
  </para>
<!-- pgdoc-cn_end sig_en=bbcff2d20b3c23e14a0c8ac7224a488e -->

<!-- pgdoc-cn_start sig_en=87efe767a8f9f7dfe79a519db87970fc sig_cn_org=None source=14.1 
  <para>
   This function should only be called from a connected C function.
  </para>
________________________________________________________-->
  <para>
   这个函数只能从一个已连接的C函数调用。
  </para>
<!-- pgdoc-cn_end sig_en=87efe767a8f9f7dfe79a519db87970fc -->

<!-- pgdoc-cn_start sig_en=d2cd75800b54cff3d6e98f255c9e1611 sig_cn_org=None source=14.1 
  <para>
   <type>SPIPlanPtr</type> is declared as a pointer to an opaque struct type in
   <filename>spi.h</filename>.  It is unwise to try to access its contents
   directly, as that makes your code much more likely to break in
   future revisions of <productname>PostgreSQL</productname>.
  </para>
________________________________________________________-->
  <para>
   <type>SPIPlanPtr</type>被声明为<filename>spi.h</filename>中的一种不透明结构类型
   的指针。尝试直接访问其内容是不明智的，因为那会让你的代码更有可能会在未
   来版本的<productname>PostgreSQL</productname>中崩溃。
  </para>
<!-- pgdoc-cn_end sig_en=d2cd75800b54cff3d6e98f255c9e1611 -->

<!-- pgdoc-cn_start sig_en=e440aaae1465ddbd0ef6902962e0b2c9 sig_cn_org=None source=14.1 
  <para>
   The name <type>SPIPlanPtr</type> is somewhat historical, since the data
   structure no longer necessarily contains an execution plan.
  </para>
________________________________________________________-->
  <para>
   <type>SPIPlanPtr</type>这个名字多少有点历史原因，因为该数据结构不再需要包
   含一个执行计划。
  </para>
<!-- pgdoc-cn_end sig_en=e440aaae1465ddbd0ef6902962e0b2c9 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-prepare-cursor">
<!-- pgdoc-cn_start sig_en=aaef9e760ba1b8887807ba940c55a39e sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_prepare_cursor</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_prepare_cursor</primary></indexterm>
<!-- pgdoc-cn_end sig_en=aaef9e760ba1b8887807ba940c55a39e -->

 <refmeta>
  <refentrytitle>SPI_prepare_cursor</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=312bf1d576eddb18540f6ea01f2b3b9f sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_prepare_cursor</refname>
  <refpurpose>prepare a statement, without executing it yet</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_prepare_cursor</refname>
  <refpurpose>预备一个语句，但是不执行它</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=312bf1d576eddb18540f6ea01f2b3b9f -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=9d06f4d7098119c6be7441ce80722890 sig_cn_org=None source=14.1 
<synopsis>
SPIPlanPtr SPI_prepare_cursor(const char * <parameter>command</parameter>, int <parameter>nargs</parameter>,
                              Oid * <parameter>argtypes</parameter>, int <parameter>cursorOptions</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
SPIPlanPtr SPI_prepare_cursor(const char * <parameter>command</parameter>, int <parameter>nargs</parameter>,
                              Oid * <parameter>argtypes</parameter>, int <parameter>cursorOptions</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=9d06f4d7098119c6be7441ce80722890 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=05cfb51e7f606cf089536d67e922e78a sig_cn_org=None source=14.1 
  <para>
   <function>SPI_prepare_cursor</function> is identical to
   <function>SPI_prepare</function>, except that it also allows specification
   of the planner's <quote>cursor options</quote> parameter.  This is a bit mask
   having the values shown in <filename>nodes/parsenodes.h</filename>
   for the <structfield>options</structfield> field of <structname>DeclareCursorStmt</structname>.
   <function>SPI_prepare</function> always takes the cursor options as zero.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_prepare_cursor</function>和
   <function>SPI_prepare</function>一样，不过它也允许说明规划器的
   <quote>游标选项</quote>参数。这是一个位掩码，它的值如
   <filename>nodes/parsenodes.h</filename>中
   <structname>DeclareCursorStmt</structname>的<structfield>options</structfield>域所示。
   <function>SPI_prepare</function>总是把该游标选项取做零。
  </para>
<!-- pgdoc-cn_end sig_en=05cfb51e7f606cf089536d67e922e78a -->

<!-- pgdoc-cn_start sig_en=837c87f9b2f148c207276e7fbe0d40a4 sig_cn_org=None source=14.1 
  <para>
   This function is now deprecated in favor
   of <function>SPI_prepare_extended</function>.
  </para>
________________________________________________________-->
  <para>
   这个参数现在被弃用，用<function>SPI_prepare_extended</function>代替。
  </para>
<!-- pgdoc-cn_end sig_en=837c87f9b2f148c207276e7fbe0d40a4 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=a12067418fb7474b146adb5a862771c0 sig_cn_org=None source=14.1 
     <para>
      command string
     </para>
________________________________________________________-->
     <para>
      命令字符串
     </para>
<!-- pgdoc-cn_end sig_en=a12067418fb7474b146adb5a862771c0 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>nargs</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=91d8128269766936120f242347d2e9ab sig_cn_org=None source=14.1 
     <para>
      number of input parameters (<literal>$1</literal>, <literal>$2</literal>, etc.)
     </para>
________________________________________________________-->
     <para>
      输入参数的数量（<literal>$1</literal>、<literal>$2</literal>等等）。
     </para>
<!-- pgdoc-cn_end sig_en=91d8128269766936120f242347d2e9ab -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=dfdb731eb593fd66e0f9d766b5968cea sig_cn_org=None source=14.1 
     <para>
      pointer to an array containing the <acronym>OID</acronym>s of
      the data types of the parameters
     </para>
________________________________________________________-->
     <para>
      一个数组指针，它指向的数组包含参数的数据类型的
      <acronym>OID</acronym>
     </para>
<!-- pgdoc-cn_end sig_en=dfdb731eb593fd66e0f9d766b5968cea -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>cursorOptions</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=766a5ff7fb3a5c027fbe740c701e1d64 sig_cn_org=None source=14.1 
     <para>
      integer bit mask of cursor options; zero produces default behavior
     </para>
________________________________________________________-->
     <para>
      整数形式的游标选项位掩码，零会导致默认行为
     </para>
<!-- pgdoc-cn_end sig_en=766a5ff7fb3a5c027fbe740c701e1d64 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=18c35fb1414eee255097d3d1d530dbc4 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_prepare_cursor</function> has the same return conventions as
   <function>SPI_prepare</function>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_prepare_cursor</function>具有和
   <function>SPI_prepare</function>一样的返回习惯。
  </para>
<!-- pgdoc-cn_end sig_en=18c35fb1414eee255097d3d1d530dbc4 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
  <title>Notes</title>
________________________________________________________-->
  <title>注解</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->

<!-- pgdoc-cn_start sig_en=2f0f0780fae27a05da13047e2ad62aae sig_cn_org=None source=14.1 
  <para>
   Useful bits to set in <parameter>cursorOptions</parameter> include
   <symbol>CURSOR_OPT_SCROLL</symbol>,
   <symbol>CURSOR_OPT_NO_SCROLL</symbol>,
   <symbol>CURSOR_OPT_FAST_PLAN</symbol>,
   <symbol>CURSOR_OPT_GENERIC_PLAN</symbol>, and
   <symbol>CURSOR_OPT_CUSTOM_PLAN</symbol>.  Note in particular that
   <symbol>CURSOR_OPT_HOLD</symbol> is ignored.
  </para>
________________________________________________________-->
  <para>
   在<parameter>cursorOptions</parameter>设置的有用的位包括
   <symbol>CURSOR_OPT_SCROLL</symbol>、
   <symbol>CURSOR_OPT_NO_SCROLL</symbol>、
   <symbol>CURSOR_OPT_FAST_PLAN</symbol>、
   <symbol>CURSOR_OPT_GENERIC_PLAN</symbol>以及
   <symbol>CURSOR_OPT_CUSTOM_PLAN</symbol>。
   注意<symbol>CURSOR_OPT_HOLD</symbol>被特别地忽略。
  </para>
<!-- pgdoc-cn_end sig_en=2f0f0780fae27a05da13047e2ad62aae -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-prepare-extended">
<!-- pgdoc-cn_start sig_en=a330ce81f90bcc1114420529101f0a9f sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_prepare_extended</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_prepare_extended</primary></indexterm>
<!-- pgdoc-cn_end sig_en=a330ce81f90bcc1114420529101f0a9f -->

 <refmeta>
  <refentrytitle>SPI_prepare_extended</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=7b64b3ba2ecd2cf2651cbf696bd3108d sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_prepare_extended</refname>
  <refpurpose>prepare a statement, without executing it yet</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_prepare_extended</refname>
  <refpurpose>准备语句，还没有执行它</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=7b64b3ba2ecd2cf2651cbf696bd3108d -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=eb366301b0135140db1844a922396ada sig_cn_org=None source=14.1 
<synopsis>
SPIPlanPtr SPI_prepare_extended(const char * <parameter>command</parameter>,
                                const SPIPrepareOptions * <parameter>options</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
SPIPlanPtr SPI_prepare_extended(const char * <parameter>command</parameter>,
                                const SPIPrepareOptions * <parameter>options</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=eb366301b0135140db1844a922396ada -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=f4160af253df4a29eeac4db844f1c66d sig_cn_org=None source=14.1 
  <para>
   <function>SPI_prepare_extended</function> creates and returns a prepared
   statement for the specified command, but doesn't execute the command.
   This function is equivalent to <function>SPI_prepare</function>,
   with the addition that the caller can specify options to control
   the parsing of external parameter references, as well as other facets
   of query parsing and planning.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_prepare_extended</function>建立和返回一个对指定命令的准备语句，但是不执行该命令。
   这个函数等同于<function>SPI_prepare</function>，此外调度器可以指定选项以控制外部参数引用的语法分析，就像查询语法分析和计划的其他部分一样。
  </para>
<!-- pgdoc-cn_end sig_en=f4160af253df4a29eeac4db844f1c66d -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=a12067418fb7474b146adb5a862771c0 sig_cn_org=None source=14.1 
     <para>
      command string
     </para>
________________________________________________________-->
     <para>
      命令字符串
     </para>
<!-- pgdoc-cn_end sig_en=a12067418fb7474b146adb5a862771c0 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const SPIPrepareOptions * <parameter>options</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=5a8ac1b553b4ce7a64f94f1bf9604635 sig_cn_org=None source=14.1 
     <para>
      struct containing optional arguments
     </para>
________________________________________________________-->
     <para>
      包含可选参数的结构体
     </para>
<!-- pgdoc-cn_end sig_en=5a8ac1b553b4ce7a64f94f1bf9604635 -->
    </listitem>
   </varlistentry>
  </variablelist>

<!-- pgdoc-cn_start sig_en=507f26acb20bb94c84d36715775669fc sig_cn_org=None source=14.1 
  <para>
   Callers should always zero out the entire <parameter>options</parameter>
   struct, then fill whichever fields they want to set.  This ensures forward
   compatibility of code, since any fields that are added to the struct in
   future will be defined to behave backwards-compatibly if they are zero.
   The currently available <parameter>options</parameter> fields are:
  </para>
________________________________________________________-->
  <para>
   调用器将总是将整个<parameter>options</parameter>结构体归零，然后填充他们想设置的任何字段。
   这确保代码的向前兼容性，因为在未来添加到结构体中的任何字段将被定义成行为向后兼容，如果他们为零。
   当前有效的<parameter>options</parameter>字段为：
  </para>
<!-- pgdoc-cn_end sig_en=507f26acb20bb94c84d36715775669fc -->

  <variablelist>
   <varlistentry>
    <term><literal>ParserSetupHook <parameter>parserSetup</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=88013ec268c4bbcf5a7f9477dbc7044a sig_cn_org=None source=14.1 
     <para>
      Parser hook setup function
     </para>
________________________________________________________-->
     <para>
      语法分析器钩子设置函数
     </para>
<!-- pgdoc-cn_end sig_en=88013ec268c4bbcf5a7f9477dbc7044a -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>void * <parameter>parserSetupArg</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=56e4123941703d4346ba8f9a742713c4 sig_cn_org=None source=14.1 
     <para>
      pass-through argument for <parameter>parserSetup</parameter>
     </para>
________________________________________________________-->
     <para>
      对于 <parameter>parserSetup</parameter>的直通参数
     </para>
<!-- pgdoc-cn_end sig_en=56e4123941703d4346ba8f9a742713c4 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RawParseMode <parameter>parseMode</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=7fb6943dad31c565ca3719aa30233033 sig_cn_org=None source=14.1 
     <para>
      mode for raw parsing; <literal>RAW_PARSE_DEFAULT</literal> (zero)
      produces default behavior
     </para>
________________________________________________________-->
     <para>
      原始语法分析的模式；<literal>RAW_PARSE_DEFAULT</literal>（零）处理默认行为
     </para>
<!-- pgdoc-cn_end sig_en=7fb6943dad31c565ca3719aa30233033 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>cursorOptions</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=766a5ff7fb3a5c027fbe740c701e1d64 sig_cn_org=None source=14.1 
     <para>
      integer bit mask of cursor options; zero produces default behavior
     </para>
________________________________________________________-->
     <para>
      整数形式的游标选项位掩码，零会导致默认行为
     </para>
<!-- pgdoc-cn_end sig_en=766a5ff7fb3a5c027fbe740c701e1d64 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=16adfbb9bf7dfb126492ff4a12fff178 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_prepare_extended</function> has the same return conventions as
   <function>SPI_prepare</function>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_prepare_extended</function> 具有与<function>SPI_prepare</function>相同的返回约定。
  </para>
<!-- pgdoc-cn_end sig_en=16adfbb9bf7dfb126492ff4a12fff178 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-prepare-params">
<!-- pgdoc-cn_start sig_en=3b38b2c2a9e328dcea5398fa87898c7c sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_prepare_params</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_prepare_params</primary></indexterm>
<!-- pgdoc-cn_end sig_en=3b38b2c2a9e328dcea5398fa87898c7c -->

 <refmeta>
  <refentrytitle>SPI_prepare_params</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=ea1cc99f3bce889279696110eb7749d3 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_prepare_params</refname>
  <refpurpose>prepare a statement, without executing it yet</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_prepare_params</refname>
  <refpurpose>预备一个语句，但是不执行它</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=ea1cc99f3bce889279696110eb7749d3 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=406226dccbb965910912079674bdb8e1 sig_cn_org=None source=14.1 
<synopsis>
SPIPlanPtr SPI_prepare_params(const char * <parameter>command</parameter>,
                              ParserSetupHook <parameter>parserSetup</parameter>,
                              void * <parameter>parserSetupArg</parameter>,
                              int <parameter>cursorOptions</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
SPIPlanPtr SPI_prepare_params(const char * <parameter>command</parameter>,
                              ParserSetupHook <parameter>parserSetup</parameter>,
                              void * <parameter>parserSetupArg</parameter>,
                              int <parameter>cursorOptions</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=406226dccbb965910912079674bdb8e1 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=8caf4a074a73417b7b6ab7df26720457 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_prepare_params</function> creates and returns a prepared
   statement for the specified command, but doesn't execute the command.
   This function is equivalent to <function>SPI_prepare_cursor</function>,
   with the addition that the caller can specify parser hook functions
   to control the parsing of external parameter references.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_prepare_params</function>为指定的命令创建并
   返回一个预备语句，但是不执行该命令。这个函数等效于
   <function>SPI_prepare_cursor</function>，此外调用者可以指定
   解析器钩子函数来控制外部参数引用的解析。
  </para>
<!-- pgdoc-cn_end sig_en=8caf4a074a73417b7b6ab7df26720457 -->

<!-- pgdoc-cn_start sig_en=837c87f9b2f148c207276e7fbe0d40a4 sig_cn_org=None source=14.1 
  <para>
   This function is now deprecated in favor
   of <function>SPI_prepare_extended</function>.
  </para>
________________________________________________________-->
  <para>
   这个参数现在被弃用，用<function>SPI_prepare_extended</function>代替。
  </para>
<!-- pgdoc-cn_end sig_en=837c87f9b2f148c207276e7fbe0d40a4 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=a12067418fb7474b146adb5a862771c0 sig_cn_org=None source=14.1 
     <para>
      command string
     </para>
________________________________________________________-->
     <para>
      命令字符串
     </para>
<!-- pgdoc-cn_end sig_en=a12067418fb7474b146adb5a862771c0 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ParserSetupHook <parameter>parserSetup</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=88013ec268c4bbcf5a7f9477dbc7044a sig_cn_org=None source=14.1 
     <para>
      Parser hook setup function
     </para>
________________________________________________________-->
     <para>
      语法分析器钩子设置函数
     </para>
<!-- pgdoc-cn_end sig_en=88013ec268c4bbcf5a7f9477dbc7044a -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>void * <parameter>parserSetupArg</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=56e4123941703d4346ba8f9a742713c4 sig_cn_org=None source=14.1 
     <para>
      pass-through argument for <parameter>parserSetup</parameter>
     </para>
________________________________________________________-->
     <para>
      对于 <parameter>parserSetup</parameter>的直通参数
     </para>
<!-- pgdoc-cn_end sig_en=56e4123941703d4346ba8f9a742713c4 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>cursorOptions</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=766a5ff7fb3a5c027fbe740c701e1d64 sig_cn_org=None source=14.1 
     <para>
      integer bit mask of cursor options; zero produces default behavior
     </para>
________________________________________________________-->
     <para>
      整数形式的游标选项位掩码，零会导致默认行为
     </para>
<!-- pgdoc-cn_end sig_en=766a5ff7fb3a5c027fbe740c701e1d64 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=f0e8ffd98962ecea6389f97643c9327e sig_cn_org=None source=14.1 
  <para>
   <function>SPI_prepare_params</function> has the same return conventions as
   <function>SPI_prepare</function>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_prepare_params</function>具有和
   <function>SPI_prepare</function>相同的返回习惯。
  </para>
<!-- pgdoc-cn_end sig_en=f0e8ffd98962ecea6389f97643c9327e -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getargcount">
<!-- pgdoc-cn_start sig_en=ccf9e1dece77c2babfc65c36fadcf258 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_getargcount</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_getargcount</primary></indexterm>
<!-- pgdoc-cn_end sig_en=ccf9e1dece77c2babfc65c36fadcf258 -->

 <refmeta>
  <refentrytitle>SPI_getargcount</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=f48f7f84360353d833054e776c2b152d sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_getargcount</refname>
  <refpurpose>return the number of arguments needed by a statement
  prepared by <function>SPI_prepare</function></refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_getargcount</refname>
  <refpurpose>返回一个由<function>SPI_prepare</function>
  准备好的语句所需的参数数量</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=f48f7f84360353d833054e776c2b152d -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=466c785ce12be909bc4de878eb065d8b sig_cn_org=None source=14.1 
<synopsis>
int SPI_getargcount(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
int SPI_getargcount(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=466c785ce12be909bc4de878eb065d8b -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=41b37903ef42ee791f970a6964e287f2 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_getargcount</function> returns the number of arguments needed
   to execute a statement prepared by <function>SPI_prepare</function>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_getargcount</function>返回执行一个由
   <function>SPI_prepare</function>准备好的语句所需的参数数量。
  </para>
<!-- pgdoc-cn_end sig_en=41b37903ef42ee791f970a6964e287f2 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=7ba5ee24987a832e4009fbbc70894115 sig_cn_org=None source=14.1 
     <para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
________________________________________________________-->
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
<!-- pgdoc-cn_end sig_en=7ba5ee24987a832e4009fbbc70894115 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->
<!-- pgdoc-cn_start sig_en=71b0f3edbb933063e5c9a21740b965e6 sig_cn_org=None source=14.1 
  <para>
    The count of expected arguments for the <parameter>plan</parameter>.
    If the <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid,
    <varname>SPI_result</varname> is set to <symbol>SPI_ERROR_ARGUMENT</symbol>
    and -1 is returned.
  </para>
________________________________________________________-->
  <para>
    <parameter>plan</parameter>所期望的参数计数。如果该
    <parameter>plan</parameter>为<symbol>NULL</symbol>或者无效，
    <varname>SPI_result</varname>会被设置为<symbol>SPI_ERROR_ARGUMENT</symbol>
    并且返回 -1。
  </para>
<!-- pgdoc-cn_end sig_en=71b0f3edbb933063e5c9a21740b965e6 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getargtypeid">
<!-- pgdoc-cn_start sig_en=6431771ba255f3046e9908ad013daf64 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_getargtypeid</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_getargtypeid</primary></indexterm>
<!-- pgdoc-cn_end sig_en=6431771ba255f3046e9908ad013daf64 -->

 <refmeta>
  <refentrytitle>SPI_getargtypeid</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=cef36a7d9b1591a3fecd0bcd0686c258 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_getargtypeid</refname>
  <refpurpose>return the data type OID for an argument of
  a statement prepared by <function>SPI_prepare</function></refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_getargtypeid</refname>
  <refpurpose>为由<function>SPI_prepare</function>
  准备好的一个语句的一个参数返回其数据类型 OID</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=cef36a7d9b1591a3fecd0bcd0686c258 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=45522845d26990f74b908a52d588429e sig_cn_org=None source=14.1 
<synopsis>
Oid SPI_getargtypeid(SPIPlanPtr <parameter>plan</parameter>, int <parameter>argIndex</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
Oid SPI_getargtypeid(SPIPlanPtr <parameter>plan</parameter>, int <parameter>argIndex</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=45522845d26990f74b908a52d588429e -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=3cb84a7e551707b9c0eb2c7e4e743d1e sig_cn_org=None source=14.1 
  <para>
   <function>SPI_getargtypeid</function> returns the OID representing the type
   for the <parameter>argIndex</parameter>'th argument of a statement prepared by
   <function>SPI_prepare</function>. First argument is at index zero.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_getargtypeid</function>返回由
   <function>SPI_prepare</function>准备好的一个语句的
   第<parameter>argIndex</parameter>个参数的类型的 OID。
   第一个参数的索引为零。
  </para>
<!-- pgdoc-cn_end sig_en=3cb84a7e551707b9c0eb2c7e4e743d1e -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=7ba5ee24987a832e4009fbbc70894115 sig_cn_org=None source=14.1 
     <para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
________________________________________________________-->
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
<!-- pgdoc-cn_end sig_en=7ba5ee24987a832e4009fbbc70894115 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>argIndex</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=b9d580abbb75bcf4ae9c4b0a66e288b7 sig_cn_org=None source=14.1 
     <para>
      zero based index of the argument
     </para>
________________________________________________________-->
     <para>
      参数的索引，从零开始
     </para>
<!-- pgdoc-cn_end sig_en=b9d580abbb75bcf4ae9c4b0a66e288b7 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->
<!-- pgdoc-cn_start sig_en=6ce044c9d339d066a0fb0fb0f6674fb4 sig_cn_org=None source=14.1 
  <para>
    The type OID of the argument at the given index.
    If the <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid,
    or <parameter>argIndex</parameter> is less than 0 or
    not less than the number of arguments declared for the
    <parameter>plan</parameter>,
    <varname>SPI_result</varname> is set to <symbol>SPI_ERROR_ARGUMENT</symbol>
    and <symbol>InvalidOid</symbol> is returned.
  </para>
________________________________________________________-->
  <para>
    给定索引处的参数的类型 OID。如果该
    <parameter>plan</parameter>为<symbol>NULL</symbol>或者无效，
    或者<parameter>argIndex</parameter>小于零或者小于为
    <parameter>plan</parameter>声明的参数数量，
    <varname>SPI_result</varname>会被设置为
    <symbol>SPI_ERROR_ARGUMENT</symbol>并且将会返回
    <symbol>InvalidOid</symbol>。
  </para>
<!-- pgdoc-cn_end sig_en=6ce044c9d339d066a0fb0fb0f6674fb4 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-is-cursor-plan">
<!-- pgdoc-cn_start sig_en=dad68c659f1039ce4d0fcbe6209f3c12 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_is_cursor_plan</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_is_cursor_plan</primary></indexterm>
<!-- pgdoc-cn_end sig_en=dad68c659f1039ce4d0fcbe6209f3c12 -->

 <refmeta>
  <refentrytitle>SPI_is_cursor_plan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=a8bb8fe1d8b8e1b826a5182d28aee80d sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_is_cursor_plan</refname>
  <refpurpose>return <symbol>true</symbol> if a statement
  prepared by <function>SPI_prepare</function> can be used with
  <function>SPI_cursor_open</function></refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_is_cursor_plan</refname>
  <refpurpose>如果一个由<function>SPI_prepare</function>预备好
  的语句可以用于<function>SPI_cursor_open</function>则返回
  <symbol>true</symbol></refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=a8bb8fe1d8b8e1b826a5182d28aee80d -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=ab23ceb10d48fa2de55b72c2c1d757db sig_cn_org=None source=14.1 
<synopsis>
bool SPI_is_cursor_plan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
bool SPI_is_cursor_plan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=ab23ceb10d48fa2de55b72c2c1d757db -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=2a9704cc30aa204d65733f0fd1e077fd sig_cn_org=None source=14.1 
  <para>
   <function>SPI_is_cursor_plan</function> returns <symbol>true</symbol>
   if a statement prepared by <function>SPI_prepare</function> can be passed
   as an argument to <function>SPI_cursor_open</function>, or
   <symbol>false</symbol> if that is not the case. The criteria are that the
   <parameter>plan</parameter> represents one single command and that this
   command returns tuples to the caller; for example, <command>SELECT</command>
   is allowed unless it contains an <literal>INTO</literal> clause, and
   <command>UPDATE</command> is allowed only if it contains a <literal>RETURNING</literal>
   clause.
  </para>
________________________________________________________-->
  <para>
   如果一个由<function>SPI_prepare</function>预备好
   的语句可以被作为一个参数传递给<function>SPI_cursor_open</function>，
   <function>SPI_is_cursor_plan</function>会返回<symbol>true</symbol>。
   否则返回<symbol>false</symbol>。原则是该
   <parameter>plan</parameter>表示一个单一命令并且这个命令向其调用者
   返回元组。例如，只要不含<literal>INTO</literal>子句，<command>SELECT</command>
   就被允许，而只有包含一个<literal>RETURNING</literal>子句时才允许
   <command>UPDATE</command>。
  </para>
<!-- pgdoc-cn_end sig_en=2a9704cc30aa204d65733f0fd1e077fd -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=7ba5ee24987a832e4009fbbc70894115 sig_cn_org=None source=14.1 
     <para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
________________________________________________________-->
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
<!-- pgdoc-cn_end sig_en=7ba5ee24987a832e4009fbbc70894115 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->
<!-- pgdoc-cn_start sig_en=95e67e31dac6db675ec6cd2b3bd2579e sig_cn_org=None source=14.1 
  <para>
    <symbol>true</symbol> or <symbol>false</symbol> to indicate if the
    <parameter>plan</parameter> can produce a cursor or not, with
    <varname>SPI_result</varname> set to zero.
    If it is not possible to determine the answer (for example,
    if the <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid,
    or if called when not connected to SPI), then
    <varname>SPI_result</varname> is set to a suitable error code
    and <symbol>false</symbol> is returned.
  </para>
________________________________________________________-->
  <para>
    如果该<parameter>plan</parameter>能产生一个游标则返回
    <symbol>true</symbol>，否则返回<symbol>false</symbol>
    并且把<varname>SPI_result</varname>设置为零。如果不可能决定答案
    （例如，如果<parameter>plan</parameter>为
    <symbol>NULL</symbol>或无效，或者在没有连接到 SPI 时调用），
    那么<varname>SPI_result</varname>会被设置为一个合适的错误码
    并且返回<symbol>false</symbol>。
  </para>
<!-- pgdoc-cn_end sig_en=95e67e31dac6db675ec6cd2b3bd2579e -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute-plan">
<!-- pgdoc-cn_start sig_en=915a25d7a2b20fb5d712c21067155636 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_execute_plan</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_execute_plan</primary></indexterm>
<!-- pgdoc-cn_end sig_en=915a25d7a2b20fb5d712c21067155636 -->

 <refmeta>
  <refentrytitle>SPI_execute_plan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=c328e86fefed522fb9d13989a224b4f9 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_execute_plan</refname>
  <refpurpose>execute a statement prepared by <function>SPI_prepare</function></refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_execute_plan</refname>
  <refpurpose>执行一个由<function>SPI_prepare</function>预备好的语句</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=c328e86fefed522fb9d13989a224b4f9 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=02306039dd46c9638093af8af7618e22 sig_cn_org=None source=14.1 
<synopsis>
int SPI_execute_plan(SPIPlanPtr <parameter>plan</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>,
                     bool <parameter>read_only</parameter>, long <parameter>count</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
int SPI_execute_plan(SPIPlanPtr <parameter>plan</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>,
                     bool <parameter>read_only</parameter>, long <parameter>count</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=02306039dd46c9638093af8af7618e22 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=c30eac20bc5b20c4407096bee0f2d01f sig_cn_org=None source=14.1 
  <para>
   <function>SPI_execute_plan</function> executes a statement prepared by
   <function>SPI_prepare</function> or one of its siblings.
   <parameter>read_only</parameter> and
   <parameter>count</parameter> have the same interpretation as in
   <function>SPI_execute</function>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_execute_plan</function>执行一个由
   <function>SPI_prepare</function>或其同类方法准备好的语句。
   <parameter>read_only</parameter>和 and
   <parameter>count</parameter>的解释和
   <function>SPI_execute</function>中相同。
  </para>
<!-- pgdoc-cn_end sig_en=c30eac20bc5b20c4407096bee0f2d01f -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=7ba5ee24987a832e4009fbbc70894115 sig_cn_org=None source=14.1 
     <para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
________________________________________________________-->
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
<!-- pgdoc-cn_end sig_en=7ba5ee24987a832e4009fbbc70894115 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=5f4cdb269d747b20f3d1537c409e6d1b sig_cn_org=None source=14.1 
     <para>
      An array of actual parameter values.  Must have same length as the
      statement's number of arguments.
     </para>
________________________________________________________-->
     <para>
      一个实际参数值的数组。必须和语句的参数数量等长。
     </para>
<!-- pgdoc-cn_end sig_en=5f4cdb269d747b20f3d1537c409e6d1b -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=354089203667d6b8af55f58ddebe428b sig_cn_org=None source=14.1 
     <para>
      An array describing which parameters are null.  Must have same length as
      the statement's number of arguments.
     </para>
________________________________________________________-->
     <para>
      一个描述哪些参数为空值的数组。必须和语句的参数数量等长。
     </para>
<!-- pgdoc-cn_end sig_en=354089203667d6b8af55f58ddebe428b -->

<!-- pgdoc-cn_start sig_en=f0682b4d1b129f03698cba8aafe0be83 sig_cn_org=None source=14.1 
     <para>
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_execute_plan</function> assumes that no parameters
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</literal> if the corresponding parameter
      value is non-null, or <literal>'n'</literal> if the corresponding parameter
      value is null.  (In the latter case, the actual value in the
      corresponding <parameter>values</parameter> entry doesn't matter.)  Note
      that <parameter>nulls</parameter> is not a text string, just an array:
      it does not need a <literal>'\0'</literal> terminator.
     </para>
________________________________________________________-->
     <para>
      如果<parameter>nulls</parameter>为<symbol>NULL</symbol>，
      那么<function>SPI_execute_plan</function>会假设没有参数
      为空值。否则，如果对应的参数值为非空，
      <parameter>nulls</parameter>
      数组的每一个项都应该是<literal>'&nbsp;'</literal>；如果对应参数值为空，
      <parameter>nulls</parameter>数组的项应为<literal>'n'</literal>（在后
      面的情况中，对应的<parameter>values</parameter>项中的值没有
      关系）。注意<parameter>nulls</parameter>不是一个文本字符串，
      它只是一个数组：它不需要一个<literal>'\0'</literal>终止符。
     </para>
<!-- pgdoc-cn_end sig_en=f0682b4d1b129f03698cba8aafe0be83 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=b4631d77e109c42543b5ede7350ea3c6 sig_cn_org=None source=14.1 
     <para><literal>true</literal> for read-only execution</para>
________________________________________________________-->
     <para>对只读执行为<literal>true</literal></para>
<!-- pgdoc-cn_end sig_en=b4631d77e109c42543b5ede7350ea3c6 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=40ca4421fc90d088c0476e49929d6da0 sig_cn_org=None source=14.1 
     <para>
      maximum number of rows to return,
      or <literal>0</literal> for no limit
     </para>
________________________________________________________-->
     <para>
      要返回的最大行数，或者用<literal>0</literal>表示没有限制
     </para>
<!-- pgdoc-cn_end sig_en=40ca4421fc90d088c0476e49929d6da0 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=8ed3378ff49e09f5cec9d3f8e3b30db5 sig_cn_org=None source=14.1 
  <para>
   The return value is the same as for <function>SPI_execute</function>,
   with the following additional possible error (negative) results:

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       if <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid,
       or <parameter>count</parameter> is less than 0
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_PARAM</symbol></term>
     <listitem>
      <para>
       if <parameter>values</parameter> is <symbol>NULL</symbol> and
       <parameter>plan</parameter> was prepared with some parameters
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   返回值和<function>SPI_execute</function>相同，
   还有下列额外可能的错误（负值）结果：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       如果<parameter>plan</parameter>为<symbol>NULL</symbol>
       或者非法，或者<parameter>count</parameter>小于 0
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_PARAM</symbol></term>
     <listitem>
      <para>
       如果<parameter>values</parameter>为<symbol>NULL</symbol>但是
       <parameter>plan</parameter>被准备时用了一些参数
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=8ed3378ff49e09f5cec9d3f8e3b30db5 -->

<!-- pgdoc-cn_start sig_en=f501eb9c4097f782a68f87c3eed6fb6e sig_cn_org=None source=14.1 
  <para>
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute</function> if successful.
  </para>
________________________________________________________-->
  <para>
   如果成功<function>SPI_execute</function>会设置
   <varname>SPI_processed</varname>和
   <varname>SPI_tuptable</varname>。
  </para>
<!-- pgdoc-cn_end sig_en=f501eb9c4097f782a68f87c3eed6fb6e -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute-plan-extended">
<!-- pgdoc-cn_start sig_en=cade253ffed88d4353763d6fdcac27a8 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_execute_plan_extended</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_execute_plan_extended</primary></indexterm>
<!-- pgdoc-cn_end sig_en=cade253ffed88d4353763d6fdcac27a8 -->

 <refmeta>
  <refentrytitle>SPI_execute_plan_extended</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=15d2449f4ab19f70c51a651ab95215a6 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_execute_plan_extended</refname>
  <refpurpose>execute a statement prepared by <function>SPI_prepare</function></refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_execute_plan_extended</refname>
  <refpurpose>执行一个由<function>SPI_prepare</function>准备的语句</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=15d2449f4ab19f70c51a651ab95215a6 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=731a6d8352f14656978dd080e5400ecb sig_cn_org=None source=14.1 
<synopsis>
int SPI_execute_plan_extended(SPIPlanPtr <parameter>plan</parameter>,
                              const SPIExecuteOptions * <parameter>options</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
int SPI_execute_plan_extended(SPIPlanPtr <parameter>plan</parameter>,
                              const SPIExecuteOptions * <parameter>options</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=731a6d8352f14656978dd080e5400ecb -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=a02b3a77befb9e1d16bb26715fea8be5 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_execute_plan_extended</function> executes a statement
   prepared by <function>SPI_prepare</function> or one of its siblings.
   This function is equivalent to <function>SPI_execute_plan</function>,
   except that information about the parameter values to be passed to the
   query is presented differently, and additional execution-controlling
   options can be passed.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_execute_plan_extended</function> 执行一个由<function>SPI_prepare</function>或它的一个同类所准备的语句。
   这个函数等同于<function>SPI_execute_plan</function>，除了传递到查询的参数值的信息表现不同，并且可以传递附加的执行控制选项。
  </para>
<!-- pgdoc-cn_end sig_en=a02b3a77befb9e1d16bb26715fea8be5 -->

<!-- pgdoc-cn_start sig_en=cb7517615ab8d82de83860df8b4f6ed4 sig_cn_org=None source=14.1 
  <para>
   Query parameter values are represented by
   a <literal>ParamListInfo</literal> struct, which is convenient for passing
   down values that are already available in that format.  Dynamic parameter
   sets can also be used, via hook functions specified
   in <literal>ParamListInfo</literal>.
  </para>
________________________________________________________-->
  <para>
   查询参数值由<literal>ParamListInfo</literal>结构体表示，便于继承已经按那种格式生效的值。
   动态参数设置也可以使用，通过指定的钩子函数。
  </para>
<!-- pgdoc-cn_end sig_en=cb7517615ab8d82de83860df8b4f6ed4 -->

<!-- pgdoc-cn_start sig_en=f34083950c8061583a187436d785118a sig_cn_org=None source=14.1 
  <para>
   Also, instead of always accumulating the result tuples into a
   <varname>SPI_tuptable</varname> structure, tuples can be passed to a
   caller-supplied <literal>DestReceiver</literal> object as they are
   generated by the executor.  This is particularly helpful for queries
   that might generate many tuples, since the data can be processed
   on-the-fly instead of being accumulated in memory.
  </para>
________________________________________________________-->
  <para>
   而且，与总是累积结果元组到<varname>SPI_tuptable</varname>结构不同，元组可以传递到调用器支持的<literal>DestReceiver</literal>对象，就像他们被执行器产生的那样。
   这个对可能产生多个元组的铲鲟特别有帮助，因为数据可以在运行中处理而不是积累在内存中。
  </para>
<!-- pgdoc-cn_end sig_en=f34083950c8061583a187436d785118a -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=7ba5ee24987a832e4009fbbc70894115 sig_cn_org=None source=14.1 
     <para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
________________________________________________________-->
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
<!-- pgdoc-cn_end sig_en=7ba5ee24987a832e4009fbbc70894115 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const SPIExecuteOptions * <parameter>options</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=5a8ac1b553b4ce7a64f94f1bf9604635 sig_cn_org=None source=14.1 
     <para>
      struct containing optional arguments
     </para>
________________________________________________________-->
     <para>
      包含可选参数的结构体
     </para>
<!-- pgdoc-cn_end sig_en=5a8ac1b553b4ce7a64f94f1bf9604635 -->
    </listitem>
   </varlistentry>
  </variablelist>

<!-- pgdoc-cn_start sig_en=507f26acb20bb94c84d36715775669fc sig_cn_org=None source=14.1 
  <para>
   Callers should always zero out the entire <parameter>options</parameter>
   struct, then fill whichever fields they want to set.  This ensures forward
   compatibility of code, since any fields that are added to the struct in
   future will be defined to behave backwards-compatibly if they are zero.
   The currently available <parameter>options</parameter> fields are:
  </para>
________________________________________________________-->
  <para>
   调用器将总是将整个<parameter>options</parameter>结构体归零，然后填充他们想设置的任何字段。
   这确保代码的向前兼容性，因为在未来添加到结构体中的任何字段将被定义成行为向后兼容，如果他们为零。
   当前有效的<parameter>options</parameter>字段为：
  </para>
<!-- pgdoc-cn_end sig_en=507f26acb20bb94c84d36715775669fc -->

  <variablelist>
   <varlistentry>
    <term><literal>ParamListInfo <parameter>params</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=d463c39cdaff23f00b44fef84727bd66 sig_cn_org=None source=14.1 
     <para>
      data structure containing query parameter types and values; NULL if none
     </para>
________________________________________________________-->
     <para>
      包含查询参数类型和值的数据结构；没有则为NULL
     </para>
<!-- pgdoc-cn_end sig_en=d463c39cdaff23f00b44fef84727bd66 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=b4631d77e109c42543b5ede7350ea3c6 sig_cn_org=None source=14.1 
     <para><literal>true</literal> for read-only execution</para>
________________________________________________________-->
     <para>对只读执行为<literal>true</literal></para>
<!-- pgdoc-cn_end sig_en=b4631d77e109c42543b5ede7350ea3c6 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>allow_nonatomic</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=6ecdf023cae3b289793e459472f9d5a9 sig_cn_org=None source=14.1 
     <para>
      <literal>true</literal> allows non-atomic execution of CALL and DO
      statements
     </para>
________________________________________________________-->
     <para>
      <literal>true</literal> 允许CALL和DO语句的非原子执行。
     </para>
<!-- pgdoc-cn_end sig_en=6ecdf023cae3b289793e459472f9d5a9 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>must_return_tuples</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=426f037fdd895a60e99b16c93e37b151 sig_cn_org=None source=14.1 
     <para>
      if <literal>true</literal>, raise error if the query is not of a kind
      that returns tuples (this does not forbid the case where it happens to
      return zero tuples)
     </para>
________________________________________________________-->
     <para>
      如果为<literal>true</literal>，如果查询不是一种返回元组时抛出错误(这不禁止发生返回零元组的情况) 
     </para>
<!-- pgdoc-cn_end sig_en=426f037fdd895a60e99b16c93e37b151 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>uint64 <parameter>tcount</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=40ca4421fc90d088c0476e49929d6da0 sig_cn_org=None source=14.1 
     <para>
      maximum number of rows to return,
      or <literal>0</literal> for no limit
     </para>
________________________________________________________-->
     <para>
      要返回的最大行数，或者用<literal>0</literal>表示没有限制
     </para>
<!-- pgdoc-cn_end sig_en=40ca4421fc90d088c0476e49929d6da0 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DestReceiver * <parameter>dest</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=0167eec1ab881f13eeec8d16d0ce2bcd sig_cn_org=None source=14.1 
     <para>
      <literal>DestReceiver</literal> object that will receive any tuples
      emitted by the query; if NULL, result tuples are accumulated into
      a <varname>SPI_tuptable</varname> structure, as
      in <function>SPI_execute_plan</function>
     </para>
________________________________________________________-->
     <para>
      <literal>DestReceiver</literal> 对象将接收查询发出的任何元组；如果为NULL，结果元组积累到<varname>SPI_tuptable</varname>结构之中，就像在<function>SPI_execute_plan</function>中一样。
     </para>
<!-- pgdoc-cn_end sig_en=0167eec1ab881f13eeec8d16d0ce2bcd -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ResourceOwner <parameter>owner</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=39aea4bfb2234cf8d312557b4d0199db sig_cn_org=None source=14.1 
     <para>
      The resource owner that will hold a reference count on the plan while
      it is executed.  If NULL, CurrentResourceOwner is used.  Ignored for
      non-saved plans, as SPI does not acquire reference counts on those.
     </para>
________________________________________________________-->
     <para>
      资源的所有者，将在执行时持有计划上的引用计数。
      忽略不保存的计划，就像SPI不获取他们的引用计数。
     </para>
<!-- pgdoc-cn_end sig_en=39aea4bfb2234cf8d312557b4d0199db -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=b682c139b2294c1a07daab4e9e297483 sig_cn_org=None source=14.1 
  <para>
   The return value is the same as for <function>SPI_execute_plan</function>.
  </para>
________________________________________________________-->
  <para>
   返回值与<function>SPI_execute_plan</function>一样。
  </para>
<!-- pgdoc-cn_end sig_en=b682c139b2294c1a07daab4e9e297483 -->

<!-- pgdoc-cn_start sig_en=6adeeca69e6fc553e8eee488e39d186e sig_cn_org=None source=14.1 
  <para>
   When <parameter>options-&gt;dest</parameter> is NULL,
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute_plan</function>.
   When <parameter>options-&gt;dest</parameter> is not NULL,
   <varname>SPI_processed</varname> is set to zero and
   <varname>SPI_tuptable</varname> is set to NULL.  If a tuple count
   is required, the caller's <literal>DestReceiver</literal> object must
   calculate it.
  </para>
________________________________________________________-->
  <para>
   当 <parameter>options-&gt;dest</parameter> 为 NULL时，<varname>SPI_processed</varname> 和 <varname>SPI_tuptable</varname> 在<function>SPI_execute_plan</function>中设定。
   当 <parameter>options-&gt;dest</parameter> 不为 NULL时，<varname>SPI_processed</varname> 被设定为零，而且<varname>SPI_tuptable</varname> 被设定为 NULL。
   如果需要元组计数，调用器的<literal>DestReceiver</literal>对象必须计算它。
  </para>
<!-- pgdoc-cn_end sig_en=6adeeca69e6fc553e8eee488e39d186e -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execute-plan-with-paramlist">
<!-- pgdoc-cn_start sig_en=4a6ba86cbadb3db5f9b9be513469868b sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_execute_plan_with_paramlist</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_execute_plan_with_paramlist</primary></indexterm>
<!-- pgdoc-cn_end sig_en=4a6ba86cbadb3db5f9b9be513469868b -->

 <refmeta>
  <refentrytitle>SPI_execute_plan_with_paramlist</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=641e2b82a23a2901b51e4ac1f17136dd sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_execute_plan_with_paramlist</refname>
  <refpurpose>execute a statement prepared by <function>SPI_prepare</function></refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_execute_plan_with_paramlist</refname>
  <refpurpose>执行一个由<function>SPI_prepare</function>预备好的语句</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=641e2b82a23a2901b51e4ac1f17136dd -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=f67a1447d84f151d58e04b8449ee0d50 sig_cn_org=None source=14.1 
<synopsis>
int SPI_execute_plan_with_paramlist(SPIPlanPtr <parameter>plan</parameter>,
                                    ParamListInfo <parameter>params</parameter>,
                                    bool <parameter>read_only</parameter>,
                                    long <parameter>count</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
int SPI_execute_plan_with_paramlist(SPIPlanPtr <parameter>plan</parameter>,
                                    ParamListInfo <parameter>params</parameter>,
                                    bool <parameter>read_only</parameter>,
                                    long <parameter>count</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=f67a1447d84f151d58e04b8449ee0d50 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=e0cd99c91573a8b3ab911b30a3f9fc09 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_execute_plan_with_paramlist</function> executes a statement
   prepared by <function>SPI_prepare</function>.
   This function is equivalent to <function>SPI_execute_plan</function>
   except that information about the parameter values to be passed to the
   query is presented differently.  The <literal>ParamListInfo</literal>
   representation can be convenient for passing down values that are
   already available in that format.  It also supports use of dynamic
   parameter sets via hook functions specified in <literal>ParamListInfo</literal>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_execute_plan_with_paramlist</function>执行一个由
   <function>SPI_prepare</function>准备好的语句。这个函数与
   <function>SPI_execute_plan</function>等效，不过被传递给该查询
   的参数值的信息以不同的方式呈现。<literal>ParamListInfo</literal>表现形
   式更方便于把这种格式的值向下传递。它也支持通过
   <literal>ParamListInfo</literal>中指定的钩子函数动态设置参数。
  </para>
<!-- pgdoc-cn_end sig_en=e0cd99c91573a8b3ab911b30a3f9fc09 -->

<!-- pgdoc-cn_start sig_en=75a3676844f2a2738feb8860e2a75856 sig_cn_org=None source=14.1 
  <para>
   This function is now deprecated in favor
   of <function>SPI_execute_plan_extended</function>.
  </para>
________________________________________________________-->
  <para>
   这个函数现在废弃了，由<function>SPI_execute_plan_extended</function>代替。
  </para>
<!-- pgdoc-cn_end sig_en=75a3676844f2a2738feb8860e2a75856 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=7ba5ee24987a832e4009fbbc70894115 sig_cn_org=None source=14.1 
     <para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
________________________________________________________-->
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
<!-- pgdoc-cn_end sig_en=7ba5ee24987a832e4009fbbc70894115 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ParamListInfo <parameter>params</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=938aa30503bb886a3b5a13f3696a810e sig_cn_org=None source=14.1 
     <para>
      data structure containing parameter types and values; NULL if none
     </para>
________________________________________________________-->
     <para>
      包含参数类型和值的数据结构，如果没有则为 NULL
     </para>
<!-- pgdoc-cn_end sig_en=938aa30503bb886a3b5a13f3696a810e -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=b4631d77e109c42543b5ede7350ea3c6 sig_cn_org=None source=14.1 
     <para><literal>true</literal> for read-only execution</para>
________________________________________________________-->
     <para>对只读执行为<literal>true</literal></para>
<!-- pgdoc-cn_end sig_en=b4631d77e109c42543b5ede7350ea3c6 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=40ca4421fc90d088c0476e49929d6da0 sig_cn_org=None source=14.1 
     <para>
      maximum number of rows to return,
      or <literal>0</literal> for no limit
     </para>
________________________________________________________-->
     <para>
      要返回的最大行数，或者用<literal>0</literal>表示没有限制
     </para>
<!-- pgdoc-cn_end sig_en=40ca4421fc90d088c0476e49929d6da0 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=b682c139b2294c1a07daab4e9e297483 sig_cn_org=None source=14.1 
  <para>
   The return value is the same as for <function>SPI_execute_plan</function>.
  </para>
________________________________________________________-->
  <para>
   返回值与<function>SPI_execute_plan</function>一样。
  </para>
<!-- pgdoc-cn_end sig_en=b682c139b2294c1a07daab4e9e297483 -->

<!-- pgdoc-cn_start sig_en=96983b6ed7e16ef15ec3282bc0076296 sig_cn_org=None source=14.1 
  <para>
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute_plan</function> if successful.
  </para>
________________________________________________________-->
  <para>
   成功时，在<function>SPI_execute_plan</function>中会设置
   <varname>SPI_processed</varname>和
   <varname>SPI_tuptable</varname>。
  </para>
<!-- pgdoc-cn_end sig_en=96983b6ed7e16ef15ec3282bc0076296 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-execp">
<!-- pgdoc-cn_start sig_en=a4d6a8274efe6a7cecc8c27f9b5e2317 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_execp</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_execp</primary></indexterm>
<!-- pgdoc-cn_end sig_en=a4d6a8274efe6a7cecc8c27f9b5e2317 -->

 <refmeta>
  <refentrytitle>SPI_execp</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=627f860add388b8c032a5bc3d1e891da sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_execp</refname>
  <refpurpose>execute a statement in read/write mode</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_execp</refname>
  <refpurpose>以读/写模式执行一个语句</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=627f860add388b8c032a5bc3d1e891da -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=a8b552955e1051a621dfd3c307800e23 sig_cn_org=None source=14.1 
<synopsis>
int SPI_execp(SPIPlanPtr <parameter>plan</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>, long <parameter>count</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
int SPI_execp(SPIPlanPtr <parameter>plan</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>, long <parameter>count</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=a8b552955e1051a621dfd3c307800e23 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=41a112d36c196f66cf766ea4c171dfb2 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_execp</function> is the same as
   <function>SPI_execute_plan</function>, with the latter's
   <parameter>read_only</parameter> parameter always taken as
   <literal>false</literal>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_execp</function>与
   <function>SPI_execute_plan</function>相同，不过后者的
   <parameter>read_only</parameter>参数总是取<literal>false</literal>。
  </para>
<!-- pgdoc-cn_end sig_en=41a112d36c196f66cf766ea4c171dfb2 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=7ba5ee24987a832e4009fbbc70894115 sig_cn_org=None source=14.1 
     <para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
________________________________________________________-->
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
<!-- pgdoc-cn_end sig_en=7ba5ee24987a832e4009fbbc70894115 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=5f4cdb269d747b20f3d1537c409e6d1b sig_cn_org=None source=14.1 
     <para>
      An array of actual parameter values.  Must have same length as the
      statement's number of arguments.
     </para>
________________________________________________________-->
     <para>
      一个实际参数值的数组。必须和语句的参数数量等长。
     </para>
<!-- pgdoc-cn_end sig_en=5f4cdb269d747b20f3d1537c409e6d1b -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=354089203667d6b8af55f58ddebe428b sig_cn_org=None source=14.1 
     <para>
      An array describing which parameters are null.  Must have same length as
      the statement's number of arguments.
     </para>
________________________________________________________-->
     <para>
      一个描述哪些参数为空值的数组。必须和语句的参数数量等长。
     </para>
<!-- pgdoc-cn_end sig_en=354089203667d6b8af55f58ddebe428b -->

<!-- pgdoc-cn_start sig_en=98f06a90da237f754da6a32e4d1399dc sig_cn_org=None source=14.1 
     <para>
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_execp</function> assumes that no parameters
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</literal> if the corresponding parameter
      value is non-null, or <literal>'n'</literal> if the corresponding parameter
      value is null.  (In the latter case, the actual value in the
      corresponding <parameter>values</parameter> entry doesn't matter.)  Note
      that <parameter>nulls</parameter> is not a text string, just an array:
      it does not need a <literal>'\0'</literal> terminator.
     </para>
________________________________________________________-->
     <para>
      如果<parameter>nulls</parameter>为<symbol>NULL</symbol>，
      那么<function>SPI_execp</function>会假设没有参数
      为空值。否则，如果对应的参数值为非空，
      <parameter>nulls</parameter>
      数组的每一个项都应该是<literal>'&nbsp;'</literal>；如果对应参数值为空，
      <parameter>nulls</parameter>数组的项应为<literal>'n'</literal>（在后
      面的情况中，对应的<parameter>values</parameter>项中的值没有
      关系）。注意<parameter>nulls</parameter>不是一个文本字符串，
      它只是一个数组：它不需要一个<literal>'\0'</literal>终止符。
     </para>
<!-- pgdoc-cn_end sig_en=98f06a90da237f754da6a32e4d1399dc -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=40ca4421fc90d088c0476e49929d6da0 sig_cn_org=None source=14.1 
     <para>
      maximum number of rows to return,
      or <literal>0</literal> for no limit
     </para>
________________________________________________________-->
     <para>
      要返回的最大行数，或者用<literal>0</literal>表示没有限制
     </para>
<!-- pgdoc-cn_end sig_en=40ca4421fc90d088c0476e49929d6da0 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=d4c75f2f6ab86f9a25aeacb49de08b68 sig_cn_org=None source=14.1 
  <para>
   See <function>SPI_execute_plan</function>.
  </para>
________________________________________________________-->
  <para>
   见<function>SPI_execute_plan</function>。
  </para>
<!-- pgdoc-cn_end sig_en=d4c75f2f6ab86f9a25aeacb49de08b68 -->

<!-- pgdoc-cn_start sig_en=f501eb9c4097f782a68f87c3eed6fb6e sig_cn_org=None source=14.1 
  <para>
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute</function> if successful.
  </para>
________________________________________________________-->
  <para>
   如果成功<function>SPI_execute</function>会设置
   <varname>SPI_processed</varname>和
   <varname>SPI_tuptable</varname>。
  </para>
<!-- pgdoc-cn_end sig_en=f501eb9c4097f782a68f87c3eed6fb6e -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-open">
<!-- pgdoc-cn_start sig_en=03fb7a3d11ca7adce3e0a00d4f808b1c sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_cursor_open</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_cursor_open</primary></indexterm>
<!-- pgdoc-cn_end sig_en=03fb7a3d11ca7adce3e0a00d4f808b1c -->

 <refmeta>
  <refentrytitle>SPI_cursor_open</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=a1c910ad12cf78672070310d911dea7e sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_cursor_open</refname>
  <refpurpose>set up a cursor using a statement created with <function>SPI_prepare</function></refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_cursor_open</refname>
  <refpurpose>使用由<function>SPI_prepare</function>创建的
  语句建立一个游标</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=a1c910ad12cf78672070310d911dea7e -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=5cf7713690b310271771ae0086eee032 sig_cn_org=None source=14.1 
<synopsis>
Portal SPI_cursor_open(const char * <parameter>name</parameter>, SPIPlanPtr <parameter>plan</parameter>,
                       Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>,
                       bool <parameter>read_only</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
Portal SPI_cursor_open(const char * <parameter>name</parameter>, SPIPlanPtr <parameter>plan</parameter>,
                       Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>,
                       bool <parameter>read_only</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=5cf7713690b310271771ae0086eee032 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=c8143ddd5e4e11f304cdd886e11fe526 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_cursor_open</function> sets up a cursor (internally,
   a portal) that will execute a statement prepared by
   <function>SPI_prepare</function>.  The parameters have the same
   meanings as the corresponding parameters to
   <function>SPI_execute_plan</function>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_cursor_open</function>建立一个游标（在内部是一个
   portal），该游标将执行由<function>SPI_prepare</function>准备好
   的一个语句。参数具有和<function>SPI_execute_plan</function>的
   相应参数相同的含义。
  </para>
<!-- pgdoc-cn_end sig_en=c8143ddd5e4e11f304cdd886e11fe526 -->

<!-- pgdoc-cn_start sig_en=1307698be23eaac933ace5319b2c331e sig_cn_org=None source=14.1 
  <para>
   Using a cursor instead of executing the statement directly has two
   benefits.  First, the result rows can be retrieved a few at a time,
   avoiding memory overrun for queries that return many rows.  Second,
   a portal can outlive the current C function (it can, in fact, live
   to the end of the current transaction).  Returning the portal name
   to the C function's caller provides a way of returning a row set as
   result.
  </para>
________________________________________________________-->
  <para>
   使用一个游标而不是直接执行该语句有两个好处。首先，可以一次只取出
   一些结果行，避免为返回很多行的查询过度使用内存。其次，一个 portal
   可以比当前的C函数生存更长时间（事实上，它可以生存到当前事务结束）。
   把 portal 的名称返回给该C函数的调用者提供了一种将一个行集合返回为结
   果的方法。
  </para>
<!-- pgdoc-cn_end sig_en=1307698be23eaac933ace5319b2c331e -->

<!-- pgdoc-cn_start sig_en=d2c07c31203a7a6bad1dc70579af42a5 sig_cn_org=None source=14.1 
  <para>
   The passed-in parameter data will be copied into the cursor's portal, so it
   can be freed while the cursor still exists.
  </para>
________________________________________________________-->
  <para>
   被传入的参数数据将被复制到游标的 portal 中，因此在该游标仍然存在时
   可以释放掉被传入的参数数据。
  </para>
<!-- pgdoc-cn_end sig_en=d2c07c31203a7a6bad1dc70579af42a5 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=25f914487d3cb3bbad4c3fe21739285a sig_cn_org=None source=14.1 
     <para>
      name for portal, or <symbol>NULL</symbol> to let the system
      select a name
     </para>
________________________________________________________-->
     <para>
      portal 的名字，或者设置成<symbol>NULL</symbol>
      让系统选择一个名称
     </para>
<!-- pgdoc-cn_end sig_en=25f914487d3cb3bbad4c3fe21739285a -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=7ba5ee24987a832e4009fbbc70894115 sig_cn_org=None source=14.1 
     <para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
________________________________________________________-->
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
<!-- pgdoc-cn_end sig_en=7ba5ee24987a832e4009fbbc70894115 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=5f4cdb269d747b20f3d1537c409e6d1b sig_cn_org=None source=14.1 
     <para>
      An array of actual parameter values.  Must have same length as the
      statement's number of arguments.
     </para>
________________________________________________________-->
     <para>
      一个实际参数值的数组。必须和语句的参数数量等长。
     </para>
<!-- pgdoc-cn_end sig_en=5f4cdb269d747b20f3d1537c409e6d1b -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=354089203667d6b8af55f58ddebe428b sig_cn_org=None source=14.1 
     <para>
      An array describing which parameters are null.  Must have same length as
      the statement's number of arguments.
     </para>
________________________________________________________-->
     <para>
      一个描述哪些参数为空值的数组。必须和语句的参数数量等长。
     </para>
<!-- pgdoc-cn_end sig_en=354089203667d6b8af55f58ddebe428b -->

<!-- pgdoc-cn_start sig_en=962653668c7d79f165caa0317f7975fc sig_cn_org=None source=14.1 
     <para>
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_cursor_open</function> assumes that no parameters
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</literal> if the corresponding parameter
      value is non-null, or <literal>'n'</literal> if the corresponding parameter
      value is null.  (In the latter case, the actual value in the
      corresponding <parameter>values</parameter> entry doesn't matter.)  Note
      that <parameter>nulls</parameter> is not a text string, just an array:
      it does not need a <literal>'\0'</literal> terminator.
     </para>
________________________________________________________-->
     <para>
      如果<parameter>nulls</parameter>为<symbol>NULL</symbol>，
      那么<function>SPI_cursor_open</function>会假设没有参数
      为空值。否则，如果对应的参数值为非空，
      <parameter>nulls</parameter>
      数组的每一个项都应该是<literal>'&nbsp;'</literal>；如果对应参数值为空，
      <parameter>nulls</parameter>数组的项应为<literal>'n'</literal>（在后
      面的情况中，对应的<parameter>values</parameter>项中的值没有
      关系）。注意<parameter>nulls</parameter>不是一个文本字符串，
      它只是一个数组：它不需要一个<literal>'\0'</literal>终止符。
     </para>
<!-- pgdoc-cn_end sig_en=962653668c7d79f165caa0317f7975fc -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=b4631d77e109c42543b5ede7350ea3c6 sig_cn_org=None source=14.1 
     <para><literal>true</literal> for read-only execution</para>
________________________________________________________-->
     <para>对只读执行为<literal>true</literal></para>
<!-- pgdoc-cn_end sig_en=b4631d77e109c42543b5ede7350ea3c6 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=e2ea877e409ea42ab0ad97a4a1433c31 sig_cn_org=None source=14.1 
  <para>
   Pointer to portal containing the cursor.  Note there is no error
   return convention; any error will be reported via <function>elog</function>.
  </para>
________________________________________________________-->
  <para>
   指向包含该游标的 portal 的指针。注意这里没有错误返回约定，
   任何错误都将通过<function>elog</function>报告。
  </para>
<!-- pgdoc-cn_end sig_en=e2ea877e409ea42ab0ad97a4a1433c31 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-open-with-args">
<!-- pgdoc-cn_start sig_en=38a3f8beaafb2e433b4d7fe22de882dd sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_cursor_open_with_args</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_cursor_open_with_args</primary></indexterm>
<!-- pgdoc-cn_end sig_en=38a3f8beaafb2e433b4d7fe22de882dd -->

 <refmeta>
  <refentrytitle>SPI_cursor_open_with_args</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=9b103f8fc68cf85976e3ade4129532b8 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_cursor_open_with_args</refname>
  <refpurpose>set up a cursor using a query and parameters</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_cursor_open_with_args</refname>
  <refpurpose>使用一个查询和参数建立一个游标</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=9b103f8fc68cf85976e3ade4129532b8 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=4a30a2e15b5365f1679f561d55cdff72 sig_cn_org=None source=14.1 
<synopsis>
Portal SPI_cursor_open_with_args(const char *<parameter>name</parameter>,
                                 const char *<parameter>command</parameter>,
                                 int <parameter>nargs</parameter>, Oid *<parameter>argtypes</parameter>,
                                 Datum *<parameter>values</parameter>, const char *<parameter>nulls</parameter>,
                                 bool <parameter>read_only</parameter>, int <parameter>cursorOptions</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
Portal SPI_cursor_open_with_args(const char *<parameter>name</parameter>,
                                 const char *<parameter>command</parameter>,
                                 int <parameter>nargs</parameter>, Oid *<parameter>argtypes</parameter>,
                                 Datum *<parameter>values</parameter>, const char *<parameter>nulls</parameter>,
                                 bool <parameter>read_only</parameter>, int <parameter>cursorOptions</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=4a30a2e15b5365f1679f561d55cdff72 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=9694b09b25708931d8afc7b158aaccca sig_cn_org=None source=14.1 
  <para>
   <function>SPI_cursor_open_with_args</function> sets up a cursor
   (internally, a portal) that will execute the specified query.
   Most of the parameters have the same meanings as the corresponding
   parameters to <function>SPI_prepare_cursor</function>
   and <function>SPI_cursor_open</function>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_cursor_open_with_args</function>建立一个将
   执行指定查询的游标（在内部是一个 portal）。大部分参数具有和
   <function>SPI_prepare_cursor</function>
   和<function>SPI_cursor_open</function>中相应参数相同的含
   义。
  </para>
<!-- pgdoc-cn_end sig_en=9694b09b25708931d8afc7b158aaccca -->

<!-- pgdoc-cn_start sig_en=6a7632d5ad8e64bfac80241b8dd077ea sig_cn_org=None source=14.1 
  <para>
   For one-time query execution, this function should be preferred
   over <function>SPI_prepare_cursor</function> followed by
   <function>SPI_cursor_open</function>.
   If the same command is to be executed with many different parameters,
   either method might be faster, depending on the cost of re-planning
   versus the benefit of custom plans.
  </para>
________________________________________________________-->
  <para>
   对于一次性的查询执行，这个函数应该比
   <function>SPI_prepare_cursor</function>加上其后的
   <function>SPI_cursor_open</function>更好。如果相同的命令
   要被用很多不同的参数执行，哪种方法更快就要取决于重做计划的
   代价与定制计划带来的好处之间谁更有利。
  </para>
<!-- pgdoc-cn_end sig_en=6a7632d5ad8e64bfac80241b8dd077ea -->

<!-- pgdoc-cn_start sig_en=d2c07c31203a7a6bad1dc70579af42a5 sig_cn_org=None source=14.1 
  <para>
   The passed-in parameter data will be copied into the cursor's portal, so it
   can be freed while the cursor still exists.
  </para>
________________________________________________________-->
  <para>
   被传入的参数数据将被复制到游标的 portal 中，因此在该游标仍然存在时
   可以释放掉被传入的参数数据。
  </para>
<!-- pgdoc-cn_end sig_en=d2c07c31203a7a6bad1dc70579af42a5 -->

<!-- pgdoc-cn_start sig_en=4164ec6dd22933b54f3c359ec62b3b79 sig_cn_org=None source=14.1 
  <para>
   This function is now deprecated in favor
   of <function>SPI_cursor_parse_open</function>, which provides equivalent
   functionality using a more modern API for handling query parameters.
  </para>
________________________________________________________-->
  <para>
   这个函数现在被废弃了，由<function>SPI_cursor_parse_open</function>代替，提供相同的函数性，使用更多现代的API以处理查询参数。
  </para>
<!-- pgdoc-cn_end sig_en=4164ec6dd22933b54f3c359ec62b3b79 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=25f914487d3cb3bbad4c3fe21739285a sig_cn_org=None source=14.1 
     <para>
      name for portal, or <symbol>NULL</symbol> to let the system
      select a name
     </para>
________________________________________________________-->
     <para>
      portal 的名字，或者设置成<symbol>NULL</symbol>
      让系统选择一个名称
     </para>
<!-- pgdoc-cn_end sig_en=25f914487d3cb3bbad4c3fe21739285a -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=a12067418fb7474b146adb5a862771c0 sig_cn_org=None source=14.1 
     <para>
      command string
     </para>
________________________________________________________-->
     <para>
      命令字符串
     </para>
<!-- pgdoc-cn_end sig_en=a12067418fb7474b146adb5a862771c0 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>nargs</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=91d8128269766936120f242347d2e9ab sig_cn_org=None source=14.1 
     <para>
      number of input parameters (<literal>$1</literal>, <literal>$2</literal>, etc.)
     </para>
________________________________________________________-->
     <para>
      输入参数的数量（<literal>$1</literal>、<literal>$2</literal>等等）。
     </para>
<!-- pgdoc-cn_end sig_en=91d8128269766936120f242347d2e9ab -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Oid * <parameter>argtypes</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=25168306c917bc4fa2ac1a794d0acbd6 sig_cn_org=None source=14.1 
     <para>
      an array of length <parameter>nargs</parameter>, containing the
      <acronym>OID</acronym>s of the data types of the parameters
     </para>
________________________________________________________-->
     <para>
      一个长度为<parameter>nargs</parameter>的数组，
      包含参数的数据类型的<acronym>OID</acronym>
     </para>
<!-- pgdoc-cn_end sig_en=25168306c917bc4fa2ac1a794d0acbd6 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=9162abcaa4afd84b6c714e9110e102fb sig_cn_org=None source=14.1 
     <para>
      an array of length <parameter>nargs</parameter>, containing the actual
      parameter values
     </para>
________________________________________________________-->
     <para>
      一个长度为<parameter>nargs</parameter>的数组，
      包含实际的参数值
     </para>
<!-- pgdoc-cn_end sig_en=9162abcaa4afd84b6c714e9110e102fb -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=c45f3ae0214af534c266875d73016440 sig_cn_org=None source=14.1 
     <para>
      an array of length <parameter>nargs</parameter>, describing which
      parameters are null
     </para>
________________________________________________________-->
     <para>
      一个长度为<parameter>nargs</parameter>的数组，
      描述哪些参数为空值
     </para>
<!-- pgdoc-cn_end sig_en=c45f3ae0214af534c266875d73016440 -->

<!-- pgdoc-cn_start sig_en=68cb1da1c73db762ca89872c5e76719b sig_cn_org=None source=14.1 
     <para>
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_cursor_open_with_args</function> assumes that no parameters
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</literal> if the corresponding parameter
      value is non-null, or <literal>'n'</literal> if the corresponding parameter
      value is null.  (In the latter case, the actual value in the
      corresponding <parameter>values</parameter> entry doesn't matter.)  Note
      that <parameter>nulls</parameter> is not a text string, just an array:
      it does not need a <literal>'\0'</literal> terminator.
     </para>
________________________________________________________-->
     <para>
      如果<parameter>nulls</parameter>为<symbol>NULL</symbol>，
      那么<function>SPI_cursor_open_with_args</function>会假设没有参数
      为空值。否则，如果对应的参数值为非空，
      <parameter>nulls</parameter>
      数组的每一个项都应该是<literal>'&nbsp;'</literal>；如果对应参数值为空，
      <parameter>nulls</parameter>数组的项应为<literal>'n'</literal>（在后
      面的情况中，对应的<parameter>values</parameter>项中的值没有
      关系）。注意<parameter>nulls</parameter>不是一个文本字符串，
      它只是一个数组：它不需要一个<literal>'\0'</literal>终止符。
     </para>
<!-- pgdoc-cn_end sig_en=68cb1da1c73db762ca89872c5e76719b -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=b4631d77e109c42543b5ede7350ea3c6 sig_cn_org=None source=14.1 
     <para><literal>true</literal> for read-only execution</para>
________________________________________________________-->
     <para>对只读执行为<literal>true</literal></para>
<!-- pgdoc-cn_end sig_en=b4631d77e109c42543b5ede7350ea3c6 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>cursorOptions</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=766a5ff7fb3a5c027fbe740c701e1d64 sig_cn_org=None source=14.1 
     <para>
      integer bit mask of cursor options; zero produces default behavior
     </para>
________________________________________________________-->
     <para>
      整数形式的游标选项位掩码，零会导致默认行为
     </para>
<!-- pgdoc-cn_end sig_en=766a5ff7fb3a5c027fbe740c701e1d64 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=e2ea877e409ea42ab0ad97a4a1433c31 sig_cn_org=None source=14.1 
  <para>
   Pointer to portal containing the cursor.  Note there is no error
   return convention; any error will be reported via <function>elog</function>.
  </para>
________________________________________________________-->
  <para>
   指向包含该游标的 portal 的指针。注意这里没有错误返回约定，
   任何错误都将通过<function>elog</function>报告。
  </para>
<!-- pgdoc-cn_end sig_en=e2ea877e409ea42ab0ad97a4a1433c31 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-open-with-paramlist">
<!-- pgdoc-cn_start sig_en=a7810abc8a69cc98a42aba229d2f8241 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_cursor_open_with_paramlist</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_cursor_open_with_paramlist</primary></indexterm>
<!-- pgdoc-cn_end sig_en=a7810abc8a69cc98a42aba229d2f8241 -->

 <refmeta>
  <refentrytitle>SPI_cursor_open_with_paramlist</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=eae3dd1ffb2a1b4d0198f8c477a241c7 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_cursor_open_with_paramlist</refname>
  <refpurpose>set up a cursor using parameters</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_cursor_open_with_paramlist</refname>
  <refpurpose>使用参数建立一个游标</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=eae3dd1ffb2a1b4d0198f8c477a241c7 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=bbc07c68844536707060a1b686c6e3e7 sig_cn_org=None source=14.1 
<synopsis>
Portal SPI_cursor_open_with_paramlist(const char *<parameter>name</parameter>,
                                      SPIPlanPtr <parameter>plan</parameter>,
                                      ParamListInfo <parameter>params</parameter>,
                                      bool <parameter>read_only</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
Portal SPI_cursor_open_with_paramlist(const char *<parameter>name</parameter>,
                                      SPIPlanPtr <parameter>plan</parameter>,
                                      ParamListInfo <parameter>params</parameter>,
                                      bool <parameter>read_only</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=bbc07c68844536707060a1b686c6e3e7 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=6aa5ac3d227e10610999cc041d52606d sig_cn_org=None source=14.1 
  <para>
   <function>SPI_cursor_open_with_paramlist</function> sets up a cursor
   (internally, a portal) that will execute a statement prepared by
   <function>SPI_prepare</function>.
   This function is equivalent to <function>SPI_cursor_open</function>
   except that information about the parameter values to be passed to the
   query is presented differently.  The <literal>ParamListInfo</literal>
   representation can be convenient for passing down values that are
   already available in that format.  It also supports use of dynamic
   parameter sets via hook functions specified in <literal>ParamListInfo</literal>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_cursor_open_with_paramlist</function>建立一个
   游标（在内部是一个 portal），它将执行一个由
   <function>SPI_prepare</function>准备好的语句。这个函数等效于
   <function>SPI_cursor_open</function>，不过被传递给该查询
   的参数值的信息以不同的方式呈现。<literal>ParamListInfo</literal>表现形
   式更方便于把这种格式的值向下传递。它也支持通过
   <literal>ParamListInfo</literal>中指定的钩子函数动态设置参数。
  </para>
<!-- pgdoc-cn_end sig_en=6aa5ac3d227e10610999cc041d52606d -->

<!-- pgdoc-cn_start sig_en=d2c07c31203a7a6bad1dc70579af42a5 sig_cn_org=None source=14.1 
  <para>
   The passed-in parameter data will be copied into the cursor's portal, so it
   can be freed while the cursor still exists.
  </para>
________________________________________________________-->
  <para>
   被传入的参数数据将被复制到游标的 portal 中，因此在该游标仍然存在时
   可以释放掉被传入的参数数据。
  </para>
<!-- pgdoc-cn_end sig_en=d2c07c31203a7a6bad1dc70579af42a5 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=25f914487d3cb3bbad4c3fe21739285a sig_cn_org=None source=14.1 
     <para>
      name for portal, or <symbol>NULL</symbol> to let the system
      select a name
     </para>
________________________________________________________-->
     <para>
      portal 的名字，或者设置成<symbol>NULL</symbol>
      让系统选择一个名称
     </para>
<!-- pgdoc-cn_end sig_en=25f914487d3cb3bbad4c3fe21739285a -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=7ba5ee24987a832e4009fbbc70894115 sig_cn_org=None source=14.1 
     <para>
      prepared statement (returned by <function>SPI_prepare</function>)
     </para>
________________________________________________________-->
     <para>
      预备语句（由<function>SPI_prepare</function>返回）
     </para>
<!-- pgdoc-cn_end sig_en=7ba5ee24987a832e4009fbbc70894115 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ParamListInfo <parameter>params</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=938aa30503bb886a3b5a13f3696a810e sig_cn_org=None source=14.1 
     <para>
      data structure containing parameter types and values; NULL if none
     </para>
________________________________________________________-->
     <para>
      包含参数类型和值的数据结构，如果没有则为 NULL
     </para>
<!-- pgdoc-cn_end sig_en=938aa30503bb886a3b5a13f3696a810e -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=b4631d77e109c42543b5ede7350ea3c6 sig_cn_org=None source=14.1 
     <para><literal>true</literal> for read-only execution</para>
________________________________________________________-->
     <para>对只读执行为<literal>true</literal></para>
<!-- pgdoc-cn_end sig_en=b4631d77e109c42543b5ede7350ea3c6 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=e2ea877e409ea42ab0ad97a4a1433c31 sig_cn_org=None source=14.1 
  <para>
   Pointer to portal containing the cursor.  Note there is no error
   return convention; any error will be reported via <function>elog</function>.
  </para>
________________________________________________________-->
  <para>
   指向包含该游标的 portal 的指针。注意这里没有错误返回约定，
   任何错误都将通过<function>elog</function>报告。
  </para>
<!-- pgdoc-cn_end sig_en=e2ea877e409ea42ab0ad97a4a1433c31 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-parse-open">
<!-- pgdoc-cn_start sig_en=17a69c0f3d125ecc9cc655281e1d866f sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_cursor_parse_open</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_cursor_parse_open</primary></indexterm>
<!-- pgdoc-cn_end sig_en=17a69c0f3d125ecc9cc655281e1d866f -->

 <refmeta>
  <refentrytitle>SPI_cursor_parse_open</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=60e96784775ac0ab5cb4d8c160410ee3 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_cursor_parse_open</refname>
  <refpurpose>set up a cursor using a query string and parameters</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_cursor_parse_open</refname>
  <refpurpose>使用查询字符串和参数设置游标</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=60e96784775ac0ab5cb4d8c160410ee3 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=df03d32fd5dccb737e866620bca2d753 sig_cn_org=None source=14.1 
<synopsis>
Portal SPI_cursor_parse_open(const char *<parameter>name</parameter>,
                             const char *<parameter>command</parameter>,
                             const SPIParseOpenOptions * <parameter>options</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
Portal SPI_cursor_parse_open(const char *<parameter>name</parameter>,
                             const char *<parameter>command</parameter>,
                             const SPIParseOpenOptions * <parameter>options</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=df03d32fd5dccb737e866620bca2d753 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=b9758b901f2e013102554a2b5da6324d sig_cn_org=None source=14.1 
  <para>
   <function>SPI_cursor_parse_open</function> sets up a cursor
   (internally, a portal) that will execute the specified query string.
   This is comparable to <function>SPI_prepare_cursor</function> followed
   by <function>SPI_cursor_open_with_paramlist</function>, except that
   parameter references within the query string are handled entirely by
   supplying a <literal>ParamListInfo</literal> object.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_cursor_parse_open</function> 建立一个游标(内部的，一个门户) ，将执行指定的查询字符串。
   这可以与由<function>SPI_cursor_open_with_paramlist</function>跟随的<function>SPI_prepare_cursor</function>相比较，
   除了查询字符串内参数引用，是通过供应<literal>ParamListInfo</literal>对象完全处理的。
  </para>
<!-- pgdoc-cn_end sig_en=b9758b901f2e013102554a2b5da6324d -->

<!-- pgdoc-cn_start sig_en=6b7813d2bc47bce20033a44532824fb1 sig_cn_org=None source=14.1 
  <para>
   For one-time query execution, this function should be preferred
   over <function>SPI_prepare_cursor</function> followed by
   <function>SPI_cursor_open_with_paramlist</function>.
   If the same command is to be executed with many different parameters,
   either method might be faster, depending on the cost of re-planning
   versus the benefit of custom plans.
  </para>
________________________________________________________-->
  <para>
   对一次性查询执行，这个函数将优先于被<function>SPI_cursor_open_with_paramlist</function>跟随的<function>SPI_prepare_cursor</function>。
   如果同样的命令带着很多不同的参数被执行，二者中的某一个方法也许会更快，取决于重新计划的开销与定制计划的收益的对比。
  </para>
<!-- pgdoc-cn_end sig_en=6b7813d2bc47bce20033a44532824fb1 -->

<!-- pgdoc-cn_start sig_en=010ceb3204beecfbb23f26367d071bff sig_cn_org=None source=14.1 
  <para>
   The <parameter>options-&gt;params</parameter> object should normally
   mark each parameter with the <literal>PARAM_FLAG_CONST</literal> flag,
   since a one-shot plan is always used for the query.
  </para>
________________________________________________________-->
  <para>
   <parameter>options-&gt;params</parameter> 对象将通常以<literal>PARAM_FLAG_CONST</literal>特征位标记每个参数，因为一个一次性计划总是用于查询。
  </para>
<!-- pgdoc-cn_end sig_en=010ceb3204beecfbb23f26367d071bff -->

<!-- pgdoc-cn_start sig_en=d2c07c31203a7a6bad1dc70579af42a5 sig_cn_org=None source=14.1 
  <para>
   The passed-in parameter data will be copied into the cursor's portal, so it
   can be freed while the cursor still exists.
  </para>
________________________________________________________-->
  <para>
   被传入的参数数据将被复制到游标的 portal 中，因此在该游标仍然存在时
   可以释放掉被传入的参数数据。
  </para>
<!-- pgdoc-cn_end sig_en=d2c07c31203a7a6bad1dc70579af42a5 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=25f914487d3cb3bbad4c3fe21739285a sig_cn_org=None source=14.1 
     <para>
      name for portal, or <symbol>NULL</symbol> to let the system
      select a name
     </para>
________________________________________________________-->
     <para>
      portal 的名字，或者设置成<symbol>NULL</symbol>
      让系统选择一个名称
     </para>
<!-- pgdoc-cn_end sig_en=25f914487d3cb3bbad4c3fe21739285a -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>command</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=a12067418fb7474b146adb5a862771c0 sig_cn_org=None source=14.1 
     <para>
      command string
     </para>
________________________________________________________-->
     <para>
      命令字符串
     </para>
<!-- pgdoc-cn_end sig_en=a12067418fb7474b146adb5a862771c0 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const SPIParseOpenOptions * <parameter>options</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=5a8ac1b553b4ce7a64f94f1bf9604635 sig_cn_org=None source=14.1 
     <para>
      struct containing optional arguments
     </para>
________________________________________________________-->
     <para>
      包含可选参数的结构体
     </para>
<!-- pgdoc-cn_end sig_en=5a8ac1b553b4ce7a64f94f1bf9604635 -->
    </listitem>
   </varlistentry>
  </variablelist>

<!-- pgdoc-cn_start sig_en=507f26acb20bb94c84d36715775669fc sig_cn_org=None source=14.1 
  <para>
   Callers should always zero out the entire <parameter>options</parameter>
   struct, then fill whichever fields they want to set.  This ensures forward
   compatibility of code, since any fields that are added to the struct in
   future will be defined to behave backwards-compatibly if they are zero.
   The currently available <parameter>options</parameter> fields are:
  </para>
________________________________________________________-->
  <para>
   调用器将总是将整个<parameter>options</parameter>结构体归零，然后填充他们想设置的任何字段。
   这确保代码的向前兼容性，因为在未来添加到结构体中的任何字段将被定义成行为向后兼容，如果他们为零。
   当前有效的<parameter>options</parameter>字段为：
  </para>
<!-- pgdoc-cn_end sig_en=507f26acb20bb94c84d36715775669fc -->

  <variablelist>
   <varlistentry>
    <term><literal>ParamListInfo <parameter>params</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=d463c39cdaff23f00b44fef84727bd66 sig_cn_org=None source=14.1 
     <para>
      data structure containing query parameter types and values; NULL if none
     </para>
________________________________________________________-->
     <para>
      包含查询参数类型和值的数据结构；没有则为NULL
     </para>
<!-- pgdoc-cn_end sig_en=d463c39cdaff23f00b44fef84727bd66 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>cursorOptions</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=766a5ff7fb3a5c027fbe740c701e1d64 sig_cn_org=None source=14.1 
     <para>
      integer bit mask of cursor options; zero produces default behavior
     </para>
________________________________________________________-->
     <para>
      整数形式的游标选项位掩码，零会导致默认行为
     </para>
<!-- pgdoc-cn_end sig_en=766a5ff7fb3a5c027fbe740c701e1d64 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>read_only</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=b4631d77e109c42543b5ede7350ea3c6 sig_cn_org=None source=14.1 
     <para><literal>true</literal> for read-only execution</para>
________________________________________________________-->
     <para>对只读执行为<literal>true</literal></para>
<!-- pgdoc-cn_end sig_en=b4631d77e109c42543b5ede7350ea3c6 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=e2ea877e409ea42ab0ad97a4a1433c31 sig_cn_org=None source=14.1 
  <para>
   Pointer to portal containing the cursor.  Note there is no error
   return convention; any error will be reported via <function>elog</function>.
  </para>
________________________________________________________-->
  <para>
   指向包含该游标的 portal 的指针。注意这里没有错误返回约定，
   任何错误都将通过<function>elog</function>报告。
  </para>
<!-- pgdoc-cn_end sig_en=e2ea877e409ea42ab0ad97a4a1433c31 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-find">
<!-- pgdoc-cn_start sig_en=594af82496afb47bd550b6904b6fcaec sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_cursor_find</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_cursor_find</primary></indexterm>
<!-- pgdoc-cn_end sig_en=594af82496afb47bd550b6904b6fcaec -->

 <refmeta>
  <refentrytitle>SPI_cursor_find</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=00390ea226b1d15b4020692e1329b181 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_cursor_find</refname>
  <refpurpose>find an existing cursor by name</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_cursor_find</refname>
  <refpurpose>用名称查找一个现有的游标</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=00390ea226b1d15b4020692e1329b181 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=6dba60bbe0c8064e32ce6a2f15800b07 sig_cn_org=None source=14.1 
<synopsis>
Portal SPI_cursor_find(const char * <parameter>name</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
Portal SPI_cursor_find(const char * <parameter>name</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=6dba60bbe0c8064e32ce6a2f15800b07 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=738713bf3975136614a4edef219467a6 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_cursor_find</function> finds an existing portal by
   name.  This is primarily useful to resolve a cursor name returned
   as text by some other function.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_cursor_find</function>用名称查找一个现有的 portal。
   这主要被用于解析由其他某个函数返回的一个油表名称。
  </para>
<!-- pgdoc-cn_end sig_en=738713bf3975136614a4edef219467a6 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=45c74b81ec78cf23b11e85ed2e682546 sig_cn_org=None source=14.1 
     <para>
      name of the portal
     </para>
________________________________________________________-->
     <para>
      该 portal 的名称
     </para>
<!-- pgdoc-cn_end sig_en=45c74b81ec78cf23b11e85ed2e682546 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=d1ba9e0381a255d44fcb6bf6a52cc323 sig_cn_org=None source=14.1 
  <para>
   pointer to the portal with the specified name, or
   <symbol>NULL</symbol> if none was found
  </para>
________________________________________________________-->
  <para>
   带有指定名称的 portal 的指针，如果没有找到就是
   <symbol>NULL</symbol>
  </para>
<!-- pgdoc-cn_end sig_en=d1ba9e0381a255d44fcb6bf6a52cc323 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
  <title>Notes</title>
________________________________________________________-->
  <title>注解</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->

<!-- pgdoc-cn_start sig_en=4388ce57cb4ff12bc4a75d851efb8906 sig_cn_org=1acaed07b7e8dd7e8572b0fcd21c0979 source=15.7 
  <para>
   Beware that this function can return a <type>Portal</type> object
   that does not have cursor-like properties; for example it might not
   return tuples.  If you simply pass the <type>Portal</type> pointer
   to other SPI functions, they can defend themselves against such
   cases, but caution is appropriate when directly inspecting
   the <type>Portal</type>.
  </para>
________________________________________________________-->
  <para>
   注意，此函数可能返回一个<type>Portal</type>对象，该对象没有类似游标的属性；例如，它可能不返回元组。
   如果你只是将<type>Portal</type>指针传递给其他SPI函数，它们可以防范这种情况，但在直接检查<type>Portal</type>时需要谨慎。
</para>
<!-- pgdoc-cn_end sig_en=4388ce57cb4ff12bc4a75d851efb8906 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-fetch">
<!-- pgdoc-cn_start sig_en=5dd64f597daa323e03baf3fadf12f7d0 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_cursor_fetch</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_cursor_fetch</primary></indexterm>
<!-- pgdoc-cn_end sig_en=5dd64f597daa323e03baf3fadf12f7d0 -->

 <refmeta>
  <refentrytitle>SPI_cursor_fetch</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=4960c6a0db1b874101af17cb55278803 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_cursor_fetch</refname>
  <refpurpose>fetch some rows from a cursor</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_cursor_fetch</refname>
  <refpurpose>从一个游标取出一些行</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=4960c6a0db1b874101af17cb55278803 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=fd5af0b9f4c23748b49129f6f87b227e sig_cn_org=None source=14.1 
<synopsis>
void SPI_cursor_fetch(Portal <parameter>portal</parameter>, bool <parameter>forward</parameter>, long <parameter>count</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
void SPI_cursor_fetch(Portal <parameter>portal</parameter>, bool <parameter>forward</parameter>, long <parameter>count</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=fd5af0b9f4c23748b49129f6f87b227e -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=a0b28d830be4ef109aa4c6b276437aec sig_cn_org=None source=14.1 
  <para>
   <function>SPI_cursor_fetch</function> fetches some rows from a
   cursor.  This is equivalent to a subset of the SQL command
   <command>FETCH</command> (see <function>SPI_scroll_cursor_fetch</function>
   for more functionality).
  </para>
________________________________________________________-->
  <para>
   <function>SPI_cursor_fetch</function>从一个游标取得一些行。
   这等效于 SQL 命令<command>FETCH</command>的一个子集（更多功能
   见<function>SPI_scroll_cursor_fetch</function>）。
  </para>
<!-- pgdoc-cn_end sig_en=a0b28d830be4ef109aa4c6b276437aec -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=9fb83ec26c348b486dbd3b122fcf572a sig_cn_org=None source=14.1 
     <para>
      portal containing the cursor
     </para>
________________________________________________________-->
     <para>
      包含该游标的 portal
     </para>
<!-- pgdoc-cn_end sig_en=9fb83ec26c348b486dbd3b122fcf572a -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>forward</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=0835fbe0751f8b42017444fecaf41cf3 sig_cn_org=None source=14.1 
     <para>
      true for fetch forward, false for fetch backward
     </para>
________________________________________________________-->
     <para>
      为真表示向前获取，为假表示向后获取
     </para>
<!-- pgdoc-cn_end sig_en=0835fbe0751f8b42017444fecaf41cf3 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=c2827c4903978a77751fe4e27a8962f6 sig_cn_org=None source=14.1 
     <para>
      maximum number of rows to fetch
     </para>
________________________________________________________-->
     <para>
      要取得的最大行数
     </para>
<!-- pgdoc-cn_end sig_en=c2827c4903978a77751fe4e27a8962f6 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=f501eb9c4097f782a68f87c3eed6fb6e sig_cn_org=None source=14.1 
  <para>
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute</function> if successful.
  </para>
________________________________________________________-->
  <para>
   如果成功<function>SPI_execute</function>会设置
   <varname>SPI_processed</varname>和
   <varname>SPI_tuptable</varname>。
  </para>
<!-- pgdoc-cn_end sig_en=f501eb9c4097f782a68f87c3eed6fb6e -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
  <title>Notes</title>
________________________________________________________-->
  <title>注解</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->

<!-- pgdoc-cn_start sig_en=3c7341e9ab381314167b2d04694cdd82 sig_cn_org=None source=14.1 
  <para>
   Fetching backward may fail if the cursor's plan was not created
   with the <symbol>CURSOR_OPT_SCROLL</symbol> option.
  </para>
________________________________________________________-->
  <para>
   如果该游标的计划不是用<symbol>CURSOR_OPT_SCROLL</symbol>
   选项创建的，向后获取会失败。
  </para>
<!-- pgdoc-cn_end sig_en=3c7341e9ab381314167b2d04694cdd82 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-move">
<!-- pgdoc-cn_start sig_en=f8cab9b7a2f538967f61474680498935 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_cursor_move</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_cursor_move</primary></indexterm>
<!-- pgdoc-cn_end sig_en=f8cab9b7a2f538967f61474680498935 -->

 <refmeta>
  <refentrytitle>SPI_cursor_move</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=20cd4ad6eb894e90d4a2ca70cc66eb9b sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_cursor_move</refname>
  <refpurpose>move a cursor</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_cursor_move</refname>
  <refpurpose>移动一个游标</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=20cd4ad6eb894e90d4a2ca70cc66eb9b -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=35f7a6985979d002a2a0f5ac1dde12df sig_cn_org=None source=14.1 
<synopsis>
void SPI_cursor_move(Portal <parameter>portal</parameter>, bool <parameter>forward</parameter>, long <parameter>count</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
void SPI_cursor_move(Portal <parameter>portal</parameter>, bool <parameter>forward</parameter>, long <parameter>count</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=35f7a6985979d002a2a0f5ac1dde12df -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=f75dc5f97e62201b8a2bf359985cc5b6 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_cursor_move</function> skips over some number of rows
   in a cursor.  This is equivalent to a subset of the SQL command
   <command>MOVE</command> (see <function>SPI_scroll_cursor_move</function>
   for more functionality).
  </para>
________________________________________________________-->
  <para>
   <function>SPI_cursor_move</function>跳过一个游标中的一些行。
   这等效于 SQL 命令<command>MOVE</command>的一个子集（更多的功能
   请见<function>SPI_scroll_cursor_move</function>）。
  </para>
<!-- pgdoc-cn_end sig_en=f75dc5f97e62201b8a2bf359985cc5b6 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=9fb83ec26c348b486dbd3b122fcf572a sig_cn_org=None source=14.1 
     <para>
      portal containing the cursor
     </para>
________________________________________________________-->
     <para>
      包含该游标的 portal
     </para>
<!-- pgdoc-cn_end sig_en=9fb83ec26c348b486dbd3b122fcf572a -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool <parameter>forward</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=73742b3dab16deea4145adf67648aa29 sig_cn_org=None source=14.1 
     <para>
      true for move forward, false for move backward
     </para>
________________________________________________________-->
     <para>
      为真表示前移，为假表示后移
     </para>
<!-- pgdoc-cn_end sig_en=73742b3dab16deea4145adf67648aa29 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=5e7899d0630d669ae4b1e611bf48ba64 sig_cn_org=None source=14.1 
     <para>
      maximum number of rows to move
     </para>
________________________________________________________-->
     <para>
      要移动的最大行数
     </para>
<!-- pgdoc-cn_end sig_en=5e7899d0630d669ae4b1e611bf48ba64 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
  <title>Notes</title>
________________________________________________________-->
  <title>注解</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->

<!-- pgdoc-cn_start sig_en=2c160e302a42af9d83ac75831d28beab sig_cn_org=None source=14.1 
  <para>
   Moving backward may fail if the cursor's plan was not created
   with the <symbol>CURSOR_OPT_SCROLL</symbol> option.
  </para>
________________________________________________________-->
  <para>
   如果该游标的计划不是用<symbol>CURSOR_OPT_SCROLL</symbol>
   选项创建的，向后移动会失败。
  </para>
<!-- pgdoc-cn_end sig_en=2c160e302a42af9d83ac75831d28beab -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-scroll-cursor-fetch">
<!-- pgdoc-cn_start sig_en=4d78c372c6fe0664335d39f1ac033d98 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_scroll_cursor_fetch</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_scroll_cursor_fetch</primary></indexterm>
<!-- pgdoc-cn_end sig_en=4d78c372c6fe0664335d39f1ac033d98 -->

 <refmeta>
  <refentrytitle>SPI_scroll_cursor_fetch</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=ce6b6375759da8ae6797a880c8b0b235 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_scroll_cursor_fetch</refname>
  <refpurpose>fetch some rows from a cursor</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_scroll_cursor_fetch</refname>
  <refpurpose>从一个游标取出一些行</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=ce6b6375759da8ae6797a880c8b0b235 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=35347a5b36c5d77dc12679164d0b61ab sig_cn_org=None source=14.1 
<synopsis>
void SPI_scroll_cursor_fetch(Portal <parameter>portal</parameter>, FetchDirection <parameter>direction</parameter>,
                             long <parameter>count</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
void SPI_scroll_cursor_fetch(Portal <parameter>portal</parameter>, FetchDirection <parameter>direction</parameter>,
                             long <parameter>count</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=35347a5b36c5d77dc12679164d0b61ab -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=c73a56797fabee45e6cef4b0fbdb3b19 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_scroll_cursor_fetch</function> fetches some rows from a
   cursor.  This is equivalent to the SQL command <command>FETCH</command>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_scroll_cursor_fetch</function>从一个游标中取出一些行。
   这等效于 SQL 命令<command>FETCH</command>。
  </para>
<!-- pgdoc-cn_end sig_en=c73a56797fabee45e6cef4b0fbdb3b19 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=9fb83ec26c348b486dbd3b122fcf572a sig_cn_org=None source=14.1 
     <para>
      portal containing the cursor
     </para>
________________________________________________________-->
     <para>
      包含该游标的 portal
     </para>
<!-- pgdoc-cn_end sig_en=9fb83ec26c348b486dbd3b122fcf572a -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FetchDirection <parameter>direction</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=25096d403d1f86c5feb651994c0db4c1 sig_cn_org=None source=14.1 
     <para>
      one of <symbol>FETCH_FORWARD</symbol>,
      <symbol>FETCH_BACKWARD</symbol>,
      <symbol>FETCH_ABSOLUTE</symbol> or
      <symbol>FETCH_RELATIVE</symbol>
     </para>
________________________________________________________-->
     <para>
      <symbol>FETCH_FORWARD</symbol>、
      <symbol>FETCH_BACKWARD</symbol>、
      <symbol>FETCH_ABSOLUTE</symbol>或者
      <symbol>FETCH_RELATIVE</symbol>之一
     </para>
<!-- pgdoc-cn_end sig_en=25096d403d1f86c5feb651994c0db4c1 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=16d1ab53d630bf943ee4dae3dc80755a sig_cn_org=None source=14.1 
     <para>
      number of rows to fetch for
      <symbol>FETCH_FORWARD</symbol> or
      <symbol>FETCH_BACKWARD</symbol>; absolute row number to fetch for
      <symbol>FETCH_ABSOLUTE</symbol>; or relative row number to fetch for
      <symbol>FETCH_RELATIVE</symbol>
     </para>
________________________________________________________-->
     <para>
      <symbol>FETCH_FORWARD</symbol>或
      <symbol>FETCH_BACKWARD</symbol>方式中要取出的行数；
      <symbol>FETCH_ABSOLUTE</symbol>方式中要取出的绝对行号；
      <symbol>FETCH_RELATIVE</symbol>方式中要取出的相对行号
     </para>
<!-- pgdoc-cn_end sig_en=16d1ab53d630bf943ee4dae3dc80755a -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=f501eb9c4097f782a68f87c3eed6fb6e sig_cn_org=None source=14.1 
  <para>
   <varname>SPI_processed</varname> and
   <varname>SPI_tuptable</varname> are set as in
   <function>SPI_execute</function> if successful.
  </para>
________________________________________________________-->
  <para>
   如果成功<function>SPI_execute</function>会设置
   <varname>SPI_processed</varname>和
   <varname>SPI_tuptable</varname>。
  </para>
<!-- pgdoc-cn_end sig_en=f501eb9c4097f782a68f87c3eed6fb6e -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
  <title>Notes</title>
________________________________________________________-->
  <title>注解</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->

<!-- pgdoc-cn_start sig_en=39df16c40a4e35bfa220e372d5e139d4 sig_cn_org=None source=14.1 
  <para>
   See the SQL <xref linkend="sql-fetch"/> command
   for details of the interpretation of the
   <parameter>direction</parameter> and
   <parameter>count</parameter> parameters.
  </para>
________________________________________________________-->
  <para>
   参数<parameter>direction</parameter>和
   <parameter>count</parameter>的详细解释请见
   SQL <xref linkend="sql-fetch"/>命令。
  </para>
<!-- pgdoc-cn_end sig_en=39df16c40a4e35bfa220e372d5e139d4 -->

<!-- pgdoc-cn_start sig_en=446f661c6df91489e36e6e4e9a9a478c sig_cn_org=None source=14.1 
  <para>
   Direction values other than <symbol>FETCH_FORWARD</symbol>
   may fail if the cursor's plan was not created
   with the <symbol>CURSOR_OPT_SCROLL</symbol> option.
  </para>
________________________________________________________-->
  <para>
   如果该游标的计划不是用<symbol>CURSOR_OPT_SCROLL</symbol>
   选项创建的，除<symbol>FETCH_FORWARD</symbol>之外的方向值会
   失败。
  </para>
<!-- pgdoc-cn_end sig_en=446f661c6df91489e36e6e4e9a9a478c -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-scroll-cursor-move">
<!-- pgdoc-cn_start sig_en=26e4c832db0f0172cd17a76862d3c7d7 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_scroll_cursor_move</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_scroll_cursor_move</primary></indexterm>
<!-- pgdoc-cn_end sig_en=26e4c832db0f0172cd17a76862d3c7d7 -->

 <refmeta>
  <refentrytitle>SPI_scroll_cursor_move</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=c591e52f777358884c2e89654803b7c5 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_scroll_cursor_move</refname>
  <refpurpose>move a cursor</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_scroll_cursor_move</refname>
  <refpurpose>移动一个游标</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=c591e52f777358884c2e89654803b7c5 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=a19ab6afd4c321167b9738e13ef18372 sig_cn_org=None source=14.1 
<synopsis>
void SPI_scroll_cursor_move(Portal <parameter>portal</parameter>, FetchDirection <parameter>direction</parameter>,
                            long <parameter>count</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
void SPI_scroll_cursor_move(Portal <parameter>portal</parameter>, FetchDirection <parameter>direction</parameter>,
                            long <parameter>count</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=a19ab6afd4c321167b9738e13ef18372 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=3ee70244ae8c9d7b7361e0e3f2d38038 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_scroll_cursor_move</function> skips over some number of rows
   in a cursor.  This is equivalent to the SQL command
   <command>MOVE</command>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_scroll_cursor_move</function>在一个游标中跳过
   一定数量的行。这等效于 SQL 命令<command>MOVE</command>。
  </para>
<!-- pgdoc-cn_end sig_en=3ee70244ae8c9d7b7361e0e3f2d38038 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=9fb83ec26c348b486dbd3b122fcf572a sig_cn_org=None source=14.1 
     <para>
      portal containing the cursor
     </para>
________________________________________________________-->
     <para>
      包含该游标的 portal
     </para>
<!-- pgdoc-cn_end sig_en=9fb83ec26c348b486dbd3b122fcf572a -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FetchDirection <parameter>direction</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=25096d403d1f86c5feb651994c0db4c1 sig_cn_org=None source=14.1 
     <para>
      one of <symbol>FETCH_FORWARD</symbol>,
      <symbol>FETCH_BACKWARD</symbol>,
      <symbol>FETCH_ABSOLUTE</symbol> or
      <symbol>FETCH_RELATIVE</symbol>
     </para>
________________________________________________________-->
     <para>
      <symbol>FETCH_FORWARD</symbol>、
      <symbol>FETCH_BACKWARD</symbol>、
      <symbol>FETCH_ABSOLUTE</symbol>或者
      <symbol>FETCH_RELATIVE</symbol>之一
     </para>
<!-- pgdoc-cn_end sig_en=25096d403d1f86c5feb651994c0db4c1 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>long <parameter>count</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=deab1bdfe9ee07a25a4cf99b473bdbec sig_cn_org=None source=14.1 
     <para>
      number of rows to move for
      <symbol>FETCH_FORWARD</symbol> or
      <symbol>FETCH_BACKWARD</symbol>; absolute row number to move to for
      <symbol>FETCH_ABSOLUTE</symbol>; or relative row number to move to for
      <symbol>FETCH_RELATIVE</symbol>
     </para>
________________________________________________________-->
     <para>
      <symbol>FETCH_FORWARD</symbol>或者
      <symbol>FETCH_BACKWARD</symbol>方式中要移动的行数；
      <symbol>FETCH_ABSOLUTE</symbol>方式中要移动到的绝对行号；
      <symbol>FETCH_RELATIVE</symbol>方式中要移动到的相对行号
     </para>
<!-- pgdoc-cn_end sig_en=deab1bdfe9ee07a25a4cf99b473bdbec -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=7dde3465dd9b1b5f63525c6f5b98f8f5 sig_cn_org=None source=14.1 
  <para>
   <varname>SPI_processed</varname> is set as in
   <function>SPI_execute</function> if successful.
   <varname>SPI_tuptable</varname> is set to <symbol>NULL</symbol>, since
   no rows are returned by this function.
  </para>
________________________________________________________-->
  <para>
   成功时，就像在<function>SPI_execute</function>中会设置
   <varname>SPI_processed</varname>。
   <varname>SPI_tuptable</varname>被设置为<symbol>NULL</symbol>，
   因为这个函数不需要返回行。
  </para>
<!-- pgdoc-cn_end sig_en=7dde3465dd9b1b5f63525c6f5b98f8f5 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
  <title>Notes</title>
________________________________________________________-->
  <title>注解</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->

<!-- pgdoc-cn_start sig_en=39df16c40a4e35bfa220e372d5e139d4 sig_cn_org=None source=14.1 
  <para>
   See the SQL <xref linkend="sql-fetch"/> command
   for details of the interpretation of the
   <parameter>direction</parameter> and
   <parameter>count</parameter> parameters.
  </para>
________________________________________________________-->
  <para>
   参数<parameter>direction</parameter>和
   <parameter>count</parameter>的详细解释请见
   SQL <xref linkend="sql-fetch"/>命令。
  </para>
<!-- pgdoc-cn_end sig_en=39df16c40a4e35bfa220e372d5e139d4 -->

<!-- pgdoc-cn_start sig_en=446f661c6df91489e36e6e4e9a9a478c sig_cn_org=None source=14.1 
  <para>
   Direction values other than <symbol>FETCH_FORWARD</symbol>
   may fail if the cursor's plan was not created
   with the <symbol>CURSOR_OPT_SCROLL</symbol> option.
  </para>
________________________________________________________-->
  <para>
   如果该游标的计划不是用<symbol>CURSOR_OPT_SCROLL</symbol>
   选项创建的，除<symbol>FETCH_FORWARD</symbol>之外的方向值会
   失败。
  </para>
<!-- pgdoc-cn_end sig_en=446f661c6df91489e36e6e4e9a9a478c -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-cursor-close">
<!-- pgdoc-cn_start sig_en=00d04ea6a1433775416ece7c5032267f sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_cursor_close</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_cursor_close</primary></indexterm>
<!-- pgdoc-cn_end sig_en=00d04ea6a1433775416ece7c5032267f -->

 <refmeta>
  <refentrytitle>SPI_cursor_close</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=6fdc3a32309fea251ad7d2fe065bd25b sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_cursor_close</refname>
  <refpurpose>close a cursor</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_cursor_close</refname>
  <refpurpose>关闭一个游标</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=6fdc3a32309fea251ad7d2fe065bd25b -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=b2ab593e8cfd0220c249bc5e23ec8025 sig_cn_org=None source=14.1 
<synopsis>
void SPI_cursor_close(Portal <parameter>portal</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
void SPI_cursor_close(Portal <parameter>portal</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=b2ab593e8cfd0220c249bc5e23ec8025 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=ff8ccffc9591f7492cd38754a24ecb09 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_cursor_close</function> closes a previously created
   cursor and releases its portal storage.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_cursor_close</function>关闭一个之前创建的游标
   并且释放它的 portal 存储。
  </para>
<!-- pgdoc-cn_end sig_en=ff8ccffc9591f7492cd38754a24ecb09 -->

<!-- pgdoc-cn_start sig_en=dae17b7931a80ac7528270eb8b297a7b sig_cn_org=None source=14.1 
  <para>
   All open cursors are closed automatically at the end of a
   transaction.  <function>SPI_cursor_close</function> need only be
   invoked if it is desirable to release resources sooner.
  </para>
________________________________________________________-->
  <para>
   所有打开的游标会在事务结束时自动被关闭。
   只有在希望尽快释放资源时，才需要调用
   <function>SPI_cursor_close</function>。
  </para>
<!-- pgdoc-cn_end sig_en=dae17b7931a80ac7528270eb8b297a7b -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>Portal <parameter>portal</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=9fb83ec26c348b486dbd3b122fcf572a sig_cn_org=None source=14.1 
     <para>
      portal containing the cursor
     </para>
________________________________________________________-->
     <para>
      包含该游标的 portal
     </para>
<!-- pgdoc-cn_end sig_en=9fb83ec26c348b486dbd3b122fcf572a -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-keepplan">
<!-- pgdoc-cn_start sig_en=fd8a6b5781f6d9c82877f02bee21aa64 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_keepplan</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_keepplan</primary></indexterm>
<!-- pgdoc-cn_end sig_en=fd8a6b5781f6d9c82877f02bee21aa64 -->

 <refmeta>
  <refentrytitle>SPI_keepplan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=8158b36f2e99a424d04db3aed88870d8 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_keepplan</refname>
  <refpurpose>save a prepared statement</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_keepplan</refname>
  <refpurpose>保存一个预备语句</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=8158b36f2e99a424d04db3aed88870d8 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=0ed65d2ca0e39ae068969eb48d29602d sig_cn_org=None source=14.1 
<synopsis>
int SPI_keepplan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
int SPI_keepplan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=0ed65d2ca0e39ae068969eb48d29602d -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=7ba5f30ae09016404f7482ec0df5ff5b sig_cn_org=None source=14.1 
  <para>
   <function>SPI_keepplan</function> saves a passed statement (prepared by
   <function>SPI_prepare</function>) so that it will not be freed
   by <function>SPI_finish</function> nor by the transaction manager.
   This gives you the ability to reuse prepared statements in the subsequent
   invocations of your C function in the current session.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_keepplan</function>保存一个被传入的语句（由
   <function>SPI_prepare</function>准备好），这样它将不会被
   <function>SPI_finish</function>或者事务管理器释放。这让你能够
   在当前会话的后续C函数调用中重用预备语句。
  </para>
<!-- pgdoc-cn_end sig_en=7ba5f30ae09016404f7482ec0df5ff5b -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=66f04d6edaa58db79dee10d4cfbaee5f sig_cn_org=None source=14.1 
     <para>
      the prepared statement to be saved
     </para>
________________________________________________________-->
     <para>
      要保存的预备语句
     </para>
<!-- pgdoc-cn_end sig_en=66f04d6edaa58db79dee10d4cfbaee5f -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=f3510886283b692efcd8cdefe53fff5c sig_cn_org=None source=14.1 
  <para>
   0 on success;
   <symbol>SPI_ERROR_ARGUMENT</symbol> if <parameter>plan</parameter>
   is <symbol>NULL</symbol> or invalid
  </para>
________________________________________________________-->
  <para>
   成功返回 0；如果<parameter>plan</parameter>为<symbol>NULL</symbol>
   或者无效则返回<symbol>SPI_ERROR_ARGUMENT</symbol>
  </para>
<!-- pgdoc-cn_end sig_en=f3510886283b692efcd8cdefe53fff5c -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
  <title>Notes</title>
________________________________________________________-->
  <title>注解</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->

<!-- pgdoc-cn_start sig_en=a8f442e7c41b7a4b85b36a27df0f0fef sig_cn_org=None source=14.1 
  <para>
   The passed-in statement is relocated to permanent storage by means
   of pointer adjustment (no data copying is required).  If you later
   wish to delete it, use <function>SPI_freeplan</function> on it.
  </para>
________________________________________________________-->
  <para>
   这个函数通过指针调整的方法（不需要数据复制）将被传入的语句重定位
   到永久存储中。如果你后来需要删除它，可以对它使用
   <function>SPI_freeplan</function>。
  </para>
<!-- pgdoc-cn_end sig_en=a8f442e7c41b7a4b85b36a27df0f0fef -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-saveplan">
<!-- pgdoc-cn_start sig_en=8fcfb69c1fb29bf3554266e349f859ac sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_saveplan</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_saveplan</primary></indexterm>
<!-- pgdoc-cn_end sig_en=8fcfb69c1fb29bf3554266e349f859ac -->

 <refmeta>
  <refentrytitle>SPI_saveplan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=fa4f8f7d69d8072b7fa4edb50128785f sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_saveplan</refname>
  <refpurpose>save a prepared statement</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_saveplan</refname>
  <refpurpose>保存一个预备语句</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=fa4f8f7d69d8072b7fa4edb50128785f -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=9133a7d7708379529bdf88e27a7f2cce sig_cn_org=None source=14.1 
<synopsis>
SPIPlanPtr SPI_saveplan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
SPIPlanPtr SPI_saveplan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=9133a7d7708379529bdf88e27a7f2cce -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=f88133206d969d4f4e713a9c2a37a44a sig_cn_org=None source=14.1 
  <para>
   <function>SPI_saveplan</function> copies a passed statement (prepared by
   <function>SPI_prepare</function>) into memory that will not be freed
   by <function>SPI_finish</function> nor by the transaction manager,
   and returns a pointer to the copied statement.  This gives you the
   ability to reuse prepared statements in the subsequent invocations of
   your C function in the current session.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_saveplan</function>把一个被传入的语句（由
   <function>SPI_prepare</function>准备好）复制到不会被
   <function>SPI_finish</function>或者事务管理器释放的内存中。
   这让你能够在当前会话的后续C函数调用中重用预备语句。
  </para>
<!-- pgdoc-cn_end sig_en=f88133206d969d4f4e713a9c2a37a44a -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=66f04d6edaa58db79dee10d4cfbaee5f sig_cn_org=None source=14.1 
     <para>
      the prepared statement to be saved
     </para>
________________________________________________________-->
     <para>
      要保存的预备语句
     </para>
<!-- pgdoc-cn_end sig_en=66f04d6edaa58db79dee10d4cfbaee5f -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=a6afe50b39c77872e5282d90e7ba74e3 sig_cn_org=None source=14.1 
  <para>
   Pointer to the copied statement; or <symbol>NULL</symbol> if unsuccessful.
   On error, <varname>SPI_result</varname> is set thus:

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       if <parameter>plan</parameter> is <symbol>NULL</symbol> or invalid
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       if called from an unconnected C function
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   要被复制的语句的指针；如果没有成功则返回<symbol>NULL</symbol>。
   错误时，<varname>SPI_result</varname>会被这样设置：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       如果<parameter>plan</parameter>为<symbol>NULL</symbol>或无效
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       如果从一个未连接的C函数调用
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=a6afe50b39c77872e5282d90e7ba74e3 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 sig_cn_org=None source=14.1 
  <title>Notes</title>
________________________________________________________-->
  <title>注解</title>
<!-- pgdoc-cn_end sig_en=c44fa43baeb4f69a8a2aa1ea108c6e97 -->

<!-- pgdoc-cn_start sig_en=3d990907ce480112e4b102fa4b2819f1 sig_cn_org=None source=14.1 
  <para>
   The originally passed-in statement is not freed, so you might wish to do
   <function>SPI_freeplan</function> on it to avoid leaking memory
   until <function>SPI_finish</function>.
  </para>
________________________________________________________-->
  <para>
   原始的被传入的语句不会被释放，因此你可能希望在其上执行
   <function>SPI_freeplan</function>以避免在
   <function>SPI_finish</function>之前发生内存泄露。
  </para>
<!-- pgdoc-cn_end sig_en=3d990907ce480112e4b102fa4b2819f1 -->

<!-- pgdoc-cn_start sig_en=746cacb8c4ba42be1a1c75514072e955 sig_cn_org=None source=14.1 
  <para>
   In most cases, <function>SPI_keepplan</function> is preferred to this
   function, since it accomplishes largely the same result without needing
   to physically copy the prepared statement's data structures.
  </para>
________________________________________________________-->
  <para>
   在大部分情况下，<function>SPI_keepplan</function>更适合于
   执行这种功能，因为它极大程度上达到了同样的结果而无需物理地
   复制该预备语句的数据结构。
  </para>
<!-- pgdoc-cn_end sig_en=746cacb8c4ba42be1a1c75514072e955 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-register-relation">
<!-- pgdoc-cn_start sig_en=8a924bc4354f5aee67be2c9a2ab9f61e sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_register_relation</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_register_relation</primary></indexterm>
<!-- pgdoc-cn_end sig_en=8a924bc4354f5aee67be2c9a2ab9f61e -->

<!-- pgdoc-cn_start sig_en=3f3e8ae9a80850bb58c883ed6e862086 sig_cn_org=None source=14.1 
 <indexterm>
  <primary>ephemeral named relation</primary>
  <secondary>registering with SPI</secondary>
 </indexterm>
________________________________________________________-->
 <indexterm>
  <primary>ephemeral named relation</primary>
  <secondary>registering with SPI</secondary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=3f3e8ae9a80850bb58c883ed6e862086 -->

 <refmeta>
  <refentrytitle>SPI_register_relation</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=17cf6ff0e56d7d037e937b9202b6783a sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_register_relation</refname>
  <refpurpose>make an ephemeral named relation available by name in SPI queries</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_register_relation</refname>
  <refpurpose>make an ephemeral named relation available by name in SPI queries</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=17cf6ff0e56d7d037e937b9202b6783a -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=912af4e143690db601974c27c548521d sig_cn_org=None source=14.1 
<synopsis>
int SPI_register_relation(EphemeralNamedRelation <parameter>enr</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
int SPI_register_relation(EphemeralNamedRelation <parameter>enr</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=912af4e143690db601974c27c548521d -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=88860a4cbc71c5782c805463ef3e5c7d sig_cn_org=None source=14.1 
  <para>
   <function>SPI_register_relation</function> makes an ephemeral named
   relation, with associated information, available to queries planned and
   executed through the current SPI connection.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_register_relation</function>用相关信息建立一个短暂的命名关系，它对通过当前SPI连接规划和执行的查询可用。
  </para>
<!-- pgdoc-cn_end sig_en=88860a4cbc71c5782c805463ef3e5c7d -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>EphemeralNamedRelation <parameter>enr</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=7abf718fd3702eb10d44790099696412 sig_cn_org=None source=14.1 
     <para>
      the ephemeral named relation registry entry
     </para>
________________________________________________________-->
     <para>
      短暂的命名关系的注册项
     </para>
<!-- pgdoc-cn_end sig_en=7abf718fd3702eb10d44790099696412 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=71ff7e5e5d7b12b411acede52243c093 sig_cn_org=None source=14.1 
  <para>
   If the execution of the command was successful then the following
   (nonnegative) value will be returned:

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_OK_REL_REGISTER</symbol></term>
     <listitem>
      <para>
       if the relation has been successfully registered by name
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   如果该命令的执行成功，则将返回下列（非负）值：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_OK_REL_REGISTER</symbol></term>
     <listitem>
      <para>
       如果该关系已经成功地用名称注册
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=71ff7e5e5d7b12b411acede52243c093 -->

<!-- pgdoc-cn_start sig_en=fc090bed835566451831046d7b83180b sig_cn_org=None source=14.1 
  <para>
   On error, one of the following negative values is returned:

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       if <parameter>enr</parameter> is <symbol>NULL</symbol> or its
       <varname>name</varname> field is <symbol>NULL</symbol>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       if called from an unconnected C function
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_REL_DUPLICATE</symbol></term>
     <listitem>
      <para>
       if the name specified in the <varname>name</varname> field of
       <parameter>enr</parameter> is already registered for this connection
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   在出错时，会返回下列负值之一：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       如果<parameter>enr</parameter>是<symbol>NULL</symbol>或者其<varname>name</varname>字段是<symbol>NULL</symbol>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       如果从一个未连接的C函数中调用
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_REL_DUPLICATE</symbol></term>
     <listitem>
      <para>
       如果<parameter>enr</parameter>的<varname>name</varname>字段中指定的名称已经为这个连接注册
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=fc090bed835566451831046d7b83180b -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-unregister-relation">
<!-- pgdoc-cn_start sig_en=3aeb320be8004f2ab9d6730eff30b0cd sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_unregister_relation</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_unregister_relation</primary></indexterm>
<!-- pgdoc-cn_end sig_en=3aeb320be8004f2ab9d6730eff30b0cd -->

<!-- pgdoc-cn_start sig_en=5a824ffe246d1161bf87d18f0775d71d sig_cn_org=None source=14.1 
 <indexterm>
  <primary>ephemeral named relation</primary>
  <secondary>unregistering from SPI</secondary>
 </indexterm>
________________________________________________________-->
 <indexterm>
  <primary>ephemeral named relation</primary>
  <secondary>unregistering from SPI</secondary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=5a824ffe246d1161bf87d18f0775d71d -->

 <refmeta>
  <refentrytitle>SPI_unregister_relation</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=2b94f083330737444b887d438c1744b4 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_unregister_relation</refname>
  <refpurpose>remove an ephemeral named relation from the registry</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_unregister_relation</refname>
  <refpurpose>remove an ephemeral named relation from the registry</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=2b94f083330737444b887d438c1744b4 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=fbabaf563d93842cb75360d908928b44 sig_cn_org=None source=14.1 
<synopsis>
int SPI_unregister_relation(const char * <parameter>name</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
int SPI_unregister_relation(const char * <parameter>name</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=fbabaf563d93842cb75360d908928b44 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=a4cdf5e06183b060a87d4475e92efcb1 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_unregister_relation</function> removes an ephemeral named
   relation from the registry for the current connection.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_unregister_relation</function>从当前连接的注册项中移除一个短暂存在的关系。
  </para>
<!-- pgdoc-cn_end sig_en=a4cdf5e06183b060a87d4475e92efcb1 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>const char * <parameter>name</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=51c976b79f0db4da8351be69ac59508a sig_cn_org=None source=14.1 
     <para>
      the relation registry entry name
     </para>
________________________________________________________-->
     <para>
      关系的注册项名称
     </para>
<!-- pgdoc-cn_end sig_en=51c976b79f0db4da8351be69ac59508a -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=1d32addfcfc19131e553ac84e0596cfd sig_cn_org=None source=14.1 
  <para>
   If the execution of the command was successful then the following
   (nonnegative) value will be returned:

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_OK_REL_UNREGISTER</symbol></term>
     <listitem>
      <para>
       if the tuplestore has been successfully removed from the registry
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   如果该命令的执行成功，则会返回下列（非负）值：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_OK_REL_UNREGISTER</symbol></term>
     <listitem>
      <para>
       如果tuplestore已经被成功地从注册项中移除
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=1d32addfcfc19131e553ac84e0596cfd -->

<!-- pgdoc-cn_start sig_en=05c29e5018ee736368698f5c9b21690f sig_cn_org=None source=14.1 
  <para>
   On error, one of the following negative values is returned:

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       if <parameter>name</parameter> is <symbol>NULL</symbol>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       if called from an unconnected C function
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_REL_NOT_FOUND</symbol></term>
     <listitem>
      <para>
       if <parameter>name</parameter> is not found in the registry for the
       current connection
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   出现错误时，会返回下列负值之一：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       如果<parameter>name</parameter>为<symbol>NULL</symbol>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       如果从一个未连接的C函数中调用
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_REL_NOT_FOUND</symbol></term>
     <listitem>
      <para>
       如果没有在当前连接的注册项中找到<parameter>name</parameter>
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=05c29e5018ee736368698f5c9b21690f -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-register-trigger-data">
<!-- pgdoc-cn_start sig_en=d85b6650d851f69f2d03ce3bf730f468 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_register_trigger_data</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_register_trigger_data</primary></indexterm>
<!-- pgdoc-cn_end sig_en=d85b6650d851f69f2d03ce3bf730f468 -->

<!-- pgdoc-cn_start sig_en=3f3e8ae9a80850bb58c883ed6e862086 sig_cn_org=None source=14.1 
 <indexterm>
  <primary>ephemeral named relation</primary>
  <secondary>registering with SPI</secondary>
 </indexterm>
________________________________________________________-->
 <indexterm>
  <primary>ephemeral named relation</primary>
  <secondary>registering with SPI</secondary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=3f3e8ae9a80850bb58c883ed6e862086 -->

<!-- pgdoc-cn_start sig_en=208d9098ff23ec0e9a7b0c1242e672a3 sig_cn_org=None source=14.1 
 <indexterm>
  <primary>transition tables</primary>
  <secondary>implementation in PLs</secondary>
 </indexterm>
________________________________________________________-->
 <indexterm>
  <primary>transition tables</primary>
  <secondary>implementation in PLs</secondary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=208d9098ff23ec0e9a7b0c1242e672a3 -->

 <refmeta>
  <refentrytitle>SPI_register_trigger_data</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=fff8114e26628e4296e37fe3a027523f sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_register_trigger_data</refname>
  <refpurpose>make ephemeral trigger data available in SPI queries</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_register_trigger_data</refname>
  <refpurpose>make ephemeral trigger data available in SPI queries</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=fff8114e26628e4296e37fe3a027523f -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=f0b99fa28fc1d94d46e80292302143b6 sig_cn_org=None source=14.1 
<synopsis>
int SPI_register_trigger_data(TriggerData *<parameter>tdata</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
int SPI_register_trigger_data(TriggerData *<parameter>tdata</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=f0b99fa28fc1d94d46e80292302143b6 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=a2929ea1931ecab5e6f8d37bae3bcaa0 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_register_trigger_data</function> makes any ephemeral
   relations captured by a trigger available to queries planned and executed
   through the current SPI connection.  Currently, this means the transition
   tables captured by an <literal>AFTER</literal> trigger defined with a
   <literal>REFERENCING OLD/NEW TABLE AS</literal> ... clause.  This function
   should be called by a PL trigger handler function after connecting.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_register_trigger_data</function>会造出被触发器捕获的任何短暂存在的关系，它们对通过当前SPI连接规划和执行的查询可用。当前，这表示用<literal>REFERENCING OLD/NEW TABLE AS</literal> ... 子句定义的被<literal>AFTER</literal>触发器捕获的传递表。这个函数应该被一个PL触发器的处理器函数在连接之后调用。
  </para>
<!-- pgdoc-cn_end sig_en=a2929ea1931ecab5e6f8d37bae3bcaa0 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>TriggerData *<parameter>tdata</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=3e440bb84011c4bb10dea2e87c19d077 sig_cn_org=None source=14.1 
     <para>
       the <structname>TriggerData</structname> object passed to a trigger
       handler function as <literal>fcinfo->context</literal>
     </para>
________________________________________________________-->
     <para>
       以<literal>fcinfo->context</literal>传递给触发器处理器函数的<structname>TriggerData</structname>对象
     </para>
<!-- pgdoc-cn_end sig_en=3e440bb84011c4bb10dea2e87c19d077 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=eeafaa7a1907e5a7d961f2055d5869ff sig_cn_org=None source=14.1 
  <para>
   If the execution of the command was successful then the following
   (nonnegative) value will be returned:

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_OK_TD_REGISTER</symbol></term>
     <listitem>
      <para>
       if the captured trigger data (if any) has been successfully registered
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   如果命令的执行成功，则会返回下列（非负）值：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_OK_TD_REGISTER</symbol></term>
     <listitem>
      <para>
       如果被捕获的触发器数据（如果有）已经被成功地注册
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=eeafaa7a1907e5a7d961f2055d5869ff -->

<!-- pgdoc-cn_start sig_en=72ed03b8d53529f361e5002232855878 sig_cn_org=None source=14.1 
  <para>
   On error, one of the following negative values is returned:

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       if <parameter>tdata</parameter> is <symbol>NULL</symbol>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       if called from an unconnected C function
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_REL_DUPLICATE</symbol></term>
     <listitem>
      <para>
       if the name of any trigger data transient relation is already
       registered for this connection
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   出现错误时，会返回下列负值之一：

   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       如果<parameter>tdata</parameter>为<symbol>NULL</symbol>
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       如果从一个未连接的C函数中调用
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_REL_DUPLICATE</symbol></term>
     <listitem>
      <para>
       如果任何触发器数据瞬时关系的名字已经为这个连接注册过
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=72ed03b8d53529f361e5002232855878 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

</sect1>

<sect1 id="spi-interface-support">
<!-- pgdoc-cn_start sig_en=b4993e7ce7bfa3cac9b5b6f84b60eb6b sig_cn_org=None source=14.1 
 <title>Interface Support Functions</title>
________________________________________________________-->
 <title>接口支持函数</title>
<!-- pgdoc-cn_end sig_en=b4993e7ce7bfa3cac9b5b6f84b60eb6b -->

<!-- pgdoc-cn_start sig_en=64bb0c6e11a911adc09aaeb80079e5fa sig_cn_org=None source=14.1 
 <para>
  The functions described here provide an interface for extracting
  information from result sets returned by <function>SPI_execute</function> and
  other SPI functions.
 </para>
________________________________________________________-->
 <para>
  这里描述的函数提供了一个接口从<function>SPI_execute</function>
  及其他 SPI 函数返回的结果集中抽取信息。
 </para>
<!-- pgdoc-cn_end sig_en=64bb0c6e11a911adc09aaeb80079e5fa -->

<!-- pgdoc-cn_start sig_en=6551f5ddd0ebed6bffd1026bb2031a1c sig_cn_org=None source=14.1 
 <para>
  All functions described in this section can be used by both
  connected and unconnected C functions.
 </para>
________________________________________________________-->
 <para>
  这一小节中描述的所有函数都可以被用在已连接和未连接的C函数中。
 </para>
<!-- pgdoc-cn_end sig_en=6551f5ddd0ebed6bffd1026bb2031a1c -->

<!-- *********************************************** -->

<refentry id="spi-spi-fname">
<!-- pgdoc-cn_start sig_en=d3245dd1634abf9438973e989f23395e sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_fname</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_fname</primary></indexterm>
<!-- pgdoc-cn_end sig_en=d3245dd1634abf9438973e989f23395e -->

 <refmeta>
  <refentrytitle>SPI_fname</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=5ff2b034874911caf99ae27a24fb6fc5 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_fname</refname>
  <refpurpose>determine the column name for the specified column number</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_fname</refname>
  <refpurpose>为指定的列号确定列名</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=5ff2b034874911caf99ae27a24fb6fc5 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=ed2928f830cf86ae4e336c35d58acd35 sig_cn_org=None source=14.1 
<synopsis>
char * SPI_fname(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
char * SPI_fname(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=ed2928f830cf86ae4e336c35d58acd35 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=578830b436643d95716b5f71dd2bf56f sig_cn_org=None source=14.1 
  <para>
   <function>SPI_fname</function> returns a copy of the column name of the
   specified column.  (You can use <function>pfree</function> to
   release the copy of the name when you don't need it anymore.)
  </para>
________________________________________________________-->
  <para>
   <function>SPI_fname</function>返回一个指定列的列名的拷贝（
   当你不再需要该列名拷贝后，可以使用<function>pfree</function>
   释放它）。
  </para>
<!-- pgdoc-cn_end sig_en=578830b436643d95716b5f71dd2bf56f -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=5e370e0a469e531af155dfdb065e24aa sig_cn_org=None source=14.1 
     <para>
      input row description
     </para>
________________________________________________________-->
     <para>
      输入行描述
     </para>
<!-- pgdoc-cn_end sig_en=5e370e0a469e531af155dfdb065e24aa -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=6878732be17618670d3000e56a2ca715 sig_cn_org=None source=14.1 
     <para>
      column number (count starts at 1)
     </para>
________________________________________________________-->
     <para>
      列号（从 1 开始计）
     </para>
<!-- pgdoc-cn_end sig_en=6878732be17618670d3000e56a2ca715 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=cde58dc400cb78e9056aada49e1e6926 sig_cn_org=None source=14.1 
  <para>
   The column name; <symbol>NULL</symbol> if
   <parameter>colnumber</parameter> is out of range.
   <varname>SPI_result</varname> set to
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol> on error.
  </para>
________________________________________________________-->
  <para>
   列名；如果<parameter>colnumber</parameter>超出范围则返回
   <symbol>NULL</symbol>。出错时
   <varname>SPI_result</varname>会被设置成
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>。
  </para>
<!-- pgdoc-cn_end sig_en=cde58dc400cb78e9056aada49e1e6926 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-fnumber">
<!-- pgdoc-cn_start sig_en=af7c9f89ba220bac5cdb2cbcf971012b sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_fnumber</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_fnumber</primary></indexterm>
<!-- pgdoc-cn_end sig_en=af7c9f89ba220bac5cdb2cbcf971012b -->

 <refmeta>
  <refentrytitle>SPI_fnumber</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=b68261e16eb2d38711b3f76b307b499e sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_fnumber</refname>
  <refpurpose>determine the column number for the specified column name</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_fnumber</refname>
  <refpurpose>为一个指定的列名确定列号</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=b68261e16eb2d38711b3f76b307b499e -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=a2445c3a86e9f988aeba29571dd4e010 sig_cn_org=None source=14.1 
<synopsis>
int SPI_fnumber(TupleDesc <parameter>rowdesc</parameter>, const char * <parameter>colname</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
int SPI_fnumber(TupleDesc <parameter>rowdesc</parameter>, const char * <parameter>colname</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=a2445c3a86e9f988aeba29571dd4e010 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=20ac6fb0a3ddde9b7f04b9e6c31ed6aa sig_cn_org=None source=14.1 
  <para>
   <function>SPI_fnumber</function> returns the column number for the
   column with the specified name.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_fnumber</function>返回指定列名的列号。
  </para>
<!-- pgdoc-cn_end sig_en=20ac6fb0a3ddde9b7f04b9e6c31ed6aa -->

<!-- pgdoc-cn_start sig_en=16a675f0146e5f5a4842fb65e1cd86d3 sig_cn_org=None source=14.1 
  <para>
   If <parameter>colname</parameter> refers to a system column (e.g.,
   <literal>ctid</literal>) then the appropriate negative column number will
   be returned.  The caller should be careful to test the return value
   for exact equality to <symbol>SPI_ERROR_NOATTRIBUTE</symbol> to
   detect an error; testing the result for less than or equal to 0 is
   not correct unless system columns should be rejected.
  </para>
________________________________________________________-->
  <para>
   如果<parameter>colname</parameter>引用的是一个系统列（例如，
   <literal>ctid</literal>），那么将返回对应的负值列号。调用者应该小心地测试
   返回值是不是正好为<symbol>SPI_ERROR_NOATTRIBUTE</symbol>
   来检测错误；除非系统列应该被拒绝，测试结果是否小于或者等于零这种
   方式是不正确的。
  </para>
<!-- pgdoc-cn_end sig_en=16a675f0146e5f5a4842fb65e1cd86d3 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=5e370e0a469e531af155dfdb065e24aa sig_cn_org=None source=14.1 
     <para>
      input row description
     </para>
________________________________________________________-->
     <para>
      输入行描述
     </para>
<!-- pgdoc-cn_end sig_en=5e370e0a469e531af155dfdb065e24aa -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>colname</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=40eeefd9c79639861b9e7617be82d258 sig_cn_org=None source=14.1 
     <para>
      column name
     </para>
________________________________________________________-->
     <para>
      列名
     </para>
<!-- pgdoc-cn_end sig_en=40eeefd9c79639861b9e7617be82d258 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=dc235efe5396dac72d68564d38675136 sig_cn_org=None source=14.1 
  <para>
   Column number (count starts at 1 for user-defined columns), or
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol> if the named column was not
   found.
  </para>
________________________________________________________-->
  <para>
   列号（用户定义的列从1开始计），如果没有找到所提到的列名则返回
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>。
  </para>
<!-- pgdoc-cn_end sig_en=dc235efe5396dac72d68564d38675136 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getvalue">
<!-- pgdoc-cn_start sig_en=0ab5bf2335ccc4b1bb5000da94b35dc1 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_getvalue</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_getvalue</primary></indexterm>
<!-- pgdoc-cn_end sig_en=0ab5bf2335ccc4b1bb5000da94b35dc1 -->

 <refmeta>
  <refentrytitle>SPI_getvalue</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=c16d6056280762786e9cd730d1389f2c sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_getvalue</refname>
  <refpurpose>return the string value of the specified column</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_getvalue</refname>
  <refpurpose>返回指定列的字符串值</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=c16d6056280762786e9cd730d1389f2c -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=5075c768a36ab6cb5cf2e1191b857b2a sig_cn_org=None source=14.1 
<synopsis>
char * SPI_getvalue(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
char * SPI_getvalue(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=5075c768a36ab6cb5cf2e1191b857b2a -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=dd982501c7a0f32f633516ef3318e695 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_getvalue</function> returns the string representation
   of the value of the specified column.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_getvalue</function>返回指定列的值的字符串表示。
  </para>
<!-- pgdoc-cn_end sig_en=dd982501c7a0f32f633516ef3318e695 -->

<!-- pgdoc-cn_start sig_en=420473e5ce3ad9f80fe99ff450f02bc3 sig_cn_org=None source=14.1 
  <para>
   The result is returned in memory allocated using
   <function>palloc</function>.  (You can use
   <function>pfree</function> to release the memory when you don't
   need it anymore.)
  </para>
________________________________________________________-->
  <para>
   结果在使用<function>palloc</function>分配的内存中返回（当你不再
   需要该结果时，你可以使用<function>pfree</function>释放该内存）。
  </para>
<!-- pgdoc-cn_end sig_en=420473e5ce3ad9f80fe99ff450f02bc3 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=1cd83a0f8f9237390267e7b99e7a3e7f sig_cn_org=None source=14.1 
     <para>
      input row to be examined
     </para>
________________________________________________________-->
     <para>
      要检查的输入行
     </para>
<!-- pgdoc-cn_end sig_en=1cd83a0f8f9237390267e7b99e7a3e7f -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=5e370e0a469e531af155dfdb065e24aa sig_cn_org=None source=14.1 
     <para>
      input row description
     </para>
________________________________________________________-->
     <para>
      输入行描述
     </para>
<!-- pgdoc-cn_end sig_en=5e370e0a469e531af155dfdb065e24aa -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=6878732be17618670d3000e56a2ca715 sig_cn_org=None source=14.1 
     <para>
      column number (count starts at 1)
     </para>
________________________________________________________-->
     <para>
      列号（从 1 开始计）
     </para>
<!-- pgdoc-cn_end sig_en=6878732be17618670d3000e56a2ca715 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=73e4f0086fda10f487d731bbbd3e5c9e sig_cn_org=None source=14.1 
  <para>
   Column value, or <symbol>NULL</symbol> if the column is null,
   <parameter>colnumber</parameter> is out of range
   (<varname>SPI_result</varname> is set to
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>), or no output function is
   available (<varname>SPI_result</varname> is set to
   <symbol>SPI_ERROR_NOOUTFUNC</symbol>).
  </para>
________________________________________________________-->
  <para>
   列值，如果列为空值、<parameter>colnumber</parameter>超出范围
   （<varname>SPI_result</varname>被设置为
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>）或者没有输出函数
   可用（<varname>SPI_result</varname>被设置为
   <symbol>SPI_ERROR_NOOUTFUNC</symbol>）则返回
   <symbol>NULL</symbol>。
  </para>
<!-- pgdoc-cn_end sig_en=73e4f0086fda10f487d731bbbd3e5c9e -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getbinval">
<!-- pgdoc-cn_start sig_en=baa67842f8cfd08859c2fb0cf34508a6 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_getbinval</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_getbinval</primary></indexterm>
<!-- pgdoc-cn_end sig_en=baa67842f8cfd08859c2fb0cf34508a6 -->

 <refmeta>
  <refentrytitle>SPI_getbinval</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=035969e7bc4999ffd5f4487bf6b32d89 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_getbinval</refname>
  <refpurpose>return the binary value of the specified column</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_getbinval</refname>
  <refpurpose>返回指定列的二进制值</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=035969e7bc4999ffd5f4487bf6b32d89 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=8e504396f73ed0af5ea1cacf32eb01c1 sig_cn_org=None source=14.1 
<synopsis>
Datum SPI_getbinval(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>,
                    bool * <parameter>isnull</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
Datum SPI_getbinval(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>,
                    bool * <parameter>isnull</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=8e504396f73ed0af5ea1cacf32eb01c1 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=8c47df5cd1d0c9d3f35267fbfe16d9bc sig_cn_org=None source=14.1 
  <para>
   <function>SPI_getbinval</function> returns the value of the
   specified column in the internal form (as type <type>Datum</type>).
  </para>
________________________________________________________-->
  <para>
   <function>SPI_getbinval</function>以内部格
   式（以<type>Datum</type>类型）返回指定列的值。
  </para>
<!-- pgdoc-cn_end sig_en=8c47df5cd1d0c9d3f35267fbfe16d9bc -->

<!-- pgdoc-cn_start sig_en=a2b2bf4292eab755399fe7e7dfa662a7 sig_cn_org=None source=14.1 
  <para>
   This function does not allocate new space for the datum.  In the
   case of a pass-by-reference data type, the return value will be a
   pointer into the passed row.
  </para>
________________________________________________________-->
  <para>
   这个函数不会为该 datum 分配新空间。在传引用数据类型的情况下，
   返回值将是一个被传递行的指针。
  </para>
<!-- pgdoc-cn_end sig_en=a2b2bf4292eab755399fe7e7dfa662a7 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=1cd83a0f8f9237390267e7b99e7a3e7f sig_cn_org=None source=14.1 
     <para>
      input row to be examined
     </para>
________________________________________________________-->
     <para>
      要检查的输入行
     </para>
<!-- pgdoc-cn_end sig_en=1cd83a0f8f9237390267e7b99e7a3e7f -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=5e370e0a469e531af155dfdb065e24aa sig_cn_org=None source=14.1 
     <para>
      input row description
     </para>
________________________________________________________-->
     <para>
      输入行描述
     </para>
<!-- pgdoc-cn_end sig_en=5e370e0a469e531af155dfdb065e24aa -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=6878732be17618670d3000e56a2ca715 sig_cn_org=None source=14.1 
     <para>
      column number (count starts at 1)
     </para>
________________________________________________________-->
     <para>
      列号（从 1 开始计）
     </para>
<!-- pgdoc-cn_end sig_en=6878732be17618670d3000e56a2ca715 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>bool * <parameter>isnull</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=41451dd74ce66f812a5d7cb7f9fb0b19 sig_cn_org=None source=14.1 
     <para>
      flag for a null value in the column
     </para>
________________________________________________________-->
     <para>
      列中是否为空值的标志
     </para>
<!-- pgdoc-cn_end sig_en=41451dd74ce66f812a5d7cb7f9fb0b19 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=51b94dc46b6099574531b48a93679547 sig_cn_org=None source=14.1 
  <para>
   The binary value of the column is returned.  The variable pointed
   to by <parameter>isnull</parameter> is set to true if the column is
   null, else to false.
  </para>
________________________________________________________-->
  <para>
   该列的二进制值会被返回。如果该列为空值，由<parameter>isnull</parameter>
   指向的变量将被设置为真，否则会被设置为假。
  </para>
<!-- pgdoc-cn_end sig_en=51b94dc46b6099574531b48a93679547 -->

<!-- pgdoc-cn_start sig_en=8d32f70d41d9a0c4efeb5d5f03fe97fe sig_cn_org=None source=14.1 
  <para>
   <varname>SPI_result</varname> is set to
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol> on error.
  </para>
________________________________________________________-->
  <para>
   错误时<varname>SPI_result</varname>会被设置成
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>。
  </para>
<!-- pgdoc-cn_end sig_en=8d32f70d41d9a0c4efeb5d5f03fe97fe -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-gettype">
<!-- pgdoc-cn_start sig_en=9366139746200b317df6afb0f9c3d85c sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_gettype</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_gettype</primary></indexterm>
<!-- pgdoc-cn_end sig_en=9366139746200b317df6afb0f9c3d85c -->

 <refmeta>
  <refentrytitle>SPI_gettype</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=520d511c31cde90448cb780db938103c sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_gettype</refname>
  <refpurpose>return the data type name of the specified column</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_gettype</refname>
  <refpurpose>返回指定列的数据类型名称</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=520d511c31cde90448cb780db938103c -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=e785ec385e32a23c27f00a0586528b53 sig_cn_org=None source=14.1 
<synopsis>
char * SPI_gettype(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
char * SPI_gettype(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=e785ec385e32a23c27f00a0586528b53 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=7d19609508320efb57b1d0940ff8d271 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_gettype</function> returns a copy of the data type name of the
   specified column.  (You can use <function>pfree</function> to
   release the copy of the name when you don't need it anymore.)
  </para>
________________________________________________________-->
  <para>
   <function>SPI_gettype</function>返回该指定列的数据类型名称
   的拷贝（当你不再需要该拷贝后，可以使用<function>pfree</function>
   释放它）。
  </para>
<!-- pgdoc-cn_end sig_en=7d19609508320efb57b1d0940ff8d271 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=5e370e0a469e531af155dfdb065e24aa sig_cn_org=None source=14.1 
     <para>
      input row description
     </para>
________________________________________________________-->
     <para>
      输入行描述
     </para>
<!-- pgdoc-cn_end sig_en=5e370e0a469e531af155dfdb065e24aa -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=6878732be17618670d3000e56a2ca715 sig_cn_org=None source=14.1 
     <para>
      column number (count starts at 1)
     </para>
________________________________________________________-->
     <para>
      列号（从 1 开始计）
     </para>
<!-- pgdoc-cn_end sig_en=6878732be17618670d3000e56a2ca715 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=c043e295101c8d8d9344e637f4baa520 sig_cn_org=None source=14.1 
  <para>
   The data type name of the specified column, or
   <symbol>NULL</symbol> on error.  <varname>SPI_result</varname> is
   set to <symbol>SPI_ERROR_NOATTRIBUTE</symbol> on error.
  </para>
________________________________________________________-->
  <para>
   指定列的数据类型名称，或者在错误时返回<symbol>NULL</symbol>。
   错误时<varname>SPI_result</varname>会被设置成
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>。
  </para>
<!-- pgdoc-cn_end sig_en=c043e295101c8d8d9344e637f4baa520 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-gettypeid">
<!-- pgdoc-cn_start sig_en=d7dcb62b69774170ebd2fb5e5f0cdfb1 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_gettypeid</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_gettypeid</primary></indexterm>
<!-- pgdoc-cn_end sig_en=d7dcb62b69774170ebd2fb5e5f0cdfb1 -->

 <refmeta>
  <refentrytitle>SPI_gettypeid</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=16de3b2b8e9936b2a090702057343fdd sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_gettypeid</refname>
  <refpurpose>return the data type <acronym>OID</acronym> of the specified column</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_gettypeid</refname>
  <refpurpose>返回指定列的数据类型的<acronym>OID</acronym></refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=16de3b2b8e9936b2a090702057343fdd -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=c0f3e7e04b1a05d079e888e08c0a8bc3 sig_cn_org=None source=14.1 
<synopsis>
Oid SPI_gettypeid(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
Oid SPI_gettypeid(TupleDesc <parameter>rowdesc</parameter>, int <parameter>colnumber</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=c0f3e7e04b1a05d079e888e08c0a8bc3 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=531aa049894154010a9eae5746219719 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_gettypeid</function> returns the
   <acronym>OID</acronym> of the data type of the specified column.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_gettypeid</function>返回该指定列的数据类型的
   <acronym>OID</acronym>。
  </para>
<!-- pgdoc-cn_end sig_en=531aa049894154010a9eae5746219719 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=5e370e0a469e531af155dfdb065e24aa sig_cn_org=None source=14.1 
     <para>
      input row description
     </para>
________________________________________________________-->
     <para>
      输入行描述
     </para>
<!-- pgdoc-cn_end sig_en=5e370e0a469e531af155dfdb065e24aa -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>colnumber</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=6878732be17618670d3000e56a2ca715 sig_cn_org=None source=14.1 
     <para>
      column number (count starts at 1)
     </para>
________________________________________________________-->
     <para>
      列号（从 1 开始计）
     </para>
<!-- pgdoc-cn_end sig_en=6878732be17618670d3000e56a2ca715 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=025ec68216a531542837672048a862a5 sig_cn_org=None source=14.1 
  <para>
   The <acronym>OID</acronym> of the data type of the specified column
   or <symbol>InvalidOid</symbol> on error.  On error,
   <varname>SPI_result</varname> is set to
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>.
  </para>
________________________________________________________-->
  <para>
   指定列的数据类型的<acronym>OID</acronym>，或者出错时返回
   <symbol>InvalidOid</symbol>。出错时，
   <varname>SPI_result</varname>会被设置成
   <symbol>SPI_ERROR_NOATTRIBUTE</symbol>。
  </para>
<!-- pgdoc-cn_end sig_en=025ec68216a531542837672048a862a5 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-getrelname">
<!-- pgdoc-cn_start sig_en=28531874a9598c4bf6dc332b91889485 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_getrelname</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_getrelname</primary></indexterm>
<!-- pgdoc-cn_end sig_en=28531874a9598c4bf6dc332b91889485 -->

 <refmeta>
  <refentrytitle>SPI_getrelname</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=a70696164c4e0bf6e4e54f39e042710e sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_getrelname</refname>
  <refpurpose>return the name of the specified relation</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_getrelname</refname>
  <refpurpose>返回指定关系的名称</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=a70696164c4e0bf6e4e54f39e042710e -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=8f33b698452596471ddd706837d71a1f sig_cn_org=None source=14.1 
<synopsis>
char * SPI_getrelname(Relation <parameter>rel</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
char * SPI_getrelname(Relation <parameter>rel</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=8f33b698452596471ddd706837d71a1f -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=06c4c091aa03411cb38e2a9015c19d25 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_getrelname</function> returns a copy of the name of the
   specified relation.  (You can use <function>pfree</function> to
   release the copy of the name when you don't need it anymore.)
  </para>
________________________________________________________-->
  <para>
   <function>SPI_getrelname</function>返回该指定关系的名称
   的拷贝（当你不再需要该拷贝后，可以使用<function>pfree</function>
   释放它）。
  </para>
<!-- pgdoc-cn_end sig_en=06c4c091aa03411cb38e2a9015c19d25 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>Relation <parameter>rel</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=abda2d778bff774b485c760e32fe2b69 sig_cn_org=None source=14.1 
     <para>
      input relation
     </para>
________________________________________________________-->
     <para>
      输入关系
     </para>
<!-- pgdoc-cn_end sig_en=abda2d778bff774b485c760e32fe2b69 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=684cad35defdcaacdf939ff74d456640 sig_cn_org=None source=14.1 
  <para>
   The name of the specified relation.
  </para>
________________________________________________________-->
  <para>
   指定关系的名称。
  </para>
<!-- pgdoc-cn_end sig_en=684cad35defdcaacdf939ff74d456640 -->
 </refsect1>
</refentry>

<refentry id="spi-spi-getnspname">
<!-- pgdoc-cn_start sig_en=f9db696747755531bd7f0dff656ffbe7 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_getnspname</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_getnspname</primary></indexterm>
<!-- pgdoc-cn_end sig_en=f9db696747755531bd7f0dff656ffbe7 -->

 <refmeta>
  <refentrytitle>SPI_getnspname</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=2e87534716edc2fbee5fefd617fd3284 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_getnspname</refname>
  <refpurpose>return the namespace of the specified relation</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_getnspname</refname>
  <refpurpose>返回指定关系的名字空间</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=2e87534716edc2fbee5fefd617fd3284 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=3acd81717a2242e9fe4f1c7da693fa26 sig_cn_org=None source=14.1 
<synopsis>
char * SPI_getnspname(Relation <parameter>rel</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
char * SPI_getnspname(Relation <parameter>rel</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=3acd81717a2242e9fe4f1c7da693fa26 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=f8becfc736b581d08f30ee24c2c460cd sig_cn_org=None source=14.1 
  <para>
   <function>SPI_getnspname</function> returns a copy of the name of
   the namespace that the specified <structname>Relation</structname>
   belongs to. This is equivalent to the relation's schema. You should
   <function>pfree</function> the return value of this function when
   you are finished with it.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_getnspname</function>返回指定
   <structname>关系</structname>所属的名字空间的名称拷贝。这等效
   于该关系的模式。当你用完这个函数的返回值后，应该调用
   <function>pfree</function>释放它。
  </para>
<!-- pgdoc-cn_end sig_en=f8becfc736b581d08f30ee24c2c460cd -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>Relation <parameter>rel</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=abda2d778bff774b485c760e32fe2b69 sig_cn_org=None source=14.1 
     <para>
      input relation
     </para>
________________________________________________________-->
     <para>
      输入关系
     </para>
<!-- pgdoc-cn_end sig_en=abda2d778bff774b485c760e32fe2b69 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=2e1e8ff531d0851053d864416436633f sig_cn_org=None source=14.1 
  <para>
   The name of the specified relation's namespace.
  </para>
________________________________________________________-->
  <para>
   指定关系的名字空间的名称。
  </para>
<!-- pgdoc-cn_end sig_en=2e1e8ff531d0851053d864416436633f -->
 </refsect1>
</refentry>

<refentry id="spi-spi-result-code-string">
<!-- pgdoc-cn_start sig_en=7764e647cd31ca5a107b0d28263e811a sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_result_code_string</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_result_code_string</primary></indexterm>
<!-- pgdoc-cn_end sig_en=7764e647cd31ca5a107b0d28263e811a -->

 <refmeta>
  <refentrytitle>SPI_result_code_string</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=94236f475b6ef2a9b28063c8d4650b1e sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_result_code_string</refname>
  <refpurpose>return error code as string</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_result_code_string</refname>
  <refpurpose>return error code as string</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=94236f475b6ef2a9b28063c8d4650b1e -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=d032b60a924686a73699b258322438cf sig_cn_org=None source=14.1 
<synopsis>
const char * SPI_result_code_string(int <parameter>code</parameter>);
</synopsis>
________________________________________________________-->
<synopsis>
const char * SPI_result_code_string(int <parameter>code</parameter>);
</synopsis>
<!-- pgdoc-cn_end sig_en=d032b60a924686a73699b258322438cf -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=6a41e52b185dd0026afc5bd7501cf616 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_result_code_string</function> returns a string representation
   of the result code returned by various SPI functions or stored
   in <varname>SPI_result</varname>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_result_code_string</function>返回之前各种SPI函数返回的或者存储在<varname>SPI_result</varname>中的结果代码的字符串表示。
  </para>
<!-- pgdoc-cn_end sig_en=6a41e52b185dd0026afc5bd7501cf616 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>int <parameter>code</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=529c4743406ec08a64517fa22ac3d5bf sig_cn_org=None source=14.1 
     <para>
      result code
     </para>
________________________________________________________-->
     <para>
      结果代码
     </para>
<!-- pgdoc-cn_end sig_en=529c4743406ec08a64517fa22ac3d5bf -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=f35749d644c23c87958fc44da0e879d4 sig_cn_org=None source=14.1 
  <para>
   A string representation of the result code.
  </para>
________________________________________________________-->
  <para>
   结果代码的字符串表示。
  </para>
<!-- pgdoc-cn_end sig_en=f35749d644c23c87958fc44da0e879d4 -->
 </refsect1>
</refentry>

 </sect1>

 <sect1 id="spi-memory">
<!-- pgdoc-cn_start sig_en=d50be6f5e3895ba6e13965719f109a90 sig_cn_org=None source=14.1 
  <title>Memory Management</title>
________________________________________________________-->
  <title>内存管理</title>
<!-- pgdoc-cn_end sig_en=d50be6f5e3895ba6e13965719f109a90 -->

<!-- pgdoc-cn_start sig_en=ba0107ebfb04a183cdf7ad67fd14c592 sig_cn_org=None source=14.1 
  <para>
    <indexterm>
     <primary>memory context</primary>
     <secondary>in SPI</secondary>
    </indexterm>
   <productname>PostgreSQL</productname> allocates memory within
   <firstterm>memory contexts</firstterm>, which provide a convenient method of
   managing allocations made in many different places that need to
   live for differing amounts of time.  Destroying a context releases
   all the memory that was allocated in it.  Thus, it is not necessary
   to keep track of individual objects to avoid memory leaks; instead
   only a relatively small number of contexts have to be managed.
   <function>palloc</function> and related functions allocate memory
   from the <quote>current</quote> context.
  </para>
________________________________________________________-->
  <para>
    <indexterm>
     <primary>memory context</primary>
     <secondary>in SPI</secondary>
    </indexterm>
   <productname>PostgreSQL</productname>
   在<firstterm>内存上下文</firstterm>中分配内存，内存上下文为管理
   在多个不同位置、具有不同生存时间需要的分配提供了一种便捷的方法。
   销毁一个上下文会释放所有在其中分配的内存。因此不必跟踪单个对象来
   避免内存泄露，而是只需要管理数量相对较少的上下文即可。
   <function>palloc</function>和相关的函数可以从<quote>当前</quote>
   上下文中分配内存。
  </para>
<!-- pgdoc-cn_end sig_en=ba0107ebfb04a183cdf7ad67fd14c592 -->

<!-- pgdoc-cn_start sig_en=724d4b6a5191e171192a6bb93cabc683 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_connect</function> creates a new memory context and
   makes it current.  <function>SPI_finish</function> restores the
   previous current memory context and destroys the context created by
   <function>SPI_connect</function>.  These actions ensure that
   transient memory allocations made inside your C function are
   reclaimed at C function exit, avoiding memory leakage.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_connect</function>创建一个新的内存上下文并且让它
   成为当前上下文。<function>SPI_finish</function>恢复之前的当前上下
   文并且销毁由<function>SPI_connect</function>创建的内存上下文。
   这些动作确保在你的C函数中分配的内存在C函数退出时被回收，从而避免内存
   泄露。
  </para>
<!-- pgdoc-cn_end sig_en=724d4b6a5191e171192a6bb93cabc683 -->

<!-- pgdoc-cn_start sig_en=b9db47bbfd583fdca47c077cb71cb07e sig_cn_org=None source=14.1 
  <para>
   However, if your C function needs to return an object in allocated
   memory (such as a value of a pass-by-reference data type), you
   cannot allocate that memory using <function>palloc</function>, at
   least not while you are connected to SPI.  If you try, the object
   will be deallocated by <function>SPI_finish</function>, and your
   C function will not work reliably.  To solve this problem, use
   <function>SPI_palloc</function> to allocate memory for your return
   object.  <function>SPI_palloc</function> allocates memory in the
   <quote>upper executor context</quote>, that is, the memory context
   that was current when <function>SPI_connect</function> was called,
   which is precisely the right context for a value returned from your
   C function.  Several of the other utility functions described in
   this section also return objects created in the upper executor context.
  </para>
________________________________________________________-->
  <para>
   不过，如果你的C函数需要返回一个在已分配内存中的对象（例如一个
   传引用数据类型的值），你不能使用<function>palloc</function>
   分配内存，或者说至少不能在连接到 SPI 时这样做。如果你试着这样
   做，该对象会被<function>SPI_finish</function>接触分配，那么
   你的C函数将无法可靠地工作。要解决这个问题，应使用
   <function>SPI_palloc</function>来为要返回的对象分配内存。
   <function>SPI_palloc</function>会在
   <quote>上层执行器上下文</quote>中分配内存，也就是当
   <function>SPI_connect</function>被调用时的当前内存上下文，
   它才是从你的C函数中返回的值最适合的上下文。这一节中描述的几个其他实用函数也会返回在上层执行器上下文中创建的对象。
  </para>
<!-- pgdoc-cn_end sig_en=b9db47bbfd583fdca47c077cb71cb07e -->

<!-- pgdoc-cn_start sig_en=91b1eb912ff5e705775c61c5f697d2ee sig_cn_org=None source=14.1 
  <para>
   When <function>SPI_connect</function> is called, the private
   context of the C function, which is created by
   <function>SPI_connect</function>, is made the current context.  All
   allocations made by <function>palloc</function>,
   <function>repalloc</function>, or SPI utility functions (except as
   described in this section) are made in this context.  When a
   C function disconnects from the SPI manager (via
   <function>SPI_finish</function>) the current context is restored to
   the upper executor context, and all allocations made in the
   C function memory context are freed and cannot be used any more.
  </para>
________________________________________________________-->
  <para>
   当<function>SPI_connect</function>被调用时，这个C函数的私有
   上下文（由<function>SPI_connect</function>）会被作为当前上
   下文。所有用<function>palloc</function>、
   <function>repalloc</function>或者 SPI 功能函数（除了这个小节中描述的例外）分配的内存都在这个上下文中。
   当一个C函数从SPI管理器断开连接时（通过
   <function>SPI_finish</function>），当前上下文被恢复到上层的
   执行器上下文，并且在该过程的内存上下文中分配的内存都会被释放，
   之后再不能被使用。
  </para>
<!-- pgdoc-cn_end sig_en=91b1eb912ff5e705775c61c5f697d2ee -->

<!-- *********************************************** -->

<refentry id="spi-spi-palloc">
<!-- pgdoc-cn_start sig_en=4eebbd162d84702dd1e6eaa95f3675f3 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_palloc</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_palloc</primary></indexterm>
<!-- pgdoc-cn_end sig_en=4eebbd162d84702dd1e6eaa95f3675f3 -->

 <refmeta>
  <refentrytitle>SPI_palloc</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=e7b53760e6d5092f4306bb646acecbc3 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_palloc</refname>
  <refpurpose>allocate memory in the upper executor context</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_palloc</refname>
  <refpurpose>在上层执行器上下文中分配内存</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=e7b53760e6d5092f4306bb646acecbc3 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=8cec42ca8ac6a3f98a33a64b4a08f6c5 sig_cn_org=None source=14.1 
<synopsis>
void * SPI_palloc(Size <parameter>size</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
void * SPI_palloc(Size <parameter>size</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=8cec42ca8ac6a3f98a33a64b4a08f6c5 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=777f1802f614fdcda01145b54845584e sig_cn_org=None source=14.1 
  <para>
   <function>SPI_palloc</function> allocates memory in the upper
   executor context.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_palloc</function>在上层的执行器上下文中分配内存。
  </para>
<!-- pgdoc-cn_end sig_en=777f1802f614fdcda01145b54845584e -->

<!-- pgdoc-cn_start sig_en=3a9a070dd04e8e52ae098f2235f4ed82 sig_cn_org=None source=14.1 
  <para>
   This function can only be used while connected to SPI.
   Otherwise, it throws an error.
  </para>
________________________________________________________-->
  <para>
   这个函数只能在连接到SPI时使用。否则，它会报出错误。
  </para>
<!-- pgdoc-cn_end sig_en=3a9a070dd04e8e52ae098f2235f4ed82 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>Size <parameter>size</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=6fb0e4c73bdc052ef741cb6f8e68e750 sig_cn_org=None source=14.1 
     <para>
      size in bytes of storage to allocate
     </para>
________________________________________________________-->
     <para>
      要分配的存储空间大小（以字节计）
     </para>
<!-- pgdoc-cn_end sig_en=6fb0e4c73bdc052ef741cb6f8e68e750 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=b072915ff39e0e35045cfc0da29ef75c sig_cn_org=None source=14.1 
  <para>
   pointer to new storage space of the specified size
  </para>
________________________________________________________-->
  <para>
   指向具有指定大小的新存储空间的指针
  </para>
<!-- pgdoc-cn_end sig_en=b072915ff39e0e35045cfc0da29ef75c -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-realloc">
<!-- pgdoc-cn_start sig_en=0323d38d3ba05d1944d20c914e9721d5 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_repalloc</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_repalloc</primary></indexterm>
<!-- pgdoc-cn_end sig_en=0323d38d3ba05d1944d20c914e9721d5 -->

 <refmeta>
  <refentrytitle>SPI_repalloc</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=53c2ff3efe3a798f3f18f063649e9d07 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_repalloc</refname>
  <refpurpose>reallocate memory in the upper executor context</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_repalloc</refname>
  <refpurpose>在上层执行器上下文中重分配内存</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=53c2ff3efe3a798f3f18f063649e9d07 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=aa9932852659f1dc432ba4ef4e80dda9 sig_cn_org=None source=14.1 
<synopsis>
void * SPI_repalloc(void * <parameter>pointer</parameter>, Size <parameter>size</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
void * SPI_repalloc(void * <parameter>pointer</parameter>, Size <parameter>size</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=aa9932852659f1dc432ba4ef4e80dda9 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=01841840217f89f443d7dff4953eef9c sig_cn_org=None source=14.1 
  <para>
   <function>SPI_repalloc</function> changes the size of a memory
   segment previously allocated using <function>SPI_palloc</function>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_repalloc</function>改变之前用<function>SPI_palloc</function>
   分配的内存段的大小。
  </para>
<!-- pgdoc-cn_end sig_en=01841840217f89f443d7dff4953eef9c -->

<!-- pgdoc-cn_start sig_en=6cfb9b7b08e58de44ee1b336818b7d9d sig_cn_org=None source=14.1 
  <para>
   This function is no longer different from plain
   <function>repalloc</function>.  It's kept just for backward
   compatibility of existing code.
  </para>
________________________________________________________-->
  <para>
   这个函数不再和普通的<function>repalloc</function>相区别。
   保留它只是为了对现有代码保持向后兼容。
  </para>
<!-- pgdoc-cn_end sig_en=6cfb9b7b08e58de44ee1b336818b7d9d -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>void * <parameter>pointer</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=29a4ddc1310adaf65e14518d442a34ac sig_cn_org=None source=14.1 
     <para>
      pointer to existing storage to change
     </para>
________________________________________________________-->
     <para>
      指向要改变的现有存储空间的指针
     </para>
<!-- pgdoc-cn_end sig_en=29a4ddc1310adaf65e14518d442a34ac -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Size <parameter>size</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=6fb0e4c73bdc052ef741cb6f8e68e750 sig_cn_org=None source=14.1 
     <para>
      size in bytes of storage to allocate
     </para>
________________________________________________________-->
     <para>
      要分配的存储空间大小（以字节计）
     </para>
<!-- pgdoc-cn_end sig_en=6fb0e4c73bdc052ef741cb6f8e68e750 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=be2b3a80902571d956a54038dc0746ed sig_cn_org=None source=14.1 
  <para>
   pointer to new storage space of specified size with the contents
   copied from the existing area
  </para>
________________________________________________________-->
  <para>
   指向具有指定大小的新存储空间的指针，现有区域的内容会被复制到其中
  </para>
<!-- pgdoc-cn_end sig_en=be2b3a80902571d956a54038dc0746ed -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-pfree">
<!-- pgdoc-cn_start sig_en=bd0def05d47b452973383959f56097a2 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_pfree</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_pfree</primary></indexterm>
<!-- pgdoc-cn_end sig_en=bd0def05d47b452973383959f56097a2 -->

 <refmeta>
  <refentrytitle>SPI_pfree</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=374789f6881c28e78eeff10a150ba680 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_pfree</refname>
  <refpurpose>free memory in the upper executor context</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_pfree</refname>
  <refpurpose>在上层执行器上下文中释放内存</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=374789f6881c28e78eeff10a150ba680 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=4a3f3c8024e09cc9afefc56e5a74ac4e sig_cn_org=None source=14.1 
<synopsis>
void SPI_pfree(void * <parameter>pointer</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
void SPI_pfree(void * <parameter>pointer</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=4a3f3c8024e09cc9afefc56e5a74ac4e -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=fcb6e6400ff32200c4a34f63f5a7b6a8 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_pfree</function> frees memory previously allocated
   using <function>SPI_palloc</function> or
   <function>SPI_repalloc</function>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_pfree</function>释放之前使用
   <function>SPI_palloc</function>或者
   <function>SPI_repalloc</function>分配的内存。
  </para>
<!-- pgdoc-cn_end sig_en=fcb6e6400ff32200c4a34f63f5a7b6a8 -->

<!-- pgdoc-cn_start sig_en=5866dfc61008618ae9a1cb677bb8589f sig_cn_org=None source=14.1 
  <para>
   This function is no longer different from plain
   <function>pfree</function>.  It's kept just for backward
   compatibility of existing code.
  </para>
________________________________________________________-->
  <para>
   这个函数不再和普通的<function>pfree</function>相区别。
   保留它只是为了对现有代码保持向后兼容。
  </para>
<!-- pgdoc-cn_end sig_en=5866dfc61008618ae9a1cb677bb8589f -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>void * <parameter>pointer</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=59a9e6c5e63b6bf1360fcf41d2fcc798 sig_cn_org=None source=14.1 
     <para>
      pointer to existing storage to free
     </para>
________________________________________________________-->
     <para>
      指向要释放的现有存储空间的指针
     </para>
<!-- pgdoc-cn_end sig_en=59a9e6c5e63b6bf1360fcf41d2fcc798 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-copytuple">
<!-- pgdoc-cn_start sig_en=ed42f613fcd1263d2187ae37e174f198 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_copytuple</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_copytuple</primary></indexterm>
<!-- pgdoc-cn_end sig_en=ed42f613fcd1263d2187ae37e174f198 -->

 <refmeta>
  <refentrytitle>SPI_copytuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=c8ec54818f8789954103bf815ac23513 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_copytuple</refname>
  <refpurpose>make a copy of a row in the upper executor context</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_copytuple</refname>
  <refpurpose>在上层执行器上下文中创建一行的拷贝</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=c8ec54818f8789954103bf815ac23513 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=b6f5a7a744a7d83879caecaff129b9e7 sig_cn_org=None source=14.1 
<synopsis>
HeapTuple SPI_copytuple(HeapTuple <parameter>row</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
HeapTuple SPI_copytuple(HeapTuple <parameter>row</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=b6f5a7a744a7d83879caecaff129b9e7 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=db5a155aba5d446ad2509007f9a3de60 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_copytuple</function> makes a copy of a row in the
   upper executor context.  This is normally used to return a modified
   row from a trigger.  In a function declared to return a composite
   type, use <function>SPI_returntuple</function> instead.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_copytuple</function>在上层执行器上下文中为一行创建
   一份拷贝。这通常被用来从一个触发器中返回一个被修改的行。在一个被声
   明为返回组合类型的函数中，应使用
   <function>SPI_returntuple</function>。
  </para>
<!-- pgdoc-cn_end sig_en=db5a155aba5d446ad2509007f9a3de60 -->

<!-- pgdoc-cn_start sig_en=94a8c7a92982b6f123aecd5927fb89ac sig_cn_org=None source=14.1 
  <para>
   This function can only be used while connected to SPI.
   Otherwise, it returns NULL and sets <varname>SPI_result</varname> to
   <symbol>SPI_ERROR_UNCONNECTED</symbol>.
  </para>
________________________________________________________-->
  <para>
   这个函数只能在连接到SPI时使用。否则，它会返回NULL并且把<varname>SPI_result</varname>设置为<symbol>SPI_ERROR_UNCONNECTED</symbol>。
  </para>
<!-- pgdoc-cn_end sig_en=94a8c7a92982b6f123aecd5927fb89ac -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=39795cdcb42d915e455eb6f69ace6375 sig_cn_org=None source=14.1 
     <para>
      row to be copied
     </para>
________________________________________________________-->
     <para>
      要拷贝的行
     </para>
<!-- pgdoc-cn_end sig_en=39795cdcb42d915e455eb6f69ace6375 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=929d2e883f57ea44199b30abc1708017 sig_cn_org=None source=14.1 
  <para>
   the copied row, or <symbol>NULL</symbol> on error
   (see <varname>SPI_result</varname> for an error indication)
  </para>
________________________________________________________-->
  <para>
   被拷贝的行，或者在出错时返回<symbol>NULL</symbol>（错误的内容请参考<varname>SPI_result</varname>）
  </para>
<!-- pgdoc-cn_end sig_en=929d2e883f57ea44199b30abc1708017 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-returntuple">
<!-- pgdoc-cn_start sig_en=1ecb889d096c9ceac3b5523ff44b07dd sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_returntuple</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_returntuple</primary></indexterm>
<!-- pgdoc-cn_end sig_en=1ecb889d096c9ceac3b5523ff44b07dd -->

 <refmeta>
  <refentrytitle>SPI_returntuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=07682b5a64028fc432279ccde8e1b72f sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_returntuple</refname>
  <refpurpose>prepare to return a tuple as a Datum</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_returntuple</refname>
  <refpurpose>准备把一个元组返回为一个 Datum</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=07682b5a64028fc432279ccde8e1b72f -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=22e14759f6c3949b1f6eb16382ca6fc1 sig_cn_org=None source=14.1 
<synopsis>
HeapTupleHeader SPI_returntuple(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
HeapTupleHeader SPI_returntuple(HeapTuple <parameter>row</parameter>, TupleDesc <parameter>rowdesc</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=22e14759f6c3949b1f6eb16382ca6fc1 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=f1c4f8ca4b1e8f6a5ff9ae3dd57da756 sig_cn_org=None source=14.1 
  <para>
   <function>SPI_returntuple</function> makes a copy of a row in
   the upper executor context, returning it in the form of a row type <type>Datum</type>.
   The returned pointer need only be converted to <type>Datum</type> via <function>PointerGetDatum</function>
   before returning.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_returntuple</function>为一个行在上层执行器上下文中
   创建一个拷贝，把它以一种行类型<type>Datum</type>的形式返回。被
   返回的指针只需要在返回前通过<function>PointerGetDatum</function>
   被转换成<type>Datum</type>。
  </para>
<!-- pgdoc-cn_end sig_en=f1c4f8ca4b1e8f6a5ff9ae3dd57da756 -->

<!-- pgdoc-cn_start sig_en=94a8c7a92982b6f123aecd5927fb89ac sig_cn_org=None source=14.1 
  <para>
   This function can only be used while connected to SPI.
   Otherwise, it returns NULL and sets <varname>SPI_result</varname> to
   <symbol>SPI_ERROR_UNCONNECTED</symbol>.
  </para>
________________________________________________________-->
  <para>
   这个函数只能在连接到SPI时使用。否则，它会返回NULL并且把<varname>SPI_result</varname>设置为<symbol>SPI_ERROR_UNCONNECTED</symbol>。
  </para>
<!-- pgdoc-cn_end sig_en=94a8c7a92982b6f123aecd5927fb89ac -->

<!-- pgdoc-cn_start sig_en=45f9a437c2f085efe9b681fa2e04d01b sig_cn_org=None source=14.1 
  <para>
   Note that this should be used for functions that are declared to return
   composite types.  It is not used for triggers; use
   <function>SPI_copytuple</function> for returning a modified row in a trigger.
  </para>
________________________________________________________-->
  <para>
   注意这应该被用于声明为要返回组合类型的函数。它不能用于触发器，在
   触发器中应使用<function>SPI_copytuple</function>来返回一个被修改的行。
  </para>
<!-- pgdoc-cn_end sig_en=45f9a437c2f085efe9b681fa2e04d01b -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=39795cdcb42d915e455eb6f69ace6375 sig_cn_org=None source=14.1 
     <para>
      row to be copied
     </para>
________________________________________________________-->
     <para>
      要拷贝的行
     </para>
<!-- pgdoc-cn_end sig_en=39795cdcb42d915e455eb6f69ace6375 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>TupleDesc <parameter>rowdesc</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=9d35abf2f5f553132a9ab95da0e75151 sig_cn_org=None source=14.1 
     <para>
      descriptor for row (pass the same descriptor each time for most
      effective caching)
     </para>
________________________________________________________-->
     <para>
      行的描述符（对大部分有效的缓存，每次都传递相同的描述符）
     </para>
<!-- pgdoc-cn_end sig_en=9d35abf2f5f553132a9ab95da0e75151 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=d5a3d3e0aff3d4a7ffbb0922b6413317 sig_cn_org=None source=14.1 
  <para>
   <type>HeapTupleHeader</type> pointing to copied row,
   or <symbol>NULL</symbol> on error
   (see <varname>SPI_result</varname> for an error indication)
  </para>
________________________________________________________-->
  <para>
   指向被拷贝行的<type>HeapTupleHeader</type>，或者在出错时返回<symbol>NULL</symbol>（错误的内容请参考<varname>SPI_result</varname>）
  </para>
<!-- pgdoc-cn_end sig_en=d5a3d3e0aff3d4a7ffbb0922b6413317 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-modifytuple">
<!-- pgdoc-cn_start sig_en=bd03c63a02fd26e3c1f57d3dd3532263 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_modifytuple</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_modifytuple</primary></indexterm>
<!-- pgdoc-cn_end sig_en=bd03c63a02fd26e3c1f57d3dd3532263 -->

 <refmeta>
  <refentrytitle>SPI_modifytuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=e66a8cd06c799e87bce37ad0eba836d4 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_modifytuple</refname>
  <refpurpose>create a row by replacing selected fields of a given row</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_modifytuple</refname>
  <refpurpose>通过替换一个给定行的选定域来创建一行</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=e66a8cd06c799e87bce37ad0eba836d4 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=120fc5fb3cc2cf89591c90d5ec220d58 sig_cn_org=None source=14.1 
<synopsis>
HeapTuple SPI_modifytuple(Relation <parameter>rel</parameter>, HeapTuple <parameter>row</parameter>, int <parameter>ncols</parameter>,
                          int * <parameter>colnum</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
HeapTuple SPI_modifytuple(Relation <parameter>rel</parameter>, HeapTuple <parameter>row</parameter>, int <parameter>ncols</parameter>,
                          int * <parameter>colnum</parameter>, Datum * <parameter>values</parameter>, const char * <parameter>nulls</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=120fc5fb3cc2cf89591c90d5ec220d58 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=5f9808d9dacfeb29950c5f282ebb0c4b sig_cn_org=None source=14.1 
  <para>
   <function>SPI_modifytuple</function> creates a new row by
   substituting new values for selected columns, copying the original
   row's columns at other positions.  The input row is not modified.
   The new row is returned in the upper executor context.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_modifytuple</function>创建一个新行，其中选定的列
   用新值替代，其他列则从输入行中拷贝。输入行本身不被修改。新行被返回在上层的执行器上下文中。
  </para>
<!-- pgdoc-cn_end sig_en=5f9808d9dacfeb29950c5f282ebb0c4b -->

<!-- pgdoc-cn_start sig_en=94a8c7a92982b6f123aecd5927fb89ac sig_cn_org=None source=14.1 
  <para>
   This function can only be used while connected to SPI.
   Otherwise, it returns NULL and sets <varname>SPI_result</varname> to
   <symbol>SPI_ERROR_UNCONNECTED</symbol>.
  </para>
________________________________________________________-->
  <para>
   这个函数只能在连接到SPI时使用。否则，它会返回NULL并且把<varname>SPI_result</varname>设置为<symbol>SPI_ERROR_UNCONNECTED</symbol>。
  </para>
<!-- pgdoc-cn_end sig_en=94a8c7a92982b6f123aecd5927fb89ac -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>Relation <parameter>rel</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=92e87965c30cf91b90d288fc37f4e7bb sig_cn_org=None source=14.1 
     <para>
      Used only as the source of the row descriptor for the row.
      (Passing a relation rather than a row descriptor is a
      misfeature.)
     </para>
________________________________________________________-->
     <para>
      只被用作该行的行描述符的来源（传递一个关系而不是
      一个行描述符是一种令人头痛的设计）。
     </para>
<!-- pgdoc-cn_end sig_en=92e87965c30cf91b90d288fc37f4e7bb -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=90cc2b33a60aaafd31024a09dc363cec sig_cn_org=None source=14.1 
     <para>
      row to be modified
     </para>
________________________________________________________-->
     <para>
      要被修改的行
     </para>
<!-- pgdoc-cn_end sig_en=90cc2b33a60aaafd31024a09dc363cec -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int <parameter>ncols</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=670962f7d61f12c7e2b0d71c78ecd786 sig_cn_org=None source=14.1 
     <para>
      number of columns to be changed
     </para>
________________________________________________________-->
     <para>
      要被修改的列数
     </para>
<!-- pgdoc-cn_end sig_en=670962f7d61f12c7e2b0d71c78ecd786 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>int * <parameter>colnum</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=ac43685fd8a4af4172f0f62845b7d735 sig_cn_org=None source=14.1 
     <para>
      an array of length <parameter>ncols</parameter>, containing the numbers
      of the columns that are to be changed (column numbers start at 1)
     </para>
________________________________________________________-->
     <para>
      一个长度为<parameter>ncols</parameter>的数组，包含了要被修改的列号
      （列号从 1 开始）
     </para>
<!-- pgdoc-cn_end sig_en=ac43685fd8a4af4172f0f62845b7d735 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>Datum * <parameter>values</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=925932e654558e0d1ed422b12980cb94 sig_cn_org=None source=14.1 
     <para>
      an array of length <parameter>ncols</parameter>, containing the
      new values for the specified columns
     </para>
________________________________________________________-->
     <para>
      一个长度为<parameter>ncols</parameter>的数组，包含了指定列的新值
     </para>
<!-- pgdoc-cn_end sig_en=925932e654558e0d1ed422b12980cb94 -->
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>const char * <parameter>nulls</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=8b3e00d854c61f005b77adfcdd095abc sig_cn_org=None source=14.1 
     <para>
      an array of length <parameter>ncols</parameter>, describing which
      new values are null
     </para>
________________________________________________________-->
     <para>
      一个长度为<parameter>ncols</parameter>的数组，描述哪些新值为空值
     </para>
<!-- pgdoc-cn_end sig_en=8b3e00d854c61f005b77adfcdd095abc -->

<!-- pgdoc-cn_start sig_en=97887105a6eecdfb765532bfdab6a9b1 sig_cn_org=None source=14.1 
     <para>
      If <parameter>nulls</parameter> is <symbol>NULL</symbol> then
      <function>SPI_modifytuple</function> assumes that no new values
      are null.  Otherwise, each entry of the <parameter>nulls</parameter>
      array should be <literal>'&nbsp;'</literal> if the corresponding new value is
      non-null, or <literal>'n'</literal> if the corresponding new value is
      null.  (In the latter case, the actual value in the corresponding
      <parameter>values</parameter> entry doesn't matter.)  Note that
      <parameter>nulls</parameter> is not a text string, just an array: it
      does not need a <literal>'\0'</literal> terminator.
     </para>
________________________________________________________-->
     <para>
      如果<parameter>nulls</parameter>为<symbol>NULL</symbol>，那么
      <function>SPI_modifytuple</function>假定没有新值为空值。否则，
      如果对应的新值为非空，<parameter>nulls</parameter>数组的每一项都应
      该是<literal>'&nbsp;'</literal>，而如果对应的新值为空值则为<literal>'n'</literal>（在
      后一种情况中，对应的<parameter>values</parameter>项中的新值无关紧
      要）。注意<parameter>nulls</parameter>不是一个文本字符串，只是一个
      数组：它不需要一个<literal>'\0'</literal>终止符。
     </para>
<!-- pgdoc-cn_end sig_en=97887105a6eecdfb765532bfdab6a9b1 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=17d1ab9d1678d8ae49cffcb054c7d973 sig_cn_org=None source=14.1 
  <para>
   new row with modifications, allocated in the upper executor
   context, or <symbol>NULL</symbol> on error
   (see <varname>SPI_result</varname> for an error indication)
  </para>
________________________________________________________-->
  <para>
   修改过的新行，它被分配在上层的执行器上下文中，或者在出错时返回<symbol>NULL</symbol>（错误的内容请参考<varname>SPI_result</varname>）
  </para>
<!-- pgdoc-cn_end sig_en=17d1ab9d1678d8ae49cffcb054c7d973 -->

<!-- pgdoc-cn_start sig_en=d3ba5b5dbdf07c9328702081a1edaac6 sig_cn_org=None source=14.1 
  <para>
   On error, <varname>SPI_result</varname> is set as follows:
   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       if <parameter>rel</parameter> is <symbol>NULL</symbol>, or if
       <parameter>row</parameter> is <symbol>NULL</symbol>, or if <parameter>ncols</parameter>
       is less than or equal to 0, or if <parameter>colnum</parameter> is
       <symbol>NULL</symbol>, or if <parameter>values</parameter> is <symbol>NULL</symbol>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_NOATTRIBUTE</symbol></term>
     <listitem>
      <para>
       if <parameter>colnum</parameter> contains an invalid column number (less
       than or equal to 0 or greater than the number of columns in
       <parameter>row</parameter>)
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       if SPI is not active
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   出错时，<varname>SPI_result</varname>被设置如下：
   <variablelist>
    <varlistentry>
     <term><symbol>SPI_ERROR_ARGUMENT</symbol></term>
     <listitem>
      <para>
       如果<parameter>rel</parameter>为<symbol>NULL</symbol>，或者
       <parameter>row</parameter>为<symbol>NULL</symbol>，或者<parameter>ncols</parameter>
       小于等于 0，或者<parameter>colnum</parameter>为<symbol>NULL</symbol>，
       或者<parameter>values</parameter>为<symbol>NULL</symbol>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_NOATTRIBUTE</symbol></term>
     <listitem>
      <para>
       如果<parameter>colnum</parameter>包含一个无效的列号（小于等于 0 或者大于
       <parameter>row</parameter>中的列数）。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SPI_ERROR_UNCONNECTED</symbol></term>
     <listitem>
      <para>
       如果SPI不是活跃状态
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=d3ba5b5dbdf07c9328702081a1edaac6 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-freetuple">
<!-- pgdoc-cn_start sig_en=1d969e26bb4ca9f375486cdb5b3fdb9c sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_freetuple</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_freetuple</primary></indexterm>
<!-- pgdoc-cn_end sig_en=1d969e26bb4ca9f375486cdb5b3fdb9c -->

 <refmeta>
  <refentrytitle>SPI_freetuple</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=306819e8cb7772888ac01f73261d549a sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_freetuple</refname>
  <refpurpose>free a row allocated in the upper executor context</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_freetuple</refname>
  <refpurpose>释放一个在上层执行器上下文中分配的行</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=306819e8cb7772888ac01f73261d549a -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=1d5d8bc7bf0c4ec89f324e7dbf38149f sig_cn_org=None source=14.1 
<synopsis>
void SPI_freetuple(HeapTuple <parameter>row</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
void SPI_freetuple(HeapTuple <parameter>row</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=1d5d8bc7bf0c4ec89f324e7dbf38149f -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=b3a1d75cf0a40a56cb7a0b5682bf609e sig_cn_org=None source=14.1 
  <para>
   <function>SPI_freetuple</function> frees a row previously allocated
   in the upper executor context.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_freetuple</function>释放之前在上层执行器上下文中
   分配的一个行。
  </para>
<!-- pgdoc-cn_end sig_en=b3a1d75cf0a40a56cb7a0b5682bf609e -->

<!-- pgdoc-cn_start sig_en=443bc8bf69e54f3d3cd1e8be3c1efc13 sig_cn_org=None source=14.1 
  <para>
   This function is no longer different from plain
   <function>heap_freetuple</function>.  It's kept just for backward
   compatibility of existing code.
  </para>
________________________________________________________-->
  <para>
   这个函数不再和普通的<function>heap_freetuple</function>相区别。
   保留它只是为了对现有代码保持向后兼容。
  </para>
<!-- pgdoc-cn_end sig_en=443bc8bf69e54f3d3cd1e8be3c1efc13 -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>HeapTuple <parameter>row</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=80cc8fc6bac17a682117a3627f094aa2 sig_cn_org=None source=14.1 
     <para>
      row to free
     </para>
________________________________________________________-->
     <para>
      要释放的行
     </para>
<!-- pgdoc-cn_end sig_en=80cc8fc6bac17a682117a3627f094aa2 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-freetupletable">
<!-- pgdoc-cn_start sig_en=a2e5edbedb5e189065970e3e6784a965 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_freetuptable</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_freetuptable</primary></indexterm>
<!-- pgdoc-cn_end sig_en=a2e5edbedb5e189065970e3e6784a965 -->

 <refmeta>
  <refentrytitle>SPI_freetuptable</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=e1530fbf1e0db22e11077ca9c204c299 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_freetuptable</refname>
  <refpurpose>free a row set created by <function>SPI_execute</function> or a similar
  function</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_freetuptable</refname>
  <refpurpose>释放一个由<function>SPI_execute</function>
  或者类似函数创建的行集合</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=e1530fbf1e0db22e11077ca9c204c299 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=b4d9956272f29c1c29e9cd2b57c08990 sig_cn_org=None source=14.1 
<synopsis>
void SPI_freetuptable(SPITupleTable * <parameter>tuptable</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
void SPI_freetuptable(SPITupleTable * <parameter>tuptable</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=b4d9956272f29c1c29e9cd2b57c08990 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=c9ae8d09dc76542bd39356a486d820bb sig_cn_org=None source=14.1 
  <para>
   <function>SPI_freetuptable</function> frees a row set created by a
   prior SPI command execution function, such as
   <function>SPI_execute</function>.  Therefore, this function is often called
   with the global variable <varname>SPI_tuptable</varname> as
   argument.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_freetuptable</function>释放一个由之前的 SPI 命令
   执行函数（例如<function>SPI_execute</function>）创建的行集合。因此，
   调用这个函数时，常常使用<varname>SPI_tuptable</varname>作为
   参数。
  </para>
<!-- pgdoc-cn_end sig_en=c9ae8d09dc76542bd39356a486d820bb -->

<!-- pgdoc-cn_start sig_en=b9dfa3e56e31cca5d2b3cb3286af804d sig_cn_org=None source=14.1 
  <para>
   This function is useful if an SPI-using C function needs to execute
   multiple commands and does not want to keep the results of earlier
   commands around until it ends.  Note that any unfreed row sets will
   be freed anyway at <function>SPI_finish</function>.
   Also, if a subtransaction is started and then aborted within execution
   of an SPI-using C function, SPI automatically frees any row sets created while
   the subtransaction was running.
  </para>
________________________________________________________-->
  <para>
   如果一个使用SPI的C函数需要执行多个命令并且不想保留早期命令的结果，这个
   函数就有用了。注意，<function>SPI_finish</function>会释放任何还未释放的
   行集合。还有，如果在一个使用SPI的C函数的执行中开始了一个子事务并且后来
   被中止，SPI 会自动释放该子事务运行期间创建的任何行集合。
  </para>
<!-- pgdoc-cn_end sig_en=b9dfa3e56e31cca5d2b3cb3286af804d -->

<!-- pgdoc-cn_start sig_en=a660059c8de9db2d892598c63da4a0ff sig_cn_org=None source=14.1 
  <para>
   Beginning in <productname>PostgreSQL</productname> 9.3,
   <function>SPI_freetuptable</function> contains guard logic to protect
   against duplicate deletion requests for the same row set.  In previous
   releases, duplicate deletions would lead to crashes.
  </para>
________________________________________________________-->
  <para>
   从<productname>PostgreSQL</productname> 9.3 开始，
   <function>SPI_freetuptable</function>包含了保护逻辑以避免对于同
   一行集的重复删除请求。在以前的发布中，重复的删除将会导致崩溃。
  </para>
<!-- pgdoc-cn_end sig_en=a660059c8de9db2d892598c63da4a0ff -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>SPITupleTable * <parameter>tuptable</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=51c7ff8934be92a9bd4801362fd05dd9 sig_cn_org=None source=14.1 
     <para>
      pointer to row set to free, or NULL to do nothing
     </para>
________________________________________________________-->
     <para>
      要释放的行集的指针，NULL 表示什么也不做
     </para>
<!-- pgdoc-cn_end sig_en=51c7ff8934be92a9bd4801362fd05dd9 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-freeplan">
<!-- pgdoc-cn_start sig_en=826b7e189fe5ed07d6d4d948d52f78e5 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_freeplan</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_freeplan</primary></indexterm>
<!-- pgdoc-cn_end sig_en=826b7e189fe5ed07d6d4d948d52f78e5 -->

 <refmeta>
  <refentrytitle>SPI_freeplan</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=9ff5b83444af23729ed47ecf988d15d6 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_freeplan</refname>
  <refpurpose>free a previously saved prepared statement</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_freeplan</refname>
  <refpurpose>释放一个之前保存的预备语句</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=9ff5b83444af23729ed47ecf988d15d6 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=872d894abf354b0d3d421a6eb2d10186 sig_cn_org=None source=14.1 
<synopsis>
int SPI_freeplan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
________________________________________________________-->
<synopsis>
int SPI_freeplan(SPIPlanPtr <parameter>plan</parameter>)
</synopsis>
<!-- pgdoc-cn_end sig_en=872d894abf354b0d3d421a6eb2d10186 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=6bb6113b8cff0a7507b263271a61a2ee sig_cn_org=None source=14.1 
  <para>
   <function>SPI_freeplan</function> releases a prepared statement
   previously returned by <function>SPI_prepare</function> or saved by
   <function>SPI_keepplan</function> or <function>SPI_saveplan</function>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_freeplan</function>释放一个之前由
   <function>SPI_prepare</function>返回的或者由
   <function>SPI_keepplan</function>、<function>SPI_saveplan</function>
   保存的预备语句。
  </para>
<!-- pgdoc-cn_end sig_en=6bb6113b8cff0a7507b263271a61a2ee -->
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f68406ac17410c8573c15f193c5b1eb3 sig_cn_org=None source=14.1 
  <title>Arguments</title>
________________________________________________________-->
  <title>参数</title>
<!-- pgdoc-cn_end sig_en=f68406ac17410c8573c15f193c5b1eb3 -->

  <variablelist>
   <varlistentry>
    <term><literal>SPIPlanPtr <parameter>plan</parameter></literal></term>
    <listitem>
<!-- pgdoc-cn_start sig_en=eef82b3059e4d3686716e4bda35005e3 sig_cn_org=None source=14.1 
     <para>
      pointer to statement to free
     </para>
________________________________________________________-->
     <para>
      要释放的语句的指针
     </para>
<!-- pgdoc-cn_end sig_en=eef82b3059e4d3686716e4bda35005e3 -->
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
<!-- pgdoc-cn_start sig_en=f1443dcf791d2c869a13cd692d668ccd sig_cn_org=None source=14.1 
  <title>Return Value</title>
________________________________________________________-->
  <title>返回值</title>
<!-- pgdoc-cn_end sig_en=f1443dcf791d2c869a13cd692d668ccd -->

<!-- pgdoc-cn_start sig_en=f3510886283b692efcd8cdefe53fff5c sig_cn_org=None source=14.1 
  <para>
   0 on success;
   <symbol>SPI_ERROR_ARGUMENT</symbol> if <parameter>plan</parameter>
   is <symbol>NULL</symbol> or invalid
  </para>
________________________________________________________-->
  <para>
   成功返回 0；如果<parameter>plan</parameter>为<symbol>NULL</symbol>
   或者无效则返回<symbol>SPI_ERROR_ARGUMENT</symbol>
  </para>
<!-- pgdoc-cn_end sig_en=f3510886283b692efcd8cdefe53fff5c -->
 </refsect1>
</refentry>

 </sect1>

 <sect1 id="spi-transaction">
<!-- pgdoc-cn_start sig_en=168b9264e23c07090b9e1a29f31a5165 sig_cn_org=None source=14.1 
  <title>Transaction Management</title>
________________________________________________________-->
  <title>事务管理</title>
<!-- pgdoc-cn_end sig_en=168b9264e23c07090b9e1a29f31a5165 -->

<!-- pgdoc-cn_start sig_en=20cd674cece3141178b020f15f0418f0 sig_cn_org=None source=14.1 
  <para>
   It is not possible to run transaction control commands such
   as <command>COMMIT</command> and <command>ROLLBACK</command> through SPI
   functions such as <function>SPI_execute</function>.  There are, however,
   separate interface functions that allow transaction control through SPI.
  </para>
________________________________________________________-->
  <para>
   不能通过<function>SPI_execute</function>这样的SPI函数运行<command>COMMIT</command>和<command>ROLLBACK</command>之类的事务控制命令。不过，也有单独的接口函数允许通过SPI进行事务控制。
  </para>
<!-- pgdoc-cn_end sig_en=20cd674cece3141178b020f15f0418f0 -->

<!-- pgdoc-cn_start sig_en=b75fe6fdebdfa4766aa2b82fda2da29b sig_cn_org=None source=14.1 
  <para>
   It is not generally safe and sensible to start and end transactions in
   arbitrary user-defined SQL-callable functions without taking into account
   the context in which they are called.  For example, a transaction boundary
   in the middle of a function that is part of a complex SQL expression that
   is part of some SQL command will probably result in obscure internal errors
   or crashes.  The interface functions presented here are primarily intended
   to be used by procedural language implementations to support transaction
   management in SQL-level procedures that are invoked by the <command>CALL</command>
   command, taking the context of the <command>CALL</command> invocation into
   account.  SPI-using procedures implemented in C can implement the same logic, but
   the details of that are beyond the scope of this documentation.
  </para>
________________________________________________________-->
  <para>
   如果不考虑被调用的上下文，在任意的用户定义的可从SQL调用的函数中开始以及结束事务通常并不是安全和明智的。例如，一个事务位于一个函数内，而该函数是某个SQL命令中的一个复杂SQL表达式的一部分，这样的事务有可能会导致隐蔽的内部错误或者崩溃。这里介绍的接口函数的主要目的是被过程语言的实现用于支持在<command>CALL</command>命令调用的SQL层过程中进行事务管理，同时把<command>CALL</command>调用的上下文也加以考虑。用C实现的使用SPI的过程可以实现同样的逻辑，但是其细节超出了这份文档的范围。
  </para>
<!-- pgdoc-cn_end sig_en=b75fe6fdebdfa4766aa2b82fda2da29b -->

<!-- *********************************************** -->

<refentry id="spi-spi-commit">
<!-- pgdoc-cn_start sig_en=c7f5c3cd7c388ffa87873a1f28004cd7 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_commit</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_commit</primary></indexterm>
<!-- pgdoc-cn_end sig_en=c7f5c3cd7c388ffa87873a1f28004cd7 -->
<!-- pgdoc-cn_start sig_en=dc749a4385afba70027a6bf410fc13a0 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_commit_and_chain</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_commit_and_chain</primary></indexterm>
<!-- pgdoc-cn_end sig_en=dc749a4385afba70027a6bf410fc13a0 -->

 <refmeta>
  <refentrytitle>SPI_commit</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=c135164312bed47c427bd8d71ca52775 sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_commit</refname>
  <refname>SPI_commit_and_chain</refname>
  <refpurpose>commit the current transaction</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_commit</refname>
  <refname>SPI_commit_and_chain</refname>
  <refpurpose>commit the current transaction</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=c135164312bed47c427bd8d71ca52775 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=f886f95e1b8773497cca2aaec56e8cab sig_cn_org=None source=14.1 
<synopsis>
void SPI_commit(void)
</synopsis>
________________________________________________________-->
<synopsis>
void SPI_commit(void)
</synopsis>
<!-- pgdoc-cn_end sig_en=f886f95e1b8773497cca2aaec56e8cab -->

<!-- pgdoc-cn_start sig_en=b8bcdd3b5152ab3851148dda26a58c2e sig_cn_org=None source=14.1 
<synopsis>
void SPI_commit_and_chain(void)
</synopsis>
________________________________________________________-->
<synopsis>
void SPI_commit_and_chain(void)
</synopsis>
<!-- pgdoc-cn_end sig_en=b8bcdd3b5152ab3851148dda26a58c2e -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=f7dd489db2b8ad9be3b636eaeaf41f7d sig_cn_org=071e961b9cd2ef754dff02eda11820c4 source=15.7 
  <para>
   <function>SPI_commit</function> commits the current transaction.  It is
   approximately equivalent to running the SQL
   command <command>COMMIT</command>.  After the transaction is committed, a
   new transaction is automatically started using default transaction
   characteristics, so that the caller can continue using SPI facilities.
   If there is a failure during commit, the current transaction is instead
   rolled back and a new transaction is started, after which the error is
   thrown in the usual way.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_commit</function>提交当前事务。它大致相当于运行SQL命令<command>COMMIT</command>。
   在事务提交后，将自动启动一个新事务，使用默认的事务特性，以便调用者可以继续使用SPI工具。
   如果在提交过程中出现故障，则当前事务将被回滚，并启动一个新事务，之后错误将以通常的方式抛出。
</para>
<!-- pgdoc-cn_end sig_en=f7dd489db2b8ad9be3b636eaeaf41f7d -->

<!-- pgdoc-cn_start sig_en=c50be0074ba8f3434f7a6df36f363488 sig_cn_org=d900909dab74240f35769d003dc67441 source=15.7 
  <para>
   <function>SPI_commit_and_chain</function> is the same, but the new
   transaction is started with the same transaction
   characteristics as the just finished one, like with the SQL command
   <command>COMMIT AND CHAIN</command>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_commit_and_chain</function>是相同的，
   但新事务将以与刚刚完成的事务相同的事务特性启动，
   就像使用SQL命令<command>COMMIT AND CHAIN</command>一样。
</para>
<!-- pgdoc-cn_end sig_en=c50be0074ba8f3434f7a6df36f363488 -->

<!-- pgdoc-cn_start sig_en=387e4ab95589f2098e4ea14d31ce6ad0 sig_cn_org=None source=14.1 
  <para>
   These functions can only be executed if the SPI connection has been set as
   nonatomic in the call to <function>SPI_connect_ext</function>.
  </para>
________________________________________________________-->
  <para>
   只有当SPI连接已经在对<function>SPI_connect_ext</function>的调用中被设置为非原子的情况下才能执行这些函数。
  </para>
<!-- pgdoc-cn_end sig_en=387e4ab95589f2098e4ea14d31ce6ad0 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-rollback">
<!-- pgdoc-cn_start sig_en=b7c1fc65f74e94db9131cd01eae77825 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_rollback</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_rollback</primary></indexterm>
<!-- pgdoc-cn_end sig_en=b7c1fc65f74e94db9131cd01eae77825 -->
<!-- pgdoc-cn_start sig_en=b3dfcd8de7799f5f62bd0d9590e57a48 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_rollback_and_chain</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_rollback_and_chain</primary></indexterm>
<!-- pgdoc-cn_end sig_en=b3dfcd8de7799f5f62bd0d9590e57a48 -->

 <refmeta>
  <refentrytitle>SPI_rollback</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=e1d0e9dc8597804c2b91096ef21d296e sig_cn_org=None source=14.1 
 <refnamediv>
  <refname>SPI_rollback</refname>
  <refname>SPI_rollback_and_chain</refname>
  <refpurpose>abort the current transaction</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_rollback</refname>
  <refname>SPI_rollback_and_chain</refname>
  <refpurpose>abort the current transaction</refpurpose>
 </refnamediv>
<!-- pgdoc-cn_end sig_en=e1d0e9dc8597804c2b91096ef21d296e -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=d1c0a0b3bdbed4fe7eb7d05c3691f70d sig_cn_org=None source=14.1 
<synopsis>
void SPI_rollback(void)
</synopsis>
________________________________________________________-->
<synopsis>
void SPI_rollback(void)
</synopsis>
<!-- pgdoc-cn_end sig_en=d1c0a0b3bdbed4fe7eb7d05c3691f70d -->

<!-- pgdoc-cn_start sig_en=8eead00ccd4213cd2b93b56297c52b72 sig_cn_org=None source=14.1 
<synopsis>
void SPI_rollback_and_chain(void)
</synopsis>
________________________________________________________-->
<synopsis>
void SPI_rollback_and_chain(void)
</synopsis>
<!-- pgdoc-cn_end sig_en=8eead00ccd4213cd2b93b56297c52b72 -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=7bd7d3c824d91afc6a2e63b16acc863e sig_cn_org=ed479c43ef341a92658867ac511b7f59 source=15.7 
  <para>
   <function>SPI_rollback</function> rolls back the current transaction.  It
   is approximately equivalent to running the SQL
   command <command>ROLLBACK</command>.  After the transaction is rolled back,
   a new transaction is automatically started using default transaction
   characteristics, so that the caller can continue using SPI facilities.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_rollback</function>回滚当前事务。它大致相当于运行SQL命令<command>ROLLBACK</command>。
   事务回滚后，将自动启动一个新事务，使用默认的事务特性，以便调用者可以继续使用SPI功能。
</para>
<!-- pgdoc-cn_end sig_en=7bd7d3c824d91afc6a2e63b16acc863e -->
<!-- pgdoc-cn_start sig_en=879e3e9ffe2aa7da74bda62b532b01fd sig_cn_org=37821d032cd1b5f399cc7fd59625d69b source=15.7 
  <para>
   <function>SPI_rollback_and_chain</function> is the same, but the new
   transaction is started with the same transaction
   characteristics as the just finished one, like with the SQL command
   <command>ROLLBACK AND CHAIN</command>.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_rollback_and_chain</function>是相同的，但新事务将使用与刚结束的事务一样的事务特性启动，就像使用SQL命令<command>ROLLBACK AND CHAIN</command>一样。
</para>
<!-- pgdoc-cn_end sig_en=879e3e9ffe2aa7da74bda62b532b01fd -->

<!-- pgdoc-cn_start sig_en=387e4ab95589f2098e4ea14d31ce6ad0 sig_cn_org=None source=14.1 
  <para>
   These functions can only be executed if the SPI connection has been set as
   nonatomic in the call to <function>SPI_connect_ext</function>.
  </para>
________________________________________________________-->
  <para>
   只有当SPI连接已经在对<function>SPI_connect_ext</function>的调用中被设置为非原子的情况下才能执行这些函数。
  </para>
<!-- pgdoc-cn_end sig_en=387e4ab95589f2098e4ea14d31ce6ad0 -->
 </refsect1>
</refentry>

<!-- *********************************************** -->

<refentry id="spi-spi-start-transaction">
<!-- pgdoc-cn_start sig_en=7b60f07ea1228787236a7e752d55e676 sig_cn_org=None source=14.1 
 <indexterm><primary>SPI_start_transaction</primary></indexterm>
________________________________________________________-->
 <indexterm><primary>SPI_start_transaction</primary></indexterm>
<!-- pgdoc-cn_end sig_en=7b60f07ea1228787236a7e752d55e676 -->

 <refmeta>
  <refentrytitle>SPI_start_transaction</refentrytitle>
  <manvolnum>3</manvolnum>
 </refmeta>

<!-- pgdoc-cn_start sig_en=d7adc1cf0d122a63fa941748afac3d65 sig_cn_org=99f949168ddd7f626929362336b8efa9 source=15.7 
 <refnamediv>
  <refname>SPI_start_transaction</refname>
  <refpurpose>obsolete function</refpurpose>
 </refnamediv>
________________________________________________________-->
 <refnamediv>
  <refname>SPI_start_transaction</refname>
  <refpurpose>废弃函数</refpurpose>
</refnamediv>
<!-- pgdoc-cn_end sig_en=d7adc1cf0d122a63fa941748afac3d65 -->

 <refsynopsisdiv>
<!-- pgdoc-cn_start sig_en=9611868aa7ef1df700573665e845703d sig_cn_org=None source=14.1 
<synopsis>
void SPI_start_transaction(void)
</synopsis>
________________________________________________________-->
<synopsis>
void SPI_start_transaction(void)
</synopsis>
<!-- pgdoc-cn_end sig_en=9611868aa7ef1df700573665e845703d -->
 </refsynopsisdiv>

 <refsect1>
<!-- pgdoc-cn_start sig_en=59d6e86f3a60db4f1e08d0d6e639924e sig_cn_org=None source=14.1 
  <title>Description</title>
________________________________________________________-->
  <title>描述</title>
<!-- pgdoc-cn_end sig_en=59d6e86f3a60db4f1e08d0d6e639924e -->

<!-- pgdoc-cn_start sig_en=1a4f058a6757901a71882c7141990a3a sig_cn_org=30972d6f9372eec66c1ce19bfb24a2a9 source=15.7 
  <para>
   <function>SPI_start_transaction</function> does nothing, and exists
   only for code compatibility with
   earlier <productname>PostgreSQL</productname> releases.  It used to
   be required after calling <function>SPI_commit</function>
   or <function>SPI_rollback</function>, but now those functions start
   a new transaction automatically.
  </para>
________________________________________________________-->
  <para>
   <function>SPI_start_transaction</function>不执行任何操作，仅用于与早期<productname>PostgreSQL</productname>版本的代码兼容性而存在。
   在过去，调用<function>SPI_commit</function>或<function>SPI_rollback</function>之后需要使用它，但现在这些函数会自动开始一个新事务。
</para>
<!-- pgdoc-cn_end sig_en=1a4f058a6757901a71882c7141990a3a -->
 </refsect1>
</refentry>

 </sect1>

 <sect1 id="spi-visibility">
<!-- pgdoc-cn_start sig_en=e88f22d13f2f5c2d0ea075e514e467bc sig_cn_org=None source=14.1 
  <title>Visibility of Data Changes</title>
________________________________________________________-->
  <title>数据改变的可见性</title>
<!-- pgdoc-cn_end sig_en=e88f22d13f2f5c2d0ea075e514e467bc -->

<!-- pgdoc-cn_start sig_en=55cd7a52787170106ff8dc73512f616c sig_cn_org=None source=14.1 
  <para>
   The following rules govern the visibility of data changes in
   functions that use SPI (or any other C function):

   <itemizedlist>
    <listitem>
     <para>
      During the execution of an SQL command, any data changes made by
      the command are invisible to the command itself.  For
      example, in:
<programlisting>
INSERT INTO a SELECT * FROM a;
</programlisting>
      the inserted rows are invisible to the <command>SELECT</command>
      part.
     </para>
    </listitem>

    <listitem>
     <para>
      Changes made by a command C are visible to all commands that are
      started after C, no matter whether they are started inside C
      (during the execution of C) or after C is done.
     </para>
    </listitem>

    <listitem>
     <para>
      Commands executed via SPI inside a function called by an SQL command
      (either an ordinary function or a trigger) follow one or the
      other of the above rules depending on the read/write flag passed
      to SPI.  Commands executed in read-only mode follow the first
      rule: they cannot see changes of the calling command.  Commands executed
      in read-write mode follow the second rule: they can see all changes made
      so far.
     </para>
    </listitem>

    <listitem>
     <para>
      All standard procedural languages set the SPI read-write mode
      depending on the volatility attribute of the function.  Commands of
      <literal>STABLE</literal> and <literal>IMMUTABLE</literal> functions are done in
      read-only mode, while commands of <literal>VOLATILE</literal> functions are
      done in read-write mode.  While authors of C functions are able to
      violate this convention, it's unlikely to be a good idea to do so.
     </para>
    </listitem>
   </itemizedlist>
  </para>
________________________________________________________-->
  <para>
   下列规则主导了使用 SPI 的函数（或者任何其他 C 函数）中数据改变
   的可见性：

   <itemizedlist>
    <listitem>
     <para>
      在一个 SQL 命令的执行期间，该命令所作的任何数据更改对该命令本身
      是不可见的。例如，在
<programlisting>
INSERT INTO a SELECT * FROM a;
</programlisting>
      中，被插入的行对<command>SELECT</command>部分不可见。
     </para>
    </listitem>

    <listitem>
     <para>
      一个命令 C 所作的更改对所有在 C 之后开始的命令可见，不管它们是否
      在 C 之中（在 C 的执行期间）开始还是在 C 完成之后开始。
     </para>
    </listitem>

    <listitem>
     <para>
      在一个 SQL 命令（或者一个普通函数或者触发器）调用的函数内通过
      SPI 执行的命令遵循以上哪条规则取决于传递给 SPI 的读/写标志。以
      只读模式执行的命令遵循第一条规则：它们不能看到调用它们的命令的
      改变。在读写模式中执行的命令遵循第二条规则：它们能看见目前为止
      所有的改变。
     </para>
    </listitem>

    <listitem>
     <para>
      所有的标准过程语言会基于函数的易变性属性设置 SPI 读写模式。
      <literal>STABLE</literal>和<literal>IMMUTABLE</literal>函数的命令会以
      只读模式完成，而<literal>VOLATILE</literal>函数的命令会以读写模式
      完成。虽然 C 函数的作者可以违反这种习惯，但是最好不要那样做。
     </para>
    </listitem>
   </itemizedlist>
  </para>
<!-- pgdoc-cn_end sig_en=55cd7a52787170106ff8dc73512f616c -->

<!-- pgdoc-cn_start sig_en=337774335dee3a267fe4adc32b0442e2 sig_cn_org=None source=14.1 
  <para>
   The next section contains an example that illustrates the
   application of these rules.
  </para>
________________________________________________________-->
  <para>
   下一节包含一个关于这些规则应用的例子：
  </para>
<!-- pgdoc-cn_end sig_en=337774335dee3a267fe4adc32b0442e2 -->
 </sect1>

 <sect1 id="spi-examples">
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
  <title>Examples</title>
________________________________________________________-->
  <title>例子</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=57fcf7a02be77c77a405e728aed1fe67 sig_cn_org=None source=14.1 
  <para>
   This section contains a very simple example of SPI usage. The
   C function <function>execq</function> takes an SQL command as its
   first argument and a row count as its second, executes the command
   using <function>SPI_exec</function> and returns the number of rows
   that were processed by the command.  You can find more complex
   examples for SPI in the source tree in
   <filename>src/test/regress/regress.c</filename> and in the
   <xref linkend="contrib-spi"/> module.
  </para>
________________________________________________________-->
  <para>
   这一节包含了 SPI 用法的一个非常简单的例子。C函数
   <function>execq</function>用一个 SQL 命令作为其第一个参数
   并且用一个行计数作为第二个参数，使用
   <function>SPI_exec</function>执行该命令并且返回被该该命令
   处理过的行的数量。你可以在源代码树的
   <filename>src/test/regress/regress.c</filename>和
   <xref linkend="contrib-spi"/>模块中找到 SPI 的更复杂的例子。
  </para>
<!-- pgdoc-cn_end sig_en=57fcf7a02be77c77a405e728aed1fe67 -->

<!-- pgdoc-cn_start sig_en=8e8e76a3daa6252e51551ce44945a297 sig_cn_org=None source=14.1 
<programlisting>
#include "postgres.h"

#include "executor/spi.h"
#include "utils/builtins.h"

PG_MODULE_MAGIC;

PG_FUNCTION_INFO_V1(execq);

Datum
execq(PG_FUNCTION_ARGS)
{
    char *command;
    int cnt;
    int ret;
    uint64 proc;

    /* Convert given text object to a C string */
    command = text_to_cstring(PG_GETARG_TEXT_PP(0));
    cnt = PG_GETARG_INT32(1);

    SPI_connect();

    ret = SPI_exec(command, cnt);

    proc = SPI_processed;

    /*
     * If some rows were fetched, print them via elog(INFO).
     */
    if (ret &gt; 0 &amp;&amp; SPI_tuptable != NULL)
    {
        SPITupleTable *tuptable = SPI_tuptable;
        TupleDesc tupdesc = tuptable-&gt;tupdesc;
        char buf[8192];
        uint64 j;

        for (j = 0; j &lt; tuptable-&gt;numvals; j++)
        {
            HeapTuple tuple = tuptable-&gt;vals[j];
            int i;

            for (i = 1, buf[0] = 0; i &lt;= tupdesc-&gt;natts; i++)
                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), " %s%s",
                        SPI_getvalue(tuple, tupdesc, i),
                        (i == tupdesc-&gt;natts) ? " " : " |");
            elog(INFO, "EXECQ: %s", buf);
        }
    }

    SPI_finish();
    pfree(command);

    PG_RETURN_INT64(proc);
}
</programlisting>
________________________________________________________-->
<programlisting>
#include "postgres.h"

#include "executor/spi.h"
#include "utils/builtins.h"

PG_MODULE_MAGIC;

PG_FUNCTION_INFO_V1(execq);

Datum
execq(PG_FUNCTION_ARGS)
{
    char *command;
    int cnt;
    int ret;
    uint64 proc;

    /* 把给定的文本对象转换成一个 C 字符串 */
    command = text_to_cstring(PG_GETARG_TEXT_PP(0));
    cnt = PG_GETARG_INT32(1);

    SPI_connect();

    ret = SPI_exec(command, cnt);

    proc = SPI_processed;

    /*
     * 如果取出了一些行，通过 elog(INFO) 打印它们。
     */
    if (ret &gt; 0 &amp;&amp; SPI_tuptable != NULL)
    {
        SPITupleTable *tuptable = SPI_tuptable;
        TupleDesc tupdesc = tuptable-&gt;tupdesc;
        char buf[8192];
        uint64 j;

        for (j = 0; j &lt; tuptable-&gt;numvals; j++)
        {
            HeapTuple tuple = tuptable-&gt;vals[j];
            int i;

            for (i = 1, buf[0] = 0; i &lt;= tupdesc-&gt;natts; i++)
                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), " %s%s",
                        SPI_getvalue(tuple, tupdesc, i),
                        (i == tupdesc-&gt;natts) ? " " : " |");
            elog(INFO, "EXECQ: %s", buf);
        }
    }

    SPI_finish();
    pfree(command);

    PG_RETURN_INT64(proc);
}
</programlisting>
<!-- pgdoc-cn_end sig_en=8e8e76a3daa6252e51551ce44945a297 -->

<!-- pgdoc-cn_start sig_en=e26186ac9cd0cb7f3dd1d89d91694f37 sig_cn_org=None source=14.1 
  <para>
   This is how you declare the function after having compiled it into
   a shared library (details are in <xref linkend="dfunc"/>.):

<programlisting>
CREATE FUNCTION execq(text, integer) RETURNS int8
    AS '<replaceable>filename</replaceable>'
    LANGUAGE C STRICT;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   在把该函数编译到一个共享库中（详见<xref linkend="dfunc"/>）之
   后，这样声明该函数：

<programlisting>
CREATE FUNCTION execq(text, integer) RETURNS int8
    AS '<replaceable>filename</replaceable>'
    LANGUAGE C STRICT;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=e26186ac9cd0cb7f3dd1d89d91694f37 -->

<!-- pgdoc-cn_start sig_en=fed74dbed15c52fa8525f882e5b047b7 sig_cn_org=2e4601b9821a0f6c0808ff84a6e749f9 source=15.7 
  <para>
   Here is a sample session:

<programlisting>
=&gt; SELECT execq('CREATE TABLE a (x integer)', 0);
 execq
-&minus;-&minus;-&minus;-
     0
(1 row)

=&gt; INSERT INTO a VALUES (execq('INSERT INTO a VALUES (0)', 0));
INSERT 0 1
=&gt; SELECT execq('SELECT * FROM a', 0);
INFO:  EXECQ:  0    <lineannotation>-&minus; inserted by execq</lineannotation>
INFO:  EXECQ:  1    <lineannotation>-&minus; returned by execq and inserted by upper INSERT</lineannotation>

 execq
-&minus;-&minus;-&minus;-
     2
(1 row)

=&gt; SELECT execq('INSERT INTO a SELECT x + 2 FROM a RETURNING *', 1);
INFO:  EXECQ:  2    <lineannotation>-&minus; 0 + 2, then execution was stopped by count</lineannotation>
 execq
-&minus;-&minus;-&minus;-
     1
(1 row)

=&gt; SELECT execq('SELECT * FROM a', 10);
INFO:  EXECQ:  0
INFO:  EXECQ:  1
INFO:  EXECQ:  2

 execq
-&minus;-&minus;-&minus;-
     3              <lineannotation>-&minus; 10 is the max value only, 3 is the real number of rows</lineannotation>
(1 row)

=&gt; SELECT execq('INSERT INTO a SELECT x + 10 FROM a', 1);
 execq
-&minus;-&minus;-&minus;-
     3              <lineannotation>-&minus; all rows processed; count does not stop it, because nothing is returned</lineannotation>
(1 row)

=&gt; SELECT * FROM a;
 x
-&minus;-&minus;
  0
  1
  2
 10
 11
 12
(6 rows)

=&gt; DELETE FROM a;
DELETE 6
=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);
INSERT 0 1
=&gt; SELECT * FROM a;
 x
-&minus;-
 1                  <lineannotation>-&minus; 0 (no rows in a) + 1</lineannotation>
(1 row)

=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);
INFO:  EXECQ:  1
INSERT 0 1
=&gt; SELECT * FROM a;
 x
-&minus;-
 1
 2                  <lineannotation>-&minus; 1 (there was one row in a) + 1</lineannotation>
(2 rows)

<lineannotation>-&minus; This demonstrates the data changes visibility rule.</lineannotation>
<lineannotation>-&minus; execq is called twice and sees different numbers of rows each time:</lineannotation>

=&gt; INSERT INTO a SELECT execq('SELECT * FROM a', 0) * x FROM a;
INFO:  EXECQ:  1    <lineannotation>-&minus; results from first execq</lineannotation>
INFO:  EXECQ:  2
INFO:  EXECQ:  1    <lineannotation>-&minus; results from second execq</lineannotation>
INFO:  EXECQ:  2
INFO:  EXECQ:  2
INSERT 0 2
=&gt; SELECT * FROM a;
 x
-&minus;-
 1
 2
 2                  <lineannotation>-&minus; 2 rows * 1 (x in first row)</lineannotation>
 6                  <lineannotation>-&minus; 3 rows (2 + 1 just inserted) * 2 (x in second row)</lineannotation>
(4 rows)
</programlisting>
  </para>
________________________________________________________-->
  <para>
   这是一个示例会话：

<programlisting>
=&gt; SELECT execq('CREATE TABLE a (x integer)', 0);
 execq
-------
     0
(1 row)

=&gt; INSERT INTO a VALUES (execq('INSERT INTO a VALUES (0)', 0));
INSERT 0 1
=&gt; SELECT execq('SELECT * FROM a', 0);
INFO:  EXECQ:  0    <lineannotation>-- 由execq插入</lineannotation>
INFO:  EXECQ:  1    <lineannotation>-- 由execq返回并由上层INSERT插入</lineannotation>

 execq
-------
     2
(1 rows)

=&gt; SELECT execq('INSERT INTO a SELECT x + 2 FROM a RETURNING *', 1);
INFO:  EXECQ:  2    <lineannotation>-- 0 + 2，然后根据计数停止执行</lineannotation>
 execq
-------
     1
(1 row)

=&gt; SELECT execq('SELECT * FROM a', 10);
INFO:  EXECQ:  0
INFO:  EXECQ:  1
INFO:  EXECQ:  2

 execq
-------
     3              <lineannotation>-- 10是最大值，3是实际行数</lineannotation>
(1 row)

=&gt; SELECT execq('INSERT INTO a SELECT x + 10 FROM a', 1);
 execq
-------
     3              <lineannotation>-- 所有行已处理；计数不会停止，因为没有返回值</lineannotation>
(1 row)

=&gt; SELECT * FROM a;
 x
----
  0
  1
  2
 10
 11
 12
(6 rows)

=&gt; DELETE FROM a;
DELETE 6
=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);
INSERT 0 1
=&gt; SELECT * FROM a;
 x
---
 1                  <lineannotation>-- 0（a中没有行）+ 1</lineannotation>
(1 row)

=&gt; INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1);
INFO:  EXECQ:  1
INSERT 0 1
=&gt; SELECT * FROM a;
 x
---
 1
 2                  <lineannotation>-- 1（a中有一行）+ 1</lineannotation>
(2 rows)

<lineannotation>-- 这演示了数据更改可见性规则。</lineannotation>
<lineannotation>-- execq被调用两次，每次看到不同数量的行：</lineannotation>

=&gt; INSERT INTO a SELECT execq('SELECT * FROM a', 0) * x FROM a;
INFO:  EXECQ:  1    <lineannotation>-- 第一个execq的结果</lineannotation>
INFO:  EXECQ:  2
INFO:  EXECQ:  1    <lineannotation>-- 第二个execq的结果</lineannotation>
INFO:  EXECQ:  2
INFO:  EXECQ:  2
INSERT 0 2
=&gt; SELECT * FROM a;
 x
---
 1
 2
 2                  <lineannotation>-- 2行 * 1（第一行中的x）</lineannotation>
 6                  <lineannotation>-- 3行（2 + 1刚插入）* 2（第二行中的x）</lineannotation>
(4 rows)
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=fed74dbed15c52fa8525f882e5b047b7 -->
 </sect1>
</chapter>
