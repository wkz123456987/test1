<!-- doc/src/sgml/datatype.sgml -->

 <chapter id="datatype">
<!-- pgdoc-cn_start sig_en=4db1c7313abae97c18199af614e269c9 sig_cn_org=None source=14.1 
  <title>Data Types</title>
________________________________________________________-->
  <title>数据类型</title>
<!-- pgdoc-cn_end sig_en=4db1c7313abae97c18199af614e269c9 -->

<!-- pgdoc-cn_start sig_en=505216b3ea0de88b71c817ea7e04c746 sig_cn_org=None source=14.1 
  <indexterm zone="datatype">
   <primary>data type</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="datatype">
   <primary>数据类型</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=505216b3ea0de88b71c817ea7e04c746 -->

<!-- pgdoc-cn_start sig_en=7a1dd2ebd05de51236194f75edd1cfb3 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>type</primary>
   <see>data type</see>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>类型</primary>
   <see>数据类型</see>
  </indexterm>
<!-- pgdoc-cn_end sig_en=7a1dd2ebd05de51236194f75edd1cfb3 -->

<!-- pgdoc-cn_start sig_en=a0d3f7da20dbae1fc02a510e4931348e sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> has a rich set of native data
   types available to users.  Users can add new types to
   <productname>PostgreSQL</productname> using the <xref
   linkend="sql-createtype"/> command.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>有着丰富的本地数据类型可用。用户可以使用<xref linkend="sql-createtype"/>命令为 <productname>PostgreSQL</productname>增加新的数据类型。
  </para>
<!-- pgdoc-cn_end sig_en=a0d3f7da20dbae1fc02a510e4931348e -->

<!-- pgdoc-cn_start sig_en=44bcf2e74d66deca19d7c4e2f166c019 sig_cn_org=None source=14.1 
  <para>
   <xref linkend="datatype-table"/> shows all the built-in general-purpose data
   types. Most of the alternative names listed in the
   <quote>Aliases</quote> column are the names used internally by
   <productname>PostgreSQL</productname> for historical reasons.  In
   addition, some internally used or deprecated types are available,
   but are not listed here.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="datatype-table"/>显示了所有内建的普通数据类型。大部分在<quote>别名</quote>列里列出的可选名字都是因历史原因 被<productname>PostgreSQL</productname>在内部使用的名字。另外，还有一些内部使用的或者废弃的类型也可以用，但没有在这里列出。
  </para>
<!-- pgdoc-cn_end sig_en=44bcf2e74d66deca19d7c4e2f166c019 -->

   <table id="datatype-table">
<!-- pgdoc-cn_start sig_en=4db1c7313abae97c18199af614e269c9 sig_cn_org=None source=14.1 
    <title>Data Types</title>
________________________________________________________-->
    <title>数据类型</title>
<!-- pgdoc-cn_end sig_en=4db1c7313abae97c18199af614e269c9 -->
    <tgroup cols="3">
     <colspec colname="col1" colwidth="2*"/>
     <colspec colname="col2" colwidth="1*"/>
     <colspec colname="col3" colwidth="2*"/>
     <thead>
<!-- pgdoc-cn_start sig_en=8c8f5df4f393dab563a482a7e9d3b92e sig_cn_org=None source=14.1 
      <row>
       <entry>Name</entry>
       <entry>Aliases</entry>
       <entry>Description</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>名字</entry>
       <entry>别名</entry>
       <entry>描述</entry>
      </row>
<!-- pgdoc-cn_end sig_en=8c8f5df4f393dab563a482a7e9d3b92e -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=f33c361d7c56db626159e5711e5783e8 sig_cn_org=None source=14.1 
      <row>
       <entry><type>bigint</type></entry>
       <entry><type>int8</type></entry>
       <entry>signed eight-byte integer</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>bigint</type></entry>
       <entry><type>int8</type></entry>
       <entry>有符号的8字节整数</entry>
      </row>
<!-- pgdoc-cn_end sig_en=f33c361d7c56db626159e5711e5783e8 -->

<!-- pgdoc-cn_start sig_en=06f9f606cad85b6fd28243298fd36020 sig_cn_org=None source=14.1 
      <row>
       <entry><type>bigserial</type></entry>
       <entry><type>serial8</type></entry>
       <entry>autoincrementing eight-byte integer</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>bigserial</type></entry>
       <entry><type>serial8</type></entry>
       <entry>自动增长的8字节整数</entry>
      </row>
<!-- pgdoc-cn_end sig_en=06f9f606cad85b6fd28243298fd36020 -->

<!-- pgdoc-cn_start sig_en=3dbaff865b68b2fe65f3c9e3d6a1d037 sig_cn_org=None source=14.1 
      <row>
       <entry><type>bit [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry></entry>
       <entry>fixed-length bit string</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>bit [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry></entry>
       <entry>定长位串</entry>
      </row>
<!-- pgdoc-cn_end sig_en=3dbaff865b68b2fe65f3c9e3d6a1d037 -->

<!-- pgdoc-cn_start sig_en=4141518f77579cb7d33ce32f01ba199f sig_cn_org=None source=14.1 
      <row>
       <entry><type>bit varying [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>varbit [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry>variable-length bit string</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>bit varying [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>varbit [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry>变长位串</entry>
      </row>
<!-- pgdoc-cn_end sig_en=4141518f77579cb7d33ce32f01ba199f -->

<!-- pgdoc-cn_start sig_en=df8d59209a76fa8e6e9ca64bf9f0dd39 sig_cn_org=None source=14.1 
      <row>
       <entry><type>boolean</type></entry>
       <entry><type>bool</type></entry>
       <entry>logical Boolean (true/false)</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>boolean</type></entry>
       <entry><type>bool</type></entry>
       <entry>逻辑布尔值（真/假）</entry>
      </row>
<!-- pgdoc-cn_end sig_en=df8d59209a76fa8e6e9ca64bf9f0dd39 -->

<!-- pgdoc-cn_start sig_en=1b852dd30c80235debd90a43dbe0a911 sig_cn_org=None source=14.1 
      <row>
       <entry><type>box</type></entry>
       <entry></entry>
       <entry>rectangular box on a plane</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>box</type></entry>
       <entry></entry>
       <entry>平面上的普通方框</entry>
      </row>
<!-- pgdoc-cn_end sig_en=1b852dd30c80235debd90a43dbe0a911 -->

<!-- pgdoc-cn_start sig_en=357f1ebabe010b331f6b4ac9d9ef1679 sig_cn_org=None source=14.1 
      <row>
       <entry><type>bytea</type></entry>
       <entry></entry>
       <entry>binary data (<quote>byte array</quote>)</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>bytea</type></entry>
       <entry></entry>
       <entry>二进制数据（<quote>字节数组</quote>）</entry>
      </row>
<!-- pgdoc-cn_end sig_en=357f1ebabe010b331f6b4ac9d9ef1679 -->

<!-- pgdoc-cn_start sig_en=7ad34d63923673e8ab400ed05f7ca337 sig_cn_org=None source=14.1 
      <row>
       <entry><type>character [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>char [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry>fixed-length character string</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>character [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>char [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry>定长字符串</entry>
      </row>
<!-- pgdoc-cn_end sig_en=7ad34d63923673e8ab400ed05f7ca337 -->

<!-- pgdoc-cn_start sig_en=85dfd2aa8f1d0c2d123b46f8e2b22485 sig_cn_org=None source=14.1 
      <row>
       <entry><type>character varying [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>varchar [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry>variable-length character string</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>character varying [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry><type>varchar [ (<replaceable>n</replaceable>) ]</type></entry>
       <entry>变长字符串</entry>
      </row>
<!-- pgdoc-cn_end sig_en=85dfd2aa8f1d0c2d123b46f8e2b22485 -->

<!-- pgdoc-cn_start sig_en=f105c3f34869a8c6146d3c7ecd7fde83 sig_cn_org=None source=14.1 
      <row>
       <entry><type>cidr</type></entry>
       <entry></entry>
       <entry>IPv4 or IPv6 network address</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>cidr</type></entry>
       <entry></entry>
       <entry>IPv4或IPv6网络地址</entry>
      </row>
<!-- pgdoc-cn_end sig_en=f105c3f34869a8c6146d3c7ecd7fde83 -->

<!-- pgdoc-cn_start sig_en=565954aeb5529cfad0fec3da35c631f5 sig_cn_org=None source=14.1 
      <row>
       <entry><type>circle</type></entry>
       <entry></entry>
       <entry>circle on a plane</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>circle</type></entry>
       <entry></entry>
       <entry>平面上的圆</entry>
      </row>
<!-- pgdoc-cn_end sig_en=565954aeb5529cfad0fec3da35c631f5 -->

<!-- pgdoc-cn_start sig_en=24a7cbad4e58e50f3e293124ea3e6a30 sig_cn_org=None source=14.1 
      <row>
       <entry><type>date</type></entry>
       <entry></entry>
       <entry>calendar date (year, month, day)</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>date</type></entry>
       <entry></entry>
       <entry>日历日期（年、月、日）</entry>
      </row>
<!-- pgdoc-cn_end sig_en=24a7cbad4e58e50f3e293124ea3e6a30 -->

<!-- pgdoc-cn_start sig_en=94e68b6f03141330a90f6495022be42f sig_cn_org=None source=14.1 
      <row>
       <entry><type>double precision</type></entry>
       <entry><type>float8</type></entry>
       <entry>double precision floating-point number (8 bytes)</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>double precision</type></entry>
       <entry><type>float8</type></entry>
       <entry>双精度浮点数（8字节）</entry>
      </row>
<!-- pgdoc-cn_end sig_en=94e68b6f03141330a90f6495022be42f -->

<!-- pgdoc-cn_start sig_en=79109a139559502f97ec4a2f67b904cc sig_cn_org=None source=14.1 
      <row>
       <entry><type>inet</type></entry>
       <entry></entry>
       <entry>IPv4 or IPv6 host address</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>inet</type></entry>
       <entry></entry>
       <entry>IPv4或IPv6主机地址</entry>
      </row>
<!-- pgdoc-cn_end sig_en=79109a139559502f97ec4a2f67b904cc -->

<!-- pgdoc-cn_start sig_en=c7636bec3c60bef201a7cb28c7d3280c sig_cn_org=None source=14.1 
      <row>
       <entry><type>integer</type></entry>
       <entry><type>int</type>, <type>int4</type></entry>
       <entry>signed four-byte integer</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>integer</type></entry>
       <entry><type>int</type>, <type>int4</type></entry>
       <entry>有符号4字节整数</entry>
      </row>
<!-- pgdoc-cn_end sig_en=c7636bec3c60bef201a7cb28c7d3280c -->

<!-- pgdoc-cn_start sig_en=28fa48b529f23d289f4d33e8843dc88e sig_cn_org=None source=14.1 
      <row>
       <entry><type>interval [ <replaceable>fields</replaceable> ] [ (<replaceable>p</replaceable>) ]</type></entry>
       <entry></entry>
       <entry>time span</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>interval [ <replaceable>fields</replaceable> ] [ (<replaceable>p</replaceable>) ]</type></entry>
       <entry></entry>
       <entry>时间段</entry>
      </row>
<!-- pgdoc-cn_end sig_en=28fa48b529f23d289f4d33e8843dc88e -->

<!-- pgdoc-cn_start sig_en=06f7081ba08a7651e1db536eadb19fe6 sig_cn_org=None source=14.1 
      <row>
       <entry><type>json</type></entry>
       <entry></entry>
       <entry>textual JSON data</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>json</type></entry>
       <entry></entry>
       <entry>文本 JSON 数据</entry>
      </row>
<!-- pgdoc-cn_end sig_en=06f7081ba08a7651e1db536eadb19fe6 -->

<!-- pgdoc-cn_start sig_en=6268e4d2297860ef4b5eb4ab29fa476a sig_cn_org=None source=14.1 
      <row>
       <entry><type>jsonb</type></entry>
       <entry></entry>
       <entry>binary JSON data, decomposed</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>jsonb</type></entry>
       <entry></entry>
       <entry>二进制 JSON 数据，已分解</entry>
      </row>
<!-- pgdoc-cn_end sig_en=6268e4d2297860ef4b5eb4ab29fa476a -->

<!-- pgdoc-cn_start sig_en=09bcacb1a606da5fcbe264cfc1859910 sig_cn_org=None source=14.1 
      <row>
       <entry><type>line</type></entry>
       <entry></entry>
       <entry>infinite line on a plane</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>line</type></entry>
       <entry></entry>
       <entry>平面上的无限长的线</entry>
      </row>
<!-- pgdoc-cn_end sig_en=09bcacb1a606da5fcbe264cfc1859910 -->

<!-- pgdoc-cn_start sig_en=388cae6cab2d69ec4e2d420dc80e8e04 sig_cn_org=None source=14.1 
      <row>
       <entry><type>lseg</type></entry>
       <entry></entry>
       <entry>line segment on a plane</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>lseg</type></entry>
       <entry></entry>
       <entry>平面上的线段</entry>
      </row>
<!-- pgdoc-cn_end sig_en=388cae6cab2d69ec4e2d420dc80e8e04 -->

<!-- pgdoc-cn_start sig_en=9188c8a0c12526c29ad56d234ead68eb sig_cn_org=None source=14.1 
      <row>
       <entry><type>macaddr</type></entry>
       <entry></entry>
       <entry>MAC (Media Access Control) address</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>macaddr</type></entry>
       <entry></entry>
       <entry>MAC（Media Access Control）地址</entry>
      </row>
<!-- pgdoc-cn_end sig_en=9188c8a0c12526c29ad56d234ead68eb -->

<!-- pgdoc-cn_start sig_en=6ce25df9d37bf8c4fd7d9c1b382d6c40 sig_cn_org=None source=14.1 
      <row>
       <entry><type>macaddr8</type></entry>
       <entry></entry>
       <entry>MAC (Media Access Control) address (EUI-64 format)</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>macaddr8</type></entry>
       <entry></entry>
       <entry>MAC（Media Access Control）地址（EUI-64格式）</entry>
      </row>
<!-- pgdoc-cn_end sig_en=6ce25df9d37bf8c4fd7d9c1b382d6c40 -->

<!-- pgdoc-cn_start sig_en=ca83a81bd7c2ab9d2d60dbf36b28fdfa sig_cn_org=None source=14.1 
      <row>
       <entry><type>money</type></entry>
       <entry></entry>
       <entry>currency amount</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>money</type></entry>
       <entry></entry>
       <entry>货币数量</entry>
      </row>
<!-- pgdoc-cn_end sig_en=ca83a81bd7c2ab9d2d60dbf36b28fdfa -->

<!-- pgdoc-cn_start sig_en=bc26db64d6a5301af57efc0b45d77f89 sig_cn_org=None source=14.1 
      <row>
       <entry><type>numeric [ (<replaceable>p</replaceable>,
         <replaceable>s</replaceable>) ]</type></entry>
       <entry><type>decimal [ (<replaceable>p</replaceable>,
         <replaceable>s</replaceable>) ]</type></entry>
       <entry>exact numeric of selectable precision</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>numeric [ (<replaceable>p</replaceable>,
         <replaceable>s</replaceable>) ]</type></entry>
       <entry><type>decimal [ (<replaceable>p</replaceable>,
         <replaceable>s</replaceable>) ]</type></entry>
       <entry>可选择精度的精确数字</entry>
      </row>
<!-- pgdoc-cn_end sig_en=bc26db64d6a5301af57efc0b45d77f89 -->

<!-- pgdoc-cn_start sig_en=f4deca0c3065b752d09a4d885a107450 sig_cn_org=None source=14.1 
      <row>
       <entry><type>path</type></entry>
       <entry></entry>
       <entry>geometric path on a plane</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>path</type></entry>
       <entry></entry>
       <entry>平面上的几何路径</entry>
      </row>
<!-- pgdoc-cn_end sig_en=f4deca0c3065b752d09a4d885a107450 -->

<!-- pgdoc-cn_start sig_en=3aeeb3e5ba70fbfe102b592551e390ba sig_cn_org=None source=14.1 
      <row>
       <entry><type>pg_lsn</type></entry>
       <entry></entry>
       <entry><productname>PostgreSQL</productname> Log Sequence Number</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>pg_lsn</type></entry>
       <entry></entry>
       <entry><productname>PostgreSQL</productname>日志序列号</entry>
      </row>
<!-- pgdoc-cn_end sig_en=3aeeb3e5ba70fbfe102b592551e390ba -->

<!-- pgdoc-cn_start sig_en=39800805898e4338bec29c9a3c1518b9 sig_cn_org=None source=14.1 
      <row>
       <entry><type>pg_snapshot</type></entry>
       <entry></entry>
       <entry>user-level transaction ID snapshot</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>pg_snapshot</type></entry>
       <entry></entry>
       <entry>用户级事务ID快照</entry>
      </row>
<!-- pgdoc-cn_end sig_en=39800805898e4338bec29c9a3c1518b9 -->

<!-- pgdoc-cn_start sig_en=03d85cc68d867da20ea27719ca4684e8 sig_cn_org=None source=14.1 
      <row>
       <entry><type>point</type></entry>
       <entry></entry>
       <entry>geometric point on a plane</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>point</type></entry>
       <entry></entry>
       <entry>平面上的几何点</entry>
      </row>
<!-- pgdoc-cn_end sig_en=03d85cc68d867da20ea27719ca4684e8 -->

<!-- pgdoc-cn_start sig_en=1a361c322acfb8440956efdcdce0b71f sig_cn_org=None source=14.1 
      <row>
       <entry><type>polygon</type></entry>
       <entry></entry>
       <entry>closed geometric path on a plane</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>polygon</type></entry>
       <entry></entry>
       <entry>平面上的封闭几何路径</entry>
      </row>
<!-- pgdoc-cn_end sig_en=1a361c322acfb8440956efdcdce0b71f -->

<!-- pgdoc-cn_start sig_en=f007ab7d439de4b45efc194969901a90 sig_cn_org=None source=14.1 
      <row>
       <entry><type>real</type></entry>
       <entry><type>float4</type></entry>
       <entry>single precision floating-point number (4 bytes)</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>real</type></entry>
       <entry><type>float4</type></entry>
       <entry>单精度浮点数（4字节）</entry>
      </row>
<!-- pgdoc-cn_end sig_en=f007ab7d439de4b45efc194969901a90 -->

<!-- pgdoc-cn_start sig_en=2f56a55f1a1905d6c834c14bf138e02e sig_cn_org=None source=14.1 
      <row>
       <entry><type>smallint</type></entry>
       <entry><type>int2</type></entry>
       <entry>signed two-byte integer</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>smallint</type></entry>
       <entry><type>int2</type></entry>
       <entry>有符号2字节整数</entry>
      </row>
<!-- pgdoc-cn_end sig_en=2f56a55f1a1905d6c834c14bf138e02e -->

<!-- pgdoc-cn_start sig_en=36462c968eb14a863037beb0669662ab sig_cn_org=None source=14.1 
      <row>
       <entry><type>smallserial</type></entry>
       <entry><type>serial2</type></entry>
       <entry>autoincrementing two-byte integer</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>smallserial</type></entry>
       <entry><type>serial2</type></entry>
       <entry>自动增长的2字节整数</entry>
      </row>
<!-- pgdoc-cn_end sig_en=36462c968eb14a863037beb0669662ab -->

<!-- pgdoc-cn_start sig_en=76e6e82dcfbc74fd181d02af23b81a85 sig_cn_org=None source=14.1 
      <row>
       <entry><type>serial</type></entry>
       <entry><type>serial4</type></entry>
       <entry>autoincrementing four-byte integer</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>serial</type></entry>
       <entry><type>serial4</type></entry>
       <entry>自动增长的4字节整数</entry>
      </row>
<!-- pgdoc-cn_end sig_en=76e6e82dcfbc74fd181d02af23b81a85 -->

<!-- pgdoc-cn_start sig_en=638c4e68f0b1a90d40d8f5dfcab58687 sig_cn_org=None source=14.1 
      <row>
       <entry><type>text</type></entry>
       <entry></entry>
       <entry>variable-length character string</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>text</type></entry>
       <entry></entry>
       <entry>变长字符串</entry>
      </row>
<!-- pgdoc-cn_end sig_en=638c4e68f0b1a90d40d8f5dfcab58687 -->

<!-- pgdoc-cn_start sig_en=ef573256f1eaec08a6cae1dd336a0767 sig_cn_org=None source=14.1 
      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
       <entry></entry>
       <entry>time of day (no time zone)</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
       <entry></entry>
       <entry>一天中的时间（无时区）</entry>
      </row>
<!-- pgdoc-cn_end sig_en=ef573256f1eaec08a6cae1dd336a0767 -->

<!-- pgdoc-cn_start sig_en=411938b5daeca6e9878a89810ad7360f sig_cn_org=None source=14.1 
      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
       <entry><type>timetz</type></entry>
       <entry>time of day, including time zone</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
       <entry><type>timetz</type></entry>
       <entry>一天中的时间，包括时区</entry>
      </row>
<!-- pgdoc-cn_end sig_en=411938b5daeca6e9878a89810ad7360f -->

<!-- pgdoc-cn_start sig_en=39482e0557e493c0748b8f05620b3b05 sig_cn_org=None source=14.1 
      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
       <entry></entry>
       <entry>date and time (no time zone)</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
       <entry></entry>
       <entry>日期和时间（无时区）</entry>
      </row>
<!-- pgdoc-cn_end sig_en=39482e0557e493c0748b8f05620b3b05 -->

<!-- pgdoc-cn_start sig_en=9cf83eba57943fd59675f9c18f56bd09 sig_cn_org=None source=14.1 
      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
       <entry><type>timestamptz</type></entry>
       <entry>date and time, including time zone</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>timestamp [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
       <entry><type>timestamptz</type></entry>
       <entry>日期和时间，包括时区</entry>
      </row>
<!-- pgdoc-cn_end sig_en=9cf83eba57943fd59675f9c18f56bd09 -->

<!-- pgdoc-cn_start sig_en=9f0a88d2fbfb527080f2ea2432c5d915 sig_cn_org=None source=14.1 
      <row>
       <entry><type>tsquery</type></entry>
       <entry></entry>
       <entry>text search query</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>tsquery</type></entry>
       <entry></entry>
       <entry>文本搜索查询</entry>
      </row>
<!-- pgdoc-cn_end sig_en=9f0a88d2fbfb527080f2ea2432c5d915 -->

<!-- pgdoc-cn_start sig_en=e6cee53b28556af580b92976b29b403e sig_cn_org=None source=14.1 
      <row>
       <entry><type>tsvector</type></entry>
       <entry></entry>
       <entry>text search document</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>tsvector</type></entry>
       <entry></entry>
       <entry>文本搜索文档</entry>
      </row>
<!-- pgdoc-cn_end sig_en=e6cee53b28556af580b92976b29b403e -->

<!-- pgdoc-cn_start sig_en=347a451fcd66db9130700a6800503766 sig_cn_org=None source=14.1 
      <row>
       <entry><type>txid_snapshot</type></entry>
       <entry></entry>
       <entry>user-level transaction ID snapshot (deprecated; see <type>pg_snapshot</type>)</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>txid_snapshot</type></entry>
       <entry></entry>
       <entry>用户级别事务ID快照(废弃; 参见 <type>pg_snapshot</type>)</entry>
      </row>
<!-- pgdoc-cn_end sig_en=347a451fcd66db9130700a6800503766 -->

<!-- pgdoc-cn_start sig_en=d4cbabf2919753e8e2edb4e701e1e3c6 sig_cn_org=None source=14.1 
      <row>
       <entry><type>uuid</type></entry>
       <entry></entry>
       <entry>universally unique identifier</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>uuid</type></entry>
       <entry></entry>
       <entry>通用唯一标识码</entry>
      </row>
<!-- pgdoc-cn_end sig_en=d4cbabf2919753e8e2edb4e701e1e3c6 -->

<!-- pgdoc-cn_start sig_en=b919e30e65aaceb4e8051d3b45586652 sig_cn_org=None source=14.1 
      <row>
       <entry><type>xml</type></entry>
       <entry></entry>
       <entry>XML data</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>xml</type></entry>
       <entry></entry>
       <entry>XML数据</entry>
      </row>
<!-- pgdoc-cn_end sig_en=b919e30e65aaceb4e8051d3b45586652 -->
     </tbody>
    </tgroup>
   </table>

  <note>
<!-- pgdoc-cn_start sig_en=b38d493f3c2d2d5d9a7a49d257da9811 sig_cn_org=None source=14.1 
   <title>Compatibility</title>
________________________________________________________-->
   <title>兼容性</title>
<!-- pgdoc-cn_end sig_en=b38d493f3c2d2d5d9a7a49d257da9811 -->
<!-- pgdoc-cn_start sig_en=ad52c484d27054ea3a939421167ee42c sig_cn_org=None source=14.1 
   <para>
    The following types (or spellings thereof) are specified by
    <acronym>SQL</acronym>: <type>bigint</type>, <type>bit</type>, <type>bit
    varying</type>, <type>boolean</type>, <type>char</type>,
    <type>character varying</type>, <type>character</type>,
    <type>varchar</type>, <type>date</type>, <type>double
    precision</type>, <type>integer</type>, <type>interval</type>,
    <type>numeric</type>, <type>decimal</type>, <type>real</type>,
    <type>smallint</type>, <type>time</type> (with or without time zone),
    <type>timestamp</type> (with or without time zone),
    <type>xml</type>.
   </para>
________________________________________________________-->
   <para>
    下列类型（或者及其拼写）是<acronym>SQL</acronym>指定的：<type>bigint</type>、<type>bit</type>、<type>bit varying</type>、<type>boolean</type>、<type>char</type>、<type>character varying</type>、<type>character</type>、<type>varchar</type>、<type>date</type>、<type>double precision</type>、<type>integer</type>、<type>interval</type>、<type>numeric</type>、<type>decimal</type>、<type>real</type>、<type>smallint</type>、<type>time</type>（有时区或无时区）、<type>timestamp</type>（有时区或无时区）、<type>xml</type>。
   </para>
<!-- pgdoc-cn_end sig_en=ad52c484d27054ea3a939421167ee42c -->
  </note>

<!-- pgdoc-cn_start sig_en=51c7e72f215dec9f01c24b1b0a641b84 sig_cn_org=None source=14.1 
  <para>
   Each data type has an external representation determined by its input
   and output functions.  Many of the built-in types have
   obvious external formats.  However, several types are either unique
   to <productname>PostgreSQL</productname>, such as geometric
   paths, or have several possible formats, such as the date
   and time types.
   Some of the input and output functions are not invertible, i.e.,
   the result of an output function might lose accuracy when compared to
   the original input.
  </para>
________________________________________________________-->
  <para>
   每种数据类型都有一个由其输入和输出函数决定的外部表现形式。许多内建的类型有明显的格式。不过，许多类型要么是<productname>PostgreSQL</productname>所特有的（例如几何路径），要么可能是有几种不同的格式（例如日期和时间类型）。 有些输入和输出函数是不可逆的，即输出函数的结果和原始输入比较时可能丢失精度。
  </para>
<!-- pgdoc-cn_end sig_en=51c7e72f215dec9f01c24b1b0a641b84 -->

  <sect1 id="datatype-numeric">
<!-- pgdoc-cn_start sig_en=e110fd57fa89d9c906db7244fbb9e62a sig_cn_org=None source=14.1 
   <title>Numeric Types</title>
________________________________________________________-->
   <title>数字类型</title>
<!-- pgdoc-cn_end sig_en=e110fd57fa89d9c906db7244fbb9e62a -->

<!-- pgdoc-cn_start sig_en=7e8abf5075466f51e6fdede8f9c12aeb sig_cn_org=None source=14.1 
   <indexterm zone="datatype-numeric">
    <primary>data type</primary>
    <secondary>numeric</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-numeric">
    <primary>数据类型</primary>
    <secondary>数字</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=7e8abf5075466f51e6fdede8f9c12aeb -->

<!-- pgdoc-cn_start sig_en=4f562f56f3d46a9dd0e14b5d990605e0 sig_cn_org=None source=14.1 
   <para>
    Numeric types consist of two-, four-, and eight-byte integers,
    four- and eight-byte floating-point numbers, and selectable-precision
    decimals.  <xref linkend="datatype-numeric-table"/> lists the
    available types.
   </para>
________________________________________________________-->
   <para>
    数字类型由2、4或8字节的整数以及4或8字节的浮点数和可选精度小数组成。<xref linkend="datatype-numeric-table"/>列出了所有可用类型。
   </para>
<!-- pgdoc-cn_end sig_en=4f562f56f3d46a9dd0e14b5d990605e0 -->

    <table id="datatype-numeric-table">
<!-- pgdoc-cn_start sig_en=e110fd57fa89d9c906db7244fbb9e62a sig_cn_org=None source=14.1 
     <title>Numeric Types</title>
________________________________________________________-->
     <title>数字类型</title>
<!-- pgdoc-cn_end sig_en=e110fd57fa89d9c906db7244fbb9e62a -->
     <tgroup cols="4">
      <colspec colname="col1" colwidth="2*"/>
      <colspec colname="col2" colwidth="1*"/>
      <colspec colname="col3" colwidth="2*"/>
      <colspec colname="col4" colwidth="2*"/>
      <thead>
<!-- pgdoc-cn_start sig_en=eb61dfa4ad1188b3f53b37e835c3d8fb sig_cn_org=None source=14.1 
       <row>
        <entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry>
        <entry>Range</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>名字</entry>
        <entry>存储尺寸</entry>
        <entry>描述</entry>
        <entry>范围</entry>
       </row>
<!-- pgdoc-cn_end sig_en=eb61dfa4ad1188b3f53b37e835c3d8fb -->
      </thead>

      <tbody>
<!-- pgdoc-cn_start sig_en=f96a70059ae590eb9bc6642c0b9c9bef sig_cn_org=None source=14.1 
       <row>
        <entry><type>smallint</type></entry>
        <entry>2 bytes</entry>
        <entry>small-range integer</entry>
        <entry>-32768 to +32767</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>smallint</type></entry>
        <entry>2字节</entry>
        <entry>小范围整数</entry>
        <entry>-32768 to +32767</entry>
       </row>
<!-- pgdoc-cn_end sig_en=f96a70059ae590eb9bc6642c0b9c9bef -->
<!-- pgdoc-cn_start sig_en=804c1477b703b0c048c38d845a5e6566 sig_cn_org=None source=14.1 
       <row>
        <entry><type>integer</type></entry>
        <entry>4 bytes</entry>
        <entry>typical choice for integer</entry>
        <entry>-2147483648 to +2147483647</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>integer</type></entry>
        <entry>4字节</entry>
        <entry>整数的典型选择</entry>
        <entry>-2147483648 to +2147483647</entry>
       </row>
<!-- pgdoc-cn_end sig_en=804c1477b703b0c048c38d845a5e6566 -->
<!-- pgdoc-cn_start sig_en=228d74f63365b1e51e3419da57604cfd sig_cn_org=None source=14.1 
       <row>
        <entry><type>bigint</type></entry>
        <entry>8 bytes</entry>
        <entry>large-range integer</entry>
        <entry>-9223372036854775808 to +9223372036854775807</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>bigint</type></entry>
        <entry>8字节</entry>
        <entry>大范围整数</entry>
        <entry>-9223372036854775808 to +9223372036854775807</entry>
       </row>
<!-- pgdoc-cn_end sig_en=228d74f63365b1e51e3419da57604cfd -->

<!-- pgdoc-cn_start sig_en=6a81f6a35cec2cae4c01064bfee84519 sig_cn_org=None source=14.1 
       <row>
        <entry><type>decimal</type></entry>
        <entry>variable</entry>
        <entry>user-specified precision, exact</entry>
        <entry>up to 131072 digits before the decimal point; up to 16383 digits after the decimal point</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>decimal</type></entry>
        <entry>可变</entry>
        <entry>用户指定精度，精确</entry>
        <entry>最高小数点前131072位，以及小数点后16383位</entry>
       </row>
<!-- pgdoc-cn_end sig_en=6a81f6a35cec2cae4c01064bfee84519 -->
<!-- pgdoc-cn_start sig_en=57df0f62b210ad35b78df785c4e4186f sig_cn_org=None source=14.1 
       <row>
        <entry><type>numeric</type></entry>
        <entry>variable</entry>
        <entry>user-specified precision, exact</entry>
        <entry>up to 131072 digits before the decimal point; up to 16383 digits after the decimal point</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>numeric</type></entry>
        <entry>可变</entry>
        <entry>用户指定精度，精确</entry>
        <entry>最高小数点前131072位，以及小数点后16383位</entry>
       </row>
<!-- pgdoc-cn_end sig_en=57df0f62b210ad35b78df785c4e4186f -->

<!-- pgdoc-cn_start sig_en=e6432d885e93a4e212db12a4738cc833 sig_cn_org=None source=14.1 
       <row>
        <entry><type>real</type></entry>
        <entry>4 bytes</entry>
        <entry>variable-precision, inexact</entry>
        <entry>6 decimal digits precision</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>real</type></entry>
        <entry>4字节</entry>
        <entry>可变精度，不精确</entry>
        <entry>6位十进制精度</entry>
       </row>
<!-- pgdoc-cn_end sig_en=e6432d885e93a4e212db12a4738cc833 -->
<!-- pgdoc-cn_start sig_en=484614bcc37b15dd319e02976eeb5da6 sig_cn_org=None source=14.1 
       <row>
        <entry><type>double precision</type></entry>
        <entry>8 bytes</entry>
        <entry>variable-precision, inexact</entry>
        <entry>15 decimal digits precision</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>double precision</type></entry>
        <entry>8字节</entry>
        <entry>可变精度，不精确</entry>
        <entry>15位十进制精度</entry>
       </row>
<!-- pgdoc-cn_end sig_en=484614bcc37b15dd319e02976eeb5da6 -->

<!-- pgdoc-cn_start sig_en=eb5f6dcb77f0486e5b9f986a2b861c97 sig_cn_org=None source=14.1 
       <row>
        <entry><type>smallserial</type></entry>
        <entry>2 bytes</entry>
        <entry>small autoincrementing integer</entry>
        <entry>1 to 32767</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>smallserial</type></entry>
        <entry>2字节</entry>
        <entry>自动增加的小整数</entry>
        <entry>1到32767</entry>
       </row>
<!-- pgdoc-cn_end sig_en=eb5f6dcb77f0486e5b9f986a2b861c97 -->

<!-- pgdoc-cn_start sig_en=247f2ce008ff6abf3b72b8cf9dc83aec sig_cn_org=None source=14.1 
       <row>
        <entry><type>serial</type></entry>
        <entry>4 bytes</entry>
        <entry>autoincrementing integer</entry>
        <entry>1 to 2147483647</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>serial</type></entry>
        <entry>4字节</entry>
        <entry>自动增加的整数</entry>
        <entry>1到2147483647</entry>
       </row>
<!-- pgdoc-cn_end sig_en=247f2ce008ff6abf3b72b8cf9dc83aec -->

<!-- pgdoc-cn_start sig_en=250cb4c72eb01c4ca9c144c864fcca42 sig_cn_org=None source=14.1 
       <row>
        <entry><type>bigserial</type></entry>
        <entry>8 bytes</entry>
        <entry>large autoincrementing integer</entry>
        <entry>1 to 9223372036854775807</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>bigserial</type></entry>
        <entry>8字节</entry>
        <entry>自动增长的大整数</entry>
        <entry>1到9223372036854775807</entry>
       </row>
<!-- pgdoc-cn_end sig_en=250cb4c72eb01c4ca9c144c864fcca42 -->
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=bae4121e9b34ebc77f0b5972ee2d9bbd sig_cn_org=None source=14.1 
   <para>
    The syntax of constants for the numeric types is described in
    <xref linkend="sql-syntax-constants"/>.  The numeric types have a
    full set of corresponding arithmetic operators and
    functions. Refer to <xref linkend="functions"/> for more
    information.  The following sections describe the types in detail.
   </para>
________________________________________________________-->
   <para>
    数字类型常量的语法在<xref linkend="sql-syntax-constants"/>里描述。数字类型有一整套对应的数学操作符和函数。相关信息请参考 <xref linkend="functions"/>。下面的几节详细描述这些类型。
   </para>
<!-- pgdoc-cn_end sig_en=bae4121e9b34ebc77f0b5972ee2d9bbd -->

   <sect2 id="datatype-int">
<!-- pgdoc-cn_start sig_en=3a57e5324d014c57eac095faf52dae95 sig_cn_org=None source=14.1 
    <title>Integer Types</title>
________________________________________________________-->
    <title>整数类型</title>
<!-- pgdoc-cn_end sig_en=3a57e5324d014c57eac095faf52dae95 -->

<!-- pgdoc-cn_start sig_en=fed32fc77c3c5dbbf308ab119a2fc709 sig_cn_org=None source=14.1 
    <indexterm zone="datatype-int">
     <primary>integer</primary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="datatype-int">
     <primary>整数</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=fed32fc77c3c5dbbf308ab119a2fc709 -->

<!-- pgdoc-cn_start sig_en=e8bd63295f285fce873608429230cad9 sig_cn_org=None source=14.1 
    <indexterm zone="datatype-int">
     <primary>smallint</primary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="datatype-int">
     <primary>smallint</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=e8bd63295f285fce873608429230cad9 -->

<!-- pgdoc-cn_start sig_en=5e2a89e144525220f4f2fcf3ab41f803 sig_cn_org=None source=14.1 
    <indexterm zone="datatype-int">
     <primary>bigint</primary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="datatype-int">
     <primary>bigint</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=5e2a89e144525220f4f2fcf3ab41f803 -->

<!-- pgdoc-cn_start sig_en=c5c6e0f175957d890011acfce9b78639 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>int4</primary>
     <see>integer</see>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>int4</primary>
     <see>整数</see>
    </indexterm>
<!-- pgdoc-cn_end sig_en=c5c6e0f175957d890011acfce9b78639 -->

<!-- pgdoc-cn_start sig_en=4c1e58fa6d504facf07a64e80bacf55c sig_cn_org=None source=14.1 
    <indexterm>
     <primary>int2</primary>
     <see>smallint</see>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>int2</primary>
     <see>smallint</see>
    </indexterm>
<!-- pgdoc-cn_end sig_en=4c1e58fa6d504facf07a64e80bacf55c -->

<!-- pgdoc-cn_start sig_en=5c16c4590ea78e0b2b93c926348d5d1d sig_cn_org=None source=14.1 
    <indexterm>
     <primary>int8</primary>
     <see>bigint</see>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>int8</primary>
     <see>bigint</see>
    </indexterm>
<!-- pgdoc-cn_end sig_en=5c16c4590ea78e0b2b93c926348d5d1d -->

<!-- pgdoc-cn_start sig_en=5579716da904ff504d0d7b0ea12171d5 sig_cn_org=None source=14.1 
    <para>
     The types <type>smallint</type>, <type>integer</type>, and
     <type>bigint</type> store whole numbers, that is, numbers without
     fractional components, of various ranges.  Attempts to store
     values outside of the allowed range will result in an error.
    </para>
________________________________________________________-->
    <para>
     类型<type>smallint</type>、<type>integer</type>和<type>bigint</type>存储各种范围的全部是数字的数，也就是没有小数部分的数字。试图存储超出范围以外的值将导致一个错误。
    </para>
<!-- pgdoc-cn_end sig_en=5579716da904ff504d0d7b0ea12171d5 -->

<!-- pgdoc-cn_start sig_en=c31ef098c2840f8728890f3eab884eac sig_cn_org=None source=14.1 
    <para>
     The type <type>integer</type> is the common choice, as it offers
     the best balance between range, storage size, and performance.
     The <type>smallint</type> type is generally only used if disk
     space is at a premium.  The <type>bigint</type> type is designed to be
     used when the range of the <type>integer</type> type is insufficient.
    </para>
________________________________________________________-->
    <para>
     常用的类型是<type>integer</type>，因为它提供了在范围、存储空间和性能之间的最佳平衡。一般只有在磁盘空间紧张的时候才使用 <type>smallint</type>类型。而只有在<type>integer</type>的范围不够的时候才使用<type>bigint</type>。
    </para>
<!-- pgdoc-cn_end sig_en=c31ef098c2840f8728890f3eab884eac -->

<!-- pgdoc-cn_start sig_en=76f8dd900b862dab275669b8534b0e6e sig_cn_org=None source=14.1 
    <para>
     <acronym>SQL</acronym> only specifies the integer types
     <type>integer</type> (or <type>int</type>),
     <type>smallint</type>, and <type>bigint</type>.  The
     type names <type>int2</type>, <type>int4</type>, and
     <type>int8</type> are extensions, which are also used by some
     other <acronym>SQL</acronym> database systems.
    </para>
________________________________________________________-->
    <para>
     <acronym>SQL</acronym>只声明了整数类型<type>integer</type>（或<type>int</type>）、<type>smallint</type>和<type>bigint</type>。类型<type>int2</type>、<type>int4</type>和<type>int8</type>都是扩展，也在许多其它<acronym>SQL</acronym>数据库系统中使用。
    </para>
<!-- pgdoc-cn_end sig_en=76f8dd900b862dab275669b8534b0e6e -->

   </sect2>

   <sect2 id="datatype-numeric-decimal">
<!-- pgdoc-cn_start sig_en=4ceb63d631bd121da91e93a24469dabd sig_cn_org=None source=14.1 
    <title>Arbitrary Precision Numbers</title>
________________________________________________________-->
    <title>任意精度数字</title>
<!-- pgdoc-cn_end sig_en=4ceb63d631bd121da91e93a24469dabd -->

<!-- pgdoc-cn_start sig_en=c63f18954ac414cae2757ad12587c595 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>numeric (data type)</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>数字（数据类型）</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=c63f18954ac414cae2757ad12587c595 -->

<!-- pgdoc-cn_start sig_en=7335e0442f90963554a0b6ba799f34e7 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>arbitrary precision numbers</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>任意精度数字</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=7335e0442f90963554a0b6ba799f34e7 -->

<!-- pgdoc-cn_start sig_en=925b51bff13eec6f59975a98ca828a20 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>decimal</primary>
     <see>numeric</see>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>decimal</primary>
     <see>numeric</see>
    </indexterm>
<!-- pgdoc-cn_end sig_en=925b51bff13eec6f59975a98ca828a20 -->

<!-- pgdoc-cn_start sig_en=f51bed549914a1fd2fe1d15549f78e15 sig_cn_org=None source=14.1 
    <para>
     The type <type>numeric</type> can store numbers with a
     very large number of digits. It is especially recommended for
     storing monetary amounts and other quantities where exactness is
     required.  Calculations with <type>numeric</type> values yield exact
     results where possible, e.g.,  addition, subtraction, multiplication.
     However, calculations on <type>numeric</type> values are very slow
     compared to the integer types, or to the floating-point types
     described in the next section.
    </para>
________________________________________________________-->
    <para>
     类型<type>numeric</type>可以存储非常多位的数字。我们特别建议将它用于货币金额和其它要求计算准确的数量。<type>numeric</type>值的计算在可能的情况下会得到准确的结果，例如加法、减法、乘法。不过，<type>numeric</type>类型上的算术运算比整数类型或者下一节描述的浮点数类型要慢很多。
    </para>
<!-- pgdoc-cn_end sig_en=f51bed549914a1fd2fe1d15549f78e15 -->

<!-- pgdoc-cn_start sig_en=9a7223eca34200ba1dcf630a2ffcd636 sig_cn_org=None source=14.1 
    <para>
     We use the following terms below:  The
     <firstterm>precision</firstterm> of a <type>numeric</type>
     is the total count of significant digits in the whole number,
     that is, the number of digits to both sides of the decimal point.
     The <firstterm>scale</firstterm> of a <type>numeric</type> is the
     count of decimal digits in the fractional part, to the right of the
     decimal point.  So the number 23.5141 has a precision of 6 and a
     scale of 4.  Integers can be considered to have a scale of zero.
    </para>
________________________________________________________-->
    <para>
     在随后的内容里，我们使用了下述术语：一个<type>numeric</type>的<firstterm>precision</firstterm>（精度）是整个数中有效位的总数，也就是小数点两边的位数。<type>numeric</type>的<firstterm>scale</firstterm>（小数位数）是小数部分的数字位数，也就是小数点右边的部分。因此数字 23.5141 的精度为6而小数位数为4。可以认为整数的小数位数为零。
    </para>
<!-- pgdoc-cn_end sig_en=9a7223eca34200ba1dcf630a2ffcd636 -->

<!-- pgdoc-cn_start sig_en=22ac82a863dbc10da2e7b0f9c2e23549 sig_cn_org=26e18b66cf6f554b2165d2480fb8cdce source=15.7 
    <para>
     Both the maximum precision and the maximum scale of a
     <type>numeric</type> column can be
     configured.  To declare a column of type <type>numeric</type> use
     the syntax:
<programlisting>
NUMERIC(<replaceable>precision</replaceable>, <replaceable>scale</replaceable>)
</programlisting>
     The precision must be positive, while the scale may be positive or
     negative (see below).  Alternatively:
<programlisting>
NUMERIC(<replaceable>precision</replaceable>)
</programlisting>
     selects a scale of 0.  Specifying:
<programlisting>
NUMERIC
</programlisting>
     without any precision or scale creates an <quote>unconstrained
     numeric</quote> column in which numeric values of any length can be
     stored, up to the implementation limits.  A column of this kind will
     not coerce input values to any particular scale, whereas
     <type>numeric</type> columns with a declared scale will coerce
     input values to that scale.  (The <acronym>SQL</acronym> standard
     requires a default scale of 0, i.e., coercion to integer
     precision.  We find this a bit useless.  If you're concerned
     about portability, always specify the precision and scale
     explicitly.)
    </para>
________________________________________________________-->
    <para>
     <type>numeric</type>的最大精度和最大标度都可以配置。要声明<type>numeric</type>类型的列，请使用以下语法：
<programlisting>
NUMERIC(<replaceable>precision</replaceable>, <replaceable>scale</replaceable>)
</programlisting>
     精度必须是正数，而标度可以是正数或负数（见下文）。另外：
<programlisting>
NUMERIC(<replaceable>precision</replaceable>)
</programlisting>
     选择标度为0。指定：
<programlisting>
NUMERIC
</programlisting>
     没有任何精度或标度会创建一个<quote>无约束的数值</quote>列，其中可以存储任意长度的数值，直到实现限制。这种列不会强制输入值到任何特定的标度，而带有声明标度的<type>numeric</type>列会强制输入值到该标度。
     （<acronym>SQL</acronym>标准要求默认标度为0，即强制到整数精度。我们觉得这有点无用。如果你关心可移植性，总是明确指定精度和标度。）
    </para>
<!-- pgdoc-cn_end sig_en=22ac82a863dbc10da2e7b0f9c2e23549 -->

    <note>
<!-- pgdoc-cn_start sig_en=babbc87ea4ca33190c366d68ccbde43a sig_cn_org=d5dcf0ed356c190cba718da6ed252e66 source=15.7 
     <para>
      The maximum precision that can be explicitly specified in
      a <type>numeric</type> type declaration is 1000.  An
      unconstrained <type>numeric</type> column is subject to the limits
      described in <xref linkend="datatype-numeric-table"/>.
     </para>
________________________________________________________-->
     <para>
      可以在<type>numeric</type>类型声明中明确指定的最大精度为1000。一个无约束的<type>numeric</type>列受到在<xref linkend="datatype-numeric-table"/>中描述的限制。
     </para>
<!-- pgdoc-cn_end sig_en=babbc87ea4ca33190c366d68ccbde43a -->
    </note>

<!-- pgdoc-cn_start sig_en=8ae5d378bc5021cb7866744dc669fdb1 sig_cn_org=335d33bc7f1302e0d44201f9472b58f0 source=15.7 
    <para>
     If the scale of a value to be stored is greater than the declared
     scale of the column, the system will round the value to the specified
     number of fractional digits.  Then, if the number of digits to the
     left of the decimal point exceeds the declared precision minus the
     declared scale, an error is raised.
     For example, a column declared as
<programlisting>
NUMERIC(3, 1)
</programlisting>
     will round values to 1 decimal place and can store values between
     -99.9 and 99.9, inclusive.
    </para>
________________________________________________________-->
    <para>
     如果要存储的值的范围大于列的声明范围，则系统将将该值四舍五入到指定的小数位数。
     然后，如果小数点左边的数字位数超过声明精度减去声明范围，则会引发错误。
     例如，声明为
<programlisting>
NUMERIC(3, 1)
</programlisting>
     的列将将值四舍五入到1位小数，并且可以存储在-99.9和99.9之间的值，包括边界值。
    </para>
<!-- pgdoc-cn_end sig_en=8ae5d378bc5021cb7866744dc669fdb1 -->

<!-- pgdoc-cn_start sig_en=ee0adcce8d8b5b12f2ca2a3dffdc40b2 sig_cn_org=639498b7437a9635ae209088ebb8ebbc source=15.7 
    <para>
     Beginning in <productname>PostgreSQL</productname> 15, it is allowed
     to declare a <type>numeric</type> column with a negative scale.  Then
     values will be rounded to the left of the decimal point.  The
     precision still represents the maximum number of non-rounded digits.
     Thus, a column declared as
<programlisting>
NUMERIC(2, -3)
</programlisting>
     will round values to the nearest thousand and can store values
     between -99000 and 99000, inclusive.
     It is also allowed to declare a scale larger than the declared
     precision.  Such a column can only hold fractional values, and it
     requires the number of zero digits just to the right of the decimal
     point to be at least the declared scale minus the declared precision.
     For example, a column declared as
<programlisting>
NUMERIC(3, 5)
</programlisting>
     will round values to 5 decimal places and can store values between
     -0.00999 and 0.00999, inclusive.
    </para>
________________________________________________________-->
    <para>
     从<productname>PostgreSQL</productname> 15开始，允许声明带有负标度的<type>numeric</type>列。
     然后值将四舍五入到小数点左侧。精度仍表示最大非四舍五入数字的数量。
     因此，声明为
<programlisting>
NUMERIC(2, -3)
</programlisting>
     的列将值四舍五入到最接近的千位，并可以存储在-99000和99000之间的值，包括这两个值。
     也允许声明比声明的精度更大的标度。这样的列只能容纳小数值，并且需要小数点右侧的零位数至少等于声明的标度减去声明的精度。
     例如，声明为
<programlisting>
NUMERIC(3, 5)
</programlisting>
     的列将值四舍五入到5位小数，并可以存储在-0.00999和0.00999之间的值，包括这两个值。
    </para>
<!-- pgdoc-cn_end sig_en=ee0adcce8d8b5b12f2ca2a3dffdc40b2 -->

    <note>
<!-- pgdoc-cn_start sig_en=d7c0fbcb3ffa8617f8387f3ef3ad0ab3 sig_cn_org=8e467de4b29aa0a4ecf5745f7f517aab source=15.7 
     <para>
      <productname>PostgreSQL</productname> permits the scale in a
      <type>numeric</type> type declaration to be any value in the range
      -1000 to 1000.  However, the <acronym>SQL</acronym> standard requires
      the scale to be in the range 0 to <replaceable>precision</replaceable>.
      Using scales outside that range may not be portable to other database
      systems.
     </para>
________________________________________________________-->
     <para>
      <productname>PostgreSQL</productname>允许在<type>numeric</type>类型声明中的比例为-1000到1000的任意值。
      然而，<acronym>SQL</acronym>标准要求比例在0到<replaceable>precision</replaceable>的范围内。
      使用超出该范围的比例可能无法在其他数据库系统中移植。
     </para>
<!-- pgdoc-cn_end sig_en=d7c0fbcb3ffa8617f8387f3ef3ad0ab3 -->
    </note>

<!-- pgdoc-cn_start sig_en=dc44b1743acb46c682f13545229fffc4 sig_cn_org=None source=14.1 
    <para>
     Numeric values are physically stored without any extra leading or
     trailing zeroes.  Thus, the declared precision and scale of a column
     are maximums, not fixed allocations.  (In this sense the <type>numeric</type>
     type is more akin to <type>varchar(<replaceable>n</replaceable>)</type>
     than to <type>char(<replaceable>n</replaceable>)</type>.)  The actual storage
     requirement is two bytes for each group of four decimal digits,
     plus three to eight bytes overhead.
    </para>
________________________________________________________-->
    <para>
     数字值在物理上是以不带任何前导或者后缀零的形式存储。 因此，列上声明的精度和小数位数都是最大值，而不是固定分配的 （在这个方面，<type>numeric</type>类型更类似于<type>varchar(<replaceable>n</replaceable>)</type>， 而不像<type>char(<replaceable>n</replaceable>)</type>）。 实际存储要求是每四个十进制位组用两个字节，再加上三到八个字节的开销。
    </para>
<!-- pgdoc-cn_end sig_en=dc44b1743acb46c682f13545229fffc4 -->

<!-- pgdoc-cn_start sig_en=f4e8b49a19e8446f8f373b6ac3d9c0fd sig_cn_org=None source=14.1 
    <indexterm>
     <primary>infinity</primary>
     <secondary>numeric (data type)</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>infinity</primary>
     <secondary>numeric (数据类型)</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=f4e8b49a19e8446f8f373b6ac3d9c0fd -->

<!-- pgdoc-cn_start sig_en=81cf850b3f990252137c77a91ac2f95a sig_cn_org=None source=14.1 
    <indexterm>
     <primary>NaN</primary>
     <see>not a number</see>
   </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>NaN</primary>
     <see>不是一个数字</see>
   </indexterm>
<!-- pgdoc-cn_end sig_en=81cf850b3f990252137c77a91ac2f95a -->

<!-- pgdoc-cn_start sig_en=a63883d0d72a86218047750d967983c3 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>not a number</primary>
     <secondary>numeric (data type)</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>不是一个数字</primary>
     <secondary>数字（数据类型）</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=a63883d0d72a86218047750d967983c3 -->

<!-- pgdoc-cn_start sig_en=ac8f1b89949d0b649d11f6c35e7a5870 sig_cn_org=None source=14.1 
    <para>
     In addition to ordinary numeric values, the <type>numeric</type> type
     has several special values:
<literallayout>
<literal>Infinity</literal>
<literal>-Infinity</literal>
<literal>NaN</literal>
</literallayout>
     These are adapted from the IEEE 754 standard, and represent
     <quote>infinity</quote>, <quote>negative infinity</quote>, and
     <quote>not-a-number</quote>, respectively. When writing these values
     as constants in an SQL command, you must put quotes around them,
     for example <literal>UPDATE table SET x = '-Infinity'</literal>.
     On input, these strings are recognized in a case-insensitive manner.
     The infinity values can alternatively be spelled <literal>inf</literal>
     and <literal>-inf</literal>.
    </para>
________________________________________________________-->
    <para>
     除了普通的numeric值以外，<type>numeric</type>类型还有如下几个特殊值：
<literallayout>
<literal>Infinity</literal>
<literal>-Infinity</literal>
<literal>NaN</literal>
</literallayout>
     这些是根据IEEE 754标准改编的，分别表示<quote>infinity</quote>，<quote>negative infinity</quote>，和<quote>not-a-number</quote>。在SQL命令中将这些值作为常量写入时，必须在其周围加引号，例如<literal>UPDATE table SET x = '-Infinity'</literal>。输入时，以不区分大小写的方式识别这些字符串。无穷大值也可以拼写为<literal>inf</literal>和<literal>-inf</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=ac8f1b89949d0b649d11f6c35e7a5870 -->

<!-- pgdoc-cn_start sig_en=fe5a06a755c4cccb64e6bb4e1a88df7f sig_cn_org=None source=14.1 
    <para>
     The infinity values behave as per mathematical expectations.  For
     example, <literal>Infinity</literal> plus any finite value equals
     <literal>Infinity</literal>, as does <literal>Infinity</literal>
     plus <literal>Infinity</literal>; but <literal>Infinity</literal>
     minus <literal>Infinity</literal> yields <literal>NaN</literal> (not a
     number), because it has no well-defined interpretation.  Note that an
     infinity can only be stored in an unconstrained <type>numeric</type>
     column, because it notionally exceeds any finite precision limit.
    </para>
________________________________________________________-->
    <para>
     无穷大值的行为符合数学期望。例如，<literal>Infinity</literal>加上任何有限值等于<literal>Infinity</literal>，就像<literal>Infinity</literal>加上<literal>Infinite</literal>一样；但是<literal>Infinity</literal>减去<literal>Infinity</literal> 得到<literal>NaN</literal> （不是一个数字），因为它没有良好定义的解释。请注意，无穷大只能存储在无约束的<type>numeric</type> 列中，因为它名义上超过了任何有限精度限制。
    </para>
<!-- pgdoc-cn_end sig_en=fe5a06a755c4cccb64e6bb4e1a88df7f -->

<!-- pgdoc-cn_start sig_en=19d5a6e1465dd254eac15ed24083f87a sig_cn_org=None source=14.1 
    <para>
     The <literal>NaN</literal> (not a number) value is used to represent
     undefined calculational results.  In general, any operation with
     a <literal>NaN</literal> input yields another <literal>NaN</literal>.
     The only exception is when the operation's other inputs are such that
     the same output would be obtained if the <literal>NaN</literal> were to
     be replaced by any finite or infinite numeric value; then, that output
     value is used for <literal>NaN</literal> too.  (An example of this
     principle is that <literal>NaN</literal> raised to the zero power
     yields one.)
    </para>
________________________________________________________-->
    <para>
     <literal>NaN</literal>（不是数字）值用于表示未定义的计算结果。 通常，任何具有 <literal>NaN</literal>输入的操作都会产生另一个 <literal>NaN</literal>。 唯一的例外是当操作的其他输入使得如果将<literal>NaN</literal>替换为任何有限或无限数值时将获得相同的输出，那么，该输出值也适用于 <literal>NaN</literal>。 （这个原理的一个例子是，<literal>NaN</literal>的零次方会得到 1。）
    </para>
<!-- pgdoc-cn_end sig_en=19d5a6e1465dd254eac15ed24083f87a -->

    <note>
<!-- pgdoc-cn_start sig_en=8d6fb0dd5c6a255aefc5ba9ac7fd1abb sig_cn_org=None source=14.1 
     <para>
      In most implementations of the <quote>not-a-number</quote> concept,
      <literal>NaN</literal> is not considered equal to any other numeric
      value (including <literal>NaN</literal>).  In order to allow
      <type>numeric</type> values to be sorted and used in tree-based
      indexes, <productname>PostgreSQL</productname> treats <literal>NaN</literal>
      values as equal, and greater than all non-<literal>NaN</literal>
      values.
     </para>
________________________________________________________-->
     <para>
      在<quote>不是一个数字</quote>概念的大部分实现中，<literal>NaN</literal>被认为不等于任何其他数字值（包括<literal>NaN</literal>）。为了允许<type>numeric</type>值可以被排序和使用基于树的索引，<productname>PostgreSQL</productname>把<literal>NaN</literal>值视为相等，并且比所有非<literal>NaN</literal>值都要大。
     </para>
<!-- pgdoc-cn_end sig_en=8d6fb0dd5c6a255aefc5ba9ac7fd1abb -->
    </note>

<!-- pgdoc-cn_start sig_en=461456054e004c5751b2e547526121dc sig_cn_org=None source=14.1 
    <para>
     The types <type>decimal</type> and <type>numeric</type> are
     equivalent.  Both types are part of the <acronym>SQL</acronym>
     standard.
    </para>
________________________________________________________-->
    <para>
     类型<type>decimal</type>和<type>numeric</type>是等效的。两种类型都是<acronym>SQL</acronym>标准的一部分。
    </para>
<!-- pgdoc-cn_end sig_en=461456054e004c5751b2e547526121dc -->

<!-- pgdoc-cn_start sig_en=4df9ef6f5a1025bbc2cbbc71832c51a1 sig_cn_org=None source=14.1 
    <para>
     When rounding values, the <type>numeric</type> type rounds ties away
     from zero, while (on most machines) the <type>real</type>
     and <type>double precision</type> types round ties to the nearest even
     number.  For example:

<programlisting>
SELECT x,
  round(x::numeric) AS num_round,
  round(x::double precision) AS dbl_round
FROM generate_series(-3.5, 3.5, 1) as x;
  x   | num_round | dbl_round
-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-
 -3.5 |        -4 |        -4
 -2.5 |        -3 |        -2
 -1.5 |        -2 |        -2
 -0.5 |        -1 |        -0
  0.5 |         1 |         0
  1.5 |         2 |         2
  2.5 |         3 |         2
  3.5 |         4 |         4
(8 rows)
</programlisting>
    </para>
________________________________________________________-->
    <para>
     在对值进行圆整时，<type>numeric</type>类型会圆到远离零的整数，而（在大部分机器上）<type>real</type>和<type>double precision</type>类型会圆到最近的偶数上。例如：

<programlisting>
SELECT x,
  round(x::numeric) AS num_round,
  round(x::double precision) AS dbl_round
FROM generate_series(-3.5, 3.5, 1) as x;
  x   | num_round | dbl_round
------+-----------+-----------
 -3.5 |        -4 |        -4
 -2.5 |        -3 |        -2
 -1.5 |        -2 |        -2
 -0.5 |        -1 |        -0
  0.5 |         1 |         0
  1.5 |         2 |         2
  2.5 |         3 |         2
  3.5 |         4 |         4
(8 rows)
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=4df9ef6f5a1025bbc2cbbc71832c51a1 -->
   </sect2>


   <sect2 id="datatype-float">
<!-- pgdoc-cn_start sig_en=91d183cd379c8f7450df37fc2def366f sig_cn_org=None source=14.1 
    <title>Floating-Point Types</title>
________________________________________________________-->
    <title>浮点类型</title>
<!-- pgdoc-cn_end sig_en=91d183cd379c8f7450df37fc2def366f -->

<!-- pgdoc-cn_start sig_en=6266431d711aa6565dd1418104a8509b sig_cn_org=None source=14.1 
    <indexterm zone="datatype-float">
     <primary>real</primary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="datatype-float">
     <primary>real</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=6266431d711aa6565dd1418104a8509b -->

<!-- pgdoc-cn_start sig_en=628cdada7ec13fc1cd554dd351d135e7 sig_cn_org=None source=14.1 
    <indexterm zone="datatype-float">
     <primary>double precision</primary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="datatype-float">
     <primary>双精度</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=628cdada7ec13fc1cd554dd351d135e7 -->

<!-- pgdoc-cn_start sig_en=4ccf6f53f5e3b21f91c519c48ca7f21a sig_cn_org=None source=14.1 
    <indexterm>
     <primary>float4</primary>
     <see>real</see>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>float4</primary>
     <see>real</see>
    </indexterm>
<!-- pgdoc-cn_end sig_en=4ccf6f53f5e3b21f91c519c48ca7f21a -->

<!-- pgdoc-cn_start sig_en=bf95f5d9d0dabec1912947c0d7b2a61b sig_cn_org=None source=14.1 
    <indexterm>
     <primary>float8</primary>
     <see>double precision</see>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>float8</primary>
     <see>双精度</see>
    </indexterm>
<!-- pgdoc-cn_end sig_en=bf95f5d9d0dabec1912947c0d7b2a61b -->

<!-- pgdoc-cn_start sig_en=e9e715487806b6833f1061e5038e07b0 sig_cn_org=None source=14.1 
    <indexterm zone="datatype-float">
     <primary>floating point</primary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="datatype-float">
     <primary>浮点</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=e9e715487806b6833f1061e5038e07b0 -->

<!-- pgdoc-cn_start sig_en=2e89af28392b0ce21b6b707af947d083 sig_cn_org=None source=14.1 
    <para>
     The data types <type>real</type> and <type>double precision</type> are
     inexact, variable-precision numeric types. On all currently supported
     platforms, these types are implementations of <acronym>IEEE</acronym>
     Standard 754 for Binary Floating-Point Arithmetic (single and double
     precision, respectively), to the extent that the underlying processor,
     operating system, and compiler support it.
    </para>
________________________________________________________-->
    <para>
     数据类型<type>real</type>和<type>double precision</type>是不精确的、变精度的数字类型。
     在所有当前支持的平台上，这些类型是<acronym>IEEE</acronym>标准 754 二进制浮点算术（分别对应单精度和双精度）的实现， 一直到下层处理器、操作系统和支持它的编译器。
    </para>
<!-- pgdoc-cn_end sig_en=2e89af28392b0ce21b6b707af947d083 -->

<!-- pgdoc-cn_start sig_en=186bf7f04a748a5f89dbb31e25c1b7b3 sig_cn_org=None source=14.1 
    <para>
     Inexact means that some values cannot be converted exactly to the
     internal format and are stored as approximations, so that storing
     and retrieving a value might show slight discrepancies.
     Managing these errors and how they propagate through calculations
     is the subject of an entire branch of mathematics and computer
     science and will not be discussed here, except for the
     following points:
     <itemizedlist>
      <listitem>
       <para>
        If you require exact storage and calculations (such as for
        monetary amounts), use the <type>numeric</type> type instead.
       </para>
      </listitem>

      <listitem>
       <para>
        If you want to do complicated calculations with these types
        for anything important, especially if you rely on certain
        behavior in boundary cases (infinity, underflow), you should
        evaluate the implementation carefully.
       </para>
      </listitem>

      <listitem>
       <para>
        Comparing two floating-point values for equality might not
        always work as expected.
       </para>
      </listitem>
     </itemizedlist>
    </para>
________________________________________________________-->
    <para>
     不准确意味着一些值不能准确地转换成内部格式并且是以近似的形式存储的，因此存储和检索一个值可能出现一些缺失。 处理这些错误以及这些错误是如何在计算中传播的主题属于数学和计算机科学的一个完整的分支， 我们不会在这里进一步讨论它，这里的讨论仅限于如下几点：
     <itemizedlist>
      <listitem>
       <para>
        如果你要求准确的存储和计算（例如计算货币金额），应使用<type>numeric</type>类型。
       </para>
      </listitem>

      <listitem>
       <para>
        如果你想用这些类型做任何重要的复杂计算，尤其是那些你对范围情况（无穷、下溢）严重依赖的事情，那你应该仔细评诂你的实现。
       </para>
      </listitem>

      <listitem>
       <para>
        用两个浮点数值进行等值比较不可能总是按照期望地进行。
       </para>
      </listitem>
     </itemizedlist>
    </para>
<!-- pgdoc-cn_end sig_en=186bf7f04a748a5f89dbb31e25c1b7b3 -->

<!-- pgdoc-cn_start sig_en=3c82199b9bf2a1bc6a549d0120da869a sig_cn_org=None source=14.1 
    <para>
     On all currently supported platforms, the <type>real</type> type has a
     range of around 1E-37 to 1E+37 with a precision of at least 6 decimal
     digits. The <type>double precision</type> type has a range of around
     1E-307 to 1E+308 with a precision of at least 15 digits. Values that are
     too large or too small will cause an error. Rounding might take place if
     the precision of an input number is too high. Numbers too close to zero
     that are not representable as distinct from zero will cause an underflow
     error.
    </para>
________________________________________________________-->
    <para>
     在所有当前支持的平台上，<type>real</type>类型的范围是 1E-37 to 1E+37 ，精度至少是 6 位小数。
     <type>double precision</type>类型的范围是 1E-307 to 1E+308 ，精度至少是 15 位数字。
     太大或者太小的值都会导致错误。 如果输入数字的精度太高，那么可能发生四舍五入。
     太接近零的数字，如果不能体现出与零的区别就会导致下溢错误。
    </para>
<!-- pgdoc-cn_end sig_en=3c82199b9bf2a1bc6a549d0120da869a -->

<!-- pgdoc-cn_start sig_en=e12dc72ce377f52051d35a691acb0e53 sig_cn_org=None source=14.1 
    <para>
     By default, floating point values are output in text form in their
     shortest precise decimal representation; the decimal value produced is
     closer to the true stored binary value than to any other value
     representable in the same binary precision. (However, the output value is
     currently never <emphasis>exactly</emphasis> midway between two
     representable values, in order to avoid a widespread bug where input
     routines do not properly respect the round-to-nearest-even rule.) This value will
     use at most 17 significant decimal digits for <type>float8</type>
     values, and at most 9 digits for <type>float4</type> values.
    </para>
________________________________________________________-->
    <para>
     默认情况下，浮点值以其最短精确的十进制表示的文本形式输出；所产生的十进制值与相同二进制精度的任何其他的值表示相比，更接近于真实存储的二进制值。
    （但是，当前输出值永远不会<emphasis>精确地</emphasis>处于两个可表示的值之间，以免输入程序不能正确遵守舍近取整法则。）
     对于<type>float8</type>值，此值最多使用 17 个有效十进制数字，对于<type>float4</type>值，最多使用9个数字。
    </para>
<!-- pgdoc-cn_end sig_en=e12dc72ce377f52051d35a691acb0e53 -->

    <note>
<!-- pgdoc-cn_start sig_en=854eca383b912805c6e5ae85a63e686c sig_cn_org=None source=14.1 
     <para>
      This shortest-precise output format is much faster to generate than the
      historical rounded format.
     </para>
________________________________________________________-->
     <para>
	  生成这种最短精确的输出格式比历史的四舍五入的格式要快得多。
     </para>
<!-- pgdoc-cn_end sig_en=854eca383b912805c6e5ae85a63e686c -->
    </note>

<!-- pgdoc-cn_start sig_en=20cb2d9d497d458b415f974124aa34ff sig_cn_org=None source=14.1 
    <para>
     For compatibility with output generated by older versions
     of <productname>PostgreSQL</productname>, and to allow the output
     precision to be reduced, the <xref linkend="guc-extra-float-digits"/>
     parameter can be used to select rounded decimal output instead. Setting a
     value of 0 restores the previous default of rounding the value to 6
     (for <type>float4</type>) or 15 (for <type>float8</type>)
     significant decimal digits. Setting a negative value reduces the number
     of digits further; for example -2 would round output to 4 or 13 digits
     respectively.
    </para>
________________________________________________________-->
    <para>
	 为了与<productname>PostgreSQL</productname>的较旧版本生成的输出兼容，并允许降低输出精度，可以使用<xref linkend="guc-extra-float-digits"/>参数选择四舍五入的十进制输出。
     将值设置为0将恢复以前的默认值，即将值四舍五入为6（对于<type>float4</type>）或15（对于<type>float8</type>）个有效的十进制数字。
     设置负值会进一步减少位数。 例如-2会将输出分别舍入到4或13位数字。
    </para>
<!-- pgdoc-cn_end sig_en=20cb2d9d497d458b415f974124aa34ff -->

<!-- pgdoc-cn_start sig_en=f82ac6281ef869ce22c251ba9f09b3ad sig_cn_org=None source=14.1 
    <para>
     Any value of <xref linkend="guc-extra-float-digits"/> greater than 0
     selects the shortest-precise format.
    </para>
________________________________________________________-->
    <para>
     设置<xref linkend="guc-extra-float-digits"/>位任何大于 0 的值将选择最短精确格式。
    </para>
<!-- pgdoc-cn_end sig_en=f82ac6281ef869ce22c251ba9f09b3ad -->

    <note>
<!-- pgdoc-cn_start sig_en=eec0372a02d376f3eddede6d9c1946de sig_cn_org=None source=14.1 
     <para>
      Applications that wanted precise values have historically had to set
      <xref linkend="guc-extra-float-digits"/> to 3 to obtain them. For
      maximum compatibility between versions, they should continue to do so.
     </para>
________________________________________________________-->
     <para>
     需要更精确值的应用需要设置<xref linkend="guc-extra-float-digits"/>为3以获取更精确值。
	 为了版本之间的最大兼容性，他们可以继续这样做。
     </para>
<!-- pgdoc-cn_end sig_en=eec0372a02d376f3eddede6d9c1946de -->
    </note>

<!-- pgdoc-cn_start sig_en=7f98251c8ed1b1db2e3cdfa488653065 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>infinity</primary>
     <secondary>floating point</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>无限大</primary>
     <secondary>浮点型</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=7f98251c8ed1b1db2e3cdfa488653065 -->

<!-- pgdoc-cn_start sig_en=8fb0e0e621c957dd414010fc80ea1ad0 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>not a number</primary>
     <secondary>floating point</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>非数字</primary>
     <secondary>浮点型</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=8fb0e0e621c957dd414010fc80ea1ad0 -->

<!-- pgdoc-cn_start sig_en=1c490923258f293a93bba1aca3c8768d sig_cn_org=None source=14.1 
    <para>
     In addition to ordinary numeric values, the floating-point types
     have several special values:
<literallayout>
<literal>Infinity</literal>
<literal>-Infinity</literal>
<literal>NaN</literal>
</literallayout>
     These represent the IEEE 754 special values
     <quote>infinity</quote>, <quote>negative infinity</quote>, and
     <quote>not-a-number</quote>, respectively. When writing these values
     as constants in an SQL command, you must put quotes around them,
     for example <literal>UPDATE table SET x = '-Infinity'</literal>.  On input,
     these strings are recognized in a case-insensitive manner.
     The infinity values can alternatively be spelled <literal>inf</literal>
     and <literal>-inf</literal>.
    </para>
________________________________________________________-->
    <para>
     除了普通的数字值之外，浮点类型还有几个特殊值：
<literallayout>
<literal>Infinity</literal>
<literal>-Infinity</literal>
<literal>NaN</literal>
</literallayout>
     这些分别代表 IEEE 754 特殊值<quote>infinity</quote>、<quote>negative infinity</quote>以及<quote>not-a-number</quote>，
     如果在 SQL 命令里把这些数值当作常量写，你必须在它们周围放上单引号，例如<literal>UPDATE table SET x = '-Infinity'</literal>。 在输入时，这些字符串是以大小写不敏感的方式识别的。
     无穷大值也可以拼写为<literal>inf</literal>和<literal>-inf</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=1c490923258f293a93bba1aca3c8768d -->

    <note>
<!-- pgdoc-cn_start sig_en=dc9a64225474bd2ee9494ce9bbcb7ef7 sig_cn_org=None source=14.1 
     <para>
      IEEE 754 specifies that <literal>NaN</literal> should not compare equal
      to any other floating-point value (including <literal>NaN</literal>).
      In order to allow floating-point values to be sorted and used
      in tree-based indexes, <productname>PostgreSQL</productname> treats
      <literal>NaN</literal> values as equal, and greater than all
      non-<literal>NaN</literal> values.
     </para>
________________________________________________________-->
     <para>
      IEEE754指定<literal>NaN</literal>不应该与任何其他浮点值（包括<literal>NaN</literal>）相等。为了允许浮点值被排序或者在基于树的索引中使用，<productname>PostgreSQL</productname>将<literal>NaN</literal>值视为相等，并且比所有非<literal>NaN</literal>值要更大。
     </para>
<!-- pgdoc-cn_end sig_en=dc9a64225474bd2ee9494ce9bbcb7ef7 -->
    </note>

<!-- pgdoc-cn_start sig_en=f00881d273d9ab5dce0b1c71af3b46e0 sig_cn_org=None source=14.1 
    <para>
     <productname>PostgreSQL</productname> also supports the SQL-standard
     notations <type>float</type> and
     <type>float(<replaceable>p</replaceable>)</type> for specifying
     inexact numeric types.  Here, <replaceable>p</replaceable> specifies
     the minimum acceptable precision in <emphasis>binary</emphasis> digits.
     <productname>PostgreSQL</productname> accepts
     <type>float(1)</type> to <type>float(24)</type> as selecting the
     <type>real</type> type, while
     <type>float(25)</type> to <type>float(53)</type> select
     <type>double precision</type>.  Values of <replaceable>p</replaceable>
     outside the allowed range draw an error.
     <type>float</type> with no precision specified is taken to mean
     <type>double precision</type>.
    </para>
________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>还支持 SQL 标准表示法<type>float</type>和<type>float(<replaceable>p</replaceable>)</type>用于声明非精确的数字类型。在这里，<replaceable>p</replaceable>指定以<emphasis>二进制</emphasis>位表示的最低可接受精度。 在选取<type>real</type>类型的时候，<productname>PostgreSQL</productname>接受<type>float(1)</type>到<type>float(24)</type>，在选取<type>double precision</type>的时候，接受<type>float(25)</type>到<type>float(53)</type>。在允许范围之外的<replaceable>p</replaceable>值将导致一个错误。没有指定精度的<type>float</type>将被当作是<type>double precision</type>。
    </para>
<!-- pgdoc-cn_end sig_en=f00881d273d9ab5dce0b1c71af3b46e0 -->

   </sect2>

   <sect2 id="datatype-serial">
<!-- pgdoc-cn_start sig_en=473e0f14d5f0a245bc382e3d3c88b767 sig_cn_org=None source=14.1 
    <title>Serial Types</title>
________________________________________________________-->
    <title>序数类型</title>
<!-- pgdoc-cn_end sig_en=473e0f14d5f0a245bc382e3d3c88b767 -->

<!-- pgdoc-cn_start sig_en=46e2249650eafdc8f925e88f673814af sig_cn_org=None source=14.1 
    <indexterm zone="datatype-serial">
     <primary>smallserial</primary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="datatype-serial">
     <primary>smallserial</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=46e2249650eafdc8f925e88f673814af -->

<!-- pgdoc-cn_start sig_en=f349ebd9e4f2c9239af6ee169cbda196 sig_cn_org=None source=14.1 
    <indexterm zone="datatype-serial">
     <primary>serial</primary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="datatype-serial">
     <primary>serial</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=f349ebd9e4f2c9239af6ee169cbda196 -->

<!-- pgdoc-cn_start sig_en=8e873a76f65fd74403db3498722b63e2 sig_cn_org=None source=14.1 
    <indexterm zone="datatype-serial">
     <primary>bigserial</primary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="datatype-serial">
     <primary>bigserial</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=8e873a76f65fd74403db3498722b63e2 -->

<!-- pgdoc-cn_start sig_en=4f59d7f141e5dbe22c018f64b280a459 sig_cn_org=None source=14.1 
    <indexterm zone="datatype-serial">
     <primary>serial2</primary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="datatype-serial">
     <primary>serial2</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=4f59d7f141e5dbe22c018f64b280a459 -->

<!-- pgdoc-cn_start sig_en=8832c194a39af763ec9f9d80482f2a52 sig_cn_org=None source=14.1 
    <indexterm zone="datatype-serial">
     <primary>serial4</primary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="datatype-serial">
     <primary>serial4</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=8832c194a39af763ec9f9d80482f2a52 -->

<!-- pgdoc-cn_start sig_en=cdfb69925ca57c6a23046c9a2e9ae331 sig_cn_org=None source=14.1 
    <indexterm zone="datatype-serial">
     <primary>serial8</primary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="datatype-serial">
     <primary>serial8</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=cdfb69925ca57c6a23046c9a2e9ae331 -->

<!-- pgdoc-cn_start sig_en=4b48885c68447f96a1e7051de9f75ab3 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>auto-increment</primary>
     <see>serial</see>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>auto-increment</primary>
     <see>serial</see>
    </indexterm>
<!-- pgdoc-cn_end sig_en=4b48885c68447f96a1e7051de9f75ab3 -->

<!-- pgdoc-cn_start sig_en=3f9bbb503457d3f6968635348e4e01c7 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>sequence</primary>
     <secondary>and serial type</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>sequence</primary>
     <secondary>and serial type</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=3f9bbb503457d3f6968635348e4e01c7 -->

    <note>
<!-- pgdoc-cn_start sig_en=0deab6a79ff5d7a12d1585c57c567c2a sig_cn_org=None source=14.1 
     <para>
      This section describes a PostgreSQL-specific way to create an
      autoincrementing column.  Another way is to use the SQL-standard
      identity column feature, described at <xref linkend="sql-createtable"/>.
     </para>
________________________________________________________-->
     <para>
      这一节描述了PostgreSQL特有的创建一个自增列的方法。另一种方法是使用SQL标准的标识列特性，它在<xref linkend="sql-createtable"/>中描述。
     </para>
<!-- pgdoc-cn_end sig_en=0deab6a79ff5d7a12d1585c57c567c2a -->
    </note>

<!-- pgdoc-cn_start sig_en=46072e0957c5c96b4054257824b1b9e5 sig_cn_org=None source=14.1 
    <para>
     The data types <type>smallserial</type>, <type>serial</type> and
     <type>bigserial</type> are not true types, but merely
     a notational convenience for creating unique identifier columns
     (similar to the <literal>AUTO_INCREMENT</literal> property
     supported by some other databases). In the current
     implementation, specifying:

<programlisting>
CREATE TABLE <replaceable class="parameter">tablename</replaceable> (
    <replaceable class="parameter">colname</replaceable> SERIAL
);
</programlisting>

     is equivalent to specifying:

<programlisting>
CREATE SEQUENCE <replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq AS integer;
CREATE TABLE <replaceable class="parameter">tablename</replaceable> (
    <replaceable class="parameter">colname</replaceable> integer NOT NULL DEFAULT nextval('<replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq')
);
ALTER SEQUENCE <replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq OWNED BY <replaceable class="parameter">tablename</replaceable>.<replaceable class="parameter">colname</replaceable>;
</programlisting>

     Thus, we have created an integer column and arranged for its default
     values to be assigned from a sequence generator.  A <literal>NOT NULL</literal>
     constraint is applied to ensure that a null value cannot be
     inserted.  (In most cases you would also want to attach a
     <literal>UNIQUE</literal> or <literal>PRIMARY KEY</literal> constraint to prevent
     duplicate values from being inserted by accident, but this is
     not automatic.)  Lastly, the sequence is marked as <quote>owned by</quote>
     the column, so that it will be dropped if the column or table is dropped.
    </para>
________________________________________________________-->
    <para>
     <type>smallserial</type>、<type>serial</type>和<type>bigserial</type>类型不是真正的类型，它们只是为了创建唯一标识符列而存在的方便符号（类似其它一些数据库中支持的<literal>AUTO_INCREMENT</literal>属性）。 在目前的实现中，下面一个语句：

<programlisting>
CREATE TABLE <replaceable class="parameter">tablename</replaceable> (
    <replaceable class="parameter">colname</replaceable> SERIAL
);
</programlisting>

     等价于以下语句：

<programlisting>
CREATE SEQUENCE <replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq AS integer;
CREATE TABLE <replaceable class="parameter">tablename</replaceable> (
    <replaceable class="parameter">colname</replaceable> integer NOT NULL DEFAULT nextval('<replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq')
);
ALTER SEQUENCE <replaceable class="parameter">tablename</replaceable>_<replaceable class="parameter">colname</replaceable>_seq OWNED BY <replaceable class="parameter">tablename</replaceable>.<replaceable class="parameter">colname</replaceable>;
</programlisting>

     因此，我们就创建了一个整数列并且把它的缺省值安排为从一个序列发生器取值。应用了一个<literal>NOT NULL</literal>约束以确保空值不会被插入（在大多数情况下你可能还希望附加一个<literal>UNIQUE</literal>或者<literal>PRIMARY KEY</literal>约束避免意外地插入重复的值，但这个不是自动发生的）。最后，该序列被标记为<quote>属于</quote>该列，这样当列或表被删除时该序列也会被删除。
    </para>
<!-- pgdoc-cn_end sig_en=46072e0957c5c96b4054257824b1b9e5 -->

    <note>
<!-- pgdoc-cn_start sig_en=f49fa9d7e31b01f07fb07881fb159558 sig_cn_org=None source=14.1 
      <para>
        Because <type>smallserial</type>, <type>serial</type> and
        <type>bigserial</type> are implemented using sequences, there may
        be "holes" or gaps in the sequence of values which appears in the
        column, even if no rows are ever deleted.  A value allocated
        from the sequence is still "used up" even if a row containing that
        value is never successfully inserted into the table column.  This
        may happen, for example, if the inserting transaction rolls back.
        See <literal>nextval()</literal> in <xref linkend="functions-sequence"/>
        for details.
      </para>
________________________________________________________-->
      <para>
        因为<type>smallserial</type>、<type>serial</type>和<type>bigserial</type>是用序列实现的，所以即使没有删除过行，在出现在列中的序列值可能有“空洞”或者间隙。如果一个从序列中分配的值被用在一行中，即使该行最终没有被成功地插入到表中，该值也被“用掉”了。例如，当插入事务回滚时就会发生这种情况。更多信息参见<xref linkend="functions-sequence"/>中的<literal>nextval()</literal>。
      </para>
<!-- pgdoc-cn_end sig_en=f49fa9d7e31b01f07fb07881fb159558 -->
    </note>

<!-- pgdoc-cn_start sig_en=816dc163d13dd83c736c2b72cfebebf7 sig_cn_org=None source=14.1 
    <para>
     To insert the next value of the sequence into the <type>serial</type>
     column, specify that the <type>serial</type>
     column should be assigned its default value. This can be done
     either by excluding the column from the list of columns in
     the <command>INSERT</command> statement, or through the use of
     the <literal>DEFAULT</literal> key word.
    </para>
________________________________________________________-->
    <para>
     要使用<type>serial</type>列插入序列的下一个数值到表中， 请指定<type>serial</type>列应该被赋予其缺省值。我们可以通过在<command>INSERT</command>语句中把该列排除在列列表之外来实现，也可以通过使用<literal>DEFAULT</literal>关键字来实现。
    </para>
<!-- pgdoc-cn_end sig_en=816dc163d13dd83c736c2b72cfebebf7 -->

<!-- pgdoc-cn_start sig_en=4719e5c7ab7559acc42b677622bf1fb6 sig_cn_org=None source=14.1 
    <para>
     The type names <type>serial</type> and <type>serial4</type> are
     equivalent: both create <type>integer</type> columns.  The type
     names <type>bigserial</type> and <type>serial8</type> work
     the same way, except that they create a <type>bigint</type>
     column.  <type>bigserial</type> should be used if you anticipate
     the use of more than 2<superscript>31</superscript> identifiers over the
     lifetime of the table. The type names <type>smallserial</type> and
     <type>serial2</type> also work the same way, except that they
     create a <type>smallint</type> column.
    </para>
________________________________________________________-->
    <para>
     类型名<type>serial</type>和<type>serial4</type>是等效的： 两个都创建<type>integer</type>列。类型名<type>bigserial</type>和<type>serial8</type>也一样，只不过它们创建一个 <type>bigint</type>列。如果你预计在表的生存期中使用的标识符数目超过 2<superscript>31</superscript> 个，那么你应该使用<type>bigserial</type>。类型名<type>smallserial</type>和<type>serial2</type>也以相同方式工作，只不过它们创建一个<type>smallint</type>列。
    </para>
<!-- pgdoc-cn_end sig_en=4719e5c7ab7559acc42b677622bf1fb6 -->

<!-- pgdoc-cn_start sig_en=fd22ae3527874d4c46de519a2e553e04 sig_cn_org=None source=14.1 
    <para>
     The sequence created for a <type>serial</type> column is
     automatically dropped when the owning column is dropped.
     You can drop the sequence without dropping the column, but this
     will force removal of the column default expression.
    </para>
________________________________________________________-->
    <para>
     为一个<type>serial</type>列创建的序列在所属的列被删除的时候自动删除。你可以在不删除列的情况下删除序列，但是这会强制删除该列的默认值表达式。
    </para>
<!-- pgdoc-cn_end sig_en=fd22ae3527874d4c46de519a2e553e04 -->
   </sect2>
  </sect1>

  <sect1 id="datatype-money">
<!-- pgdoc-cn_start sig_en=22d675670a99e276e2da7681f7998064 sig_cn_org=None source=14.1 
   <title>Monetary Types</title>
________________________________________________________-->
   <title>货币类型</title>
<!-- pgdoc-cn_end sig_en=22d675670a99e276e2da7681f7998064 -->

<!-- pgdoc-cn_start sig_en=abab6740d6c15fb52f72bac74c4c1da1 sig_cn_org=None source=14.1 
   <para>
    The <type>money</type> type stores a currency amount with a fixed
    fractional precision; see <xref
    linkend="datatype-money-table"/>.  The fractional precision is
    determined by the database's <xref linkend="guc-lc-monetary"/> setting.
    The range shown in the table assumes there are two fractional digits.
    Input is accepted in a variety of formats, including integer and
    floating-point literals, as well as typical
    currency formatting, such as <literal>'$1,000.00'</literal>.
    Output is generally in the latter form but depends on the locale.
   </para>
________________________________________________________-->
   <para>
    <type>money</type>类型存储固定小数精度的货币数字，参阅<xref linkend="datatype-money-table"/>。小数的精度由数据库的<xref linkend="guc-lc-monetary"/>设置决定。表中展示的范围假设有两个小数位。可接受的输入格式很多，包括整数和浮点数文字，以及常用的货币格式，如<literal>'$1,000.00'</literal>。 输出通常是最后一种形式，但和区域相关。
   </para>
<!-- pgdoc-cn_end sig_en=abab6740d6c15fb52f72bac74c4c1da1 -->

    <table id="datatype-money-table">
<!-- pgdoc-cn_start sig_en=22d675670a99e276e2da7681f7998064 sig_cn_org=None source=14.1 
     <title>Monetary Types</title>
________________________________________________________-->
     <title>货币类型</title>
<!-- pgdoc-cn_end sig_en=22d675670a99e276e2da7681f7998064 -->
     <tgroup cols="4">
      <colspec colname="col1" colwidth="2*"/>
      <colspec colname="col2" colwidth="1*"/>
      <colspec colname="col3" colwidth="2*"/>
      <colspec colname="col4" colwidth="2*"/>
      <thead>
<!-- pgdoc-cn_start sig_en=eb61dfa4ad1188b3f53b37e835c3d8fb sig_cn_org=None source=14.1 
       <row>
        <entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry>
        <entry>Range</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>名字</entry>
        <entry>存储尺寸</entry>
        <entry>描述</entry>
        <entry>范围</entry>
       </row>
<!-- pgdoc-cn_end sig_en=eb61dfa4ad1188b3f53b37e835c3d8fb -->
      </thead>
      <tbody>
<!-- pgdoc-cn_start sig_en=94bb2138c73e29af7c604a64e53bc9d7 sig_cn_org=None source=14.1 
       <row>
        <entry><type>money</type></entry>
        <entry>8 bytes</entry>
        <entry>currency amount</entry>
        <entry>-92233720368547758.08 to +92233720368547758.07</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>money</type></entry>
        <entry>8 bytes</entry>
        <entry>货币额</entry>
        <entry>-92233720368547758.08到+92233720368547758.07</entry>
       </row>
<!-- pgdoc-cn_end sig_en=94bb2138c73e29af7c604a64e53bc9d7 -->
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=7dcc2f09ab70ecf7f6cc4252aa1534bc sig_cn_org=None source=14.1 
   <para>
    Since the output of this data type is locale-sensitive, it might not
    work to load <type>money</type> data into a database that has a different
    setting of <varname>lc_monetary</varname>.  To avoid problems, before
    restoring a dump into a new database make sure <varname>lc_monetary</varname> has
    the same or equivalent value as in the database that was dumped.
   </para>
________________________________________________________-->
   <para>
    由于这种数据类型的输出是区域敏感的，因此将<type>money</type>数据装入到一个具有不同<varname>lc_monetary</varname>设置的数据库是不起作用的。为了避免这种问题，在恢复一个转储到一个新数据库中之前，应确保新数据库的<varname>lc_monetary</varname>设置和被转储数据库的相同或者具有等效值。
   </para>
<!-- pgdoc-cn_end sig_en=7dcc2f09ab70ecf7f6cc4252aa1534bc -->

<!-- pgdoc-cn_start sig_en=1c400956dbf5611320baa5d1f45f5bc2 sig_cn_org=None source=14.1 
   <para>
    Values of the <type>numeric</type>, <type>int</type>, and
    <type>bigint</type> data types can be cast to <type>money</type>.
    Conversion from the <type>real</type> and <type>double precision</type>
    data types can be done by casting to <type>numeric</type> first, for
    example:
<programlisting>
SELECT '12.34'::float8::numeric::money;
</programlisting>
    However, this is not recommended.  Floating point numbers should not be
    used to handle money due to the potential for rounding errors.
   </para>
________________________________________________________-->
   <para>
    数据类型<type>numeric</type>、<type>int</type>和<type>bigint</type>的值可以被造型成<type>money</type>。从数据类型<type>real</type>和<type>double precision</type>的转换可以通过先造型成<type>numeric</type>来实现，例如：
<programlisting>
SELECT '12.34'::float8::numeric::money;
</programlisting>
    但是，我们不推荐这样做。浮点数不应该被用来处理货币，因为浮点数可能会有圆整错误。
   </para>
<!-- pgdoc-cn_end sig_en=1c400956dbf5611320baa5d1f45f5bc2 -->

<!-- pgdoc-cn_start sig_en=14a21c483dc519f620ffe3cd8db62946 sig_cn_org=None source=14.1 
   <para>
    A <type>money</type> value can be cast to <type>numeric</type> without
    loss of precision. Conversion to other types could potentially lose
    precision, and must also be done in two stages:
<programlisting>
SELECT '52093.89'::money::numeric::float8;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    一个<type>money</type>值可以在不损失精度的情况下被造型成<type>numeric</type>。转换到其他类型可能会丢失精度，并且必须采用两个阶段完成：
<programlisting>
SELECT '52093.89'::money::numeric::float8;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=14a21c483dc519f620ffe3cd8db62946 -->

<!-- pgdoc-cn_start sig_en=575f528a48eb6a97efe5937658ba84a0 sig_cn_org=None source=14.1 
   <para>
    Division of a <type>money</type> value by an integer value is performed
    with truncation of the fractional part towards zero.  To get a rounded
    result, divide by a floating-point value, or cast the <type>money</type>
    value to <type>numeric</type> before dividing and back to <type>money</type>
    afterwards.  (The latter is preferable to avoid risking precision loss.)
    When a <type>money</type> value is divided by another <type>money</type>
    value, the result is <type>double precision</type> (i.e., a pure number,
    not money); the currency units cancel each other out in the division.
   </para>
________________________________________________________-->
   <para>
    一个<type>money</type>值被一个整数值除的除法结果会被截去分数部分。要得到圆整的结果，可以除以一个浮点值，或者在除法之前把<type>money</type>转换成<type>numeric</type>然后在除法之后转回<type>money</type>（如果要避免精度丢失的风险则后者更好）。当一个<type>money</type>值被另一个<type>money</type>值除时，结果是<type>double precision</type>（即一个纯数字，而不是金额），在除法中货币单位被约掉了。
   </para>
<!-- pgdoc-cn_end sig_en=575f528a48eb6a97efe5937658ba84a0 -->
  </sect1>


  <sect1 id="datatype-character">
<!-- pgdoc-cn_start sig_en=22b313dc65ef036ea9cec8aa0912f884 sig_cn_org=None source=14.1 
   <title>Character Types</title>
________________________________________________________-->
   <title>字符类型</title>
<!-- pgdoc-cn_end sig_en=22b313dc65ef036ea9cec8aa0912f884 -->

<!-- pgdoc-cn_start sig_en=9ae360801b444a47f41836ffbfcad561 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-character">
    <primary>character string</primary>
    <secondary>data types</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-character">
    <primary>字符串</primary>
    <secondary>数据类型</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=9ae360801b444a47f41836ffbfcad561 -->

<!-- pgdoc-cn_start sig_en=08f2dd945a9eb9e4fc15566d851485f9 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>string</primary>
    <see>character string</see>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>string</primary>
    <see>字符串</see>
   </indexterm>
<!-- pgdoc-cn_end sig_en=08f2dd945a9eb9e4fc15566d851485f9 -->

<!-- pgdoc-cn_start sig_en=e1a63364f1b6d5a0f93fdf578c51b59a sig_cn_org=None source=14.1 
   <indexterm zone="datatype-character">
    <primary>character</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-character">
    <primary>字符</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=e1a63364f1b6d5a0f93fdf578c51b59a -->

<!-- pgdoc-cn_start sig_en=ca0e011108f96612488e26a62e342050 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-character">
    <primary>character varying</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-character">
    <primary>character varying</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=ca0e011108f96612488e26a62e342050 -->

<!-- pgdoc-cn_start sig_en=d4e7f30ec11e56b00cfb088eda78878d sig_cn_org=None source=14.1 
   <indexterm zone="datatype-character">
    <primary>text</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-character">
    <primary>text</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=d4e7f30ec11e56b00cfb088eda78878d -->

<!-- pgdoc-cn_start sig_en=a40fc69379255e9bac7845a178adf7ed sig_cn_org=None source=14.1 
   <indexterm zone="datatype-character">
    <primary>char</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-character">
    <primary>char</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=a40fc69379255e9bac7845a178adf7ed -->

<!-- pgdoc-cn_start sig_en=9322b446bf43d2b5173f5a0da3b97f1f sig_cn_org=None source=14.1 
   <indexterm zone="datatype-character">
    <primary>varchar</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-character">
    <primary>varchar</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=9322b446bf43d2b5173f5a0da3b97f1f -->

    <table id="datatype-character-table">
<!-- pgdoc-cn_start sig_en=22b313dc65ef036ea9cec8aa0912f884 sig_cn_org=None source=14.1 
     <title>Character Types</title>
________________________________________________________-->
     <title>字符类型</title>
<!-- pgdoc-cn_end sig_en=22b313dc65ef036ea9cec8aa0912f884 -->
     <tgroup cols="2">
      <thead>
<!-- pgdoc-cn_start sig_en=03e0d819510e3f9125691a63a170e08d sig_cn_org=None source=14.1 
       <row>
        <entry>Name</entry>
        <entry>Description</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>名字</entry>
        <entry>描述</entry>
       </row>
<!-- pgdoc-cn_end sig_en=03e0d819510e3f9125691a63a170e08d -->
      </thead>
      <tbody>
<!-- pgdoc-cn_start sig_en=2e1bae63c05165605083ac377a278e17 sig_cn_org=None source=14.1 
       <row>
        <entry><type>character varying(<replaceable>n</replaceable>)</type>, <type>varchar(<replaceable>n</replaceable>)</type></entry>
        <entry>variable-length with limit</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>character varying(<replaceable>n</replaceable>)</type>, <type>varchar(<replaceable>n</replaceable>)</type></entry>
        <entry>有限制的变长</entry>
       </row>
<!-- pgdoc-cn_end sig_en=2e1bae63c05165605083ac377a278e17 -->
<!-- pgdoc-cn_start sig_en=203f6efa1f7dc37995557b7aecd40d42 sig_cn_org=None source=14.1 
       <row>
        <entry><type>character(<replaceable>n</replaceable>)</type>, <type>char(<replaceable>n</replaceable>)</type></entry>
        <entry>fixed-length, blank padded</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>character(<replaceable>n</replaceable>)</type>, <type>char(<replaceable>n</replaceable>)</type></entry>
        <entry>定长，空格填充</entry>
       </row>
<!-- pgdoc-cn_end sig_en=203f6efa1f7dc37995557b7aecd40d42 -->
<!-- pgdoc-cn_start sig_en=0de3098a5da8522fc4d35a961cffe456 sig_cn_org=None source=14.1 
       <row>
        <entry><type>text</type></entry>
        <entry>variable unlimited length</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>text</type></entry>
        <entry>无限变长</entry>
       </row>
<!-- pgdoc-cn_end sig_en=0de3098a5da8522fc4d35a961cffe456 -->
     </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=d3c2f9f01e345416d865c3d5cfba2aed sig_cn_org=None source=14.1 
   <para>
    <xref linkend="datatype-character-table"/> shows the
    general-purpose character types available in
    <productname>PostgreSQL</productname>.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="datatype-character-table"/>显示了在<productname>PostgreSQL</productname>里可用的一般用途的字符类型。
   </para>
<!-- pgdoc-cn_end sig_en=d3c2f9f01e345416d865c3d5cfba2aed -->

<!-- pgdoc-cn_start sig_en=7dc7bcd703e59f5a4210016886e29058 sig_cn_org=None source=14.1 
   <para>
    <acronym>SQL</acronym> defines two primary character types:
    <type>character varying(<replaceable>n</replaceable>)</type> and
    <type>character(<replaceable>n</replaceable>)</type>, where <replaceable>n</replaceable>
    is a positive integer.  Both of these types can store strings up to
    <replaceable>n</replaceable> characters (not bytes) in length.  An attempt to store a
    longer string into a column of these types will result in an
    error, unless the excess characters are all spaces, in which case
    the string will be truncated to the maximum length. (This somewhat
    bizarre exception is required by the <acronym>SQL</acronym>
    standard.) If the string to be stored is shorter than the declared
    length, values of type <type>character</type> will be space-padded;
    values of type <type>character varying</type> will simply store the
    shorter
    string.
   </para>
________________________________________________________-->
   <para>
    <acronym>SQL</acronym>定义了两种基本的字符类型： <type>character varying(<replaceable>n</replaceable>)</type>和<type>character(<replaceable>n</replaceable>)</type>， 其中<replaceable>n</replaceable>是一个正整数。两种类型都可以存储最多<replaceable>n</replaceable>个字符长的串。试图存储更长的串到这些类型的列里会产生一个错误， 除非超出长度的字符都是空白，这种情况下该串将被截断为最大长度（这个看上去有点怪异的例外是<acronym>SQL</acronym>标准要求的）。 如果要存储的串比声明的长度短，类型为<type>character</type>的值将会用空白填满；而类型为<type>character varying</type>的值将只是存储短些的串。
   </para>
<!-- pgdoc-cn_end sig_en=7dc7bcd703e59f5a4210016886e29058 -->

<!-- pgdoc-cn_start sig_en=7503f2e049ab00feaf138d9cf5a35ca4 sig_cn_org=None source=14.1 
   <para>
    If one explicitly casts a value to <type>character
    varying(<replaceable>n</replaceable>)</type> or
    <type>character(<replaceable>n</replaceable>)</type>, then an over-length
    value will be truncated to <replaceable>n</replaceable> characters without
    raising an error. (This too is required by the
    <acronym>SQL</acronym> standard.)
   </para>
________________________________________________________-->
   <para>
    如果我们明确地把一个值造型成<type>character varying(<replaceable>n</replaceable>)</type>或者<type>character(<replaceable>n</replaceable>)</type>， 那么超长的值将被截断成<replaceable>n</replaceable>个字符，而不会抛出错误（这也是<acronym>SQL</acronym>标准的要求）。
   </para>
<!-- pgdoc-cn_end sig_en=7503f2e049ab00feaf138d9cf5a35ca4 -->

<!-- pgdoc-cn_start sig_en=97c69bb97f47862f4b2e37bd49ab0f4a sig_cn_org=16fa61ca563466cdda90ae09b814c8f2 source=15.7 
   <para>
    The notations <type>varchar(<replaceable>n</replaceable>)</type> and
    <type>char(<replaceable>n</replaceable>)</type> are aliases for <type>character
    varying(<replaceable>n</replaceable>)</type> and
    <type>character(<replaceable>n</replaceable>)</type>, respectively.
    If specified, the length must be greater than zero and cannot exceed
    10485760.
    <type>character</type> without length specifier is equivalent to
    <type>character(1)</type>. If <type>character varying</type> is used
    without length specifier, the type accepts strings of any size. The
    latter is a <productname>PostgreSQL</productname> extension.
   </para>
________________________________________________________-->
   <para>
    符号<type>varchar(<replaceable>n</replaceable>)</type>和
    <type>char(<replaceable>n</replaceable>)</type>是<type>character
    varying(<replaceable>n</replaceable>)</type>和
    <type>character(<replaceable>n</replaceable>)</type>的别名。
    如果指定，长度必须大于零且不能超过10485760。
    没有长度说明符的<type>character</type>等同于
    <type>character(1)</type>。如果使用<type>character varying</type>
    而没有长度说明符，则该类型接受任意大小的字符串。后者是
    <productname>PostgreSQL</productname>的扩展。
</para>
<!-- pgdoc-cn_end sig_en=97c69bb97f47862f4b2e37bd49ab0f4a -->

<!-- pgdoc-cn_start sig_en=0c9d341e4409c3f72bbd3da0b07db315 sig_cn_org=None source=14.1 
   <para>
    In addition, <productname>PostgreSQL</productname> provides the
    <type>text</type> type, which stores strings of any length.
    Although the type <type>text</type> is not in the
    <acronym>SQL</acronym> standard, several other SQL database
    management systems have it as well.
   </para>
________________________________________________________-->
   <para>
    另外，<productname>PostgreSQL</productname>提供<type>text</type>类型，它可以存储任何长度的串。尽管类型<type>text</type>不是<acronym>SQL</acronym>标准，但是许多其它 SQL 数据库系统也有它。
   </para>
<!-- pgdoc-cn_end sig_en=0c9d341e4409c3f72bbd3da0b07db315 -->

<!-- pgdoc-cn_start sig_en=ed05a954a01a83f530770ccf2dec7148 sig_cn_org=None source=14.1 
   <para>
    Values of type <type>character</type> are physically padded
    with spaces to the specified width <replaceable>n</replaceable>, and are
    stored and displayed that way.  However, trailing spaces are treated as
    semantically insignificant and disregarded when comparing two values
    of type <type>character</type>.  In collations where whitespace
    is significant, this behavior can produce unexpected results;
    for example <command>SELECT 'a '::CHAR(2) collate "C" &lt;
    E'a\n'::CHAR(2)</command> returns true, even though <literal>C</literal>
    locale would consider a space to be greater than a newline.
    Trailing spaces are removed when converting a <type>character</type> value
    to one of the other string types.  Note that trailing spaces
    <emphasis>are</emphasis> semantically significant in
    <type>character varying</type> and <type>text</type> values, and
    when using pattern matching, that is <literal>LIKE</literal> and
    regular expressions.
   </para>
________________________________________________________-->
   <para>
      类型<type>character</type>的值物理上都用空白填充到指定的长度<replaceable>n</replaceable>， 并且以这种方式存储和显示。不过，拖尾的空白被当作是没有意义的，并且在比较两个
    <type>character</type>类型值时不会考虑它们。在空白有意义的排序规则中，这种行为可能会
    产生意料之外的结果，例如<command>SELECT 'a '::CHAR(2) collate "C" &lt;
    E'a\n'::CHAR(2)</command>会返回真（即便<literal>C</literal>区域会认为一个空格比新行更大）。当把一个<type>character</type>值转换成其他
    字符串类型之一时，拖尾的空白会被移除。请注意，在<type>character varying</type>和<type>text</type>值里， 结尾的空白语意上<emphasis>是</emphasis>有含义的，并且在使用模式匹配（如<literal>LIKE</literal>和正则表达式）时也会被考虑。

   </para>
<!-- pgdoc-cn_end sig_en=ed05a954a01a83f530770ccf2dec7148 -->

<!-- pgdoc-cn_start sig_en=d41a8917e790d27f958af9db345907af sig_cn_org=None source=14.1 
   <para>
    The characters that can be stored in any of these data types are
    determined by the database character set, which is selected when
    the database is created.  Regardless of the specific character set,
    the character with code zero (sometimes called NUL) cannot be stored.
    For more information refer to <xref linkend="multibyte"/>.
   </para>
________________________________________________________-->
   <para>
    可以存储在这些数据类型中的字符由数据库字符集确定，该数据库字符集在创建数据库时选择。无论特定的字符集是什么，都无法存储代码为零的字符（有时称为NUL）。有关更多信息，请参阅<xref linkend="multibyte"/>。
   </para>
<!-- pgdoc-cn_end sig_en=d41a8917e790d27f958af9db345907af -->

<!-- pgdoc-cn_start sig_en=2f1f90e6244b733ea4d81b2c8697856b sig_cn_org=None source=14.1 
   <para>
    The storage requirement for a short string (up to 126 bytes) is 1 byte
    plus the actual string, which includes the space padding in the case of
    <type>character</type>.  Longer strings have 4 bytes of overhead instead
    of 1.  Long strings are compressed by the system automatically, so
    the physical requirement on disk might be less. Very long values are also
    stored in background tables so that they do not interfere with rapid
    access to shorter column values. In any case, the longest
    possible character string that can be stored is about 1 GB. (The
    maximum value that will be allowed for <replaceable>n</replaceable> in the data
    type declaration is less than that. It wouldn't be useful to
    change this because with multibyte character encodings the number of
    characters and bytes can be quite different. If you desire to
    store long strings with no specific upper limit, use
    <type>text</type> or <type>character varying</type> without a length
    specifier, rather than making up an arbitrary length limit.)
   </para>
________________________________________________________-->
   <para>
    这些类型的存储需求是 4 字节加上实际的字串，如果是 character 的话再加上填充的字节。长的字串将会自动被系统压缩， 因此在磁盘上的物理需求可能会更少些。长的数值也会存储在后台表里面，这样它们就不会干扰对短字段值的快速访问。 不管怎样，允许存储的最长字串大概是 1 GB。 （允许在数据类型声明中出现的的 n 的最大值比这还小。 修改这个行为没有甚么意义，因为在多字节编码下字符和字节的数目可能差别很大。 如果你想存储没有特定上限的长字串，那么使用 text 或者没有长度声明词的 character varying， 而不要选择一个任意长度限制。）
    一个短串（最长126字节）的存储要求是1个字节外加实际的串，该串在<type>character</type>情况下包含填充的空白。长一些的串在前面需要4个字节而不是1个字节。长串会被系统自动压缩，这样在磁盘上的物理需求可能会更少。非常长的值也会被存储在背景表中，这样它们不会干扰对较短的列值的快速访问。在任何情况下，能被存储的最长的字符串是1GB（数据类型定义中<replaceable>n</replaceable>能允许的最大值比这个值要小。修改它没有用处，因为对于多字节字符编码来说，字符的数量和字节数可能完全不同。如果你想要存储没有指定上限的长串，使用<type>text</type>或没有长度声明的<type>character varying</type>，而不是给出一个任意长度限制）。
   </para>
<!-- pgdoc-cn_end sig_en=2f1f90e6244b733ea4d81b2c8697856b -->

   <tip>
<!-- pgdoc-cn_start sig_en=76ae2527c9696e5e88e0d1d348a6ab8f sig_cn_org=None source=14.1 
    <para>
     There is no performance difference among these three types,
     apart from increased storage space when using the blank-padded
     type, and a few extra CPU cycles to check the length when storing into
     a length-constrained column.  While
     <type>character(<replaceable>n</replaceable>)</type> has performance
     advantages in some other database systems, there is no such advantage in
     <productname>PostgreSQL</productname>; in fact
     <type>character(<replaceable>n</replaceable>)</type> is usually the slowest of
     the three because of its additional storage costs.  In most situations
     <type>text</type> or <type>character varying</type> should be used
     instead.
    </para>
________________________________________________________-->
    <para>
     这三种类型之间没有性能差别，只不过是在使用填充空白的类型的时候需要更多存储尺寸，以及在存储到一个有长度约束的列时需要少量额外CPU周期来检查长度。虽然在某些其它的数据库系统里，<type>character(<replaceable>n</replaceable>)</type>有一定的性能优势，但在<productname>PostgreSQL</productname>里没有。事实上，<type>character(<replaceable>n</replaceable>)</type>通常是这三种类型之中最慢的一个，因为它需要额外的存储开销。在大多数情况下，应该使用<type>text</type>或者<type>character varying</type>。
    </para>
<!-- pgdoc-cn_end sig_en=76ae2527c9696e5e88e0d1d348a6ab8f -->
   </tip>

<!-- pgdoc-cn_start sig_en=e73e528d270141900e93a4efe59b36f8 sig_cn_org=None source=14.1 
   <para>
    Refer to <xref linkend="sql-syntax-strings"/> for information about
    the syntax of string literals, and to <xref linkend="functions"/>
    for information about available operators and functions.
   </para>
________________________________________________________-->
   <para>
    请参考<xref linkend="sql-syntax-strings"/>获取关于串文本的语法的信息，以及参阅<xref linkend="functions"/>获取关于可用操作符和函数的信息。 
   </para>
<!-- pgdoc-cn_end sig_en=e73e528d270141900e93a4efe59b36f8 -->

   <example>
<!-- pgdoc-cn_start sig_en=82dd29919e36cee842ffc6657d33d329 sig_cn_org=None source=14.1 
    <title>Using the Character Types</title>
________________________________________________________-->
    <title>使用字符类型</title>
<!-- pgdoc-cn_end sig_en=82dd29919e36cee842ffc6657d33d329 -->

<!-- pgdoc-cn_start sig_en=7f8531b8b8e361c21bb8fc95eef5310c sig_cn_org=None source=14.1 
<programlisting>
CREATE TABLE test1 (a character(4));
INSERT INTO test1 VALUES ('ok');
SELECT a, char_length(a) FROM test1; -&minus; <co id="co.datatype-char"/>
<computeroutput>
  a   | char_length
-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 ok   |           2
</computeroutput>

CREATE TABLE test2 (b varchar(5));
INSERT INTO test2 VALUES ('ok');
INSERT INTO test2 VALUES ('good      ');
INSERT INTO test2 VALUES ('too long');
<computeroutput>ERROR:  value too long for type character varying(5)</computeroutput>
INSERT INTO test2 VALUES ('too long'::varchar(5)); -&minus; explicit truncation
SELECT b, char_length(b) FROM test2;
<computeroutput>
   b   | char_length
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 ok    |           2
 good  |           5
 too l |           5
</computeroutput>
</programlisting>
________________________________________________________-->
<programlisting>
CREATE TABLE test1 (a character(4));
INSERT INTO test1 VALUES ('ok');
SELECT a, char_length(a) FROM test1; -- <co id="co.datatype-char"/>
<computeroutput>
  a   | char_length
------+-------------
 ok   |           2
</computeroutput>

CREATE TABLE test2 (b varchar(5));
INSERT INTO test2 VALUES ('ok');
INSERT INTO test2 VALUES ('good      ');
INSERT INTO test2 VALUES ('too long');
<computeroutput>ERROR:  value too long for type character varying(5)</computeroutput>
INSERT INTO test2 VALUES ('too long'::varchar(5)); -- explicit truncation
SELECT b, char_length(b) FROM test2;
<computeroutput>
   b   | char_length
-------+-------------
 ok    |           2
 good  |           5
 too l |           5
</computeroutput>
</programlisting>
<!-- pgdoc-cn_end sig_en=7f8531b8b8e361c21bb8fc95eef5310c -->
    <calloutlist>
     <callout arearefs="co.datatype-char">
<!-- pgdoc-cn_start sig_en=79101a431aac2a7ea7d448fa00bda8e5 sig_cn_org=None source=14.1 
      <para>
       The <function>char_length</function> function is discussed in
       <xref linkend="functions-string"/>.
      </para>
________________________________________________________-->
      <para>
       函数<function>char_length</function>在<xref linkend="functions-string"/>中讨论。
      </para>
<!-- pgdoc-cn_end sig_en=79101a431aac2a7ea7d448fa00bda8e5 -->
     </callout>
    </calloutlist>
   </example>

<!-- pgdoc-cn_start sig_en=21154e552ad2113f17d056886373cfa5 sig_cn_org=0678dadc6d398749c2a9072798a319ad source=15.7 
   <para>
    There are two other fixed-length character types in
    <productname>PostgreSQL</productname>, shown in <xref
    linkend="datatype-character-special-table"/>.
    These are not intended for general-purpose use, only for use
    in the internal system catalogs.
    The <type>name</type> type is used to store identifiers. Its
    length is currently defined as 64 bytes (63 usable characters plus
    terminator) but should be referenced using the constant
    <symbol>NAMEDATALEN</symbol> in <literal>C</literal> source code.
    The length is set at compile time (and
    is therefore adjustable for special uses); the default maximum
    length might change in a future release. The type <type>"char"</type>
    (note the quotes) is different from <type>char(1)</type> in that it
    only uses one byte of storage, and therefore can store only a single
    ASCII character. It is used in the system
    catalogs as a simplistic enumeration type.
   </para>
________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname>中还有另外两种固定长度的字符类型，显示在<xref linkend="datatype-character-special-table"/>中。
    这些类型不适用于通用用途，仅用于内部系统目录中。
    <type>name</type>类型用于存储标识符。其长度目前定义为64字节（63个可用字符加终止符），但应在<literal>C</literal>源代码中使用常量<symbol>NAMEDATALEN</symbol>引用。
    长度在编译时设置（因此可根据特殊用途进行调整）；默认最大长度可能在将来的版本中更改。类型<type>"char"</type>（注意引号）与<type>char(1)</type>不同，因为它只使用一个字节的存储空间，因此只能存储单个ASCII字符。它在系统目录中用作简单的枚举类型。
</para>
<!-- pgdoc-cn_end sig_en=21154e552ad2113f17d056886373cfa5 -->

    <table id="datatype-character-special-table">
<!-- pgdoc-cn_start sig_en=970c393180967de10c7d651dadd44886 sig_cn_org=None source=14.1 
     <title>Special Character Types</title>
________________________________________________________-->
     <title>特殊字符类型</title>
<!-- pgdoc-cn_end sig_en=970c393180967de10c7d651dadd44886 -->
     <tgroup cols="3">
      <thead>
<!-- pgdoc-cn_start sig_en=304ab03d21d35b8f40189b876d1fc5d1 sig_cn_org=None source=14.1 
       <row>
        <entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>名字</entry>
        <entry>存储尺寸</entry>
        <entry>描述</entry>
       </row>
<!-- pgdoc-cn_end sig_en=304ab03d21d35b8f40189b876d1fc5d1 -->
      </thead>
      <tbody>
<!-- pgdoc-cn_start sig_en=41eed4133cb75edfe1a0b85a5f6e3c9d sig_cn_org=None source=14.1 
       <row>
        <entry><type>"char"</type></entry>
        <entry>1 byte</entry>
        <entry>single-byte internal type</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>"char"</type></entry>
        <entry>1字节</entry>
        <entry>单字节内部类型</entry>
       </row>
<!-- pgdoc-cn_end sig_en=41eed4133cb75edfe1a0b85a5f6e3c9d -->
<!-- pgdoc-cn_start sig_en=444fc98b534c78544f7d9361f123294c sig_cn_org=None source=14.1 
       <row>
        <entry><type>name</type></entry>
        <entry>64 bytes</entry>
        <entry>internal type for object names</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>name</type></entry>
        <entry>64字节</entry>
        <entry>用于对象名的内部类型</entry>
       </row>
<!-- pgdoc-cn_end sig_en=444fc98b534c78544f7d9361f123294c -->
      </tbody>
     </tgroup>
    </table>

  </sect1>

 <sect1 id="datatype-binary">
<!-- pgdoc-cn_start sig_en=8b5f4b0ea66196a2f4726acc67648605 sig_cn_org=None source=14.1 
  <title>Binary Data Types</title>
________________________________________________________-->
  <title>二进制数据类型</title>
<!-- pgdoc-cn_end sig_en=8b5f4b0ea66196a2f4726acc67648605 -->

<!-- pgdoc-cn_start sig_en=50646e0a6c177ed405ac64b1550e48c3 sig_cn_org=None source=14.1 
  <indexterm zone="datatype-binary">
   <primary>binary data</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="datatype-binary">
   <primary>二进制数据</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=50646e0a6c177ed405ac64b1550e48c3 -->

<!-- pgdoc-cn_start sig_en=a5d45282c7f7488b998b69ae6fa2ad7e sig_cn_org=None source=14.1 
  <indexterm zone="datatype-binary">
   <primary>bytea</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="datatype-binary">
   <primary>bytea</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=a5d45282c7f7488b998b69ae6fa2ad7e -->

<!-- pgdoc-cn_start sig_en=893789492d7d120ed19604730e6a522b sig_cn_org=None source=14.1 
   <para>
    The <type>bytea</type> data type allows storage of binary strings;
    see <xref linkend="datatype-binary-table"/>.
   </para>
________________________________________________________-->
   <para>
    <type>bytea</type>数据类型允许存储二进制串，参见<xref linkend="datatype-binary-table"/>。
   </para>
<!-- pgdoc-cn_end sig_en=893789492d7d120ed19604730e6a522b -->

   <table id="datatype-binary-table">
<!-- pgdoc-cn_start sig_en=8b5f4b0ea66196a2f4726acc67648605 sig_cn_org=None source=14.1 
    <title>Binary Data Types</title>
________________________________________________________-->
    <title>二进制数据类型</title>
<!-- pgdoc-cn_end sig_en=8b5f4b0ea66196a2f4726acc67648605 -->
    <tgroup cols="3">
     <colspec colname="col1" colwidth="1*"/>
     <colspec colname="col2" colwidth="3*"/>
     <colspec colname="col3" colwidth="2*"/>
     <thead>
<!-- pgdoc-cn_start sig_en=050488145e667f5c94fa0348a4112c89 sig_cn_org=None source=14.1 
      <row>
       <entry>Name</entry>
       <entry>Storage Size</entry>
       <entry>Description</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>名字</entry>
       <entry>存储尺寸</entry>
       <entry>描述</entry>
      </row>
<!-- pgdoc-cn_end sig_en=050488145e667f5c94fa0348a4112c89 -->
     </thead>
     <tbody>
<!-- pgdoc-cn_start sig_en=a8f821e3ba5a609d2c61e6132e7e15c2 sig_cn_org=None source=14.1 
      <row>
       <entry><type>bytea</type></entry>
       <entry>1 or 4 bytes plus the actual binary string</entry>
       <entry>variable-length binary string</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>bytea</type></entry>
       <entry>1或4字节外加真正的二进制串</entry>
       <entry>变长二进制串</entry>
      </row>
<!-- pgdoc-cn_end sig_en=a8f821e3ba5a609d2c61e6132e7e15c2 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=cf3452a7d37516920f78d6ab79ccb0d0 sig_cn_org=None source=14.1 
   <para>
    A binary string is a sequence of octets (or bytes).  Binary
    strings are distinguished from character strings in two
    ways.  First, binary strings specifically allow storing
    octets of value zero and other <quote>non-printable</quote>
    octets (usually, octets outside the decimal range 32 to 126).
    Character strings disallow zero octets, and also disallow any
    other octet values and sequences of octet values that are invalid
    according to the database's selected character set encoding.
    Second, operations on binary strings process the actual bytes,
    whereas the processing of character strings depends on locale settings.
    In short, binary strings are appropriate for storing data that the
    programmer thinks of as <quote>raw bytes</quote>, whereas character
    strings are appropriate for storing text.
   </para>
________________________________________________________-->
   <para>
    二进制串是一个八位位组（或字节）的序列。 二进制串和字符串的区别有两个： 首先，二进制串明确允许存储零值的字节以及其它<quote>不可打印的</quote>字节（通常是位于十进制范围32到126之外的字节）。 字符串不允许零字节，并且也不允许那些对于数据库的选定字符集编码是非法的任何其它字节值或者字节值序列。 第二，对二进制串的操作会处理实际上的字节，而字符串的处理和取决于区域设置。 简单说，二进制字串适用于存储那些程序员认为是<quote>裸字节</quote>的数据，而字符串适合存储文本。
   </para>
<!-- pgdoc-cn_end sig_en=cf3452a7d37516920f78d6ab79ccb0d0 -->

<!-- pgdoc-cn_start sig_en=95081fb83f19084850817951e50b8783 sig_cn_org=None source=14.1 
   <para>
    The <type>bytea</type> type supports two
    formats for input and output: <quote>hex</quote> format
    and <productname>PostgreSQL</productname>'s historical
    <quote>escape</quote> format.  Both
    of these are always accepted on input.  The output format depends
    on the configuration parameter <xref linkend="guc-bytea-output"/>;
    the default is hex.  (Note that the hex format was introduced in
    <productname>PostgreSQL</productname> 9.0; earlier versions and some
    tools don't understand it.)
   </para>
________________________________________________________-->
   <para>
    <type>bytea</type>类型支持两种用于输入和输出的格式：<quote>十六进制</quote>格式和<productname>PostgreSQL</productname>的历史的<quote>转义</quote>格式。在输入时这两种格式总是会被接受。输出格式则取决于配置参数<xref linkend="guc-bytea-output"/>，其默认值为十六进制（注意十六进制格式是在<productname>PostgreSQL</productname> 9.0中被引入的，早期的版本和某些工具无法理解它）。
   </para>
<!-- pgdoc-cn_end sig_en=95081fb83f19084850817951e50b8783 -->

<!-- pgdoc-cn_start sig_en=1ebdca3f65f5684fec6cd4cf0c1d6c08 sig_cn_org=None source=14.1 
   <para>
    The <acronym>SQL</acronym> standard defines a different binary
    string type, called <type>BLOB</type> or <type>BINARY LARGE
    OBJECT</type>.  The input format is different from
    <type>bytea</type>, but the provided functions and operators are
    mostly the same.
   </para>
________________________________________________________-->
   <para>
    <acronym>SQL</acronym>标准定义了一种不同的二进制串类型， 叫做<type>BLOB</type>或者<type>BINARY LARGE OBJECT</type>。其输入格式和<type>bytea</type>不同，但是提供的函数和操作符大多一样。
   </para>
<!-- pgdoc-cn_end sig_en=1ebdca3f65f5684fec6cd4cf0c1d6c08 -->

  <sect2>
<!-- pgdoc-cn_start sig_en=d164749735cc8ba1c58cd4dccb98241d sig_cn_org=None source=14.1 
   <title><type>bytea</type> Hex Format</title>
________________________________________________________-->
   <title><type>bytea</type>的十六进制格式</title>
<!-- pgdoc-cn_end sig_en=d164749735cc8ba1c58cd4dccb98241d -->

<!-- pgdoc-cn_start sig_en=f2142d9c16289d31345c6a36d118accf sig_cn_org=None source=14.1 
   <para>
    The <quote>hex</quote> format encodes binary data as 2 hexadecimal digits
    per byte, most significant nibble first.  The entire string is
    preceded by the sequence <literal>\x</literal> (to distinguish it
    from the escape format).  In some contexts, the initial backslash may
    need to be escaped by doubling it
    (see <xref linkend="sql-syntax-strings"/>).
    For input, the hexadecimal digits can
    be either upper or lower case, and whitespace is permitted between
    digit pairs (but not within a digit pair nor in the starting
    <literal>\x</literal> sequence).
    The hex format is compatible with a wide
    range of external applications and protocols, and it tends to be
    faster to convert than the escape format, so its use is preferred.
   </para>
________________________________________________________-->
   <para>
    <quote>十六进制</quote>格式将二进制数据编码为每个字节2个十六进制位，最高有效位在前。整个串以序列<literal>\x</literal>开头（用以和转义格式区分）。在某些情景中，开头的反斜线可能需要通过双写来转义，详见(see <xref linkend="sql-syntax-strings"/>)。 作为输入，十六进制位可以是大写也可以是小写，在位对之间可以有空白（但是在位对内部以及开头的<literal>\x</literal>序列中不能有空白）。十六进制格式和很多外部应用及协议相兼容，并且其转换速度要比转义格式更快，因此人们更愿意用它。
   </para>
<!-- pgdoc-cn_end sig_en=f2142d9c16289d31345c6a36d118accf -->

<!-- pgdoc-cn_start sig_en=61083cf99ec27a05eafc4671bdd529c2 sig_cn_org=22267fa7206daa8245460c43151ff3cf source=15.7 
   <para>
    Example:
<programlisting>
SET bytea_output = 'hex';

SELECT '\xDEADBEEF'::bytea;
   bytea
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 \xdeadbeef
</programlisting>
   </para>
________________________________________________________-->
   <para>
    示例:
<programlisting>
SET bytea_output = 'hex';

SELECT '\xDEADBEEF'::bytea;
   bytea
------------
 \xdeadbeef
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=61083cf99ec27a05eafc4671bdd529c2 -->
  </sect2>

  <sect2>
<!-- pgdoc-cn_start sig_en=a43444a978cfe957eeec47de7f887b78 sig_cn_org=None source=14.1 
   <title><type>bytea</type> Escape Format</title>
________________________________________________________-->
   <title><type>bytea</type>的转义格式</title>
<!-- pgdoc-cn_end sig_en=a43444a978cfe957eeec47de7f887b78 -->

<!-- pgdoc-cn_start sig_en=7fc1ff391e05684921f2d3dc04bf19b3 sig_cn_org=None source=14.1 
   <para>
    The <quote>escape</quote> format is the traditional
    <productname>PostgreSQL</productname> format for the <type>bytea</type>
    type.  It
    takes the approach of representing a binary string as a sequence
    of ASCII characters, while converting those bytes that cannot be
    represented as an ASCII character into special escape sequences.
    If, from the point of view of the application, representing bytes
    as characters makes sense, then this representation can be
    convenient.  But in practice it is usually confusing because it
    fuzzes up the distinction between binary strings and character
    strings, and also the particular escape mechanism that was chosen is
    somewhat unwieldy.  Therefore, this format should probably be avoided
    for most new applications.
   </para>
________________________________________________________-->
   <para>
    <quote>转义</quote>格式是<type>bytea</type>类型的传统<productname>PostgreSQL</productname>格式。它采用将二进制串表示成ASCII字符序列的方法，而将那些无法用ASCII字符表示的字节转换成特殊的转义语句。从应用的角度来看，如果将字节表示为字符有意义，那么这种表示将很方便。但是在实际中，这常常是令人困扰的，因为它使二进制串和字符串之间的区别变得模糊，并且这种特别的转义机制也有点难于处理。因此这种格式可能会在大部分新应用中避免使用。
   </para>
<!-- pgdoc-cn_end sig_en=7fc1ff391e05684921f2d3dc04bf19b3 -->

<!-- pgdoc-cn_start sig_en=c1c4e79cb9541819f99734919cb1aa1d sig_cn_org=None source=14.1 
   <para>
    When entering <type>bytea</type> values in escape format,
    octets of certain
    values <emphasis>must</emphasis> be escaped, while all octet
    values <emphasis>can</emphasis> be escaped.  In
    general, to escape an octet, convert it into its three-digit
    octal value and precede it by a backslash.
    Backslash itself (octet decimal value 92) can alternatively be represented by
    double backslashes.
    <xref linkend="datatype-binary-sqlesc"/>
    shows the characters that must be escaped, and gives the alternative
    escape sequences where applicable.
   </para>
________________________________________________________-->
   <para>
    在转义模式下输入<type>bytea</type>值时，某些值的字节<emphasis>必须</emphasis>被转义，而所有的字节值都<emphasis>可以</emphasis>被转义。通常，要转义一个字节，需要把它转换成与它的三位八进制值， 并且前导一个反斜线。反斜线本身（十进制字节值92）也可以用双写的反斜线表示。<xref linkend="datatype-binary-sqlesc"/>显示了必须被转义的字符，并给出了可以使用的替代转义序列。
   </para>
<!-- pgdoc-cn_end sig_en=c1c4e79cb9541819f99734919cb1aa1d -->

   <table id="datatype-binary-sqlesc">
<!-- pgdoc-cn_start sig_en=0df13b3534dbea9c3fb925b7034fe63f sig_cn_org=None source=14.1 
    <title><type>bytea</type> Literal Escaped Octets</title>
________________________________________________________-->
    <title><type>bytea</type>文字转义字节</title>
<!-- pgdoc-cn_end sig_en=0df13b3534dbea9c3fb925b7034fe63f -->
    <tgroup cols="5">
     <colspec colname="col1" colwidth="1*"/>
     <colspec colname="col2" colwidth="1*"/>
     <colspec colname="col3" colwidth="1*"/>
     <colspec colname="col4" colwidth="1.25*"/>
     <colspec colname="col5" colwidth="1*"/>
     <thead>
<!-- pgdoc-cn_start sig_en=3114487a550eb5572e08541d40b28b0e sig_cn_org=None source=14.1 
      <row>
       <entry>Decimal Octet Value</entry>
       <entry>Description</entry>
       <entry>Escaped Input Representation</entry>
       <entry>Example</entry>
       <entry>Hex Representation</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>十进制字节值</entry>
       <entry>描述</entry>
       <entry>转义输入表示</entry>
       <entry>例子</entry>
       <entry>十六进制表示</entry>
      </row>
<!-- pgdoc-cn_end sig_en=3114487a550eb5572e08541d40b28b0e -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=f2c159182988fb0afc059e53eed6839b sig_cn_org=None source=14.1 
      <row>
       <entry>0</entry>
       <entry>zero octet</entry>
       <entry><literal>'\000'</literal></entry>
       <entry><literal>'\000'::bytea</literal></entry>
       <entry><literal>\x00</literal></entry>
      </row>
________________________________________________________-->
      <row>
       <entry>0</entry>
       <entry>0字节</entry>
       <entry><literal>'\000'</literal></entry>
       <entry><literal>'\000'::bytea</literal></entry>
       <entry><literal>\x00</literal></entry>
      </row>
<!-- pgdoc-cn_end sig_en=f2c159182988fb0afc059e53eed6839b -->

<!-- pgdoc-cn_start sig_en=ed1d0b94b0932255c879436202a63e2c sig_cn_org=None source=14.1 
      <row>
       <entry>39</entry>
       <entry>single quote</entry>
       <entry><literal>''''</literal> or <literal>'\047'</literal></entry>
       <entry><literal>''''::bytea</literal></entry>
       <entry><literal>\x27</literal></entry>
      </row>
________________________________________________________-->
      <row>
       <entry>39</entry>
       <entry>单引号</entry>
       <entry><literal>''''</literal>或<literal>'\047'</literal></entry>
       <entry><literal>''''::bytea</literal></entry>
       <entry><literal>\x27</literal></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ed1d0b94b0932255c879436202a63e2c -->

<!-- pgdoc-cn_start sig_en=56c2a78ab437447c154b54666bec80bd sig_cn_org=None source=14.1 
      <row>
       <entry>92</entry>
       <entry>backslash</entry>
       <entry><literal>'\\'</literal> or <literal>'\134'</literal></entry>
       <entry><literal>'\\'::bytea</literal></entry>
       <entry><literal>\x5c</literal></entry>
      </row>
________________________________________________________-->
      <row>
       <entry>92</entry>
       <entry>反斜线</entry>
       <entry><literal>'\\'</literal>或<literal>'\134'</literal></entry>
       <entry><literal>'\\'::bytea</literal></entry>
       <entry><literal>\x5c</literal></entry>
      </row>
<!-- pgdoc-cn_end sig_en=56c2a78ab437447c154b54666bec80bd -->

<!-- pgdoc-cn_start sig_en=5ba1e89c1ba9f003cc08ecd6d3ec9591 sig_cn_org=None source=14.1 
      <row>
       <entry>0 to 31 and 127 to 255</entry>
       <entry><quote>non-printable</quote> octets</entry>
       <entry><literal>'\<replaceable>xxx'</replaceable></literal> (octal value)</entry>
       <entry><literal>'\001'::bytea</literal></entry>
       <entry><literal>\x01</literal></entry>
      </row>
________________________________________________________-->
      <row>
       <entry>0到31和127到255</entry>
       <entry><quote>不可打印的</quote>字节</entry>
       <entry><literal>'\<replaceable>xxx'</replaceable></literal>（八进制值）</entry>
       <entry><literal>'\001'::bytea</literal></entry>
       <entry><literal>\x01</literal></entry>
      </row>
<!-- pgdoc-cn_end sig_en=5ba1e89c1ba9f003cc08ecd6d3ec9591 -->

     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=fbc6d6a7e90373764788c00f8f54d423 sig_cn_org=None source=14.1 
   <para>
    The requirement to escape <emphasis>non-printable</emphasis> octets
    varies depending on locale settings. In some instances you can get away
    with leaving them unescaped.
   </para>
________________________________________________________-->
   <para>
    转义<quote>不可打印的</quote>字节的要求取决于区域设置。在某些实例中，你可以不理睬它们，让它们保持未转义的状态。
   </para>
<!-- pgdoc-cn_end sig_en=fbc6d6a7e90373764788c00f8f54d423 -->

<!-- pgdoc-cn_start sig_en=2347cf0c9953f482e9180bf334f035ec sig_cn_org=None source=14.1 
   <para>
    The reason that single quotes must be doubled, as shown
    in <xref linkend="datatype-binary-sqlesc"/>, is that this
    is true for any string literal in an SQL command.  The generic
    string-literal parser consumes the outermost single quotes
    and reduces any pair of single quotes to one data character.
    What the <type>bytea</type> input function sees is just one
    single quote, which it treats as a plain data character.
    However, the <type>bytea</type> input function treats
    backslashes as special, and the other behaviors shown in
    <xref linkend="datatype-binary-sqlesc"/> are implemented by
    that function.
   </para>
________________________________________________________-->
   <para>
    如<xref linkend="datatype-binary-sqlesc"/>中所示，要求单引号必须写两次的原因对任何SQL命令中的字符串常量都是一样的。
   文字解析器消耗最外层的单引号，并缩减成对的单引号为一个普通数据字符。
   <type>bytea</type>输入函数看到的只是一个单引号，它将其视为普通数据字符。
   但是，<type>bytea</type>输入函数将反斜杠视为特殊字符，<xref linkend ="datatype-binary-sqlesc"/>中显示的其他行为由该函数实现。
   </para>
<!-- pgdoc-cn_end sig_en=2347cf0c9953f482e9180bf334f035ec -->

<!-- pgdoc-cn_start sig_en=eb0719faf5c2eb669cea449d1dd09d92 sig_cn_org=None source=14.1 
   <para>
    In some contexts, backslashes must be doubled compared to what is
    shown above, because the generic string-literal parser will also
    reduce pairs of backslashes to one data character;
    see <xref linkend="sql-syntax-strings"/>.
   </para>
________________________________________________________-->
   <para>
    在某些情况下，反斜杠必须加倍，如上所示，因为通用的字符串文字解析器也会
    将一对反斜杠减少为一个数据字符;请参阅<xref linkend ="sql-syntax-strings"/>。
   </para>
<!-- pgdoc-cn_end sig_en=eb0719faf5c2eb669cea449d1dd09d92 -->

<!-- pgdoc-cn_start sig_en=cc5531ca18731fb510f5c9946e622741 sig_cn_org=None source=14.1 
   <para>
    <type>Bytea</type> octets are output in <literal>hex</literal>
    format by default.  If you change <xref linkend="guc-bytea-output"/>
    to <literal>escape</literal>,
    <quote>non-printable</quote> octets are converted to their
    equivalent three-digit octal value and preceded by one backslash.
    Most <quote>printable</quote> octets are output by their standard
    representation in the client character set, e.g.:

<programlisting>
SET bytea_output = 'escape';

SELECT 'abc \153\154\155 \052\251\124'::bytea;
     bytea
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 abc klm *\251T
</programlisting>

    The octet with decimal value 92 (backslash) is doubled in the output.
    Details are in <xref linkend="datatype-binary-resesc"/>.
   </para>
________________________________________________________-->
   <para>
    <type>Bytea</type>字节默认被输出为<literal>hex</literal>格式。如果你把<xref linkend="guc-bytea-output"/>改为<literal>escape</literal>，<quote>不可打印的</quote>字节会被转换成与之等效的三位八进制值并且前置一个反斜线。大部分<quote>可打印的</quote>字节被输出为它们在客户端字符集中的标准表示形式，例如：

<programlisting>
SET bytea_output = 'escape';

SELECT 'abc \153\154\155 \052\251\124'::bytea;
     bytea
----------------
 abc klm *\251T
</programlisting>

    十进制值为92（反斜线）的字节在输出时被双写。详情请见<xref linkend="datatype-binary-resesc"/>。
   </para>
<!-- pgdoc-cn_end sig_en=cc5531ca18731fb510f5c9946e622741 -->

   <table id="datatype-binary-resesc">
<!-- pgdoc-cn_start sig_en=ea97a955763512bdd3fbb27e44c63ee5 sig_cn_org=None source=14.1 
    <title><type>bytea</type> Output Escaped Octets</title>
________________________________________________________-->
    <title><type>bytea</type>输出转义字节</title>
<!-- pgdoc-cn_end sig_en=ea97a955763512bdd3fbb27e44c63ee5 -->
    <tgroup cols="5">
     <colspec colname="col1" colwidth="1*"/>
     <colspec colname="col2" colwidth="1*"/>
     <colspec colname="col3" colwidth="1*"/>
     <colspec colname="col4" colwidth="1.25*"/>
     <colspec colname="col5" colwidth="1*"/>
     <thead>
<!-- pgdoc-cn_start sig_en=d5bed3c7abee19cf9b665356ff5fca78 sig_cn_org=None source=14.1 
      <row>
       <entry>Decimal Octet Value</entry>
       <entry>Description</entry>
       <entry>Escaped Output Representation</entry>
       <entry>Example</entry>
       <entry>Output Result</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>十进制字节值</entry>
       <entry>描述</entry>
       <entry>转义的输出表示</entry>
       <entry>例子</entry>
       <entry>输出结果</entry>
      </row>
<!-- pgdoc-cn_end sig_en=d5bed3c7abee19cf9b665356ff5fca78 -->
     </thead>

     <tbody>

<!-- pgdoc-cn_start sig_en=7e4ceea8256d9823f20071503050165d sig_cn_org=None source=14.1 
      <row>
       <entry>92</entry>
       <entry>backslash</entry>
       <entry><literal>\\</literal></entry>
       <entry><literal>'\134'::bytea</literal></entry>
       <entry><literal>\\</literal></entry>
      </row>
________________________________________________________-->
      <row>
       <entry>92</entry>
       <entry>反斜线</entry>
       <entry><literal>\\</literal></entry>
       <entry><literal>'\134'::bytea</literal></entry>
       <entry><literal>\\</literal></entry>
      </row>
<!-- pgdoc-cn_end sig_en=7e4ceea8256d9823f20071503050165d -->

<!-- pgdoc-cn_start sig_en=26bd257df141970a41a7a73425b8ad3e sig_cn_org=None source=14.1 
      <row>
       <entry>0 to 31 and 127 to 255</entry>
       <entry><quote>non-printable</quote> octets</entry>
       <entry><literal>\<replaceable>xxx</replaceable></literal> (octal value)</entry>
       <entry><literal>'\001'::bytea</literal></entry>
       <entry><literal>\001</literal></entry>
      </row>
________________________________________________________-->
      <row>
       <entry>0到31和127到255</entry>
       <entry><quote>不可打印的</quote>字节</entry>
       <entry><literal>\<replaceable>xxx</replaceable></literal>（八进制值）</entry>
       <entry><literal>'\001'::bytea</literal></entry>
       <entry><literal>\001</literal></entry>
      </row>
<!-- pgdoc-cn_end sig_en=26bd257df141970a41a7a73425b8ad3e -->

<!-- pgdoc-cn_start sig_en=58fdd3b1a681aaaddb6140e4a2ac4556 sig_cn_org=None source=14.1 
      <row>
       <entry>32 to 126</entry>
       <entry><quote>printable</quote> octets</entry>
       <entry>client character set representation</entry>
       <entry><literal>'\176'::bytea</literal></entry>
       <entry><literal>~</literal></entry>
      </row>
________________________________________________________-->
      <row>
       <entry>32到126</entry>
       <entry><quote>可打印的</quote>字节</entry>
       <entry>客户端字符集表示</entry>
       <entry><literal>'\176'::bytea</literal></entry>
       <entry><literal>~</literal></entry>
      </row>
<!-- pgdoc-cn_end sig_en=58fdd3b1a681aaaddb6140e4a2ac4556 -->

     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=6bbe59d3fd34395ac6ef02dde167381a sig_cn_org=None source=14.1 
   <para>
    Depending on the front end to <productname>PostgreSQL</productname> you use,
    you might have additional work to do in terms of escaping and
    unescaping <type>bytea</type> strings. For example, you might also
    have to escape line feeds and carriage returns if your interface
    automatically translates these.
   </para>
________________________________________________________-->
   <para>
    根据你使用的<productname>PostgreSQL</productname>前端，你在转义和未转义<type>bytea</type>串方面可能需要做额外的工作。例如，如果你的接口自动翻译换行和回车，你可能也不得不转义它们。
   </para>
<!-- pgdoc-cn_end sig_en=6bbe59d3fd34395ac6ef02dde167381a -->
  </sect2>
 </sect1>


  <sect1 id="datatype-datetime">
<!-- pgdoc-cn_start sig_en=fa580fb1ac30654f2cc4a7d02202ea87 sig_cn_org=None source=14.1 
   <title>Date/Time Types</title>
________________________________________________________-->
   <title>日期/时间类型</title>
<!-- pgdoc-cn_end sig_en=fa580fb1ac30654f2cc4a7d02202ea87 -->

<!-- pgdoc-cn_start sig_en=2ecc983de188c2fb447d78c6d4db2c93 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-datetime">
    <primary>date</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-datetime">
    <primary>date</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=2ecc983de188c2fb447d78c6d4db2c93 -->
<!-- pgdoc-cn_start sig_en=825a38de00d0a5c4237b2b04d478fa6f sig_cn_org=None source=14.1 
   <indexterm zone="datatype-datetime">
    <primary>time</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-datetime">
    <primary>time</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=825a38de00d0a5c4237b2b04d478fa6f -->
<!-- pgdoc-cn_start sig_en=ef5d40b6d0739d450e0f2b0be89fbf4e sig_cn_org=None source=14.1 
   <indexterm zone="datatype-datetime">
    <primary>time without time zone</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-datetime">
    <primary>不带时区的时间</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=ef5d40b6d0739d450e0f2b0be89fbf4e -->
<!-- pgdoc-cn_start sig_en=0fc618745561c18c50a0793bccfab298 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-datetime">
    <primary>time with time zone</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-datetime">
    <primary>带时区的时间</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=0fc618745561c18c50a0793bccfab298 -->
<!-- pgdoc-cn_start sig_en=d92174199c825c3d8d46b8fb0cb310fa sig_cn_org=None source=14.1 
   <indexterm zone="datatype-datetime">
    <primary>timestamp</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-datetime">
    <primary>timestamp</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=d92174199c825c3d8d46b8fb0cb310fa -->
<!-- pgdoc-cn_start sig_en=1d5384d28c5c0d5c3416f0aab749a771 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-datetime">
    <primary>timestamptz</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-datetime">
    <primary>timestamptz</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=1d5384d28c5c0d5c3416f0aab749a771 -->
<!-- pgdoc-cn_start sig_en=9cc19e4a4524fe2c9de2c00ce3c3b077 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-datetime">
    <primary>timestamp with time zone</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-datetime">
    <primary>带时区的时间戳</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=9cc19e4a4524fe2c9de2c00ce3c3b077 -->
<!-- pgdoc-cn_start sig_en=3ba6270ce8664d4313a50dd2a376fca8 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-datetime">
    <primary>timestamp without time zone</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-datetime">
    <primary>不带时区的时间戳</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=3ba6270ce8664d4313a50dd2a376fca8 -->
<!-- pgdoc-cn_start sig_en=f5c796eec77239f322a0a6d770a09fd3 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-datetime">
    <primary>interval</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-datetime">
    <primary>间隔</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=f5c796eec77239f322a0a6d770a09fd3 -->
<!-- pgdoc-cn_start sig_en=95def2e78897a5d6232da8604659bd86 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-datetime">
    <primary>time span</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-datetime">
    <primary>时间跨度</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=95def2e78897a5d6232da8604659bd86 -->

<!-- pgdoc-cn_start sig_en=4fb9d78627c5c54e627de7c4f2ab6a03 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> supports the full set of
    <acronym>SQL</acronym> date and time types, shown in <xref
    linkend="datatype-datetime-table"/>.  The operations available
    on these data types are described in
    <xref linkend="functions-datetime"/>.
    Dates are counted according to the Gregorian calendar, even in
    years before that calendar was introduced (see <xref
    linkend="datetime-units-history"/> for more information).
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>支持<acronym>SQL</acronym>中所有的日期和时间类型，如<xref linkend="datatype-datetime-table"/>所示。这些数据类型上可用的操作如<xref linkend="functions-datetime"/>所述。日期根据公历来计算，即使对于该历法被引入之前的年份也一样（见<xref linkend="datetime-units-history"/>）。
   </para>
<!-- pgdoc-cn_end sig_en=4fb9d78627c5c54e627de7c4f2ab6a03 -->

    <table id="datatype-datetime-table">
<!-- pgdoc-cn_start sig_en=fa580fb1ac30654f2cc4a7d02202ea87 sig_cn_org=None source=14.1 
     <title>Date/Time Types</title>
________________________________________________________-->
     <title>日期/时间类型</title>
<!-- pgdoc-cn_end sig_en=fa580fb1ac30654f2cc4a7d02202ea87 -->
     <tgroup cols="6">
      <thead>
<!-- pgdoc-cn_start sig_en=f5885ddfa2f27b28f8e1a27891d14c9a sig_cn_org=None source=14.1 
       <row>
        <entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry>
        <entry>Low Value</entry>
        <entry>High Value</entry>
        <entry>Resolution</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>名字</entry>
        <entry>存储尺寸</entry>
        <entry>描述</entry>
        <entry>最小值</entry>
        <entry>最大值</entry>
        <entry>解析度</entry>
       </row>
<!-- pgdoc-cn_end sig_en=f5885ddfa2f27b28f8e1a27891d14c9a -->
      </thead>
      <tbody>
<!-- pgdoc-cn_start sig_en=6c28cac4f52af53b4a7584643cd397f7 sig_cn_org=None source=14.1 
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
        <entry>8 bytes</entry>
        <entry>both date and time (no time zone)</entry>
        <entry>4713 BC</entry>
        <entry>294276 AD</entry>
        <entry>1 microsecond</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
        <entry>8字节</entry>
        <entry>包括日期和时间（无时区）</entry>
        <entry>4713 BC</entry>
        <entry>294276 AD</entry>
        <entry>1微秒</entry>
       </row>
<!-- pgdoc-cn_end sig_en=6c28cac4f52af53b4a7584643cd397f7 -->
<!-- pgdoc-cn_start sig_en=c39cf8bfc15c53a1c5078927774028fc sig_cn_org=None source=14.1 
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
        <entry>8 bytes</entry>
        <entry>both date and time, with time zone</entry>
        <entry>4713 BC</entry>
        <entry>294276 AD</entry>
        <entry>1 microsecond</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>timestamp [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
        <entry>8字节</entry>
        <entry>包括日期和时间，有时区</entry>
        <entry>4713 BC</entry>
        <entry>294276 AD</entry>
        <entry>1微秒</entry>
       </row>
<!-- pgdoc-cn_end sig_en=c39cf8bfc15c53a1c5078927774028fc -->
<!-- pgdoc-cn_start sig_en=f5fb922c95d293e412de58a4f454cb66 sig_cn_org=None source=14.1 
       <row>
        <entry><type>date</type></entry>
        <entry>4 bytes</entry>
        <entry>date (no time of day)</entry>
        <entry>4713 BC</entry>
        <entry>5874897 AD</entry>
        <entry>1 day</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>date</type></entry>
        <entry>4字节</entry>
        <entry>日期（没有一天中的时间）</entry>
        <entry>4713 BC</entry>
        <entry>5874897 AD</entry>
        <entry>1日</entry>
       </row>
<!-- pgdoc-cn_end sig_en=f5fb922c95d293e412de58a4f454cb66 -->
<!-- pgdoc-cn_start sig_en=d032139d7c824afce60103ccab3a64c3 sig_cn_org=None source=14.1 
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
        <entry>8 bytes</entry>
        <entry>time of day (no date)</entry>
        <entry>00:00:00</entry>
        <entry>24:00:00</entry>
        <entry>1 microsecond</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] [ without time zone ]</type></entry>
        <entry>8字节</entry>
        <entry>一天中的时间（无日期）</entry>
        <entry>00:00:00</entry>
        <entry>24:00:00</entry>
        <entry>1微秒</entry>
       </row>
<!-- pgdoc-cn_end sig_en=d032139d7c824afce60103ccab3a64c3 -->
<!-- pgdoc-cn_start sig_en=a4758b371cb837fab6f7de8467457f43 sig_cn_org=None source=14.1 
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
        <entry>12 bytes</entry>
        <entry>time of day (no date), with time zone</entry>
        <!-&minus; see MAX_TZDISP_HOUR in datatype/timestamp.h -&minus;>
        <entry>00:00:00+1559</entry>
        <entry>24:00:00-1559</entry>
        <entry>1 microsecond</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>time [ (<replaceable>p</replaceable>) ] with time zone</type></entry>
        <entry>12字节</entry>
        <entry>仅仅是一天中的时间（没有日期），带有时区</entry>
        <!-- 在数据类型中参见 MAX_TZDISP_HOUR /timestamp.h -->
        <entry>00:00:00+1459</entry>
        <entry>24:00:00-1459</entry>
        <entry>1微秒</entry>
       </row>
<!-- pgdoc-cn_end sig_en=a4758b371cb837fab6f7de8467457f43 -->
<!-- pgdoc-cn_start sig_en=11d409963d871541453146d99c6a9221 sig_cn_org=None source=14.1 
       <row>
        <entry><type>interval [ <replaceable>fields</replaceable> ] [ (<replaceable>p</replaceable>) ]</type></entry>
        <entry>16 bytes</entry>
        <entry>time interval</entry>
        <entry>-178000000 years</entry>
        <entry>178000000 years</entry>
        <entry>1 microsecond</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>interval [ <replaceable>fields</replaceable> ] [ (<replaceable>p</replaceable>) ]</type></entry>
        <entry>16字节</entry>
        <entry>时间间隔</entry>
        <entry>-178000000年</entry>
        <entry>178000000年</entry>
        <entry>1微秒</entry>
       </row>
<!-- pgdoc-cn_end sig_en=11d409963d871541453146d99c6a9221 -->
      </tbody>
     </tgroup>
    </table>

   <note>
<!-- pgdoc-cn_start sig_en=014235a634510b48fa9ad4db580439c8 sig_cn_org=None source=14.1 
    <para>
     The SQL standard requires that writing just <type>timestamp</type>
     be equivalent to <type>timestamp without time
     zone</type>, and <productname>PostgreSQL</productname> honors that
     behavior.  <type>timestamptz</type> is accepted as an
     abbreviation for <type>timestamp with time zone</type>; this is a
     <productname>PostgreSQL</productname> extension.
    </para>
________________________________________________________-->
    <para>
     SQL要求只写<type>timestamp</type>等效于<type>timestamp without time zone</type>，并且<productname>PostgreSQL</productname>鼓励这种行为。<type>timestamptz</type>被接受为<type>timestamp with time zone</type>的一种简写，这是一种<productname>PostgreSQL</productname>的扩展。
    </para>
<!-- pgdoc-cn_end sig_en=014235a634510b48fa9ad4db580439c8 -->
   </note>

<!-- pgdoc-cn_start sig_en=650561637ebfe31a9bf14d57985aad80 sig_cn_org=None source=14.1 
   <para>
    <type>time</type>, <type>timestamp</type>, and
    <type>interval</type> accept an optional precision value
    <replaceable>p</replaceable> which specifies the number of
    fractional digits retained in the seconds field. By default, there
    is no explicit bound on precision.  The allowed range of
    <replaceable>p</replaceable> is from 0 to 6.
   </para>
________________________________________________________-->
   <para>
    <type>time</type>、<type>timestamp</type>和<type>interval</type>接受一个可选的精度值 <replaceable>p</replaceable>，这个精度值声明在秒域中小数点之后保留的位数。缺省情况下，在精度上没有明确的边界。<replaceable>p</replaceable>允许的范围是从 0 到 6。
   </para>
<!-- pgdoc-cn_end sig_en=650561637ebfe31a9bf14d57985aad80 -->

<!-- pgdoc-cn_start sig_en=02c037743a4ba172b270706047cd5cfc sig_cn_org=None source=14.1 
   <para>
    The <type>interval</type> type has an additional option, which is
    to restrict the set of stored fields by writing one of these phrases:
<literallayout class="monospaced">
YEAR
MONTH
DAY
HOUR
MINUTE
SECOND
YEAR TO MONTH
DAY TO HOUR
DAY TO MINUTE
DAY TO SECOND
HOUR TO MINUTE
HOUR TO SECOND
MINUTE TO SECOND
</literallayout>
    Note that if both <replaceable>fields</replaceable> and
    <replaceable>p</replaceable> are specified, the
    <replaceable>fields</replaceable> must include <literal>SECOND</literal>,
    since the precision applies only to the seconds.
   </para>
________________________________________________________-->
   <para>
    <type>interval</type>类型有一个附加选项，它可以通过写下面之一的短语来限制存储的fields的集合：
<literallayout class="monospaced">
YEAR
MONTH
DAY
HOUR
MINUTE
SECOND
YEAR TO MONTH
DAY TO HOUR
DAY TO MINUTE
DAY TO SECOND
HOUR TO MINUTE
HOUR TO SECOND
MINUTE TO SECOND
</literallayout>
    注意如果<replaceable>fields</replaceable>和<replaceable>p</replaceable>被指定，<replaceable>fields</replaceable>必须包括<literal>SECOND</literal>，因为精度只应用于秒。
   </para>
<!-- pgdoc-cn_end sig_en=02c037743a4ba172b270706047cd5cfc -->

<!-- pgdoc-cn_start sig_en=fc38972e82adbe52f36f5994430d91a7 sig_cn_org=None source=14.1 
   <para>
    The type <type>time with time zone</type> is defined by the SQL
    standard, but the definition exhibits properties which lead to
    questionable usefulness. In most cases, a combination of
    <type>date</type>, <type>time</type>, <type>timestamp without time
    zone</type>, and <type>timestamp with time zone</type> should
    provide a complete range of date/time functionality required by
    any application.
   </para>
________________________________________________________-->
   <para>
    类型<type>time with time zone</type>是 SQL 标准定义的，但是该定义显示出了一些会影响可用性的性质。在大多数情况下， <type>date</type>、<type>time</type>、<type>timestamp without time zone</type>和<type>timestamp with time zone</type>的组合就应该能提供任何应用所需的全范围的日期/时间功能。
   </para>
<!-- pgdoc-cn_end sig_en=fc38972e82adbe52f36f5994430d91a7 -->

   <sect2 id="datatype-datetime-input">
<!-- pgdoc-cn_start sig_en=525a5cdbbc807c1d151b429a533a33d0 sig_cn_org=None source=14.1 
    <title>Date/Time Input</title>
________________________________________________________-->
    <title> 日期/时间输入</title>
<!-- pgdoc-cn_end sig_en=525a5cdbbc807c1d151b429a533a33d0 -->

<!-- pgdoc-cn_start sig_en=b0d326ceb3dc654d01c256e1e8c93e4e sig_cn_org=None source=14.1 
    <para>
     Date and time input is accepted in almost any reasonable format, including
     ISO 8601, <acronym>SQL</acronym>-compatible,
     traditional <productname>POSTGRES</productname>, and others.
     For some formats, ordering of day, month, and year in date input is
     ambiguous and there is support for specifying the expected
     ordering of these fields.  Set the <xref linkend="guc-datestyle"/> parameter
     to <literal>MDY</literal> to select month-day-year interpretation,
     <literal>DMY</literal> to select day-month-year interpretation, or
     <literal>YMD</literal> to select year-month-day interpretation.
    </para>
________________________________________________________-->
    <para>
     日期和时间的输入可以接受几乎任何合理的格式，包括 ISO 8601、<acronym>SQL</acronym>-兼容的、传统<productname>POSTGRES</productname>的和其他的形式。 对于一些格式，日期输入里的日、月和年的顺序会让人混淆， 并且支持指定所预期的这些域的顺序。把<xref linkend="guc-datestyle"/>参数设置为<literal>MDY</literal>，就是选择“月－日－年”的解释，设置为<literal>DMY</literal>就是 “日－月－年”，而<literal>YMD</literal>是 “年－月－日”。
    </para>
<!-- pgdoc-cn_end sig_en=b0d326ceb3dc654d01c256e1e8c93e4e -->

<!-- pgdoc-cn_start sig_en=41cb022f8374be1a75ec32572856da6e sig_cn_org=None source=14.1 
    <para>
     <productname>PostgreSQL</productname> is more flexible in
     handling date/time input than the
     <acronym>SQL</acronym> standard requires.
     See <xref linkend="datetime-appendix"/>
     for the exact parsing rules of date/time input and for the
     recognized text fields including months, days of the week, and
     time zones.
    </para>
________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>在处理日期/时间输入上比<acronym>SQL</acronym>标准要求的更灵活。 参阅<xref linkend="datetime-appendix"/>获取关于日期/时间输入的准确的分析规则和可识别文本域，包括月份、星期几和时区。
    </para>
<!-- pgdoc-cn_end sig_en=41cb022f8374be1a75ec32572856da6e -->

<!-- pgdoc-cn_start sig_en=133430ea03909e99ea2266001edaee71 sig_cn_org=None source=14.1 
    <para>
     Remember that any date or time literal input needs to be enclosed
     in single quotes, like text strings.  Refer to
     <xref linkend="sql-syntax-constants-generic"/> for more
     information.
     <acronym>SQL</acronym> requires the following syntax
<synopsis>
<replaceable>type</replaceable> [ (<replaceable>p</replaceable>) ] '<replaceable>value</replaceable>'
</synopsis>
     where <replaceable>p</replaceable> is an optional precision
     specification giving the number of
     fractional digits in the seconds field. Precision can be
     specified for <type>time</type>, <type>timestamp</type>, and
     <type>interval</type> types, and can range from 0 to 6.
     If no precision is specified in a constant specification,
     it defaults to the precision of the literal value (but not
     more than 6 digits).
    </para>
________________________________________________________-->
    <para>
     请记住任何日期或者时间的文字输入需要由单引号包围，就象一个文本字符串一样。参考<xref linkend="sql-syntax-constants-generic"/>获取更多信息。<acronym>SQL</acronym>要求下面的语法
<synopsis>
<replaceable>type</replaceable> [ (<replaceable>p</replaceable>) ] '<replaceable>value</replaceable>'
</synopsis>
     其中<replaceable>p</replaceable>是一个可选的精度声明，它给出了在秒域中的小数位数目。精度可以被指定给<type>time</type>、<type>timestamp</type>和<type>interval</type>类型，并且可以取从0到6的值。这允许前文所述的值。如果在一个常数声明中没有指定任何精度，它将默认取文字值的精度（但不能超过6位）。
    </para>
<!-- pgdoc-cn_end sig_en=133430ea03909e99ea2266001edaee71 -->

    <sect3>
<!-- pgdoc-cn_start sig_en=ea2b40ae215a5958b5a146ca31f2f65c sig_cn_org=None source=14.1 
    <title>Dates</title>
________________________________________________________-->
    <title>日期</title>
<!-- pgdoc-cn_end sig_en=ea2b40ae215a5958b5a146ca31f2f65c -->

<!-- pgdoc-cn_start sig_en=708eb14f817ea6a24377e49c05fabe8a sig_cn_org=None source=14.1 
    <indexterm>
     <primary>date</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>date</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=708eb14f817ea6a24377e49c05fabe8a -->

<!-- pgdoc-cn_start sig_en=cccf9855417d98da8c18d721ba5e44cf sig_cn_org=None source=14.1 
    <para>
     <xref linkend="datatype-datetime-date-table"/> shows some possible
     inputs for the <type>date</type> type.
    </para>
________________________________________________________-->
    <para>
     <xref linkend="datatype-datetime-date-table"/>显示了<type>date</type>类型可能的输入方式。
    </para>
<!-- pgdoc-cn_end sig_en=cccf9855417d98da8c18d721ba5e44cf -->

     <table id="datatype-datetime-date-table">
<!-- pgdoc-cn_start sig_en=0d0a247af6e64e01afc805cc65c2c849 sig_cn_org=None source=14.1 
      <title>Date Input</title>
________________________________________________________-->
      <title>日期输入</title>
<!-- pgdoc-cn_end sig_en=0d0a247af6e64e01afc805cc65c2c849 -->
      <tgroup cols="2">
       <colspec colname="col1" colwidth="1*"/>
       <colspec colname="col2" colwidth="2*"/>
       <thead>
<!-- pgdoc-cn_start sig_en=60ecc22310c4db7c945afd5cf3c23861 sig_cn_org=None source=14.1 
        <row>
         <entry>Example</entry>
         <entry>Description</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>例子</entry>
         <entry>描述</entry>
        </row>
<!-- pgdoc-cn_end sig_en=60ecc22310c4db7c945afd5cf3c23861 -->
       </thead>
       <tbody>
<!-- pgdoc-cn_start sig_en=80a21b2d2921f5d7a4b86f5050376718 sig_cn_org=None source=14.1 
        <row>
         <entry>1999-01-08</entry>
         <entry>ISO 8601; January 8 in any mode
         (recommended format)</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>1999-01-08</entry>
         <entry>ISO 8601; 任何模式下的1月8日
         （推荐格式）</entry>
        </row>
<!-- pgdoc-cn_end sig_en=80a21b2d2921f5d7a4b86f5050376718 -->
<!-- pgdoc-cn_start sig_en=fca3a0eca269015067ea376a103d023c sig_cn_org=None source=14.1 
        <row>
         <entry>January 8, 1999</entry>
         <entry>unambiguous in any <varname>datestyle</varname> input mode</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>January 8, 1999</entry>
         <entry>在任何<varname>datestyle</varname>输入模式下都无歧义</entry>
        </row>
<!-- pgdoc-cn_end sig_en=fca3a0eca269015067ea376a103d023c -->
<!-- pgdoc-cn_start sig_en=42bf74e78d06f63315e633c30179174c sig_cn_org=None source=14.1 
        <row>
         <entry>1/8/1999</entry>
         <entry>January 8 in <literal>MDY</literal> mode;
          August 1 in <literal>DMY</literal> mode</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>1/8/1999</entry>
         <entry><literal>MDY</literal>模式中的1月8日；<literal>DMY</literal>模式中的8月1日</entry>
        </row>
<!-- pgdoc-cn_end sig_en=42bf74e78d06f63315e633c30179174c -->
<!-- pgdoc-cn_start sig_en=86c5c65ea5ffd15b4c46d9c175e1744b sig_cn_org=None source=14.1 
        <row>
         <entry>1/18/1999</entry>
         <entry>January 18 in <literal>MDY</literal> mode;
          rejected in other modes</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>1/18/1999</entry>
         <entry><literal>MDY</literal>模式中的1月18日；在其他模式中被拒绝</entry>
        </row>
<!-- pgdoc-cn_end sig_en=86c5c65ea5ffd15b4c46d9c175e1744b -->
<!-- pgdoc-cn_start sig_en=94e4889648405d25c4dbe9c84075edad sig_cn_org=None source=14.1 
        <row>
         <entry>01/02/03</entry>
         <entry>January 2, 2003 in <literal>MDY</literal> mode;
          February 1, 2003 in <literal>DMY</literal> mode;
          February 3, 2001 in <literal>YMD</literal> mode
         </entry>
        </row>
________________________________________________________-->
        <row>
         <entry>01/02/03</entry>
         <entry><literal>MDY</literal>模式中的2003年1月2日；
          <literal>DMY</literal>模式中的2003年2月1日；
          <literal>YMD</literal>模式中的2001年2月3日
         </entry>
        </row>
<!-- pgdoc-cn_end sig_en=94e4889648405d25c4dbe9c84075edad -->
<!-- pgdoc-cn_start sig_en=bc994a31a6eb24e9853946610c482d13 sig_cn_org=None source=14.1 
        <row>
         <entry>1999-Jan-08</entry>
         <entry>January 8 in any mode</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>1999-Jan-08</entry>
         <entry>任何模式下的1月8日</entry>
        </row>
<!-- pgdoc-cn_end sig_en=bc994a31a6eb24e9853946610c482d13 -->
<!-- pgdoc-cn_start sig_en=d5b799a6ea54ff58b5f4632d12492274 sig_cn_org=None source=14.1 
        <row>
         <entry>Jan-08-1999</entry>
         <entry>January 8 in any mode</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>Jan-08-1999</entry>
         <entry>任何模式下的1月8日</entry>
        </row>
<!-- pgdoc-cn_end sig_en=d5b799a6ea54ff58b5f4632d12492274 -->
<!-- pgdoc-cn_start sig_en=021c36b33829f71e472c10e24eeaea07 sig_cn_org=None source=14.1 
        <row>
         <entry>08-Jan-1999</entry>
         <entry>January 8 in any mode</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>08-Jan-1999</entry>
         <entry>任何模式下的1月8日</entry>
        </row>
<!-- pgdoc-cn_end sig_en=021c36b33829f71e472c10e24eeaea07 -->
<!-- pgdoc-cn_start sig_en=5791961627983a53cbf5e0d2ef3b4da2 sig_cn_org=None source=14.1 
        <row>
         <entry>99-Jan-08</entry>
         <entry>January 8 in <literal>YMD</literal> mode, else error</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>99-Jan-08</entry>
         <entry><literal>YMD</literal>模式中的1月8日，否则错误</entry>
        </row>
<!-- pgdoc-cn_end sig_en=5791961627983a53cbf5e0d2ef3b4da2 -->
<!-- pgdoc-cn_start sig_en=e94a81628379d6daba8a0c6ededc7e52 sig_cn_org=None source=14.1 
        <row>
         <entry>08-Jan-99</entry>
         <entry>January 8, except error in <literal>YMD</literal> mode</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>08-Jan-99</entry>
         <entry>1月8日，除了在<literal>YMD</literal>模式中错误</entry>
        </row>
<!-- pgdoc-cn_end sig_en=e94a81628379d6daba8a0c6ededc7e52 -->
<!-- pgdoc-cn_start sig_en=05c3b215c7a25955da08bc0efb094220 sig_cn_org=None source=14.1 
        <row>
         <entry>Jan-08-99</entry>
         <entry>January 8, except error in <literal>YMD</literal> mode</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>Jan-08-99</entry>
         <entry>1月8日，除了在<literal>YMD</literal>模式中错误</entry>
        </row>
<!-- pgdoc-cn_end sig_en=05c3b215c7a25955da08bc0efb094220 -->
<!-- pgdoc-cn_start sig_en=9e6f9ab069f980b2bea42084414e80bf sig_cn_org=None source=14.1 
        <row>
         <entry>19990108</entry>
         <entry>ISO 8601; January 8, 1999 in any mode</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>19990108</entry>
         <entry>ISO 8601; 任何模式中的1999年1月8日</entry>
        </row>
<!-- pgdoc-cn_end sig_en=9e6f9ab069f980b2bea42084414e80bf -->
<!-- pgdoc-cn_start sig_en=6ce68f21f435292693cd3590815337a2 sig_cn_org=None source=14.1 
        <row>
         <entry>990108</entry>
         <entry>ISO 8601; January 8, 1999 in any mode</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>990108</entry>
         <entry>ISO 8601; 任何模式中的1999年1月8日</entry>
        </row>
<!-- pgdoc-cn_end sig_en=6ce68f21f435292693cd3590815337a2 -->
<!-- pgdoc-cn_start sig_en=aa1384d18954d3ebe6c1e84342bbdda6 sig_cn_org=None source=14.1 
        <row>
         <entry>1999.008</entry>
         <entry>year and day of year</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>1999.008</entry>
         <entry>年和一年中的日子</entry>
        </row>
<!-- pgdoc-cn_end sig_en=aa1384d18954d3ebe6c1e84342bbdda6 -->
<!-- pgdoc-cn_start sig_en=dd733bd4a4de01671c7d3878d66d9541 sig_cn_org=None source=14.1 
        <row>
         <entry>J2451187</entry>
         <entry>Julian date</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>J2451187</entry>
         <entry>儒略日期</entry>
        </row>
<!-- pgdoc-cn_end sig_en=dd733bd4a4de01671c7d3878d66d9541 -->
<!-- pgdoc-cn_start sig_en=9c8d248a21782e2ac5f0059b35d5fc12 sig_cn_org=None source=14.1 
        <row>
         <entry>January 8, 99 BC</entry>
         <entry>year 99 BC</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>January 8, 99 BC</entry>
         <entry>公元前99年</entry>
        </row>
<!-- pgdoc-cn_end sig_en=9c8d248a21782e2ac5f0059b35d5fc12 -->
       </tbody>
      </tgroup>
     </table>
    </sect3>

    <sect3>
<!-- pgdoc-cn_start sig_en=b90833ba5d26e2a2ad5c9751ed2848cf sig_cn_org=None source=14.1 
     <title>Times</title>
________________________________________________________-->
     <title>时间</title>
<!-- pgdoc-cn_end sig_en=b90833ba5d26e2a2ad5c9751ed2848cf -->

<!-- pgdoc-cn_start sig_en=ba9977488d167dbddbc15d9681688cae sig_cn_org=None source=14.1 
     <indexterm>
      <primary>time</primary>
     </indexterm>
________________________________________________________-->
     <indexterm>
      <primary>time</primary>
     </indexterm>
<!-- pgdoc-cn_end sig_en=ba9977488d167dbddbc15d9681688cae -->
<!-- pgdoc-cn_start sig_en=203ebd5bdef8964bc8d6882e39c6d1d5 sig_cn_org=None source=14.1 
     <indexterm>
      <primary>time without time zone</primary>
     </indexterm>
________________________________________________________-->
     <indexterm>
      <primary>time without time zone</primary>
     </indexterm>
<!-- pgdoc-cn_end sig_en=203ebd5bdef8964bc8d6882e39c6d1d5 -->
<!-- pgdoc-cn_start sig_en=cc51fbddc9061d2686b31af15d1ccce7 sig_cn_org=None source=14.1 
     <indexterm>
      <primary>time with time zone</primary>
     </indexterm>
________________________________________________________-->
     <indexterm>
      <primary>time with time zone</primary>
     </indexterm>
<!-- pgdoc-cn_end sig_en=cc51fbddc9061d2686b31af15d1ccce7 -->

<!-- pgdoc-cn_start sig_en=d2be942b90f1f2b7ccab4f2ca4068612 sig_cn_org=None source=14.1 
     <para>
      The time-of-day types are <type>time [
      (<replaceable>p</replaceable>) ] without time zone</type> and
      <type>time [ (<replaceable>p</replaceable>) ] with time
      zone</type>.  <type>time</type> alone is equivalent to
      <type>time without time zone</type>.
     </para>
________________________________________________________-->
     <para>
      当日时间类型是<type>time [ (<replaceable>p</replaceable>) ] without time zone</type>和<type>time [ (<replaceable>p</replaceable>) ] with time zone</type>。 只写<type>time</type>等效于<type>time without time zone</type>。
     </para>
<!-- pgdoc-cn_end sig_en=d2be942b90f1f2b7ccab4f2ca4068612 -->

<!-- pgdoc-cn_start sig_en=2ddc26bf8d51cfca90d60bb0bc11a715 sig_cn_org=ff86c69a0c4c7062c9889848c63ae2af source=15.7 
     <para>
      Valid input for these types consists of a time of day followed
      by an optional time zone. (See <xref
      linkend="datatype-datetime-time-table"/>
      and <xref linkend="datatype-timezone-table"/>.)  If a time zone is
      specified in the input for <type>time without time zone</type>,
      it is silently ignored. You can also specify a date but it will
      be ignored, except when you use a time zone name that involves a
      daylight-savings rule, such as
      <literal>America/New_York</literal>. In this case specifying the date
      is required in order to determine whether standard or daylight-savings
      time applies.  The appropriate time zone offset is recorded in the
      <type>time with time zone</type> value and is output as stored;
      it is not adjusted to the active time zone.
     </para>
________________________________________________________-->
     <para>
      这些类型的有效输入包括一个时间，后面跟着一个可选的时区。（参见<xref linkend="datatype-datetime-time-table"/>和<xref linkend="datatype-timezone-table"/>。）
	  如果在<type>不带时区的时间</type>的输入中指定了时区，则会被静默忽略。您也可以指定一个日期，但会被忽略，除非您使用涉及夏令时规则的时区名称，例如<literal>America/New_York</literal>。
	  在这种情况下，指定日期是必需的，以确定标准时间还是夏令时适用。适当的时区偏移记录在<type>带时区的时间</type>值中，并按存储的方式输出；它不会根据活动时区进行调整。
     </para>
<!-- pgdoc-cn_end sig_en=2ddc26bf8d51cfca90d60bb0bc11a715 -->

      <table id="datatype-datetime-time-table">
<!-- pgdoc-cn_start sig_en=cc3a6efc99eebc9289f3dc07d5a7d235 sig_cn_org=None source=14.1 
       <title>Time Input</title>
________________________________________________________-->
       <title>时间输入</title>
<!-- pgdoc-cn_end sig_en=cc3a6efc99eebc9289f3dc07d5a7d235 -->
       <tgroup cols="2">
        <colspec colname="col1" colwidth="3*"/>
        <colspec colname="col2" colwidth="2*"/>
        <thead>
<!-- pgdoc-cn_start sig_en=be428e485013ffc9394f7a44c759438b sig_cn_org=None source=14.1 
         <row>
          <entry>Example</entry>
          <entry>Description</entry>
         </row>
________________________________________________________-->
         <row>
          <entry>例子</entry>
          <entry>描述</entry>
         </row>
<!-- pgdoc-cn_end sig_en=be428e485013ffc9394f7a44c759438b -->
        </thead>
        <tbody>
<!-- pgdoc-cn_start sig_en=9c354314bc23f6d25a43c3f1568c2f4b sig_cn_org=None source=14.1 
         <row>
          <entry><literal>04:05:06.789</literal></entry>
          <entry>ISO 8601</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>04:05:06.789</literal></entry>
          <entry>ISO 8601</entry>
         </row>
<!-- pgdoc-cn_end sig_en=9c354314bc23f6d25a43c3f1568c2f4b -->
<!-- pgdoc-cn_start sig_en=e3be34fe27dac32866135366876b34e8 sig_cn_org=None source=14.1 
         <row>
          <entry><literal>04:05:06</literal></entry>
          <entry>ISO 8601</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>04:05:06</literal></entry>
          <entry>ISO 8601</entry>
         </row>
<!-- pgdoc-cn_end sig_en=e3be34fe27dac32866135366876b34e8 -->
<!-- pgdoc-cn_start sig_en=8cec80d4edf5ee3bd782e0d11d5e6d3e sig_cn_org=None source=14.1 
         <row>
          <entry><literal>04:05</literal></entry>
          <entry>ISO 8601</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>04:05</literal></entry>
          <entry>ISO 8601</entry>
         </row>
<!-- pgdoc-cn_end sig_en=8cec80d4edf5ee3bd782e0d11d5e6d3e -->
<!-- pgdoc-cn_start sig_en=bdf9ae633dbad5bf54a0d77c32f84021 sig_cn_org=None source=14.1 
         <row>
          <entry><literal>040506</literal></entry>
          <entry>ISO 8601</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>040506</literal></entry>
          <entry>ISO 8601</entry>
         </row>
<!-- pgdoc-cn_end sig_en=bdf9ae633dbad5bf54a0d77c32f84021 -->
<!-- pgdoc-cn_start sig_en=b68c41930f7f3be5df1c17140d90d84b sig_cn_org=None source=14.1 
         <row>
          <entry><literal>04:05 AM</literal></entry>
          <entry>same as 04:05; AM does not affect value</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>04:05 AM</literal></entry>
          <entry>和04:05一样，AM并不影响值</entry>
         </row>
<!-- pgdoc-cn_end sig_en=b68c41930f7f3be5df1c17140d90d84b -->
<!-- pgdoc-cn_start sig_en=f3cf4f6ad7451a75eb9b80de8c59b623 sig_cn_org=None source=14.1 
         <row>
          <entry><literal>04:05 PM</literal></entry>
          <entry>same as 16:05; input hour must be &lt;= 12</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>04:05 PM</literal></entry>
          <entry>和16:05一样，输入的小时必须为 &lt;= 12</entry>
         </row>
<!-- pgdoc-cn_end sig_en=f3cf4f6ad7451a75eb9b80de8c59b623 -->
<!-- pgdoc-cn_start sig_en=3516f50c7c39ce9dd913a0e85ee8bd0f sig_cn_org=None source=14.1 
         <row>
          <entry><literal>04:05:06.789-8</literal></entry>
          <entry>ISO 8601, with time zone as UTC offset</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>04:05:06.789-8</literal></entry>
          <entry>ISO 8601,时区为UTC偏移</entry>
         </row>
<!-- pgdoc-cn_end sig_en=3516f50c7c39ce9dd913a0e85ee8bd0f -->
<!-- pgdoc-cn_start sig_en=ddfe50e437d38ab94268fb7447ca0554 sig_cn_org=None source=14.1 
         <row>
          <entry><literal>04:05:06-08:00</literal></entry>
          <entry>ISO 8601, with time zone as UTC offset</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>04:05:06-08:00</literal></entry>
          <entry>ISO 8601,时区为UTC偏移</entry>
         </row>
<!-- pgdoc-cn_end sig_en=ddfe50e437d38ab94268fb7447ca0554 -->
<!-- pgdoc-cn_start sig_en=1e532055f241ef7752f6064390048d44 sig_cn_org=None source=14.1 
         <row>
          <entry><literal>04:05-08:00</literal></entry>
          <entry>ISO 8601, with time zone as UTC offset</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>04:05-08:00</literal></entry>
          <entry>ISO 8601,时区为UTC偏移</entry>
         </row>
<!-- pgdoc-cn_end sig_en=1e532055f241ef7752f6064390048d44 -->
<!-- pgdoc-cn_start sig_en=ba16dd76d6143ba2b1b03bdfc22f39ea sig_cn_org=None source=14.1 
         <row>
          <entry><literal>040506-08</literal></entry>
          <entry>ISO 8601, with time zone as UTC offset</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>040506-08</literal></entry>
          <entry>ISO 8601,时区为UTC偏移</entry>
         </row>
<!-- pgdoc-cn_end sig_en=ba16dd76d6143ba2b1b03bdfc22f39ea -->
<!-- pgdoc-cn_start sig_en=de44b3ac2ae2a9ffc9a97233a270505d sig_cn_org=None source=14.1 
         <row>
          <entry><literal>040506+0730</literal></entry>
          <entry>ISO 8601, with fractional-hour time zone as UTC offset</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>040506+0730</literal></entry>
          <entry>ISO 8601, 以分数小时时区作为UTC偏移</entry>
         </row>
<!-- pgdoc-cn_end sig_en=de44b3ac2ae2a9ffc9a97233a270505d -->
<!-- pgdoc-cn_start sig_en=806b3933d86d35129f8074bd4a5fcf98 sig_cn_org=None source=14.1 
         <row>
          <entry><literal>040506+07:30:00</literal></entry>
          <entry>UTC offset specified to seconds (not allowed in ISO 8601)</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>040506+07:30:00</literal></entry>
          <entry>UTC偏移量指定为秒（ISO 8601中不允许）</entry>
         </row>
<!-- pgdoc-cn_end sig_en=806b3933d86d35129f8074bd4a5fcf98 -->
<!-- pgdoc-cn_start sig_en=944e162edb2469e614be89a410d7dd4b sig_cn_org=None source=14.1 
         <row>
          <entry><literal>04:05:06 PST</literal></entry>
          <entry>time zone specified by abbreviation</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>04:05:06 PST</literal></entry>
          <entry>缩写指定的时区</entry>
         </row>
<!-- pgdoc-cn_end sig_en=944e162edb2469e614be89a410d7dd4b -->
<!-- pgdoc-cn_start sig_en=f732360d42875da88aafaa10410ab4ba sig_cn_org=None source=14.1 
         <row>
          <entry><literal>2003-04-12 04:05:06 America/New_York</literal></entry>
          <entry>time zone specified by full name</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>2003-04-12 04:05:06 America/New_York</literal></entry>
          <entry>全名指定的时区</entry>
         </row>
<!-- pgdoc-cn_end sig_en=f732360d42875da88aafaa10410ab4ba -->
        </tbody>
       </tgroup>
      </table>

      <table tocentry="1" id="datatype-timezone-table">
<!-- pgdoc-cn_start sig_en=2f355cd9668bc801d26243d786989498 sig_cn_org=None source=14.1 
       <title>Time Zone Input</title>
________________________________________________________-->
       <title>时区输入</title>
<!-- pgdoc-cn_end sig_en=2f355cd9668bc801d26243d786989498 -->
       <tgroup cols="2">
        <thead>
<!-- pgdoc-cn_start sig_en=be428e485013ffc9394f7a44c759438b sig_cn_org=None source=14.1 
         <row>
          <entry>Example</entry>
          <entry>Description</entry>
         </row>
________________________________________________________-->
         <row>
          <entry>例子</entry>
          <entry>描述</entry>
         </row>
<!-- pgdoc-cn_end sig_en=be428e485013ffc9394f7a44c759438b -->
        </thead>
        <tbody>
<!-- pgdoc-cn_start sig_en=bf25c4a14a882fbdd122f4c7cdca8b53 sig_cn_org=None source=14.1 
         <row>
          <entry><literal>PST</literal></entry>
          <entry>Abbreviation (for Pacific Standard Time)</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>PST</literal></entry>
          <entry>缩写（太平洋标准时间）</entry>
         </row>
<!-- pgdoc-cn_end sig_en=bf25c4a14a882fbdd122f4c7cdca8b53 -->
<!-- pgdoc-cn_start sig_en=431727a9f404c37bef982f1a6a8bef2e sig_cn_org=None source=14.1 
         <row>
          <entry><literal>America/New_York</literal></entry>
          <entry>Full time zone name</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>America/New_York</literal></entry>
          <entry>完整时区名</entry>
         </row>
<!-- pgdoc-cn_end sig_en=431727a9f404c37bef982f1a6a8bef2e -->
<!-- pgdoc-cn_start sig_en=8257fdfa3e3149ec18de3c11363907c3 sig_cn_org=None source=14.1 
         <row>
          <entry><literal>PST8PDT</literal></entry>
          <entry>POSIX-style time zone specification</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>PST8PDT</literal></entry>
          <entry>POSIX风格的时区声明</entry>
         </row>
<!-- pgdoc-cn_end sig_en=8257fdfa3e3149ec18de3c11363907c3 -->
<!-- pgdoc-cn_start sig_en=f65715f1b4d3fb4b829ada9a0b6a0aec sig_cn_org=None source=14.1 
         <row>
          <entry><literal>-8:00:00</literal></entry>
          <entry>UTC offset for PST</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>-8:00:00</literal></entry>
          <entry>PST的UTC偏移</entry>
         </row>
<!-- pgdoc-cn_end sig_en=f65715f1b4d3fb4b829ada9a0b6a0aec -->
<!-- pgdoc-cn_start sig_en=aada53a15900dcdbaa31d7263ea39d4a sig_cn_org=None source=14.1 
         <row>
          <entry><literal>-8:00</literal></entry>
          <entry>UTC offset for PST (ISO 8601 extended format)</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>-8:00</literal></entry>
          <entry>PST的UTC偏移量（ISO 8601扩展格式）</entry>
         </row>
<!-- pgdoc-cn_end sig_en=aada53a15900dcdbaa31d7263ea39d4a -->
<!-- pgdoc-cn_start sig_en=1d563a0fb8b5d94dd5d5cf248b254df2 sig_cn_org=None source=14.1 
         <row>
          <entry><literal>-800</literal></entry>
          <entry>UTC offset for PST (ISO 8601 basic format)</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>-800</literal></entry>
          <entry>PST的UTC偏移量（ISO 8601基本格式）</entry>
         </row>
<!-- pgdoc-cn_end sig_en=1d563a0fb8b5d94dd5d5cf248b254df2 -->
<!-- pgdoc-cn_start sig_en=b9d31873a1918a1b0cdb24bc900c23c2 sig_cn_org=None source=14.1 
         <row>
          <entry><literal>-8</literal></entry>
          <entry>UTC offset for PST (ISO 8601 basic format)</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>-8</literal></entry>
          <entry>PST的UTC偏移量（ISO 8601基本格式）</entry>
         </row>
<!-- pgdoc-cn_end sig_en=b9d31873a1918a1b0cdb24bc900c23c2 -->
<!-- pgdoc-cn_start sig_en=4a7fc658d426d9e356af475649cc98b4 sig_cn_org=None source=14.1 
         <row>
          <entry><literal>zulu</literal></entry>
          <entry>Military abbreviation for UTC</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>zulu</literal></entry>
          <entry>UTC的军方缩写</entry>
         </row>
<!-- pgdoc-cn_end sig_en=4a7fc658d426d9e356af475649cc98b4 -->
<!-- pgdoc-cn_start sig_en=033f73a7f1b016cbc176eccd5dc2cd46 sig_cn_org=None source=14.1 
         <row>
          <entry><literal>z</literal></entry>
          <entry>Short form of <literal>zulu</literal> (also in ISO 8601)</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>z</literal></entry>
          <entry><literal>zulu</literal>的缩写形式（也在ISO 8601中）</entry>
         </row>
<!-- pgdoc-cn_end sig_en=033f73a7f1b016cbc176eccd5dc2cd46 -->
        </tbody>
       </tgroup>
      </table>

<!-- pgdoc-cn_start sig_en=79b7a4cfc1f3d7b2c52568a6b859dc1e sig_cn_org=None source=14.1 
     <para>
     Refer to <xref linkend="datatype-timezones"/> for more information on how
     to specify time zones.
    </para>
________________________________________________________-->
     <para>
     参考<xref linkend="datatype-timezones"/>可以了解如何指定时区。
    </para>
<!-- pgdoc-cn_end sig_en=79b7a4cfc1f3d7b2c52568a6b859dc1e -->
    </sect3>

    <sect3>
<!-- pgdoc-cn_start sig_en=d8c837aa3d212491bf1d12510554c2fc sig_cn_org=None source=14.1 
    <title>Time Stamps</title>
________________________________________________________-->
    <title>时间戳</title>
<!-- pgdoc-cn_end sig_en=d8c837aa3d212491bf1d12510554c2fc -->

<!-- pgdoc-cn_start sig_en=6c264d3b1d1bbef78081eeedbd5d6025 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>timestamp</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>timestamp</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=6c264d3b1d1bbef78081eeedbd5d6025 -->

<!-- pgdoc-cn_start sig_en=cf116666580b98a715bc4118053f4310 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>timestamp with time zone</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>timestamp with time zone</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=cf116666580b98a715bc4118053f4310 -->

<!-- pgdoc-cn_start sig_en=d63ff05b90c6039b6a4b87fa3054f115 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>timestamp without time zone</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>timestamp without time zone</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=d63ff05b90c6039b6a4b87fa3054f115 -->

<!-- pgdoc-cn_start sig_en=3899e74602327ad39630668ea3a4efcc sig_cn_org=None source=14.1 
     <para>
      Valid input for the time stamp types consists of the concatenation
      of a date and a time, followed by an optional time zone,
      followed by an optional <literal>AD</literal> or <literal>BC</literal>.
      (Alternatively, <literal>AD</literal>/<literal>BC</literal> can appear
      before the time zone, but this is not the preferred ordering.)
      Thus:

<programlisting>
1999-01-08 04:05:06
</programlisting>
      and:
<programlisting>
1999-01-08 04:05:06 -8:00
</programlisting>

      are valid values, which follow the <acronym>ISO</acronym> 8601
      standard.  In addition, the common format:
<programlisting>
January 8 04:05:06 1999 PST
</programlisting>
      is supported.
     </para>
________________________________________________________-->
     <para>
      时间戳类型的有效输入由一个日期和时间的串接组成，后面跟着一个可选的时区，一个可选的<literal>AD</literal>或者<literal>BC</literal>（另外，<literal>AD</literal>/<literal>BC</literal>可以出现在时区前面，但这个顺序并非最佳）。 因此：

<programlisting>
1999-01-08 04:05:06
</programlisting>
      和：
<programlisting>
1999-01-08 04:05:06 -8:00
</programlisting>

      都是有效的值，它遵循<acronym>ISO</acronym> 8601 标准。另外，使用广泛的格式：
<programlisting>
January 8 04:05:06 1999 PST
</programlisting>
      也被支持。
     </para>
<!-- pgdoc-cn_end sig_en=3899e74602327ad39630668ea3a4efcc -->

<!-- pgdoc-cn_start sig_en=f8960c9192b73175d87cb7a4b6de8b68 sig_cn_org=None source=14.1 
     <para>
      The <acronym>SQL</acronym> standard differentiates
      <type>timestamp without time zone</type>
      and <type>timestamp with time zone</type> literals by the presence of a
      <quote>+</quote> or <quote>-</quote> symbol and time zone offset after
      the time.  Hence, according to the standard,

<programlisting>
TIMESTAMP '2004-10-19 10:23:54'
</programlisting>

      is a <type>timestamp without time zone</type>, while

<programlisting>
TIMESTAMP '2004-10-19 10:23:54+02'
</programlisting>

      is a <type>timestamp with time zone</type>.
      <productname>PostgreSQL</productname> never examines the content of a
      literal string before determining its type, and therefore will treat
      both of the above as <type>timestamp without time zone</type>.  To
      ensure that a literal is treated as <type>timestamp with time
      zone</type>, give it the correct explicit type:

<programlisting>
TIMESTAMP WITH TIME ZONE '2004-10-19 10:23:54+02'
</programlisting>

      In a literal that has been determined to be <type>timestamp without time
      zone</type>, <productname>PostgreSQL</productname> will silently ignore
      any time zone indication.
      That is, the resulting value is derived from the date/time
      fields in the input value, and is not adjusted for time zone.
     </para>
________________________________________________________-->
     <para>
      <acronym>SQL</acronym>标准通过<quote>+</quote>或者<quote>-</quote>符号的存在以及时间后面的时区偏移来区分<type>timestamp without time zone</type>和<type>timestamp with time zone</type>文字。因此，根据标准，

<programlisting>
TIMESTAMP '2004-10-19 10:23:54'
</programlisting>

      是一个<type>timestamp without time zone</type>， 而

<programlisting>
TIMESTAMP '2004-10-19 10:23:54+02'
</programlisting>

      是一个<type>timestamp with time zone</type>。<productname>PostgreSQL</productname>从来不会在确定文字串的类型之前检查其内容，因此会把上面两个都看做是 <type>timestamp without time zone</type>。
      因此要保证把上面的文字当作<type>timestamp with time zone</type>看待， 就要给它正确的显式类型：

<programlisting>
TIMESTAMP WITH TIME ZONE '2004-10-19 10:23:54+02'
</programlisting>

      如果一个文字已被确定是<type>timestamp without time zone</type>，<productname>PostgreSQL</productname>将不声不响忽略任何其中指出的时区。 
      即，结果值是从输入值的日期/时间域衍生出来的，并且没有就时区进行调整。
     </para>
<!-- pgdoc-cn_end sig_en=f8960c9192b73175d87cb7a4b6de8b68 -->

<!-- pgdoc-cn_start sig_en=2ab94eaa6ff26e1ea45f15485dc2abe0 sig_cn_org=None source=14.1 
     <para>
      For <type>timestamp with time zone</type>, the internally stored
      value is always in UTC (Universal
      Coordinated Time, traditionally known as Greenwich Mean Time,
      <acronym>GMT</acronym>).  An input value that has an explicit
      time zone specified is converted to UTC using the appropriate offset
      for that time zone.  If no time zone is stated in the input string,
      then it is assumed to be in the time zone indicated by the system's
      <xref linkend="guc-timezone"/> parameter, and is converted to UTC using the
      offset for the <varname>timezone</varname> zone.
     </para>
________________________________________________________-->
     <para>
      对于<type>timestamp with time zone</type>，内部存储的值总是 UTC （全球统一时间，以前也叫格林威治时间<acronym>GMT</acronym>）。如果一个输入值有明确的时区声明， 那么它将用该时区合适的偏移量转换成 UTC。如果在输入串里没有时区声明， 那么它就被假设是在系统的<xref linkend="guc-timezone"/>参数里的那个时区，然后使用这个 <varname>timezone</varname>时区的偏移转换成 UTC。
     </para>
<!-- pgdoc-cn_end sig_en=2ab94eaa6ff26e1ea45f15485dc2abe0 -->

<!-- pgdoc-cn_start sig_en=4fd0b2089cfaf0f586fcbe6d28de5aba sig_cn_org=None source=14.1 
     <para>
      When a <type>timestamp with time
      zone</type> value is output, it is always converted from UTC to the
      current <varname>timezone</varname> zone, and displayed as local time in that
      zone.  To see the time in another time zone, either change
      <varname>timezone</varname> or use the <literal>AT TIME ZONE</literal> construct
      (see <xref linkend="functions-datetime-zoneconvert"/>).
     </para>
________________________________________________________-->
     <para>
      如果一个<type>timestamp with time zone</type>值被输出，那么它总是从 UTC 转换成当前的<varname>timezone</varname>时区，并且显示为该时区的本地时间。要看其它时区的时间，要么修改<varname>timezone</varname>，要么使用<literal>AT TIME ZONE</literal>构造（参阅<xref linkend="functions-datetime-zoneconvert"/>）。
     </para>
<!-- pgdoc-cn_end sig_en=4fd0b2089cfaf0f586fcbe6d28de5aba -->

<!-- pgdoc-cn_start sig_en=16b3bfd6b12c31c88788167e4793cdff sig_cn_org=None source=14.1 
     <para>
      Conversions between <type>timestamp without time zone</type> and
      <type>timestamp with time zone</type> normally assume that the
      <type>timestamp without time zone</type> value should be taken or given
      as <varname>timezone</varname> local time.  A different time zone can
      be specified for the conversion using <literal>AT TIME ZONE</literal>.
     </para>
________________________________________________________-->
     <para>
      在<type>timestamp without time zone</type>和<type>timestamp with time zone</type>之间的转换通常假设<type>timestamp without time zone</type>值应该以<varname>timezone</varname>本地时间的形式接受或者写出。为该转换指定一个不同的可以用<literal>AT TIME ZONE</literal>。
     </para>
<!-- pgdoc-cn_end sig_en=16b3bfd6b12c31c88788167e4793cdff -->
    </sect3>

    <sect3 id="datatype-datetime-special-values">
<!-- pgdoc-cn_start sig_en=504f527b6a708da956d44f344da90dc8 sig_cn_org=None source=14.1 
     <title>Special Values</title>
________________________________________________________-->
     <title>特殊值</title>
<!-- pgdoc-cn_end sig_en=504f527b6a708da956d44f344da90dc8 -->

<!-- pgdoc-cn_start sig_en=18e949b3df4e4a04c8085a0e23b5c47f sig_cn_org=None source=14.1 
     <indexterm>
      <primary>time</primary>
      <secondary>constants</secondary>
     </indexterm>
________________________________________________________-->
     <indexterm>
      <primary>time</primary>
      <secondary>constants</secondary>
     </indexterm>
<!-- pgdoc-cn_end sig_en=18e949b3df4e4a04c8085a0e23b5c47f -->

<!-- pgdoc-cn_start sig_en=ee1f1b0351b05cd972005babebce8c57 sig_cn_org=None source=14.1 
     <indexterm>
      <primary>date</primary>
      <secondary>constants</secondary>
     </indexterm>
________________________________________________________-->
     <indexterm>
      <primary>date</primary>
      <secondary>constants</secondary>
     </indexterm>
<!-- pgdoc-cn_end sig_en=ee1f1b0351b05cd972005babebce8c57 -->

<!-- pgdoc-cn_start sig_en=0db6aed5a85f57b19985af7d34d4de20 sig_cn_org=None source=14.1 
     <para>
      <productname>PostgreSQL</productname> supports several
      special date/time input values for convenience, as shown in <xref
      linkend="datatype-datetime-special-table"/>.  The values
      <literal>infinity</literal> and <literal>-infinity</literal>
      are specially represented inside the system and will be displayed
      unchanged; but the others are simply notational shorthands
      that will be converted to ordinary date/time values when read.
      (In particular, <literal>now</literal> and related strings are converted
      to a specific time value as soon as they are read.)
      All of these values need to be enclosed in single quotes when used
      as constants in SQL commands.
     </para>
________________________________________________________-->
     <para>
      为了方便，<productname>PostgreSQL</productname>支持一些特殊日期/时间输入值，如<xref linkend="datatype-datetime-special-table"/>所示。这些值中<literal>infinity</literal>和<literal>-infinity</literal>被在系统内部以特殊方式表示并且将被原封不动地显示。但是其他的仅仅只是概念上的速写，当被读到的时候会被转换为正常的日期/时间值（特殊地，<literal>now</literal>及相关串在被读到时立刻被转换到一个指定的时间值）。在作为常量在SQL命令中使用时，所有这些值需要被包括在单引号内。
     </para>
<!-- pgdoc-cn_end sig_en=0db6aed5a85f57b19985af7d34d4de20 -->

      <table id="datatype-datetime-special-table">
<!-- pgdoc-cn_start sig_en=dda78598eb91bbda5239c003f2e8832c sig_cn_org=None source=14.1 
       <title>Special Date/Time Inputs</title>
________________________________________________________-->
       <title>特殊日期/时间输入</title>
<!-- pgdoc-cn_end sig_en=dda78598eb91bbda5239c003f2e8832c -->
       <tgroup cols="3">
        <thead>
<!-- pgdoc-cn_start sig_en=af20c40198b625934a083bc41c65fd1c sig_cn_org=None source=14.1 
         <row>
          <entry>Input String</entry>
          <entry>Valid Types</entry>
          <entry>Description</entry>
         </row>
________________________________________________________-->
         <row>
          <entry>输入串</entry>
          <entry>合法类型</entry>
          <entry>描述</entry>
         </row>
<!-- pgdoc-cn_end sig_en=af20c40198b625934a083bc41c65fd1c -->
        </thead>
        <tbody>
<!-- pgdoc-cn_start sig_en=10182d8b58e7153560e4cf496438df6e sig_cn_org=None source=14.1 
         <row>
          <entry><literal>epoch</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>1970-01-01 00:00:00+00 (Unix system time zero)</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>epoch</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>1970-01-01 00:00:00+00（Unix系统时间0）</entry>
         </row>
<!-- pgdoc-cn_end sig_en=10182d8b58e7153560e4cf496438df6e -->
<!-- pgdoc-cn_start sig_en=1b5145b19f2ce3bdd70dd103da68ef0c sig_cn_org=None source=14.1 
         <row>
          <entry><literal>infinity</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>later than all other time stamps</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>infinity</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>比任何其他时间戳都晚</entry>
         </row>
<!-- pgdoc-cn_end sig_en=1b5145b19f2ce3bdd70dd103da68ef0c -->
<!-- pgdoc-cn_start sig_en=ff4dcd0c83e260c486a61d5a6035b2eb sig_cn_org=None source=14.1 
         <row>
          <entry><literal>-infinity</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>earlier than all other time stamps</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>-infinity</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>比任何其他时间戳都早</entry>
         </row>
<!-- pgdoc-cn_end sig_en=ff4dcd0c83e260c486a61d5a6035b2eb -->
<!-- pgdoc-cn_start sig_en=e61a61eaa1e05a5b2989221e61b76004 sig_cn_org=None source=14.1 
         <row>
          <entry><literal>now</literal></entry>
          <entry><type>date</type>, <type>time</type>, <type>timestamp</type></entry>
          <entry>current transaction's start time</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>now</literal></entry>
          <entry><type>date</type>, <type>time</type>, <type>timestamp</type></entry>
          <entry>当前事务的开始时间</entry>
         </row>
<!-- pgdoc-cn_end sig_en=e61a61eaa1e05a5b2989221e61b76004 -->
<!-- pgdoc-cn_start sig_en=df92841438cc49e28d262d0db2c5873c sig_cn_org=None source=14.1 
         <row>
          <entry><literal>today</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>midnight (<literal>00:00</literal>) today</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>today</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>今日午夜 (<literal>00:00</literal>) </entry>
         </row>
<!-- pgdoc-cn_end sig_en=df92841438cc49e28d262d0db2c5873c -->
<!-- pgdoc-cn_start sig_en=b6db5883506aff6a2b7727d596130fa7 sig_cn_org=None source=14.1 
         <row>
          <entry><literal>tomorrow</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>midnight (<literal>00:00</literal>) tomorrow</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>tomorrow</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>明日午夜 (<literal>00:00</literal>) </entry>
         </row>
<!-- pgdoc-cn_end sig_en=b6db5883506aff6a2b7727d596130fa7 -->
<!-- pgdoc-cn_start sig_en=bae9aa161e5fe141982a375ae5d97bcf sig_cn_org=None source=14.1 
         <row>
          <entry><literal>yesterday</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>midnight (<literal>00:00</literal>) yesterday</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>yesterday</literal></entry>
          <entry><type>date</type>, <type>timestamp</type></entry>
          <entry>昨日午夜 (<literal>00:00</literal>) </entry>
         </row>
<!-- pgdoc-cn_end sig_en=bae9aa161e5fe141982a375ae5d97bcf -->
<!-- pgdoc-cn_start sig_en=cf8061cfef39ef39a1bb76c4af7c71ce sig_cn_org=None source=14.1 
         <row>
          <entry><literal>allballs</literal></entry>
          <entry><type>time</type></entry>
          <entry>00:00:00.00 UTC</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>allballs</literal></entry>
          <entry><type>time</type></entry>
          <entry>00:00:00.00 UTC</entry>
         </row>
<!-- pgdoc-cn_end sig_en=cf8061cfef39ef39a1bb76c4af7c71ce -->
        </tbody>
       </tgroup>
      </table>

<!-- pgdoc-cn_start sig_en=9d444f7108f5cee13af1d30655291865 sig_cn_org=None source=14.1 
     <para>
      The following <acronym>SQL</acronym>-compatible functions can also
      be used to obtain the current time value for the corresponding data
      type:
      <literal>CURRENT_DATE</literal>, <literal>CURRENT_TIME</literal>,
      <literal>CURRENT_TIMESTAMP</literal>, <literal>LOCALTIME</literal>,
      <literal>LOCALTIMESTAMP</literal>.  (See <xref
      linkend="functions-datetime-current"/>.)  Note that these are
      SQL functions and are <emphasis>not</emphasis> recognized in data input strings.
     </para>
________________________________________________________-->
     <para>
      下列<acronym>SQL</acronym>-兼容的函数可以被用来为相应的数据类型获得当前时间值：
      <literal>CURRENT_DATE</literal>、<literal>CURRENT_TIME</literal>、
      <literal>CURRENT_TIMESTAMP</literal>、<literal>LOCALTIME</literal>、
      <literal>LOCALTIMESTAMP</literal>。（参见<xref linkend="functions-datetime-current"/>）。
      注意这些是SQL函数并且在数据输入串中<emphasis>不</emphasis>被识别。
     </para>
<!-- pgdoc-cn_end sig_en=9d444f7108f5cee13af1d30655291865 -->

     <caution>
<!-- pgdoc-cn_start sig_en=694804da96f18d5af0cdddeebe7832fa sig_cn_org=None source=14.1 
      <para>
       While the input strings <literal>now</literal>,
       <literal>today</literal>, <literal>tomorrow</literal>,
       and <literal>yesterday</literal> are fine to use in interactive SQL
       commands, they can have surprising behavior when the command is
       saved to be executed later, for example in prepared statements,
       views, and function definitions.  The string can be converted to a
       specific time value that continues to be used long after it becomes
       stale.  Use one of the SQL functions instead in such contexts.
       For example, <literal>CURRENT_DATE + 1</literal> is safer than
       <literal>'tomorrow'::date</literal>.
      </para>
________________________________________________________-->
      <para>
       虽然输入字符串 <literal>now</literal>、<literal>today</literal>、<literal>tomorrow</literal>和<literal>yesterday</literal>都可以在交互式 SQL 命令中使用，但当命令被保存以待稍后执行时，它们可能会有令人惊讶的行为，例如在准备的语句、视图和函数定义中。 
       字符串可以被转换为特定的时间值，该值在变得过时后长时间继续使用。 在这种上下文中使用某一种SQL函数代替。例如，
       <literal>CURRENT_DATE + 1</literal> 比 <literal>'tomorrow'::date</literal>更安全。
      </para>
<!-- pgdoc-cn_end sig_en=694804da96f18d5af0cdddeebe7832fa -->
     </caution>

    </sect3>
   </sect2>

   <sect2 id="datatype-datetime-output">
<!-- pgdoc-cn_start sig_en=4488ac19b0d0bc4d91c6530a3cad8b39 sig_cn_org=None source=14.1 
    <title>Date/Time Output</title>
________________________________________________________-->
    <title>日期/时间输出</title>
<!-- pgdoc-cn_end sig_en=4488ac19b0d0bc4d91c6530a3cad8b39 -->

<!-- pgdoc-cn_start sig_en=757d6dccb0fceb2dcb19d5218406ac8f sig_cn_org=None source=14.1 
    <indexterm>
     <primary>date</primary>
     <secondary>output format</secondary>
     <seealso>formatting</seealso>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>date</primary>
     <secondary>输出格式</secondary>
     <seealso>formatting</seealso>
    </indexterm>
<!-- pgdoc-cn_end sig_en=757d6dccb0fceb2dcb19d5218406ac8f -->

<!-- pgdoc-cn_start sig_en=5797ec2ededea49bab7c3a3ee1e475f7 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>time</primary>
     <secondary>output format</secondary>
     <seealso>formatting</seealso>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>time</primary>
     <secondary>输出格式</secondary>
     <seealso>formatting</seealso>
    </indexterm>
<!-- pgdoc-cn_end sig_en=5797ec2ededea49bab7c3a3ee1e475f7 -->

<!-- pgdoc-cn_start sig_en=942babe48bc5196ebb0b309cc5ab27ae sig_cn_org=None source=14.1 
    <para>
     The output format of the date/time types can be set to one of the four
     styles ISO 8601,
     <acronym>SQL</acronym> (Ingres), traditional <productname>POSTGRES</productname>
     (Unix <application>date</application> format), or
     German.  The default
     is the <acronym>ISO</acronym> format.  (The
     <acronym>SQL</acronym> standard requires the use of the ISO 8601
     format.  The name of the <quote>SQL</quote> output format is a
     historical accident.)  <xref
     linkend="datatype-datetime-output-table"/> shows examples of each
     output style.  The output of the <type>date</type> and
     <type>time</type> types is generally only the date or time part
     in accordance with the given examples.  However, the
     <productname>POSTGRES</productname> style outputs date-only values in
     <acronym>ISO</acronym> format.
    </para>
________________________________________________________-->
    <para>
     时间/日期类型的输出格式可以设成四种风格之一： ISO 8601、<acronym>SQL</acronym>（Ingres）、传统的<productname>POSTGRES</productname>（Unix的<application>date</application>格式）或 German 。缺省是<acronym>ISO</acronym>格式（<acronym>ISO</acronym>标准要求使用 ISO 8601 格式。<acronym>ISO</acronym>输出格式的名字是历史偶然）。<xref linkend="datatype-datetime-output-table"/>显示了每种输出风格的例子。<type>date</type>和<type>time</type>类型的 输出通常只有日期或时间部分和例子中一致。不过，<productname>POSTGRES</productname>风格输出的是<acronym>ISO</acronym>格式的只有日期的值。
    </para>
<!-- pgdoc-cn_end sig_en=942babe48bc5196ebb0b309cc5ab27ae -->

     <table id="datatype-datetime-output-table">
<!-- pgdoc-cn_start sig_en=9e99b542c6920fffb59b3a7b9ef3a6b2 sig_cn_org=None source=14.1 
      <title>Date/Time Output Styles</title>
________________________________________________________-->
      <title>日期/时间输出风格</title>
<!-- pgdoc-cn_end sig_en=9e99b542c6920fffb59b3a7b9ef3a6b2 -->
      <tgroup cols="3">
       <colspec colname="col1" colwidth="1*"/>
       <colspec colname="col2" colwidth="1*"/>
       <colspec colname="col3" colwidth="2*"/>
       <thead>
<!-- pgdoc-cn_start sig_en=8cdb6b1635b51f8766ece92709060664 sig_cn_org=None source=14.1 
        <row>
         <entry>Style Specification</entry>
         <entry>Description</entry>
         <entry>Example</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>风格声明</entry>
         <entry>描述</entry>
         <entry>例子</entry>
        </row>
<!-- pgdoc-cn_end sig_en=8cdb6b1635b51f8766ece92709060664 -->
       </thead>
       <tbody>
<!-- pgdoc-cn_start sig_en=cafafacdb752c887271487447562cb53 sig_cn_org=None source=14.1 
        <row>
         <entry><literal>ISO</literal></entry>
         <entry>ISO 8601, SQL standard</entry>
         <entry><literal>1997-12-17 07:37:16-08</literal></entry>
        </row>
________________________________________________________-->
        <row>
         <entry><literal>ISO</literal></entry>
         <entry>ISO 8601, SQL标准</entry>
         <entry><literal>1997-12-17 07:37:16-08</literal></entry>
        </row>
<!-- pgdoc-cn_end sig_en=cafafacdb752c887271487447562cb53 -->
<!-- pgdoc-cn_start sig_en=b94d22a8a3147787fa1b5f8462b6ee39 sig_cn_org=None source=14.1 
        <row>
         <entry><literal>SQL</literal></entry>
         <entry>traditional style</entry>
         <entry><literal>12/17/1997 07:37:16.00 PST</literal></entry>
        </row>
________________________________________________________-->
        <row>
         <entry><literal>SQL</literal></entry>
         <entry>传统风格</entry>
         <entry><literal>12/17/1997 07:37:16.00 PST</literal></entry>
        </row>
<!-- pgdoc-cn_end sig_en=b94d22a8a3147787fa1b5f8462b6ee39 -->
<!-- pgdoc-cn_start sig_en=e4bfcc304cbc4fc1702309ef7566ca8c sig_cn_org=None source=14.1 
        <row>
         <entry><literal>Postgres</literal></entry>
         <entry>original style</entry>
         <entry><literal>Wed Dec 17 07:37:16 1997 PST</literal></entry>
        </row>
________________________________________________________-->
        <row>
         <entry><literal>Postgres</literal></entry>
         <entry>原始风格</entry>
         <entry><literal>Wed Dec 17 07:37:16 1997 PST</literal></entry>
        </row>
<!-- pgdoc-cn_end sig_en=e4bfcc304cbc4fc1702309ef7566ca8c -->
<!-- pgdoc-cn_start sig_en=44279c9ac4597b05b43248f7675cfd7b sig_cn_org=None source=14.1 
        <row>
         <entry><literal>German</literal></entry>
         <entry>regional style</entry>
         <entry><literal>17.12.1997 07:37:16.00 PST</literal></entry>
        </row>
________________________________________________________-->
        <row>
         <entry><literal>German</literal></entry>
         <entry>地区风格</entry>
         <entry><literal>17.12.1997 07:37:16.00 PST</literal></entry>
        </row>
<!-- pgdoc-cn_end sig_en=44279c9ac4597b05b43248f7675cfd7b -->
       </tbody>
      </tgroup>
     </table>

    <note>
<!-- pgdoc-cn_start sig_en=2b962532d8690197f963526b4078ddd4 sig_cn_org=1f4b73b51d976b91443a6407179a2aff source=15.7 
     <para>
      ISO 8601 specifies the use of uppercase letter <literal>T</literal> to separate
      the date and time.  <productname>PostgreSQL</productname> accepts that format on
      input, but on output it uses a space rather than <literal>T</literal>, as shown
      above.  This is for readability and for consistency with
      <ulink url="https://datatracker.ietf.org/doc/html/rfc3339">RFC 3339</ulink> as
      well as some other database systems.
     </para>
________________________________________________________-->
     <para>
      ISO 8601规定使用大写字母<literal>T</literal>来分隔日期和时间。
      <productname>PostgreSQL</productname>在输入时接受该格式，但在输出时使用空格而不是<literal>T</literal>，如上所示。
      这是为了可读性和与<ulink url="https://datatracker.ietf.org/doc/html/rfc3339">RFC 3339</ulink>以及其他一些数据库系统的一致性。
     </para>
<!-- pgdoc-cn_end sig_en=2b962532d8690197f963526b4078ddd4 -->
    </note>

<!-- pgdoc-cn_start sig_en=b8763a09564acd232a3f5e7808d4e8ab sig_cn_org=None source=14.1 
    <para>
     In the <acronym>SQL</acronym> and POSTGRES styles, day appears before
     month if DMY field ordering has been specified, otherwise month appears
     before day.
     (See <xref linkend="datatype-datetime-input"/>
     for how this setting also affects interpretation of input values.)
     <xref linkend="datatype-datetime-output2-table"/> shows examples.
    </para>
________________________________________________________-->
    <para>
     <acronym>SQL</acronym>和POSTGRES风格中，如果DMY域顺序被指定，“日”将出现在“月”之前，否则“月”出现在“日”之前（有关该设置如何影响输入值的解释，请参考<xref linkend="datatype-datetime-input"/>）。<xref linkend="datatype-datetime-output2-table"/>给出了例子。
    </para>
<!-- pgdoc-cn_end sig_en=b8763a09564acd232a3f5e7808d4e8ab -->

     <table id="datatype-datetime-output2-table">
<!-- pgdoc-cn_start sig_en=ee05816287fdfaf606e0e4a1ac4bb942 sig_cn_org=None source=14.1 
      <title>Date Order Conventions</title>
________________________________________________________-->
      <title>日期顺序习惯</title>
<!-- pgdoc-cn_end sig_en=ee05816287fdfaf606e0e4a1ac4bb942 -->
      <tgroup cols="3">
       <colspec colname="col1" colwidth="1*"/>
       <colspec colname="col2" colwidth="1*"/>
       <colspec colname="col3" colwidth="2*"/>
       <thead>
<!-- pgdoc-cn_start sig_en=90cb317d03e7db7fcaedd689801eb7b7 sig_cn_org=None source=14.1 
        <row>
         <entry><varname>datestyle</varname> Setting</entry>
         <entry>Input Ordering</entry>
         <entry>Example Output</entry>
        </row>
________________________________________________________-->
        <row>
         <entry><varname>datestyle</varname>设置</entry>
         <entry>输入顺序</entry>
         <entry>例子输出</entry>
        </row>
<!-- pgdoc-cn_end sig_en=90cb317d03e7db7fcaedd689801eb7b7 -->
       </thead>
       <tbody>
<!-- pgdoc-cn_start sig_en=72e996bdb15d7724d09e3603e45026b5 sig_cn_org=None source=14.1 
        <row>
         <entry><literal>SQL, DMY</literal></entry>
         <entry><replaceable>day</replaceable>/<replaceable>month</replaceable>/<replaceable>year</replaceable></entry>
         <entry><literal>17/12/1997 15:37:16.00 CET</literal></entry>
        </row>
________________________________________________________-->
        <row>
         <entry><literal>SQL, DMY</literal></entry>
         <entry><replaceable>日</replaceable>/<replaceable>月</replaceable>/<replaceable>年</replaceable></entry>
         <entry><literal>17/12/1997 15:37:16.00 CET</literal></entry>
        </row>
<!-- pgdoc-cn_end sig_en=72e996bdb15d7724d09e3603e45026b5 -->
<!-- pgdoc-cn_start sig_en=b2bbef0f268e84c3eca187cb6974274d sig_cn_org=None source=14.1 
        <row>
         <entry><literal>SQL, MDY</literal></entry>
         <entry><replaceable>month</replaceable>/<replaceable>day</replaceable>/<replaceable>year</replaceable></entry>
         <entry><literal>12/17/1997 07:37:16.00 PST</literal></entry>
        </row>
________________________________________________________-->
        <row>
         <entry><literal>SQL, MDY</literal></entry>
         <entry><replaceable>月</replaceable>/<replaceable>日</replaceable>/<replaceable>年</replaceable></entry>
         <entry><literal>12/17/1997 07:37:16.00 PST</literal></entry>
        </row>
<!-- pgdoc-cn_end sig_en=b2bbef0f268e84c3eca187cb6974274d -->
<!-- pgdoc-cn_start sig_en=77d4115764d46b20a7ee07c4932cbf6d sig_cn_org=None source=14.1 
        <row>
         <entry><literal>Postgres, DMY</literal></entry>
         <entry><replaceable>day</replaceable>/<replaceable>month</replaceable>/<replaceable>year</replaceable></entry>
         <entry><literal>Wed 17 Dec 07:37:16 1997 PST</literal></entry>
        </row>
________________________________________________________-->
        <row>
         <entry><literal>Postgres, DMY</literal></entry>
         <entry><replaceable>日</replaceable>/<replaceable>月</replaceable>/<replaceable>年</replaceable></entry>
         <entry><literal>Wed 17 Dec 07:37:16 1997 PST</literal></entry>
        </row>
<!-- pgdoc-cn_end sig_en=77d4115764d46b20a7ee07c4932cbf6d -->
       </tbody>
      </tgroup>
     </table>

<!-- pgdoc-cn_start sig_en=8bbe1c1c6b04291518e7121a2e5b64bb sig_cn_org=None source=14.1 
    <para>
     In the <acronym>ISO</acronym> style, the time zone is always shown as
     a signed numeric offset from UTC, with positive sign used for zones
     east of Greenwich.  The offset will be shown
     as <replaceable>hh</replaceable> (hours only) if it is an integral
     number of hours, else
     as <replaceable>hh</replaceable>:<replaceable>mm</replaceable> if it
     is an integral number of minutes, else as
     <replaceable>hh</replaceable>:<replaceable>mm</replaceable>:<replaceable>ss</replaceable>.
     (The third case is not possible with any modern time zone standard,
     but it can appear when working with timestamps that predate the
     adoption of standardized time zones.)
     In the other date styles, the time zone is shown as an alphabetic
     abbreviation if one is in common use in the current zone.  Otherwise
     it appears as a signed numeric offset in ISO 8601 basic format
     (<replaceable>hh</replaceable> or <replaceable>hhmm</replaceable>).
    </para>
________________________________________________________-->
    <para>
     在<acronym>ISO</acronym>样式中，时区始终显示为与UTC之间的有符号数偏移，正号用于格林威治以东的区域。如果偏移量为整小时数，则偏移量将显示为 <replaceable>hh</replaceable>（仅小时），如果偏移量是整分钟数，则为<replaceable>hh</replaceable>:<replaceable>mm</replaceable> ，否则为<replaceable>hh</replaceable>:<replaceable>mm</replaceable>:<replaceable>ss</replaceable>。（第三种情况在任何现代时区标准中都不可能出现，但如果是时区标准启用之前的时间戳则可能会出现。）在其它日期样式中，如果时区在当前时区中常用，则时区显示为字母缩写。否则，它将显示为ISO 8601基本格式的带符号数字偏移量（<replaceable>hh</replaceable>或<replaceable>hhmm</replaceable>）。
    </para>
<!-- pgdoc-cn_end sig_en=8bbe1c1c6b04291518e7121a2e5b64bb -->

<!-- pgdoc-cn_start sig_en=5fa777e5ca117d923506fa18f6b1aeea sig_cn_org=None source=14.1 
    <para>
     The date/time style can be selected by the user using the
     <command>SET datestyle</command> command, the <xref
     linkend="guc-datestyle"/> parameter in the
     <filename>postgresql.conf</filename> configuration file, or the
     <envar>PGDATESTYLE</envar> environment variable on the server or
     client.
    </para>
________________________________________________________-->
    <para>
     日期/时间风格可以由用户使用<command>SET datestyle</command>命令选取，在<filename>postgresql.conf</filename>配置文件里的参数<xref linkend="guc-datestyle"/>设置或者在服务器或客户端的<envar>PGDATESTYLE</envar>环境变量里设置。
    </para>
<!-- pgdoc-cn_end sig_en=5fa777e5ca117d923506fa18f6b1aeea -->

<!-- pgdoc-cn_start sig_en=d17ac621ac750ae6e190dfd1980dedb5 sig_cn_org=None source=14.1 
    <para>
     The formatting function <function>to_char</function>
     (see <xref linkend="functions-formatting"/>) is also available as
     a more flexible way to format date/time output.
    </para>
________________________________________________________-->
    <para>
     格式化函数<function>to_char</function>（见<xref linkend="functions-formatting"/>）也可以作为一个更灵活的方式来格式化日期/时间输出。
    </para>
<!-- pgdoc-cn_end sig_en=d17ac621ac750ae6e190dfd1980dedb5 -->
   </sect2>

   <sect2 id="datatype-timezones">
<!-- pgdoc-cn_start sig_en=d5fd05361eaa714c14f981af0e8f2f6b sig_cn_org=None source=14.1 
    <title>Time Zones</title>
________________________________________________________-->
    <title> 时区</title>
<!-- pgdoc-cn_end sig_en=d5fd05361eaa714c14f981af0e8f2f6b -->

<!-- pgdoc-cn_start sig_en=35080220e895518deaa5294cdb8881c6 sig_cn_org=None source=14.1 
    <indexterm zone="datatype-timezones">
     <primary>time zone</primary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="datatype-timezones">
     <primary>time zone</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=35080220e895518deaa5294cdb8881c6 -->

<!-- pgdoc-cn_start sig_en=4c7d52ca5807c16e1d01675b4008dce2 sig_cn_org=None source=14.1 
   <para>
    Time zones, and time-zone conventions, are influenced by
    political decisions, not just earth geometry. Time zones around the
    world became somewhat standardized during the 1900s,
    but continue to be prone to arbitrary changes, particularly with
    respect to daylight-savings rules.
    <productname>PostgreSQL</productname> uses the widely-used
    IANA (Olson) time zone database for information about
    historical time zone rules.  For times in the future, the assumption
    is that the latest known rules for a given time zone will
    continue to be observed indefinitely far into the future.
   </para>
________________________________________________________-->
   <para>
    时区和时区习惯不仅仅受地球几何形状的影响，还受到政治决定的影响。 到了19世纪，全球的时区变得稍微标准化了些，但是还是易于遭受随意的修改，部分是因为夏时制规
    则。<productname>PostgreSQL</productname>使用广泛使用的 IANA (Olson) 时区数据库来得到有关历史时区规则的信息。对于未来的时间，我们假设关于一个给定时区的最新已知
    规则将会一直持续到无穷远的未来。
   </para>
<!-- pgdoc-cn_end sig_en=4c7d52ca5807c16e1d01675b4008dce2 -->

<!-- pgdoc-cn_start sig_en=877de4cea48461d998115b03c9bc5204 sig_cn_org=None source=14.1 
    <para>
     <productname>PostgreSQL</productname> endeavors to be compatible with
     the <acronym>SQL</acronym> standard definitions for typical usage.
     However, the <acronym>SQL</acronym> standard has an odd mix of date and
     time types and capabilities. Two obvious problems are:

     <itemizedlist>
      <listitem>
       <para>
        Although the <type>date</type> type
        cannot have an associated time zone, the
        <type>time</type> type can.
        Time zones in the real world have little meaning unless
        associated with a date as well as a time,
        since the offset can vary through the year with daylight-saving
        time boundaries.
       </para>
      </listitem>

      <listitem>
       <para>
        The default time zone is specified as a constant numeric offset
        from <acronym>UTC</acronym>. It is therefore impossible to adapt to
        daylight-saving time when doing date/time arithmetic across
        <acronym>DST</acronym> boundaries.
       </para>
      </listitem>

     </itemizedlist>
    </para>
________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>努力在典型使用中与<acronym>SQL</acronym>标准的定义相兼容。但<acronym>SQL</acronym>标准在日期和时间类型和功能上有一些奇怪的混淆。两个显而易见的问题是：

     <itemizedlist>
      <listitem>
       <para>
        尽管<type>date</type>类型与时区没有联系，而<type>time</type>类型却可以有。 然而，现实世界的时区只有在与时间和日期都关联时才有意义， 因为偏移（时差）可能因为实行类似夏时制这样的制度而在一年里有所变化。
       </para>
      </listitem>

      <listitem>
       <para>
        缺省的时区会指定一个到<acronym>UTC</acronym>的数字常量偏移（时差）。因此，当跨<acronym>DST</acronym>边界做日期/时间算术时， 我们根本不可能适应于夏时制时间。
       </para>
      </listitem>

     </itemizedlist>
    </para>
<!-- pgdoc-cn_end sig_en=877de4cea48461d998115b03c9bc5204 -->

<!-- pgdoc-cn_start sig_en=57f6b3bfc8b95b72716340a28876d638 sig_cn_org=None source=14.1 
    <para>
     To address these difficulties, we recommend using date/time types
     that contain both date and time when using time zones. We
     do <emphasis>not</emphasis> recommend using the type <type>time with
     time zone</type> (though it is supported by
     <productname>PostgreSQL</productname> for legacy applications and
     for compliance with the <acronym>SQL</acronym> standard).
     <productname>PostgreSQL</productname> assumes
     your local time zone for any type containing only date or time.
    </para>
________________________________________________________-->
    <para>
     为了克服这些困难，我们建议在使用时区的时候，使用那些同时包含日期和时间的日期/时间类型。我们<emphasis>不</emphasis>建议使用类型 <type>time with time zone</type> （尽管<productname>PostgreSQL</productname>出于遗留应用以及与<acronym>SQL</acronym>标准兼容性的考虑支持这个类型）。 <productname>PostgreSQL</productname>假设你用于任何类型的本地时区都只包含日期或时间。
    </para>
<!-- pgdoc-cn_end sig_en=57f6b3bfc8b95b72716340a28876d638 -->

<!-- pgdoc-cn_start sig_en=9a57ddf59813758eb8caf2c2eec573c6 sig_cn_org=None source=14.1 
    <para>
     All timezone-aware dates and times are stored internally in
     <acronym>UTC</acronym>.  They are converted to local time
     in the zone specified by the <xref linkend="guc-timezone"/> configuration
     parameter before being displayed to the client.
    </para>
________________________________________________________-->
    <para>
     在系统内部，所有时区相关的日期和时间都用<acronym>UTC</acronym>存储。它们在被显示给客户端之前会被转换成由<xref linkend="guc-timezone"/>配置参数指定的本地时间。
    </para>
<!-- pgdoc-cn_end sig_en=9a57ddf59813758eb8caf2c2eec573c6 -->

<!-- pgdoc-cn_start sig_en=25e859d24f5ad374628ecdbb06cc6f28 sig_cn_org=None source=14.1 
    <para>
     <productname>PostgreSQL</productname> allows you to specify time zones in
     three different forms:
     <itemizedlist>
      <listitem>
       <para>
        A full time zone name, for example <literal>America/New_York</literal>.
        The recognized time zone names are listed in the
        <literal>pg_timezone_names</literal> view (see <xref
        linkend="view-pg-timezone-names"/>).
        <productname>PostgreSQL</productname> uses the widely-used IANA
        time zone data for this purpose, so the same time zone
        names are also recognized by other software.
       </para>
      </listitem>
      <listitem>
       <para>
        A time zone abbreviation, for example <literal>PST</literal>.  Such a
        specification merely defines a particular offset from UTC, in
        contrast to full time zone names which can imply a set of daylight
        savings transition rules as well.  The recognized abbreviations
        are listed in the <literal>pg_timezone_abbrevs</literal> view (see <xref
        linkend="view-pg-timezone-abbrevs"/>).  You cannot set the
        configuration parameters <xref linkend="guc-timezone"/> or
        <xref linkend="guc-log-timezone"/> to a time
        zone abbreviation, but you can use abbreviations in
        date/time input values and with the <literal>AT TIME ZONE</literal>
        operator.
       </para>
      </listitem>
      <listitem>
       <para>
        In addition to the timezone names and abbreviations,
        <productname>PostgreSQL</productname> will accept POSIX-style time zone
        specifications, as described in
        <xref linkend="datetime-posix-timezone-specs"/>.  This option is not
        normally preferable to using a named time zone, but it may be
        necessary if no suitable IANA time zone entry is available.
       </para>
      </listitem>
     </itemizedlist>

     In short, this is the difference between abbreviations
     and full names: abbreviations represent a specific offset from UTC,
     whereas many of the full names imply a local daylight-savings time
     rule, and so have two possible UTC offsets.  As an example,
     <literal>2014-06-04 12:00 America/New_York</literal> represents noon local
     time in New York, which for this particular date was Eastern Daylight
     Time (UTC-4).  So <literal>2014-06-04 12:00 EDT</literal> specifies that
     same time instant.  But <literal>2014-06-04 12:00 EST</literal> specifies
     noon Eastern Standard Time (UTC-5), regardless of whether daylight
     savings was nominally in effect on that date.
    </para>
________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>允许你使用三种不同形式指定时区：
     <itemizedlist>
      <listitem>
       <para>
        一个完整的时区名字，例如<literal>America/New_York</literal>。能被识别的时区名字被列在<literal>pg_timezone_names</literal>视图中（参见<xref linkend="view-pg-timezone-names"/>）。<productname>PostgreSQL</productname>用广泛使用的 IANA 时区数据来实现该目的，因此相同的时区名字也可以在其他软件中被识别。
       </para>
      </listitem>
      <listitem>
       <para>
        一个时区缩写，例如<literal>PST</literal>。这样一种声明仅仅定义了到UTC的一个特定偏移，而不像完整时区名那样指出整套夏令时转换规则。
        能被识别的缩写被列在<literal>pg_timezone_abbrevs</literal>视图中（参见<xref linkend="view-pg-timezone-abbrevs"/>）。
        你不能将配置参数<xref linkend="guc-timezone"/>或<xref linkend="guc-log-timezone"/>设置成一个时区缩写，但是你可以在日期/时间输入值和<literal>AT TIME ZONE</literal>操作符中使用时区缩写。
       </para>
      </listitem>
      <listitem>
       <para>
        除了时区名和缩写，<productname>PostgreSQL</productname>将接受POSIX-风格的时区规范，如同<xref linkend="datetime-posix-timezone-specs"/>所描述的。
        这个选项通常不优先用于指定时区，但是，如果没有合适的IANA时区条目，这可能是必要的。
       </para>
      </listitem>
     </itemizedlist>

     简而言之，在缩写和全称之间是有不同的：缩写表示从UTC开始的一个特定偏移量，
     而很多全称表示一个本地夏令时规则并且因此具有两种可能的UTC偏移量。例如，
     <literal>2014-06-04 12:00 America/New_York</literal>表示纽约本地时间的中午，
     这个特殊的日期是东部夏令时间（UTC-4）。因此<literal>2014-06-04 12:00 EDT</literal>
     指定的是同一个时间点。但是<literal>2014-06-04 12:00 EST</literal>指定东部标准时间的
     中午（UTC-5），不管在那个日期夏令时是否生效。
    </para>
<!-- pgdoc-cn_end sig_en=25e859d24f5ad374628ecdbb06cc6f28 -->

<!-- pgdoc-cn_start sig_en=86614841c151a769fd62c5027b0d2cc5 sig_cn_org=None source=14.1 
    <para>
     To complicate matters, some jurisdictions have used the same timezone
     abbreviation to mean different UTC offsets at different times; for
     example, in Moscow <literal>MSK</literal> has meant UTC+3 in some years and
     UTC+4 in others.  <application>PostgreSQL</application> interprets such
     abbreviations according to whatever they meant (or had most recently
     meant) on the specified date; but, as with the <literal>EST</literal> example
     above, this is not necessarily the same as local civil time on that date.
    </para>
________________________________________________________-->
    <para>
     更要命的是，某些行政区已经使用相同的时区缩写在不同的时间表示不同的 UTC 偏移量。例如，
     在莫斯科<literal>MSK</literal>在某些年份表示 UTC+3 而在另一些年份表示 UTC+4。 <application>PostgreSQL</application> 会根据在指定的日期它们到底表示什么（或者最近表示什么）
     来解释这种缩写。但是，正如上面的<literal>EST</literal>例子所示，这并不是必须和那一天的本地
     标准时间相同。
    </para>
<!-- pgdoc-cn_end sig_en=86614841c151a769fd62c5027b0d2cc5 -->

<!-- pgdoc-cn_start sig_en=fd2a3295d97f14f5f534d010912d2fd4 sig_cn_org=None source=14.1 
    <para>
     In all cases, timezone names and abbreviations are recognized
     case-insensitively.  (This is a change from <productname>PostgreSQL</productname>
     versions prior to 8.2, which were case-sensitive in some contexts but
     not others.)
    </para>
________________________________________________________-->
    <para>
     在所有情况下，时区名及其缩写都是大小写不敏感的（这是对<productname>PostgreSQL</productname> 8.2之前版本的一个修改，在这些版本中某些环境下时区名是大小写敏感的而在另外一些环境中却是大小写不敏感的）。
    </para>
<!-- pgdoc-cn_end sig_en=fd2a3295d97f14f5f534d010912d2fd4 -->

<!-- pgdoc-cn_start sig_en=90347294e07d7f10c434e5e56ee1e6b8 sig_cn_org=None source=14.1 
    <para>
     Neither timezone names nor abbreviations are hard-wired into the server;
     they are obtained from configuration files stored under
     <filename>.../share/timezone/</filename> and <filename>.../share/timezonesets/</filename>
     of the installation directory
     (see <xref linkend="datetime-config-files"/>).
    </para>
________________________________________________________-->
    <para>
     时区名和缩写都不是硬写在服务器中的，它们是从存储在安装目录下的<filename>.../share/timezone/</filename>和<filename>.../share/timezonesets/</filename>子目录中获取的（参见<xref linkend="datetime-config-files"/>）。
    </para>
<!-- pgdoc-cn_end sig_en=90347294e07d7f10c434e5e56ee1e6b8 -->

<!-- pgdoc-cn_start sig_en=0e587e11f4dc2d24c3171972e50ad9b4 sig_cn_org=None source=14.1 
    <para>
     The <xref linkend="guc-timezone"/> configuration parameter can
     be set in the file <filename>postgresql.conf</filename>, or in any of the
     other standard ways described in <xref linkend="runtime-config"/>.
     There are also some special ways to set it:

     <itemizedlist>
      <listitem>
       <para>
        The <acronym>SQL</acronym> command <command>SET TIME ZONE</command>
        sets the time zone for the session.  This is an alternative spelling
        of <command>SET TIMEZONE TO</command> with a more SQL-spec-compatible syntax.
       </para>
      </listitem>

      <listitem>
       <para>
        The <envar>PGTZ</envar> environment variable is used by
        <application>libpq</application> clients
        to send a <command>SET TIME ZONE</command>
        command to the server upon connection.
       </para>
      </listitem>
     </itemizedlist>
    </para>
________________________________________________________-->
    <para>
     <xref linkend="guc-timezone"/>配置参数可以在文件<filename>postgresql.conf</filename>中被设置，或者使用<xref linkend="runtime-config"/>中描述的任何一种标准方法设置。同时也有一些特殊的方法来设置它：

     <itemizedlist>
      <listitem>
       <para>
        <acronym>SQL</acronym>命令<command>SET TIME ZONE</command>为会话设置时区。它是<command>SET TIMEZONE TO</command>的另一种拼写，它更加符合SQL的语法。
       </para>
      </listitem>

      <listitem>
       <para>
        <application>libpq</application>客户端使用<envar>PGTZ</envar>环境变量来通过连接发送一个<command>SET TIME ZONE</command>命令给服务器。
       </para>
      </listitem>
     </itemizedlist>
    </para>
<!-- pgdoc-cn_end sig_en=0e587e11f4dc2d24c3171972e50ad9b4 -->
   </sect2>

   <sect2 id="datatype-interval-input">
<!-- pgdoc-cn_start sig_en=4a7e62324b6ab55ef6a100e4d25844f9 sig_cn_org=None source=14.1 
    <title>Interval Input</title>
________________________________________________________-->
    <title>间隔输入</title>
<!-- pgdoc-cn_end sig_en=4a7e62324b6ab55ef6a100e4d25844f9 -->

<!-- pgdoc-cn_start sig_en=675dcfc7279f8253126c2483ad599be4 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>interval</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>interval</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=675dcfc7279f8253126c2483ad599be4 -->

<!-- pgdoc-cn_start sig_en=e1a107fda907fcfd5d3709091ca0fa0c sig_cn_org=None source=14.1 
     <para>
      <type>interval</type> values can be written using the following
      verbose syntax:

<synopsis>
<optional>@</optional> <replaceable>quantity</replaceable> <replaceable>unit</replaceable> <optional><replaceable>quantity</replaceable> <replaceable>unit</replaceable>...</optional> <optional><replaceable>direction</replaceable></optional>
</synopsis>

     where <replaceable>quantity</replaceable> is a number (possibly signed);
     <replaceable>unit</replaceable> is <literal>microsecond</literal>,
     <literal>millisecond</literal>, <literal>second</literal>,
     <literal>minute</literal>, <literal>hour</literal>, <literal>day</literal>,
     <literal>week</literal>, <literal>month</literal>, <literal>year</literal>,
     <literal>decade</literal>, <literal>century</literal>, <literal>millennium</literal>,
     or abbreviations or plurals of these units;
     <replaceable>direction</replaceable> can be <literal>ago</literal> or
     empty.  The at sign (<literal>@</literal>) is optional noise.  The amounts
     of the different units are implicitly added with appropriate
     sign accounting.  <literal>ago</literal> negates all the fields.
     This syntax is also used for interval output, if
     <xref linkend="guc-intervalstyle"/> is set to
     <literal>postgres_verbose</literal>.
    </para>
________________________________________________________-->
     <para>
      <type>interval</type>值可以使用下列语法书写：

<synopsis>
<optional>@</optional> <replaceable>quantity</replaceable> <replaceable>unit</replaceable> <optional><replaceable>quantity</replaceable> <replaceable>unit</replaceable>...</optional> <optional><replaceable>direction</replaceable></optional>
</synopsis>

     其中<replaceable>quantity</replaceable>是一个数字（很可能是有符号的）；
     <replaceable>unit</replaceable>是<literal>毫秒</literal>、
     <literal>millisecond</literal>、<literal>second</literal>、
     <literal>minute</literal>、<literal>hour</literal>、<literal>day</literal>、
     <literal>week</literal>、<literal>month</literal>、<literal>year</literal>、
     <literal>decade</literal>、<literal>century</literal>、<literal>millennium</literal>
     或者缩写或者这些单位的复数；
     <replaceable>direction</replaceable>可以是<literal>ago</literal>或者为空。At符号（<literal>@</literal>）是一个可选的噪声。不同单位的数量通过合适的符号计数被隐式地添加。<literal>ago</literal>对所有域求反。如果<xref linkend="guc-intervalstyle"/>被设置为<literal>postgres_verbose</literal>，该语法也被用于间隔输出。
    </para>
<!-- pgdoc-cn_end sig_en=e1a107fda907fcfd5d3709091ca0fa0c -->

<!-- pgdoc-cn_start sig_en=696dbd9c5a3d6b2218ca221ec8246284 sig_cn_org=None source=14.1 
    <para>
     Quantities of days, hours, minutes, and seconds can be specified without
     explicit unit markings.  For example, <literal>'1 12:59:10'</literal> is read
     the same as <literal>'1 day 12 hours 59 min 10 sec'</literal>.  Also,
     a combination of years and months can be specified with a dash;
     for example <literal>'200-10'</literal> is read the same as <literal>'200 years
     10 months'</literal>.  (These shorter forms are in fact the only ones allowed
     by the <acronym>SQL</acronym> standard, and are used for output when
     <varname>IntervalStyle</varname> is set to <literal>sql_standard</literal>.)
    </para>
________________________________________________________-->
    <para>
     日、小时、分钟和秒的数量可以不适用显式的单位标记指定。例如，<literal>'1 12:59:10'</literal>被读作<literal>'1 day 12 hours 59 min 10 sec'</literal>。同样，一个年和月的组合可以使用一个横线指定，例如<literal>'200-10'</literal>被读作<literal>'200年10个月'</literal>（这些较短的形式事实上是<acronym>SQL</acronym>标准唯一许可的形式，并且在<varname>IntervalStyle</varname>被设置为<literal>sql_standard</literal>时用于输出）。
    </para>
<!-- pgdoc-cn_end sig_en=696dbd9c5a3d6b2218ca221ec8246284 -->

<!-- pgdoc-cn_start sig_en=cebc3cd08e6cdf6b22849f52ee94b4a6 sig_cn_org=None source=14.1 
    <para>
     Interval values can also be written as ISO 8601 time intervals, using
     either the <quote>format with designators</quote> of the standard's section
     4.4.3.2 or the <quote>alternative format</quote> of section 4.4.3.3.  The
     format with designators looks like this:
<synopsis>
P <replaceable>quantity</replaceable> <replaceable>unit</replaceable> <optional> <replaceable>quantity</replaceable> <replaceable>unit</replaceable> ...</optional> <optional> T <optional> <replaceable>quantity</replaceable> <replaceable>unit</replaceable> ...</optional></optional>
</synopsis>
      The string must start with a <literal>P</literal>, and may include a
      <literal>T</literal> that introduces the time-of-day units.  The
      available unit abbreviations are given in <xref
      linkend="datatype-interval-iso8601-units"/>.  Units may be
      omitted, and may be specified in any order, but units smaller than
      a day must appear after <literal>T</literal>.  In particular, the meaning of
      <literal>M</literal> depends on whether it is before or after
      <literal>T</literal>.
     </para>
________________________________________________________-->
    <para>
     间隔值也可以被写成 ISO 8601 时间间隔，使用该标准4.4.3.2小节的<quote>带标志符的格式</quote>或者4.4.3.3小节的<quote>替代格式</quote>。带标志符的格式看起来像这样：
<synopsis>
P <replaceable>quantity</replaceable> <replaceable>unit</replaceable> <optional> <replaceable>quantity</replaceable> <replaceable>unit</replaceable> ...</optional> <optional> T <optional> <replaceable>quantity</replaceable> <replaceable>unit</replaceable> ...</optional></optional>
</synopsis>
      该串必须以一个<literal>P</literal>开始，并且可以包括一个引入当日时间单位的<literal>T</literal>。可用的单位缩写在<xref linkend="datatype-interval-iso8601-units"/>中给出。单位可以被忽略，并且可以以任何顺序指定，但是小于一天的单位必须出现在<literal>T</literal>之后。特别地，<literal>M</literal>的含义取决于它出现在<literal>T</literal>之前还是之后。
     </para>
<!-- pgdoc-cn_end sig_en=cebc3cd08e6cdf6b22849f52ee94b4a6 -->

     <table id="datatype-interval-iso8601-units">
<!-- pgdoc-cn_start sig_en=0481c9a757df54202e96f79dbc95bf16 sig_cn_org=None source=14.1 
      <title>ISO 8601 Interval Unit Abbreviations</title>
________________________________________________________-->
      <title>ISO 8601 间隔单位缩写</title>
<!-- pgdoc-cn_end sig_en=0481c9a757df54202e96f79dbc95bf16 -->
     <tgroup cols="2">
       <thead>
<!-- pgdoc-cn_start sig_en=1066533cc69c03246dfb9205b2ee262d sig_cn_org=None source=14.1 
        <row>
         <entry>Abbreviation</entry>
         <entry>Meaning</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>缩写</entry>
         <entry>含义</entry>
        </row>
<!-- pgdoc-cn_end sig_en=1066533cc69c03246dfb9205b2ee262d -->
       </thead>
       <tbody>
<!-- pgdoc-cn_start sig_en=dc2a2634abca480cafcee8d882812f98 sig_cn_org=None source=14.1 
        <row>
         <entry>Y</entry>
         <entry>Years</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>Y</entry>
         <entry>年</entry>
        </row>
<!-- pgdoc-cn_end sig_en=dc2a2634abca480cafcee8d882812f98 -->
<!-- pgdoc-cn_start sig_en=30bb6b0da2d611cd799d4d857d83145e sig_cn_org=None source=14.1 
        <row>
         <entry>M</entry>
         <entry>Months (in the date part)</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>M</entry>
         <entry>月（在日期部分中）</entry>
        </row>
<!-- pgdoc-cn_end sig_en=30bb6b0da2d611cd799d4d857d83145e -->
<!-- pgdoc-cn_start sig_en=b70d3497df6842cf52bc5ae29ea3d8f4 sig_cn_org=None source=14.1 
        <row>
         <entry>W</entry>
         <entry>Weeks</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>W</entry>
         <entry>周</entry>
        </row>
<!-- pgdoc-cn_end sig_en=b70d3497df6842cf52bc5ae29ea3d8f4 -->
<!-- pgdoc-cn_start sig_en=fa651f5e9f601e29610610790c7a8f94 sig_cn_org=None source=14.1 
        <row>
         <entry>D</entry>
         <entry>Days</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>D</entry>
         <entry>日</entry>
        </row>
<!-- pgdoc-cn_end sig_en=fa651f5e9f601e29610610790c7a8f94 -->
<!-- pgdoc-cn_start sig_en=8bb6a4882387e70f484c819eca0884bd sig_cn_org=None source=14.1 
        <row>
         <entry>H</entry>
         <entry>Hours</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>H</entry>
         <entry>小时</entry>
        </row>
<!-- pgdoc-cn_end sig_en=8bb6a4882387e70f484c819eca0884bd -->
<!-- pgdoc-cn_start sig_en=5c8cb5915b603be2c830cdd581936dc9 sig_cn_org=None source=14.1 
        <row>
         <entry>M</entry>
         <entry>Minutes (in the time part)</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>M</entry>
         <entry>分钟 (在时间部分中）</entry>
        </row>
<!-- pgdoc-cn_end sig_en=5c8cb5915b603be2c830cdd581936dc9 -->
<!-- pgdoc-cn_start sig_en=642b1b59b6709fe0bb0eb9ce064f5fce sig_cn_org=None source=14.1 
        <row>
         <entry>S</entry>
         <entry>Seconds</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>S</entry>
         <entry>秒</entry>
        </row>
<!-- pgdoc-cn_end sig_en=642b1b59b6709fe0bb0eb9ce064f5fce -->
       </tbody>
      </tgroup>
     </table>

<!-- pgdoc-cn_start sig_en=2c5a8fc389008a2b1bcffd5d4926113d sig_cn_org=None source=14.1 
     <para>
      In the alternative format:
<synopsis>
P <optional> <replaceable>years</replaceable>-<replaceable>months</replaceable>-<replaceable>days</replaceable> </optional> <optional> T <replaceable>hours</replaceable>:<replaceable>minutes</replaceable>:<replaceable>seconds</replaceable> </optional>
</synopsis>
      the string must begin with <literal>P</literal>, and a
      <literal>T</literal> separates the date and time parts of the interval.
      The values are given as numbers similar to ISO 8601 dates.
    </para>
________________________________________________________-->
     <para>
      如果使用替代格式：
<synopsis>
P <optional> <replaceable>years</replaceable>-<replaceable>months</replaceable>-<replaceable>days</replaceable> </optional> <optional> T <replaceable>hours</replaceable>:<replaceable>minutes</replaceable>:<replaceable>seconds</replaceable> </optional>
</synopsis>
      串必须以<literal>P</literal>开始，并且一个<literal>T</literal>分隔间隔的日期和时间部分。其值按照类似于 ISO 8601日期的数字给出。
    </para>
<!-- pgdoc-cn_end sig_en=2c5a8fc389008a2b1bcffd5d4926113d -->

<!-- pgdoc-cn_start sig_en=43201193cfdd691b2c93f1889fe60e40 sig_cn_org=None source=14.1 
    <para>
     When writing an interval constant with a <replaceable>fields</replaceable>
     specification, or when assigning a string to an interval column that was
     defined with a <replaceable>fields</replaceable> specification, the interpretation of
     unmarked quantities depends on the <replaceable>fields</replaceable>.  For
     example <literal>INTERVAL '1' YEAR</literal> is read as 1 year, whereas
     <literal>INTERVAL '1'</literal> means 1 second.  Also, field values
     <quote>to the right</quote> of the least significant field allowed by the
     <replaceable>fields</replaceable> specification are silently discarded.  For
     example, writing <literal>INTERVAL '1 day 2:03:04' HOUR TO MINUTE</literal>
     results in dropping the seconds field, but not the day field.
    </para>
________________________________________________________-->
    <para>
     在用一个<replaceable>域</replaceable>声明书写一个间隔常量时，或者为一个用<replaceable>域</replaceable>声明定义的间隔列赋予一个串时，对于为标记的量的解释依赖于<replaceable>域</replaceable>。例如<literal>INTERVAL '1' YEAR</literal>被解读成1年，而<literal>INTERVAL '1'</literal>表示1秒。同样，<replaceable>域</replaceable>声明允许的最后一个有效域<quote>右边</quote>的域值会被无声地丢弃掉。例如书写<literal>INTERVAL '1 day 2:03:04' HOUR TO MINUTE</literal>将会导致丢弃秒域，而不是日域。
    </para>
<!-- pgdoc-cn_end sig_en=43201193cfdd691b2c93f1889fe60e40 -->

<!-- pgdoc-cn_start sig_en=fd2837c0a97b4c2a89812a7d23813533 sig_cn_org=None source=14.1 
    <para>
     According to the <acronym>SQL</acronym> standard all fields of an interval
     value must have the same sign, so a leading negative sign applies to all
     fields; for example the negative sign in the interval literal
     <literal>'-1 2:03:04'</literal> applies to both the days and hour/minute/second
     parts.  <productname>PostgreSQL</productname> allows the fields to have different
     signs, and traditionally treats each field in the textual representation
     as independently signed, so that the hour/minute/second part is
     considered positive in this example.  If <varname>IntervalStyle</varname> is
     set to <literal>sql_standard</literal> then a leading sign is considered
     to apply to all fields (but only if no additional signs appear).
     Otherwise the traditional <productname>PostgreSQL</productname> interpretation is
     used.  To avoid ambiguity, it's recommended to attach an explicit sign
     to each field if any field is negative.
    </para>
________________________________________________________-->
    <para>
     根据<acronym>SQL</acronym>标准，一个间隔值的所有域都必须由相同的符号，这样一个领头的负号将会应用到所有域；例如在间隔文字<literal>'-1 2:03:04'</literal>中的负号会被应用于日、小时、分钟和秒部分。<productname>PostgreSQL</productname>允许域具有不同的符号，并且在习惯上认为以文本表示的每个域具有独立的符号，因此在这个例子中小时、分钟和秒部分被认为是正值。如果<varname>IntervalStyle</varname>被设置为<literal>sql_standard</literal>，则一个领头的符号将被认为是应用于所有域（但是仅当没有额外符号出现）。否则将使用传统的<productname>PostgreSQL</productname>解释。为了避免混淆，我们推荐在任何域为负值时为每一个域都附加一个显式的符号。
    </para>
<!-- pgdoc-cn_end sig_en=fd2837c0a97b4c2a89812a7d23813533 -->

<!-- pgdoc-cn_start sig_en=b75eacbca00c6bf7a3527ab89ddce75c sig_cn_org=68f1da90cf524faca8b5a620e2f14925 source=15.7 
    <para>
     Internally, <type>interval</type> values are stored as three integral
     fields: months, days, and microseconds.  These fields are kept
     separate because the number of days in a month varies, while a day
     can have 23 or 25 hours if a daylight savings time transition is
     involved.  An interval input string that uses other units is
     normalized into this format, and then reconstructed in a standardized
     way for output, for example:

<programlisting>
SELECT '2 years 15 months 100 weeks 99 hours 123456789 milliseconds'::interval;
               interval
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 3 years 3 mons 700 days 133:17:36.789
</programlisting>

     Here weeks, which are understood as <quote>7 days</quote>, have been
     kept separate, while the smaller and larger time units were
     combined and normalized.
    </para>
________________________________________________________-->
    <para>
     在内部，<type>interval</type>值被存储为三个整数字段：月份、天数和微秒。
     这些字段被保持分开，因为一个月的天数是变化的，而如果涉及夏令时转换，一天可能有23或25小时。
     使用其他单位的间隔输入字符串被规范化为这种格式，然后以标准化的方式重建输出，例如：

<programlisting>
SELECT '2 years 15 months 100 weeks 99 hours 123456789 milliseconds'::interval;
               interval
---------------------------------------
 3 years 3 mons 700 days 133:17:36.789
</programlisting>

     这里，被理解为<quote>7天</quote>的周被保持分开，而较小和较大的时间单位被合并和规范化。
    </para>
<!-- pgdoc-cn_end sig_en=b75eacbca00c6bf7a3527ab89ddce75c -->

<!-- pgdoc-cn_start sig_en=2c18637a17fc1cfdc5d9dd2c35a2cd05 sig_cn_org=c2d6884a70fbeb744e9e6d11f42c7d18 source=15.7 
    <para>
     Input field values can have fractional parts, for example <literal>'1.5
     weeks'</literal> or <literal>'01:02:03.45'</literal>.  However,
     because <type>interval</type> internally stores only integral fields,
     fractional values must be converted into smaller
     units.  Fractional parts of units greater than months are rounded to
     be an integer number of months, e.g. <literal>'1.5 years'</literal>
     becomes <literal>'1 year 6 mons'</literal>.  Fractional parts of
     weeks and days are computed to be an integer number of days and
     microseconds, assuming 30 days per month and 24 hours per day, e.g.,
     <literal>'1.75 months'</literal> becomes <literal>1 mon 22 days
     12:00:00</literal>.  Only seconds will ever be shown as fractional
     on output.
    </para>
________________________________________________________-->
    <para>
     输入字段值可以有小数部分，例如<literal>'1.5周'</literal>或<literal>'01:02:03.45'</literal>。
     然而，因为<type>interval</type>内部仅存储整数字段，小数值必须转换为更小的单位。
     大于月份的单位的小数部分将四舍五入为整数个月，例如<literal>'1.5年'</literal>变为<literal>'1年6个月'</literal>。
     周和天的小数部分被计算为整数天和微秒，假设每月30天，每天24小时，例如，
     <literal>'1.75个月'</literal>变为<literal>1个月22天12:00:00</literal>。
     仅秒将在输出时显示为小数。
</para>
<!-- pgdoc-cn_end sig_en=2c18637a17fc1cfdc5d9dd2c35a2cd05 -->

<!-- pgdoc-cn_start sig_en=3f125068f306ec643e6b6848737b9c1f sig_cn_org=None source=14.1 
    <para>
     <xref linkend="datatype-interval-input-examples"/> shows some examples
     of valid <type>interval</type> input.
    </para>
________________________________________________________-->
    <para>
     <xref linkend="datatype-interval-input-examples"/>展示了一些有效<type>interval</type>输入的例子。
    </para>
<!-- pgdoc-cn_end sig_en=3f125068f306ec643e6b6848737b9c1f -->

     <table id="datatype-interval-input-examples">
<!-- pgdoc-cn_start sig_en=4a7e62324b6ab55ef6a100e4d25844f9 sig_cn_org=None source=14.1 
      <title>Interval Input</title>
________________________________________________________-->
      <title>间隔输入</title>
<!-- pgdoc-cn_end sig_en=4a7e62324b6ab55ef6a100e4d25844f9 -->
      <tgroup cols="2">
       <thead>
<!-- pgdoc-cn_start sig_en=60ecc22310c4db7c945afd5cf3c23861 sig_cn_org=None source=14.1 
        <row>
         <entry>Example</entry>
         <entry>Description</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>例子</entry>
         <entry>描述</entry>
        </row>
<!-- pgdoc-cn_end sig_en=60ecc22310c4db7c945afd5cf3c23861 -->
       </thead>
       <tbody>
<!-- pgdoc-cn_start sig_en=b9b795c92182db2f6ab9092cddb67ab4 sig_cn_org=None source=14.1 
        <row>
         <entry><literal>1-2</literal></entry>
         <entry>SQL standard format: 1 year 2 months</entry>
        </row>
________________________________________________________-->
        <row>
         <entry><literal>1-2</literal></entry>
         <entry>SQL标准格式：1年2个月</entry>
        </row>
<!-- pgdoc-cn_end sig_en=b9b795c92182db2f6ab9092cddb67ab4 -->
<!-- pgdoc-cn_start sig_en=1c0d04f99387f9f963046100537015a0 sig_cn_org=None source=14.1 
        <row>
         <entry><literal>3 4:05:06</literal></entry>
         <entry>SQL standard format: 3 days 4 hours 5 minutes 6 seconds</entry>
        </row>
________________________________________________________-->
        <row>
         <entry><literal>3 4:05:06</literal></entry>
         <entry>SQL标准格式：3日4小时5分钟6秒</entry>
        </row>
<!-- pgdoc-cn_end sig_en=1c0d04f99387f9f963046100537015a0 -->
<!-- pgdoc-cn_start sig_en=0a5041b6ac6aa2217fd1c420eae48267 sig_cn_org=None source=14.1 
        <row>
         <entry><literal>1 year 2 months 3 days 4 hours 5 minutes 6 seconds</literal></entry>
         <entry>Traditional Postgres format: 1 year 2 months 3 days 4 hours 5 minutes 6 seconds</entry>
        </row>
________________________________________________________-->
        <row>
         <entry><literal>1 year 2 months 3 days 4 hours 5 minutes 6 seconds</literal></entry>
         <entry>传统Postgres格式：1年2个月3日4小时5分钟6秒钟</entry>
        </row>
<!-- pgdoc-cn_end sig_en=0a5041b6ac6aa2217fd1c420eae48267 -->
<!-- pgdoc-cn_start sig_en=6d85ac04932ae07fe6821ef03c48a9cc sig_cn_org=None source=14.1 
        <row>
         <entry><literal>P1Y2M3DT4H5M6S</literal></entry>
         <entry>ISO 8601 <quote>format with designators</quote>: same meaning as above</entry>
        </row>
________________________________________________________-->
        <row>
         <entry><literal>P1Y2M3DT4H5M6S</literal></entry>
         <entry><quote>带标志符的</quote>ISO 8601 格式：含义同上</entry>
        </row>
<!-- pgdoc-cn_end sig_en=6d85ac04932ae07fe6821ef03c48a9cc -->
<!-- pgdoc-cn_start sig_en=9417897fc2c8943a4a5492ac82bccff9 sig_cn_org=None source=14.1 
        <row>
         <entry><literal>P0001-02-03T04:05:06</literal></entry>
         <entry>ISO 8601 <quote>alternative format</quote>: same meaning as above</entry>
        </row>
________________________________________________________-->
        <row>
         <entry><literal>P0001-02-03T04:05:06</literal></entry>
         <entry>ISO 8601 的<quote>替代格式</quote>：含义同上</entry>
        </row>
<!-- pgdoc-cn_end sig_en=9417897fc2c8943a4a5492ac82bccff9 -->
       </tbody>
      </tgroup>
     </table>

   </sect2>

   <sect2 id="datatype-interval-output">
<!-- pgdoc-cn_start sig_en=06e777f33a045aaff079ff922eec6e3a sig_cn_org=None source=14.1 
    <title>Interval Output</title>
________________________________________________________-->
    <title>间隔输出</title>
<!-- pgdoc-cn_end sig_en=06e777f33a045aaff079ff922eec6e3a -->

<!-- pgdoc-cn_start sig_en=18b79fa9556aa2ee504b7977b02f525e sig_cn_org=None source=14.1 
    <indexterm>
     <primary>interval</primary>
     <secondary>output format</secondary>
     <seealso>formatting</seealso>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>interval</primary>
     <secondary>输出格式</secondary>
     <seealso>formatting</seealso>
    </indexterm>
<!-- pgdoc-cn_end sig_en=18b79fa9556aa2ee504b7977b02f525e -->

<!-- pgdoc-cn_start sig_en=d7818bb1873a4ead67d68b6d64556cea sig_cn_org=98159cf42f5f557bf10115bf357b4ae5 source=15.7 
    <para>
     As previously explained, <productname>PostgreSQL</productname>
     stores <type>interval</type> values as months, days, and
     microseconds.  For output, the months field is converted to years and
     months by dividing by 12.  The days field is shown as-is.  The
     microseconds field is converted to hours, minutes, seconds, and
     fractional seconds.  Thus months, minutes, and seconds will never be
     shown as exceeding the ranges 0&ndash;11, 0&ndash;59, and 0&ndash;59
     respectively, while the displayed years, days, and hours fields can
     be quite large.  (The <link
     linkend="function-justify-days"><function>justify_days</function></link>
     and <link
     linkend="function-justify-hours"><function>justify_hours</function></link>
     functions can be used if it is desirable to transpose large days or
     hours values into the next higher field.)
    </para>
________________________________________________________-->
    <para>
     如前所述，<productname>PostgreSQL</productname>将<type>interval</type>值存储为月、日和微秒。
     对于输出，月份字段通过除以12转换为年和月。天数字段按原样显示。
     微秒字段转换为小时、分钟、秒和分数秒。因此，月份、分钟和秒永远不会显示超过0-11、0-59和0-59的范围，
     而显示的年、天和小时字段可以非常大。（如果希望将大的天数或小时值转置为下一个更高的字段，则可以使用
     <link linkend="function-justify-days"><function>justify_days</function></link>和
     <link linkend="function-justify-hours"><function>justify_hours</function></link>函数。）
</para>
<!-- pgdoc-cn_end sig_en=d7818bb1873a4ead67d68b6d64556cea -->

<!-- pgdoc-cn_start sig_en=024196a8d6120615b720c1b2bac3b8bf sig_cn_org=None source=14.1 
    <para>
     The output format of the interval type can be set to one of the
     four styles <literal>sql_standard</literal>, <literal>postgres</literal>,
     <literal>postgres_verbose</literal>, or <literal>iso_8601</literal>,
     using the command <literal>SET intervalstyle</literal>.
     The default is the <literal>postgres</literal> format.
     <xref linkend="interval-style-output-table"/> shows examples of each
     output style.
    </para>
________________________________________________________-->
    <para>
     间隔类型的输出格式可以被设置为四种风格之一：<literal>sql_standard</literal>、<literal>postgres</literal>、<literal>postgres_verbose</literal>或<literal>iso_8601</literal>，设置方法使用<literal>SET intervalstyle</literal>命令。默认值为<literal>postgres</literal>格式。<xref linkend="interval-style-output-table"/>展示了每种输出风格的例子。
    </para>
<!-- pgdoc-cn_end sig_en=024196a8d6120615b720c1b2bac3b8bf -->

<!-- pgdoc-cn_start sig_en=b3b2657a4b3d8a166065c523c406f150 sig_cn_org=None source=14.1 
    <para>
     The <literal>sql_standard</literal> style produces output that conforms to
     the SQL standard's specification for interval literal strings, if
     the interval value meets the standard's restrictions (either year-month
     only or day-time only, with no mixing of positive
     and negative components).  Otherwise the output looks like a standard
     year-month literal string followed by a day-time literal string,
     with explicit signs added to disambiguate mixed-sign intervals.
    </para>
________________________________________________________-->
    <para>
     如果间隔值符合SQL标准的限制（仅年-月或仅日-时间，没有正负值部分的混合），<literal>sql_standard</literal>风格为间隔文字串产生符合SQL标准规范的输出。否则输出将看起来像一个标准的年-月文字串跟着一个日-时间文字串，并且带有显式添加的符号以区分混合符号的间隔。
    </para>
<!-- pgdoc-cn_end sig_en=b3b2657a4b3d8a166065c523c406f150 -->

<!-- pgdoc-cn_start sig_en=54fec273ea6753f39398afa066024bf3 sig_cn_org=None source=14.1 
    <para>
     The output of the <literal>postgres</literal> style matches the output of
     <productname>PostgreSQL</productname> releases prior to 8.4 when the
     <xref linkend="guc-datestyle"/> parameter was set to <literal>ISO</literal>.
    </para>
________________________________________________________-->
    <para>
     当<xref linkend="guc-datestyle"/>参数被设置为<literal>ISO</literal>时，<literal>postgres</literal>风格的输出匹配<productname>PostgreSQL</productname> 8.4版本以前的输出。
    </para>
<!-- pgdoc-cn_end sig_en=54fec273ea6753f39398afa066024bf3 -->

<!-- pgdoc-cn_start sig_en=16565a0f1f956c0581f305af69824670 sig_cn_org=None source=14.1 
    <para>
     The output of the <literal>postgres_verbose</literal> style matches the output of
     <productname>PostgreSQL</productname> releases prior to 8.4 when the
     <varname>DateStyle</varname> parameter was set to non-<literal>ISO</literal> output.
    </para>
________________________________________________________-->
    <para>
     当<varname>DateStyle</varname>参数被设置为非<literal>ISO</literal>输出时，<literal>postgres_verbose</literal>风格的输出匹配<productname>PostgreSQL</productname> 8.4版本以前的输出。
    </para>
<!-- pgdoc-cn_end sig_en=16565a0f1f956c0581f305af69824670 -->

<!-- pgdoc-cn_start sig_en=ac652bdb8c10f4860b2ba1551475e8c4 sig_cn_org=None source=14.1 
    <para>
     The output of the <literal>iso_8601</literal> style matches the <quote>format
     with designators</quote> described in section 4.4.3.2 of the
     ISO 8601 standard.
    </para>
________________________________________________________-->
    <para>
     <literal>iso_8601</literal>风格的输出匹配在ISO 8601标准的4.4.3.2小节中描述的<quote>带标志符的格式</quote>。
    </para>
<!-- pgdoc-cn_end sig_en=ac652bdb8c10f4860b2ba1551475e8c4 -->

     <table id="interval-style-output-table">
<!-- pgdoc-cn_start sig_en=afd674a01a4a615d1fb7a68c7834c453 sig_cn_org=None source=14.1 
       <title>Interval Output Style Examples</title>
________________________________________________________-->
       <title>间隔输出风格例子</title>
<!-- pgdoc-cn_end sig_en=afd674a01a4a615d1fb7a68c7834c453 -->
       <tgroup cols="4">
        <thead>
<!-- pgdoc-cn_start sig_en=5576387d93938fde612a932d89a597fb sig_cn_org=None source=14.1 
         <row>
          <entry>Style Specification</entry>
          <entry>Year-Month Interval</entry>
          <entry>Day-Time Interval</entry>
          <entry>Mixed Interval</entry>
         </row>
________________________________________________________-->
         <row>
          <entry>风格声明</entry>
          <entry>年-月间隔</entry>
          <entry>日-时间间隔</entry>
          <entry>混合间隔</entry>
         </row>
<!-- pgdoc-cn_end sig_en=5576387d93938fde612a932d89a597fb -->
        </thead>
        <tbody>
<!-- pgdoc-cn_start sig_en=bf465d58b3a198b932ccbbda2267d064 sig_cn_org=None source=14.1 
         <row>
          <entry><literal>sql_standard</literal></entry>
          <entry>1-2</entry>
          <entry>3 4:05:06</entry>
          <entry>-1-2 +3 -4:05:06</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>sql_standard</literal></entry>
          <entry>1-2</entry>
          <entry>3 4:05:06</entry>
          <entry>-1-2 +3 -4:05:06</entry>
         </row>
<!-- pgdoc-cn_end sig_en=bf465d58b3a198b932ccbbda2267d064 -->
<!-- pgdoc-cn_start sig_en=821b0d20a9720b7c6674e4b8f095714f sig_cn_org=None source=14.1 
         <row>
          <entry><literal>postgres</literal></entry>
          <entry>1 year 2 mons</entry>
          <entry>3 days 04:05:06</entry>
          <entry>-1 year -2 mons +3 days -04:05:06</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>postgres</literal></entry>
          <entry>1 year 2 mons</entry>
          <entry>3 days 04:05:06</entry>
          <entry>-1 year -2 mons +3 days -04:05:06</entry>
         </row>
<!-- pgdoc-cn_end sig_en=821b0d20a9720b7c6674e4b8f095714f -->
<!-- pgdoc-cn_start sig_en=1f40887c5f3209e5c8ddf8ef6a29f16d sig_cn_org=None source=14.1 
         <row>
          <entry><literal>postgres_verbose</literal></entry>
          <entry>@ 1 year 2 mons</entry>
          <entry>@ 3 days 4 hours 5 mins 6 secs</entry>
          <entry>@ 1 year 2 mons -3 days 4 hours 5 mins 6 secs ago</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>postgres_verbose</literal></entry>
          <entry>@ 1 year 2 mons</entry>
          <entry>@ 3 days 4 hours 5 mins 6 secs</entry>
          <entry>@ 1 year 2 mons -3 days 4 hours 5 mins 6 secs ago</entry>
         </row>
<!-- pgdoc-cn_end sig_en=1f40887c5f3209e5c8ddf8ef6a29f16d -->
<!-- pgdoc-cn_start sig_en=29dffea01ca62e3c187fdf2280a04e99 sig_cn_org=None source=14.1 
         <row>
          <entry><literal>iso_8601</literal></entry>
          <entry>P1Y2M</entry>
          <entry>P3DT4H5M6S</entry>
          <entry>P-1Y-2M3D&zwsp;T-4H-5M-6S</entry>
         </row>
________________________________________________________-->
         <row>
          <entry><literal>iso_8601</literal></entry>
          <entry>P1Y2M</entry>
          <entry>P3DT4H5M6S</entry>
          <entry>P-1Y-2M3D&zwsp;T-4H-5M-6S</entry>
         </row>
<!-- pgdoc-cn_end sig_en=29dffea01ca62e3c187fdf2280a04e99 -->
        </tbody>
       </tgroup>
    </table>

   </sect2>

  </sect1>

  <sect1 id="datatype-boolean">
<!-- pgdoc-cn_start sig_en=9674c5860b8d452f7b7cafc8ee6f8ad0 sig_cn_org=None source=14.1 
   <title>Boolean Type</title>
________________________________________________________-->
   <title>布尔类型</title>
<!-- pgdoc-cn_end sig_en=9674c5860b8d452f7b7cafc8ee6f8ad0 -->

<!-- pgdoc-cn_start sig_en=b93e7763c7b1bbc62811dce41ca8b47b sig_cn_org=None source=14.1 
   <indexterm zone="datatype-boolean">
    <primary>Boolean</primary>
    <secondary>data type</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-boolean">
    <primary>Boolean</primary>
    <secondary>数据类型</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=b93e7763c7b1bbc62811dce41ca8b47b -->

<!-- pgdoc-cn_start sig_en=7493043f5e72196b6c563e316a4b8356 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-boolean">
    <primary>true</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-boolean">
    <primary>true</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=7493043f5e72196b6c563e316a4b8356 -->

<!-- pgdoc-cn_start sig_en=dc37d73027602981f4c2da10351f6906 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-boolean">
    <primary>false</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-boolean">
    <primary>false</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=dc37d73027602981f4c2da10351f6906 -->

<!-- pgdoc-cn_start sig_en=8fb3cf80440c30d5320a6ba3f4fd73ab sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> provides the
    standard <acronym>SQL</acronym> type <type>boolean</type>;
    see <xref linkend="datatype-boolean-table"/>.
    The <type>boolean</type> type can have several states:
    <quote>true</quote>, <quote>false</quote>, and a third state,
    <quote>unknown</quote>, which is represented by the
    <acronym>SQL</acronym> null value.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>提供标准的<acronym>SQL</acronym>类型<type>boolean</type>，参见<xref linkend="datatype-boolean-table"/>。<type>boolean</type>可以有多个状态：<quote>true（真）</quote>、<quote>false（假）</quote>和第三种状态<quote>unknown（未知）</quote>，未知状态由<acronym>SQL</acronym>空值表示。
   </para>
<!-- pgdoc-cn_end sig_en=8fb3cf80440c30d5320a6ba3f4fd73ab -->

   <table id="datatype-boolean-table">
<!-- pgdoc-cn_start sig_en=617514bc0f2e856d7ae5f0157b6a30f6 sig_cn_org=None source=14.1 
    <title>Boolean Data Type</title>
________________________________________________________-->
    <title>布尔数据类型</title>
<!-- pgdoc-cn_end sig_en=617514bc0f2e856d7ae5f0157b6a30f6 -->
    <tgroup cols="3">
     <thead>
<!-- pgdoc-cn_start sig_en=050488145e667f5c94fa0348a4112c89 sig_cn_org=None source=14.1 
      <row>
       <entry>Name</entry>
       <entry>Storage Size</entry>
       <entry>Description</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>名字</entry>
       <entry>存储尺寸</entry>
       <entry>描述</entry>
      </row>
<!-- pgdoc-cn_end sig_en=050488145e667f5c94fa0348a4112c89 -->
     </thead>
     <tbody>
<!-- pgdoc-cn_start sig_en=61ad9b48b0a0e4cc193456109f815656 sig_cn_org=None source=14.1 
      <row>
       <entry><type>boolean</type></entry>
       <entry>1 byte</entry>
       <entry>state of true or false</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><type>boolean</type></entry>
       <entry>1字节</entry>
       <entry>状态为真或假</entry>
      </row>
<!-- pgdoc-cn_end sig_en=61ad9b48b0a0e4cc193456109f815656 -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=1470363a7fa8c781c37cf6f6102bc262 sig_cn_org=None source=14.1 
   <para>
    Boolean constants can be represented in SQL queries by the SQL
    key words <literal>TRUE</literal>, <literal>FALSE</literal>,
    and <literal>NULL</literal>.
   </para>
________________________________________________________-->
   <para>
    在SQL查询中，布尔常量可以表示为SQL关键字<literal>TRUE</literal>, <literal>FALSE</literal>,和 <literal>NULL</literal>.
   </para>
<!-- pgdoc-cn_end sig_en=1470363a7fa8c781c37cf6f6102bc262 -->

<!-- pgdoc-cn_start sig_en=6c884dd50f7415ba8de0217e4dde990e sig_cn_org=None source=14.1 
   <para>
    The datatype input function for type <type>boolean</type> accepts these
    string representations for the <quote>true</quote> state:
    <simplelist>
     <member><literal>true</literal></member>
     <member><literal>yes</literal></member>
     <member><literal>on</literal></member>
     <member><literal>1</literal></member>
    </simplelist>
    and these representations for the <quote>false</quote> state:
    <simplelist>
     <member><literal>false</literal></member>
     <member><literal>no</literal></member>
     <member><literal>off</literal></member>
     <member><literal>0</literal></member>
    </simplelist>
    Unique prefixes of these strings are also accepted, for
    example <literal>t</literal> or <literal>n</literal>.
    Leading or trailing whitespace is ignored, and case does not matter.
   </para>
________________________________________________________-->
   <para>
    <type>boolean</type> 类型的数据类型输入函数接受这些字符串表示<quote>真</quote>状态:
    <simplelist>
     <member><literal>true</literal></member>
     <member><literal>yes</literal></member>
     <member><literal>on</literal></member>
     <member><literal>1</literal></member>
    </simplelist>
    下面这些表示<quote>假</quote> 状态:
    <simplelist>
     <member><literal>false</literal></member>
     <member><literal>no</literal></member>
     <member><literal>off</literal></member>
     <member><literal>0</literal></member>
    </simplelist>
    这些字符串的唯一前缀也可以接受，例如<literal>t</literal> 或 <literal>n</literal>.
    前端或尾部的空格将被忽略，并且大小写不敏感。
   </para>
<!-- pgdoc-cn_end sig_en=6c884dd50f7415ba8de0217e4dde990e -->

<!-- pgdoc-cn_start sig_en=d3bcfec3f45dbbb3647e6adc610b4db5 sig_cn_org=None source=14.1 
   <para>
    The datatype output function for type <type>boolean</type> always emits
    either <literal>t</literal> or <literal>f</literal>, as shown in
    <xref linkend="datatype-boolean-example"/>.
   </para>
________________________________________________________-->
   <para>
    <type>boolean</type>类型的数据类型输出函数总是发出 <literal>t</literal> 或 <literal>f</literal>，如<xref linkend="datatype-boolean-example"/>所示。
   </para>
<!-- pgdoc-cn_end sig_en=d3bcfec3f45dbbb3647e6adc610b4db5 -->

   <example id="datatype-boolean-example">
<!-- pgdoc-cn_start sig_en=f2153828bd134b8d048cb9dcbfbdc620 sig_cn_org=None source=14.1 
    <title>Using the <type>boolean</type> Type</title>
________________________________________________________-->
    <title>使用<type>boolean</type>类型</title>
<!-- pgdoc-cn_end sig_en=f2153828bd134b8d048cb9dcbfbdc620 -->

<!-- pgdoc-cn_start sig_en=46f5cebfcc8d4122459cdba6b89153ba sig_cn_org=None source=14.1 
<programlisting>
CREATE TABLE test1 (a boolean, b text);
INSERT INTO test1 VALUES (TRUE, 'sic est');
INSERT INTO test1 VALUES (FALSE, 'non est');
SELECT * FROM test1;
 a |    b
-&minus;-+-&minus;-&minus;-&minus;-&minus;-
 t | sic est
 f | non est

SELECT * FROM test1 WHERE a;
 a |    b
-&minus;-+-&minus;-&minus;-&minus;-&minus;-
 t | sic est
</programlisting>
________________________________________________________-->
<programlisting>
CREATE TABLE test1 (a boolean, b text);
INSERT INTO test1 VALUES (TRUE, 'sic est');
INSERT INTO test1 VALUES (FALSE, 'non est');
SELECT * FROM test1;
 a |    b
---+---------
 t | sic est
 f | non est

SELECT * FROM test1 WHERE a;
 a |    b
---+---------
 t | sic est
</programlisting>
<!-- pgdoc-cn_end sig_en=46f5cebfcc8d4122459cdba6b89153ba -->
   </example>

<!-- pgdoc-cn_start sig_en=ece0a3fbcf615e6a47dce4fbe352ac10 sig_cn_org=None source=14.1 
   <para>
    The key words <literal>TRUE</literal> and <literal>FALSE</literal> are
    the preferred (<acronym>SQL</acronym>-compliant) method for writing
    Boolean constants in SQL queries.  But you can also use the string
    representations by following the generic string-literal constant syntax
    described in <xref linkend="sql-syntax-constants-generic"/>, for
    example <literal>'yes'::boolean</literal>.
   </para>
________________________________________________________-->
   <para>
    在SQL查询中优先使用关键字<literal>TRUE</literal> 和 <literal>FALSE</literal>来写布尔常数(<acronym>SQL</acronym>-兼容)。
    但是你也可以使用遵循<xref linkend="sql-syntax-constants-generic"/>中描述的通用字符串文字常量句法的字符串来表达，例如<literal>'yes'::boolean</literal>.
   </para>
<!-- pgdoc-cn_end sig_en=ece0a3fbcf615e6a47dce4fbe352ac10 -->

<!-- pgdoc-cn_start sig_en=24742c94d9bf69db314db033c12cac9d sig_cn_org=None source=14.1 
   <para>
    Note that the parser automatically understands
    that <literal>TRUE</literal> and <literal>FALSE</literal> are of
    type <type>boolean</type>, but this is not so
    for <literal>NULL</literal> because that can have any type.
    So in some contexts you might have to cast <literal>NULL</literal>
    to <type>boolean</type> explicitly, for
    example <literal>NULL::boolean</literal>.  Conversely, the cast can be
    omitted from a string-literal Boolean value in contexts where the parser
    can deduce that the literal must be of type <type>boolean</type>.
   </para>
________________________________________________________-->
   <para>
    注意语法分析程序会把<literal>TRUE</literal> 和 <literal>FALSE</literal> 自动理解为<type>boolean</type>类型，但是不包括<literal>NULL</literal> ，因为它可以是任何类型的。
    因此在某些语境中你也许要将 <literal>NULL</literal> 转化为显示<type>boolean</type>类型，例如<literal>NULL::boolean</literal>.
    反过来，上下文中的字符串文字布尔值也可以不转换，当语法分析程序能够断定文字必定为<type>boolean</type>类型时。
   </para>
<!-- pgdoc-cn_end sig_en=24742c94d9bf69db314db033c12cac9d -->
  </sect1>

  <sect1 id="datatype-enum">
<!-- pgdoc-cn_start sig_en=c369c76ce5c2c2c42f035f3d9e9d2de0 sig_cn_org=None source=14.1 
   <title>Enumerated Types</title>
________________________________________________________-->
   <title>枚举类型</title>
<!-- pgdoc-cn_end sig_en=c369c76ce5c2c2c42f035f3d9e9d2de0 -->

<!-- pgdoc-cn_start sig_en=daf31a4392b77c308c8f46b48e2d9fa7 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-enum">
    <primary>data type</primary>
    <secondary>enumerated (enum)</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-enum">
    <primary>数据类型</primary>
    <secondary>enumerated (enum)</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=daf31a4392b77c308c8f46b48e2d9fa7 -->

<!-- pgdoc-cn_start sig_en=60bec85b3a777a0df88c15043bb7380c sig_cn_org=None source=14.1 
   <indexterm zone="datatype-enum">
    <primary>enumerated types</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-enum">
    <primary>enumerated types</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=60bec85b3a777a0df88c15043bb7380c -->

<!-- pgdoc-cn_start sig_en=5d4c878a03251b2337ec4362f8bb5d81 sig_cn_org=None source=14.1 
   <para>
    Enumerated (enum) types are data types that
    comprise a static, ordered set of values.
    They are equivalent to the <type>enum</type>
    types supported in a number of programming languages. An example of an enum
    type might be the days of the week, or a set of status values for
    a piece of data.
   </para>
________________________________________________________-->
   <para>
    枚举（enum）类型是由一个静态、值的有序集合构成的数据类型。它们等效于很多编程语言所支持的<type>enum</type>类型。枚举类型的一个例子可以是一周中的日期，或者一个数据的状态值集合。
   </para>
<!-- pgdoc-cn_end sig_en=5d4c878a03251b2337ec4362f8bb5d81 -->

   <sect2>
<!-- pgdoc-cn_start sig_en=fd685463367ff7678b3ec74d51cf9e98 sig_cn_org=None source=14.1 
    <title>Declaration of Enumerated Types</title>
________________________________________________________-->
    <title>枚举类型的声明</title>
<!-- pgdoc-cn_end sig_en=fd685463367ff7678b3ec74d51cf9e98 -->

<!-- pgdoc-cn_start sig_en=77b8afcfd43eff3e3d44ed4a46593fae sig_cn_org=a96391bb58ab2b865aa2fe814fde8a7d source=15.7 
    <para>
     Enum types are created using the <xref
     linkend="sql-createtype"/> command,
     for example:

<programlisting>
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
</programlisting>

     Once created, the enum type can be used in table and function
     definitions much like any other type:
<programlisting>
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
CREATE TABLE person (
    name text,
    current_mood mood
);
INSERT INTO person VALUES ('Moe', 'happy');
SELECT * FROM person WHERE current_mood = 'happy';
 name | current_mood
-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Moe  | happy
(1 row)
</programlisting>
    </para>
________________________________________________________-->
    <para>
     枚举类型是使用<xref linkend="sql-createtype"/>命令创建的，例如：

<programlisting>
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
</programlisting>

     创建后，枚举类型可以像任何其他类型一样在表和函数定义中使用：
<programlisting>
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
CREATE TABLE person (
    name text,
    current_mood mood
);
INSERT INTO person VALUES ('Moe', 'happy');
SELECT * FROM person WHERE current_mood = 'happy';
 name | current_mood
------+--------------
 Moe  | happy
(1 row)
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=77b8afcfd43eff3e3d44ed4a46593fae -->
    </sect2>

    <sect2>
<!-- pgdoc-cn_start sig_en=89db443328a5818b7c4de9bacd551322 sig_cn_org=None source=14.1 
     <title>Ordering</title>
________________________________________________________-->
     <title>排序</title>
<!-- pgdoc-cn_end sig_en=89db443328a5818b7c4de9bacd551322 -->

<!-- pgdoc-cn_start sig_en=a704f865302a1ea88e157ccaf176abba sig_cn_org=bdf4574c5943ba86967a23e0718cc36b source=15.7 
     <para>
      The ordering of the values in an enum type is the
      order in which the values were listed when the type was created.
      All standard comparison operators and related
      aggregate functions are supported for enums.  For example:

<programlisting>
INSERT INTO person VALUES ('Larry', 'sad');
INSERT INTO person VALUES ('Curly', 'ok');
SELECT * FROM person WHERE current_mood > 'sad';
 name  | current_mood
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Moe   | happy
 Curly | ok
(2 rows)

SELECT * FROM person WHERE current_mood > 'sad' ORDER BY current_mood;
 name  | current_mood
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Curly | ok
 Moe   | happy
(2 rows)

SELECT name
FROM person
WHERE current_mood = (SELECT MIN(current_mood) FROM person);
 name
-&minus;-&minus;-&minus;-
 Larry
(1 row)
</programlisting>
     </para>
________________________________________________________-->
     <para>
      枚举类型中值的排序是创建类型时列出值的顺序。
      所有标准比较运算符和相关的聚合函数都支持枚举类型。例如：

<programlisting>
INSERT INTO person VALUES ('Larry', 'sad');
INSERT INTO person VALUES ('Curly', 'ok');
SELECT * FROM person WHERE current_mood > 'sad';
 name  | current_mood
-------+--------------
 Moe   | happy
 Curly | ok
(2 rows)

SELECT * FROM person WHERE current_mood > 'sad' ORDER BY current_mood;
 name  | current_mood
-------+--------------
 Curly | ok
 Moe   | happy
(2 rows)

SELECT name
FROM person
WHERE current_mood = (SELECT MIN(current_mood) FROM person);
 name
-------
 Larry
(1 row)
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=a704f865302a1ea88e157ccaf176abba -->
   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=c383efbce547cbcfcdae163e56d6ce2c sig_cn_org=None source=14.1 
    <title>Type Safety</title>
________________________________________________________-->
    <title>类型安全性</title>
<!-- pgdoc-cn_end sig_en=c383efbce547cbcfcdae163e56d6ce2c -->

<!-- pgdoc-cn_start sig_en=8da4c98a601a28c9eb8282ec62fe8fa5 sig_cn_org=None source=14.1 
    <para>
     Each enumerated data type is separate and cannot
     be compared with other enumerated types.  See this example:

<programlisting>
CREATE TYPE happiness AS ENUM ('happy', 'very happy', 'ecstatic');
CREATE TABLE holidays (
    num_weeks integer,
    happiness happiness
);
INSERT INTO holidays(num_weeks,happiness) VALUES (4, 'happy');
INSERT INTO holidays(num_weeks,happiness) VALUES (6, 'very happy');
INSERT INTO holidays(num_weeks,happiness) VALUES (8, 'ecstatic');
INSERT INTO holidays(num_weeks,happiness) VALUES (2, 'sad');
ERROR:  invalid input value for enum happiness: "sad"
SELECT person.name, holidays.num_weeks FROM person, holidays
  WHERE person.current_mood = holidays.happiness;
ERROR:  operator does not exist: mood = happiness
</programlisting>
    </para>
________________________________________________________-->
    <para>
     每一种枚举数据类型都是独立的并且不能和其他枚举类型相比较。看这样一个例子：

<programlisting>
CREATE TYPE happiness AS ENUM ('happy', 'very happy', 'ecstatic');
CREATE TABLE holidays (
    num_weeks integer,
    happiness happiness
);
INSERT INTO holidays(num_weeks,happiness) VALUES (4, 'happy');
INSERT INTO holidays(num_weeks,happiness) VALUES (6, 'very happy');
INSERT INTO holidays(num_weeks,happiness) VALUES (8, 'ecstatic');
INSERT INTO holidays(num_weeks,happiness) VALUES (2, 'sad');
ERROR:  invalid input value for enum happiness: "sad"
SELECT person.name, holidays.num_weeks FROM person, holidays
  WHERE person.current_mood = holidays.happiness;
ERROR:  operator does not exist: mood = happiness
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=8da4c98a601a28c9eb8282ec62fe8fa5 -->

<!-- pgdoc-cn_start sig_en=311ad12e4b4afd4361d1a31258bae4bf sig_cn_org=628f208905c1d381391a234a7a3c8611 source=15.7 
    <para>
     If you really need to do something like that, you can either
     write a custom operator or add explicit casts to your query:

<programlisting>
SELECT person.name, holidays.num_weeks FROM person, holidays
  WHERE person.current_mood::text = holidays.happiness::text;
 name | num_weeks
-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-
 Moe  |         4
(1 row)

</programlisting>
    </para>
________________________________________________________-->
    <para>
     如果您真的需要做类似的事情，您可以编写自定义操作符或在查询中添加显式转换：
<programlisting>
SELECT person.name, holidays.num_weeks FROM person, holidays
  WHERE person.current_mood::text = holidays.happiness::text;
 name | num_weeks
------+-----------
 Moe  |         4
(1 row)
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=311ad12e4b4afd4361d1a31258bae4bf -->
   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=d6dec2d776f526238591c5ab5fddca06 sig_cn_org=None source=14.1 
    <title>Implementation Details</title>
________________________________________________________-->
    <title>实现细节</title>
<!-- pgdoc-cn_end sig_en=d6dec2d776f526238591c5ab5fddca06 -->

<!-- pgdoc-cn_start sig_en=b958f95696d1d5fd9a1cc08cca456090 sig_cn_org=None source=14.1 
    <para>
     Enum labels are case sensitive, so
     <type>'happy'</type> is not the same as <type>'HAPPY'</type>.
     White space in the labels is significant too.
    </para>
________________________________________________________-->
    <para>
     枚举标签是大小写敏感的，因此<type>'happy'</type>与<type>'HAPPY'</type>是不同的。标签中的空格也是有意义的。
    </para>
<!-- pgdoc-cn_end sig_en=b958f95696d1d5fd9a1cc08cca456090 -->

<!-- pgdoc-cn_start sig_en=20bf88b944f3480fd3fee3214138daef sig_cn_org=None source=14.1 
    <para>
     Although enum types are primarily intended for static sets of values,
     there is support for adding new values to an existing enum type, and for
     renaming values (see <xref linkend="sql-altertype"/>).  Existing values
     cannot be removed from an enum type, nor can the sort ordering of such
     values be changed, short of dropping and re-creating the enum type.
    </para>
________________________________________________________-->
    <para>
     尽管枚举类型的主要目的是用于值的静态集合，但也有方法在现有枚举类型中增加新值和重命名值（见<xref linkend="sql-altertype"/>）。不能从枚举类型中去除现有的值，也不能更改这些值的排序顺序，如果要那样做可以删除并且重建枚举类型。
    </para>
<!-- pgdoc-cn_end sig_en=20bf88b944f3480fd3fee3214138daef -->

<!-- pgdoc-cn_start sig_en=e50b6541086a0e30321e1447c0385c4d sig_cn_org=None source=14.1 
    <para>
     An enum value occupies four bytes on disk.  The length of an enum
     value's textual label is limited by the <symbol>NAMEDATALEN</symbol>
     setting compiled into <productname>PostgreSQL</productname>; in standard
     builds this means at most 63 bytes.
    </para>
________________________________________________________-->
    <para>
     一个枚举值在磁盘上占据4个字节。一个枚举值的文本标签的长度受限于<symbol>NAMEDATALEN</symbol>设置，该设置被编译在<productname>PostgreSQL</productname>中，在标准编译下它表示最多63字节。
    </para>
<!-- pgdoc-cn_end sig_en=e50b6541086a0e30321e1447c0385c4d -->

<!-- pgdoc-cn_start sig_en=9a88a25b8c8066aca430f3f63623f014 sig_cn_org=None source=14.1 
    <para>
     The translations from internal enum values to textual labels are
     kept in the system catalog
     <link linkend="catalog-pg-enum"><structname>pg_enum</structname></link>.
     Querying this catalog directly can be useful.
    </para>
________________________________________________________-->
    <para>
     从内部枚举值到文本标签的翻译被保存在系统目录<link linkend="catalog-pg-enum"><structname>pg_enum</structname></link>中。可以直接查询该目录。
    </para>
<!-- pgdoc-cn_end sig_en=9a88a25b8c8066aca430f3f63623f014 -->

   </sect2>
  </sect1>

  <sect1 id="datatype-geometric">
<!-- pgdoc-cn_start sig_en=ecbfcfccd1ef6664457b70a344878e0a sig_cn_org=None source=14.1 
   <title>Geometric Types</title>
________________________________________________________-->
   <title>几何类型</title>
<!-- pgdoc-cn_end sig_en=ecbfcfccd1ef6664457b70a344878e0a -->

<!-- pgdoc-cn_start sig_en=67053d08ea69a82c709f4eb462a4fa47 sig_cn_org=None source=14.1 
   <para>
    Geometric data types represent two-dimensional spatial
    objects. <xref linkend="datatype-geo-table"/> shows the geometric
    types available in <productname>PostgreSQL</productname>.
   </para>
________________________________________________________-->
   <para>
    几何数据类型表示二维的空间物体。<xref linkend="datatype-geo-table"/>展示了<productname>PostgreSQL</productname>中可以用的几何类型。
   </para>
<!-- pgdoc-cn_end sig_en=67053d08ea69a82c709f4eb462a4fa47 -->

    <table id="datatype-geo-table">
<!-- pgdoc-cn_start sig_en=ecbfcfccd1ef6664457b70a344878e0a sig_cn_org=None source=14.1 
     <title>Geometric Types</title>
________________________________________________________-->
     <title>几何类型</title>
<!-- pgdoc-cn_end sig_en=ecbfcfccd1ef6664457b70a344878e0a -->
     <tgroup cols="4">
      <colspec colname="col1" colwidth="1*"/>
      <colspec colname="col2" colwidth="1*"/>
      <colspec colname="col3" colwidth="2*"/>
      <colspec colname="col4" colwidth="1*"/>
      <thead>
<!-- pgdoc-cn_start sig_en=5364c246516c5fb9d667f03ffe05f60c sig_cn_org=None source=14.1 
       <row>
        <entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry>
        <entry>Representation</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>名字</entry>
        <entry>存储尺寸</entry>
        <entry>表示</entry>
        <entry>描述</entry>
       </row>
<!-- pgdoc-cn_end sig_en=5364c246516c5fb9d667f03ffe05f60c -->
      </thead>
      <tbody>
<!-- pgdoc-cn_start sig_en=2d755ff03d09cabeb907410fae725c74 sig_cn_org=None source=14.1 
       <row>
        <entry><type>point</type></entry>
        <entry>16 bytes</entry>
        <entry>Point on a plane</entry>
        <entry>(x,y)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>point</type></entry>
        <entry>16字节</entry>
        <entry>平面上的点</entry>
        <entry>(x,y)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=2d755ff03d09cabeb907410fae725c74 -->
<!-- pgdoc-cn_start sig_en=182add2bae162a8124864e670fde5f08 sig_cn_org=None source=14.1 
       <row>
        <entry><type>line</type></entry>
        <entry>32 bytes</entry>
        <entry>Infinite line</entry>
        <entry>{A,B,C}</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>line</type></entry>
        <entry>32字节</entry>
        <entry>无限长的线</entry>
        <entry>{A,B,C}</entry>
       </row>
<!-- pgdoc-cn_end sig_en=182add2bae162a8124864e670fde5f08 -->
<!-- pgdoc-cn_start sig_en=636140d2c996c7fb5fd2dfe043778a31 sig_cn_org=None source=14.1 
       <row>
        <entry><type>lseg</type></entry>
        <entry>32 bytes</entry>
        <entry>Finite line segment</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>lseg</type></entry>
        <entry>32字节</entry>
        <entry>有限线段</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
<!-- pgdoc-cn_end sig_en=636140d2c996c7fb5fd2dfe043778a31 -->
<!-- pgdoc-cn_start sig_en=2bf952aa0de00d6d6c7b0704b4f5bbc0 sig_cn_org=None source=14.1 
       <row>
        <entry><type>box</type></entry>
        <entry>32 bytes</entry>
        <entry>Rectangular box</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>box</type></entry>
        <entry>32字节</entry>
        <entry>矩形框</entry>
        <entry>((x1,y1),(x2,y2))</entry>
       </row>
<!-- pgdoc-cn_end sig_en=2bf952aa0de00d6d6c7b0704b4f5bbc0 -->
<!-- pgdoc-cn_start sig_en=6f6978b16f8d1cc81656137d8261e3e9 sig_cn_org=None source=14.1 
       <row>
        <entry><type>path</type></entry>
        <entry>16+16n bytes</entry>
        <entry>Closed path (similar to polygon)</entry>
        <entry>((x1,y1),...)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>path</type></entry>
        <entry>16+16n字节</entry>
        <entry>封闭路径（类似于多边形）</entry>
        <entry>((x1,y1),...)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=6f6978b16f8d1cc81656137d8261e3e9 -->
<!-- pgdoc-cn_start sig_en=d4f10d09a35bd6700dcf312ee3a61d9b sig_cn_org=None source=14.1 
       <row>
        <entry><type>path</type></entry>
        <entry>16+16n bytes</entry>
        <entry>Open path</entry>
        <entry>[(x1,y1),...]</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>path</type></entry>
        <entry>16+16n字节</entry>
        <entry>开放路径</entry>
        <entry>[(x1,y1),...]</entry>
       </row>
<!-- pgdoc-cn_end sig_en=d4f10d09a35bd6700dcf312ee3a61d9b -->
<!-- pgdoc-cn_start sig_en=5a6bfa4dc0ee8c53ae8f3b6ef79c4a05 sig_cn_org=None source=14.1 
       <row>
        <entry><type>polygon</type></entry>
        <entry>40+16n bytes</entry>
        <entry>Polygon (similar to closed path)</entry>
        <entry>((x1,y1),...)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>polygon</type></entry>
        <entry>40+16n字节</entry>
        <entry>多边形（类似于封闭路径）</entry>
        <entry>((x1,y1),...)</entry>
       </row>
<!-- pgdoc-cn_end sig_en=5a6bfa4dc0ee8c53ae8f3b6ef79c4a05 -->
<!-- pgdoc-cn_start sig_en=58d27ea267d778251b8ecb0888d6d11a sig_cn_org=None source=14.1 
       <row>
        <entry><type>circle</type></entry>
        <entry>24 bytes</entry>
        <entry>Circle</entry>
        <entry>&lt;(x,y),r&gt; (center point and radius)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>circle</type></entry>
        <entry>24字节</entry>
        <entry>圆</entry>
        <entry>&lt;(x,y),r&gt;（中心点和半径）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=58d27ea267d778251b8ecb0888d6d11a -->
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=93bb31819920a1f2b77daf81d48e7054 sig_cn_org=None source=14.1 
   <para>
    A rich set of functions and operators is available to perform various geometric
    operations such as scaling, translation, rotation, and determining
    intersections.  They are explained in <xref linkend="functions-geometry"/>.
   </para>
________________________________________________________-->
   <para>
    我们有一系列丰富的函数和操作符可用来进行各种几何操作， 如缩放、平移、旋转和计算相交等 它们在<xref linkend="functions-geometry"/>中解释。
   </para>
<!-- pgdoc-cn_end sig_en=93bb31819920a1f2b77daf81d48e7054 -->

   <sect2>
<!-- pgdoc-cn_start sig_en=c3c91dd83779ac6dd1144d9f2b287005 sig_cn_org=None source=14.1 
    <title>Points</title>
________________________________________________________-->
    <title>点</title>
<!-- pgdoc-cn_end sig_en=c3c91dd83779ac6dd1144d9f2b287005 -->

<!-- pgdoc-cn_start sig_en=9507c64e62d332e0c77395c1e339660a sig_cn_org=None source=14.1 
    <indexterm>
     <primary>point</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>point</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=9507c64e62d332e0c77395c1e339660a -->

<!-- pgdoc-cn_start sig_en=26dd43ec889c301443b81afb5b9b4d63 sig_cn_org=None source=14.1 
    <para>
     Points are the fundamental two-dimensional building block for geometric
     types.  Values of type <type>point</type> are specified using either of
     the following syntaxes:

<synopsis>
( <replaceable>x</replaceable> , <replaceable>y</replaceable> )
  <replaceable>x</replaceable> , <replaceable>y</replaceable>
</synopsis>

     where <replaceable>x</replaceable> and <replaceable>y</replaceable> are the respective
     coordinates, as floating-point numbers.
    </para>
________________________________________________________-->
    <para>
     点是几何类型的基本二维构造块。用下面的语法描述<type>point</type>类型的值：

<synopsis>
( <replaceable>x</replaceable> , <replaceable>y</replaceable> )
  <replaceable>x</replaceable> , <replaceable>y</replaceable>
</synopsis>

     其中<replaceable>x</replaceable>和<replaceable>y</replaceable>分别是坐标，都是浮点数。
    </para>
<!-- pgdoc-cn_end sig_en=26dd43ec889c301443b81afb5b9b4d63 -->

<!-- pgdoc-cn_start sig_en=0b9dcd11238e8554b379893d107a9eca sig_cn_org=None source=14.1 
    <para>
     Points are output using the first syntax.
    </para>
________________________________________________________-->
    <para>
     点使用第一种语法输出。
    </para>
<!-- pgdoc-cn_end sig_en=0b9dcd11238e8554b379893d107a9eca -->
   </sect2>

   <sect2 id="datatype-line">
<!-- pgdoc-cn_start sig_en=029484e9b999c664799ecdadc3e23d95 sig_cn_org=None source=14.1 
    <title>Lines</title>
________________________________________________________-->
    <title>线</title>
<!-- pgdoc-cn_end sig_en=029484e9b999c664799ecdadc3e23d95 -->

<!-- pgdoc-cn_start sig_en=b73dfcba10445f4dbaf6b60a4f0227c1 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>line</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>line</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=b73dfcba10445f4dbaf6b60a4f0227c1 -->

<!-- pgdoc-cn_start sig_en=6dffce2b9a07ef357058add58a2933d8 sig_cn_org=None source=14.1 
    <para>
     Lines are represented by the linear
     equation <replaceable>A</replaceable>x + <replaceable>B</replaceable>y + <replaceable>C</replaceable> = 0,
     where <replaceable>A</replaceable> and <replaceable>B</replaceable> are not both zero.  Values
     of type <type>line</type> are input and output in the following form:
<synopsis>
{ <replaceable>A</replaceable>, <replaceable>B</replaceable>, <replaceable>C</replaceable> }
</synopsis>

     Alternatively, any of the following forms can be used for input:

<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

     where
     <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     and
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     are two different points on the line.
    </para>
________________________________________________________-->
    <para>
     线由线性方程<replaceable>A</replaceable>x + <replaceable>B</replaceable>y + <replaceable>C</replaceable> = 0
     表示，其中<replaceable>A</replaceable>和<replaceable>B</replaceable>都不为零。类型<type>line</type>
     的值采用以下形式输入和输出：
<synopsis>
{ <replaceable>A</replaceable>, <replaceable>B</replaceable>, <replaceable>C</replaceable> }
</synopsis>

     另外，还可以用下列任一形式输入：

<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

     其中
     <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     和
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     是线上不同的两点。
    </para>
<!-- pgdoc-cn_end sig_en=6dffce2b9a07ef357058add58a2933d8 -->
   </sect2>

   <sect2 id="datatype-lseg">
<!-- pgdoc-cn_start sig_en=d2ae36ef52be169f7696e4ace6ad501c sig_cn_org=None source=14.1 
    <title>Line Segments</title>
________________________________________________________-->
    <title>线段</title>
<!-- pgdoc-cn_end sig_en=d2ae36ef52be169f7696e4ace6ad501c -->

<!-- pgdoc-cn_start sig_en=3183fa55788b5162e3efa4bf8245f943 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>lseg</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>lseg</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=3183fa55788b5162e3efa4bf8245f943 -->

<!-- pgdoc-cn_start sig_en=6dece124febdd5e4c8f2d19e52569143 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>line segment</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>线段</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=6dece124febdd5e4c8f2d19e52569143 -->

<!-- pgdoc-cn_start sig_en=e6fc4d0c8b6a1a59d43abb03f9d6feae sig_cn_org=None source=14.1 
    <para>
     Line segments are represented by pairs of points that are the endpoints
     of the segment.  Values of type <type>lseg</type> are specified using any
     of the following syntaxes:

<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

     where
     <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     and
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     are the end points of the line segment.
    </para>
________________________________________________________-->
    <para>
     线段用一对线段的端点来表示。<type>lseg</type>类型的值用下面的语法声明：

<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

     其中<literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     和
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     是线段的端点。
    </para>
<!-- pgdoc-cn_end sig_en=e6fc4d0c8b6a1a59d43abb03f9d6feae -->

<!-- pgdoc-cn_start sig_en=43c4c9ba58bf7b5d95b3ff7287f1ecd8 sig_cn_org=None source=14.1 
    <para>
     Line segments are output using the first syntax.
    </para>
________________________________________________________-->
    <para>
     线段使用第一种语法输出。
    </para>
<!-- pgdoc-cn_end sig_en=43c4c9ba58bf7b5d95b3ff7287f1ecd8 -->
   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=67bdc748eb7cbfbdb7b09801e8829570 sig_cn_org=None source=14.1 
    <title>Boxes</title>
________________________________________________________-->
    <title>方框</title>
<!-- pgdoc-cn_end sig_en=67bdc748eb7cbfbdb7b09801e8829570 -->

<!-- pgdoc-cn_start sig_en=3313fdaa4a3dbb433b7200b8f2df35ce sig_cn_org=None source=14.1 
    <indexterm>
     <primary>box (data type)</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>box (data type)</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=3313fdaa4a3dbb433b7200b8f2df35ce -->

<!-- pgdoc-cn_start sig_en=5b4a0757db8b784f0caf3a71c003d7ba sig_cn_org=None source=14.1 
    <indexterm>
     <primary>rectangle</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>rectangle</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=5b4a0757db8b784f0caf3a71c003d7ba -->

<!-- pgdoc-cn_start sig_en=3e6fbb6ec99969957030f18e6abc8379 sig_cn_org=None source=14.1 
    <para>
     Boxes are represented by pairs of points that are opposite
     corners of the box.
     Values of type <type>box</type> are specified using any of the following
     syntaxes:

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

     where
     <literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     and
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     are any two opposite corners of the box.
    </para>
________________________________________________________-->
    <para>
     方框用其对角的点对表示。<type>box</type>类型的值使用下面的语法指定：

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ( <replaceable>x2</replaceable> , <replaceable>y2</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   ,   <replaceable>x2</replaceable> , <replaceable>y2</replaceable>
</synopsis>

     其中<literal>(<replaceable>x1</replaceable>,<replaceable>y1</replaceable>)</literal>
     和
     <literal>(<replaceable>x2</replaceable>,<replaceable>y2</replaceable>)</literal>
     是方框的对角点。
    </para>
<!-- pgdoc-cn_end sig_en=3e6fbb6ec99969957030f18e6abc8379 -->

<!-- pgdoc-cn_start sig_en=ff316841c2c55bc58c55c822ffae348a sig_cn_org=None source=14.1 
    <para>
     Boxes are output using the second syntax.
    </para>
________________________________________________________-->
    <para>
     方框使用第二种语法输出。
    </para>
<!-- pgdoc-cn_end sig_en=ff316841c2c55bc58c55c822ffae348a -->

<!-- pgdoc-cn_start sig_en=36bd8508218af76675774d388193e5d7 sig_cn_org=None source=14.1 
    <para>
     Any two opposite corners can be supplied on input, but the values
     will be reordered as needed to store the
     upper right and lower left corners, in that order.
    </para>
________________________________________________________-->
    <para>
     在输入时可以提供任意两个对角，但是值将根据需要被按顺序记录为右上角和左下角。
    </para>
<!-- pgdoc-cn_end sig_en=36bd8508218af76675774d388193e5d7 -->
   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=042369596206226c2f78c032fcd883e0 sig_cn_org=None source=14.1 
    <title>Paths</title>
________________________________________________________-->
    <title>路径</title>
<!-- pgdoc-cn_end sig_en=042369596206226c2f78c032fcd883e0 -->

<!-- pgdoc-cn_start sig_en=53f1092985a86152e5e9cd718dd9d301 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>path (data type)</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>path (data type)</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=53f1092985a86152e5e9cd718dd9d301 -->

<!-- pgdoc-cn_start sig_en=c2a4866df58896dbc110d3c03446673b sig_cn_org=None source=14.1 
    <para>
     Paths are represented by lists of connected points. Paths can be
     <firstterm>open</firstterm>, where
     the first and last points in the list are considered not connected, or
     <firstterm>closed</firstterm>,
     where the first and last points are considered connected.
    </para>
________________________________________________________-->
    <para>
     路径由一系列连接的点组成。路径可能是<firstterm>开放</firstterm>的，也就是认为列表中第一个点和最后一个点没有被连接起来；也可能是<firstterm>封闭</firstterm>的，这时认为第一个和最后一个点被连接起来。
    </para>
<!-- pgdoc-cn_end sig_en=c2a4866df58896dbc110d3c03446673b -->

<!-- pgdoc-cn_start sig_en=1919c7cb4c47a923f436f3a97bd7dfab sig_cn_org=None source=14.1 
    <para>
     Values of type <type>path</type> are specified using any of the following
     syntaxes:

<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>
</synopsis>

     where the points are the end points of the line segments
     comprising the path.  Square brackets (<literal>[]</literal>) indicate
     an open path, while parentheses (<literal>()</literal>) indicate a
     closed path.  When the outermost parentheses are omitted, as
     in the third through fifth syntaxes, a closed path is assumed.
    </para>
________________________________________________________-->
    <para>
     <type>path</type>类型的值用下面的语法声明：

<synopsis>
[ ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) ]
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>
</synopsis>

     其中的点是组成路径的线段的端点。方括弧（<literal>[]</literal>）表示一个开放的路径，圆括弧（<literal>()</literal>）表示一个封闭的路径。如第三种到第五种语法所示，当最外面的圆括号被忽略时，路径将被假定为封闭。
    </para>
<!-- pgdoc-cn_end sig_en=1919c7cb4c47a923f436f3a97bd7dfab -->

<!-- pgdoc-cn_start sig_en=279498b0df3b6d2bc67725c96466e861 sig_cn_org=None source=14.1 
    <para>
     Paths are output using the first or second syntax, as appropriate.
    </para>
________________________________________________________-->
    <para>
     路径的输出使用第一种或第二种语法。
    </para>
<!-- pgdoc-cn_end sig_en=279498b0df3b6d2bc67725c96466e861 -->
   </sect2>

   <sect2 id="datatype-polygon">
<!-- pgdoc-cn_start sig_en=0499a1f5ceaca93cf069d0fd4b1796b0 sig_cn_org=None source=14.1 
    <title>Polygons</title>
________________________________________________________-->
    <title>多边形</title>
<!-- pgdoc-cn_end sig_en=0499a1f5ceaca93cf069d0fd4b1796b0 -->

<!-- pgdoc-cn_start sig_en=200798b3bd4eb0a17749ae73c7064977 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>polygon</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>polygon</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=200798b3bd4eb0a17749ae73c7064977 -->

<!-- pgdoc-cn_start sig_en=2a568725a49a73229f631c4c7178f624 sig_cn_org=cb43c7f089af37ea855a75f82f77fc9f source=15.7 
    <para>
     Polygons are represented by lists of points (the vertexes of the
     polygon). Polygons are very similar to closed paths; the essential
     difference is that a polygon is considered to include the area
     within it, while a path is not.
    </para>
________________________________________________________-->
    <para>
     多边形由点的列表（多边形的顶点）表示。多边形与闭合路径非常相似；
     本质区别在于多边形被认为包括其中的区域，而路径则不包括。
</para>
<!-- pgdoc-cn_end sig_en=2a568725a49a73229f631c4c7178f624 -->

<!-- pgdoc-cn_start sig_en=f33b29744df80def449fce3eb21ea946 sig_cn_org=None source=14.1 
    <para>
     Values of type <type>polygon</type> are specified using any of the
     following syntaxes:

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>
</synopsis>

     where the points are the end points of the line segments
     comprising the boundary of the polygon.
    </para>
________________________________________________________-->
    <para>
     <type>polygon</type>类型的值用下列语法声明：

<synopsis>
( ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> ) )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable> ) , ... , ( <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
  ( <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable> )
    <replaceable>x1</replaceable> , <replaceable>y1</replaceable>   , ... ,   <replaceable>xn</replaceable> , <replaceable>yn</replaceable>
</synopsis>

     其中的点是组成多边形边界的线段的端点。
    </para>
<!-- pgdoc-cn_end sig_en=f33b29744df80def449fce3eb21ea946 -->

<!-- pgdoc-cn_start sig_en=063b8ee5c5f13fec53fc13afe229618a sig_cn_org=None source=14.1 
    <para>
     Polygons are output using the first syntax.
    </para>
________________________________________________________-->
    <para>
     多边形的输出使用第一种语法。
    </para>
<!-- pgdoc-cn_end sig_en=063b8ee5c5f13fec53fc13afe229618a -->
   </sect2>

   <sect2 id="datatype-circle">
<!-- pgdoc-cn_start sig_en=386b54a95d931b5f7a430b4ad079bdbd sig_cn_org=None source=14.1 
    <title>Circles</title>
________________________________________________________-->
    <title>圆</title>
<!-- pgdoc-cn_end sig_en=386b54a95d931b5f7a430b4ad079bdbd -->

<!-- pgdoc-cn_start sig_en=469050eec7a825f6227cf24794905a44 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>circle</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>circle</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=469050eec7a825f6227cf24794905a44 -->

<!-- pgdoc-cn_start sig_en=7f6f1fde02142e860006f8045847cfd0 sig_cn_org=None source=14.1 
    <para>
     Circles are represented by a center point and radius.
     Values of type <type>circle</type> are specified using any of the
     following syntaxes:

<synopsis>
&lt; ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> &gt;
( ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> )
  ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable>
    <replaceable>x</replaceable> , <replaceable>y</replaceable>   , <replaceable>r</replaceable>
</synopsis>

     where
     <literal>(<replaceable>x</replaceable>,<replaceable>y</replaceable>)</literal>
     is the center point and <replaceable>r</replaceable> is the radius of the
     circle.
    </para>
________________________________________________________-->
    <para>
     圆由一个圆心和一个半径代表。<type>circle</type>类型的值用下面的语法指定：

<synopsis>
&lt; ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> &gt;
( ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable> )
  ( <replaceable>x</replaceable> , <replaceable>y</replaceable> ) , <replaceable>r</replaceable>
    <replaceable>x</replaceable> , <replaceable>y</replaceable>   , <replaceable>r</replaceable>
</synopsis>

     其中<literal>(<replaceable>x</replaceable>,<replaceable>y</replaceable>)</literal>是圆心，而<replaceable>r</replaceable>是圆的半径。
    </para>
<!-- pgdoc-cn_end sig_en=7f6f1fde02142e860006f8045847cfd0 -->

<!-- pgdoc-cn_start sig_en=c19e4df8a74d0f784898ac39dd835ffd sig_cn_org=None source=14.1 
    <para>
     Circles are output using the first syntax.
    </para>
________________________________________________________-->
    <para>
     圆的输出用第一种语法。
    </para>
<!-- pgdoc-cn_end sig_en=c19e4df8a74d0f784898ac39dd835ffd -->
   </sect2>

  </sect1>

  <sect1 id="datatype-net-types">
<!-- pgdoc-cn_start sig_en=e5a0318deec1d008f225c1945e6d8533 sig_cn_org=None source=14.1 
   <title>Network Address Types</title>
________________________________________________________-->
   <title>网络地址类型</title>
<!-- pgdoc-cn_end sig_en=e5a0318deec1d008f225c1945e6d8533 -->

<!-- pgdoc-cn_start sig_en=db726e00f40d4fb37fc3b8d7619c79fe sig_cn_org=None source=14.1 
   <indexterm zone="datatype-net-types">
    <primary>network</primary>
    <secondary>data types</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-net-types">
    <primary>network</primary>
    <secondary>数据类型</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=db726e00f40d4fb37fc3b8d7619c79fe -->

<!-- pgdoc-cn_start sig_en=cc34730d176c8f8509bc6d639e3d96f2 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> offers data types to store IPv4, IPv6, and MAC
    addresses, as shown in <xref linkend="datatype-net-types-table"/>.  It
    is better to use these types instead of plain text types to store
    network addresses, because
    these types offer input error checking and specialized
    operators and functions (see <xref linkend="functions-net"/>).
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>提供用于存储 IPv4、IPv6 和 MAC 地址的数据类型，如<xref linkend="datatype-net-types-table"/>所示。 用这些数据类型存储网络地址比用纯文本类型好，因为这些类型提供输入错误检查以及特殊的操作符和函数（见<xref linkend="functions-net"/>）
   </para>
<!-- pgdoc-cn_end sig_en=cc34730d176c8f8509bc6d639e3d96f2 -->

    <table tocentry="1" id="datatype-net-types-table">
<!-- pgdoc-cn_start sig_en=e5a0318deec1d008f225c1945e6d8533 sig_cn_org=None source=14.1 
     <title>Network Address Types</title>
________________________________________________________-->
     <title>网络地址类型</title>
<!-- pgdoc-cn_end sig_en=e5a0318deec1d008f225c1945e6d8533 -->
     <tgroup cols="3">
      <colspec colname="col1" colwidth="1*"/>
      <colspec colname="col2" colwidth="1*"/>
      <colspec colname="col3" colwidth="2*"/>
      <thead>
<!-- pgdoc-cn_start sig_en=304ab03d21d35b8f40189b876d1fc5d1 sig_cn_org=None source=14.1 
       <row>
        <entry>Name</entry>
        <entry>Storage Size</entry>
        <entry>Description</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>名字</entry>
        <entry>存储尺寸</entry>
        <entry>描述</entry>
       </row>
<!-- pgdoc-cn_end sig_en=304ab03d21d35b8f40189b876d1fc5d1 -->
      </thead>
      <tbody>

<!-- pgdoc-cn_start sig_en=f7d887298307288eae51312f0028cebc sig_cn_org=None source=14.1 
       <row>
        <entry><type>cidr</type></entry>
        <entry>7 or 19 bytes</entry>
        <entry>IPv4 and IPv6 networks</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>cidr</type></entry>
        <entry>7或19字节</entry>
        <entry>IPv4和IPv6网络</entry>
       </row>
<!-- pgdoc-cn_end sig_en=f7d887298307288eae51312f0028cebc -->

<!-- pgdoc-cn_start sig_en=caaf2d908f71b25285be89da811f3ecf sig_cn_org=None source=14.1 
       <row>
        <entry><type>inet</type></entry>
        <entry>7 or 19 bytes</entry>
        <entry>IPv4 and IPv6 hosts and networks</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>inet</type></entry>
        <entry>7或19字节</entry>
        <entry>IPv4和IPv6主机以及网络</entry>
       </row>
<!-- pgdoc-cn_end sig_en=caaf2d908f71b25285be89da811f3ecf -->

<!-- pgdoc-cn_start sig_en=a16fb8320e65c6794edc8db3c1dccb72 sig_cn_org=None source=14.1 
       <row>
        <entry><type>macaddr</type></entry>
        <entry>6 bytes</entry>
        <entry>MAC addresses</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>macaddr</type></entry>
        <entry>6字节</entry>
        <entry>MAC地址</entry>
       </row>
<!-- pgdoc-cn_end sig_en=a16fb8320e65c6794edc8db3c1dccb72 -->

<!-- pgdoc-cn_start sig_en=ebf3a82e7864078ea05656401ac8d808 sig_cn_org=None source=14.1 
       <row>
        <entry><type>macaddr8</type></entry>
        <entry>8 bytes</entry>
        <entry>MAC addresses (EUI-64 format)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>macaddr8</type></entry>
        <entry>8 bytes</entry>
        <entry>MAC地址（EUI-64格式）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=ebf3a82e7864078ea05656401ac8d808 -->

      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=4109c4fcbbb2055d89063bfc7f6ab005 sig_cn_org=None source=14.1 
   <para>
    When sorting <type>inet</type> or <type>cidr</type> data types,
    IPv4 addresses will always sort before IPv6 addresses, including
    IPv4 addresses encapsulated or mapped to IPv6 addresses, such as
    ::10.2.3.4 or ::ffff:10.4.3.2.
   </para>
________________________________________________________-->
   <para>
    在对<type>inet</type>或者<type>cidr</type>数据类型进行排序的时候， IPv4 地址将总是排在 IPv6 地址前面，包括那些封装或者是映射在 IPv6 地址里 的 IPv4 地址，例如 ::10.2.3.4 或者 ::ffff::10.4.3.2。
   </para>
<!-- pgdoc-cn_end sig_en=4109c4fcbbb2055d89063bfc7f6ab005 -->


   <sect2 id="datatype-inet">
    <title><type>inet</type></title>

<!-- pgdoc-cn_start sig_en=1f59f8bad0e59b004f99d3e56e2b265d sig_cn_org=None source=14.1 
    <indexterm>
     <primary>inet (data type)</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>inet（数据类型）</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=1f59f8bad0e59b004f99d3e56e2b265d -->

<!-- pgdoc-cn_start sig_en=85dc5359b60d55891989dcc114b75d66 sig_cn_org=None source=14.1 
    <para>
     The <type>inet</type> type holds an IPv4 or IPv6 host address, and
     optionally its subnet, all in one field.
     The subnet is represented by the number of network address bits
     present in the host address (the
     <quote>netmask</quote>).  If the netmask is 32 and the address is IPv4,
     then the value does not indicate a subnet, only a single host.
     In IPv6, the address length is 128 bits, so 128 bits specify a
     unique host address.  Note that if you
     want to accept only networks, you should use the
     <type>cidr</type> type rather than <type>inet</type>.
    </para>
________________________________________________________-->
    <para>
     <type>inet</type>在一个数据域里保存一个 IPv4 或 IPv6 主机地址，以及一个可选的它的子网。 子网由主机地址中表示的网络地址位数表示（<quote>网络掩码</quote>）。 如果网络掩码为 32 并且地址是 IPv4 ，那么该值不表示任何子网，只是一台主机。在 IPv6 中地址长度是 128 位，因此 128 位指定一个唯一的主机地址。 请注意如果你想只接受网络地址，你应该使用<type>cidr</type>类型而不是<type>inet</type>。
    </para>
<!-- pgdoc-cn_end sig_en=85dc5359b60d55891989dcc114b75d66 -->

<!-- pgdoc-cn_start sig_en=f23ac119ef1f3ba57027e67d220eef44 sig_cn_org=None source=14.1 
    <para>
      The input format for this type is
      <replaceable class="parameter">address/y</replaceable>
      where
      <replaceable class="parameter">address</replaceable>
      is an IPv4 or IPv6 address and
      <replaceable class="parameter">y</replaceable>
      is the number of bits in the netmask.  If the
      <replaceable class="parameter">/y</replaceable>
      portion is omitted, the
      netmask is taken to be 32 for IPv4 or 128 for IPv6,
      so the value represents
      just a single host.  On display, the
      <replaceable class="parameter">/y</replaceable>
      portion is suppressed if the netmask specifies a single host.
    </para>
________________________________________________________-->
    <para>
      该类型的输入格式是<replaceable class="parameter">地址/y</replaceable>，其中<replaceable class="parameter">地址</replaceable>是一个 IPv4 或者 IPv6 地址，<replaceable class="parameter">y</replaceable>是网络掩码的位数。
      如果<replaceable class="parameter">/y</replaceable>部分省略， 则网络掩码对 IPv4 取为 32，对 IPv6 取为 128，所以该值表示只有一台主机。在显示时，如果<replaceable class="parameter">/y</replaceable>部分指定一个单台主机，它将不会被显示出来。
    </para>
<!-- pgdoc-cn_end sig_en=f23ac119ef1f3ba57027e67d220eef44 -->
   </sect2>

   <sect2 id="datatype-cidr">
    <title><type>cidr</type></title>

<!-- pgdoc-cn_start sig_en=d141f871f67d9fddbf3304c287761f98 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>cidr</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>cidr</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=d141f871f67d9fddbf3304c287761f98 -->

<!-- pgdoc-cn_start sig_en=7686091cad80a47861d38dfa11c3912a sig_cn_org=None source=14.1 
    <para>
     The <type>cidr</type> type holds an IPv4 or IPv6 network specification.
     Input and output formats follow Classless Internet Domain Routing
     conventions.
     The format for specifying networks is <replaceable
     class="parameter">address/y</replaceable> where <replaceable
     class="parameter">address</replaceable> is the network's lowest
     address represented as an
     IPv4 or IPv6 address, and <replaceable
     class="parameter">y</replaceable> is the number of bits in the netmask.  If
     <replaceable class="parameter">y</replaceable> is omitted, it is calculated
     using assumptions from the older classful network numbering system, except
     it will be at least large enough to include all of the octets
     written in the input.  It is an error to specify a network address
     that has bits set to the right of the specified netmask.
    </para>
________________________________________________________-->
    <para>
     <type>cidr</type>类型保存一个 IPv4 或 IPv6 网络地址声明。其输入和输出遵循无类的互联网域路由（Classless Internet Domain Routing）习惯。
     声明一个网络的格式是<replaceable class="parameter">地址/y</replaceable>，其中<replaceable class="parameter">address</replaceable>是最低位地址，表现为 IPv4 或 IPv6 网络地址而<replaceable class="parameter">y</replaceable>是网络掩码的位数。
     如果省略<replaceable class="parameter">y</replaceable>， 那么掩码部分用旧的有类的网络编号系统进行计算，否则它将至少大到足以包括写在输入中的所有字节。
     声明一个在其指定的掩码右边置了位的网络地址会导致错误。
    </para>
<!-- pgdoc-cn_end sig_en=7686091cad80a47861d38dfa11c3912a -->

<!-- pgdoc-cn_start sig_en=ac97ba5becd5ad6629272d92b8d016c5 sig_cn_org=None source=14.1 
    <para>
     <xref linkend="datatype-net-cidr-table"/> shows some examples.
    </para>
________________________________________________________-->
    <para>
     <xref linkend="datatype-net-cidr-table"/>展示了一些例子。
    </para>
<!-- pgdoc-cn_end sig_en=ac97ba5becd5ad6629272d92b8d016c5 -->

     <table id="datatype-net-cidr-table">
<!-- pgdoc-cn_start sig_en=c70b545c31b8fa1d0fbe094f9f8bbf49 sig_cn_org=None source=14.1 
      <title><type>cidr</type> Type Input Examples</title>
________________________________________________________-->
      <title><type>cidr</type>类型输入例子</title>
<!-- pgdoc-cn_end sig_en=c70b545c31b8fa1d0fbe094f9f8bbf49 -->
      <tgroup cols="3">
       <thead>
<!-- pgdoc-cn_start sig_en=969e92796023dd73fd9e915e1328e803 sig_cn_org=None source=14.1 
        <row>
         <entry><type>cidr</type> Input</entry>
         <entry><type>cidr</type> Output</entry>
         <entry><literal><function>abbrev(<type>cidr</type>)</function></literal></entry>
        </row>
________________________________________________________-->
        <row>
         <entry><type>cidr</type>输入</entry>
         <entry><type>cidr</type>输出</entry>
         <entry><literal><function>abbrev(<type>cidr</type>)</function></literal></entry>
        </row>
<!-- pgdoc-cn_end sig_en=969e92796023dd73fd9e915e1328e803 -->
       </thead>
       <tbody>
<!-- pgdoc-cn_start sig_en=e9711d7499a8e5a02cff753e08c36f36 sig_cn_org=None source=14.1 
        <row>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
         <entry>192.168.100.128/25</entry>
        </row>
<!-- pgdoc-cn_end sig_en=e9711d7499a8e5a02cff753e08c36f36 -->
<!-- pgdoc-cn_start sig_en=c163bb4360dff6a8cf1a8231ae89aa12 sig_cn_org=None source=14.1 
        <row>
         <entry>192.168/24</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>192.168/24</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
<!-- pgdoc-cn_end sig_en=c163bb4360dff6a8cf1a8231ae89aa12 -->
<!-- pgdoc-cn_start sig_en=bf4e593046543b049b955f5b336d86e6 sig_cn_org=None source=14.1 
        <row>
         <entry>192.168/25</entry>
         <entry>192.168.0.0/25</entry>
         <entry>192.168.0.0/25</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>192.168/25</entry>
         <entry>192.168.0.0/25</entry>
         <entry>192.168.0.0/25</entry>
        </row>
<!-- pgdoc-cn_end sig_en=bf4e593046543b049b955f5b336d86e6 -->
<!-- pgdoc-cn_start sig_en=5980c9652f99487985f630942d608617 sig_cn_org=None source=14.1 
        <row>
         <entry>192.168.1</entry>
         <entry>192.168.1.0/24</entry>
         <entry>192.168.1/24</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>192.168.1</entry>
         <entry>192.168.1.0/24</entry>
         <entry>192.168.1/24</entry>
        </row>
<!-- pgdoc-cn_end sig_en=5980c9652f99487985f630942d608617 -->
<!-- pgdoc-cn_start sig_en=6b5ea90f3224b815983c641fffea6c0c sig_cn_org=None source=14.1 
        <row>
         <entry>192.168</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>192.168</entry>
         <entry>192.168.0.0/24</entry>
         <entry>192.168.0/24</entry>
        </row>
<!-- pgdoc-cn_end sig_en=6b5ea90f3224b815983c641fffea6c0c -->
<!-- pgdoc-cn_start sig_en=5e5a2f0c4ffd9cf382b3a6c9a29bdc0a sig_cn_org=None source=14.1 
        <row>
         <entry>128.1</entry>
         <entry>128.1.0.0/16</entry>
         <entry>128.1/16</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>128.1</entry>
         <entry>128.1.0.0/16</entry>
         <entry>128.1/16</entry>
        </row>
<!-- pgdoc-cn_end sig_en=5e5a2f0c4ffd9cf382b3a6c9a29bdc0a -->
<!-- pgdoc-cn_start sig_en=4a6c7a6a1d35d1354b42c6a7546114c5 sig_cn_org=None source=14.1 
        <row>
         <entry>128</entry>
         <entry>128.0.0.0/16</entry>
         <entry>128.0/16</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>128</entry>
         <entry>128.0.0.0/16</entry>
         <entry>128.0/16</entry>
        </row>
<!-- pgdoc-cn_end sig_en=4a6c7a6a1d35d1354b42c6a7546114c5 -->
<!-- pgdoc-cn_start sig_en=cccd597224c6d2dbbc38399ca378bca4 sig_cn_org=None source=14.1 
        <row>
         <entry>128.1.2</entry>
         <entry>128.1.2.0/24</entry>
         <entry>128.1.2/24</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>128.1.2</entry>
         <entry>128.1.2.0/24</entry>
         <entry>128.1.2/24</entry>
        </row>
<!-- pgdoc-cn_end sig_en=cccd597224c6d2dbbc38399ca378bca4 -->
<!-- pgdoc-cn_start sig_en=9aa1cb015c1e31ad90846aa38e920b20 sig_cn_org=None source=14.1 
        <row>
         <entry>10.1.2</entry>
         <entry>10.1.2.0/24</entry>
         <entry>10.1.2/24</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>10.1.2</entry>
         <entry>10.1.2.0/24</entry>
         <entry>10.1.2/24</entry>
        </row>
<!-- pgdoc-cn_end sig_en=9aa1cb015c1e31ad90846aa38e920b20 -->
<!-- pgdoc-cn_start sig_en=c4e40b8b576a252b5ca341b88ea04ee8 sig_cn_org=None source=14.1 
        <row>
         <entry>10.1</entry>
         <entry>10.1.0.0/16</entry>
         <entry>10.1/16</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>10.1</entry>
         <entry>10.1.0.0/16</entry>
         <entry>10.1/16</entry>
        </row>
<!-- pgdoc-cn_end sig_en=c4e40b8b576a252b5ca341b88ea04ee8 -->
<!-- pgdoc-cn_start sig_en=27f3d1cd5527b551cf550a0e82b81b74 sig_cn_org=None source=14.1 
        <row>
         <entry>10</entry>
         <entry>10.0.0.0/8</entry>
         <entry>10/8</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>10</entry>
         <entry>10.0.0.0/8</entry>
         <entry>10/8</entry>
        </row>
<!-- pgdoc-cn_end sig_en=27f3d1cd5527b551cf550a0e82b81b74 -->
<!-- pgdoc-cn_start sig_en=02e03ee7d34cbe1b222b12de357ed085 sig_cn_org=None source=14.1 
        <row>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
         <entry>10.1.2.3/32</entry>
        </row>
<!-- pgdoc-cn_end sig_en=02e03ee7d34cbe1b222b12de357ed085 -->
<!-- pgdoc-cn_start sig_en=8769be371b5d377347025aba536a5d9b sig_cn_org=None source=14.1 
        <row>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba/64</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba::/64</entry>
         <entry>2001:4f8:3:ba/64</entry>
        </row>
<!-- pgdoc-cn_end sig_en=8769be371b5d377347025aba536a5d9b -->
<!-- pgdoc-cn_start sig_en=f77ac640faef9fd6dabeb5e80971b09a sig_cn_org=None source=14.1 
        <row>
         <entry>2001:4f8:3:ba:&zwsp;2e0:81ff:fe22:d1f1/128</entry>
         <entry>2001:4f8:3:ba:&zwsp;2e0:81ff:fe22:d1f1/128</entry>
         <entry>2001:4f8:3:ba:&zwsp;2e0:81ff:fe22:d1f1/128</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>2001:4f8:3:ba:&zwsp;2e0:81ff:fe22:d1f1/128</entry>
         <entry>2001:4f8:3:ba:&zwsp;2e0:81ff:fe22:d1f1/128</entry>
         <entry>2001:4f8:3:ba:&zwsp;2e0:81ff:fe22:d1f1/128</entry>
        </row>
<!-- pgdoc-cn_end sig_en=f77ac640faef9fd6dabeb5e80971b09a -->
<!-- pgdoc-cn_start sig_en=0cfb801a3317e02fc02c55e2d1253864 sig_cn_org=None source=14.1 
        <row>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3/120</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3.0/120</entry>
         <entry>::ffff:1.2.3/120</entry>
        </row>
<!-- pgdoc-cn_end sig_en=0cfb801a3317e02fc02c55e2d1253864 -->
<!-- pgdoc-cn_start sig_en=b2945465c29c462ea1fb8f7e7939de91 sig_cn_org=None source=14.1 
        <row>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
        </row>
________________________________________________________-->
        <row>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
         <entry>::ffff:1.2.3.0/128</entry>
        </row>
<!-- pgdoc-cn_end sig_en=b2945465c29c462ea1fb8f7e7939de91 -->
       </tbody>
      </tgroup>
     </table>
   </sect2>

   <sect2 id="datatype-inet-vs-cidr">
<!-- pgdoc-cn_start sig_en=9f2fcf9447245d21f0237e0680ce3bed sig_cn_org=None source=14.1 
    <title><type>inet</type> vs. <type>cidr</type></title>
________________________________________________________-->
    <title><type>inet</type> vs. <type>cidr</type></title>
<!-- pgdoc-cn_end sig_en=9f2fcf9447245d21f0237e0680ce3bed -->

<!-- pgdoc-cn_start sig_en=43cee638a44764db634da1e1f7094f02 sig_cn_org=None source=14.1 
    <para>
    The essential difference between <type>inet</type> and <type>cidr</type>
    data types is that <type>inet</type> accepts values with nonzero bits to
    the right of the netmask, whereas <type>cidr</type> does not.  For
    example, <literal>192.168.0.1/24</literal> is valid for <type>inet</type>
    but not for <type>cidr</type>.
    </para>
________________________________________________________-->
    <para>
    <type>inet</type>和<type>cidr</type>类型之间的本质区别是<type>inet</type>接受右边有非零位的网络掩码， 而<type>cidr</type>不接受。例如，<literal>192.168.0.1/24</literal>对<type>inet</type>是有效的，但对<type>cidr</type>是无效的。
    </para>
<!-- pgdoc-cn_end sig_en=43cee638a44764db634da1e1f7094f02 -->

      <tip>
<!-- pgdoc-cn_start sig_en=2b56cc9a16ac6e4f09235c63ced59c22 sig_cn_org=None source=14.1 
        <para>
        If you do not like the output format for <type>inet</type> or
        <type>cidr</type> values, try the functions <function>host</function>,
        <function>text</function>, and <function>abbrev</function>.
        </para>
________________________________________________________-->
        <para>
        如果你不喜欢<type>inet</type>或<type>cidr</type>值的输出格式，可以尝试函数<function>host</function>、<function>text</function>和<function>abbrev</function>。
        </para>
<!-- pgdoc-cn_end sig_en=2b56cc9a16ac6e4f09235c63ced59c22 -->
      </tip>
   </sect2>

   <sect2 id="datatype-macaddr">
    <title><type>macaddr</type></title>

<!-- pgdoc-cn_start sig_en=c030441423874b2aa7c7400859093ec5 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>macaddr (data type)</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>macaddr（数据类型）</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=c030441423874b2aa7c7400859093ec5 -->

<!-- pgdoc-cn_start sig_en=cc2c77e0bdcfac533baedbddda26f952 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>MAC address</primary>
     <see>macaddr</see>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>MAC地址</primary>
     <see>macaddr</see>
    </indexterm>
<!-- pgdoc-cn_end sig_en=cc2c77e0bdcfac533baedbddda26f952 -->

<!-- pgdoc-cn_start sig_en=d6c288a2fee9b079ed34ac68366596cb sig_cn_org=None source=14.1 
    <para>
     The <type>macaddr</type> type stores MAC addresses, known for example
     from Ethernet card hardware addresses (although MAC addresses are
     used for other purposes as well).  Input is accepted in the
     following formats:

     <simplelist>
      <member><literal>'08:00:2b:01:02:03'</literal></member>
      <member><literal>'08-00-2b-01-02-03'</literal></member>
      <member><literal>'08002b:010203'</literal></member>
      <member><literal>'08002b-010203'</literal></member>
      <member><literal>'0800.2b01.0203'</literal></member>
      <member><literal>'0800-2b01-0203'</literal></member>
      <member><literal>'08002b010203'</literal></member>
     </simplelist>

     These examples all specify the same address.  Upper and
     lower case is accepted for the digits
     <literal>a</literal> through <literal>f</literal>.  Output is always in the
     first of the forms shown.
    </para>
________________________________________________________-->
    <para>
     <type>macaddr</type>类型存储 MAC 地址，也就是以太网卡硬件地址 （尽管 MAC 地址还用于其它用途）。可以接受下列格式的输入：

     <simplelist>
      <member><literal>'08:00:2b:01:02:03'</literal></member>
      <member><literal>'08-00-2b-01-02-03'</literal></member>
      <member><literal>'08002b:010203'</literal></member>
      <member><literal>'08002b-010203'</literal></member>
      <member><literal>'0800.2b01.0203'</literal></member>
      <member><literal>'0800-2b01-0203'</literal></member>
      <member><literal>'08002b010203'</literal></member>
     </simplelist>

     这些例子指定的都是同一个地址。对于位<literal>a</literal>到<literal>f</literal>，大小写都可以接受。输出总是使用展示的第一种形式。    </para>
<!-- pgdoc-cn_end sig_en=d6c288a2fee9b079ed34ac68366596cb -->

<!-- pgdoc-cn_start sig_en=bdd0f31f7b4a202e6ba250e6dc906703 sig_cn_org=5a6ffa9f99052244e66cca5c493da7df source=15.7 
    <para>
     IEEE Standard 802-2001 specifies the second form shown (with hyphens)
     as the canonical form for MAC addresses, and specifies the first
     form (with colons) as used with bit-reversed, MSB-first notation, so that
     08-00-2b-01-02-03 = 10:00:D4:80:40:C0.  This convention is widely
     ignored nowadays, and it is relevant only for obsolete network
     protocols (such as Token Ring).  PostgreSQL makes no provisions
     for bit reversal; all accepted formats use the canonical LSB
     order.
    </para>
________________________________________________________-->
    <para>
     IEEE标准802-2001指定了MAC地址的第二种形式（带连字符）作为规范形式，
     并指定第一种形式（带冒号）用于位反转、最高位在前的表示法，因此
     08-00-2b-01-02-03 = 10:00:D4:80:40:C0。这种约定现在被广泛
     忽略，仅适用于过时的网络协议（如Token Ring）。PostgreSQL不提供
     位反转的功能；所有接受的格式都使用规范的LSB顺序。
    </para>
<!-- pgdoc-cn_end sig_en=bdd0f31f7b4a202e6ba250e6dc906703 -->

<!-- pgdoc-cn_start sig_en=3362459eb6902a641921896bfcb1f971 sig_cn_org=None source=14.1 
    <para>
     The remaining five input formats are not part of any standard.
    </para>
________________________________________________________-->
    <para>
     剩下的五种输入格式不属于任何标准。
    </para>
<!-- pgdoc-cn_end sig_en=3362459eb6902a641921896bfcb1f971 -->
   </sect2>

   <sect2 id="datatype-macaddr8">
    <title><type>macaddr8</type></title>

<!-- pgdoc-cn_start sig_en=4bfdd241d7190b87797a7bd9700939b5 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>macaddr8 (data type)</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>macaddr8 (data type)</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=4bfdd241d7190b87797a7bd9700939b5 -->

<!-- pgdoc-cn_start sig_en=456daf92d51f5f03acd6b44fae4d63de sig_cn_org=None source=14.1 
    <indexterm>
     <primary>MAC address (EUI-64 format)</primary>
     <see>macaddr</see>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>MAC address (EUI-64 format)</primary>
     <see>macaddr</see>
    </indexterm>
<!-- pgdoc-cn_end sig_en=456daf92d51f5f03acd6b44fae4d63de -->

<!-- pgdoc-cn_start sig_en=bfe2410019375fa8f78abb98524ea91e sig_cn_org=None source=14.1 
    <para>
     The <type>macaddr8</type> type stores MAC addresses in EUI-64
     format, known for example from Ethernet card hardware addresses
     (although MAC addresses are used for other purposes as well).
     This type can accept both 6 and 8 byte length MAC addresses
     and stores them in 8 byte length format.  MAC addresses given
     in 6 byte format will be stored in 8 byte length format with the
     4th and 5th bytes set to FF and FE, respectively.

     Note that IPv6 uses a modified EUI-64 format where the 7th bit
     should be set to one after the conversion from EUI-48.  The
     function <function>macaddr8_set7bit</function> is provided to make this
     change.

     Generally speaking, any input which is comprised of pairs of hex
     digits (on byte boundaries), optionally separated consistently by
     one of <literal>':'</literal>, <literal>'-'</literal> or <literal>'.'</literal>, is
     accepted.  The number of hex digits must be either 16 (8 bytes) or
     12 (6 bytes).  Leading and trailing whitespace is ignored.

     The following are examples of input formats that are accepted:

     <simplelist>
      <member><literal>'08:00:2b:01:02:03:04:05'</literal></member>
      <member><literal>'08-00-2b-01-02-03-04-05'</literal></member>
      <member><literal>'08002b:0102030405'</literal></member>
      <member><literal>'08002b-0102030405'</literal></member>
      <member><literal>'0800.2b01.0203.0405'</literal></member>
      <member><literal>'0800-2b01-0203-0405'</literal></member>
      <member><literal>'08002b01:02030405'</literal></member>
      <member><literal>'08002b0102030405'</literal></member>
     </simplelist>

     These examples all specify the same address.  Upper and
     lower case is accepted for the digits
     <literal>a</literal> through <literal>f</literal>.  Output is always in the
     first of the forms shown.
    </para>
________________________________________________________-->
    <para>
     <type>macaddr8</type>类型以EUI-64格式存储MAC地址，例如以太网卡的硬件地址（尽管MAC地址也被用于其他目的）。这种类型可以接受6字节和8字节长度的MAC地址，并且将它们存储为8字节长度的格式。以6字节格式给出的MAC地址被存储为8字节长度格式的方式是吧第4和第5字节分别设置为FF和FE。

     注意IPv6使用一种修改过的EUI-64格式，其中从EUI-48转换过来后的第7位应该被设置为一。函数<function>macaddr8_set7bit</function>被用来做这种修改。

     一般而言，任何由16进制数（字节边界上）对构成的输入（可以由<literal>':'</literal>、<literal>'-'</literal>或者<literal>'.'</literal>统一地分隔）都会被接受。16进制数的数量必须是16（8字节）或者12（6字节）。前导和拖尾的空格会被忽略。

     下面是可以被接受的输入格式的例子：

     <simplelist>
      <member><literal>'08:00:2b:01:02:03:04:05'</literal></member>
      <member><literal>'08-00-2b-01-02-03-04-05'</literal></member>
      <member><literal>'08002b:0102030405'</literal></member>
      <member><literal>'08002b-0102030405'</literal></member>
      <member><literal>'0800.2b01.0203.0405'</literal></member>
      <member><literal>'0800-2b01-0203-0405'</literal></member>
      <member><literal>'08002b01:02030405'</literal></member>
      <member><literal>'08002b0102030405'</literal></member>
     </simplelist>

     这些例子都指定相同的地址。数字<literal>a</literal>到<literal>f</literal>的大小写形式都被接受。输出总是以上面显示的第一种形式。

    </para>
<!-- pgdoc-cn_end sig_en=bfe2410019375fa8f78abb98524ea91e -->

<!-- pgdoc-cn_start sig_en=d756142d476750bee647bd370b81bc35 sig_cn_org=None source=14.1 
    <para>
     The last six input formats shown above are not part of any standard.
    </para>
________________________________________________________-->
    <para>
     上述的后六种输入格式不属于任何标准。
    </para>
<!-- pgdoc-cn_end sig_en=d756142d476750bee647bd370b81bc35 -->

<!-- pgdoc-cn_start sig_en=c7261c70b32182a0f13e81f137e1dd5a sig_cn_org=fbbeae79b334eacb85a5e3facaf62c4a source=15.7 
    <para>
     To convert a traditional 48 bit MAC address in EUI-48 format to
     modified EUI-64 format to be included as the host portion of an
     IPv6 address, use <function>macaddr8_set7bit</function> as shown:

<programlisting>
SELECT macaddr8_set7bit('08:00:2b:01:02:03');
<computeroutput>
    macaddr8_set7bit
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 0a:00:2b:ff:fe:01:02:03
(1 row)
</computeroutput>
</programlisting>

    </para>
________________________________________________________-->
    <para>
     要将传统的48位EUI-48格式MAC地址转换为修改后的EUI-64格式，以包含在IPv6地址的主机部分中，使用<function>macaddr8_set7bit</function>如下所示：

<programlisting>
SELECT macaddr8_set7bit('08:00:2b:01:02:03');
<computeroutput>
    macaddr8_set7bit
-------------------------
 0a:00:2b:ff:fe:01:02:03
(1 row)
</computeroutput>
</programlisting>

    </para>
<!-- pgdoc-cn_end sig_en=c7261c70b32182a0f13e81f137e1dd5a -->

   </sect2>

  </sect1>

  <sect1 id="datatype-bit">
<!-- pgdoc-cn_start sig_en=2bc383beb261688d610212c1b5d0fbf1 sig_cn_org=None source=14.1 
   <title>Bit String Types</title>
________________________________________________________-->
   <title>位串类型</title>
<!-- pgdoc-cn_end sig_en=2bc383beb261688d610212c1b5d0fbf1 -->

<!-- pgdoc-cn_start sig_en=89ab968f90f2fc4be483e316fd9a3054 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-bit">
    <primary>bit string</primary>
    <secondary>data type</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-bit">
    <primary>位串</primary>
    <secondary>数据类型</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=89ab968f90f2fc4be483e316fd9a3054 -->

<!-- pgdoc-cn_start sig_en=bac3d53b8e701174c2a9b4de8fb194f6 sig_cn_org=None source=14.1 
   <para>
    Bit strings are strings of 1's and 0's.  They can be used to store
    or visualize bit masks.  There are two SQL bit types:
    <type>bit(<replaceable>n</replaceable>)</type> and <type>bit
    varying(<replaceable>n</replaceable>)</type>, where
    <replaceable>n</replaceable> is a positive integer.
   </para>
________________________________________________________-->
   <para>
    位串就是一串 1 和 0 的串。它们可以用于存储和可视化位掩码。我们有两种类型的 SQL 位类型：<type>bit(<replaceable>n</replaceable>)</type>和<type>bit varying(<replaceable>n</replaceable>)</type>，其中 <replaceable>n</replaceable>是一个正整数。
   </para>
<!-- pgdoc-cn_end sig_en=bac3d53b8e701174c2a9b4de8fb194f6 -->

<!-- pgdoc-cn_start sig_en=c2ecdcb0228d680c779999a3b14aa332 sig_cn_org=None source=14.1 
   <para>
    <type>bit</type> type data must match the length
    <replaceable>n</replaceable> exactly; it is an error to attempt to
    store shorter or longer bit strings.  <type>bit varying</type> data is
    of variable length up to the maximum length
    <replaceable>n</replaceable>; longer strings will be rejected.
    Writing <type>bit</type> without a length is equivalent to
    <literal>bit(1)</literal>, while <type>bit varying</type> without a length
    specification means unlimited length.
   </para>
________________________________________________________-->
   <para>
    <type>bit</type>类型的数据必须准确匹配长度<replaceable>n</replaceable>; 试图存储短些或者长一些的位串都是错误的。<type>bit varying</type>数据是最长<replaceable>n</replaceable>的变长类型，更长的串会被拒绝。写一个没有长度的<type>bit</type>等效于 <literal>bit(1)</literal>，没有长度的<type>bit varying</type>意味着没有长度限制。
   </para>
<!-- pgdoc-cn_end sig_en=c2ecdcb0228d680c779999a3b14aa332 -->

   <note>
<!-- pgdoc-cn_start sig_en=4cd20cdb2225ed49a8ec2e8f90bc0993 sig_cn_org=None source=14.1 
    <para>
     If one explicitly casts a bit-string value to
     <type>bit(<replaceable>n</replaceable>)</type>, it will be truncated or
     zero-padded on the right to be exactly <replaceable>n</replaceable> bits,
     without raising an error.  Similarly,
     if one explicitly casts a bit-string value to
     <type>bit varying(<replaceable>n</replaceable>)</type>, it will be truncated
     on the right if it is more than <replaceable>n</replaceable> bits.
    </para>
________________________________________________________-->
    <para>
     如果我们显式地把一个位串值转换成<type>bit(<replaceable>n</replaceable>)</type>， 那么它的右边将被截断或者在右边补齐零，直到刚好<replaceable>n</replaceable>位， 而且不会抛出任何错误。类似地，如果我们显式地把一个位串数值转换成<type>bit varying(<replaceable>n</replaceable>)</type>，如果它超过了<replaceable>n</replaceable>位， 那么它的右边将被截断。
    </para>
<!-- pgdoc-cn_end sig_en=4cd20cdb2225ed49a8ec2e8f90bc0993 -->
   </note>

<!-- pgdoc-cn_start sig_en=729d501e6917771875b1b7d6e1d8ab7c sig_cn_org=None source=14.1 
   <para>
    Refer to <xref
    linkend="sql-syntax-bit-strings"/> for information about the syntax
    of bit string constants.  Bit-logical operators and string
    manipulation functions are available; see <xref
    linkend="functions-bitstring"/>.
   </para>
________________________________________________________-->
   <para>
    请参考<xref linkend="sql-syntax-bit-strings"/>获取有关位串常量的语法的信息。还有一些位逻辑操作符和串操作函数可用，请见<xref linkend="functions-bitstring"/>。
   </para>
<!-- pgdoc-cn_end sig_en=729d501e6917771875b1b7d6e1d8ab7c -->

   <example>
<!-- pgdoc-cn_start sig_en=eef93b751626d6a2398699fd8ec91ce8 sig_cn_org=None source=14.1 
    <title>Using the Bit String Types</title>
________________________________________________________-->
    <title>使用位串类型</title>
<!-- pgdoc-cn_end sig_en=eef93b751626d6a2398699fd8ec91ce8 -->

<!-- pgdoc-cn_start sig_en=c811a027e2d94be8d260f63bfa5f1b53 sig_cn_org=None source=14.1 
<programlisting>
CREATE TABLE test (a BIT(3), b BIT VARYING(5));
INSERT INTO test VALUES (B'101', B'00');
INSERT INTO test VALUES (B'10', B'101');
<computeroutput>
ERROR:  bit string length 2 does not match type bit(3)
</computeroutput>
INSERT INTO test VALUES (B'10'::bit(3), B'101');
SELECT * FROM test;
<computeroutput>
  a  |  b
-&minus;-&minus;-+-&minus;-&minus;-
 101 | 00
 100 | 101
</computeroutput>
</programlisting>
________________________________________________________-->
<programlisting>
CREATE TABLE test (a BIT(3), b BIT VARYING(5));
INSERT INTO test VALUES (B'101', B'00');
INSERT INTO test VALUES (B'10', B'101');
<computeroutput>
ERROR:  bit string length 2 does not match type bit(3)
</computeroutput>
INSERT INTO test VALUES (B'10'::bit(3), B'101');
SELECT * FROM test;
<computeroutput>
  a  |  b
-----+-----
 101 | 00
 100 | 101
</computeroutput>
</programlisting>
<!-- pgdoc-cn_end sig_en=c811a027e2d94be8d260f63bfa5f1b53 -->
   </example>

<!-- pgdoc-cn_start sig_en=f8c2ed317b58299001447213a00f1243 sig_cn_org=None source=14.1 
   <para>
    A bit string value requires 1 byte for each group of 8 bits, plus
    5 or 8 bytes overhead depending on the length of the string
    (but long values may be compressed or moved out-of-line, as explained
    in <xref linkend="datatype-character"/> for character strings).
   </para>
________________________________________________________-->
   <para>
    一个位串值对于每8位的组需要一个字节，外加总共5个或8个字节，这取决于串的长度（但是长值可能被压缩或者移到线外，如<xref linkend="datatype-character"/>中对字符串的解释一样）。
   </para>
<!-- pgdoc-cn_end sig_en=f8c2ed317b58299001447213a00f1243 -->
  </sect1>

  <sect1 id="datatype-textsearch">
<!-- pgdoc-cn_start sig_en=f2f98000201b498bd1e87dbf3c0cbbd3 sig_cn_org=None source=14.1 
   <title>Text Search Types</title>
________________________________________________________-->
   <title>文本搜索类型</title>
<!-- pgdoc-cn_end sig_en=f2f98000201b498bd1e87dbf3c0cbbd3 -->

<!-- pgdoc-cn_start sig_en=c9584ae21b442858b446ee350063964e sig_cn_org=None source=14.1 
   <indexterm zone="datatype-textsearch">
    <primary>full text search</primary>
    <secondary>data types</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-textsearch">
    <primary>全文搜索</primary>
    <secondary>数据类型</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=c9584ae21b442858b446ee350063964e -->

<!-- pgdoc-cn_start sig_en=75899e35923752cc4e72ba64b8e80785 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-textsearch">
    <primary>text search</primary>
    <secondary>data types</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-textsearch">
    <primary>文本搜索</primary>
    <secondary>数据类型</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=75899e35923752cc4e72ba64b8e80785 -->

<!-- pgdoc-cn_start sig_en=90604970b3e956e32ee456755c956161 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> provides two data types that
    are designed to support full text search, which is the activity of
    searching through a collection of natural-language <firstterm>documents</firstterm>
    to locate those that best match a <firstterm>query</firstterm>.
    The <type>tsvector</type> type represents a document in a form optimized
    for text search; the <type>tsquery</type> type similarly represents
    a text query.
    <xref linkend="textsearch"/> provides a detailed explanation of this
    facility, and <xref linkend="functions-textsearch"/> summarizes the
    related functions and operators.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>提供两种数据类型，它们被设计用来支持全文搜索，全文搜索是一种在自然语言的<firstterm>文档</firstterm>集合中搜索以定位那些最匹配一个<firstterm>查询</firstterm>的文档的活动。<type>tsvector</type>类型表示一个为文本搜索优化的形式下的文档，<type>tsquery</type>类型表示一个文本查询。<xref linkend="textsearch"/>提供了对于这种功能的详细解释，并且<xref linkend="functions-textsearch"/>总结了相关的函数和操作符。
   </para>
<!-- pgdoc-cn_end sig_en=90604970b3e956e32ee456755c956161 -->

   <sect2 id="datatype-tsvector">
    <title><type>tsvector</type></title>

<!-- pgdoc-cn_start sig_en=d452c552002e75899564505fce724965 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>tsvector (data type)</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>tsvector（数据类型）</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=d452c552002e75899564505fce724965 -->

<!-- pgdoc-cn_start sig_en=cb65f847e1c0af4a28bf24bf840ce4a7 sig_cn_org=edea5ebfdf70ce44d389b4448fd7380c source=15.7 
    <para>
     A <type>tsvector</type> value is a sorted list of distinct
     <firstterm>lexemes</firstterm>, which are words that have been
     <firstterm>normalized</firstterm> to merge different variants of the same word
     (see <xref linkend="textsearch"/> for details).  Sorting and
     duplicate-elimination are done automatically during input, as shown in
     this example:

<programlisting>
SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector;
                      tsvector
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 'a' 'and' 'ate' 'cat' 'fat' 'mat' 'on' 'rat' 'sat'
</programlisting>

     To represent
     lexemes containing whitespace or punctuation, surround them with quotes:

<programlisting>
SELECT $$the lexeme '    ' contains spaces$$::tsvector;
                 tsvector
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 '    ' 'contains' 'lexeme' 'spaces' 'the'
</programlisting>

     (We use dollar-quoted string literals in this example and the next one
     to avoid the confusion of having to double quote marks within the
     literals.)  Embedded quotes and backslashes must be doubled:

<programlisting>
SELECT $$the lexeme 'Joe''s' contains a quote$$::tsvector;
                    tsvector
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 'Joe''s' 'a' 'contains' 'lexeme' 'quote' 'the'
</programlisting>

     Optionally, integer <firstterm>positions</firstterm>
     can be attached to lexemes:

<programlisting>
SELECT 'a:1 fat:2 cat:3 sat:4 on:5 a:6 mat:7 and:8 ate:9 a:10 fat:11 rat:12'::tsvector;
                                  tsvector
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&zwsp;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 'a':1,6,10 'and':8 'ate':9 'cat':3 'fat':2,11 'mat':7 'on':5 'rat':12 'sat':4
</programlisting>

     A position normally indicates the source word's location in the
     document.  Positional information can be used for
     <firstterm>proximity ranking</firstterm>.  Position values can
     range from 1 to 16383; larger numbers are silently set to 16383.
     Duplicate positions for the same lexeme are discarded.
    </para>
________________________________________________________-->
    <para>
     一个<type>tsvector</type>值是一个排序的不同<firstterm>词元（lexemes）</firstterm>的列表，这些词元是已经<firstterm>标准化(normalized)</firstterm>的单词，用于合并同一个单词的不同变体（详见<xref linkend="textsearch"/>）。在输入时会自动进行排序和去重，如下所示：

<programlisting>
SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector;
                      tsvector
----------------------------------------------------
 'a' 'and' 'ate' 'cat' 'fat' 'mat' 'on' 'rat' 'sat'
</programlisting>

     为了表示包含空格或标点符号的词元，请用引号括起来：

<programlisting>
SELECT $$the lexeme '    ' contains spaces$$::tsvector;
                 tsvector
-------------------------------------------
 '    ' 'contains' 'lexeme' 'spaces' 'the'
</programlisting>

     （在这个例子和下一个例子中，我们使用了dollar-quoted字符串字面值，以避免在字面值内部需要双引号。）嵌入的引号和反斜杠必须加倍：

<programlisting>
SELECT $$the lexeme 'Joe''s' contains a quote$$::tsvector;
                    tsvector
------------------------------------------------
 'Joe''s' 'a' 'contains' 'lexeme' 'quote' 'the'
</programlisting>

     可选地，可以将整数<firstterm>位置（positions）</firstterm>附加到词元上：

<programlisting>
SELECT 'a:1 fat:2 cat:3 sat:4 on:5 a:6 mat:7 and:8 ate:9 a:10 fat:11 rat:12'::tsvector;
                                  tsvector
-------------------------------------------------------------------&zwsp;------------
 'a':1,6,10 'and':8 'ate':9 'cat':3 'fat':2,11 'mat':7 'on':5 'rat':12 'sat':4
</programlisting>

     位置通常表示文档中源单词的位置。位置信息可用于<firstterm>接近排名（proximity ranking）</firstterm>。位置值可以从1到16383范围；较大的数字会被自动设置为16383。相同词元的重复位置会被丢弃。
    </para>
<!-- pgdoc-cn_end sig_en=cb65f847e1c0af4a28bf24bf840ce4a7 -->

<!-- pgdoc-cn_start sig_en=15c76fa2af9006291193db4b1e7f683d sig_cn_org=f3d322ce07211b45f0b940e2a46c1c86 source=15.7 
    <para>
     Lexemes that have positions can further be labeled with a
     <firstterm>weight</firstterm>, which can be <literal>A</literal>,
     <literal>B</literal>, <literal>C</literal>, or <literal>D</literal>.
     <literal>D</literal> is the default and hence is not shown on output:

<programlisting>
SELECT 'a:1A fat:2B,4C cat:5D'::tsvector;
          tsvector
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 'a':1A 'cat':5 'fat':2B,4C
</programlisting>

     Weights are typically used to reflect document structure, for example
     by marking title words differently from body words.  Text search
     ranking functions can assign different priorities to the different
     weight markers.
    </para>
________________________________________________________-->
    <para>
     具有位置的词元可以进一步用<firstterm>权重（weight）</firstterm>标记，可以是<literal>A</literal>，
     <literal>B</literal>，<literal>C</literal>或<literal>D</literal>。
     <literal>D</literal>是默认值，因此不会显示在输出中：

<programlisting>
SELECT 'a:1A fat:2B,4C cat:5D'::tsvector;
          tsvector
----------------------------
 'a':1A 'cat':5 'fat':2B,4C
</programlisting>

     权重通常用于反映文档结构，例如通过将标题词与正文词标记不同。文本搜索
     排名函数可以为不同的权重标记分配不同的优先级。
    </para>
<!-- pgdoc-cn_end sig_en=15c76fa2af9006291193db4b1e7f683d -->

<!-- pgdoc-cn_start sig_en=22f5fef51208451c700fed83a4baa66e sig_cn_org=2190e0401374e050b7a8d77262a7e412 source=15.7 
    <para>
     It is important to understand that the
     <type>tsvector</type> type itself does not perform any word
     normalization; it assumes the words it is given are normalized
     appropriately for the application.  For example,

<programlisting>
SELECT 'The Fat Rats'::tsvector;
      tsvector
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 'Fat' 'Rats' 'The'
</programlisting>

     For most English-text-searching applications the above words would
     be considered non-normalized, but <type>tsvector</type> doesn't care.
     Raw document text should usually be passed through
     <function>to_tsvector</function> to normalize the words appropriately
     for searching:

<programlisting>
SELECT to_tsvector('english', 'The Fat Rats');
   to_tsvector
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 'fat':2 'rat':3
</programlisting>

     Again, see <xref linkend="textsearch"/> for more detail.
    </para>
________________________________________________________-->
    <para>
     重要的是要理解<type>tsvector</type>类型本身不执行任何单词规范化；它假定给定的单词已经适当地规范化了应用程序。
     例如，

<programlisting>
SELECT 'The Fat Rats'::tsvector;
      tsvector
--------------------
 'Fat' 'Rats' 'The'
</programlisting>

     对于大多数英文文本搜索应用程序来说，上述单词被认为是非规范化的，但<type>tsvector</type>并不在乎。
     原始文档文本通常应通过<function>to_tsvector</function>进行传递，以便适当地规范化单词以供搜索：

<programlisting>
SELECT to_tsvector('english', 'The Fat Rats');
   to_tsvector
-----------------
 'fat':2 'rat':3
</programlisting>

     再次，详细信息请参见<xref linkend="textsearch"/>。
    </para>
<!-- pgdoc-cn_end sig_en=22f5fef51208451c700fed83a4baa66e -->

   </sect2>

   <sect2 id="datatype-tsquery">
    <title><type>tsquery</type></title>

<!-- pgdoc-cn_start sig_en=a0c592cd1faf15fc6360dca6dcbf319c sig_cn_org=None source=14.1 
    <indexterm>
     <primary>tsquery (data type)</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>tsquery（数据类型）</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=a0c592cd1faf15fc6360dca6dcbf319c -->

<!-- pgdoc-cn_start sig_en=13d269db91f899f2fc6fc848c1a90c6c sig_cn_org=None source=14.1 
    <para>
     A <type>tsquery</type> value stores lexemes that are to be
     searched for, and can combine them using the Boolean operators
     <literal>&amp;</literal> (AND), <literal>|</literal> (OR), and
     <literal>!</literal> (NOT), as well as the phrase search operator
     <literal>&lt;-&gt;</literal> (FOLLOWED BY).  There is also a variant
     <literal>&lt;<replaceable>N</replaceable>&gt;</literal> of the FOLLOWED BY
     operator, where <replaceable>N</replaceable> is an integer constant that
     specifies the distance between the two lexemes being searched
     for.  <literal>&lt;-&gt;</literal> is equivalent to <literal>&lt;1&gt;</literal>.
    </para>
________________________________________________________-->
    <para>
     一个<type>tsquery</type>值存储要用于搜索的词位，并且使用布尔操作符<literal>&amp;</literal>（AND）、<literal>|</literal>（OR）和<literal>!</literal>（NOT）来组合它们，还有短语搜索操作符<literal>&lt;-&gt;</literal>（FOLLOWED BY）。也有一种 FOLLOWED BY 操作符的变体<literal>&lt;<replaceable>N</replaceable>&gt;</literal>，其中<replaceable>N</replaceable>是一个整数常量，它指定要搜索的两个词位之间的距离。<literal>&lt;-&gt;</literal>等效于<literal>&lt;1&gt;</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=13d269db91f899f2fc6fc848c1a90c6c -->

<!-- pgdoc-cn_start sig_en=aa499c98955c9adfec2804a13ed97e5d sig_cn_org=None source=14.1 
    <para>
     Parentheses can be used to enforce grouping of these operators.
     In the absence of parentheses, <literal>!</literal> (NOT) binds most tightly,
     <literal>&lt;-&gt;</literal> (FOLLOWED BY) next most tightly, then
     <literal>&amp;</literal> (AND), with <literal>|</literal> (OR) binding
     the least tightly.
    </para>
________________________________________________________-->
    <para>   
     圆括号可以被用来强制对操作符分组。如果没有圆括号，<literal>!</literal>（NOT）的优先级最高，其次是<literal>&lt;-&gt;</literal>（FOLLOWED BY），然后是<literal>&amp;</literal>（AND），最后是<literal>|</literal>（OR）。
    </para>
<!-- pgdoc-cn_end sig_en=aa499c98955c9adfec2804a13ed97e5d -->

<!-- pgdoc-cn_start sig_en=9225d88e34f23dc63648fd44e4ef85c5 sig_cn_org=eba3e37898e06fb2623acc0fd071d350 source=15.7 
    <para>
     Here are some examples:

<programlisting>
SELECT 'fat &amp; rat'::tsquery;
    tsquery
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 'fat' &amp; 'rat'

SELECT 'fat &amp; (rat | cat)'::tsquery;
          tsquery
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 'fat' &amp; ( 'rat' | 'cat' )

SELECT 'fat &amp; rat &amp; ! cat'::tsquery;
        tsquery
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 'fat' &amp; 'rat' &amp; !'cat'
</programlisting>
    </para>
________________________________________________________-->
    <para>
     这里是一些示例:

<programlisting>
SELECT 'fat &amp; rat'::tsquery;
    tsquery
---------------
 'fat' &amp; 'rat'

SELECT 'fat &amp; (rat | cat)'::tsquery;
          tsquery
---------------------------
 'fat' &amp; ( 'rat' | 'cat' )

SELECT 'fat &amp; rat &amp; ! cat'::tsquery;
        tsquery
------------------------
 'fat' &amp; 'rat' &amp; !'cat'
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=9225d88e34f23dc63648fd44e4ef85c5 -->

<!-- pgdoc-cn_start sig_en=e2faf81c5fa2879fe99589caa9d0974b sig_cn_org=None source=14.1 
    <para>
     Optionally, lexemes in a <type>tsquery</type> can be labeled with
     one or more weight letters, which restricts them to match only
     <type>tsvector</type> lexemes with one of those weights:

<programlisting>
SELECT 'fat:ab &amp; cat'::tsquery;
    tsquery
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 'fat':AB &amp; 'cat'
</programlisting>
    </para>
________________________________________________________-->
    <para>
     可选地，一个<type>tsquery</type>中的词位可以被标注一个或多个权重字母，这将限制它们只能和具有那些权重之一的<type>tsvector</type>词位相匹配：

<programlisting>
SELECT 'fat:ab &amp; cat'::tsquery;
    tsquery
------------------
 'fat':AB &amp; 'cat'
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=e2faf81c5fa2879fe99589caa9d0974b -->

<!-- pgdoc-cn_start sig_en=a0b306981cd271af566d299a641f242f sig_cn_org=d9af2f910c4712a3b329a810d433cb0c source=15.7 
    <para>
     Also, lexemes in a <type>tsquery</type> can be labeled with <literal>*</literal>
     to specify prefix matching:
<programlisting>
SELECT 'super:*'::tsquery;
  tsquery
-&minus;-&minus;-&minus;-&minus;-&minus;-
 'super':*
</programlisting>
     This query will match any word in a <type>tsvector</type> that begins
     with <quote>super</quote>.
    </para>
________________________________________________________-->
    <para>
     另外，在<type>tsquery</type>中的词元可以用<literal>*</literal>标记以指定前缀匹配：
<programlisting>
SELECT 'super:*'::tsquery;
  tsquery
-----------
 'super':*
</programlisting>
     这个查询将匹配<type>tsvector</type>中以<quote>super</quote>开头的任何单词。
    </para>
<!-- pgdoc-cn_end sig_en=a0b306981cd271af566d299a641f242f -->

<!-- pgdoc-cn_start sig_en=37c16ccb3f1236d4ec37d2c8f0150def sig_cn_org=7c841e94dc0f9f9dff863b4d9df9c6d1 source=15.7 
    <para>
     Quoting rules for lexemes are the same as described previously for
     lexemes in <type>tsvector</type>; and, as with <type>tsvector</type>,
     any required normalization of words must be done before converting
     to the <type>tsquery</type> type.  The <function>to_tsquery</function>
     function is convenient for performing such normalization:

<programlisting>
SELECT to_tsquery('Fat:ab &amp; Cats');
    to_tsquery
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 'fat':AB &amp; 'cat'
</programlisting>

     Note that <function>to_tsquery</function> will process prefixes in the same way
     as other words, which means this comparison returns true:

<programlisting>
SELECT to_tsvector( 'postgraduate' ) @@ to_tsquery( 'postgres:*' );
 ?column?
-&minus;-&minus;-&minus;-&minus;-&minus;
 t
</programlisting>
     because <literal>postgres</literal> gets stemmed to <literal>postgr</literal>:
<programlisting>
SELECT to_tsvector( 'postgraduate' ), to_tsquery( 'postgres:*' );
  to_tsvector  | to_tsquery
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 'postgradu':1 | 'postgr':*
</programlisting>
     which will match the stemmed form of <literal>postgraduate</literal>.
    </para>
________________________________________________________-->
    <para>
     对于词元的引用规则与之前描述的<type>tsvector</type>中的词元相同；并且，与<type>tsvector</type>一样，
     在转换为<type>tsquery</type>类型之前，必须对单词进行任何必需的规范化。函数<function>to_tsquery</function>
     用于执行这种规范化：

<programlisting>
SELECT to_tsquery('Fat:ab &amp; Cats');
    to_tsquery
------------------
 'fat':AB &amp; 'cat'
</programlisting>

     请注意，<function>to_tsquery</function>将以与其他单词相同的方式处理前缀，这意味着此比较返回true：

<programlisting>
SELECT to_tsvector( 'postgraduate' ) @@ to_tsquery( 'postgres:*' );
 ?column?
----------
 t
</programlisting>
     因为<literal>postgres</literal>被词干化为<literal>postgr</literal>：
<programlisting>
SELECT to_tsvector( 'postgraduate' ), to_tsquery( 'postgres:*' );
  to_tsvector  | to_tsquery
---------------+------------
 'postgradu':1 | 'postgr':*
</programlisting>
     这将匹配<literal>postgraduate</literal>的词干形式。
    </para>
<!-- pgdoc-cn_end sig_en=37c16ccb3f1236d4ec37d2c8f0150def -->

   </sect2>

  </sect1>

  <sect1 id="datatype-uuid">
<!-- pgdoc-cn_start sig_en=5d4092a8592b9bb0b83c99c69e66c325 sig_cn_org=None source=14.1 
   <title><acronym>UUID</acronym> Type</title>
________________________________________________________-->
   <title><acronym>UUID</acronym>类型</title>
<!-- pgdoc-cn_end sig_en=5d4092a8592b9bb0b83c99c69e66c325 -->

<!-- pgdoc-cn_start sig_en=47585941bd4cfd5a5508bc8e18e20b23 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-uuid">
    <primary>UUID</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-uuid">
    <primary>UUID</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=47585941bd4cfd5a5508bc8e18e20b23 -->

<!-- pgdoc-cn_start sig_en=b3e7aac4a6d81aa23d728dbdd595eb0d sig_cn_org=55e39fcc3cee4b00df3d38ad32bcd28c source=15.7 
   <para>
    The data type <type>uuid</type> stores Universally Unique Identifiers
    (UUID) as defined by <ulink url="https://datatracker.ietf.org/doc/html/rfc4122">RFC 4122</ulink>,
    ISO/IEC 9834-8:2005, and related standards.
    (Some systems refer to this data type as a globally unique identifier, or
    GUID,<indexterm><primary>GUID</primary></indexterm> instead.)  This
    identifier is a 128-bit quantity that is generated by an algorithm chosen
    to make it very unlikely that the same identifier will be generated by
    anyone else in the known universe using the same algorithm.  Therefore,
    for distributed systems, these identifiers provide a better uniqueness
    guarantee than sequence generators, which
    are only unique within a single database.
   </para>
________________________________________________________-->
   <para>
    数据类型<type>uuid</type>存储由<ulink url="https://datatracker.ietf.org/doc/html/rfc4122">RFC 4122</ulink>、
    ISO/IEC 9834-8:2005和相关标准定义的通用唯一标识符（UUID）。
    （有些系统将此数据类型称为全局唯一标识符，或GUID，<indexterm><primary>GUID</primary></indexterm>）。
    此标识符是一个128位的数量，由选择的算法生成，使得在已知宇宙中使用相同算法生成相同标识符的可能性非常小。
    因此，对于分布式系统，这些标识符提供比序列生成器更好的唯一性保证，后者仅在单个数据库内是唯一的。
</para>
<!-- pgdoc-cn_end sig_en=b3e7aac4a6d81aa23d728dbdd595eb0d -->

<!-- pgdoc-cn_start sig_en=b62cc3b6d794cb6172286f15c4602afd sig_cn_org=None source=14.1 
   <para>
    A UUID is written as a sequence of lower-case hexadecimal digits,
    in several groups separated by hyphens, specifically a group of 8
    digits followed by three groups of 4 digits followed by a group of
    12 digits, for a total of 32 digits representing the 128 bits.  An
    example of a UUID in this standard form is:
<programlisting>
a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11
</programlisting>
    <productname>PostgreSQL</productname> also accepts the following
    alternative forms for input:
    use of upper-case digits, the standard format surrounded by
    braces, omitting some or all hyphens, adding a hyphen after any
    group of four digits.  Examples are:
<programlisting>
A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11
{a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11}
a0eebc999c0b4ef8bb6d6bb9bd380a11
a0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11
{a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11}
</programlisting>
    Output is always in the standard form.
   </para>
________________________________________________________-->
   <para>
    一个UUID被写成一个小写十六进制位的序列，该序列被连字符分隔成多个组：首先是一个8位组，接下来是三个4位组，最后是一个12位组。总共的32位（十六进制位）表示了128个二进制位。一个标准形式的UUID类似于：
<programlisting>
a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11
</programlisting>
    <productname>PostgreSQL</productname>也接受另一种输入形式：
    使用大写位、标准格式被花括号包围、忽略某些或者全部连字符、在任意4位组后面增加一个连字符。例如：
<programlisting>
A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11
{a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11}
a0eebc999c0b4ef8bb6d6bb9bd380a11
a0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11
{a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11}
</programlisting>
    输出总是采用标准形式。
   </para>
<!-- pgdoc-cn_end sig_en=b62cc3b6d794cb6172286f15c4602afd -->

<!-- pgdoc-cn_start sig_en=36175f160c954b2af85cf5a26a936b1a sig_cn_org=None source=14.1 
   <para>
    See <xref linkend="functions-uuid"/> for how to generate a UUID in
    <productname>PostgreSQL</productname>.
   </para>
________________________________________________________-->
   <para>
    对于如何在<productname>PostgreSQL</productname>中生成UUID，请参见 <xref linkend="functions-uuid"/> 。
   </para>
<!-- pgdoc-cn_end sig_en=36175f160c954b2af85cf5a26a936b1a -->
  </sect1>

  <sect1 id="datatype-xml">
<!-- pgdoc-cn_start sig_en=d5f0c47cdf6871a933def6b54f773b20 sig_cn_org=None source=14.1 
   <title><acronym>XML</acronym> Type</title>
________________________________________________________-->
   <title><acronym>XML</acronym>类型</title>
<!-- pgdoc-cn_end sig_en=d5f0c47cdf6871a933def6b54f773b20 -->

<!-- pgdoc-cn_start sig_en=36e7eebbebd64121418861c767cb2b02 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-xml">
    <primary>XML</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-xml">
    <primary>XML</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=36e7eebbebd64121418861c767cb2b02 -->

<!-- pgdoc-cn_start sig_en=fda5db6b1cb6061e75a97603b8339305 sig_cn_org=None source=14.1 
   <para>
    The <type>xml</type> data type can be used to store XML data.  Its
    advantage over storing XML data in a <type>text</type> field is that it
    checks the input values for well-formedness, and there are support
    functions to perform type-safe operations on it; see <xref
    linkend="functions-xml"/>.  Use of this data type requires the
    installation to have been built with <command>configure
    -&minus;with-libxml</command>.
   </para>
________________________________________________________-->
   <para>
    <type>xml</type>数据类型可以被用来存储XML数据。它比直接在一个<type>text</type>域中存储XML数据的优势在于，它会检查输入值的结构是不是良好，并且有支持函数用于在其上执行类型安全的操作，参见<xref linkend="functions-xml"/>。使用这种数据类型要求在安装时用<command>configure --with-libxml</command>选项编译。
   </para>
<!-- pgdoc-cn_end sig_en=fda5db6b1cb6061e75a97603b8339305 -->

<!-- pgdoc-cn_start sig_en=57f6ba2929296f6fa8a718d50f58f3f7 sig_cn_org=None source=14.1 
   <para>
    The <type>xml</type> type can store well-formed
    <quote>documents</quote>, as defined by the XML standard, as well
    as <quote>content</quote> fragments, which are defined by reference
    to the more permissive
    <ulink url="https://www.w3.org/TR/2010/REC-xpath-datamodel-20101214/#DocumentNode"><quote>document node</quote></ulink>
    of the XQuery and XPath data model.
    Roughly, this means that content fragments can have
    more than one top-level element or character node.  The expression
    <literal><replaceable>xmlvalue</replaceable> IS DOCUMENT</literal>
    can be used to evaluate whether a particular <type>xml</type>
    value is a full document or only a content fragment.
   </para>
________________________________________________________-->
   <para>
    <type>xml</type>类型可以存储格式良好的遵循XML标准定义的<quote>文档</quote>，以及<quote>内容</quote>片段，它是通过引用更宽泛的<ulink url="https://www.w3.org/TR/2010/REC-xpath-datamodel-20101214/#DocumentNode"><quote>document node</quote></ulink> XQuery 和 XPath 数据模型来定义的。
    大致上说，这意味着内容片段中可以有多于一个的顶层元素或字符节点。
	表达式<literal><replaceable>xmlvalue</replaceable> IS DOCUMENT</literal>可以被用来评估一个特定的<type>xml</type>值是一个完整文档或者仅仅是一个文档片段。
   </para>
<!-- pgdoc-cn_end sig_en=57f6ba2929296f6fa8a718d50f58f3f7 -->

<!-- pgdoc-cn_start sig_en=469477a7a9454b54d68902c5de07dd63 sig_cn_org=None source=14.1 
   <para>
    Limits and compatibility notes for the <type>xml</type> data type
    can be found in <xref linkend="xml-limits-conformance"/>.
   </para>
________________________________________________________-->
   <para>
    <type>xml</type> 数据类型的限制和兼容性说明可以在 <xref linkend="xml-limits-conformance"/>中找到.
   </para>
<!-- pgdoc-cn_end sig_en=469477a7a9454b54d68902c5de07dd63 -->

   <sect2>
<!-- pgdoc-cn_start sig_en=06d3c1597746cc158b0ae906b4cf4b59 sig_cn_org=None source=14.1 
    <title>Creating XML Values</title>
________________________________________________________-->
    <title>创建XML值</title>
<!-- pgdoc-cn_end sig_en=06d3c1597746cc158b0ae906b4cf4b59 -->
<!-- pgdoc-cn_start sig_en=abe04ce11e6ea70864dbc78b373cdefc sig_cn_org=None source=14.1 
   <para>
    To produce a value of type <type>xml</type> from character data,
    use the function
    <function>xmlparse</function>:<indexterm><primary>xmlparse</primary></indexterm>
<synopsis>
XMLPARSE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable>)
</synopsis>
    Examples:
<programlisting><![CDATA[
XMLPARSE (DOCUMENT '<?xml version="1.0"?><book><title>Manual</title><chapter>...</chapter></book>')
XMLPARSE (CONTENT 'abc<foo>bar</foo><bar>foo</bar>')
]]></programlisting>
    While this is the only way to convert character strings into XML
    values according to the SQL standard, the PostgreSQL-specific
    syntaxes:
<programlisting><![CDATA[
xml '<foo>bar</foo>'
'<foo>bar</foo>'::xml
]]></programlisting>
    can also be used.
   </para>
________________________________________________________-->
   <para>
    要从字符数据中生成一个<type>xml</type>类型的值，可以使用函数<function>xmlparse</function>:<indexterm><primary>xmlparse</primary></indexterm>
<synopsis>
XMLPARSE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable>)
</synopsis>
    例子：
<programlisting><![CDATA[
XMLPARSE (DOCUMENT '<?xml version="1.0"?><book><title>Manual</title><chapter>...</chapter></book>')
XMLPARSE (CONTENT 'abc<foo>bar</foo><bar>foo</bar>')
]]></programlisting>
    然而根据SQL标准这是唯一将字符串转换为XML值的方法，PostgreSQL特有的语法：
<programlisting><![CDATA[
xml '<foo>bar</foo>'
'<foo>bar</foo>'::xml
]]></programlisting>
    也可以被使用。
   </para>
<!-- pgdoc-cn_end sig_en=abe04ce11e6ea70864dbc78b373cdefc -->

<!-- pgdoc-cn_start sig_en=35eb3536cdb747150f34eac55818003f sig_cn_org=None source=14.1 
   <para>
    The <type>xml</type> type does not validate input values
    against a document type declaration
    (DTD),<indexterm><primary>DTD</primary></indexterm>
    even when the input value specifies a DTD.
    There is also currently no built-in support for validating against
    other XML schema languages such as XML Schema.
   </para>
________________________________________________________-->
   <para>
    即便输入值指定了一个文档类型声明（DTD），<type>xml</type>类型也不根据DTD来验证输入值<indexterm><primary>DTD</primary></indexterm>。目前也没有内建的支持用于根据其他XML模式语言（如XML模式）来进行验证。
   </para>
<!-- pgdoc-cn_end sig_en=35eb3536cdb747150f34eac55818003f -->

<!-- pgdoc-cn_start sig_en=f5b5fffd39b67b7c3b2e294156a1bbe8 sig_cn_org=None source=14.1 
   <para>
    The inverse operation, producing a character string value from
    <type>xml</type>, uses the function
    <function>xmlserialize</function>:<indexterm><primary>xmlserialize</primary></indexterm>
<synopsis>
XMLSERIALIZE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable> AS <replaceable>type</replaceable> )
</synopsis>
    <replaceable>type</replaceable> can be
    <type>character</type>, <type>character varying</type>, or
    <type>text</type> (or an alias for one of those).  Again, according
    to the SQL standard, this is the only way to convert between type
    <type>xml</type> and character types, but PostgreSQL also allows
    you to simply cast the value.
   </para>
________________________________________________________-->
   <para>
    作为一个逆操作，从<type>xml</type>产生一个字符串可以使用函数<function>xmlserialize</function>:<indexterm><primary>xmlserialize</primary></indexterm>
<synopsis>
XMLSERIALIZE ( { DOCUMENT | CONTENT } <replaceable>value</replaceable> AS <replaceable>type</replaceable> )
</synopsis>
    <replaceable>type</replaceable>可以是
    <type>character</type>、<type>character varying</type>或
    <type>text</type>（或者其中之一的一个别名）。再次地，根据SQL标准，这也是在<type>xml</type>类型和字符类型间做转换的唯一方法，但是PostgreSQL也允许你简单地造型这些值。
   </para>
<!-- pgdoc-cn_end sig_en=f5b5fffd39b67b7c3b2e294156a1bbe8 -->

<!-- pgdoc-cn_start sig_en=f2525323a313225f15fa4103fcd57649 sig_cn_org=None source=14.1 
   <para>
    When a character string value is cast to or from type
    <type>xml</type> without going through <type>XMLPARSE</type> or
    <type>XMLSERIALIZE</type>, respectively, the choice of
    <literal>DOCUMENT</literal> versus <literal>CONTENT</literal> is
    determined by the <quote>XML option</quote>
    <indexterm><primary>XML option</primary></indexterm>
    session configuration parameter, which can be set using the
    standard command:
<synopsis>
SET XML OPTION { DOCUMENT | CONTENT };
</synopsis>
    or the more PostgreSQL-like syntax
<synopsis>
SET xmloption TO { DOCUMENT | CONTENT };
</synopsis>
    The default is <literal>CONTENT</literal>, so all forms of XML
    data are allowed.
   </para>
________________________________________________________-->
   <para>
    当一个字符串不是使用<type>XMLPARSE</type>造型成<type>xml</type>或者不是使用<type>XMLSERIALIZE</type>从<type>xml</type>造型得到，对于<literal>DOCUMENT</literal>和<literal>CONTENT</literal>两者的选择是根据<quote>XML option</quote>
    <indexterm><primary>XML option</primary></indexterm>会话配置参数决定的，它可以使用标准命令来设置：
<synopsis>
SET XML OPTION { DOCUMENT | CONTENT };
</synopsis>
    或者是更具有PostgreSQL风格的语法
<synopsis>
SET xmloption TO { DOCUMENT | CONTENT };
</synopsis>
    默认值是<literal>CONTENT</literal>，因此所有形式的XML数据都被允许。
   </para>
<!-- pgdoc-cn_end sig_en=f2525323a313225f15fa4103fcd57649 -->

   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=ec68c7f8554c9c3978d34049daf0e3bc sig_cn_org=None source=14.1 
    <title>Encoding Handling</title>
________________________________________________________-->
    <title>编码处理</title>
<!-- pgdoc-cn_end sig_en=ec68c7f8554c9c3978d34049daf0e3bc -->
<!-- pgdoc-cn_start sig_en=71a7ae3b946105578ba5e187658b86ff sig_cn_org=None source=14.1 
   <para>
    Care must be taken when dealing with multiple character encodings
    on the client, server, and in the XML data passed through them.
    When using the text mode to pass queries to the server and query
    results to the client (which is the normal mode), PostgreSQL
    converts all character data passed between the client and the
    server and vice versa to the character encoding of the respective
    end; see <xref linkend="multibyte"/>.  This includes string
    representations of XML values, such as in the above examples.
    This would ordinarily mean that encoding declarations contained in
    XML data can become invalid as the character data is converted
    to other encodings while traveling between client and server,
    because the embedded encoding declaration is not changed.  To cope
    with this behavior, encoding declarations contained in
    character strings presented for input to the <type>xml</type> type
    are <emphasis>ignored</emphasis>, and content is assumed
    to be in the current server encoding.  Consequently, for correct
    processing, character strings of XML data must be sent
    from the client in the current client encoding.  It is the
    responsibility of the client to either convert documents to the
    current client encoding before sending them to the server, or to
    adjust the client encoding appropriately.  On output, values of
    type <type>xml</type> will not have an encoding declaration, and
    clients should assume all data is in the current client
    encoding.
   </para>
________________________________________________________-->
   <para>
    在客户端、服务器以及其中流过的XML数据上处理多字符编码时必须要注意。在使用文本模式向服务器传递查询以及向客户端传递查询结果（在普通模式）时，PostgreSQL将所有在客户端和服务器之间传递的字符数据转换为目标端的字符编码，参见<xref linkend="multibyte"/>。这也包括了表示XML值的串，正如上面的例子所述。这也通常意味着由于字符数据会在客户端和服务器之间传递时被转换成其他编码，包含在XML数据中的编码声明可能是无效的，因为内嵌的编码声明没有被改变。为了处理这种行为，包含在表示<type>xml</type>类型输入的字符串中包含的编码声明会被<emphasis>忽略</emphasis>，并且其内容被假定为当前服务器的编码。接着，为了正确处理，XML数据的字符串必须以当前客户端编码从客户端发出。客户端负责在把文档发送给服务器之前将它们转换为当前客户端编码，或者适当地调整客户端编码。在输出时，<type>xml</type>类型的值将不会有一个编码声明，并且客户端将会假设所有数据都是当前客户端编码。
   </para>
<!-- pgdoc-cn_end sig_en=71a7ae3b946105578ba5e187658b86ff -->

<!-- pgdoc-cn_start sig_en=56d23fc61b974848e0fe6d2358f960bd sig_cn_org=None source=14.1 
   <para>
    When using binary mode to pass query parameters to the server
    and query results back to the client, no encoding conversion
    is performed, so the situation is different.  In this case, an
    encoding declaration in the XML data will be observed, and if it
    is absent, the data will be assumed to be in UTF-8 (as required by
    the XML standard; note that PostgreSQL does not support UTF-16).
    On output, data will have an encoding declaration
    specifying the client encoding, unless the client encoding is
    UTF-8, in which case it will be omitted.
   </para>
________________________________________________________-->
   <para>
    在使用二进制模式传送查询参数给服务器以及传回查询结果给客户端时，不会执行编码转换，因此情况就有所不同。在这种情况下，XML数据中的编码声明将被注意到，并且如果缺少编码声明时该数据会被假定为UTF-8（由于XML标准的要求，注意PostgreSQL不支持UTF-16）。在输出时，数据将会有一个编码声明来指定客户端编码，除非客户端编码为UTF-8（这种情况下编码声明会被忽略）。
   </para>
<!-- pgdoc-cn_end sig_en=56d23fc61b974848e0fe6d2358f960bd -->

<!-- pgdoc-cn_start sig_en=4b84065ccb420aee692354de78225f94 sig_cn_org=None source=14.1 
   <para>
    Needless to say, processing XML data with PostgreSQL will be less
    error-prone and more efficient if the XML data encoding, client encoding,
    and server encoding are the same.  Since XML data is internally
    processed in UTF-8, computations will be most efficient if the
    server encoding is also UTF-8.
   </para>
________________________________________________________-->
   <para>
    不用说，在PostgreSQL中处理XML数据产生错误的可能性更小，并且在XML数据编码、客户端编码和服务器编码三者相同时效率更高。因为XML数据在内部是以UTF-8处理的，如果服务器编码也是UTF-8时，计算效率将会最高。
   </para>
<!-- pgdoc-cn_end sig_en=4b84065ccb420aee692354de78225f94 -->

   <caution>
<!-- pgdoc-cn_start sig_en=b2628c62f7eb1b6a29c4146b53813161 sig_cn_org=None source=14.1 
    <para>
     Some XML-related functions may not work at all on non-ASCII data
     when the server encoding is not UTF-8.  This is known to be an
     issue for <function>xmltable()</function> and <function>xpath()</function> in particular.
    </para>
________________________________________________________-->
    <para>
     当服务器编码不是UTF-8时，某些XML相关的函数可能在非ASCII数据上完全无法工作。尤其在<function>xmltable()</function>和<function>xpath()</function>上，这是一个已知的问题。
    </para>
<!-- pgdoc-cn_end sig_en=b2628c62f7eb1b6a29c4146b53813161 -->
   </caution>
   </sect2>

   <sect2>
<!-- pgdoc-cn_start sig_en=e3f71a8303a04061bb9a9e113b98e570 sig_cn_org=None source=14.1 
   <title>Accessing XML Values</title>
________________________________________________________-->
   <title>访问XML值</title>
<!-- pgdoc-cn_end sig_en=e3f71a8303a04061bb9a9e113b98e570 -->

<!-- pgdoc-cn_start sig_en=5e3862be8a946fce4d93fb38ec06bf86 sig_cn_org=None source=14.1 
   <para>
    The <type>xml</type> data type is unusual in that it does not
    provide any comparison operators.  This is because there is no
    well-defined and universally useful comparison algorithm for XML
    data.  One consequence of this is that you cannot retrieve rows by
    comparing an <type>xml</type> column against a search value.  XML
    values should therefore typically be accompanied by a separate key
    field such as an ID.  An alternative solution for comparing XML
    values is to convert them to character strings first, but note
    that character string comparison has little to do with a useful
    XML comparison method.
   </para>
________________________________________________________-->
   <para>
    <type>xml</type>数据类型有些不同寻常，因为它不提供任何比较操作符。这是因为对于XML数据不存在良定义的和通用的比较算法。这种状况造成的后果就是，你无法通过比较一个<type>xml</type>和一个搜索值来检索行。XML值因此通常应该伴随着一个独立键值域，如一个ID。另一种比较XML值的方案是将它们先转换为字符串，但注意字符串比较对于XML比较方法没有什么帮助。
   </para>
<!-- pgdoc-cn_end sig_en=5e3862be8a946fce4d93fb38ec06bf86 -->

<!-- pgdoc-cn_start sig_en=30c4618da988ccc032f81bed90c2b0f9 sig_cn_org=None source=14.1 
   <para>
    Since there are no comparison operators for the <type>xml</type>
    data type, it is not possible to create an index directly on a
    column of this type.  If speedy searches in XML data are desired,
    possible workarounds include casting the expression to a
    character string type and indexing that, or indexing an XPath
    expression.  Of course, the actual query would have to be adjusted
    to search by the indexed expression.
   </para>
________________________________________________________-->
   <para>
    由于没有可以用于<type>xml</type>数据类型的比较操作符，因此无法直接在这种类型上创建索引。如果需要在XML中快速的搜索，可能的解决方案包括将表达式造型为一个字符串类型然后索引之，或者在一个XPath表达式上索引。当然，实际的查询必须被调整为使用被索引的表达式。
   </para>
<!-- pgdoc-cn_end sig_en=30c4618da988ccc032f81bed90c2b0f9 -->

<!-- pgdoc-cn_start sig_en=e1c45b9425e85c7eefb102ec22d73dce sig_cn_org=None source=14.1 
   <para>
    The text-search functionality in PostgreSQL can also be used to speed
    up full-document searches of XML data.  The necessary
    preprocessing support is, however, not yet available in the PostgreSQL
    distribution.
   </para>
________________________________________________________-->
   <para>
    PostgreSQL中的文本搜索功能也可以被用来加速XML数据的全文搜索。但是，所需的预处理支持目前在PostgreSQL发布中还不可用。
   </para>
<!-- pgdoc-cn_end sig_en=e1c45b9425e85c7eefb102ec22d73dce -->
   </sect2>
  </sect1>

  &json;

  &array;

  &rowtypes;

  &rangetypes;

  <sect1 id="domains">
<!-- pgdoc-cn_start sig_en=eb9d4a434faaeb2f594740cc0101bc54 sig_cn_org=None source=14.1 
   <title>Domain Types</title>
________________________________________________________-->
   <title>域类型</title>
<!-- pgdoc-cn_end sig_en=eb9d4a434faaeb2f594740cc0101bc54 -->

<!-- pgdoc-cn_start sig_en=bbe629c2efa68b642142fbfdf8c80aba sig_cn_org=None source=14.1 
   <indexterm zone="domains">
    <primary>domain</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="domains">
    <primary>domain</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=bbe629c2efa68b642142fbfdf8c80aba -->

<!-- pgdoc-cn_start sig_en=87480f94b65084ee25e3e33dfb28af2a sig_cn_org=None source=14.1 
   <indexterm zone="domains">
    <primary>data type</primary>
    <secondary>domain</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="domains">
    <primary>data type</primary>
    <secondary>domain</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=87480f94b65084ee25e3e33dfb28af2a -->

<!-- pgdoc-cn_start sig_en=a822275e40aefaf32cece8117e5eaed5 sig_cn_org=None source=14.1 
   <para>
    A <firstterm>domain</firstterm> is a user-defined data type that is
    based on another <firstterm>underlying type</firstterm>.  Optionally,
    it can have constraints that restrict its valid values to a subset of
    what the underlying type would allow.  Otherwise it behaves like the
    underlying type &mdash; for example, any operator or function that
    can be applied to the underlying type will work on the domain type.
    The underlying type can be any built-in or user-defined base type,
    enum type, array type, composite type, range type, or another domain.
   </para>
________________________________________________________-->
   <para>
    <firstterm>域</firstterm>是一种用户定义的数据类型，它基于另一种<firstterm>底层类型</firstterm>。根据需要，它可以有约束来限制其有效值为底层类型所允许值的一个子集。如果没有约束，它的行为就和底层类型一样 &mdash; 例如，任何适用于底层类型的操作符或函数都对该域类型有效。底层类型可以是任何内建或者用户定义的基础类型、枚举类型、数组类型、组合类型、范围类型或者另一个域。
   </para>
<!-- pgdoc-cn_end sig_en=a822275e40aefaf32cece8117e5eaed5 -->

<!-- pgdoc-cn_start sig_en=d229303d845db53e71cc774ebd0de61c sig_cn_org=None source=14.1 
   <para>
    For example, we could create a domain over integers that accepts only
    positive integers:
<programlisting>
CREATE DOMAIN posint AS integer CHECK (VALUE &gt; 0);
CREATE TABLE mytable (id posint);
INSERT INTO mytable VALUES(1);   -&minus; works
INSERT INTO mytable VALUES(-1);  -&minus; fails
</programlisting>
   </para>
________________________________________________________-->
   <para>
    例如，我们可以在整数之上创建一个域，它只接受正整数：
<programlisting>
CREATE DOMAIN posint AS integer CHECK (VALUE &gt; 0);
CREATE TABLE mytable (id posint);
INSERT INTO mytable VALUES(1);   -- works
INSERT INTO mytable VALUES(-1);  -- fails
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=d229303d845db53e71cc774ebd0de61c -->

<!-- pgdoc-cn_start sig_en=f20e3379de236cf59974869ee53bfbd2 sig_cn_org=None source=14.1 
   <para>
    When an operator or function of the underlying type is applied to a
    domain value, the domain is automatically down-cast to the underlying
    type.  Thus, for example, the result of <literal>mytable.id - 1</literal>
    is considered to be of type <type>integer</type> not <type>posint</type>.
    We could write <literal>(mytable.id - 1)::posint</literal> to cast the
    result back to <type>posint</type>, causing the domain's constraints
    to be rechecked.  In this case, that would result in an error if the
    expression had been applied to an <structfield>id</structfield> value of
    1.  Assigning a value of the underlying type to a field or variable of
    the domain type is allowed without writing an explicit cast, but the
    domain's constraints will be checked.
   </para>
________________________________________________________-->
   <para>
    当底层类型的一个操作符或函数适用于一个域值时，域会被自动向下造型为底层类型。因此，<literal>mytable.id - 1</literal>的结果会被认为是类型<type>integer</type>而不是<type>posint</type>。我们可以写成<literal>(mytable.id - 1)::posint</literal>来把结果转换回<type>posint</type>，这会导致域的约束被重新检查。在这种情况下，如果该表达式被应用于一个值为1的<structfield>id</structfield>就会错误。把底层类型的值赋给域类型的一个字段或者变量不需要写显式的造型，但是域的约束将会被检查。
   </para>
<!-- pgdoc-cn_end sig_en=f20e3379de236cf59974869ee53bfbd2 -->

<!-- pgdoc-cn_start sig_en=cb27cd3410abacc9f59c4b36a073c7dc sig_cn_org=None source=14.1 
   <para>
    For additional information see <xref linkend="sql-createdomain"/>.
   </para>
________________________________________________________-->
   <para>
    更多信息请参考<xref linkend="sql-createdomain"/>。
   </para>
<!-- pgdoc-cn_end sig_en=cb27cd3410abacc9f59c4b36a073c7dc -->
  </sect1>

  <sect1 id="datatype-oid">
<!-- pgdoc-cn_start sig_en=74b434f1193fcc88fb30543c06c4c690 sig_cn_org=None source=14.1 
   <title>Object Identifier Types</title>
________________________________________________________-->
   <title>对象标识符类型</title>
<!-- pgdoc-cn_end sig_en=74b434f1193fcc88fb30543c06c4c690 -->

<!-- pgdoc-cn_start sig_en=995535ed30230361655a582df5deb34a sig_cn_org=None source=14.1 
   <indexterm zone="datatype-oid">
    <primary>object identifier</primary>
    <secondary>data type</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>对象标识符</primary>
    <secondary>数据类型</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=995535ed30230361655a582df5deb34a -->

<!-- pgdoc-cn_start sig_en=b26b202d6fd75aab231f1bd7fd09ae88 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-oid">
    <primary>oid</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>oid</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=b26b202d6fd75aab231f1bd7fd09ae88 -->

<!-- pgdoc-cn_start sig_en=1227e686e3b3620e8901c11c78666a09 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-oid">
    <primary>regclass</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>regclass</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=1227e686e3b3620e8901c11c78666a09 -->

<!-- pgdoc-cn_start sig_en=bfe1c4242cfad9580e3caf4964926257 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-oid">
    <primary>regcollation</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>regcollation</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=bfe1c4242cfad9580e3caf4964926257 -->

<!-- pgdoc-cn_start sig_en=ed3367efc6da82f585b425a19aa4b6a7 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-oid">
    <primary>regconfig</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>regconfig</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=ed3367efc6da82f585b425a19aa4b6a7 -->

<!-- pgdoc-cn_start sig_en=565f018aeec4e0a287b1939b5c99ff6d sig_cn_org=None source=14.1 
   <indexterm zone="datatype-oid">
    <primary>regdictionary</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>regdictionary</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=565f018aeec4e0a287b1939b5c99ff6d -->

<!-- pgdoc-cn_start sig_en=df9c6ebb641de9c72651e4c991578300 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-oid">
    <primary>regnamespace</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>regnamespace</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=df9c6ebb641de9c72651e4c991578300 -->

<!-- pgdoc-cn_start sig_en=29d97fdc2c3a34c073484645305d96f1 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-oid">
    <primary>regoper</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>regoper</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=29d97fdc2c3a34c073484645305d96f1 -->

<!-- pgdoc-cn_start sig_en=3aeb72c7c1bef288d8876be7ab8a8ddb sig_cn_org=None source=14.1 
   <indexterm zone="datatype-oid">
    <primary>regoperator</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>regoperator</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=3aeb72c7c1bef288d8876be7ab8a8ddb -->

<!-- pgdoc-cn_start sig_en=c2905b6814ac55b1a0bf73c1eef45aa3 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-oid">
    <primary>regproc</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>regproc</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=c2905b6814ac55b1a0bf73c1eef45aa3 -->

<!-- pgdoc-cn_start sig_en=0b6e46806295c3ba66cc5f306d9b5199 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-oid">
    <primary>regprocedure</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>regprocedure</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=0b6e46806295c3ba66cc5f306d9b5199 -->

<!-- pgdoc-cn_start sig_en=ad7771941d2657b691e5aed5f83eda3e sig_cn_org=None source=14.1 
   <indexterm zone="datatype-oid">
    <primary>regrole</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>regrole</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=ad7771941d2657b691e5aed5f83eda3e -->

<!-- pgdoc-cn_start sig_en=472f9533aa56a06e6232353211d41431 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-oid">
    <primary>regtype</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>regtype</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=472f9533aa56a06e6232353211d41431 -->

<!-- pgdoc-cn_start sig_en=b878b63731a096157b68815bf06a59e5 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-oid">
    <primary>xid8</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>xid8</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=b878b63731a096157b68815bf06a59e5 -->

<!-- pgdoc-cn_start sig_en=cf5ed896b1781678eeaac6310b6fc8e1 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-oid">
    <primary>cid</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>cid</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=cf5ed896b1781678eeaac6310b6fc8e1 -->

<!-- pgdoc-cn_start sig_en=dd8000913f85fbf825309a87644bd683 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-oid">
    <primary>tid</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>tid</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=dd8000913f85fbf825309a87644bd683 -->

<!-- pgdoc-cn_start sig_en=5f606ae366c71696db3fd555e040f427 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-oid">
    <primary>xid</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-oid">
    <primary>xid</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=5f606ae366c71696db3fd555e040f427 -->

<!-- pgdoc-cn_start sig_en=37c0278970ed5aa470ea22d4ff613e99 sig_cn_org=None source=14.1 
   <para>
    Object identifiers (OIDs) are used internally by
    <productname>PostgreSQL</productname> as primary keys for various
    system tables.
    Type <type>oid</type> represents an object identifier.  There are also
    several alias types for <type>oid</type>, each
    named <type>reg<replaceable>something</replaceable></type>.
    <xref linkend="datatype-oid-table"/> shows an
    overview.
   </para>
________________________________________________________-->
   <para>
    对象标识符（OID）被<productname>PostgreSQL</productname>用来在内部作为多个系统表的主键。
    类型<type>oid</type>表示一个对象标识符。
    也有多个<type>oid</type>的别名类型分别被命名为<type>reg<replaceable>something</replaceable></type>。
    <xref linkend="datatype-oid-table"/>显示了一个概览。
   </para>
<!-- pgdoc-cn_end sig_en=37c0278970ed5aa470ea22d4ff613e99 -->

<!-- pgdoc-cn_start sig_en=86441b482dbcca2e5714ebc2ac9087ef sig_cn_org=None source=14.1 
   <para>
    The <type>oid</type> type is currently implemented as an unsigned
    four-byte integer.  Therefore, it is not large enough to provide
    database-wide uniqueness in large databases, or even in large
    individual tables.
   </para>
________________________________________________________-->
   <para>
    <type>oid</type>类型目前被实现为一个无符号4字节整数。
	因此，在大型数据库中它并不足以提供数据库范围内的唯一性，甚至在一些大型的表中也无法提供表范围内的唯一性。
   </para>
<!-- pgdoc-cn_end sig_en=86441b482dbcca2e5714ebc2ac9087ef -->

<!-- pgdoc-cn_start sig_en=440fdb1dc9fb19da35bbc82e51c90108 sig_cn_org=None source=14.1 
   <para>
    The <type>oid</type> type itself has few operations beyond comparison.
    It can be cast to integer, however, and then manipulated using the
    standard integer operators.  (Beware of possible
    signed-versus-unsigned confusion if you do this.)
   </para>
________________________________________________________-->
   <para>
    <type>oid</type>类型本身除了比较之外只有很少的操作。不过，它可以被造型成整数，并且接着可以使用标准的整数操作符进行操纵（这样做时要注意有符号和无符号之间可能出现的混乱）。
   </para>
<!-- pgdoc-cn_end sig_en=440fdb1dc9fb19da35bbc82e51c90108 -->

<!-- pgdoc-cn_start sig_en=3619dcad50bf33a032565cda3634bc7c sig_cn_org=None source=14.1 
   <para>
    The OID alias types have no operations of their own except
    for specialized input and output routines.  These routines are able
    to accept and display symbolic names for system objects, rather than
    the raw numeric value that type <type>oid</type> would use.  The alias
    types allow simplified lookup of OID values for objects.  For example,
    to examine the <structname>pg_attribute</structname> rows related to a table
    <literal>mytable</literal>, one could write:
<programlisting>
SELECT * FROM pg_attribute WHERE attrelid = 'mytable'::regclass;
</programlisting>
    rather than:
<programlisting>
SELECT * FROM pg_attribute
  WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'mytable');
</programlisting>
    While that doesn't look all that bad by itself, it's still oversimplified.
    A far more complicated sub-select would be needed to
    select the right OID if there are multiple tables named
    <literal>mytable</literal> in different schemas.
    The <type>regclass</type> input converter handles the table lookup according
    to the schema path setting, and so it does the <quote>right thing</quote>
    automatically.  Similarly, casting a table's OID to
    <type>regclass</type> is handy for symbolic display of a numeric OID.
   </para>
________________________________________________________-->
   <para>
    OID的别名类型除了特定的输入和输出例程之外没有别的操作。这些例程可以接受并显示系统对象的符号名，而不是类型<type>oid</type>使用的原始数字值。别名类型使查找对象的OID值变得简单。例如，要检查与一个表<literal>mytable</literal>有关的<structname>pg_attribute</structname>行，你可以写：
<programlisting>
SELECT * FROM pg_attribute WHERE attrelid = 'mytable'::regclass;
</programlisting>
    而不是：
<programlisting>
SELECT * FROM pg_attribute
  WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'mytable');
</programlisting>
    虽然从它本身看起来并没有那么糟，它仍然被过度简化了。如果有多个名为<literal>mytable</literal>的表存在于不同的模式中，就可能需要一个更复杂的子选择来选择右边的OID。<type>regclass</type>输入转换器会根据模式路径设置处理表查找，并且因此它会自动地完成这种<quote>右边的事情</quote>。类似地，对于一个数字OID的符号化显示可以很方便地通过将表OID造型成<type>regclass</type>来实现。
   </para>
<!-- pgdoc-cn_end sig_en=3619dcad50bf33a032565cda3634bc7c -->

    <table id="datatype-oid-table">
<!-- pgdoc-cn_start sig_en=74b434f1193fcc88fb30543c06c4c690 sig_cn_org=None source=14.1 
     <title>Object Identifier Types</title>
________________________________________________________-->
     <title>对象标识符类型</title>
<!-- pgdoc-cn_end sig_en=74b434f1193fcc88fb30543c06c4c690 -->
     <tgroup cols="4">
      <thead>
<!-- pgdoc-cn_start sig_en=f8d0647c06eec84b9e86397826aea439 sig_cn_org=None source=14.1 
       <row>
        <entry>Name</entry>
        <entry>References</entry>
        <entry>Description</entry>
        <entry>Value Example</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>名字</entry>
        <entry>引用</entry>
        <entry>描述</entry>
        <entry>值示例</entry>
       </row>
<!-- pgdoc-cn_end sig_en=f8d0647c06eec84b9e86397826aea439 -->
      </thead>

      <tbody>

<!-- pgdoc-cn_start sig_en=f44a31ad014f6def051c72ce1df83ddf sig_cn_org=None source=14.1 
       <row>
        <entry><type>oid</type></entry>
        <entry>any</entry>
        <entry>numeric object identifier</entry>
        <entry><literal>564182</literal></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>oid</type></entry>
        <entry>任意</entry>
        <entry>数字形式的对象标识符</entry>
        <entry><literal>564182</literal></entry>
       </row>
<!-- pgdoc-cn_end sig_en=f44a31ad014f6def051c72ce1df83ddf -->

<!-- pgdoc-cn_start sig_en=3bdda296a13f8664ece2b80d2a01f5fd sig_cn_org=None source=14.1 
       <row>
        <entry><type>regclass</type></entry>
        <entry><structname>pg_class</structname></entry>
        <entry>relation name</entry>
        <entry><literal>pg_type</literal></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>regclass</type></entry>
        <entry><structname>pg_class</structname></entry>
        <entry>关系名字</entry>
        <entry><literal>pg_type</literal></entry>
       </row>
<!-- pgdoc-cn_end sig_en=3bdda296a13f8664ece2b80d2a01f5fd -->

<!-- pgdoc-cn_start sig_en=7cb4a9e5903d0d68dd11055e34a8cc0e sig_cn_org=None source=14.1 
       <row>
        <entry><type>regcollation</type></entry>
        <entry><structname>pg_collation</structname></entry>
        <entry>collation name</entry>
        <entry><literal>"POSIX"</literal></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>regcollation</type></entry>
        <entry><structname>pg_collation</structname></entry>
        <entry>排序规则名称</entry>
        <entry><literal>"POSIX"</literal></entry>
       </row>
<!-- pgdoc-cn_end sig_en=7cb4a9e5903d0d68dd11055e34a8cc0e -->

<!-- pgdoc-cn_start sig_en=4acbc34759922bf7157400d751a21166 sig_cn_org=None source=14.1 
       <row>
        <entry><type>regconfig</type></entry>
        <entry><structname>pg_ts_config</structname></entry>
        <entry>text search configuration</entry>
        <entry><literal>english</literal></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>regconfig</type></entry>
        <entry><structname>pg_ts_config</structname></entry>
        <entry>文本搜索配置</entry>
        <entry><literal>english</literal></entry>
       </row>
<!-- pgdoc-cn_end sig_en=4acbc34759922bf7157400d751a21166 -->

<!-- pgdoc-cn_start sig_en=0d03b70f123d70793b993897f6e380dc sig_cn_org=None source=14.1 
       <row>
        <entry><type>regdictionary</type></entry>
        <entry><structname>pg_ts_dict</structname></entry>
        <entry>text search dictionary</entry>
        <entry><literal>simple</literal></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>regdictionary</type></entry>
        <entry><structname>pg_ts_dict</structname></entry>
        <entry>文本搜索字典</entry>
        <entry><literal>simple</literal></entry>
       </row>
<!-- pgdoc-cn_end sig_en=0d03b70f123d70793b993897f6e380dc -->

<!-- pgdoc-cn_start sig_en=a57ec60e0d1bbfe73ebf64b5e09c9487 sig_cn_org=None source=14.1 
       <row>
        <entry><type>regnamespace</type></entry>
        <entry><structname>pg_namespace</structname></entry>
        <entry>namespace name</entry>
        <entry><literal>pg_catalog</literal></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>regnamespace</type></entry>
        <entry><structname>pg_namespace</structname></entry>
        <entry>命名空间名称</entry>
        <entry><literal>pg_catalog</literal></entry>
       </row>
<!-- pgdoc-cn_end sig_en=a57ec60e0d1bbfe73ebf64b5e09c9487 -->

<!-- pgdoc-cn_start sig_en=a03139036008f76a05ae389940c5cfd9 sig_cn_org=None source=14.1 
       <row>
        <entry><type>regoper</type></entry>
        <entry><structname>pg_operator</structname></entry>
        <entry>operator name</entry>
        <entry><literal>+</literal></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>regoper</type></entry>
        <entry><structname>pg_operator</structname></entry>
        <entry>操作符名字</entry>
        <entry><literal>+</literal></entry>
       </row>
<!-- pgdoc-cn_end sig_en=a03139036008f76a05ae389940c5cfd9 -->

<!-- pgdoc-cn_start sig_en=97df28a0f5003df17bfa9f866151b752 sig_cn_org=None source=14.1 
       <row>
        <entry><type>regoperator</type></entry>
        <entry><structname>pg_operator</structname></entry>
        <entry>operator with argument types</entry>
        <entry><literal>*(integer,&zwsp;integer)</literal>
         or <literal>-(NONE,&zwsp;integer)</literal></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>regoperator</type></entry>
        <entry><structname>pg_operator</structname></entry>
        <entry>带参数类型的操作符</entry>
        <entry><literal>*(integer,&zwsp;integer)</literal>
         or <literal>-(NONE,&zwsp;integer)</literal></entry>
       </row>
<!-- pgdoc-cn_end sig_en=97df28a0f5003df17bfa9f866151b752 -->

<!-- pgdoc-cn_start sig_en=207042d35cdacd8f556a87323983d2ac sig_cn_org=None source=14.1 
       <row>
        <entry><type>regproc</type></entry>
        <entry><structname>pg_proc</structname></entry>
        <entry>function name</entry>
        <entry><literal>sum</literal></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>regproc</type></entry>
        <entry><structname>pg_proc</structname></entry>
        <entry>函数名字</entry>
        <entry><literal>sum</literal></entry>
       </row>
<!-- pgdoc-cn_end sig_en=207042d35cdacd8f556a87323983d2ac -->

<!-- pgdoc-cn_start sig_en=0e3f050cdae06c0fed63b8ae556e3157 sig_cn_org=None source=14.1 
       <row>
        <entry><type>regprocedure</type></entry>
        <entry><structname>pg_proc</structname></entry>
        <entry>function with argument types</entry>
        <entry><literal>sum(int4)</literal></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>regprocedure</type></entry>
        <entry><structname>pg_proc</structname></entry>
        <entry>函数与参数类型</entry>
        <entry><literal>sum(int4)</literal></entry>
       </row>
<!-- pgdoc-cn_end sig_en=0e3f050cdae06c0fed63b8ae556e3157 -->

<!-- pgdoc-cn_start sig_en=eecdb002f1a85bb3d4afd5b044608de2 sig_cn_org=None source=14.1 
       <row>
        <entry><type>regrole</type></entry>
        <entry><structname>pg_authid</structname></entry>
        <entry>role name</entry>
        <entry><literal>smithee</literal></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>regrole</type></entry>
        <entry><structname>pg_authid</structname></entry>
        <entry>角色名</entry>
        <entry><literal>smithee</literal></entry>
       </row>
<!-- pgdoc-cn_end sig_en=eecdb002f1a85bb3d4afd5b044608de2 -->

<!-- pgdoc-cn_start sig_en=06f2034d77830a02c35b0a2a74d258f6 sig_cn_org=None source=14.1 
       <row>
        <entry><type>regtype</type></entry>
        <entry><structname>pg_type</structname></entry>
        <entry>data type name</entry>
        <entry><literal>integer</literal></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>regtype</type></entry>
        <entry><structname>pg_type</structname></entry>
        <entry>数据类型名称</entry>
        <entry><literal>integer</literal></entry>
       </row>
<!-- pgdoc-cn_end sig_en=06f2034d77830a02c35b0a2a74d258f6 -->
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=f2dc854835b7242bb0705e70c4d5938d sig_cn_org=None source=14.1 
   <para>
    All of the OID alias types for objects that are grouped by namespace
    accept schema-qualified names, and will
    display schema-qualified names on output if the object would not
    be found in the current search path without being qualified.
    For example, <literal>myschema.mytable</literal> is acceptable input
    for <type>regclass</type> (if there is such a table).  That value
    might be output as <literal>myschema.mytable</literal>, or
    just <literal>mytable</literal>, depending on the current search path.
    The <type>regproc</type> and <type>regoper</type> alias types will only
    accept input names that are unique (not overloaded), so they are
    of limited use; for most uses <type>regprocedure</type> or
    <type>regoperator</type> are more appropriate.  For <type>regoperator</type>,
    unary operators are identified by writing <literal>NONE</literal> for the unused
    operand.
   </para>
________________________________________________________-->
   <para>
    按命名空间分组的对象的所有OID别名类型都接受模式限定名称，如果在当前搜索路径中找不到未经限定的对象，则将在输出中显示模式限定名称。例如，<literal>myschema.mytable</literal>是<type>regclass</type>的可接受输入（如果存在这样的表）。该值可能输出为<literal>myschema.mytable</literal>，或仅为<literal>mytable</literal>，具体取决于当前搜索路径。<type>regproc</type>和<type>regoper</type>别名类型将只接受唯一（未重载）的输入名称，因此它们的用途有限；对于大多数用途，<type>regprocedure</type>或<type>regoperator</type> 更合适。对于<type>regoperator</type>，通过为未使用的操作数写入<literal>NONE</literal>来标识一元操作符。
   </para>
<!-- pgdoc-cn_end sig_en=f2dc854835b7242bb0705e70c4d5938d -->

<!-- pgdoc-cn_start sig_en=03d57baa35328d95c7e550cafb550fa9 sig_cn_org=None source=14.1 
   <para>
    The input functions for these types allow whitespace between tokens,
    and will fold upper-case letters to lower case, except within double
    quotes; this is done to make the syntax rules similar to the way
    object names are written in SQL.  Conversely, the output functions
    will use double quotes if needed to make the output be a valid SQL
    identifier.  For example, the OID of a function
    named <literal>Foo</literal> (with upper case <literal>F</literal>)
    taking two integer arguments could be entered as
    <literal>' "Foo" ( int, integer ) '::regprocedure</literal>.  The
    output would look like <literal>"Foo"(integer,integer)</literal>.
    Both the function name and the argument type names could be
    schema-qualified, too.
   </para>
________________________________________________________-->
   <para>
    这些类型的输入函数允许标记之间使用空格，并将大写字母折叠为小写字母，双引号除外；这样做是为了使语法规则类似于在SQL中编写对象名的方式。相反，如果需要使输出成为有效的SQL标识符，输出函数将使用双引号。例如，一个名为<literal>Foo</literal>（大写<literal>F</literal>）且有两个整数参数的函数的OID可以输入为<literal>' "Foo" ( int, integer ) '::regprocedure</literal>。输出看起来像<literal>"Foo"(integer,integer)</literal>。函数名和参数类型名也可以是模式限定的。
   </para>
<!-- pgdoc-cn_end sig_en=03d57baa35328d95c7e550cafb550fa9 -->

<!-- pgdoc-cn_start sig_en=919894644cd789ff47ac43bb9fc0b2a8 sig_cn_org=None source=14.1 
   <para>
    Many built-in <productname>PostgreSQL</productname> functions accept
    the OID of a table, or another kind of database object, and for
    convenience are declared as taking <type>regclass</type> (or the
    appropriate OID alias type).  This means you do not have to look up
    the object's OID by hand, but can just enter its name as a string
    literal.  For example, the <function>nextval(regclass)</function> function
    takes a sequence relation's OID, so you could call it like this:
<programlisting>
nextval('foo')              <lineannotation>operates on sequence <literal>foo</literal></lineannotation>
nextval('FOO')              <lineannotation>same as above</lineannotation>
nextval('"Foo"')            <lineannotation>operates on sequence <literal>Foo</literal></lineannotation>
nextval('myschema.foo')     <lineannotation>operates on <literal>myschema.foo</literal></lineannotation>
nextval('"myschema".foo')   <lineannotation>same as above</lineannotation>
nextval('foo')              <lineannotation>searches search path for <literal>foo</literal></lineannotation>
</programlisting>
   </para>
________________________________________________________-->
   <para>
    许多内置的<productname>PostgreSQL</productname> 函数接受表的OID或其他类型的数据库对象，为了方便起见，将其声明为采用<type>regclass</type>（或适当的OID别名类型）。这意味着你不必手动查找对象的OID，只需将其名称作为字符串文字输入即可。例如，<function>nextval(regclass)</function> 函数接受序列关系的OID，因此你可以这样调用它：
<programlisting>
nextval('foo')              <lineannotation>按顺序操作<literal>foo</literal></lineannotation>
nextval('FOO')              <lineannotation>同上</lineannotation>
nextval('"Foo"')            <lineannotation>按顺序操作<literal>Foo</literal></lineannotation>
nextval('myschema.foo')     <lineannotation>操作于<literal>myschema.foo</literal></lineannotation>
nextval('"myschema".foo')   <lineannotation>同上</lineannotation>
nextval('foo')              <lineannotation>查找搜索路径为<literal>foo</literal></lineannotation>
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=919894644cd789ff47ac43bb9fc0b2a8 -->

   <note>
<!-- pgdoc-cn_start sig_en=ebd70f8435aab426149a188bb98756d1 sig_cn_org=None source=14.1 
    <para>
     When you write the argument of such a function as an unadorned
     literal string, it becomes a constant of type <type>regclass</type>
     (or the appropriate type).
     Since this is really just an OID, it will track the originally
     identified object despite later renaming, schema reassignment,
     etc.  This <quote>early binding</quote> behavior is usually desirable for
     object references in column defaults and views.  But sometimes you might
     want <quote>late binding</quote> where the object reference is resolved
     at run time.  To get late-binding behavior, force the constant to be
     stored as a <type>text</type> constant instead of <type>regclass</type>:
<programlisting>
nextval('foo'::text)      <lineannotation><literal>foo</literal> is looked up at runtime</lineannotation>
</programlisting>
     The <function>to_regclass()</function> function and its siblings
     can also be used to perform run-time lookups.  See
     <xref linkend="functions-info-catalog-table"/>.
    </para>
________________________________________________________-->
    <para>
     当你将此类函数的参数编写为未经修饰的文字字符串时，它将成为<type>regclass</type>（或适当类型）类型的常量。
     由于这实际上只是一个OID，因此它将跟踪最初标识的对象，哪怕他后来进行了重命名，模式重新分配等。这种 <quote>早期绑定</quote>行为通常适用于列默认值和视图中的对象引用。但有时你可能需要<quote>后期绑定</quote>在运行时解析对象引用。要获取后期绑定行为，请强制将常量存储为<type>text</type>常量，而不是<type>regclass</type>：
<programlisting>
nextval('foo'::text)      <lineannotation><literal>foo</literal>运行时被查找</lineannotation>
</programlisting>
     <function>to_regclass()</function>函数及其同级函数也可用于执行运行时查找。请参见 <xref linkend="functions-info-catalog-table"/>。
    </para>
<!-- pgdoc-cn_end sig_en=ebd70f8435aab426149a188bb98756d1 -->
   </note>

<!-- pgdoc-cn_start sig_en=9557e1466fcbd1a06b1e22a35656d1f2 sig_cn_org=None source=14.1 
   <para>
    Another practical example of use of <type>regclass</type>
    is to look up the OID of a table listed in
    the <literal>information_schema</literal> views, which don't supply
    such OIDs directly.  One might for example wish to call
    the <function>pg_relation_size()</function> function, which requires
    the table OID.  Taking the above rules into account, the correct way
    to do that is
<programlisting>
SELECT table_schema, table_name,
       pg_relation_size((quote_ident(table_schema) || '.' ||
                         quote_ident(table_name))::regclass)
FROM information_schema.tables
WHERE ...
</programlisting>
    The <function>quote_ident()</function> function will take care of
    double-quoting the identifiers where needed.  The seemingly easier
<programlisting>
SELECT pg_relation_size(table_name)
FROM information_schema.tables
WHERE ...
</programlisting>
    is <emphasis>not recommended</emphasis>, because it will fail for
    tables that are outside your search path or have names that require
    quoting.
   </para>
________________________________________________________-->
   <para>
    使用<type>regclass</type>的另一个实际示例是查找<literal>information_schema</literal>视图中列出的表的OID，这些视图不直接提供此类OID。例如，你可能希望调用<function>pg_relation_size()</function> 函数，这需要表OID。考虑到上述规则，正确的方法是：
<programlisting>
SELECT table_schema, table_name,
       pg_relation_size((quote_ident(table_schema) || '.' ||
                         quote_ident(table_name))::regclass)
FROM information_schema.tables
WHERE ...
</programlisting>
    <function>quote_ident()</function>函数将负责在需要时将标识符加上双引号。看起来更容易的
<programlisting>
SELECT pg_relation_size(table_name)
FROM information_schema.tables
WHERE ...
</programlisting>
    是<emphasis>不建议使用的</emphasis>，因为对于搜索路径之外的表或名称需要引号的表，它将失败。
   </para>
<!-- pgdoc-cn_end sig_en=9557e1466fcbd1a06b1e22a35656d1f2 -->

<!-- pgdoc-cn_start sig_en=6b4ef59713cd8419f0177208166428fe sig_cn_org=None source=14.1 
   <para>
    An additional property of most of the OID alias types is the creation of
    dependencies.  If a
    constant of one of these types appears in a stored expression
    (such as a column default expression or view), it creates a dependency
    on the referenced object.  For example, if a column has a default
    expression <literal>nextval('my_seq'::regclass)</literal>,
    <productname>PostgreSQL</productname>
    understands that the default expression depends on the sequence
    <literal>my_seq</literal>, so the system will not let the sequence
    be dropped without first removing the default expression.  The
    alternative of <literal>nextval('my_seq'::text)</literal> does not
    create a dependency.
    (<type>regrole</type> is an exception to this property. Constants of this
    type are not allowed in stored expressions.)
   </para>
________________________________________________________-->
   <para>
    大多数OID别名类型的另一个特性是创建依赖项。如果这些类型中的一个常量出现在存储的表达式（如一个列的默认表达式或视图）中，它将创建对引用对象的依赖关系。例如，如果列具有默认表达式<literal>nextval('my_seq'::regclass)</literal>，<productname>PostgreSQL</productname>知道默认表达式取决于序列<literal>my_seq</literal>，因此系统只允许在首先删除默认表达式的情况下才能删除序列。<literal>nextval('my_seq'::text)</literal>的替代方法不会创建依赖项。（<type>regrole</type>是此属性的例外。存储表达式中不允许使用此类型的常量。）
   </para>
<!-- pgdoc-cn_end sig_en=6b4ef59713cd8419f0177208166428fe -->

<!-- pgdoc-cn_start sig_en=fabea7b4525478d1cb733f6c342cba5a sig_cn_org=None source=14.1 
   <para>
    Another identifier type used by the system is <type>xid</type>, or transaction
    (abbreviated <abbrev>xact</abbrev>) identifier.  This is the data type of the system columns
    <structfield>xmin</structfield> and <structfield>xmax</structfield>.  Transaction identifiers are 32-bit quantities.
    In some contexts, a 64-bit variant <type>xid8</type> is used.  Unlike
    <type>xid</type> values, <type>xid8</type> values increase strictly
    monotonically and cannot be reused in the lifetime of a database cluster.
   </para>
________________________________________________________-->
   <para>
    另一种系统中使用的标识符类型是<type>xid</type>，或者称为事务（简写为<abbrev>xact</abbrev>）标识符。
    这是系统列<structfield>xmin</structfield>和<structfield>xmax</structfield>使用的数据类型。事务标识符是32位量。
    在某种情况下，使用64位变量<type>xid8</type>。
    不像<type>xid</type>值，<type>xid8</type>值严格单调地增加，并且不能在数据库集群的生命周期中重用。
   </para>
<!-- pgdoc-cn_end sig_en=fabea7b4525478d1cb733f6c342cba5a -->

<!-- pgdoc-cn_start sig_en=ed235954688927c7a9b6776823d28696 sig_cn_org=None source=14.1 
   <para>
    A third identifier type used by the system is <type>cid</type>, or
    command identifier.  This is the data type of the system columns
    <structfield>cmin</structfield> and <structfield>cmax</structfield>. Command identifiers are also 32-bit quantities.
   </para>
________________________________________________________-->
   <para>
    系统使用的第三种标识符类型是<type>cid</type>，或者称为命令标识符。这是系统列<structfield>cmin</structfield>和<structfield>cmax</structfield>使用的数据类型。命令标识符也是32位量。
   </para>
<!-- pgdoc-cn_end sig_en=ed235954688927c7a9b6776823d28696 -->

<!-- pgdoc-cn_start sig_en=85f0e0b458ad52c9ca53384cd4de1b30 sig_cn_org=None source=14.1 
   <para>
    A final identifier type used by the system is <type>tid</type>, or tuple
    identifier (row identifier).  This is the data type of the system column
    <structfield>ctid</structfield>.  A tuple ID is a pair
    (block number, tuple index within block) that identifies the
    physical location of the row within its table.
   </para>
________________________________________________________-->
   <para>
    系统使用的最后一种标识符类型是<type>tid</type>，或者称为元组标识符（行标识符）。这是系统列<structfield>ctid</structfield>使用的数据类型。一个元组ID是一个（块号，块内元组索引）对，它标识了行在它的表中的物理位置。
   </para>
<!-- pgdoc-cn_end sig_en=85f0e0b458ad52c9ca53384cd4de1b30 -->

<!-- pgdoc-cn_start sig_en=6eae3ee457c290f553a97ae01963a221 sig_cn_org=None source=14.1 
   <para>
    (The system columns are further explained in <xref
    linkend="ddl-system-columns"/>.)
   </para>
________________________________________________________-->
   <para>
    （这些系统列在<xref linkend="ddl-system-columns"/>中有进一步的解释）。
   </para>
<!-- pgdoc-cn_end sig_en=6eae3ee457c290f553a97ae01963a221 -->
  </sect1>

  <sect1 id="datatype-pg-lsn">
<!-- pgdoc-cn_start sig_en=47be41a74e4ca2e925c04169f8987fb4 sig_cn_org=None source=14.1 
   <title><type>pg_lsn</type> Type</title>
________________________________________________________-->
   <title><type>pg_lsn</type> 类型</title>
<!-- pgdoc-cn_end sig_en=47be41a74e4ca2e925c04169f8987fb4 -->

<!-- pgdoc-cn_start sig_en=7de51a8b247e8eb4c2020c3def3b877b sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pg-lsn">
    <primary>pg_lsn</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pg-lsn">
    <primary>pg_lsn</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=7de51a8b247e8eb4c2020c3def3b877b -->

<!-- pgdoc-cn_start sig_en=4f55ab8c471a5656466bcf09efc8fd78 sig_cn_org=None source=14.1 
   <para>
    The <type>pg_lsn</type> data type can be used to store LSN (Log Sequence
    Number) data which is a pointer to a location in the WAL. This type is a
    representation of <type>XLogRecPtr</type> and an internal system type of
    <productname>PostgreSQL</productname>.
   </para>
________________________________________________________-->
   <para>
    <type>pg_lsn</type>数据类型可以被用来存储 LSN（日志序列号）数据，LSN 是一个指向WAL中的位置的指针。这个类型是<type>XLogRecPtr</type>的一种表达并且是
    <productname>PostgreSQL</productname>的一种内部系统类型。
   </para>
<!-- pgdoc-cn_end sig_en=4f55ab8c471a5656466bcf09efc8fd78 -->

<!-- pgdoc-cn_start sig_en=e634dde8e76f0ab27c3400876cc16c91 sig_cn_org=None source=14.1 
   <para>
    Internally, an LSN is a 64-bit integer, representing a byte position in
    the write-ahead log stream.  It is printed as two hexadecimal numbers of
    up to 8 digits each, separated by a slash; for example,
    <literal>16/B374D848</literal>.  The <type>pg_lsn</type> type supports the
    standard comparison operators, like <literal>=</literal> and
    <literal>&gt;</literal>.  Two LSNs can be subtracted using the
    <literal>-</literal> operator; the result is the number of bytes separating
    those write-ahead log locations.  Also the number of bytes can be
    added into and subtracted from LSN using the
    <literal>+(pg_lsn,numeric)</literal> and
    <literal>-(pg_lsn,numeric)</literal> operators, respectively. Note that
    the calculated LSN should be in the range of <type>pg_lsn</type> type,
    i.e., between <literal>0/0</literal> and
    <literal>FFFFFFFF/FFFFFFFF</literal>.
   </para>
________________________________________________________-->
   <para>
    在内部，一个 LSN 是一个 64 位整数，表示在预写式日志流中的一个字节位置。它被打印成
    两个最高 8 位的十六进制数，中间用斜线分隔，例如<literal>16/B374D848</literal>。
    <type>pg_lsn</type>类型支持标准的比较操作符，如<literal>=</literal>和
    <literal>&gt;</literal>。两个 LSN 可以用<literal>-</literal>操作符做减法，
    结果将是分隔两个预写式日志位置的字节数。此外，还可以分别使用<literal>+(pg_lsn,numeric)</literal>和<literal>-(pg_lsn,numeric)</literal> 运算符在LSN中添加和减去字节数。请注意，计算过的LSN应在<type>pg_lsn</type> 类型的范围内，即<literal>0/0</literal>和<literal>FFFFFFFF/FFFFFFFF</literal>.之间。
   </para>
<!-- pgdoc-cn_end sig_en=e634dde8e76f0ab27c3400876cc16c91 -->
  </sect1>

  <sect1 id="datatype-pseudo">
<!-- pgdoc-cn_start sig_en=1ff242f3573cca9dfa269ccdd9e2b15b sig_cn_org=None source=14.1 
   <title>Pseudo-Types</title>
________________________________________________________-->
   <title>伪类型</title>
<!-- pgdoc-cn_end sig_en=1ff242f3573cca9dfa269ccdd9e2b15b -->

<!-- pgdoc-cn_start sig_en=9037bff166ee2ff326c136be57fdc325 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>record</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>record</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=9037bff166ee2ff326c136be57fdc325 -->

<!-- pgdoc-cn_start sig_en=f1402c9f74a9626363017708a52419b9 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>any</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>any</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=f1402c9f74a9626363017708a52419b9 -->

<!-- pgdoc-cn_start sig_en=1579f395fba32cc6d3d5a04f682e708d sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>anyelement</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>anyelement</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=1579f395fba32cc6d3d5a04f682e708d -->

<!-- pgdoc-cn_start sig_en=bf95be7345f3025940bd51e6a8719db1 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>anyarray</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>anyarray</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=bf95be7345f3025940bd51e6a8719db1 -->

<!-- pgdoc-cn_start sig_en=0c34ce925c39e316e9af1216c957958b sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>anynonarray</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>anynonarray</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=0c34ce925c39e316e9af1216c957958b -->

<!-- pgdoc-cn_start sig_en=cf2e65e041efee922b948441068ba61d sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>anyenum</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>anyenum</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=cf2e65e041efee922b948441068ba61d -->

<!-- pgdoc-cn_start sig_en=d332f66e980de77b40233ff5da8138cb sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>anyrange</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>anyrange</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=d332f66e980de77b40233ff5da8138cb -->

<!-- pgdoc-cn_start sig_en=60096ed779dc2bc31656a9dac55ee1c8 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>anymultirange</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>anymultirange</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=60096ed779dc2bc31656a9dac55ee1c8 -->

<!-- pgdoc-cn_start sig_en=d8e6ac5ceda03c58fac276e91d0e27c2 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>anycompatible</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>anycompatible</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=d8e6ac5ceda03c58fac276e91d0e27c2 -->

<!-- pgdoc-cn_start sig_en=2f72cf1100ff116cedd7999408bf3823 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>anycompatiblearray</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>anycompatiblearray</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=2f72cf1100ff116cedd7999408bf3823 -->

<!-- pgdoc-cn_start sig_en=a44be7938bcd8eaa7dad6727c5abafb0 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>anycompatiblenonarray</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>anycompatiblenonarray</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=a44be7938bcd8eaa7dad6727c5abafb0 -->

<!-- pgdoc-cn_start sig_en=a2d162df3f5c7d2e84fb2e9ffb6c05fa sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>anycompatiblerange</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>anycompatiblerange</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=a2d162df3f5c7d2e84fb2e9ffb6c05fa -->

<!-- pgdoc-cn_start sig_en=5d9332120f5f31c46674adfcdc02610e sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>anycompatiblemultirange</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>anycompatiblemultirange</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=5d9332120f5f31c46674adfcdc02610e -->

<!-- pgdoc-cn_start sig_en=245be44773276e01051f31e52b63e4d4 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>void</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>void</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=245be44773276e01051f31e52b63e4d4 -->

<!-- pgdoc-cn_start sig_en=6ceb67d1e7ead4306949f99e0d1fc582 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>trigger</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>trigger</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=6ceb67d1e7ead4306949f99e0d1fc582 -->

<!-- pgdoc-cn_start sig_en=6c43c38723e2f5227249803ebf0bef42 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>event_trigger</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>event_trigger</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=6c43c38723e2f5227249803ebf0bef42 -->

<!-- pgdoc-cn_start sig_en=7090d71ef359ec2e92df50ea4081c434 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>pg_ddl_command</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>pg_ddl_command</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=7090d71ef359ec2e92df50ea4081c434 -->

<!-- pgdoc-cn_start sig_en=8524f9c558b4c150bf8befca2d1a7ada sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>language_handler</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>language_handler</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=8524f9c558b4c150bf8befca2d1a7ada -->

<!-- pgdoc-cn_start sig_en=b1956083c1ca01bfa7a9202b0b971d74 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>fdw_handler</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>fdw_handler</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=b1956083c1ca01bfa7a9202b0b971d74 -->

<!-- pgdoc-cn_start sig_en=637255e7301feca1c538c6218755e6bf sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>table_am_handler</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>table_am_handler</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=637255e7301feca1c538c6218755e6bf -->

<!-- pgdoc-cn_start sig_en=8feb9701614870da9dce6c8921162da7 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>index_am_handler</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>index_am_handler</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=8feb9701614870da9dce6c8921162da7 -->

<!-- pgdoc-cn_start sig_en=bdaabce270addd852ab29fb08a8ff55a sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>tsm_handler</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>tsm_handler</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=bdaabce270addd852ab29fb08a8ff55a -->

<!-- pgdoc-cn_start sig_en=3e13a38334dbbdc2233b705d7ce5068c sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>cstring</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>cstring</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=3e13a38334dbbdc2233b705d7ce5068c -->

<!-- pgdoc-cn_start sig_en=97a5aa2e9d9eba75b262549b019d55b5 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>internal</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>internal</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=97a5aa2e9d9eba75b262549b019d55b5 -->

<!-- pgdoc-cn_start sig_en=0a1c1cdf15403037cfdf05470c2f3139 sig_cn_org=None source=14.1 
   <indexterm zone="datatype-pseudo">
    <primary>unknown</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="datatype-pseudo">
    <primary>unknown</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=0a1c1cdf15403037cfdf05470c2f3139 -->

<!-- pgdoc-cn_start sig_en=274241cdc730403f57bfee700c254133 sig_cn_org=None source=14.1 
   <para>
    The <productname>PostgreSQL</productname> type system contains a
    number of special-purpose entries that are collectively called
    <firstterm>pseudo-types</firstterm>.  A pseudo-type cannot be used as a
    column data type, but it can be used to declare a function's
    argument or result type.  Each of the available pseudo-types is
    useful in situations where a function's behavior does not
    correspond to simply taking or returning a value of a specific
    <acronym>SQL</acronym> data type.  <xref
    linkend="datatype-pseudotypes-table"/> lists the existing
    pseudo-types.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>类型系统包含了一些特殊目的的项，它们被统称为<firstterm>伪类型</firstterm>。一个伪类型不能被用作一个列的数据类型，但是它可以被用来定义一个函数的参数或者结果类型。每一种可用的伪类型都有其可以发挥作用的情况，这些情况的特点是一个函数的行为并不能符合于简单使用或者返回一种特定<acronym>SQL</acronym>数据类型的值。<xref linkend="datatype-pseudotypes-table"/>列出了现有的伪类型。
   </para>
<!-- pgdoc-cn_end sig_en=274241cdc730403f57bfee700c254133 -->

    <table id="datatype-pseudotypes-table">
<!-- pgdoc-cn_start sig_en=1ff242f3573cca9dfa269ccdd9e2b15b sig_cn_org=None source=14.1 
     <title>Pseudo-Types</title>
________________________________________________________-->
     <title>伪类型</title>
<!-- pgdoc-cn_end sig_en=1ff242f3573cca9dfa269ccdd9e2b15b -->
     <tgroup cols="2">
      <colspec colname="col1" colwidth="2*"/>
      <colspec colname="col2" colwidth="3*"/>
      <thead>
<!-- pgdoc-cn_start sig_en=03e0d819510e3f9125691a63a170e08d sig_cn_org=None source=14.1 
       <row>
        <entry>Name</entry>
        <entry>Description</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>名字</entry>
        <entry>描述</entry>
       </row>
<!-- pgdoc-cn_end sig_en=03e0d819510e3f9125691a63a170e08d -->
      </thead>

      <tbody>
<!-- pgdoc-cn_start sig_en=d5d27ceacbdb841d0d7d8d023c43c9dd sig_cn_org=None source=14.1 
       <row>
        <entry><type>any</type></entry>
        <entry>Indicates that a function accepts any input data type.</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>any</type></entry>
        <entry>表示一个函数可以接受任意输入数据类型。</entry>
       </row>
<!-- pgdoc-cn_end sig_en=d5d27ceacbdb841d0d7d8d023c43c9dd -->

<!-- pgdoc-cn_start sig_en=c17621f6b9b396c2b6abd7bd30ced218 sig_cn_org=None source=14.1 
       <row>
        <entry><type>anyelement</type></entry>
        <entry>Indicates that a function accepts any data type
        (see <xref linkend="extend-types-polymorphic"/>).</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>anyelement</type></entry>
        <entry>表示一个函数可以接受任意数据类型（参见<xref linkend="extend-types-polymorphic"/>）。</entry>
       </row>
<!-- pgdoc-cn_end sig_en=c17621f6b9b396c2b6abd7bd30ced218 -->

<!-- pgdoc-cn_start sig_en=0ec53d985ba1f1bb48701cbeac0524d8 sig_cn_org=None source=14.1 
       <row>
        <entry><type>anyarray</type></entry>
        <entry>Indicates that a function accepts any array data type
        (see <xref linkend="extend-types-polymorphic"/>).</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>anyarray</type></entry>
        <entry>表示一个函数可以接受任意数组数据类型（参见<xref linkend="extend-types-polymorphic"/>）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=0ec53d985ba1f1bb48701cbeac0524d8 -->

<!-- pgdoc-cn_start sig_en=5b8b8f7c6b814398b32a60d139267873 sig_cn_org=None source=14.1 
       <row>
        <entry><type>anynonarray</type></entry>
        <entry>Indicates that a function accepts any non-array data type
        (see <xref linkend="extend-types-polymorphic"/>).</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>anynonarray</type></entry>
        <entry>表示一个函数可以接受任意非数组数据类型（参见<xref linkend="extend-types-polymorphic"/>）。</entry>
       </row>
<!-- pgdoc-cn_end sig_en=5b8b8f7c6b814398b32a60d139267873 -->

<!-- pgdoc-cn_start sig_en=5c1f7c986a0aaca61bc787ac3356e6fa sig_cn_org=None source=14.1 
       <row>
        <entry><type>anyenum</type></entry>
        <entry>Indicates that a function accepts any enum data type
        (see <xref linkend="extend-types-polymorphic"/> and
        <xref linkend="datatype-enum"/>).</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>anyenum</type></entry>
        <entry>表示一个函数可以接受任意枚举数据类型（参见<xref linkend="extend-types-polymorphic"/>和<xref linkend="datatype-enum"/>）。</entry>
       </row>
<!-- pgdoc-cn_end sig_en=5c1f7c986a0aaca61bc787ac3356e6fa -->

<!-- pgdoc-cn_start sig_en=bda8a27cfad8b9a4feeb411f0f831a0d sig_cn_org=None source=14.1 
       <row>
        <entry><type>anyrange</type></entry>
        <entry>Indicates that a function accepts any range data type
        (see <xref linkend="extend-types-polymorphic"/> and
        <xref linkend="rangetypes"/>).</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>anyrange</type></entry>
        <entry>表示一个函数可以接受任意范围数据类型（参见<xref linkend="extend-types-polymorphic"/>和<xref linkend="rangetypes"/>）。</entry>
       </row>
<!-- pgdoc-cn_end sig_en=bda8a27cfad8b9a4feeb411f0f831a0d -->

<!-- pgdoc-cn_start sig_en=ebc7a8cf6ae74fc5d99ae4232ead463e sig_cn_org=None source=14.1 
       <row>
        <entry><type>anymultirange</type></entry>
        <entry>Indicates that a function accepts any multirange data type
        (see <xref linkend="extend-types-polymorphic"/> and
        <xref linkend="rangetypes"/>).</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>anymultirange</type></entry>
        <entry>表示函数接受任何多范围数据类型
        (参见 <xref linkend="extend-types-polymorphic"/> 和
        <xref linkend="rangetypes"/>).</entry>
       </row>
<!-- pgdoc-cn_end sig_en=ebc7a8cf6ae74fc5d99ae4232ead463e -->

<!-- pgdoc-cn_start sig_en=8b2e26b82a861d14669cbf11ebb33b89 sig_cn_org=None source=14.1 
       <row>
        <entry><type>anycompatible</type></entry>
        <entry>Indicates that a function accepts any data type,
        with automatic promotion of multiple arguments to a common data type
        (see <xref linkend="extend-types-polymorphic"/>).</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>anycompatible</type></entry>
        <entry>指示函数接受任何数据类型，并自动将多个参数提升为通用数据类型
        (参见 <xref linkend="extend-types-polymorphic"/>).</entry>
       </row>
<!-- pgdoc-cn_end sig_en=8b2e26b82a861d14669cbf11ebb33b89 -->

<!-- pgdoc-cn_start sig_en=4fc5904fe9cc5be1b83f022ee6a67c6a sig_cn_org=None source=14.1 
       <row>
        <entry><type>anycompatiblearray</type></entry>
        <entry>Indicates that a function accepts any array data type,
        with automatic promotion of multiple arguments to a common data type
        (see <xref linkend="extend-types-polymorphic"/>).</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>anycompatiblearray</type></entry>
        <entry>指示函数接受任何数组数据类型，并自动将多个参数提升为通用数据类型
        (参见 <xref linkend="extend-types-polymorphic"/>).</entry>
       </row>
<!-- pgdoc-cn_end sig_en=4fc5904fe9cc5be1b83f022ee6a67c6a -->

<!-- pgdoc-cn_start sig_en=52989615005deb35a03e7f6a065f60cf sig_cn_org=None source=14.1 
       <row>
        <entry><type>anycompatiblenonarray</type></entry>
        <entry>Indicates that a function accepts any non-array data type,
        with automatic promotion of multiple arguments to a common data type
        (see <xref linkend="extend-types-polymorphic"/>).</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>anycompatiblenonarray</type></entry>
        <entry>指示函数接受任何非数组数据类型，并将多个参数自动提升为通用数据类型
        (参见 <xref linkend="extend-types-polymorphic"/>).</entry>
       </row>
<!-- pgdoc-cn_end sig_en=52989615005deb35a03e7f6a065f60cf -->

<!-- pgdoc-cn_start sig_en=1c14cf2f5bb6fc79d128c6c1f5ae34cc sig_cn_org=None source=14.1 
       <row>
        <entry><type>anycompatiblerange</type></entry>
        <entry>Indicates that a function accepts any range data type,
        with automatic promotion of multiple arguments to a common data type
        (see <xref linkend="extend-types-polymorphic"/> and
        <xref linkend="rangetypes"/>).</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>anycompatiblerange</type></entry>
        <entry>指示函数接受任何范围数据类型，并将多个参数自动提升为通用数据类型
        (参见 <xref linkend="extend-types-polymorphic"/> and
        <xref linkend="rangetypes"/>).</entry>
       </row>
<!-- pgdoc-cn_end sig_en=1c14cf2f5bb6fc79d128c6c1f5ae34cc -->

<!-- pgdoc-cn_start sig_en=dd28d1cc0f22b4a784c907995b72c8cd sig_cn_org=None source=14.1 
       <row>
        <entry><type>anycompatiblemultirange</type></entry>
        <entry>Indicates that a function accepts any multirange data type,
        with automatic promotion of multiple arguments to a common data type
        (see <xref linkend="extend-types-polymorphic"/> and
        <xref linkend="rangetypes"/>).</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>anycompatiblemultirange</type></entry>
        <entry>表示函数接受任何多范围数据类型，并自动将多个参数升级为公共数据类型
        (参见 <xref linkend="extend-types-polymorphic"/> 和
        <xref linkend="rangetypes"/>).</entry>
       </row>
<!-- pgdoc-cn_end sig_en=dd28d1cc0f22b4a784c907995b72c8cd -->

<!-- pgdoc-cn_start sig_en=c75647f54bacfb692e984cc7f4855624 sig_cn_org=None source=14.1 
       <row>
        <entry><type>cstring</type></entry>
        <entry>Indicates that a function accepts or returns a null-terminated C string.</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>cstring</type></entry>
        <entry>表示一个函数接受或者返回一个非空结尾的C字符串。</entry>
       </row>
<!-- pgdoc-cn_end sig_en=c75647f54bacfb692e984cc7f4855624 -->

<!-- pgdoc-cn_start sig_en=4cbe229589bf8761ccfeb800d1143e42 sig_cn_org=None source=14.1 
       <row>
        <entry><type>internal</type></entry>
        <entry>Indicates that a function accepts or returns a server-internal
        data type.</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>internal</type></entry>
        <entry>表示一个函数接受或返回一个服务器内部数据类型。</entry>
       </row>
<!-- pgdoc-cn_end sig_en=4cbe229589bf8761ccfeb800d1143e42 -->

<!-- pgdoc-cn_start sig_en=b2c5ddea6a2344945396665d3f5168e2 sig_cn_org=None source=14.1 
       <row>
        <entry><type>language_handler</type></entry>
        <entry>A procedural language call handler is declared to return <type>language_handler</type>.</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>language_handler</type></entry>
        <entry>一个被声明为返回<type>language_handler</type>的过程语言调用处理器。</entry>
       </row>
<!-- pgdoc-cn_end sig_en=b2c5ddea6a2344945396665d3f5168e2 -->

<!-- pgdoc-cn_start sig_en=a1c445ab02188d27ea79cecdf474011a sig_cn_org=None source=14.1 
       <row>
        <entry><type>fdw_handler</type></entry>
        <entry>A foreign-data wrapper handler is declared to return <type>fdw_handler</type>.</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>fdw_handler</type></entry>
        <entry>一个被声明为返回<type>fdw_handler</type>的外部数据包装器处理器。</entry>
       </row>
<!-- pgdoc-cn_end sig_en=a1c445ab02188d27ea79cecdf474011a -->

<!-- pgdoc-cn_start sig_en=fe3f9485098cbddaf1b77247c7153a1a sig_cn_org=None source=14.1 
       <row>
        <entry><type>table_am_handler</type></entry>
        <entry>A table access method handler is declared to return <type>table_am_handler</type>.</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>table_am_handler</type></entry>
        <entry>一种表访问方法处理程序，声明要返回 <type>table_am_handler</type>.</entry>
       </row>
<!-- pgdoc-cn_end sig_en=fe3f9485098cbddaf1b77247c7153a1a -->

<!-- pgdoc-cn_start sig_en=53dfefd11503ceabbcd0d15f2375b790 sig_cn_org=None source=14.1 
       <row>
        <entry><type>index_am_handler</type></entry>
        <entry>An index access method handler is declared to return <type>index_am_handler</type>.</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>index_am_handler</type></entry>
        <entry>一个被声明为返回<type>index_am_handler</type>索引访问方法处理器。</entry>
       </row>
<!-- pgdoc-cn_end sig_en=53dfefd11503ceabbcd0d15f2375b790 -->

<!-- pgdoc-cn_start sig_en=833380f57cd48f3ac0022949244183c6 sig_cn_org=None source=14.1 
       <row>
        <entry><type>tsm_handler</type></entry>
        <entry>A tablesample method handler is declared to return <type>tsm_handler</type>.</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>tsm_handler</type></entry>
        <entry> 一个被声明为返回<type>tsm_handler</type>的表采样方法处理器。</entry>
       </row>
<!-- pgdoc-cn_end sig_en=833380f57cd48f3ac0022949244183c6 -->

<!-- pgdoc-cn_start sig_en=ff8073a5e9fcf21d4bf509c02028c6db sig_cn_org=None source=14.1 
       <row>
        <entry><type>record</type></entry>
        <entry>Identifies a function taking or returning an unspecified row type.</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>record</type></entry>
        <entry>标识一个接收或者返回一个未指定的行类型的函数。</entry>
       </row>
<!-- pgdoc-cn_end sig_en=ff8073a5e9fcf21d4bf509c02028c6db -->

<!-- pgdoc-cn_start sig_en=8d082317756fa5d387ecf9518f64f861 sig_cn_org=None source=14.1 
       <row>
        <entry><type>trigger</type></entry>
        <entry>A trigger function is declared to return <type>trigger.</type></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>trigger</type></entry>
        <entry>一个被声明为返回<type>trigger</type>的触发器函数。</entry>
       </row>
<!-- pgdoc-cn_end sig_en=8d082317756fa5d387ecf9518f64f861 -->

<!-- pgdoc-cn_start sig_en=5deada1b9278031a4aca3d2a01778f82 sig_cn_org=None source=14.1 
       <row>
        <entry><type>event_trigger</type></entry>
        <entry>An event trigger function is declared to return <type>event_trigger.</type></entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>event_trigger</type></entry>
        <entry>一个被声明为返回<type>event_trigger</type>的事件触发器函数。</entry>
       </row>
<!-- pgdoc-cn_end sig_en=5deada1b9278031a4aca3d2a01778f82 -->

<!-- pgdoc-cn_start sig_en=49beccf2236fdc383e9a02c7b61bc792 sig_cn_org=None source=14.1 
       <row>
        <entry><type>pg_ddl_command</type></entry>
        <entry>Identifies a representation of DDL commands that is available to event triggers.</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>pg_ddl_command</type></entry>
        <entry>标识一种对事件触发器可用的 DDL 命令的表达。</entry>
       </row>
<!-- pgdoc-cn_end sig_en=49beccf2236fdc383e9a02c7b61bc792 -->

<!-- pgdoc-cn_start sig_en=5b627d7bf2e3c5bb73bf3b912b1c6f64 sig_cn_org=None source=14.1 
       <row>
        <entry><type>void</type></entry>
        <entry>Indicates that a function returns no value.</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>void</type></entry>
        <entry>表示一个函数不返回值。</entry>
       </row>
<!-- pgdoc-cn_end sig_en=5b627d7bf2e3c5bb73bf3b912b1c6f64 -->

<!-- pgdoc-cn_start sig_en=9802e31348eaca658508a976b3d8ddf2 sig_cn_org=None source=14.1 
       <row>
        <entry><type>unknown</type></entry>
        <entry>Identifies a not-yet-resolved type, e.g., of an undecorated
         string literal.</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><type>unknown</type></entry>
        <entry>标识一种还未被解析的类型，例如一个未修饰的字符文本。</entry>
       </row>
<!-- pgdoc-cn_end sig_en=9802e31348eaca658508a976b3d8ddf2 -->
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=168e23e2ce2ac375b842b1409928edb9 sig_cn_org=None source=14.1 
   <para>
    Functions coded in C (whether built-in or dynamically loaded) can be
    declared to accept or return any of these pseudo-types.  It is up to
    the function author to ensure that the function will behave safely
    when a pseudo-type is used as an argument type.
   </para>
________________________________________________________-->
   <para>
    用C编写的函数（不管是内建的还是动态载入的）可以被声明为接受或返回这些为数据类型的任意一种。函数的作者应当保证当一个伪数据类型被用作一个参数类型时函数的行为是安全的。
   </para>
<!-- pgdoc-cn_end sig_en=168e23e2ce2ac375b842b1409928edb9 -->

<!-- pgdoc-cn_start sig_en=3bd46faddc7ccb5915727c7ca7942c82 sig_cn_org=None source=14.1 
   <para>
    Functions coded in procedural languages can use pseudo-types only as
    allowed by their implementation languages.  At present most procedural
    languages forbid use of a pseudo-type as an argument type, and allow
    only <type>void</type> and <type>record</type> as a result type (plus
    <type>trigger</type> or <type>event_trigger</type> when the function is used
    as a trigger or event trigger).  Some also support polymorphic functions
    using the polymorphic pseudo-types, which are shown above and discussed
    in detail in <xref linkend="extend-types-polymorphic"/>.
   </para>
________________________________________________________-->
   <para>
    用过程语言编写的函数只有在其实现语言允许的情况下才能使用伪类型。
    目前大部分过程语言都禁止使用伪类型作为一种参数类型，并且只允许使用<type>void</type>和<type>record</type>作为结果类型（如果函数被用于一个触发器或者事件触发器， <type>trigger</type>或者<type>event_trigger</type>也被允许作为结果类型）。
    有些还支持使用多态伪类型的多态函数，上述展现和讨论的详细内容在<xref linkend="extend-types-polymorphic"/>中。
   </para>
<!-- pgdoc-cn_end sig_en=3bd46faddc7ccb5915727c7ca7942c82 -->

<!-- pgdoc-cn_start sig_en=6b1d7b01311e72b970cf46b3a3a0b8e2 sig_cn_org=None source=14.1 
   <para>
    The <type>internal</type> pseudo-type is used to declare functions
    that are meant only to be called internally by the database
    system, and not by direct invocation in an <acronym>SQL</acronym>
    query.  If a function has at least one <type>internal</type>-type
    argument then it cannot be called from <acronym>SQL</acronym>.  To
    preserve the type safety of this restriction it is important to
    follow this coding rule: do not create any function that is
    declared to return <type>internal</type> unless it has at least one
    <type>internal</type> argument.
   </para>
________________________________________________________-->
   <para>
    <type>internal</type>伪类型用于定义只在数据库系统内部调用的函数，这些函数不会被<acronym>SQL</acronym>直接调用。如果一个函数拥有至少一个<type>internal</type>类型的参数，则它不能从<acronym>SQL</acronym>中被调用。为了保持这种限制的类型安全性，遵循以下编码规则非常重要：不要创建任何被声明要返回<type>internal</type>的函数，除非它有至少一个<type>internal</type>参数。
   </para>
<!-- pgdoc-cn_end sig_en=6b1d7b01311e72b970cf46b3a3a0b8e2 -->

  </sect1>

 </chapter>
