<!-- doc/src/sgml/storage.sgml -->

<chapter id="storage">

<!-- pgdoc-cn_start sig_en=d8012e1176597131b1521e0a14bbda7d sig_cn_org=None source=14.1 
<title>Database Physical Storage</title>
________________________________________________________-->
<title>数据库物理存储</title>
<!-- pgdoc-cn_end sig_en=d8012e1176597131b1521e0a14bbda7d -->

<!-- pgdoc-cn_start sig_en=89f8d470676d3d6da58d1b370de21e11 sig_cn_org=None source=14.1 
<para>
This chapter provides an overview of the physical storage format used by
<productname>PostgreSQL</productname> databases.
</para>
________________________________________________________-->
<para>
本章对<productname>PostgreSQL</productname>数据库使用的物理存储格式进行一个概述。
</para>
<!-- pgdoc-cn_end sig_en=89f8d470676d3d6da58d1b370de21e11 -->

<sect1 id="storage-file-layout">

<!-- pgdoc-cn_start sig_en=1e169482cc068b464ab550163a07737d sig_cn_org=None source=14.1 
<title>Database File Layout</title>
________________________________________________________-->
<title>数据库文件布局</title>
<!-- pgdoc-cn_end sig_en=1e169482cc068b464ab550163a07737d -->

<!-- pgdoc-cn_start sig_en=6c52a17a54c86155bd0bf66af66bb1c7 sig_cn_org=None source=14.1 
<para>
This section describes the storage format at the level of files and
directories.
</para>
________________________________________________________-->
<para>
本节在文件和目录的层次上描述存储格式。
</para>
<!-- pgdoc-cn_end sig_en=6c52a17a54c86155bd0bf66af66bb1c7 -->

<!-- pgdoc-cn_start sig_en=73268804a2ae4470643231084d41da96 sig_cn_org=None source=14.1 
<para>
Traditionally, the configuration and data files used by a database
cluster are stored together within the cluster's data
directory, commonly referred to as <varname>PGDATA</varname> (after the name of the
environment variable that can be used to define it).  A common location for
<varname>PGDATA</varname> is <filename>/var/lib/pgsql/data</filename>.  Multiple clusters,
managed by different server instances, can exist on the same machine.
</para>
________________________________________________________-->
<para>
在传统上，数据库集簇所使用的配置和数据文件都被一起存储在集簇的数据目录里， 通常用<varname>PGDATA</varname>来引用（用的是可以定义它的环境变量的名字）。<varname>PGDATA</varname>的一个常见位置是<filename>/var/lib/pgsql/data</filename>。由不同数据库实例所管理的多个集簇可以在同一台机器上共存。
</para>
<!-- pgdoc-cn_end sig_en=73268804a2ae4470643231084d41da96 -->

<!-- pgdoc-cn_start sig_en=69bbc1d39b0bd203d5026a01703bd820 sig_cn_org=None source=14.1 
<para>
The <varname>PGDATA</varname> directory contains several subdirectories and control
files, as shown in <xref linkend="pgdata-contents-table"/>.  In addition to
these required items, the cluster configuration files
<filename>postgresql.conf</filename>, <filename>pg_hba.conf</filename>, and
<filename>pg_ident.conf</filename> are traditionally stored in
<varname>PGDATA</varname>, although it is possible to place them elsewhere.
</para>
________________________________________________________-->
<para>
<varname>PGDATA</varname>目录包含几个子目录以及一些控制文件， 如<xref linkend="pgdata-contents-table"/>所示。除了这些必要的东西之外，集簇的配置文件<filename>postgresql.conf</filename>、<filename>pg_hba.conf</filename>和<filename>pg_ident.conf</filename>通常都存储在<varname>PGDATA</varname>中，不过可以把它们放在别的地方。
</para>
<!-- pgdoc-cn_end sig_en=69bbc1d39b0bd203d5026a01703bd820 -->

<table tocentry="1" id="pgdata-contents-table">
<!-- pgdoc-cn_start sig_en=2fca55c96998377c8ed887be740c2f53 sig_cn_org=None source=14.1 
<title>Contents of <varname>PGDATA</varname></title>
________________________________________________________-->
<title><varname>PGDATA</varname>的内容</title>
<!-- pgdoc-cn_end sig_en=2fca55c96998377c8ed887be740c2f53 -->
<tgroup cols="2">
<thead>
<!-- pgdoc-cn_start sig_en=225eb84ca2b2f12d8273caffcec05ef6 sig_cn_org=None source=14.1 
<row>
<entry>
Item
</entry>
<entry>Description</entry>
</row>
________________________________________________________-->
<row>
<entry>
项
</entry>
<entry>描述</entry>
</row>
<!-- pgdoc-cn_end sig_en=225eb84ca2b2f12d8273caffcec05ef6 -->
</thead>

<tbody>

<!-- pgdoc-cn_start sig_en=c98c41ef3e775f55984a5660a4274609 sig_cn_org=None source=14.1 
<row>
 <entry><filename>PG_VERSION</filename></entry>
 <entry>A file containing the major version number of <productname>PostgreSQL</productname></entry>
</row>
________________________________________________________-->
<row>
 <entry><filename>PG_VERSION</filename></entry>
 <entry>一个包含<productname>PostgreSQL</productname>主版本号的文件</entry>
</row>
<!-- pgdoc-cn_end sig_en=c98c41ef3e775f55984a5660a4274609 -->

<!-- pgdoc-cn_start sig_en=c1ae035aecd6d7b9a40add17f470a30a sig_cn_org=None source=14.1 
<row>
 <entry><filename>base</filename></entry>
 <entry>Subdirectory containing per-database subdirectories</entry>
</row>
________________________________________________________-->
<row>
 <entry><filename>base</filename></entry>
 <entry>包含每个数据库对应的子目录的子目录</entry>
</row>
<!-- pgdoc-cn_end sig_en=c1ae035aecd6d7b9a40add17f470a30a -->

<!-- pgdoc-cn_start sig_en=e6e59534f9b9c878e4fb80d2a9097e1e sig_cn_org=None source=14.1 
<row>
 <entry><filename>current_logfiles</filename></entry>
 <entry>File recording the log file(s) currently written to by the logging
  collector</entry>
</row>
________________________________________________________-->
<row>
 <entry><filename>current_logfiles</filename></entry>
 <entry>记录当前被日志收集器写入的日志文件的文件</entry>
</row>
<!-- pgdoc-cn_end sig_en=e6e59534f9b9c878e4fb80d2a9097e1e -->

<!-- pgdoc-cn_start sig_en=b0e8baf7697d498b4c4154ec6bb7077d sig_cn_org=None source=14.1 
<row>
 <entry><filename>global</filename></entry>
 <entry>Subdirectory containing cluster-wide tables, such as
 <structname>pg_database</structname></entry>
</row>
________________________________________________________-->
<row>
 <entry><filename>global</filename></entry>
 <entry>包含集簇范围的表的子目录，比如<structname>pg_database</structname></entry>
</row>
<!-- pgdoc-cn_end sig_en=b0e8baf7697d498b4c4154ec6bb7077d -->

<!-- pgdoc-cn_start sig_en=d0ded4384d97e22391c2ee9af6c50774 sig_cn_org=None source=14.1 
<row>
 <entry><filename>pg_commit_ts</filename></entry>
 <entry>Subdirectory containing transaction commit timestamp data</entry>
</row>
________________________________________________________-->
<row>
 <entry><filename>pg_commit_ts</filename></entry>
 <entry>包含事务提交时间戳数据的子目录</entry>
</row>
<!-- pgdoc-cn_end sig_en=d0ded4384d97e22391c2ee9af6c50774 -->

<!-- pgdoc-cn_start sig_en=e3b41b78fd85e0ddaf1277cdb7892e0c sig_cn_org=None source=14.1 
<row>
 <entry><filename>pg_dynshmem</filename></entry>
 <entry>Subdirectory containing files used by the dynamic shared memory
  subsystem</entry>
</row>
________________________________________________________-->
<row>
 <entry><filename>pg_dynshmem</filename></entry>
 <entry>包含被动态共享内存子系统所使用的文件的子目录</entry>
</row>
<!-- pgdoc-cn_end sig_en=e3b41b78fd85e0ddaf1277cdb7892e0c -->

<!-- pgdoc-cn_start sig_en=fc67d0de95f0ac640a6760209034a3d6 sig_cn_org=None source=14.1 
<row>
 <entry><filename>pg_logical</filename></entry>
 <entry>Subdirectory containing status data for logical decoding</entry>
</row>
________________________________________________________-->
<row>
 <entry><filename>pg_logical</filename></entry>
 <entry>包含用于逻辑复制的状态数据的子目录</entry>
</row>
<!-- pgdoc-cn_end sig_en=fc67d0de95f0ac640a6760209034a3d6 -->

<!-- pgdoc-cn_start sig_en=0f560e89c1c2fe0216d889442e75f44e sig_cn_org=None source=14.1 
<row>
 <entry><filename>pg_multixact</filename></entry>
 <entry>Subdirectory containing multitransaction status data
  (used for shared row locks)</entry>
</row>
________________________________________________________-->
<row>
 <entry><filename>pg_multixact</filename></entry>
 <entry>包含多事务（multi-transaction）状态数据的子目录（用于共享的行锁）</entry>
</row>
<!-- pgdoc-cn_end sig_en=0f560e89c1c2fe0216d889442e75f44e -->

<!-- pgdoc-cn_start sig_en=a67f7adb103c20596e55e4162cf581fa sig_cn_org=None source=14.1 
<row>
 <entry><filename>pg_notify</filename></entry>
 <entry>Subdirectory containing LISTEN/NOTIFY status data</entry>
</row>
________________________________________________________-->
<row>
 <entry><filename>pg_notify</filename></entry>
 <entry>包含LISTEN/NOTIFY状态数据的子目录</entry>
</row>
<!-- pgdoc-cn_end sig_en=a67f7adb103c20596e55e4162cf581fa -->

<!-- pgdoc-cn_start sig_en=999e0d656cc8e48c22f9a3e58dde9fcd sig_cn_org=None source=14.1 
<row>
 <entry><filename>pg_replslot</filename></entry>
 <entry>Subdirectory containing replication slot data</entry>
</row>
________________________________________________________-->
<row>
 <entry><filename>pg_replslot</filename></entry>
 <entry>包含复制槽数据的子目录</entry>
</row>
<!-- pgdoc-cn_end sig_en=999e0d656cc8e48c22f9a3e58dde9fcd -->

<!-- pgdoc-cn_start sig_en=07bdd2bd04426dc35753c7b726459ab8 sig_cn_org=None source=14.1 
<row>
 <entry><filename>pg_serial</filename></entry>
 <entry>Subdirectory containing information about committed serializable transactions</entry>
</row>
________________________________________________________-->
<row>
 <entry><filename>pg_serial</filename></entry>
 <entry>包含已提交的可序列化事务信息的子目录</entry>
</row>
<!-- pgdoc-cn_end sig_en=07bdd2bd04426dc35753c7b726459ab8 -->

<!-- pgdoc-cn_start sig_en=367f9f125f25ac9ff4a3be67b2ae4158 sig_cn_org=None source=14.1 
<row>
 <entry><filename>pg_snapshots</filename></entry>
 <entry>Subdirectory containing exported snapshots</entry>
</row>
________________________________________________________-->
<row>
 <entry><filename>pg_snapshots</filename></entry>
 <entry>包含导出的快照的子目录</entry>
</row>
<!-- pgdoc-cn_end sig_en=367f9f125f25ac9ff4a3be67b2ae4158 -->

<!-- pgdoc-cn_start sig_en=3e7e0f30fc6310c6c2edb2c308dc3ee4 sig_cn_org=None source=14.1 
<row>
 <entry><filename>pg_stat</filename></entry>
 <entry>Subdirectory containing permanent files for the statistics
  subsystem</entry>
</row>
________________________________________________________-->
<row>
 <entry><filename>pg_stat</filename></entry>
 <entry>包含用于统计子系统的永久文件的子目录</entry>
</row>
<!-- pgdoc-cn_end sig_en=3e7e0f30fc6310c6c2edb2c308dc3ee4 -->

<!-- pgdoc-cn_start sig_en=dcbdaa368d10b7bc7752c1d58caa97af sig_cn_org=None source=14.1 
<row>
 <entry><filename>pg_stat_tmp</filename></entry>
 <entry>Subdirectory containing temporary files for the statistics
  subsystem</entry>
</row>
________________________________________________________-->
<row>
 <entry><filename>pg_stat_tmp</filename></entry>
 <entry>包含用于统计信息子系统的临时文件的子目录</entry>
</row>
<!-- pgdoc-cn_end sig_en=dcbdaa368d10b7bc7752c1d58caa97af -->

<!-- pgdoc-cn_start sig_en=16512e02701c64881df38f06ba892c73 sig_cn_org=None source=14.1 
<row>
 <entry><filename>pg_subtrans</filename></entry>
 <entry>Subdirectory containing subtransaction status data</entry>
</row>
________________________________________________________-->
<row>
 <entry><filename>pg_subtrans</filename></entry>
 <entry>包含子事务状态数据的子目录</entry>
</row>
<!-- pgdoc-cn_end sig_en=16512e02701c64881df38f06ba892c73 -->

<!-- pgdoc-cn_start sig_en=41b13a3f7cd9bd7749ea237cd6a0bc7c sig_cn_org=None source=14.1 
<row>
 <entry><filename>pg_tblspc</filename></entry>
 <entry>Subdirectory containing symbolic links to tablespaces</entry>
</row>
________________________________________________________-->
<row>
 <entry><filename>pg_tblspc</filename></entry>
 <entry>包含指向表空间的符号链接的子目录</entry>
</row>
<!-- pgdoc-cn_end sig_en=41b13a3f7cd9bd7749ea237cd6a0bc7c -->

<!-- pgdoc-cn_start sig_en=1b0052c7a1cd66716e9da1e462543a2e sig_cn_org=None source=14.1 
<row>
 <entry><filename>pg_twophase</filename></entry>
 <entry>Subdirectory containing state files for prepared transactions</entry>
</row>
________________________________________________________-->
<row>
 <entry><filename>pg_twophase</filename></entry>
 <entry>包含用于预备事务状态文件的子目录</entry>
</row>
<!-- pgdoc-cn_end sig_en=1b0052c7a1cd66716e9da1e462543a2e -->

<!-- pgdoc-cn_start sig_en=730d314a461ff997709ac1ea5b1fc16f sig_cn_org=None source=14.1 
<row>
 <entry><filename>pg_wal</filename></entry>
 <entry>Subdirectory containing WAL (Write Ahead Log) files</entry>
</row>
________________________________________________________-->
<row>
 <entry><filename>pg_wal</filename></entry>
 <entry>包含 WAL （预写日志）文件的子目录</entry>
</row>
<!-- pgdoc-cn_end sig_en=730d314a461ff997709ac1ea5b1fc16f -->

<!-- pgdoc-cn_start sig_en=80a1ce301a4ee08183b3b2b859f0e71a sig_cn_org=None source=14.1 
<row>
 <entry><filename>pg_xact</filename></entry>
 <entry>Subdirectory containing transaction commit status data</entry>
</row>
________________________________________________________-->
<row>
 <entry><filename>pg_xact</filename></entry>
 <entry>包含事务提交状态数据的子目录</entry>
</row>
<!-- pgdoc-cn_end sig_en=80a1ce301a4ee08183b3b2b859f0e71a -->

<!-- pgdoc-cn_start sig_en=ff4059e339929a19486996b07da0a3b9 sig_cn_org=None source=14.1 
<row>
 <entry><filename>postgresql.auto.conf</filename></entry>
 <entry>A file used for storing configuration parameters that are set by
<command>ALTER SYSTEM</command></entry>
</row>
________________________________________________________-->
<row>
 <entry><filename>postgresql.auto.conf</filename></entry>
 <entry>一个用于存储由<command>ALTER SYSTEM</command>
 设置的配置参数的文件</entry>
</row>
<!-- pgdoc-cn_end sig_en=ff4059e339929a19486996b07da0a3b9 -->

<!-- pgdoc-cn_start sig_en=e0d0e85cc8d91c867ebfe37ecc40dde6 sig_cn_org=None source=14.1 
<row>
 <entry><filename>postmaster.opts</filename></entry>
 <entry>A file recording the command-line options the server was
last started with</entry>
</row>
________________________________________________________-->
<row>
 <entry><filename>postmaster.opts</filename></entry>
 <entry>一个记录服务器最后一次启动时使用的命令行参数的文件</entry>
</row>
<!-- pgdoc-cn_end sig_en=e0d0e85cc8d91c867ebfe37ecc40dde6 -->

<!-- pgdoc-cn_start sig_en=5a4824b722f628abe963d5427fdb6664 sig_cn_org=None source=14.1 
<row>
 <entry><filename>postmaster.pid</filename></entry>
 <entry>A lock file recording the current postmaster process ID (PID),
  cluster data directory path,
  postmaster start timestamp,
  port number,
  Unix-domain socket directory path (could be empty),
  first valid listen_address (IP address or <literal>*</literal>, or empty if
  not listening on TCP),
  and shared memory segment ID
  (this file is not present after server shutdown)</entry>
</row>
________________________________________________________-->
<row>
 <entry><filename>postmaster.pid</filename></entry>
 <entry>一个锁文件，记录着当前的 postmaster 进程ID（PID）、集簇数据目录路径、postmaster启动时间戳、端口号、Unix域套接字目录路径（Windows上为空）、第一个可用的listen_address（IP地址或者<literal>*</literal>，或者为空表示不在TCP上监听）以及共享内存段ID（服务器关闭后该文件不存在）</entry>
</row>
<!-- pgdoc-cn_end sig_en=5a4824b722f628abe963d5427fdb6664 -->

</tbody>
</tgroup>
</table>

<!-- pgdoc-cn_start sig_en=0a1fc8ce0741c6eed1d9b0f006670516 sig_cn_org=None source=14.1 
<para>
For each database in the cluster there is a subdirectory within
<varname>PGDATA</varname><filename>/base</filename>, named after the database's OID in
<structname>pg_database</structname>.  This subdirectory is the default location
for the database's files; in particular, its system catalogs are stored
there.
</para>
________________________________________________________-->
<para>
对于集簇里的每个数据库，在<varname>PGDATA</varname><filename>/base</filename>里都有一个子目录对应， 子目录的名字为该数据库在 <structname>pg_database</structname>里的 OID。这个子目录是该数据库文件的缺省位置；特别值得一提的是，该数据库的系统目录存储在此。
</para>
<!-- pgdoc-cn_end sig_en=0a1fc8ce0741c6eed1d9b0f006670516 -->

<!-- pgdoc-cn_start sig_en=e3378ddbd63e9709a05c969880b83c8f sig_cn_org=None source=14.1 
<para>
 Note that the following sections describe the behavior of the builtin
 <literal>heap</literal> <link linkend="tableam">table access method</link>,
 and the builtin <link linkend="indexam">index access methods</link>. Due
 to the extensible nature of <productname>PostgreSQL</productname>, other
 access methods might work differently.
</para>
________________________________________________________-->
<para>
 注意后续章节描述了内置的<literal>heap</literal> <link linkend="tableam">表访问方法</link>的行为，和内置 <link linkend="indexam">索引访问方法</link>。
 由于<productname>PostgreSQL</productname>的可扩展特性，其他访问方法的工作方式可能不同。
</para>
<!-- pgdoc-cn_end sig_en=e3378ddbd63e9709a05c969880b83c8f -->

<!-- pgdoc-cn_start sig_en=d70c0114084df9fcd9408902f919b45e sig_cn_org=None source=14.1 
<para>
Each table and index is stored in a separate file.  For ordinary relations,
these files are named after the table or index's <firstterm>filenode</firstterm> number,
which can be found in <structname>pg_class</structname>.<structfield>relfilenode</structfield>. But
for temporary relations, the file name is of the form
<literal>t<replaceable>BBB</replaceable>_<replaceable>FFF</replaceable></literal>, where <replaceable>BBB</replaceable>
is the backend ID of the backend which created the file, and <replaceable>FFF</replaceable>
is the filenode number.  In either case, in addition to the main file (a/k/a
main fork), each table and index has a <firstterm>free space map</firstterm> (see <xref
linkend="storage-fsm"/>), which stores information about free space available in
the relation.  The free space map is stored in a file named with the filenode
number plus the suffix <literal>_fsm</literal>.  Tables also have a
<firstterm>visibility map</firstterm>, stored in a fork with the suffix <literal>_vm</literal>,
to track which pages are known to have no dead tuples.  The visibility map is
described further in <xref linkend="storage-vm"/>.  Unlogged tables and indexes
have a third fork, known as the initialization fork, which is stored in a fork
with the suffix <literal>_init</literal> (see <xref linkend="storage-init"/>).
</para>
________________________________________________________-->
<para>
每个表和索引都存储在独立的文件里。对于普通关系，这些文件以表或索引的<firstterm>filenode</firstterm>号命名，它可以在<structname>pg_class</structname>.<structfield>relfilenode</structfield>中找到。但是对于临时关系，文件名的形式为<literal>t<replaceable>BBB</replaceable>_<replaceable>FFF</replaceable></literal>，其中<replaceable>BBB</replaceable>是创建该文件的后台的后台ID，<replaceable>FFF</replaceable>是文件节点号。在每种情况下，在主文件（a/k/a 主分支）之外，每个表和索引有一个<firstterm>空闲空间映射</firstterm>（见<xref
linkend="storage-fsm"/>），它存储关系中可用空闲空间的信息。空闲空间映射存储在一个文件中，该文件以节点号加上后缀<literal>_fsm</literal>命名。表还有一个<firstterm>可见性映射</firstterm>，存储在一个后缀为<literal>_vm</literal>的分支中，它用于跟踪哪些页面已知含有非死亡元组。可见性映射将在<xref linkend="storage-vm"/>中进一步描述。不被日志记录的表和索引还有第三个分支，即初始化分支，它存储在后缀为<literal>_init</literal>的分支中（见<xref linkend="storage-init"/>）。
</para>
<!-- pgdoc-cn_end sig_en=d70c0114084df9fcd9408902f919b45e -->

<caution>
<!-- pgdoc-cn_start sig_en=b4784da79b7ce9a06ed29f31813afe14 sig_cn_org=None source=14.1 
<para>
Note that while a table's filenode often matches its OID, this is
<emphasis>not</emphasis> necessarily the case; some operations, like
<command>TRUNCATE</command>, <command>REINDEX</command>, <command>CLUSTER</command> and some forms
of <command>ALTER TABLE</command>, can change the filenode while preserving the OID.
Avoid assuming that filenode and table OID are the same.
Also, for certain system catalogs including <structname>pg_class</structname> itself,
<structname>pg_class</structname>.<structfield>relfilenode</structfield> contains zero.  The
actual filenode number of these catalogs is stored in a lower-level data
structure, and can be obtained using the <function>pg_relation_filenode()</function>
function.
</para>
________________________________________________________-->
<para>
请注意，虽然一个表的文件节点通常和它的 OID 相匹配，但实际上并<emphasis>不</emphasis>必须如此； 有些操作，比如 <command>TRUNCATE</command>、<command>REINDEX</command>、<command>CLUSTER</command>以及某些形式的<command>ALTER TABLE</command>，都可以改变文件节点而同时保留 OID。我们不应该假设文件节点和表 OID 相同。此外，对于包含<structname>pg_class</structname>本身在内的特定系统目录，其<structname>pg_class</structname>.<structfield>relfilenode</structfield>包含0。这些目录的实际文件节点号被存储在一个低层数据结构中，并且可以使用<function>pg_relation_filenode()</function>函数获取。
</para>
<!-- pgdoc-cn_end sig_en=b4784da79b7ce9a06ed29f31813afe14 -->
</caution>

<!-- pgdoc-cn_start sig_en=3eeff6662116c98b26da841ea7146446 sig_cn_org=None source=14.1 
<para>
When a table or index exceeds 1 GB, it is divided into gigabyte-sized
<firstterm>segments</firstterm>.  The first segment's file name is the same as the
filenode; subsequent segments are named filenode.1, filenode.2, etc.
This arrangement avoids problems on platforms that have file size limitations.
(Actually, 1 GB is just the default segment size.  The segment size can be
adjusted using the configuration option <option>-&minus;with-segsize</option>
when building <productname>PostgreSQL</productname>.)
In principle, free space map and visibility map forks could require multiple
segments as well, though this is unlikely to happen in practice.
</para>
________________________________________________________-->
<para>
在表或者索引超过 1GB 之后，它就被划分成1G大小的<firstterm>段</firstterm>。 第一个段的文件名和文件节点相同；随后的段被命名为 filenode.1、filenode.2等等。这样的安排避免了在某些有文件大小限制的平台上的问题（实际上，1GB只是默认的段尺寸。段尺寸可以在编译<productname>PostgreSQL</productname>时使用配置选项<option>--with-segsize</option>进行调整）。原则上，空闲空间映射和可见性映射分支也可以要求多个段，但实际上这很少发生。
</para>
<!-- pgdoc-cn_end sig_en=3eeff6662116c98b26da841ea7146446 -->

<!-- pgdoc-cn_start sig_en=7167f8531aa73b345e1b945450c5a372 sig_cn_org=None source=14.1 
<para>
A table that has columns with potentially large entries will have an
associated <firstterm>TOAST</firstterm> table, which is used for out-of-line storage of
field values that are too large to keep in the table rows proper.
<structname>pg_class</structname>.<structfield>reltoastrelid</structfield> links from a table to
its <acronym>TOAST</acronym> table, if any.
See <xref linkend="storage-toast"/> for more information.
</para>
________________________________________________________-->
<para>
如果一个表的列中可能存储相当大的项，那么该表就会有个与之相关联的<firstterm>TOAST</firstterm>表， 它用于存储无法保留在在表行中的域值的线外存储。如果表有<firstterm>TOAST</firstterm>表，该表的<structname>pg_class</structname>.<structfield>reltoastrelid</structfield>链接到它的<acronym>TOAST</acronym>表。 参阅<xref linkend="storage-toast"/>获取更多信息。
</para>
<!-- pgdoc-cn_end sig_en=7167f8531aa73b345e1b945450c5a372 -->

<!-- pgdoc-cn_start sig_en=ed1b07a7ce7fdea5c795f19545942780 sig_cn_org=None source=14.1 
<para>
The contents of tables and indexes are discussed further in
<xref linkend="storage-page-layout"/>.
</para>
________________________________________________________-->
<para>
表和索引的内容在<xref linkend="storage-page-layout"/>中进一步讨论。
</para>
<!-- pgdoc-cn_end sig_en=ed1b07a7ce7fdea5c795f19545942780 -->

<!-- pgdoc-cn_start sig_en=244349608096999a65303955c3524e08 sig_cn_org=None source=14.1 
<para>
Tablespaces make the scenario more complicated.  Each user-defined tablespace
has a symbolic link inside the <varname>PGDATA</varname><filename>/pg_tblspc</filename>
directory, which points to the physical tablespace directory (i.e., the
location specified in the tablespace's <command>CREATE TABLESPACE</command> command).
This symbolic link is named after
the tablespace's OID.  Inside the physical tablespace directory there is
a subdirectory with a name that depends on the <productname>PostgreSQL</productname>
server version, such as <literal>PG_9.0_201008051</literal>.  (The reason for using
this subdirectory is so that successive versions of the database can use
the same <command>CREATE TABLESPACE</command> location value without conflicts.)
Within the version-specific subdirectory, there is
a subdirectory for each database that has elements in the tablespace, named
after the database's OID.  Tables and indexes are stored within that
directory, using the filenode naming scheme.
The <literal>pg_default</literal> tablespace is not accessed through
<filename>pg_tblspc</filename>, but corresponds to
<varname>PGDATA</varname><filename>/base</filename>.  Similarly, the <literal>pg_global</literal>
tablespace is not accessed through <filename>pg_tblspc</filename>, but corresponds to
<varname>PGDATA</varname><filename>/global</filename>.
</para>
________________________________________________________-->
<para>
表空间的情况更复杂些。每个用户定义的表空间都在<varname>PGDATA</varname><filename>/pg_tblspc</filename>目录里面有一个符号连接，它指向物理的表空间目录（就是在<command>CREATE TABLESPACE</command>命令里指定的那个目录）。这个符号连接是用表空间的 OID 命名的。在物理表空间目录中有一个名称取决于<productname>PostgreSQL</productname>服务器版本的子目录，例如<literal>PG_9.0_201008051</literal>（使用该子目录的原因是后续版本的数据库可以使用<command>CREATE TABLESPACE</command>指定相同的目录位置而不会造成冲突）。在这个版本相关的子目录中，为每个在这个表空间里有元素的数据库都有一个子目录， 以数据库的OID命名。该目录里的表和索引遵循文件节点命名模式。<literal>pg_default</literal>不需要通过<filename>pg_tblspc</filename>来访问，而是对应于<varname>PGDATA</varname><filename>/base</filename>。类似地，<literal>pg_global</literal>表空间也不通过<filename>pg_tblspc</filename>访问，而是对应于<varname>PGDATA</varname><filename>/global</filename>。
</para>
<!-- pgdoc-cn_end sig_en=244349608096999a65303955c3524e08 -->

<!-- pgdoc-cn_start sig_en=f25000cf856fcefa5dc3cf133638fb0b sig_cn_org=None source=14.1 
<para>
The <function>pg_relation_filepath()</function> function shows the entire path
(relative to <varname>PGDATA</varname>) of any relation.  It is often useful
as a substitute for remembering many of the above rules.  But keep in
mind that this function just gives the name of the first segment of the
main fork of the relation &mdash; you may need to append a segment number
and/or <literal>_fsm</literal>, <literal>_vm</literal>, or <literal>_init</literal> to find all
the files associated with the relation.
</para>
________________________________________________________-->
<para>
<function>pg_relation_filepath()</function>函数显示任何关系的完整路径（相对于<varname>PGDATA</varname>）。它可以作为记住上面这么多规则的替代方法。但是记住该函数只给出关系的主分支的第一个段的名称 &mdash; 你也许需要追加一个段号和/或<literal>_fsm</literal>、<literal>_vm</literal>或者<literal>_init</literal>来找到与该关系相关的所有文件。
</para>
<!-- pgdoc-cn_end sig_en=f25000cf856fcefa5dc3cf133638fb0b -->

<!-- pgdoc-cn_start sig_en=ebad2119d0a4e91b6e8248b1e14095f5 sig_cn_org=None source=14.1 
<para>
Temporary files (for operations such as sorting more data than can fit in
memory) are created within <varname>PGDATA</varname><filename>/base/pgsql_tmp</filename>,
or within a <filename>pgsql_tmp</filename> subdirectory of a tablespace directory
if a tablespace other than <literal>pg_default</literal> is specified for them.
The name of a temporary file has the form
<filename>pgsql_tmp<replaceable>PPP</replaceable>.<replaceable>NNN</replaceable></filename>,
where <replaceable>PPP</replaceable> is the PID of the owning backend and
<replaceable>NNN</replaceable> distinguishes different temporary files of that backend.
</para>
________________________________________________________-->
<para>
临时文件（用于如排序不能放在内存中的数据等操作）被创建在<varname>PGDATA</varname><filename>/base/pgsql_tmp</filename>中，如果临时文件被指定在一个非<literal>pg_default</literal>表空间中则它们会被创建在该表空间的<filename>pgsql_tmp</filename>子目录中。临时文件的名称的形式为<filename>pgsql_tmp<replaceable>PPP</replaceable>.<replaceable>NNN</replaceable></filename>，其中<replaceable>PPP</replaceable>是其所属后端的PID，而<replaceable>NNN</replaceable>用于区别该后端的不同临时文件。
</para>
<!-- pgdoc-cn_end sig_en=ebad2119d0a4e91b6e8248b1e14095f5 -->

</sect1>

<sect1 id="storage-toast">

<!-- pgdoc-cn_start sig_en=43ded4bde6656ff8e3037a02ab90b415 sig_cn_org=None source=14.1 
<title>TOAST</title>
________________________________________________________-->
<title>TOAST</title>
<!-- pgdoc-cn_end sig_en=43ded4bde6656ff8e3037a02ab90b415 -->

<!-- pgdoc-cn_start sig_en=9df09a7bac8bd1609e7c9129580ae1c3 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>TOAST</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>TOAST</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=9df09a7bac8bd1609e7c9129580ae1c3 -->
<!-- pgdoc-cn_start sig_en=2804848a65cf30301bdab30b098719cf sig_cn_org=None source=14.1 
    <indexterm><primary>sliced bread</primary><see>TOAST</see></indexterm>
________________________________________________________-->
    <indexterm><primary>切片面包</primary><see>TOAST</see></indexterm>
<!-- pgdoc-cn_end sig_en=2804848a65cf30301bdab30b098719cf -->

<!-- pgdoc-cn_start sig_en=1de6312a3bad0856aea55354e19a0c28 sig_cn_org=None source=14.1 
<para>
This section provides an overview of <acronym>TOAST</acronym> (The
Oversized-Attribute Storage Technique).
</para>
________________________________________________________-->
<para>
本节提供<acronym>TOAST</acronym>的概述（超尺寸属性存储技术－The Oversized-Attribute Storage Technique）。
</para>
<!-- pgdoc-cn_end sig_en=1de6312a3bad0856aea55354e19a0c28 -->

<!-- pgdoc-cn_start sig_en=f592eb9f8f16ede53de69d3685239051 sig_cn_org=None source=14.1 
<para>
<productname>PostgreSQL</productname> uses a fixed page size (commonly
8 kB), and does not allow tuples to span multiple pages.  Therefore, it is
not possible to store very large field values directly.  To overcome
this limitation, large field values are compressed and/or broken up into
multiple physical rows.  This happens transparently to the user, with only
small impact on most of the backend code.  The technique is affectionately
known as <acronym>TOAST</acronym> (or <quote>the best thing since sliced bread</quote>).
The <acronym>TOAST</acronym> infrastructure is also used to improve handling of
large data values in-memory.
</para>
________________________________________________________-->
<para>
<productname>PostgreSQL</productname>使用固定的页面尺寸（通常是8kB)，并且不允许元组跨越多个额页面。因此不可能直接存储非常大的域值。为了克服这个限制，大的域值会被压缩并/或分解成多个物理行。这些处理对用户都是透明的，只是在大部分的后端代码上有一些小的影响。这个技术的昵称是<acronym>TOAST</acronym>（或者<quote>切片面包之后的最好的东西</quote>）。<acronym>TOAST</acronym> 机制也被用来提升内存中大型数据值的处理。
</para>
<!-- pgdoc-cn_end sig_en=f592eb9f8f16ede53de69d3685239051 -->

<!-- pgdoc-cn_start sig_en=7063f7d7581a85ad7147773abdfecb3e sig_cn_org=None source=14.1 
<para>
Only certain data types support <acronym>TOAST</acronym> &mdash; there is no need to
impose the overhead on data types that cannot produce large field values.
To support <acronym>TOAST</acronym>, a data type must have a variable-length
(<firstterm>varlena</firstterm>) representation, in which, ordinarily, the first
four-byte word of any stored value contains the total length of the value in
bytes (including itself).  <acronym>TOAST</acronym> does not constrain the rest
of the data type's representation.  The special representations collectively
called <firstterm><acronym>TOAST</acronym>ed values</firstterm> work by modifying or
reinterpreting this initial length word.  Therefore, the C-level functions
supporting a <acronym>TOAST</acronym>-able data type must be careful about how they
handle potentially <acronym>TOAST</acronym>ed input values: an input might not
actually consist of a four-byte length word and contents until after it's
been <firstterm>detoasted</firstterm>.  (This is normally done by invoking
<function>PG_DETOAST_DATUM</function> before doing anything with an input value,
but in some cases more efficient approaches are possible.
See <xref linkend="xtypes-toast"/> for more detail.)
</para>
________________________________________________________-->
<para>
只有特定的数据类型支持<acronym>TOAST</acronym> &mdash; 我们没必要在那些不可能生成大域值的数据类型上强加这种负担。要支持<acronym>TOAST</acronym>，数据类型必须有变长（<firstterm>varlena</firstterm>）的表现形式， 通常在存储的值中，头四个字节表示值的总长度（包括长度本身，以字节计）。<acronym>TOAST</acronym>并不约束该数据类型的表达的剩余部分。这种特殊的表达被统称为<firstterm>已<acronym>TOAST</acronym>值</firstterm>， 对它们的操作都必须通过修改或者重新解释这个初始长度字来进行。因此，支持一种可<acronym>TOAST</acronym>数据类型的 C 函数必须要小心它们可能会处理被<acronym>TOAST</acronym>过的输入值： 一个输入值可能并不真正由一个四字节长度和内容构成，直到它被<firstterm>反TOAST</firstterm>（通常是在对一个输入值做任何事情之前，先调用<function>PG_DETOAST_DATUM</function>； 但是在某些情况下也存在更高效的方法，详见<xref linkend="xtypes-toast"/>）。
</para>
<!-- pgdoc-cn_end sig_en=7063f7d7581a85ad7147773abdfecb3e -->

<!-- pgdoc-cn_start sig_en=971306956281d2e14f4105fd3b8ad0a8 sig_cn_org=None source=14.1 
<para>
<acronym>TOAST</acronym> usurps two bits of the varlena length word (the high-order
bits on big-endian machines, the low-order bits on little-endian machines),
thereby limiting the logical size of any value of a <acronym>TOAST</acronym>-able
data type to 1 GB (2<superscript>30</superscript> - 1 bytes).  When both bits are zero,
the value is an ordinary un-<acronym>TOAST</acronym>ed value of the data type, and
the remaining bits of the length word give the total datum size (including
length word) in bytes.  When the highest-order or lowest-order bit is set,
the value has only a single-byte header instead of the normal four-byte
header, and the remaining bits of that byte give the total datum size
(including length byte) in bytes.  This alternative supports space-efficient
storage of values shorter than 127 bytes, while still allowing the data type
to grow to 1 GB at need.  Values with single-byte headers aren't aligned on
any particular boundary, whereas values with four-byte headers are aligned on
at least a four-byte boundary; this omission of alignment padding provides
additional space savings that is significant compared to short values.
As a special case, if the remaining bits of a single-byte header are all
zero (which would be impossible for a self-inclusive length), the value is
a pointer to out-of-line data, with several possible alternatives as
described below.  The type and size of such a <firstterm>TOAST pointer</firstterm>
are determined by a code stored in the second byte of the datum.
Lastly, when the highest-order or lowest-order bit is clear but the adjacent
bit is set, the content of the datum has been compressed and must be
decompressed before use.  In this case the remaining bits of the four-byte
length word give the total size of the compressed datum, not the
original data.  Note that compression is also possible for out-of-line data
but the varlena header does not tell whether it has occurred &mdash;
the content of the <acronym>TOAST</acronym> pointer tells that, instead.
</para>
________________________________________________________-->
<para>
<acronym>TOAST</acronym>占用使用变长类型的长度字的最高两个二进制位（
大端法机器上的高位，小端法机器上的低位）， 这样就把任何可TOAST值的
逻辑长度限制在1GB（2<superscript>30</superscript> - 1字节）。如果两个位都是零，
那么数值是该数据类型一个普通的未TOAST的值，并且长度字的剩余位给出整
个数据以字节计的大小（包括长度字）。当最高位或者最低位被设置时，该值
只是有一个单字节头部而不是通常的四字节头部，并且该字节的剩余位数给出
了以字节计的总数据尺寸（包括长度字节）。这种节省空间的方案支持对低于 
127 字节的值的存储，不过需要时仍然允许数据类型增长到 1GB。带有单字节
头部的值不会按照任何特别的边界对齐，反之带有四字节头部的值会按照至少
一个四字节边界对齐。这种对齐填充的省略额外地节省了空间，这种节省比起
短值来说更加显著。作为一种特殊情况，如果一个单字节头部的剩余位全是零
（对于一个自包含的长度来说是不可能的），该值就是一个线外数据的指针，
这就可能有下文所述的几种可能的情况。这样一个<firstterm>TOAST指针</firstterm>
的类型和尺寸由该数据的第二个字节中存储的一个代码决定。最后，如果最高
位或最低位被清除而另一位被设置，则表示该数据的内容被压缩过并且在使用
前必须先解压。在这种情况中四字节长度字的剩余位指出了压缩过的数据的大
小，而不是原始数据的大小。注意对于线外数据也可能存在压缩，但是变长数
据的头部不会告诉我们压缩是否发生 &mdash; <acronym>TOAST</acronym>指针
的内容将说明这个问题。
</para>
<!-- pgdoc-cn_end sig_en=971306956281d2e14f4105fd3b8ad0a8 -->

<!-- pgdoc-cn_start sig_en=a8627825be7ad54c2a18b14de0e63aa5 sig_cn_org=None source=14.1 
<para>
The compression technique used for either in-line or out-of-line compressed
data can be selected for each column by setting
the <literal>COMPRESSION</literal> column option in <command>CREATE
TABLE</command> or <command>ALTER TABLE</command>.  The default for columns
with no explicit setting is to consult the
<xref linkend="guc-default-toast-compression"/> parameter at the time data is
inserted.
</para>
________________________________________________________-->
<para>
线内或者线外压缩数据所使用的压缩技术可以在<command>CREATE TABLE</command>或<command>ALTER TABLE</command>时设置<literal>COMPRESSION</literal>列选项来为每一列选择。
未显式设置的列的缺省值参照插入数据时的参数<xref linkend="guc-default-toast-compression"/>。
</para>
<!-- pgdoc-cn_end sig_en=a8627825be7ad54c2a18b14de0e63aa5 -->

<!-- pgdoc-cn_start sig_en=cb69e9528dd353c151d86137767648d1 sig_cn_org=None source=14.1 
<para>
As mentioned, there are multiple types of <acronym>TOAST</acronym> pointer datums.
The oldest and most common type is a pointer to out-of-line data stored in
a <firstterm><acronym>TOAST</acronym> table</firstterm> that is separate from, but
associated with, the table containing the <acronym>TOAST</acronym> pointer datum
itself.  These <firstterm>on-disk</firstterm> pointer datums are created by the
<acronym>TOAST</acronym> management code (in <filename>access/common/toast_internals.c</filename>)
when a tuple to be stored on disk is too large to be stored as-is.
Further details appear in <xref linkend="storage-toast-ondisk"/>.
Alternatively, a <acronym>TOAST</acronym> pointer datum can contain a pointer to
out-of-line data that appears elsewhere in memory.  Such datums are
necessarily short-lived, and will never appear on-disk, but they are very
useful for avoiding copying and redundant processing of large data values.
Further details appear in <xref linkend="storage-toast-inmemory"/>.
</para>
________________________________________________________-->
<para>
如前所述，有多种类型的<acronym>TOAST</acronym>指针数据。最古老且最常见的类型是
指向存储在一个<firstterm><acronym>TOAST</acronym> 表</firstterm>中的线外数据
的指针，<firstterm><acronym>TOAST</acronym> 表</firstterm>与包含该
<acronym>TOAST</acronym>指针数据本身的表是相关的，但两者又是被分离存储的。当
一个要被存储在磁盘上的元组过大时，这些<firstterm>磁盘上的</firstterm>指针数据由
<acronym>TOAST</acronym>管理代码（在<filename>access/heap/tuptoaster.c</filename>
中）所创建。<xref linkend="storage-toast-ondisk"/>中给出了更多的细节。
或者，一个<acronym>TOAST</acronym>指针数据能够包含一个出现在内存中某处的线外
数据的指针。这种数据必定是短命的并且将不会出现在磁盘上，但是它们对于避免
大型数据值的复制和冗余处理非常有用。详见
<xref linkend="storage-toast-inmemory"/>。
</para>
<!-- pgdoc-cn_end sig_en=cb69e9528dd353c151d86137767648d1 -->

<sect2 id="storage-toast-ondisk">
<!-- pgdoc-cn_start sig_en=12bcf1527fe0480ba2f7dfe4c184471e sig_cn_org=None source=14.1 
 <title>Out-of-Line, On-Disk TOAST Storage</title>
________________________________________________________-->
 <title>线外磁盘上 TOAST 存储</title>
<!-- pgdoc-cn_end sig_en=12bcf1527fe0480ba2f7dfe4c184471e -->

<!-- pgdoc-cn_start sig_en=697befb1150e4b0458de7b72259ec89e sig_cn_org=None source=14.1 
<para>
If any of the columns of a table are <acronym>TOAST</acronym>-able, the table will
have an associated <acronym>TOAST</acronym> table, whose OID is stored in the table's
<structname>pg_class</structname>.<structfield>reltoastrelid</structfield> entry.  On-disk
<acronym>TOAST</acronym>ed values are kept in the <acronym>TOAST</acronym> table, as
described in more detail below.
</para>
________________________________________________________-->
<para>
如果一个表中有任何一个列是可以<acronym>TOAST</acronym>的， 那么该表将有一个与之关联的<acronym>TOAST</acronym>表，其 OID 存储在表的<structname>pg_class</structname>.<structfield>reltoastrelid</structfield>项中。磁盘上的被<acronym>TOAST</acronym>过的值保存在<acronym>TOAST</acronym>表里，下文有更详细的描述。
</para>
<!-- pgdoc-cn_end sig_en=697befb1150e4b0458de7b72259ec89e -->

<!-- pgdoc-cn_start sig_en=115f96292007c64ff37ca06faa80f9de sig_cn_org=None source=14.1 
<para>
Out-of-line values are divided (after compression if used) into chunks of at
most <symbol>TOAST_MAX_CHUNK_SIZE</symbol> bytes (by default this value is chosen
so that four chunk rows will fit on a page, making it about 2000 bytes).
Each chunk is stored as a separate row in the <acronym>TOAST</acronym> table
belonging to the owning table.  Every
<acronym>TOAST</acronym> table has the columns <structfield>chunk_id</structfield> (an OID
identifying the particular <acronym>TOAST</acronym>ed value),
<structfield>chunk_seq</structfield> (a sequence number for the chunk within its value),
and <structfield>chunk_data</structfield> (the actual data of the chunk).  A unique index
on <structfield>chunk_id</structfield> and <structfield>chunk_seq</structfield> provides fast
retrieval of the values.  A pointer datum representing an out-of-line on-disk
<acronym>TOAST</acronym>ed value therefore needs to store the OID of the
<acronym>TOAST</acronym> table in which to look and the OID of the specific value
(its <structfield>chunk_id</structfield>).  For convenience, pointer datums also store the
logical datum size (original uncompressed data length), physical stored size
(different if compression was applied), and the compression method used, if
any.  Allowing for the varlena header bytes,
the total size of an on-disk <acronym>TOAST</acronym> pointer datum is therefore 18
bytes regardless of the actual size of the represented value.
</para>
________________________________________________________-->
<para>
线外值被分裂成（如果压缩过，在压缩之后分裂）最大为<symbol>TOAST_MAX_CHUNK_SIZE</symbol>（默认情况下该值应选为使得四个块（chunk）行能放在一个页面中，这个数值大约为2000 字节）字节的块。每个块都作为独立的行存储在从属于所属表的<acronym>TOAST</acronym>表中。每个<acronym>TOAST</acronym>表都有列<structfield>chunk_id</structfield>（一个表示特定的被<acronym>TOAST</acronym>过的数据的OID）、<structfield>chunk_seq</structfield>（一个序列号，存储该块在值中的位置）和一个<structfield>chunk_data</structfield>（该块的实际数据）。在<structfield>chunk_id</structfield>和<structfield>chunk_seq</structfield>上有一个唯一索引， 提供对值的快速检索。因此，一个表示线外磁盘上<acronym>TOAST</acronym>过的值的指针数据应存储要查看的<acronym>TOAST</acronym>表的OID以及 指定值的OID（它的<structfield>chunk_id</structfield>）。为了方便， 指针数据还存储逻辑数据的尺寸（原始的未压缩的数据长度），物理存储的尺寸（如果应用了压缩，则两者不同）以及采用的压缩方法(如果有的话)。 加上变长数据头部的字节，一个磁盘上<acronym>TOAST</acronym>指针数据的总尺寸是18字节，不管它代表的值的实际长度是多大。
</para>
<!-- pgdoc-cn_end sig_en=115f96292007c64ff37ca06faa80f9de -->

<!-- pgdoc-cn_start sig_en=7a12916507ecd4b1e6c4d2f8adf91ba6 sig_cn_org=None source=14.1 
<para>
The <acronym>TOAST</acronym> management code is triggered only
when a row value to be stored in a table is wider than
<symbol>TOAST_TUPLE_THRESHOLD</symbol> bytes (normally 2 kB).
The <acronym>TOAST</acronym> code will compress and/or move
field values out-of-line until the row value is shorter than
<symbol>TOAST_TUPLE_TARGET</symbol> bytes (also normally 2 kB, adjustable)
or no more gains can be had.  During an UPDATE
operation, values of unchanged fields are normally preserved as-is; so an
UPDATE of a row with out-of-line values incurs no <acronym>TOAST</acronym> costs if
none of the out-of-line values change.
</para>
________________________________________________________-->
<para>
<acronym>TOAST</acronym>管理代码只有在准备向一个表中存储超过<symbol>TOAST_TUPLE_THRESHOLD</symbol>字节（通常是2kB）的行值的时候才会触发。<acronym>TOAST</acronym>代码将压缩和/或线外存储域值，直到行值比<symbol>TOAST_TUPLE_TARGET</symbol>字节（通常也是2kB）短，或者无法得到更好的结果的时候才停止。在一个 UPDATE 操作过程中，未改变的域的值通常原样保存； 所以，如果 UPDATE 一个带有线外值的行时，假如线外值没有变化，那么将不会产生<acronym>TOAST</acronym>开销。
</para>
<!-- pgdoc-cn_end sig_en=7a12916507ecd4b1e6c4d2f8adf91ba6 -->

<!-- pgdoc-cn_start sig_en=43f4bc7433998191fc9b929200382cd6 sig_cn_org=b151339d771af73692692fca2834858e source=15.7 
<para>
The <acronym>TOAST</acronym> management code recognizes four different strategies
for storing <acronym>TOAST</acronym>-able columns on disk:

   <itemizedlist>
    <listitem>
     <para>
      <literal>PLAIN</literal> prevents either compression or
      out-of-line storage.  This is the only possible strategy for
      columns of non-<acronym>TOAST</acronym>-able data types.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>EXTENDED</literal> allows both compression and out-of-line
      storage.  This is the default for most <acronym>TOAST</acronym>-able data types.
      Compression will be attempted first, then out-of-line storage if
      the row is still too big.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>EXTERNAL</literal> allows out-of-line storage but not
      compression.  Use of <literal>EXTERNAL</literal> will
      make substring operations on wide <type>text</type> and
      <type>bytea</type> columns faster (at the penalty of increased storage
      space) because these operations are optimized to fetch only the
      required parts of the out-of-line value when it is not compressed.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>MAIN</literal> allows compression but not out-of-line
      storage.  (Actually, out-of-line storage will still be performed
      for such columns, but only as a last resort when there is no other
      way to make the row small enough to fit on a page.)
     </para>
    </listitem>
   </itemizedlist>

Each <acronym>TOAST</acronym>-able data type specifies a default strategy for columns
of that data type, but the strategy for a given table column can be altered
with <link linkend="sql-altertable"><command>ALTER TABLE ... SET STORAGE</command></link>.
</para>
________________________________________________________-->
<para>
<acronym>TOAST</acronym>管理代码识别四种不同的策略，用于存储磁盘上的<acronym>TOAST</acronym>列：

   <itemizedlist>
    <listitem>
     <para>
      <literal>PLAIN</literal>阻止压缩或离线存储。这是非<acronym>TOAST</acronym>数据类型列的唯一可能策略。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>EXTENDED</literal>允许压缩和离线存储。这是大多数<acronym>TOAST</acronym>数据类型的默认值。
      首先尝试压缩，然后如果行仍然太大，则进行离线存储。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>EXTERNAL</literal>允许离线存储但不允许压缩。使用<literal>EXTERNAL</literal>
      将使宽<type>text</type>和<type>bytea</type>列上的子串操作更快（以增加存储空间为代价），
      因为这些操作被优化为仅在未压缩时获取离线值的所需部分。
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>MAIN</literal>允许压缩但不允许离线存储。（实际上，对于这样的列，仍将执行离线存储，
      但只有在没有其他方法使行足够小以适合页面时才会执行。）
     </para>
    </listitem>
   </itemizedlist>

每个<acronym>TOAST</acronym>数据类型指定了该数据类型列的默认策略，但给定表列的策略可以通过
<link linkend="sql-altertable"><command>ALTER TABLE ... SET STORAGE</command></link>进行更改。
</para>
<!-- pgdoc-cn_end sig_en=43f4bc7433998191fc9b929200382cd6 -->

<!-- pgdoc-cn_start sig_en=6de4693fd5e5d59d6e9c614777b201fa sig_cn_org=None source=14.1 
<para>
<symbol>TOAST_TUPLE_TARGET</symbol> can be adjusted for each table using
<link linkend="sql-altertable"><command>ALTER TABLE ... SET (toast_tuple_target = N)</command></link>
</para>
________________________________________________________-->
<para>
可以使用<link linkend="sql-altertable"><command>ALTER TABLE ... SET (toast_tuple_target = N)</command></link>为每个表调整<symbol>TOAST_TUPLE_TARGET</symbol>
</para>
<!-- pgdoc-cn_end sig_en=6de4693fd5e5d59d6e9c614777b201fa -->

<!-- pgdoc-cn_start sig_en=e31d6354e179a792a7031789628b1c63 sig_cn_org=None source=14.1 
<para>
This scheme has a number of advantages compared to a more straightforward
approach such as allowing row values to span pages.  Assuming that queries are
usually qualified by comparisons against relatively small key values, most of
the work of the executor will be done using the main row entry. The big values
of <acronym>TOAST</acronym>ed attributes will only be pulled out (if selected at all)
at the time the result set is sent to the client. Thus, the main table is much
smaller and more of its rows fit in the shared buffer cache than would be the
case without any out-of-line storage. Sort sets shrink also, and sorts will
more often be done entirely in memory. A little test showed that a table
containing typical HTML pages and their URLs was stored in about half of the
raw data size including the <acronym>TOAST</acronym> table, and that the main table
contained only about 10% of the entire data (the URLs and some small HTML
pages). There was no run time difference compared to an un-<acronym>TOAST</acronym>ed
comparison table, in which all the HTML pages were cut down to 7 kB to fit.
</para>
________________________________________________________-->
<para>
这个方法比那些更直接的方法（比如允许行值跨越多个页面）有更多优点。 假设查询通常是用相对比较短的键值进行匹配的，那么执行器的大多数工作都将使用主行项完成。<acronym>TOAST</acronym>过的属性的大值只是在把结果集发送给客户端的时候才被抽出来（如果它被选中）。 因此，主表要小得多，并且它的能放入到共享缓冲区中的行要比没有任何线外存储的方案更多。 排序集也缩小了，并且排序将更多地在内存里完成。一个小测试表明，一个典型的保存 HTML 页面以及它们的 URL 的表占用的存储（包括<acronym>TOAST</acronym>表在内）大约只有裸数据的一半，而主表只包含全部数据的 10%（URL和一些小的 HTML 页面）。与在一个非<acronym>TOAST</acronym>的对照表里面存储（把全部 HTML 页面裁剪成 7Kb 以匹配页面大小）同样的数据相比，运行时没有任何区别。
</para>
<!-- pgdoc-cn_end sig_en=e31d6354e179a792a7031789628b1c63 -->

</sect2>

<sect2 id="storage-toast-inmemory">
<!-- pgdoc-cn_start sig_en=0a507a20ba96f2d4c6eedbce0d328816 sig_cn_org=None source=14.1 
 <title>Out-of-Line, In-Memory TOAST Storage</title>
________________________________________________________-->
 <title>线外内存中 TOAST 存储</title>
<!-- pgdoc-cn_end sig_en=0a507a20ba96f2d4c6eedbce0d328816 -->

<!-- pgdoc-cn_start sig_en=782a6ad2ea6f1e65a0f4062ea200a5ea sig_cn_org=None source=14.1 
<para>
<acronym>TOAST</acronym> pointers can point to data that is not on disk, but is
elsewhere in the memory of the current server process.  Such pointers
obviously cannot be long-lived, but they are nonetheless useful.  There
are currently two sub-cases:
pointers to <firstterm>indirect</firstterm> data and
pointers to <firstterm>expanded</firstterm> data.
</para>
________________________________________________________-->
<para>
<acronym>TOAST</acronym>指针可以指向不在磁盘上但在当前服务器进程内存中
的数据。这样的指针显然不是长期存在的，但是它们是有用的。当前有两种
子情况：指向<firstterm>间接</firstterm>数据的指针以及指向
<firstterm>扩展</firstterm>数据的指针。
</para>
<!-- pgdoc-cn_end sig_en=782a6ad2ea6f1e65a0f4062ea200a5ea -->

<!-- pgdoc-cn_start sig_en=6161145f305cb243152e64be56e693c9 sig_cn_org=None source=14.1 
<para>
Indirect <acronym>TOAST</acronym> pointers simply point at a non-indirect varlena
value stored somewhere in memory.  This case was originally created merely
as a proof of concept, but it is currently used during logical decoding to
avoid possibly having to create physical tuples exceeding 1 GB (as pulling
all out-of-line field values into the tuple might do).  The case is of
limited use since the creator of the pointer datum is entirely responsible
that the referenced data survives for as long as the pointer could exist,
and there is no infrastructure to help with this.
</para>
________________________________________________________-->
<para>
间接<acronym>TOAST</acronym>指针指向存储在内存中某个地方的非间接 varlena
值。这种情况仅仅作为一种概念验证而创建，但是当前它被用来在逻辑解码期间
避免创建超过 1GB 的物理元组（把所有线外域值都拉入元组就会这样）。这种
情况用处有限，因为该指针数据的创建者需要负责确保只要指针存在，被引用数
据就应该存在，并且没有其他设施来帮助它。
</para>
<!-- pgdoc-cn_end sig_en=6161145f305cb243152e64be56e693c9 -->

<!-- pgdoc-cn_start sig_en=037fce0f5a7f4e80ac9312089ccbd218 sig_cn_org=None source=14.1 
<para>
Expanded <acronym>TOAST</acronym> pointers are useful for complex data types
whose on-disk representation is not especially suited for computational
purposes.  As an example, the standard varlena representation of a
<productname>PostgreSQL</productname> array includes dimensionality information, a
nulls bitmap if there are any null elements, then the values of all the
elements in order.  When the element type itself is variable-length, the
only way to find the <replaceable>N</replaceable>'th element is to scan through all the
preceding elements.  This representation is appropriate for on-disk storage
because of its compactness, but for computations with the array it's much
nicer to have an <quote>expanded</quote> or <quote>deconstructed</quote>
representation in which all the element starting locations have been
identified.  The <acronym>TOAST</acronym> pointer mechanism supports this need by
allowing a pass-by-reference Datum to point to either a standard varlena
value (the on-disk representation) or a <acronym>TOAST</acronym> pointer that
points to an expanded representation somewhere in memory.  The details of
this expanded representation are up to the data type, though it must have
a standard header and meet the other API requirements given
in <filename>src/include/utils/expandeddatum.h</filename>.  C-level functions
working with the data type can choose to handle either representation.
Functions that do not know about the expanded representation, but simply
apply <function>PG_DETOAST_DATUM</function> to their inputs, will automatically
receive the traditional varlena representation; so support for an expanded
representation can be introduced incrementally, one function at a time.
</para>
________________________________________________________-->
<para>
扩展的<acronym>TOAST</acronym>指针对于复杂数据类型有用，这些数据类型的磁盘上
表示形式不是特别适合计算性的目的。例如，一个<productname>PostgreSQL</productname>
数组的标准 varlena 表达包括了维度信息、一个空值位图（如果有任何空值元素），
然后按顺序是所有元素的值。当元素类型本身是变长时，找到第<replaceable>N</replaceable>
个元素的唯一方式是扫描所有在它前面的元素。这种表达适合于磁盘上的存储，因为它
很紧凑。但是为了对该数组进行计算，则<quote>扩展</quote>或者<quote>结构</quote>表
达会更好，这些表达中所有元素的开始位置都会被标记出来。为了支持这种需要，
<acronym>TOAST</acronym>指针机制通过允许一个传引用的数据指向一个标准 varlena
值（磁盘上的表达）或者一个<acronym>TOAST</acronym>指针指向内存中某处的一个扩展
表达。这种扩展表达的细节取决于数据类型，不过它必须具有一个标准的头部并且符合
<filename>src/include/utils/expandeddatum.h</filename>中给定的其他 API 要求。该数据
类型的 C-级别函数可以选择处理任一表达。不了解扩展表达但简单地在其输入上应用
<function>PG_DETOAST_DATUM</function>的函数将自动地接收到传统的 varlena 表达。
因此对于一种扩展表达的支持可以被增量式地引入，一次一个函数。
</para>
<!-- pgdoc-cn_end sig_en=037fce0f5a7f4e80ac9312089ccbd218 -->

<!-- pgdoc-cn_start sig_en=c7f8e4145f676a5533c96eb105ff8346 sig_cn_org=None source=14.1 
<para>
<acronym>TOAST</acronym> pointers to expanded values are further broken down
into <firstterm>read-write</firstterm> and <firstterm>read-only</firstterm> pointers.
The pointed-to representation is the same either way, but a function that
receives a read-write pointer is allowed to modify the referenced value
in-place, whereas one that receives a read-only pointer must not; it must
first create a copy if it wants to make a modified version of the value.
This distinction and some associated conventions make it possible to avoid
unnecessary copying of expanded values during query execution.
</para>
________________________________________________________-->
<para>
扩展值的<acronym>TOAST</acronym>指针会被进一步分解成
<firstterm>read-write</firstterm>和<firstterm>read-only</firstterm>指针。两种方式下被
指向的表达是相同的，但是收到一个读写指针的函数被允许就地修改被引用值，
而接收到只读指针的函数则不能。如果后者想要做一个该值的被修改的版本，
它必须先创建一个副本。这种区分和一些相关的惯例使得可以在查询执行期间
避免不必要的扩展值副本。
</para>
<!-- pgdoc-cn_end sig_en=c7f8e4145f676a5533c96eb105ff8346 -->

<!-- pgdoc-cn_start sig_en=d9f0b769c7c1229fb4975fedeb9c48c6 sig_cn_org=None source=14.1 
<para>
For all types of in-memory <acronym>TOAST</acronym> pointer, the <acronym>TOAST</acronym>
management code ensures that no such pointer datum can accidentally get
stored on disk.  In-memory <acronym>TOAST</acronym> pointers are automatically
expanded to normal in-line varlena values before storage &mdash; and then
possibly converted to on-disk <acronym>TOAST</acronym> pointers, if the containing
tuple would otherwise be too big.
</para>
________________________________________________________-->
<para>
对于所有类型的内存中<acronym>TOAST</acronym>指针，<acronym>TOAST</acronym>管理
代码会确保这类指针数据不会意外地被存储在磁盘上。在存储之前内存中
<acronym>TOAST</acronym>指针会被自动地扩展成通常的线内 varlena 值 &mdash; 然后
可能会被转换成磁盘上的<acronym>TOAST</acronym>指针（如果包含的元组不是太大）。
</para>
<!-- pgdoc-cn_end sig_en=d9f0b769c7c1229fb4975fedeb9c48c6 -->

</sect2>

</sect1>

<sect1 id="storage-fsm">

<!-- pgdoc-cn_start sig_en=69063dd8e03ba771edb401ad231c8248 sig_cn_org=None source=14.1 
<title>Free Space Map</title>
________________________________________________________-->
<title>空闲空间映射</title>
<!-- pgdoc-cn_end sig_en=69063dd8e03ba771edb401ad231c8248 -->

<!-- pgdoc-cn_start sig_en=a4c8c9079981e726c08866c951907c69 sig_cn_org=None source=14.1 
<indexterm>
 <primary>Free Space Map</primary>
</indexterm>
________________________________________________________-->
<indexterm>
 <primary>空闲空间映射</primary>
</indexterm>
<!-- pgdoc-cn_end sig_en=a4c8c9079981e726c08866c951907c69 -->
<!-- pgdoc-cn_start sig_en=21724cc015b752c05b8068e6aa74ba4c sig_cn_org=None source=14.1 
<indexterm><primary>FSM</primary><see>Free Space Map</see></indexterm>
________________________________________________________-->
<indexterm><primary>FSM</primary><see>空闲空间映射</see></indexterm>
<!-- pgdoc-cn_end sig_en=21724cc015b752c05b8068e6aa74ba4c -->

<!-- pgdoc-cn_start sig_en=f6162fa6a3fd03b637b0bca0d8f65e4b sig_cn_org=79bd5e8e536cdd0acb00ad6dcd461f59 source=15.7 
<para>
Each heap and index relation, except for hash indexes, has a Free Space Map
(<acronym>FSM</acronym>) to keep track of available space in the relation.
It's stored alongside the main relation data in a separate relation fork,
named after the filenode number of the relation, plus a <literal>_fsm</literal>
suffix. For example, if the filenode of a relation is 12345, the
<acronym>FSM</acronym> is stored in a file called
<filename>12345_fsm</filename>, in the same directory as the main relation file.
</para>
________________________________________________________-->
<para>
每个堆和索引关系，除了哈希索引外，都有一个空闲空间映射（<acronym>FSM</acronym>）来跟踪关系中的可用空间。
它存储在与主关系数据相邻的一个单独的关系分支中，命名为关系的文件节点号，再加上一个<literal>_fsm</literal>后缀。
例如，如果一个关系的文件节点号是12345，<acronym>FSM</acronym>存储在一个名为<filename>12345_fsm</filename>的文件中，
与主关系文件在同一个目录中。
</para>
<!-- pgdoc-cn_end sig_en=f6162fa6a3fd03b637b0bca0d8f65e4b -->

<!-- pgdoc-cn_start sig_en=1625e16f7af83293f890815ae5d3b6b0 sig_cn_org=None source=14.1 
<para>
The Free Space Map is organized as a tree of <acronym>FSM</acronym> pages. The
bottom level <acronym>FSM</acronym> pages store the free space available on each
heap (or index) page, using one byte to represent each such page. The upper
levels aggregate information from the lower levels.
</para>
________________________________________________________-->
<para>
空闲空间映射被组织成一棵<acronym>FSM</acronym>页面的树。底层<acronym>FSM</acronym>页面存储了在每一个堆（或索引）页面中可用的空闲空间，对于每一个这样的页面使用一个字节来表示。上层<acronym>FSM</acronym>页面则聚集来自于下层页面的信息。
</para>
<!-- pgdoc-cn_end sig_en=1625e16f7af83293f890815ae5d3b6b0 -->

<!-- pgdoc-cn_start sig_en=0405954f4d6c6d579201eda6ec707eed sig_cn_org=None source=14.1 
<para>
Within each <acronym>FSM</acronym> page is a binary tree, stored in an array with
one byte per node. Each leaf node represents a heap page, or a lower level
<acronym>FSM</acronym> page. In each non-leaf node, the higher of its children's
values is stored. The maximum value in the leaf nodes is therefore stored
at the root.
</para>
________________________________________________________-->
<para>
在每一个<acronym>FSM</acronym>页面中是一个二叉树，存储在一个数组中，每一个节点一个字节。每个叶节点表示一个堆页面或者一个下层<acronym>FSM</acronym>页面。在每一个非叶节点中存储了它孩子节点中的最大值。因此叶节点中的最大值被存储在根中。
</para>
<!-- pgdoc-cn_end sig_en=0405954f4d6c6d579201eda6ec707eed -->

<!-- pgdoc-cn_start sig_en=866823d74f5a02eda2045fcb06276af7 sig_cn_org=None source=14.1 
<para>
See <filename>src/backend/storage/freespace/README</filename> for more details on
how the <acronym>FSM</acronym> is structured, and how it's updated and searched.
The <xref linkend="pgfreespacemap"/> module
can be used to examine the information stored in free space maps.
</para>
________________________________________________________-->
<para>
关于如何构建、更新和搜索<acronym>FSM</acronym>的更多信息请参考<filename>src/backend/storage/freespace/README</filename>。<xref linkend="pgfreespacemap"/>模块可以用来检查存储在空闲空间映射中的信息。
</para>
<!-- pgdoc-cn_end sig_en=866823d74f5a02eda2045fcb06276af7 -->

</sect1>

<sect1 id="storage-vm">

<!-- pgdoc-cn_start sig_en=b5ef56a7c966f8d3a3d750dacd475313 sig_cn_org=None source=14.1 
<title>Visibility Map</title>
________________________________________________________-->
<title>可见性映射</title>
<!-- pgdoc-cn_end sig_en=b5ef56a7c966f8d3a3d750dacd475313 -->

<!-- pgdoc-cn_start sig_en=e3be1d1551507c327faddf34de5f2e0e sig_cn_org=None source=14.1 
<indexterm>
 <primary>Visibility Map</primary>
</indexterm>
________________________________________________________-->
<indexterm>
 <primary>可见性映射</primary>
</indexterm>
<!-- pgdoc-cn_end sig_en=e3be1d1551507c327faddf34de5f2e0e -->
<!-- pgdoc-cn_start sig_en=d3375035edbecc108f648373c0c78f20 sig_cn_org=None source=14.1 
<indexterm><primary>VM</primary><see>Visibility Map</see></indexterm>
________________________________________________________-->
<indexterm><primary>VM</primary><see>可见性映射</see></indexterm>
<!-- pgdoc-cn_end sig_en=d3375035edbecc108f648373c0c78f20 -->

<!-- pgdoc-cn_start sig_en=359d7d0bbf231de2e2720e5aae0697cc sig_cn_org=None source=14.1 
<para>
Each heap relation has a Visibility Map
(VM) to keep track of which pages contain only tuples that are known to be
visible to all active transactions; it also keeps track of which pages contain
only frozen tuples.  It's stored
alongside the main relation data in a separate relation fork, named after the
filenode number of the relation, plus a <literal>_vm</literal> suffix. For example,
if the filenode of a relation is 12345, the VM is stored in a file called
<filename>12345_vm</filename>, in the same directory as the main relation file.
Note that indexes do not have VMs.
</para>
________________________________________________________-->
<para>
每一个堆关系都有一个可见性映射（VM）用来跟踪哪些页面
只包含已知对所有活动事务可见的元组，它也跟踪哪些页面只包含
未被冻结的元组。它伴随着主关系数据被存储在一个独立的关系分支中，
以该关系的文件节点号加上一个<literal>_vm</literal>后缀来命名。例如，
如果一个关系的文件节点为12345，其VM被存储在名为<filename>12345_vm</filename>的文件中，
该文件域主关系文件在同一个目录中。注意索引没有VM。
</para>
<!-- pgdoc-cn_end sig_en=359d7d0bbf231de2e2720e5aae0697cc -->

<!-- pgdoc-cn_start sig_en=a56533bfafd0d22470c3ad86e9f67c76 sig_cn_org=None source=14.1 
<para>
The visibility map stores two bits per heap page.  The first bit, if set,
indicates that the page is all-visible, or in other words that the page does
not contain any tuples that need to be vacuumed.
This information can also be used
by <link linkend="indexes-index-only-scans"><firstterm>index-only
scans</firstterm></link> to answer queries using only the index tuple.
The second bit, if set, means that all tuples on the page have been frozen.
That means that even an anti-wraparound vacuum need not revisit the page.
</para>
________________________________________________________-->
<para>
可见性映射仅为每个堆页面存储两个位。第一位如果被设置，
表示该页面上的元组都是可见的，或者换句话说该页面不含有
任何需要被清理的元组。这些信息也可以被<link linkend="indexes-index-only-scans"><firstterm>index-only
scans</firstterm></link>用来只依靠索引元组回答查询。第二位如果
被设置，表示该页面上的元组都已经被冻结。这也意味着防回卷
清理操作也不需要重新访问该页面。
</para>
<!-- pgdoc-cn_end sig_en=a56533bfafd0d22470c3ad86e9f67c76 -->

<!-- pgdoc-cn_start sig_en=7b0320ec198f189b4bd4682f34e4cd39 sig_cn_org=None source=14.1 
<para>
The map is conservative in the sense that we make sure that whenever a bit is
set, we know the condition is true, but if a bit is not set, it might or
might not be true. Visibility map bits are only set by vacuum, but are
cleared by any data-modifying operations on a page.
</para>
________________________________________________________-->
<para>
该映射是保守的，我们可以确定不论何时一个位被设置，那就说明条件为真，但是如果一个位没有被设置，它可能为真也可能不为真。可见性映射的位只会被清理操作设置，但是可以被任何在页面上进行的数据修改操作清除。
</para>
<!-- pgdoc-cn_end sig_en=7b0320ec198f189b4bd4682f34e4cd39 -->

<!-- pgdoc-cn_start sig_en=6759f8acf77549e057566712f8c335e7 sig_cn_org=None source=14.1 
<para>
The <xref linkend="pgvisibility"/> module can be used to examine the
information stored in the visibility map.
</para>
________________________________________________________-->
<para>
<xref linkend="pgvisibility"/>模块可以被用来检查存储在可见性
映射中的信息。
</para>
<!-- pgdoc-cn_end sig_en=6759f8acf77549e057566712f8c335e7 -->

</sect1>

<sect1 id="storage-init">

<!-- pgdoc-cn_start sig_en=1252cb63d14a570eeae79da5770bf227 sig_cn_org=None source=14.1 
<title>The Initialization Fork</title>
________________________________________________________-->
<title>初始化分支</title>
<!-- pgdoc-cn_end sig_en=1252cb63d14a570eeae79da5770bf227 -->

<!-- pgdoc-cn_start sig_en=93c111eadf6c1ef14b6738fd0b18a8a9 sig_cn_org=None source=14.1 
<indexterm>
 <primary>Initialization Fork</primary>
</indexterm>
________________________________________________________-->
<indexterm>
 <primary>初始化分支</primary>
</indexterm>
<!-- pgdoc-cn_end sig_en=93c111eadf6c1ef14b6738fd0b18a8a9 -->

<!-- pgdoc-cn_start sig_en=222d40456222fd160a9ca14b1463fd8a sig_cn_org=None source=14.1 
<para>
Each unlogged table, and each index on an unlogged table, has an initialization
fork.  The initialization fork is an empty table or index of the appropriate
type.  When an unlogged table must be reset to empty due to a crash, the
initialization fork is copied over the main fork, and any other forks are
erased (they will be recreated automatically as needed).
</para>
________________________________________________________-->
<para>
每一个不被日志记录的表以及在这类表上的每一个索引，都有一个初始化分支。初始化分支是一个适当类型的空表或空索引。当一个不被日志记录的表由于崩溃必须被重置为空时，初始化分支被随着主分支复制，而任何其他分支则被擦除（它们会在需要时自动被重建）。
</para>
<!-- pgdoc-cn_end sig_en=222d40456222fd160a9ca14b1463fd8a -->

</sect1>

<sect1 id="storage-page-layout">

<!-- pgdoc-cn_start sig_en=840e100f36dc4b36892562628ab65103 sig_cn_org=None source=14.1 
<title>Database Page Layout</title>
________________________________________________________-->
<title>数据库页面布局</title>
<!-- pgdoc-cn_end sig_en=840e100f36dc4b36892562628ab65103 -->

<!-- pgdoc-cn_start sig_en=2e956eb083a65842de182a67d5612869 sig_cn_org=None source=14.1 
<para>
This section provides an overview of the page format used within
<productname>PostgreSQL</productname> tables and indexes.<footnote>
  <para>
    Actually, use of this page format is not required for either table or
    index access methods. The <literal>heap</literal> table access method
    always uses this format.  All the existing index methods also use the
    basic format, but the data kept on index metapages usually doesn't follow
    the item layout rules.
  </para>
</footnote>
Sequences and <acronym>TOAST</acronym> tables are formatted just like a regular table.
</para>
________________________________________________________-->
<para>
本章提供一个<productname>PostgreSQL</productname>的表和索引所使用的页面格式的概述。<footnote>
  <para>
    实际上，表和索引访问模式并不需要使用这种页面格式。 <literal>heap</literal>表访问方法总是采用这种格式。
    目前所有的索引方法的确也使用这个基本格式， 但索引元页里的数据通常并不遵循项布局规则。
  </para>
</footnote>
序列和<acronym>TOAST</acronym>表的格式就像一个普通表一样。
</para>
<!-- pgdoc-cn_end sig_en=2e956eb083a65842de182a67d5612869 -->

<!-- pgdoc-cn_start sig_en=eaded65ec6903eee6f933022eb76fe1b sig_cn_org=None source=14.1 
<para>
In the following explanation, a
<firstterm>byte</firstterm>
is assumed to contain 8 bits.  In addition, the term
<firstterm>item</firstterm>
refers to an individual data value that is stored on a page.  In a table,
an item is a row; in an index, an item is an index entry.
</para>
________________________________________________________-->
<para>
在下面解释中，一个<firstterm>字节</firstterm>被假定包含 8 个位。
另外，术语<firstterm>item</firstterm>指的是存储在一个页面里的
独立数据值。 在一个表里，一个项是一个行；在一个索引里，一个项是
一条索引记录。
</para>
<!-- pgdoc-cn_end sig_en=eaded65ec6903eee6f933022eb76fe1b -->

<!-- pgdoc-cn_start sig_en=0ebaa46d89d16d6897539c75704343c3 sig_cn_org=None source=14.1 
<para>
Every table and index is stored as an array of <firstterm>pages</firstterm> of a
fixed size (usually 8 kB, although a different page size can be selected
when compiling the server).  In a table, all the pages are logically
equivalent, so a particular item (row) can be stored in any page.  In
indexes, the first page is generally reserved as a <firstterm>metapage</firstterm>
holding control information, and there can be different types of pages
within the index, depending on the index access method.
</para>
________________________________________________________-->
<para>
每个表和索引都以一个固定尺寸（通常是 8kB，不过在编译服务器时可以选择其他不同的尺寸）的<firstterm>页面</firstterm>数组存储。 在表中，所有页面在逻辑上都相同，所以一个特定的项（行）可以被存储在任何页面里。 在索引里，第一个页面通常保留为<firstterm>元页</firstterm>来保存控制信息， 并且依索引访问方法的不同，在索引里可能有不同类型的页面。
</para>
<!-- pgdoc-cn_end sig_en=0ebaa46d89d16d6897539c75704343c3 -->

<!-- pgdoc-cn_start sig_en=9bff0c47db4a59c36679073c806ef315 sig_cn_org=None source=14.1 
<para>
<xref linkend="page-table"/> shows the overall layout of a page.
There are five parts to each page.
</para>
________________________________________________________-->
<para>
<xref linkend="page-table"/>显示一个页面的总体布局。每个页面有五个部分。
</para>
<!-- pgdoc-cn_end sig_en=9bff0c47db4a59c36679073c806ef315 -->

<table tocentry="1" id="page-table">
<!-- pgdoc-cn_start sig_en=8dbabb6c21c978b4eeaebddd665cfc6b sig_cn_org=None source=14.1 
<title>Overall Page Layout</title>
________________________________________________________-->
<title>总体页面布局</title>
<!-- pgdoc-cn_end sig_en=8dbabb6c21c978b4eeaebddd665cfc6b -->
<!-- pgdoc-cn_start sig_en=ed4088efda4b9ca32552f5f3a10357b9 sig_cn_org=None source=14.1 
<titleabbrev>Page Layout</titleabbrev>
________________________________________________________-->
<titleabbrev>页面布局</titleabbrev>
<!-- pgdoc-cn_end sig_en=ed4088efda4b9ca32552f5f3a10357b9 -->
<tgroup cols="2">
<thead>
<!-- pgdoc-cn_start sig_en=225eb84ca2b2f12d8273caffcec05ef6 sig_cn_org=None source=14.1 
<row>
<entry>
Item
</entry>
<entry>Description</entry>
</row>
________________________________________________________-->
<row>
<entry>
项
</entry>
<entry>描述</entry>
</row>
<!-- pgdoc-cn_end sig_en=225eb84ca2b2f12d8273caffcec05ef6 -->
</thead>

<tbody>

<!-- pgdoc-cn_start sig_en=044f0d0a8209ee0c8cf7a5b03f0eb696 sig_cn_org=None source=14.1 
<row>
 <entry>PageHeaderData</entry>
 <entry>24 bytes long. Contains general information about the page, including
free space pointers.</entry>
</row>
________________________________________________________-->
<row>
 <entry>PageHeaderData</entry>
 <entry>24字节长。包含关于页面的一般信息，包括空闲空间指针。</entry>
</row>
<!-- pgdoc-cn_end sig_en=044f0d0a8209ee0c8cf7a5b03f0eb696 -->

<!-- pgdoc-cn_start sig_en=b28c928600a4a9bcd1ff2b8912e4b616 sig_cn_org=None source=14.1 
<row>
<entry>ItemIdData</entry>
<entry>Array of item identifiers pointing to the actual items. Each
entry is an (offset,length) pair. 4 bytes per item.</entry>
</row>
________________________________________________________-->
<row>
<entry>ItemIdData</entry>
<entry>指向实际项的项标识符数组。每一个条目是一对(偏移量、长度)。每个项 4 字节。</entry>
</row>
<!-- pgdoc-cn_end sig_en=b28c928600a4a9bcd1ff2b8912e4b616 -->

<!-- pgdoc-cn_start sig_en=488f4f96e3c9973b0f79009fde8969a2 sig_cn_org=None source=14.1 
<row>
<entry>Free space</entry>
<entry>The unallocated space. New item identifiers are allocated from
the start of this area, new items from the end.</entry>
</row>
________________________________________________________-->
<row>
<entry>Free space</entry>
<entry>未分配的空间（空闲空间）。新项标识符从这个区域的开头开始分配，新项从其结尾开始分配。</entry>
</row>
<!-- pgdoc-cn_end sig_en=488f4f96e3c9973b0f79009fde8969a2 -->

<!-- pgdoc-cn_start sig_en=02ff31b4a6d2c8ddc74d16d866d951ed sig_cn_org=None source=14.1 
<row>
<entry>Items</entry>
<entry>The actual items themselves.</entry>
</row>
________________________________________________________-->
<row>
<entry>Items</entry>
<entry>实际的项本身。</entry>
</row>
<!-- pgdoc-cn_end sig_en=02ff31b4a6d2c8ddc74d16d866d951ed -->

<!-- pgdoc-cn_start sig_en=076dfbe8edd885502b58ead9fb135928 sig_cn_org=None source=14.1 
<row>
<entry>Special space</entry>
<entry>Index access method specific data. Different methods store different
data. Empty in ordinary tables.</entry>
</row>
________________________________________________________-->
<row>
<entry>Special space</entry>
<entry>索引访问模式相关的数据。不同的索引访问方式存放不同的数据。在普通表中为空。</entry>
</row>
<!-- pgdoc-cn_end sig_en=076dfbe8edd885502b58ead9fb135928 -->

</tbody>
</tgroup>
</table>

<!-- pgdoc-cn_start sig_en=ea86a43b11c18ddeb3265cb64d0d7b9d sig_cn_org=None source=14.1 
 <para>

  The first 24 bytes of each page consists of a page header
  (<structname>PageHeaderData</structname>). Its format is detailed in <xref
  linkend="pageheaderdata-table"/>. The first field tracks the most
  recent WAL entry related to this page. The second field contains
  the page checksum if <xref linkend="app-initdb-data-checksums"/> are
  enabled.  Next is a 2-byte field containing flag bits. This is followed
  by three 2-byte integer fields (<structfield>pd_lower</structfield>,
  <structfield>pd_upper</structfield>, and
  <structfield>pd_special</structfield>).  These contain byte offsets
  from the page start to the start of unallocated space, to the end of
  unallocated space, and to the start of the special space.  The next 2
  bytes of the page header, <structfield>pd_pagesize_version</structfield>,
  store both the page size and a version indicator.  Beginning with
  <productname>PostgreSQL</productname> 8.3 the version number is 4;
  <productname>PostgreSQL</productname> 8.1 and 8.2 used version number 3;
  <productname>PostgreSQL</productname> 8.0 used version number 2;
  <productname>PostgreSQL</productname> 7.3 and 7.4 used version number 1;
  prior releases used version number 0.
  (The basic page layout and header format has not changed in most of these
  versions, but the layout of heap row headers has.)  The page size
  is basically only present as a cross-check; there is no support for having
  more than one page size in an installation.
  The last field is a hint that shows whether pruning the page is likely
  to be profitable: it tracks the oldest un-pruned XMAX on the page.

 </para>
________________________________________________________-->
 <para>

  每个页面的头24个字节组成页头（<structname>PageHeaderData</structname>）。它的格式在<xref linkend="pageheaderdata-table"/>里详细介绍。 第一个域跟踪与此页面相关的最近的 WAL 项。第二个域包含该页面的校验码（如果<xref linkend="app-initdb-data-checksums"/>被启用）。接下来一个2字节的域包含标志位。此后跟随着三个 2 字节的整数域 （<structfield>pd_lower</structfield>、<structfield>pd_upper</structfield>和<structfield>pd_special</structfield>）。 这些域包含从页面开始位置到未分配空间开头的字节偏移、到未分配空间结尾的字节偏移以及到特殊空间开头的字节偏移。页面头中再接下来的 2 字节（<structfield>pd_pagesize_version</structfield>）存储页面尺寸和一个版本指示器。从<productname>PostgreSQL</productname> 8.3开始的版本号为4；<productname>PostgreSQL</productname> 8.1和8.2使用版本号3；<productname>PostgreSQL</productname> 8.0 使用版本号 2；<productname>PostgreSQL</productname> 7.3 和 7.4 使用版本号 1； 更早的版本使用版本号 0（基本页面布局和头格式在大部分这些版本里都没有改变，但是堆的行头部布局有所变化）。 页面大小主要用于交叉检查；目前在一次安装里，还不能支持多于一种页面大小。最后的域是一个提示，它显示删除该页是否可能获益：它跟踪在页面上最老的未删除的XMAX。

 </para>
<!-- pgdoc-cn_end sig_en=ea86a43b11c18ddeb3265cb64d0d7b9d -->

 <table tocentry="1" id="pageheaderdata-table">
<!-- pgdoc-cn_start sig_en=c3c9e81f93a983cc0eb13dc9c5635e71 sig_cn_org=None source=14.1 
 <title>PageHeaderData Layout</title>
________________________________________________________-->
 <title>PageHeaderData布局</title>
<!-- pgdoc-cn_end sig_en=c3c9e81f93a983cc0eb13dc9c5635e71 -->
<!-- pgdoc-cn_start sig_en=e5ca7ddf4acfefd14d80148ae31cd28a sig_cn_org=None source=14.1 
 <titleabbrev>PageHeaderData Layout</titleabbrev>
________________________________________________________-->
 <titleabbrev>PageHeaderData布局</titleabbrev>
<!-- pgdoc-cn_end sig_en=e5ca7ddf4acfefd14d80148ae31cd28a -->
 <tgroup cols="4">
 <thead>
<!-- pgdoc-cn_start sig_en=df39587a42d9ff6313c4db5724e6cf00 sig_cn_org=None source=14.1 
  <row>
   <entry>Field</entry>
   <entry>Type</entry>
   <entry>Length</entry>
   <entry>Description</entry>
  </row>
________________________________________________________-->
  <row>
   <entry>域</entry>
   <entry>类型</entry>
   <entry>长度</entry>
   <entry>描述</entry>
  </row>
<!-- pgdoc-cn_end sig_en=df39587a42d9ff6313c4db5724e6cf00 -->
 </thead>
 <tbody>
<!-- pgdoc-cn_start sig_en=26d38ba319eb96f85c79c31e01bb94e4 sig_cn_org=None source=14.1 
  <row>
   <entry>pd_lsn</entry>
   <entry>PageXLogRecPtr</entry>
   <entry>8 bytes</entry>
   <entry>LSN: next byte after last byte of WAL record for last change
   to this page</entry>
  </row>
________________________________________________________-->
  <row>
   <entry>pd_lsn</entry>
   <entry>PageXLogRecPtr</entry>
   <entry>8 bytes</entry>
   <entry>LSN: 最后修改这个页面的WAL记录最后一个字节后面的第一个字节</entry>
  </row>
<!-- pgdoc-cn_end sig_en=26d38ba319eb96f85c79c31e01bb94e4 -->
<!-- pgdoc-cn_start sig_en=8529d883c2b61c405357c0fdd4336097 sig_cn_org=None source=14.1 
  <row>
   <entry>pd_checksum</entry>
   <entry>uint16</entry>
   <entry>2 bytes</entry>
   <entry>Page checksum</entry>
  </row>
________________________________________________________-->
  <row>
   <entry>pd_checksum</entry>
   <entry>uint16</entry>
   <entry>2 bytes</entry>
   <entry>页面校验码</entry>
  </row>
<!-- pgdoc-cn_end sig_en=8529d883c2b61c405357c0fdd4336097 -->
<!-- pgdoc-cn_start sig_en=308dad19201a310fc2a20d39e8a3a88f sig_cn_org=None source=14.1 
  <row>
   <entry>pd_flags</entry>
   <entry>uint16</entry>
   <entry>2 bytes</entry>
   <entry>Flag bits</entry>
  </row>
________________________________________________________-->
  <row>
   <entry>pd_flags</entry>
   <entry>uint16</entry>
   <entry>2 bytes</entry>
   <entry>标志位</entry>
  </row>
<!-- pgdoc-cn_end sig_en=308dad19201a310fc2a20d39e8a3a88f -->
<!-- pgdoc-cn_start sig_en=f80171c28f4fb15a22a72cd9d0dc783c sig_cn_org=None source=14.1 
  <row>
   <entry>pd_lower</entry>
   <entry>LocationIndex</entry>
   <entry>2 bytes</entry>
   <entry>Offset to start of free space</entry>
  </row>
________________________________________________________-->
  <row>
   <entry>pd_lower</entry>
   <entry>LocationIndex</entry>
   <entry>2 bytes</entry>
   <entry>到空闲空间开头的偏移量</entry>
  </row>
<!-- pgdoc-cn_end sig_en=f80171c28f4fb15a22a72cd9d0dc783c -->
<!-- pgdoc-cn_start sig_en=910e603dcdf82a5d44e7f61e74139316 sig_cn_org=None source=14.1 
  <row>
   <entry>pd_upper</entry>
   <entry>LocationIndex</entry>
   <entry>2 bytes</entry>
   <entry>Offset to end of free space</entry>
  </row>
________________________________________________________-->
  <row>
   <entry>pd_upper</entry>
   <entry>LocationIndex</entry>
   <entry>2 bytes</entry>
   <entry>到空闲空间结尾的偏移量</entry>
  </row>
<!-- pgdoc-cn_end sig_en=910e603dcdf82a5d44e7f61e74139316 -->
<!-- pgdoc-cn_start sig_en=f43712416d2ff28809bc7c2b92c192f4 sig_cn_org=None source=14.1 
  <row>
   <entry>pd_special</entry>
   <entry>LocationIndex</entry>
   <entry>2 bytes</entry>
   <entry>Offset to start of special space</entry>
  </row>
________________________________________________________-->
  <row>
   <entry>pd_special</entry>
   <entry>LocationIndex</entry>
   <entry>2 bytes</entry>
   <entry>到特殊空间开头的偏移量</entry>
  </row>
<!-- pgdoc-cn_end sig_en=f43712416d2ff28809bc7c2b92c192f4 -->
<!-- pgdoc-cn_start sig_en=86e5b6ecd32040d6b229e87ca470972c sig_cn_org=None source=14.1 
  <row>
   <entry>pd_pagesize_version</entry>
   <entry>uint16</entry>
   <entry>2 bytes</entry>
   <entry>Page size and layout version number information</entry>
  </row>
________________________________________________________-->
  <row>
   <entry>pd_pagesize_version</entry>
   <entry>uint16</entry>
   <entry>2 bytes</entry>
   <entry>页面大小和布局版本号信息</entry>
  </row>
<!-- pgdoc-cn_end sig_en=86e5b6ecd32040d6b229e87ca470972c -->
<!-- pgdoc-cn_start sig_en=fc8dfb3e8fd71101f0c489d9ef8413c1 sig_cn_org=None source=14.1 
  <row>
   <entry>pd_prune_xid</entry>
   <entry>TransactionId</entry>
   <entry>4 bytes</entry>
   <entry>Oldest unpruned XMAX on page, or zero if none</entry>
  </row>
________________________________________________________-->
  <row>
   <entry>pd_prune_xid</entry>
   <entry>TransactionId</entry>
   <entry>4 bytes</entry>
   <entry>页面上最老未删除XMAX，如果没有则为0</entry>
  </row>
<!-- pgdoc-cn_end sig_en=fc8dfb3e8fd71101f0c489d9ef8413c1 -->
 </tbody>
 </tgroup>
 </table>

<!-- pgdoc-cn_start sig_en=fab6880cc46fdab16954d536d34404f0 sig_cn_org=None source=14.1 
 <para>
  All the details can be found in
  <filename>src/include/storage/bufpage.h</filename>.
 </para>
________________________________________________________-->
 <para>
  所有细节都可以在<filename>src/include/storage/bufpage.h</filename>中找到。
 </para>
<!-- pgdoc-cn_end sig_en=fab6880cc46fdab16954d536d34404f0 -->

<!-- pgdoc-cn_start sig_en=51de1e2d54190477f0d3760b2000bafa sig_cn_org=None source=14.1 
 <para>
  Following the page header are item identifiers
  (<type>ItemIdData</type>), each requiring four bytes.
  An item identifier contains a byte-offset to
  the start of an item, its length in bytes, and a few attribute bits
  which affect its interpretation.
  New item identifiers are allocated
  as needed from the beginning of the unallocated space.
  The number of item identifiers present can be determined by looking at
  <structfield>pd_lower</structfield>, which is increased to allocate a new identifier.
  Because an item
  identifier is never moved until it is freed, its index can be used on a
  long-term basis to reference an item, even when the item itself is moved
  around on the page to compact free space.  In fact, every pointer to an
  item (<type>ItemPointer</type>, also known as
  <type>CTID</type>) created by
  <productname>PostgreSQL</productname> consists of a page number and the
  index of an item identifier.

 </para>
________________________________________________________-->
 <para>

  在页头后面是项标识符（<type>ItemIdData</type>），每个占用四个字节。 一个项标识符包含一个到项开头的字节偏移量（它的长度以字节计）， 以及一些属性位，这些属性位影响对它的解释。 新的项标识符根据需要从未分配空间的开头分配。项标识符的数目可以通过查看<structfield>pd_lower</structfield>来判断，在分配新标识符的时候<structfield>pd_lower</structfield>会增长。因为一个项标识符在被释放前绝对不会移动，所以它的索引可以用于长期地引用一个项， 即使该项本身因为压缩空闲空间在页面内部进行了移动。实际上，<productname>PostgreSQL</productname>创建的每个指向项的指针（<type>ItemPointer</type>，也叫做<type>CTID</type>）都由一个页号和一个项标识符的索引组成。

 </para>
<!-- pgdoc-cn_end sig_en=51de1e2d54190477f0d3760b2000bafa -->

<!-- pgdoc-cn_start sig_en=07d3442b7c815be1edf4e2e7977fb001 sig_cn_org=None source=14.1 
 <para>

  The items themselves are stored in space allocated backwards from the end
  of unallocated space.  The exact structure varies depending on what the
  table is to contain. Tables and sequences both use a structure named
  <type>HeapTupleHeaderData</type>, described below.

 </para>
________________________________________________________-->
 <para>

  项本身存储在从未分配空间末尾开始从后向前分配的空间里。它们的实际结构取决于表包含的内容。表和序列都使用一种叫做 <type>HeapTupleHeaderData</type>的结构，如下文所述。

 </para>
<!-- pgdoc-cn_end sig_en=07d3442b7c815be1edf4e2e7977fb001 -->

<!-- pgdoc-cn_start sig_en=ac498c0de9e8030d4aa5cf94bd40794a sig_cn_org=None source=14.1 
 <para>

  The final section is the <quote>special section</quote> which can
  contain anything the access method wishes to store.  For example,
  b-tree indexes store links to the page's left and right siblings,
  as well as some other data relevant to the index structure.
  Ordinary tables do not use a special section at all (indicated by setting
  <structfield>pd_special</structfield> to equal the page size).

 </para>
________________________________________________________-->
 <para>

  最后一部分是<quote>特殊部分</quote>，它可以包含访问方法想存放的任何东西。比如，b-tree 索引用它存储指向页面的左右兄妹的链接，以及其他一些和索引结构相关的数据。普通表并不使用这个部分（通过设置<structfield>pd_special</structfield>等于页面大小来表示）。

 </para>
<!-- pgdoc-cn_end sig_en=ac498c0de9e8030d4aa5cf94bd40794a -->

<!-- pgdoc-cn_start sig_en=7353c55c087f46d7ccdb0083d5e56fe7 sig_cn_org=None source=14.1 
 <para>
  <xref linkend="storage-page-layout-figure"/> illustrates how these parts are
  laid out in a page.
 </para>
________________________________________________________-->
 <para>
  <xref linkend="storage-page-layout-figure"/> 举例说明这些组件如何在一个页面中布局。
 </para>
<!-- pgdoc-cn_end sig_en=7353c55c087f46d7ccdb0083d5e56fe7 -->

 <figure id="storage-page-layout-figure">
<!-- pgdoc-cn_start sig_en=7e37cac8e193cae030a65cee6748cdaf sig_cn_org=None source=14.1 
  <title>Page Layout</title>
________________________________________________________-->
  <title>页面布局</title>
<!-- pgdoc-cn_end sig_en=7e37cac8e193cae030a65cee6748cdaf -->
  <mediaobject>
   <imageobject>
    <imagedata fileref="images/pagelayout.svg" format="SVG" width="100%"/>
   </imageobject>
  </mediaobject>
 </figure>

 <sect2 id="storage-tuple-layout">

<!-- pgdoc-cn_start sig_en=77b30a5a6967dae0b687ff4d3351e2fc sig_cn_org=None source=14.1 
 <title>Table Row Layout</title>
________________________________________________________-->
 <title>表行布局</title>
<!-- pgdoc-cn_end sig_en=77b30a5a6967dae0b687ff4d3351e2fc -->

<!-- pgdoc-cn_start sig_en=b9510379a8247c35fa0b31c42fb08191 sig_cn_org=None source=14.1 
 <para>

  All table rows are structured in the same way. There is a fixed-size
  header (occupying 23 bytes on most machines), followed by an optional null
  bitmap, an optional object ID field, and the user data. The header is
  detailed
  in <xref linkend="heaptupleheaderdata-table"/>.  The actual user data
  (columns of the row) begins at the offset indicated by
  <structfield>t_hoff</structfield>, which must always be a multiple of the MAXALIGN
  distance for the platform.
  The null bitmap is
  only present if the <firstterm>HEAP_HASNULL</firstterm> bit is set in
  <structfield>t_infomask</structfield>. If it is present it begins just after
  the fixed header and occupies enough bytes to have one bit per data column
  (that is, the number of bits that equals the attribute count in
  <structfield>t_infomask2</structfield>). In this list of bits, a
  1 bit indicates not-null, a 0 bit is a null.  When the bitmap is not
  present, all columns are assumed not-null.
  The object ID is only present if the <firstterm>HEAP_HASOID_OLD</firstterm> bit
  is set in <structfield>t_infomask</structfield>.  If present, it appears just
  before the <structfield>t_hoff</structfield> boundary.  Any padding needed to make
  <structfield>t_hoff</structfield> a MAXALIGN multiple will appear between the null
  bitmap and the object ID.  (This in turn ensures that the object ID is
  suitably aligned.)

 </para>
________________________________________________________-->
 <para>

  所有表行都用同样方法构造。它们有一个定长的头部（在大多数机器上占据 23 个字节）， 后面跟着一个可选的空值位图、一个可选的对象 ID 域以及用户数据。 该头部在<xref linkend="heaptupleheaderdata-table"/>里详细描述。实际的用户数据（行的列）从<structfield>t_hoff</structfield>指示的偏移位置开始， 它必须总是该平台的 MAXALIGN 距离的倍数。空值位图只有在<structfield>t_infomask</structfield>中的<firstterm>HEAP_HASNULL</firstterm>位被设置时存在。 
  如果存在，那么它紧跟在定长的头部后面，并占据足够的字节来容纳每个数据列对应的一个位（也就是说，位数等于<structfield>t_infomask2</structfield>中的属性计数。）。 在这个位的列表中，为 1 的位表示非空，而为 0 的位表示空。如果这个位图不存在，那么所有列都被假设为非空的。
  对象 ID 只有在设置了 <structfield>t_infomask</structfield>里面的<firstterm>HEAP_HASOID_OLD</firstterm>位时才存在。 
  如果存在，它正好出现在<structfield>t_hoff</structfield>边界之前。如果需要对齐<structfield>t_hoff</structfield>使之成为 MAXALIGN 的倍数，那么填充将出现在空值位图和对象 ID 之间（这样也保证了对象 ID 得到恰当的对齐）。

 </para>
<!-- pgdoc-cn_end sig_en=b9510379a8247c35fa0b31c42fb08191 -->

 <table tocentry="1" id="heaptupleheaderdata-table">
<!-- pgdoc-cn_start sig_en=232297c95fea74a3be183c772d3ea96e sig_cn_org=None source=14.1 
 <title>HeapTupleHeaderData Layout</title>
________________________________________________________-->
 <title>HeapTupleHeaderData布局</title>
<!-- pgdoc-cn_end sig_en=232297c95fea74a3be183c772d3ea96e -->
<!-- pgdoc-cn_start sig_en=566c4383a165c29b78f3e11ae5abb379 sig_cn_org=None source=14.1 
 <titleabbrev>HeapTupleHeaderData Layout</titleabbrev>
________________________________________________________-->
 <titleabbrev>HeapTupleHeaderData布局</titleabbrev>
<!-- pgdoc-cn_end sig_en=566c4383a165c29b78f3e11ae5abb379 -->
 <tgroup cols="4">
 <thead>
<!-- pgdoc-cn_start sig_en=df39587a42d9ff6313c4db5724e6cf00 sig_cn_org=None source=14.1 
  <row>
   <entry>Field</entry>
   <entry>Type</entry>
   <entry>Length</entry>
   <entry>Description</entry>
  </row>
________________________________________________________-->
  <row>
   <entry>域</entry>
   <entry>类型</entry>
   <entry>长度</entry>
   <entry>描述</entry>
  </row>
<!-- pgdoc-cn_end sig_en=df39587a42d9ff6313c4db5724e6cf00 -->
 </thead>
 <tbody>
<!-- pgdoc-cn_start sig_en=feb7de60b788170690701f8a3705f220 sig_cn_org=None source=14.1 
  <row>
   <entry>t_xmin</entry>
   <entry>TransactionId</entry>
   <entry>4 bytes</entry>
   <entry>insert XID stamp</entry>
  </row>
________________________________________________________-->
  <row>
   <entry>t_xmin</entry>
   <entry>TransactionId</entry>
   <entry>4 bytes</entry>
   <entry>插入XID标志</entry>
  </row>
<!-- pgdoc-cn_end sig_en=feb7de60b788170690701f8a3705f220 -->
<!-- pgdoc-cn_start sig_en=b619a17750bf327eacffe8a740afd5a7 sig_cn_org=None source=14.1 
  <row>
   <entry>t_xmax</entry>
   <entry>TransactionId</entry>
   <entry>4 bytes</entry>
   <entry>delete XID stamp</entry>
  </row>
________________________________________________________-->
  <row>
   <entry>t_xmax</entry>
   <entry>TransactionId</entry>
   <entry>4 bytes</entry>
   <entry>删除XID标志</entry>
  </row>
<!-- pgdoc-cn_end sig_en=b619a17750bf327eacffe8a740afd5a7 -->
<!-- pgdoc-cn_start sig_en=d3b02f8f5a37013d93ea18e16c69ba9c sig_cn_org=None source=14.1 
  <row>
   <entry>t_cid</entry>
   <entry>CommandId</entry>
   <entry>4 bytes</entry>
   <entry>insert and/or delete CID stamp (overlays with t_xvac)</entry>
  </row>
________________________________________________________-->
  <row>
   <entry>t_cid</entry>
   <entry>CommandId</entry>
   <entry>4 bytes</entry>
   <entry>插入和/或删除CID标志（覆盖t_xvac）</entry>
  </row>
<!-- pgdoc-cn_end sig_en=d3b02f8f5a37013d93ea18e16c69ba9c -->
<!-- pgdoc-cn_start sig_en=7cb66c4b0f75acabc81248947a8d1557 sig_cn_org=None source=14.1 
  <row>
   <entry>t_xvac</entry>
   <entry>TransactionId</entry>
   <entry>4 bytes</entry>
   <entry>XID for VACUUM operation moving a row version</entry>
  </row>
________________________________________________________-->
  <row>
   <entry>t_xvac</entry>
   <entry>TransactionId</entry>
   <entry>4 bytes</entry>
   <entry>VACUUM操作移动一个行版本的XID</entry>
  </row>
<!-- pgdoc-cn_end sig_en=7cb66c4b0f75acabc81248947a8d1557 -->
<!-- pgdoc-cn_start sig_en=dffb3d878b7d4edd465fdf85bf1ff686 sig_cn_org=None source=14.1 
  <row>
   <entry>t_ctid</entry>
   <entry>ItemPointerData</entry>
   <entry>6 bytes</entry>
   <entry>current TID of this or newer row version</entry>
  </row>
________________________________________________________-->
  <row>
   <entry>t_ctid</entry>
   <entry>ItemPointerData</entry>
   <entry>6 bytes</entry>
   <entry>当前版本的TID或者指向更新的行版本</entry>
  </row>
<!-- pgdoc-cn_end sig_en=dffb3d878b7d4edd465fdf85bf1ff686 -->
<!-- pgdoc-cn_start sig_en=e56f8283b1da7300fa0c96571945db62 sig_cn_org=None source=14.1 
  <row>
   <entry>t_infomask2</entry>
   <entry>uint16</entry>
   <entry>2 bytes</entry>
   <entry>number of attributes, plus various flag bits</entry>
  </row>
________________________________________________________-->
  <row>
   <entry>t_infomask2</entry>
   <entry>uint16</entry>
   <entry>2 bytes</entry>
   <entry>一些属性，加上多个标志位</entry>
  </row>
<!-- pgdoc-cn_end sig_en=e56f8283b1da7300fa0c96571945db62 -->
<!-- pgdoc-cn_start sig_en=6f727cb018a937913885c0398c9495b9 sig_cn_org=None source=14.1 
  <row>
   <entry>t_infomask</entry>
   <entry>uint16</entry>
   <entry>2 bytes</entry>
   <entry>various flag bits</entry>
  </row>
________________________________________________________-->
  <row>
   <entry>t_infomask</entry>
   <entry>uint16</entry>
   <entry>2 bytes</entry>
   <entry>多个标志位</entry>
  </row>
<!-- pgdoc-cn_end sig_en=6f727cb018a937913885c0398c9495b9 -->
<!-- pgdoc-cn_start sig_en=cc58ae0723f48bb06ca426b6ec5aa74a sig_cn_org=None source=14.1 
  <row>
   <entry>t_hoff</entry>
   <entry>uint8</entry>
   <entry>1 byte</entry>
   <entry>offset to user data</entry>
  </row>
________________________________________________________-->
  <row>
   <entry>t_hoff</entry>
   <entry>uint8</entry>
   <entry>1 byte</entry>
   <entry>到用户数据的偏移量</entry>
  </row>
<!-- pgdoc-cn_end sig_en=cc58ae0723f48bb06ca426b6ec5aa74a -->
 </tbody>
 </tgroup>
 </table>

<!-- pgdoc-cn_start sig_en=a9f2721a3a93a0f1b8c1737f62c94e6b sig_cn_org=None source=14.1 
 <para>
   All the details can be found in
   <filename>src/include/access/htup_details.h</filename>.
 </para>
________________________________________________________-->
 <para>
   所有细节都可以在<filename>src/include/access/htup_details.h</filename>中找到。
 </para>
<!-- pgdoc-cn_end sig_en=a9f2721a3a93a0f1b8c1737f62c94e6b -->

<!-- pgdoc-cn_start sig_en=e235cd6b8b20625071ed01c0e59460a0 sig_cn_org=None source=14.1 
 <para>

  Interpreting the actual data can only be done with information obtained
  from other tables, mostly <structname>pg_attribute</structname>. The
  key values needed to identify field locations are
  <structfield>attlen</structfield> and <structfield>attalign</structfield>.
  There is no way to directly get a
  particular attribute, except when there are only fixed width fields and no
  null values. All this trickery is wrapped up in the functions
  <firstterm>heap_getattr</firstterm>, <firstterm>fastgetattr</firstterm>
  and <firstterm>heap_getsysattr</firstterm>.

 </para>
________________________________________________________-->
 <para>

  只有从其他表里获取了信息之后才能对确切数据进行， 这些信息大多数在<structname>pg_attribute</structname>中。 标识域位置的关键值是<structfield>attlen</structfield>和<structfield>attalign</structfield>。 我们没有办法直接获取某个特定属性，除非它们是定宽并且没有空值。所有这些复杂的操作都封装在函数<firstterm>heap_getattr</firstterm>、<firstterm>fastgetattr</firstterm>和<firstterm>heap_getsysattr</firstterm>中。

 </para>
<!-- pgdoc-cn_end sig_en=e235cd6b8b20625071ed01c0e59460a0 -->
<!-- pgdoc-cn_start sig_en=2fb0ddf8db0a1370b7c335ab41bea120 sig_cn_org=None source=14.1 
 <para>

  To read the data you need to examine each attribute in turn. First check
  whether the field is NULL according to the null bitmap. If it is, go to
  the next. Then make sure you have the right alignment.  If the field is a
  fixed width field, then all the bytes are simply placed. If it's a
  variable length field (attlen = -1) then it's a bit more complicated.
  All variable-length data types share the common header structure
  <type>struct varlena</type>, which includes the total length of the stored
  value and some flag bits.  Depending on the flags, the data can be either
  inline or in a <acronym>TOAST</acronym> table;
  it might be compressed, too (see <xref linkend="storage-toast"/>).

 </para>
________________________________________________________-->
 <para>

  要读取数据的话，你需要轮流检查每个属性。首先根据空值位图检查该域是否为NULL。 如果是，那么跳到下一个。然后保证你的对齐是正确的。如果域是一个定宽域，那么所有字节都简单地放在其中。 如果它是一个变长域（attlen = -1），那么它就会有点复杂。所有变长数据类型都使用一个通用的头部结构<type>struct varlena</type>， 它包含所存储的值的总长度以及一些标志位。根据标志的不同，数据可能在线内或者是在一个<acronym>TOAST</acronym>中，还可能是压缩的（参阅<xref linkend="storage-toast"/>）。

 </para>
<!-- pgdoc-cn_end sig_en=2fb0ddf8db0a1370b7c335ab41bea120 -->
 </sect2>
</sect1>

<sect1 id="storage-hot">

<!-- pgdoc-cn_start sig_en=bcf099f521db9ec13e4a0eb59b3e2cb2 sig_cn_org=018983144843baee112f7479f88f4fa4 source=15.7 
 <title>Heap-Only Tuples (<acronym>HOT</acronym>)</title>
________________________________________________________-->
 <title>仅存储在堆中的元组（<acronym>HOT</acronym>）</title>
<!-- pgdoc-cn_end sig_en=bcf099f521db9ec13e4a0eb59b3e2cb2 -->

<!-- pgdoc-cn_start sig_en=d7b8a4798d2b422cb3fc894da334d7db sig_cn_org=6d3fa64b8107f9dc5196b240c0f4f9e0 source=15.7 
 <para>
  To allow for high concurrency, <productname>PostgreSQL</productname>
  uses <link linkend="mvcc-intro">multiversion concurrency
  control</link> (<acronym>MVCC</acronym>) to store rows.  However,
  <acronym>MVCC</acronym> has some downsides for update queries.
  Specifically, updates require new versions of rows to be added to
  tables.  This can also require new index entries for each updated row,
  and removal of old versions of rows and their index entries can be
  expensive.
 </para>
________________________________________________________-->
 <para>
  为了实现高并发，<productname>PostgreSQL</productname>使用<link linkend="mvcc-intro">多版本并发控制</link>（<acronym>MVCC</acronym>）来存储行。然而，<acronym>MVCC</acronym>对于更新查询有一些不足之处。具体来说，更新需要向表中添加新版本的行。这也可能需要为每个更新的行添加新的索引条目，并且删除旧版本的行及其索引条目可能会很昂贵。
</para>
<!-- pgdoc-cn_end sig_en=d7b8a4798d2b422cb3fc894da334d7db -->

<!-- pgdoc-cn_start sig_en=4ddfae08d3c42b95e816ac05115e66ca sig_cn_org=e932be842f8df0daa6b6586ad1ceec18 source=15.7 
 <para>
  To help reduce the overhead of updates,
  <productname>PostgreSQL</productname> has an optimization called
  heap-only tuples (<acronym>HOT</acronym>).  This optimization is
  possible when:

  <itemizedlist>
   <listitem>
    <para>
     The update does not modify any columns referenced by the table's
     indexes, including expression and partial indexes.
     </para>
   </listitem>
   <listitem>
    <para>
     There is sufficient free space on the page containing the old row
     for the updated row.
    </para>
   </listitem>
  </itemizedlist>

  In such cases, heap-only tuples provide two optimizations:

  <itemizedlist>
   <listitem>
    <para>
     New index entries are not needed to represent updated rows.
    </para>
   </listitem>
   <listitem>
    <para>
     Old versions of updated rows can be completely removed during normal
     operation, including <command>SELECT</command>s, instead of requiring
     periodic vacuum operations.  (This is possible because indexes
     do not reference their <link linkend="storage-page-layout">page
     item identifiers</link>.)
    </para>
   </listitem>
  </itemizedlist>
 </para>
________________________________________________________-->
 <para>
  为了帮助减少更新的开销，<productname>PostgreSQL</productname>引入了一种优化称为 heap-only tuples（<acronym>HOT</acronym>）。
  当以下条件满足时，这种优化才可能发生：

  <itemizedlist>
   <listitem>
    <para>
     更新不修改表的索引引用的任何列，包括表达式和部分索引。
    </para>
   </listitem>
   <listitem>
    <para>
     包含旧行的页面有足够的空闲空间来存放更新后的行。
    </para>
   </listitem>
  </itemizedlist>

  在这种情况下， heap-only tuples 提供了两种优化：

  <itemizedlist>
   <listitem>
    <para>
     不需要新的索引条目来表示更新的行。
    </para>
   </listitem>
   <listitem>
    <para>
     更新行的旧版本可以在正常操作期间完全删除，包括<command>SELECT</command>操作，而不需要定期进行清理操作。
     （这是因为索引不引用它们的<link linkend="storage-page-layout">页面项标识符</link>。）
    </para>
   </listitem>
  </itemizedlist>
 </para>
<!-- pgdoc-cn_end sig_en=4ddfae08d3c42b95e816ac05115e66ca -->

<!-- pgdoc-cn_start sig_en=e3a01d3f340980a08a931daa50ffcecd sig_cn_org=7ff843a341ddd1127d0836a2dee25f0d source=15.7 
 <para>
  In summary, heap-only tuple updates can only be created
  if columns used by indexes are not updated.  You can
  increase the likelihood of sufficient page space for
  <acronym>HOT</acronym> updates by decreasing a table's <link
  linkend="reloption-fillfactor"><literal>fillfactor</literal></link>.
  If you don't, <acronym>HOT</acronym> updates will still happen because
  new rows will naturally migrate to new pages and existing pages with
  sufficient free space for new row versions.  The system view <link
  linkend="monitoring-pg-stat-all-tables-view">pg_stat_all_tables</link>
  allows monitoring of the occurrence of HOT and non-HOT updates.
 </para>
________________________________________________________-->
 <para>
  总之，只有在不更新索引使用的列时，才能创建 heap-only tuples 的元组。您可以通过减少表的
  <acronym>HOT</acronym>更新的填充因子<link linkend="reloption-fillfactor">
  <literal>fillfactor</literal></link>来增加足够页面空间的可能性。如果不这样做，
  <acronym>HOT</acronym>更新仍会发生，因为新行会自然迁移到新页面和具有足够空闲空间
  用于新行版本的现有页面。系统视图<link linkend="monitoring-pg-stat-all-tables-view">
  pg_stat_all_tables</link>允许监视HOT和非HOT更新的发生。
</para>
<!-- pgdoc-cn_end sig_en=e3a01d3f340980a08a931daa50ffcecd -->
</sect1>

</chapter>
