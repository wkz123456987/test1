<!-- doc/src/sgml/lobj.sgml -->

 <chapter id="largeobjects">
<!-- pgdoc-cn_start sig_en=3c3d036ff793bd528a168222f712355b sig_cn_org=None source=14.1 
  <title>Large Objects</title>
________________________________________________________-->
  <title>大对象</title>
<!-- pgdoc-cn_end sig_en=3c3d036ff793bd528a168222f712355b -->

<!-- pgdoc-cn_start sig_en=353ff2ba77290c5de6dba67189dba9dc sig_cn_org=None source=14.1 
  <indexterm zone="largeobjects"><primary>large object</primary></indexterm>
________________________________________________________-->
  <indexterm zone="largeobjects"><primary>large object</primary></indexterm>
<!-- pgdoc-cn_end sig_en=353ff2ba77290c5de6dba67189dba9dc -->
<!-- pgdoc-cn_start sig_en=f9a44f675f18859d84ef5b50289c6489 sig_cn_org=None source=14.1 
  <indexterm><primary>BLOB</primary><see>large object</see></indexterm>
________________________________________________________-->
  <indexterm><primary>BLOB</primary><see>large object</see></indexterm>
<!-- pgdoc-cn_end sig_en=f9a44f675f18859d84ef5b50289c6489 -->

<!-- pgdoc-cn_start sig_en=8f4304e136a8bbc057d28f123cee02dd sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> has a <firstterm>large object</firstterm>
    facility, which provides stream-style access to user data that is stored
    in a special large-object structure.  Streaming access is useful
    when working with data values that are too large to manipulate
    conveniently as a whole.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>具有<firstterm>大对象</firstterm>的功能，它提供了对于存储在一个特殊大对象结构中的用户数据的流式访问。对于那些大得无法以一个整体处理的数据值 ，流式访问非常有用。
   </para>
<!-- pgdoc-cn_end sig_en=8f4304e136a8bbc057d28f123cee02dd -->

<!-- pgdoc-cn_start sig_en=d7efc7c4c895b0c15ba2787a35295b9c sig_cn_org=None source=14.1 
   <para>
    This chapter describes the implementation and the programming and
    query language interfaces to <productname>PostgreSQL</productname>
    large object data.  We use the <application>libpq</application> C
    library for the examples in this chapter, but most programming
    interfaces native to <productname>PostgreSQL</productname> support
    equivalent functionality.  Other interfaces might use the large
    object interface internally to provide generic support for large
    values.  This is not described here.
   </para>
________________________________________________________-->
   <para>
    本章介绍了<productname>PostgreSQL</productname>中大对象数据的实现、编程和查询语言接口。在本章中我们使用名为<application>libpq</application>的C库来作为例子，但是绝大部分<productname>PostgreSQL</productname>支持的本地编程接口也具有相同的功能。其他接口可能会在内部使用大对象接口来提供对大值的一般支持，但这里就不再描述。
   </para>
<!-- pgdoc-cn_end sig_en=d7efc7c4c895b0c15ba2787a35295b9c -->

  <sect1 id="lo-intro">
<!-- pgdoc-cn_start sig_en=c2fcf93c611ba5f3baff759a5cc428dd sig_cn_org=None source=14.1 
   <title>Introduction</title>
________________________________________________________-->
   <title>简介</title>
<!-- pgdoc-cn_end sig_en=c2fcf93c611ba5f3baff759a5cc428dd -->

<!-- pgdoc-cn_start sig_en=5115f71b60bc9edc83306b6a1fef80b4 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>TOAST</primary>
    <secondary>versus large objects</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>TOAST</primary>
    <secondary>versus large objects</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=5115f71b60bc9edc83306b6a1fef80b4 -->

<!-- pgdoc-cn_start sig_en=105a3277cac39fe2e41c3ea605a8d4eb sig_cn_org=None source=14.1 
   <para>
    All large objects are stored in a single system table named <link
    linkend="catalog-pg-largeobject"><structname>pg_largeobject</structname></link>.
    Each large object also has an entry in the system table <link
    linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</structname></link>.
    Large objects can be created, modified, and deleted using a read/write API
    that is similar to standard operations on files.
   </para>
________________________________________________________-->
   <para>
    所有的大对象都存在一个名为<link linkend="catalog-pg-largeobject"><structname>pg_largeobject</structname></link>的系统表中。每一个大对象还在系统表<link linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</structname></link>中有一个对应的项。大对象可以通过类似于标准文件操作的读/写API来进行创建、修改和删除。
   </para>
<!-- pgdoc-cn_end sig_en=105a3277cac39fe2e41c3ea605a8d4eb -->

<!-- pgdoc-cn_start sig_en=a3010dbb6d1ebfee667c8f1e54641f4f sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> also supports a storage system called
    <link
    linkend="storage-toast"><quote><acronym>TOAST</acronym></quote></link>,
    which automatically stores values
    larger than a single database page into a secondary storage area per table.
    This makes the large object facility partially obsolete.  One
    remaining advantage of the large object facility is that it allows values
    up to 4 TB in size, whereas <acronym>TOAST</acronym>ed fields can be at
    most 1 GB.  Also, reading and updating portions of a large object can be
    done efficiently, while most operations on a <acronym>TOAST</acronym>ed
    field will read or write the whole value as a unit.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>也支持一种称为<link linkend="storage-toast"><quote><acronym>TOAST</acronym></quote></link>的存储系统， 它自动把大于一个数据库页的值存储到一个二级存储区域，每一个表都有专属的二级存储区域。这使得大对象功能显得有些陈旧。但是大对象功能仍然有一个优势是能够支持高达4TB的值，而<acronym>TOAST</acronym>域只能支持最大1GB。此外，读写一个大对象的片段会很高效，但是大部分在<acronym>TOAST</acronym>域上的操作都将把整个值作为一个单元进行读或写。
   </para>
<!-- pgdoc-cn_end sig_en=a3010dbb6d1ebfee667c8f1e54641f4f -->

  </sect1>

  <sect1 id="lo-implementation">
<!-- pgdoc-cn_start sig_en=d3e15cacdc3a27cb894f82525646d053 sig_cn_org=None source=14.1 
   <title>Implementation Features</title>
________________________________________________________-->
   <title>实现特性</title>
<!-- pgdoc-cn_end sig_en=d3e15cacdc3a27cb894f82525646d053 -->

<!-- pgdoc-cn_start sig_en=f4b78ac98622158a5735a81c56dde5ab sig_cn_org=None source=14.1 
   <para>
    The large object implementation breaks large
    objects up into <quote>chunks</quote> and stores the chunks in
    rows in the database.  A B-tree index guarantees fast
    searches for the correct chunk number when doing random
    access reads and writes.
   </para>
________________________________________________________-->
   <para>
    大对象的实现将大对象分解成很多<quote>数据块</quote>并且将这些数据块存储在数据库的行中。一个B-tree索引用来保证在进行随机访问读写时能够根据数据块号快速地搜索到正确的数据块。
   </para>
<!-- pgdoc-cn_end sig_en=f4b78ac98622158a5735a81c56dde5ab -->

<!-- pgdoc-cn_start sig_en=205d54f54a055a4c0e762279dcb5680c sig_cn_org=None source=14.1 
   <para>
    The chunks stored for a large object do not have to be contiguous.
    For example, if an application opens a new large object, seeks to offset
    1000000, and writes a few bytes there, this does not result in allocation
    of 1000000 bytes worth of storage; only of chunks covering the range of
    data bytes actually written.  A read operation will, however, read out
    zeroes for any unallocated locations preceding the last existing chunk.
    This corresponds to the common behavior of <quote>sparsely allocated</quote>
    files in <acronym>Unix</acronym> file systems.
   </para>
________________________________________________________-->
   <para>
    为一个大对象存储的数据块并不需要是连续的。例如，如果一个应用打开了一个新的大对象，移动到偏移量1000000并写了一些字节，这并不会导致分配1000000字节的存储，只有覆盖写入字节范围的数据块需要被分配。而一个读操作将会把现有最后的数据块之前还未分配的位置读出为0。这和<acronym>Unix</acronym>文件系统中<quote>稀疏</quote>文件的一般行为相对应。
   </para>
<!-- pgdoc-cn_end sig_en=205d54f54a055a4c0e762279dcb5680c -->

<!-- pgdoc-cn_start sig_en=832599447ec0f61bd09802e374ccf9da sig_cn_org=None source=14.1 
   <para>
    As of <productname>PostgreSQL</productname> 9.0, large objects have an owner
    and a set of access permissions, which can be managed using
    <xref linkend="sql-grant"/> and
    <xref linkend="sql-revoke"/>.
    <literal>SELECT</literal> privileges are required to read a large
    object, and
    <literal>UPDATE</literal> privileges are required to write or
    truncate it.
    Only the large object's owner (or a database superuser) can delete,
    comment on, or change the owner of a large object.
    To adjust this behavior for compatibility with prior releases, see the
    <xref linkend="guc-lo-compat-privileges"/> run-time parameter.
   </para>
________________________________________________________-->
   <para>
    自<productname>PostgreSQL</productname> 9.0起，大对象可以有一个拥有者和一组访问权限，它们可以用<xref linkend="sql-grant"/>和<xref linkend="sql-revoke"/>管理。读一个大对象需要<literal>SELECT</literal>权限，而写或者截断一个大对象则需要<literal>UPDATE</literal>权限。只有大对象的拥有者（或者一个数据库超级用户）可以创建大对象、注释大对象或修改大对象的拥有者。要调整这些行为以兼容以前的发行，请见<xref linkend="guc-lo-compat-privileges"/>的运行时参数。
   </para>
<!-- pgdoc-cn_end sig_en=832599447ec0f61bd09802e374ccf9da -->
  </sect1>

  <sect1 id="lo-interfaces">
<!-- pgdoc-cn_start sig_en=3d92464749d1878f65ae1742df32ca00 sig_cn_org=None source=14.1 
   <title>Client Interfaces</title>
________________________________________________________-->
   <title>客户端接口</title>
<!-- pgdoc-cn_end sig_en=3d92464749d1878f65ae1742df32ca00 -->

<!-- pgdoc-cn_start sig_en=19dad51cc6e1b69a41a93af5feecff28 sig_cn_org=None source=14.1 
   <para>
    This section describes the facilities that
    <productname>PostgreSQL</productname>'s <application>libpq</application>
    client interface library provides for accessing large objects.
    The <productname>PostgreSQL</productname> large object interface is
    modeled after the <acronym>Unix</acronym> file-system interface, with
    analogues of <function>open</function>,  <function>read</function>,
    <function>write</function>,
    <function>lseek</function>, etc.
   </para>
________________________________________________________-->
   <para>
    本节描述<productname>PostgreSQL</productname>的<application>libpq</application>客户端接口为访问大对象所提供的功能。<productname>PostgreSQL</productname>的大对象接口按照<acronym>Unix</acronym>文件系统的接口建模，也有相似的<function>open</function>、<function>read</function>、<function>write</function>、<function>lseek</function>等。
   </para>
<!-- pgdoc-cn_end sig_en=19dad51cc6e1b69a41a93af5feecff28 -->

<!-- pgdoc-cn_start sig_en=a364e5b5f19bcd275cc9e98b8ad5870c sig_cn_org=None source=14.1 
   <para>
    All large object manipulation using these functions
    <emphasis>must</emphasis> take place within an SQL transaction block,
    since large object file descriptors are only valid for the duration of
    a transaction.
   </para>
________________________________________________________-->
   <para>
    所有使用这些函数对大对象的操作都<emphasis>必须</emphasis>发生在一个SQL事务块中，因为大对象文件描述符只在事务期间有效。
   </para>
<!-- pgdoc-cn_end sig_en=a364e5b5f19bcd275cc9e98b8ad5870c -->

<!-- pgdoc-cn_start sig_en=6a75d7f4af49b60d6348cdb3a7ea37e0 sig_cn_org=None source=14.1 
   <para>
    If an error occurs while executing any one of these functions, the
    function will return an otherwise-impossible value, typically 0 or -1.
    A message describing the error is stored in the connection object and
    can be retrieved with <xref linkend="libpq-PQerrorMessage"/>.
   </para>
________________________________________________________-->
   <para>
    在执行任何一个这种函数期间如果发生一个错误，该函数将会返回一个其他的不可能值，典型的是0或-1。
    一个关于该错误的消息亦会被保存在连接对象中，可以通过<xref linkend="libpq-PQerrorMessage"/>检索到。
   </para>
<!-- pgdoc-cn_end sig_en=6a75d7f4af49b60d6348cdb3a7ea37e0 -->

<!-- pgdoc-cn_start sig_en=5b859c6ded87504580fb3bb67b26eeb2 sig_cn_org=None source=14.1 
   <para>
    Client applications that use these functions should include the header file
    <filename>libpq/libpq-fs.h</filename> and link with the
    <application>libpq</application> library.
   </para>
________________________________________________________-->
   <para>
    使用这些函数的客户端应用应该包括头文件<filename>libpq/libpq-fs.h</filename>并链接<application>libpq</application>库。
   </para>
<!-- pgdoc-cn_end sig_en=5b859c6ded87504580fb3bb67b26eeb2 -->

<!-- pgdoc-cn_start sig_en=ae8fe4415570037410a0123909bd06c5 sig_cn_org=None source=14.1 
   <para>
    Client applications cannot use these functions while a libpq connection is in pipeline mode.
   </para>
________________________________________________________-->
   <para>
    当libpq连接处于管道模式时，客户端应用程序不能使用这些函数。
   </para>
<!-- pgdoc-cn_end sig_en=ae8fe4415570037410a0123909bd06c5 -->

   <sect2 id="lo-create">
<!-- pgdoc-cn_start sig_en=830a34bfd199a524eaf3b98ed2e1ceb0 sig_cn_org=None source=14.1 
    <title>Creating a Large Object</title>
________________________________________________________-->
    <title>创建一个大对象</title>
<!-- pgdoc-cn_end sig_en=830a34bfd199a524eaf3b98ed2e1ceb0 -->

<!-- pgdoc-cn_start sig_en=6a5960dc47c2cdab1b49b0b27aef7d75 sig_cn_org=a4decffe1ec7e20e6331e1fe6856eaf1 source=15.7 
    <para>
     <indexterm><primary>lo_create</primary></indexterm>
     The function
<synopsis>
Oid lo_create(PGconn *conn, Oid lobjId);
</synopsis>
     creates a new large object.  The OID to be assigned can be
     specified by <replaceable class="parameter">lobjId</replaceable>;
     if so, failure occurs if that OID is already in use for some large
     object.  If <replaceable class="parameter">lobjId</replaceable>
     is <symbol>InvalidOid</symbol> (zero) then <function>lo_create</function>
     assigns an unused OID.
     The return value is the OID that was assigned to the new large object,
     or <symbol>InvalidOid</symbol> (zero) on failure.
    </para>
________________________________________________________-->
    <para>
     <indexterm><primary>lo_create</primary></indexterm>
     函数
<synopsis>
Oid lo_create(PGconn *conn, Oid lobjId);
</synopsis>
     创建一个新的大型对象。要分配的OID可以由<replaceable class="parameter">lobjId</replaceable>指定；
     如果是这样，如果该OID已经用于某个大型对象，则会失败。如果<replaceable class="parameter">lobjId</replaceable>
     是<symbol>InvalidOid</symbol>（零），那么<function>lo_create</function>会分配一个未使用的OID。
     返回值是分配给新大型对象的OID，或者在失败时为<symbol>InvalidOid</symbol>（零）。
    </para>
<!-- pgdoc-cn_end sig_en=6a5960dc47c2cdab1b49b0b27aef7d75 -->

<!-- pgdoc-cn_start sig_en=e4bd7223a17e1e3e78f9ffce32f9abd4 sig_cn_org=None source=14.1 
    <para>
     An example:
<programlisting>
inv_oid = lo_create(conn, desired_oid);
</programlisting>
    </para>
________________________________________________________-->
    <para>
     一个例子：
<programlisting>
inv_oid = lo_create(conn, desired_oid);
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=e4bd7223a17e1e3e78f9ffce32f9abd4 -->

<!-- pgdoc-cn_start sig_en=c9615693b70739c736a26e120778f1c1 sig_cn_org=115b094df110d9a113c79099b57e2548 source=15.7 
    <para>
     <indexterm><primary>lo_creat</primary></indexterm>
     The older function
<synopsis>
Oid lo_creat(PGconn *conn, int mode);
</synopsis>
     also creates a new large object, always assigning an unused OID.
     The return value is the OID that was assigned to the new large object,
     or <symbol>InvalidOid</symbol> (zero) on failure.
    </para>
________________________________________________________-->
    <para>
     <indexterm><primary>lo_creat</primary></indexterm>
     旧函数
<synopsis>
Oid lo_creat(PGconn *conn, int mode);
</synopsis>
     也创建一个新的大型对象，总是分配一个未使用的OID。
     返回值是分配给新大型对象的OID，或在失败时为<symbol>InvalidOid</symbol>（零）。
    </para>
<!-- pgdoc-cn_end sig_en=c9615693b70739c736a26e120778f1c1 -->

<!-- pgdoc-cn_start sig_en=95fc1fa516d5a217e2ded238ec0cc427 sig_cn_org=c75ac3fb850b3e1a7c365d0b81d4a2cc source=15.7 
    <para>
     In <productname>PostgreSQL</productname> releases 8.1 and later,
     the <replaceable class="parameter">mode</replaceable> is ignored,
     so that <function>lo_creat</function> is exactly equivalent to
     <function>lo_create</function> with a zero second argument.
     However, there is little reason to use <function>lo_creat</function>
     unless you need to work with servers older than 8.1.
     To work with such an old server, you must
     use <function>lo_creat</function> not <function>lo_create</function>,
     and you must set <replaceable class="parameter">mode</replaceable> to
     one of <symbol>INV_READ</symbol>, <symbol>INV_WRITE</symbol>,
     or <symbol>INV_READ</symbol> <literal>|</literal> <symbol>INV_WRITE</symbol>.
     (These symbolic constants are defined
     in the header file <filename>libpq/libpq-fs.h</filename>.)
    </para>
________________________________________________________-->
    <para>
     在<productname>PostgreSQL</productname>的8.1版本及以后的发布中，
     <replaceable class="parameter">mode</replaceable>参数被忽略，
     因此<function>lo_creat</function>与带有零秒参数的<function>lo_create</function>完全等效。
     然而，除非您需要与早于8.1版本的服务器一起工作，否则几乎没有理由使用<function>lo_creat</function>。
     要与这样一个旧服务器一起工作，您必须使用<function>lo_creat</function>而不是<function>lo_create</function>，
     并且必须将<replaceable class="parameter">mode</replaceable>设置为<symbol>INV_READ</symbol>、<symbol>INV_WRITE</symbol>，
     或<symbol>INV_READ</symbol><literal>|</literal><symbol>INV_WRITE</symbol>中的一个。
     (这些符号常量在头文件<filename>libpq/libpq-fs.h</filename>中定义。)
    </para>
<!-- pgdoc-cn_end sig_en=95fc1fa516d5a217e2ded238ec0cc427 -->

<!-- pgdoc-cn_start sig_en=18550e3ef1ed0a653287148f642b1bc1 sig_cn_org=None source=14.1 
    <para>
     An example:
<programlisting>
inv_oid = lo_creat(conn, INV_READ|INV_WRITE);
</programlisting>
    </para>
________________________________________________________-->
    <para>
     一个例子：
<programlisting>
inv_oid = lo_creat(conn, INV_READ|INV_WRITE);
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=18550e3ef1ed0a653287148f642b1bc1 -->
   </sect2>

   <sect2 id="lo-import">
<!-- pgdoc-cn_start sig_en=ba01a4ba33a28543cbb8f251289b2e1e sig_cn_org=None source=14.1 
    <title>Importing a Large Object</title>
________________________________________________________-->
    <title>导入一个大对象</title>
<!-- pgdoc-cn_end sig_en=ba01a4ba33a28543cbb8f251289b2e1e -->

<!-- pgdoc-cn_start sig_en=a61f10f8b54d252cc096050f1c743163 sig_cn_org=None source=14.1 
    <para>
     <indexterm><primary>lo_import</primary></indexterm>
     To import an operating system file as a large object, call
<synopsis>
Oid lo_import(PGconn *conn, const char *filename);
</synopsis>
     <replaceable class="parameter">filename</replaceable>
     specifies the operating system name of
     the file to be imported as a large object.
     The return value is the OID that was assigned to the new large object,
     or <symbol>InvalidOid</symbol> (zero) on failure.
     Note that the file is read by the client interface library, not by
     the server; so it must exist in the client file system and be readable
     by the client application.
    </para>
________________________________________________________-->
    <para>
     <indexterm><primary>lo_import</primary></indexterm>
     要将一个操作系统文件导入成一个大对象，调用：
<synopsis>
Oid lo_import(PGconn *conn, const char *filename);
</synopsis>
     <replaceable class="parameter">filename</replaceable>指定了要导入为大对象的操作系统文件名。返回值是分配给新大对象的OID或<symbol>InvalidOid</symbol>（0）表示发生错误。注意该文件是被客户端接口库而不是服务器所读取，因此它必须存在于客户端文件系统中并且对于客户端应用是可读的。
    </para>
<!-- pgdoc-cn_end sig_en=a61f10f8b54d252cc096050f1c743163 -->

<!-- pgdoc-cn_start sig_en=9ca535ee9f78f09f1d622a106feb647d sig_cn_org=None source=14.1 
    <para>
     <indexterm><primary>lo_import_with_oid</primary></indexterm>
     The function
<synopsis>
Oid lo_import_with_oid(PGconn *conn, const char *filename, Oid lobjId);
</synopsis>
     also imports a new large object.  The OID to be assigned can be
     specified by <replaceable class="parameter">lobjId</replaceable>;
     if so, failure occurs if that OID is already in use for some large
     object.  If <replaceable class="parameter">lobjId</replaceable>
     is <symbol>InvalidOid</symbol> (zero) then <function>lo_import_with_oid</function> assigns an unused
     OID (this is the same behavior as <function>lo_import</function>).
     The return value is the OID that was assigned to the new large object,
     or <symbol>InvalidOid</symbol> (zero) on failure.
    </para>
________________________________________________________-->
    <para>
     <indexterm><primary>lo_import_with_oid</primary></indexterm>
     函数
<synopsis>
Oid lo_import_with_oid(PGconn *conn, const char *filename, Oid lobjId);
</synopsis>
     也可以导入一个新大对象。分配给新大对象的OID可以用<replaceable class="parameter">lobjId</replaceable>指定，如果这样做，该OID已经被某个大对象使用时会产生错误。如果<replaceable class="parameter">lobjId</replaceable>是<symbol>InvalidOid</symbol>（0），则<function>lo_import_with_oid</function>会分配一个未使用的OID（这和<function>lo_import</function>的行为相同）。返回值是分配给新大对象的OID或<symbol>InvalidOid</symbol>（0）表示发生错误。
    </para>
<!-- pgdoc-cn_end sig_en=9ca535ee9f78f09f1d622a106feb647d -->

<!-- pgdoc-cn_start sig_en=4ce729e5314f7d82f45339c88a12ec6e sig_cn_org=None source=14.1 
    <para>
     <function>lo_import_with_oid</function> is new as of <productname>PostgreSQL</productname>
     8.4 and uses <function>lo_create</function> internally which is new in 8.1; if this function is run against 8.0 or before, it will
     fail and return <symbol>InvalidOid</symbol>.
    </para>
________________________________________________________-->
    <para>
     <function>lo_import_with_oid</function>在从<productname>PostgreSQL</productname> 8.1开始的版本中是新的并且在内部使用了<function>lo_create</function>（在8.1中也是新的），如果该函数在旧服务器版本上运行，它将失败并返回<symbol>InvalidOid</symbol>。
    </para>
<!-- pgdoc-cn_end sig_en=4ce729e5314f7d82f45339c88a12ec6e -->
   </sect2>

   <sect2 id="lo-export">
<!-- pgdoc-cn_start sig_en=f77c1bd33395aec6ceb3242d31e5dc89 sig_cn_org=None source=14.1 
    <title>Exporting a Large Object</title>
________________________________________________________-->
    <title>导出一个大对象</title>
<!-- pgdoc-cn_end sig_en=f77c1bd33395aec6ceb3242d31e5dc89 -->

<!-- pgdoc-cn_start sig_en=6e21915a427d406de12495af3537fb42 sig_cn_org=None source=14.1 
    <para>
     <indexterm><primary>lo_export</primary></indexterm>
     To export a large object
     into an operating system file, call
<synopsis>
int lo_export(PGconn *conn, Oid lobjId, const char *filename);
</synopsis>
     The <parameter>lobjId</parameter> argument specifies the OID of the large
     object to export and the <parameter>filename</parameter> argument
     specifies the operating system name of the file.  Note that the file is
     written by the client interface library, not by the server.  Returns 1
     on success, -1 on failure.
    </para>
________________________________________________________-->
    <para>
     <indexterm><primary>lo_export</primary></indexterm>
     要把一个大对象导出到一个操作系统文件，调用：
<synopsis>
int lo_export(PGconn *conn, Oid lobjId, const char *filename);
</synopsis>
     <parameter>lobjId</parameter>参数指定要导出的大对象的OID，<parameter>filename</parameter>参数指定操作系统文件名。注意该文件是被客户端接口库而不是服务器写入。成功返回1，错误返回-1。
    </para>
<!-- pgdoc-cn_end sig_en=6e21915a427d406de12495af3537fb42 -->
   </sect2>

   <sect2 id="lo-open">
<!-- pgdoc-cn_start sig_en=07904e62dfc992b480978169ccd000a2 sig_cn_org=None source=14.1 
    <title>Opening an Existing Large Object</title>
________________________________________________________-->
    <title>打开一个现有的大对象</title>
<!-- pgdoc-cn_end sig_en=07904e62dfc992b480978169ccd000a2 -->

<!-- pgdoc-cn_start sig_en=845507e78c70ac6ef2fb8e4e420db75a sig_cn_org=None source=14.1 
    <para>
     <indexterm><primary>lo_open</primary></indexterm>
     To open an existing large object for reading or writing, call
<synopsis>
int lo_open(PGconn *conn, Oid lobjId, int mode);
</synopsis>
     The <parameter>lobjId</parameter> argument specifies the OID of the large
     object to open.   The <parameter>mode</parameter> bits control whether the
     object is opened for reading (<symbol>INV_READ</symbol>), writing
     (<symbol>INV_WRITE</symbol>), or both.
     (These symbolic constants are defined
     in the header file <filename>libpq/libpq-fs.h</filename>.)
     <function>lo_open</function> returns a (non-negative) large object
     descriptor for later use in <function>lo_read</function>,
     <function>lo_write</function>, <function>lo_lseek</function>,
     <function>lo_lseek64</function>, <function>lo_tell</function>,
     <function>lo_tell64</function>, <function>lo_truncate</function>,
     <function>lo_truncate64</function>, and <function>lo_close</function>.
     The descriptor is only valid for
     the duration of the current transaction.
     On failure, -1 is returned.
    </para>
________________________________________________________-->
    <para>
     <indexterm><primary>lo_open</primary></indexterm>
     要打开一个现有的大对象进行读写，调用：
<synopsis>
int lo_open(PGconn *conn, Oid lobjId, int mode);
</synopsis>
     <parameter>lobjId</parameter>参数指定要打开的大对象的OID。<parameter>mode</parameter>位控制着打开对象是为了只读（<symbol>INV_READ</symbol>）、只写（<symbol>INV_WRITE</symbol>）或者读写（这些符号常量定义在头文件<filename>libpq/libpq-fs.h</filename>中）。<function>lo_open</function>返回一个（非负）大对象描述符以便后面用于<function>lo_read</function>、<function>lo_write</function>、<function>lo_lseek</function>、<function>lo_lseek64</function>、<function>lo_tell</function>、<function>lo_tell64</function>、<function>lo_truncate</function>、<function>lo_truncate64</function>以及<function>lo_close</function>。该描述符只在当前事务期间有效。如果打开错误将会返回-1。
    </para>
<!-- pgdoc-cn_end sig_en=845507e78c70ac6ef2fb8e4e420db75a -->

<!-- pgdoc-cn_start sig_en=6f36c6743d12ff455320a264eba265e8 sig_cn_org=None source=14.1 
    <para>
     The server currently does not distinguish between modes
     <symbol>INV_WRITE</symbol> and <symbol>INV_READ</symbol> <literal>|</literal>
     <symbol>INV_WRITE</symbol>: you are allowed to read from the descriptor
     in either case.  However there is a significant difference between
     these modes and <symbol>INV_READ</symbol> alone: with <symbol>INV_READ</symbol>
     you cannot write on the descriptor, and the data read from it will
     reflect the contents of the large object at the time of the transaction
     snapshot that was active when <function>lo_open</function> was executed,
     regardless of later writes by this or other transactions.  Reading
     from a descriptor opened with <symbol>INV_WRITE</symbol> returns
     data that reflects all writes of other committed transactions as well
     as writes of the current transaction.  This is similar to the behavior
     of <literal>REPEATABLE READ</literal> versus <literal>READ COMMITTED</literal> transaction
     modes for ordinary SQL <command>SELECT</command> commands.
    </para>
________________________________________________________-->
    <para>
     服务器目前并不区分模式<symbol>INV_WRITE</symbol>和<symbol>INV_READ</symbol> <literal>|</literal><symbol>INV_WRITE</symbol>：在两种情况中都允许从描述符读取。但是在这些模式和单独的<symbol>INV_READ</symbol>之间有明显的区别：使用<symbol>INV_READ</symbol>我们不能向描述符写入，从中读取的数据则反映了该大对象在活动事务快照时刻的内容（该快照在<function>lo_open</function>被执行时创建），而不管之后被该事务或其他事务写入的内容。从一个以<symbol>INV_WRITE</symbol>模式打开的描述符读取的数据所有其他已提交事务以及当前事务所作的写入。这与普通SQL命令 <command>SELECT</command>的<literal>REPEATABLE READ</literal>和<literal>READ COMMITTED</literal>事务模式之间的区别相似。
    </para>
<!-- pgdoc-cn_end sig_en=6f36c6743d12ff455320a264eba265e8 -->

<!-- pgdoc-cn_start sig_en=9710359e77209c07420702c833390459 sig_cn_org=None source=14.1 
    <para>
     <function>lo_open</function> will fail if <literal>SELECT</literal>
     privilege is not available for the large object, or
     if <symbol>INV_WRITE</symbol> is specified and <literal>UPDATE</literal>
     privilege is not available.
     (Prior to <productname>PostgreSQL</productname> 11, these privilege
     checks were instead performed at the first actual read or write call
     using the descriptor.)
     These privilege checks can be disabled with the
     <xref linkend="guc-lo-compat-privileges"/> run-time parameter.
    </para>
________________________________________________________-->
    <para>
     如果大对象的<literal>SELECT</literal>特权不可用，或者如果在指定了<symbol>INV_WRITE</symbol>时<literal>UPDATE</literal>特权不可用，则<function>lo_open</function>将会失败（在<productname>PostgreSQL</productname> 11之前，这些特权的检查是在使用该描述符的第一次实际读取或写入时进行）。这些特权检查可以用<xref linkend="guc-lo-compat-privileges"/>运行时参数禁用。
    </para>
<!-- pgdoc-cn_end sig_en=9710359e77209c07420702c833390459 -->

<!-- pgdoc-cn_start sig_en=39168727caf3e81286195e1365c91db8 sig_cn_org=None source=14.1 
    <para>
     An example:
<programlisting>
inv_fd = lo_open(conn, inv_oid, INV_READ|INV_WRITE);
</programlisting>
    </para>
________________________________________________________-->
    <para>
     一个例子：
<programlisting>
inv_fd = lo_open(conn, inv_oid, INV_READ|INV_WRITE);
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=39168727caf3e81286195e1365c91db8 -->
</sect2>

<sect2 id="lo-write">
<!-- pgdoc-cn_start sig_en=702c9f45563b6539181f6bcc92ef7473 sig_cn_org=None source=14.1 
<title>Writing Data to a Large Object</title>
________________________________________________________-->
<title>向一个大对象写入数据</title>
<!-- pgdoc-cn_end sig_en=702c9f45563b6539181f6bcc92ef7473 -->

<!-- pgdoc-cn_start sig_en=b2821dba650bd8fce2f0d4da71b608d6 sig_cn_org=None source=14.1 
<para>
     <indexterm><primary>lo_write</primary></indexterm>
     The function
<synopsis>
int lo_write(PGconn *conn, int fd, const char *buf, size_t len);
</synopsis>
     writes <parameter>len</parameter> bytes from <parameter>buf</parameter>
     (which must be of size <parameter>len</parameter>) to large object
     descriptor <parameter>fd</parameter>.  The <parameter>fd</parameter> argument must
     have been returned by a previous <function>lo_open</function>.  The
     number of bytes actually written is returned (in the current
     implementation, this will always equal <parameter>len</parameter> unless
     there is an error).  In the event of an error, the return value is -1.
</para>
________________________________________________________-->
<para>
     <indexterm><primary>lo_write</primary></indexterm>
     函数
<synopsis>
int lo_write(PGconn *conn, int fd, const char *buf, size_t len);
</synopsis>
     从<parameter>buf</parameter>（大小必须是 <parameter>len</parameter>）中写出<parameter>len</parameter>字节到大对象描述符<parameter>fd</parameter>。参数<parameter>fd</parameter>必须是已经由前面的<function>lo_open</function>返回的大对象描述符。函数将返回实际写入的字节数（在当前的实现中，除非出错，返回的字节数总是等于<parameter>len</parameter>）。在出错时，返回值为-1。
</para>
<!-- pgdoc-cn_end sig_en=b2821dba650bd8fce2f0d4da71b608d6 -->

<!-- pgdoc-cn_start sig_en=07ea32df86a4d8aea69e8e4e42614beb sig_cn_org=None source=14.1 
<para>
     Although the <parameter>len</parameter> parameter is declared as
     <type>size_t</type>, this function will reject length values larger than
     <literal>INT_MAX</literal>.  In practice, it's best to transfer data in chunks
     of at most a few megabytes anyway.
</para>
________________________________________________________-->
<para>
     尽管参数<parameter>len</parameter>被声明为类型<type>size_t</type>，该函数会拒绝超过<literal>INT_MAX</literal>的长度值。在实际中，被传送的数据最好是每块最多数兆字节。
</para>
<!-- pgdoc-cn_end sig_en=07ea32df86a4d8aea69e8e4e42614beb -->
</sect2>

<sect2 id="lo-read">
<!-- pgdoc-cn_start sig_en=e6c2a25c16086076b6939e81814534fe sig_cn_org=None source=14.1 
<title>Reading Data from a Large Object</title>
________________________________________________________-->
<title>从一个大对象读取数据</title>
<!-- pgdoc-cn_end sig_en=e6c2a25c16086076b6939e81814534fe -->

<!-- pgdoc-cn_start sig_en=836be5ea8909a01ac8a9b7608164e603 sig_cn_org=None source=14.1 
<para>
     <indexterm><primary>lo_read</primary></indexterm>
     The function
<synopsis>
int lo_read(PGconn *conn, int fd, char *buf, size_t len);
</synopsis>
     reads up to <parameter>len</parameter> bytes from large object descriptor
     <parameter>fd</parameter> into <parameter>buf</parameter> (which must be
     of size <parameter>len</parameter>).  The <parameter>fd</parameter>
     argument must have been returned by a previous
     <function>lo_open</function>.  The number of bytes actually read is
     returned; this will be less than <parameter>len</parameter> if the end of
     the large object is reached first.  In the event of an error, the return
     value is -1.
</para>
________________________________________________________-->
<para>
     <indexterm><primary>lo_read</primary></indexterm>
     函数
<synopsis>
int lo_read(PGconn *conn, int fd, char *buf, size_t len);
</synopsis>
     从大对象描述符<parameter>fd</parameter>中读取最多<parameter>len</parameter>字节到<parameter>buf</parameter> （大小必须是<parameter>len</parameter>）中。参数<parameter>fd</parameter>必须是已经由前面的<function>lo_open</function>返回的大对象描述符。实际读出的字节数将被返回，如果先到达了大对象的末尾返回值可能会小于<parameter>len</parameter>。出错时返回值为-1。
</para>
<!-- pgdoc-cn_end sig_en=836be5ea8909a01ac8a9b7608164e603 -->

<!-- pgdoc-cn_start sig_en=07ea32df86a4d8aea69e8e4e42614beb sig_cn_org=None source=14.1 
<para>
     Although the <parameter>len</parameter> parameter is declared as
     <type>size_t</type>, this function will reject length values larger than
     <literal>INT_MAX</literal>.  In practice, it's best to transfer data in chunks
     of at most a few megabytes anyway.
</para>
________________________________________________________-->
<para>
     尽管参数<parameter>len</parameter>被声明为类型<type>size_t</type>，该函数会拒绝超过<literal>INT_MAX</literal>的长度值。在实际中，被传送的数据最好是每块最多数兆字节。
</para>
<!-- pgdoc-cn_end sig_en=07ea32df86a4d8aea69e8e4e42614beb -->
</sect2>

<sect2 id="lo-seek">
<!-- pgdoc-cn_start sig_en=f8fe6c48354fc4bbd840ff6bded3217d sig_cn_org=None source=14.1 
<title>Seeking in a Large Object</title>
________________________________________________________-->
<title>在一个大对象中查找</title>
<!-- pgdoc-cn_end sig_en=f8fe6c48354fc4bbd840ff6bded3217d -->

<!-- pgdoc-cn_start sig_en=3f189a866c54ea44ce5548774ac52870 sig_cn_org=None source=14.1 
<para>
     <indexterm><primary>lo_lseek</primary></indexterm>
     To change the current read or write location associated with a
     large object descriptor, call
<synopsis>
int lo_lseek(PGconn *conn, int fd, int offset, int whence);
</synopsis>
     This function moves the
     current location pointer for the large object descriptor identified by
     <parameter>fd</parameter> to the new location specified by
     <parameter>offset</parameter>.  The valid values for <parameter>whence</parameter>
     are <symbol>SEEK_SET</symbol> (seek from object start),
     <symbol>SEEK_CUR</symbol> (seek from current position), and
     <symbol>SEEK_END</symbol> (seek from object end).  The return value is
     the new location pointer, or -1 on error.
</para>
________________________________________________________-->
<para>
     <indexterm><primary>lo_lseek</primary></indexterm>
     要改变一个大对象描述符的当前读或写位置，调用：
<synopsis>
int lo_lseek(PGconn *conn, int fd, int offset, int whence);
</synopsis>
     该函数将大对象文件描述符<parameter>fd</parameter>的当前位置指针移动到由<parameter>offset</parameter>指定的新位置。<parameter>whence</parameter>的可用值是<symbol>SEEK_SET</symbol>（从对象开头定位）、<symbol>SEEK_CUR</symbol> （从当前位置定位）以及<symbol>SEEK_END</symbol>（从对象末尾定位）。返回值是新位置的指针，或者是-1表示出错。
</para>
<!-- pgdoc-cn_end sig_en=3f189a866c54ea44ce5548774ac52870 -->

<!-- pgdoc-cn_start sig_en=b1c4b9877f486ec6dd5469e9b9694343 sig_cn_org=None source=14.1 
<para>
     <indexterm><primary>lo_lseek64</primary></indexterm>
     When dealing with large objects that might exceed 2GB in size,
     instead use
<synopsis>
pg_int64 lo_lseek64(PGconn *conn, int fd, pg_int64 offset, int whence);
</synopsis>
     This function has the same behavior
     as <function>lo_lseek</function>, but it can accept an
     <parameter>offset</parameter> larger than 2GB and/or deliver a result larger
     than 2GB.
     Note that <function>lo_lseek</function> will fail if the new location
     pointer would be greater than 2GB.
</para>
________________________________________________________-->
<para>
     <indexterm><primary>lo_lseek64</primary></indexterm>
     在处理可能超过2GB大小的大对象时，换用
<synopsis>
pg_int64 lo_lseek64(PGconn *conn, int fd, pg_int64 offset, int whence);
</synopsis>
     该函数的行为和<function>lo_lseek</function>相同，但是它能接受一个超过2GB的<parameter>offset</parameter>并/或传送一个超过2GB的结果。注意如果新位置的指针超过2GB，<function>lo_lseek</function>会失败。
</para>
<!-- pgdoc-cn_end sig_en=b1c4b9877f486ec6dd5469e9b9694343 -->

<!-- pgdoc-cn_start sig_en=a4a912e0cdf74d7938d4917da9610747 sig_cn_org=None source=14.1 
<para>
     <function>lo_lseek64</function> is new as of <productname>PostgreSQL</productname>
     9.3.  If this function is run against an older server version, it will
     fail and return -1.
</para>
________________________________________________________-->
<para>
     <function>lo_lseek64</function>是从 <productname>PostgreSQL</productname> 9.3开始增加的新函数。如果该函数在一个旧服务器版本上执行，将会失败并返回-1。
</para>
<!-- pgdoc-cn_end sig_en=a4a912e0cdf74d7938d4917da9610747 -->

</sect2>

<sect2 id="lo-tell">
<!-- pgdoc-cn_start sig_en=5402798db10702be6bde0493c9900006 sig_cn_org=None source=14.1 
<title>Obtaining the Seek Position of a Large Object</title>
________________________________________________________-->
<title>获取一个大对象的查找位置</title>
<!-- pgdoc-cn_end sig_en=5402798db10702be6bde0493c9900006 -->

<!-- pgdoc-cn_start sig_en=c8aa265d66b30ff8422a3dc422a74082 sig_cn_org=None source=14.1 
<para>
     <indexterm><primary>lo_tell</primary></indexterm>
     To obtain the current read or write location of a large object descriptor,
     call
<synopsis>
int lo_tell(PGconn *conn, int fd);
</synopsis>
     If there is an error, the return value is -1.
</para>
________________________________________________________-->
<para>
     <indexterm><primary>lo_tell</primary></indexterm>
     要得到一个大对象描述符的当前读或写位置，调用：
<synopsis>
int lo_tell(PGconn *conn, int fd);
</synopsis>
     如果出现错误，返回值是-1。
</para>
<!-- pgdoc-cn_end sig_en=c8aa265d66b30ff8422a3dc422a74082 -->

<!-- pgdoc-cn_start sig_en=8b476924ebe0bab6d43464b4df44f918 sig_cn_org=None source=14.1 
<para>
     <indexterm><primary>lo_tell64</primary></indexterm>
     When dealing with large objects that might exceed 2GB in size,
     instead use
<synopsis>
pg_int64 lo_tell64(PGconn *conn, int fd);
</synopsis>
     This function has the same behavior
     as <function>lo_tell</function>, but it can deliver a result larger
     than 2GB.
     Note that <function>lo_tell</function> will fail if the current
     read/write location is greater than 2GB.
</para>
________________________________________________________-->
<para>
     <indexterm><primary>lo_tell64</primary></indexterm>
     在处理可能超过2GB大小的大对象时，换用：
<synopsis>
pg_int64 lo_tell64(PGconn *conn, int fd);
</synopsis>
     该函数和<function>lo_tell</function>的行为相同，但是它能传递超过2GB的结果。注意如果当前读/写位置超过2GB，<function>lo_tell</function>将会失败。
</para>
<!-- pgdoc-cn_end sig_en=8b476924ebe0bab6d43464b4df44f918 -->

<!-- pgdoc-cn_start sig_en=f5813d0bba9ecaf5bce827b27ee9c9b1 sig_cn_org=None source=14.1 
<para>
     <function>lo_tell64</function> is new as of <productname>PostgreSQL</productname>
     9.3.  If this function is run against an older server version, it will
     fail and return -1.
</para>
________________________________________________________-->
<para>
     <function>lo_tell64</function>是从<productname>PostgreSQL</productname> 9.3开始新增的函数。如果该函数在旧服务器版本上运行，将会失败并返回-1。
</para>
<!-- pgdoc-cn_end sig_en=f5813d0bba9ecaf5bce827b27ee9c9b1 -->
</sect2>

<sect2 id="lo-truncate">
<!-- pgdoc-cn_start sig_en=022b92842b7a4ad6ea4ea44fa3f7598a sig_cn_org=None source=14.1 
<title>Truncating a Large Object</title>
________________________________________________________-->
<title>截断一个大对象</title>
<!-- pgdoc-cn_end sig_en=022b92842b7a4ad6ea4ea44fa3f7598a -->

<!-- pgdoc-cn_start sig_en=798d8b9c7d7577f12dba76ad446de0de sig_cn_org=None source=14.1 
<para>
     <indexterm><primary>lo_truncate</primary></indexterm>
     To truncate a large object to a given length, call
<synopsis>
int lo_truncate(PGconn *conn, int fd, size_t len);
</synopsis>
     This function truncates the large object
     descriptor <parameter>fd</parameter> to length <parameter>len</parameter>.  The
     <parameter>fd</parameter> argument must have been returned by a
     previous <function>lo_open</function>.  If <parameter>len</parameter> is
     greater than the large object's current length, the large object
     is extended to the specified length with null bytes ('\0').
     On success, <function>lo_truncate</function> returns
     zero.  On error, the return value is -1.
</para>
________________________________________________________-->
<para>
     <indexterm><primary>lo_truncate</primary></indexterm>
     要将一个大对象截断成一个给定长度，调用：
<synopsis>
int lo_truncate(PGconn *conn, int fd, size_t len);
</synopsis>
     该函数将大对象描述符<parameter>fd</parameter>截断为长度<parameter>len</parameter>。参数<parameter>fd</parameter>必须是已经由前面的<function>lo_open</function>返回的大对象描述符。如果<parameter>len</parameter>超过了大对象的当前长度，大对象将会被使用空字节（'\0'）扩展到指定长度。成功时<function>lo_truncate</function>返回0，失败时返回值为-1。
</para>
<!-- pgdoc-cn_end sig_en=798d8b9c7d7577f12dba76ad446de0de -->

<!-- pgdoc-cn_start sig_en=628b6c0d4531a7e769d21260741859c3 sig_cn_org=None source=14.1 
<para>
     The read/write location associated with the descriptor
     <parameter>fd</parameter> is not changed.
</para>
________________________________________________________-->
<para>
     描述<parameter>fd</parameter>的读/写位置不变。
</para>
<!-- pgdoc-cn_end sig_en=628b6c0d4531a7e769d21260741859c3 -->

<!-- pgdoc-cn_start sig_en=1d5ebc67f818f9fd29a18ca364237375 sig_cn_org=None source=14.1 
<para>
     Although the <parameter>len</parameter> parameter is declared as
     <type>size_t</type>, <function>lo_truncate</function> will reject length
     values larger than <literal>INT_MAX</literal>.
</para>
________________________________________________________-->
<para>
     尽管参数<parameter>len</parameter>被声明为类型<type>size_t</type>，<function>lo_truncate</function>会拒绝超过<literal>INT_MAX</literal>的长度值。
</para>
<!-- pgdoc-cn_end sig_en=1d5ebc67f818f9fd29a18ca364237375 -->

<!-- pgdoc-cn_start sig_en=852d7addb9c89e73c763740ef9319abe sig_cn_org=None source=14.1 
<para>
     <indexterm><primary>lo_truncate64</primary></indexterm>
     When dealing with large objects that might exceed 2GB in size,
     instead use
<synopsis>
int lo_truncate64(PGconn *conn, int fd, pg_int64 len);
</synopsis>
     This function has the same
     behavior as <function>lo_truncate</function>, but it can accept a
     <parameter>len</parameter> value exceeding 2GB.
</para>
________________________________________________________-->
<para>
     <indexterm><primary>lo_truncate64</primary></indexterm>
     在处理可能超过2GB大小的大对象时，换用：
<synopsis>
int lo_truncate64(PGconn *conn, int fd, pg_int64 len);
</synopsis>
     该函数和<function>lo_truncate</function>的行为相同，但它能够接受超过2GB的<parameter>len</parameter>值。
</para>
<!-- pgdoc-cn_end sig_en=852d7addb9c89e73c763740ef9319abe -->

<!-- pgdoc-cn_start sig_en=887966f03b8a4118d44e62bbd7be4f75 sig_cn_org=None source=14.1 
<para>
     <function>lo_truncate</function> is new as of <productname>PostgreSQL</productname>
     8.3; if this function is run against an older server version, it will
     fail and return -1.
</para>
________________________________________________________-->
<para>
     <function>lo_truncate</function>是从<productname>PostgreSQL</productname> 8.3开始新的函数，如果该函数运行在一个旧服务器版本上，它将失败并返回-1。
</para>
<!-- pgdoc-cn_end sig_en=887966f03b8a4118d44e62bbd7be4f75 -->

<!-- pgdoc-cn_start sig_en=b52edfa60141b8af1a3da2173f42b48c sig_cn_org=None source=14.1 
<para>
     <function>lo_truncate64</function> is new as of <productname>PostgreSQL</productname>
     9.3; if this function is run against an older server version, it will
     fail and return -1.
</para>
________________________________________________________-->
<para>
     <function>lo_truncate64</function>是从<productname>PostgreSQL</productname> 9.3开始新的函数，如果该函数运行在一个旧服务器版本上，它将失败并返回-1。
</para>
<!-- pgdoc-cn_end sig_en=b52edfa60141b8af1a3da2173f42b48c -->
</sect2>

<sect2 id="lo-close">
<!-- pgdoc-cn_start sig_en=23ed2c4bdcc54ea41fb803966216ee8f sig_cn_org=None source=14.1 
<title>Closing a Large Object Descriptor</title>
________________________________________________________-->
<title>关闭一个大对象描述符</title>
<!-- pgdoc-cn_end sig_en=23ed2c4bdcc54ea41fb803966216ee8f -->

<!-- pgdoc-cn_start sig_en=21835453be789a39fbfd1873907aa015 sig_cn_org=None source=14.1 
<para>
     <indexterm><primary>lo_close</primary></indexterm>
     A large object descriptor can be closed by calling
<synopsis>
int lo_close(PGconn *conn, int fd);
</synopsis>
     where <parameter>fd</parameter> is a
     large object descriptor returned by <function>lo_open</function>.
     On success, <function>lo_close</function> returns zero.  On
     error, the return value is -1.
</para>
________________________________________________________-->
<para>
     <indexterm><primary>lo_close</primary></indexterm>
     要关闭一个大对象描述符，调用：
<synopsis>
int lo_close(PGconn *conn, int fd);
</synopsis>
     其中<parameter>fd</parameter>是由<function>lo_open</function>返回的大对象描述符。成功时，<function>lo_close</function>返回0，失败时返回-1。
</para>
<!-- pgdoc-cn_end sig_en=21835453be789a39fbfd1873907aa015 -->

<!-- pgdoc-cn_start sig_en=948f5c3e86d00245d44725bd6ae14f06 sig_cn_org=None source=14.1 
<para>
     Any large  object  descriptors that remain open at the end of a
     transaction will be closed automatically.
</para>
________________________________________________________-->
<para>
     在事务末尾仍然保持打开的任何大对象描述符都会自动被关闭。
</para>
<!-- pgdoc-cn_end sig_en=948f5c3e86d00245d44725bd6ae14f06 -->
</sect2>

   <sect2 id="lo-unlink">
<!-- pgdoc-cn_start sig_en=05b89442e8508dcbb4ed326870edee76 sig_cn_org=None source=14.1 
    <title>Removing a Large Object</title>
________________________________________________________-->
    <title>移除一个大对象</title>
<!-- pgdoc-cn_end sig_en=05b89442e8508dcbb4ed326870edee76 -->

<!-- pgdoc-cn_start sig_en=7b999af129fc123e21893d04c1873d9e sig_cn_org=None source=14.1 
    <para>
     <indexterm><primary>lo_unlink</primary></indexterm>
     To remove a large object from the database, call
<synopsis>
int lo_unlink(PGconn *conn, Oid lobjId);
</synopsis>
     The <parameter>lobjId</parameter> argument specifies the OID of the
     large object to remove.  Returns 1 if successful, -1 on failure.
    </para>
________________________________________________________-->
    <para>
     <indexterm><primary>lo_unlink</primary></indexterm>
     要从数据库中移除一个大对象，调用：
<synopsis>
int lo_unlink(PGconn *conn, Oid lobjId);
</synopsis>
     <parameter>lobjId</parameter>参数指定要移除的大对象的OID。成功时返回1，失败时返回-1。
    </para>
<!-- pgdoc-cn_end sig_en=7b999af129fc123e21893d04c1873d9e -->
   </sect2>

</sect1>

<sect1 id="lo-funcs">
<!-- pgdoc-cn_start sig_en=0f0465b536b9232928425bb9f5fc26a1 sig_cn_org=None source=14.1 
<title>Server-Side Functions</title>
________________________________________________________-->
<title>服务器端函数</title>
<!-- pgdoc-cn_end sig_en=0f0465b536b9232928425bb9f5fc26a1 -->

<!-- pgdoc-cn_start sig_en=5d2a46b91c783b1d487e2ca0ca27bfdb sig_cn_org=None source=14.1 
  <para>
   Server-side functions tailored for manipulating large objects from SQL are
   listed in <xref linkend="lo-funcs-table"/>.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="lo-funcs-table"/>中列出了为从 SQL 操纵大对象定制的服务器端函数。
  </para>
<!-- pgdoc-cn_end sig_en=5d2a46b91c783b1d487e2ca0ca27bfdb -->

   <table id="lo-funcs-table">
<!-- pgdoc-cn_start sig_en=8ed2d7f47a737dc932f9a515f5e3ebae sig_cn_org=None source=14.1 
    <title>SQL-Oriented Large Object Functions</title>
________________________________________________________-->
    <title>面向 SQL 的大对象函数</title>
<!-- pgdoc-cn_end sig_en=8ed2d7f47a737dc932f9a515f5e3ebae -->
    <tgroup cols="1">
     <thead>
<!-- pgdoc-cn_start sig_en=aea31b510d403ec475cd76fb26ed5e1f sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para>
       <para>
        Example(s)
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para>
       <para>
        例子
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=aea31b510d403ec475cd76fb26ed5e1f -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=925922e7f4975f1054eaba78b704a9aa sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lo_from_bytea</primary>
        </indexterm>
        <function>lo_from_bytea</function> ( <parameter>loid</parameter> <type>oid</type>, <parameter>data</parameter> <type>bytea</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        Creates a large object and stores <parameter>data</parameter> in it.
        If <parameter>loid</parameter> is zero then the system will choose a
        free OID, otherwise that OID is used (with an error if some large
        object already has that OID).  On success, the large object's OID is
        returned.
       </para>
       <para>
        <literal>lo_from_bytea(0, '\xffffff00')</literal>
        <returnvalue>24528</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lo_from_bytea</primary>
        </indexterm>
        <function>lo_from_bytea</function> ( <parameter>loid</parameter> <type>oid</type>, <parameter>data</parameter> <type>bytea</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        创建一个大对象并在其中存储<parameter>数据</parameter>。
        如果<parameter>loid</parameter>为0，则系统将选择一个空闲OID，否则该OID已被使用(如果某个大对象已经拥有该OID，则会出现错误)。在成功时，将返回大对象的OID。
       </para>
       <para>
        <literal>lo_from_bytea(0, '\xffffff00')</literal>
        <returnvalue>24528</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=925922e7f4975f1054eaba78b704a9aa -->

<!-- pgdoc-cn_start sig_en=ae232d941fbec2bec53af0d169185d5d sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lo_put</primary>
        </indexterm>
        <function>lo_put</function> ( <parameter>loid</parameter> <type>oid</type>, <parameter>offset</parameter> <type>bigint</type>, <parameter>data</parameter> <type>bytea</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Writes <parameter>data</parameter> starting at the given offset within
        the large object; the large object is enlarged if necessary.
       </para>
       <para>
        <literal>lo_put(24528, 1, '\xaa')</literal>
        <returnvalue></returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lo_put</primary>
        </indexterm>
        <function>lo_put</function> ( <parameter>loid</parameter> <type>oid</type>, <parameter>offset</parameter> <type>bigint</type>, <parameter>data</parameter> <type>bytea</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        在大对象中写入从给定偏移量开始的<parameter>数据</parameter>;如有必要，可以把大对象扩大。
       </para>
       <para>
        <literal>lo_put(24528, 1, '\xaa')</literal>
        <returnvalue></returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=ae232d941fbec2bec53af0d169185d5d -->

<!-- pgdoc-cn_start sig_en=a4147a327d7eae3e60e8de8670e79cbd sig_cn_org=None source=14.1 
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lo_get</primary>
        </indexterm>
        <function>lo_get</function> ( <parameter>loid</parameter> <type>oid</type> <optional>, <parameter>offset</parameter> <type>bigint</type>, <parameter>length</parameter> <type>integer</type> </optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        Extracts the large object's contents, or a substring thereof.
       </para>
       <para>
        <literal>lo_get(24528, 0, 3)</literal>
        <returnvalue>\xffaaff</returnvalue>
       </para></entry>
      </row>
________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>lo_get</primary>
        </indexterm>
        <function>lo_get</function> ( <parameter>loid</parameter> <type>oid</type> <optional>, <parameter>offset</parameter> <type>bigint</type>, <parameter>length</parameter> <type>integer</type> </optional> )
        <returnvalue>bytea</returnvalue>
       </para>
       <para>
        提取大对象的内容，或在其中的子字符串。
       </para>
       <para>
        <literal>lo_get(24528, 0, 3)</literal>
        <returnvalue>\xffaaff</returnvalue>
       </para></entry>
      </row>
<!-- pgdoc-cn_end sig_en=a4147a327d7eae3e60e8de8670e79cbd -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=c0be32d834edfbf7bf8d668e8b6ac85b sig_cn_org=None source=14.1 
  <para>
   There are additional server-side functions corresponding to each of the
   client-side functions described earlier; indeed, for the most part the
   client-side functions are simply interfaces to the equivalent server-side
   functions.  The ones just as convenient to call via SQL commands are
   <function>lo_creat</function><indexterm><primary>lo_creat</primary></indexterm>,
   <function>lo_create</function>,
   <function>lo_unlink</function><indexterm><primary>lo_unlink</primary></indexterm>,
   <function>lo_import</function><indexterm><primary>lo_import</primary></indexterm>, and
   <function>lo_export</function><indexterm><primary>lo_export</primary></indexterm>.
   Here are examples of their use:

<programlisting>
CREATE TABLE image (
    name            text,
    raster          oid
);

SELECT lo_creat(-1);       -&minus; returns OID of new, empty large object

SELECT lo_create(43213);   -&minus; attempts to create large object with OID 43213

SELECT lo_unlink(173454);  -&minus; deletes large object with OID 173454

INSERT INTO image (name, raster)
    VALUES ('beautiful image', lo_import('/etc/motd'));

INSERT INTO image (name, raster)  -&minus; same as above, but specify OID to use
    VALUES ('beautiful image', lo_import('/etc/motd', 68583));

SELECT lo_export(image.raster, '/tmp/motd') FROM image
    WHERE name = 'beautiful image';
</programlisting>
  </para>
________________________________________________________-->
  <para>
   之前描述过的每个客户端函数都有一个相应的服务器端函数。实际上，
   多半客户端函数都是等效的服务器端函数的简单接口。这些可以从 SQL 
   命令方便调用的函数是：
   <function>lo_creat</function><indexterm><primary>lo_creat</primary></indexterm>、
   <function>lo_create</function>、
   <function>lo_unlink</function><indexterm><primary>lo_unlink</primary></indexterm>、
   <function>lo_import</function><indexterm><primary>lo_import</primary></indexterm>以及
   <function>lo_export</function><indexterm><primary>lo_export</primary></indexterm>。
   下面是使用它们的例子：

<programlisting>
CREATE TABLE image (
    name            text,
    raster          oid
);

SELECT lo_creat(-1);       -- 返回新的空大对象的OID

SELECT lo_create(43213);   -- 尝试创建OID为43213的大对象

SELECT lo_unlink(173454);  -- 删除OID为173454的大对象

INSERT INTO image (name, raster)
    VALUES ('beautiful image', lo_import('/etc/motd'));

INSERT INTO image (name, raster)  -- 和上面相同，但是指定了使用的OID
    VALUES ('beautiful image', lo_import('/etc/motd', 68583));

SELECT lo_export(image.raster, '/tmp/motd') FROM image
    WHERE name = 'beautiful image';
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=c0be32d834edfbf7bf8d668e8b6ac85b -->

<!-- pgdoc-cn_start sig_en=ae66f2c25bb62d1ec162328480fc72d1 sig_cn_org=None source=14.1 
  <para>
    The server-side <function>lo_import</function> and
    <function>lo_export</function> functions behave considerably differently
    from their client-side analogs.  These two functions read and write files
    in the server's file system, using the permissions of the database's
    owning user.  Therefore, by default their use is restricted to superusers.
    In contrast, the client-side import and export functions read and write
    files in the client's file system, using the permissions of the client
    program.  The client-side functions do not require any database
    privileges, except the privilege to read or write the large object in
    question.
  </para>
________________________________________________________-->
  <para>
    服务器端的<function>lo_import</function>和<function>lo_export</function>函数具有和它们的客户端同类大不相同的行为。这两个函数从服务器的文件系统中读和写文件，使用的是数据库所有者的权限。因此，默认情况下它们的使用被限制于超级用户。相反，客户端的导入和导出函数读写的是客户端的文件系统，使用的是客户端程序的权限。除了读取或写入所请求的大对象的特权之外，客户端函数不要求任何数据库特权。
  </para>
<!-- pgdoc-cn_end sig_en=ae66f2c25bb62d1ec162328480fc72d1 -->

  <caution>
<!-- pgdoc-cn_start sig_en=2b54211a200b0c413b72b43b9ea0d158 sig_cn_org=None source=14.1 
   <para>
    It is possible to <xref linkend="sql-grant"/> use of the
    server-side <function>lo_import</function>
    and <function>lo_export</function> functions to non-superusers, but
    careful consideration of the security implications is required.  A
    malicious user of such privileges could easily parlay them into becoming
    superuser (for example by rewriting server configuration files), or could
    attack the rest of the server's file system without bothering to obtain
    database superuser privileges as such.  <emphasis>Access to roles having
    such privilege must therefore be guarded just as carefully as access to
    superuser roles.</emphasis>  Nonetheless, if use of
    server-side <function>lo_import</function>
    or <function>lo_export</function> is needed for some routine task, it's
    safer to use a role with such privileges than one with full superuser
    privileges, as that helps to reduce the risk of damage from accidental
    errors.
   </para>
________________________________________________________-->
   <para>
    可以把服务器端的<function>lo_import</function>和<function>lo_export</function>函数<xref linkend="sql-grant"/>给非超级用户，但需要仔细地考虑安全因素。有这类特权的恶意用户可以很容易地利用它们成为超级用户（例如通过重写服务器配置文件），或者攻击该服务器文件系统的其他部分而无需获得数据库超级用户特权。<emphasis>因此对具有这类特权的角色访问必须受到和超级用户角色一样的仔细保护。</emphasis>尽管如此，如果某些例行任务需要使用服务器端的<function>lo_import</function>或者<function>lo_export</function>，使用具有这类特权的角色比使用具有完整超级用户特权的角色更加安全，因为那样会减小意外错误造成的损伤风险。
   </para>
<!-- pgdoc-cn_end sig_en=2b54211a200b0c413b72b43b9ea0d158 -->
  </caution>

<!-- pgdoc-cn_start sig_en=fad033ce2db065499f45aba697169f8c sig_cn_org=None source=14.1 
  <para>
    The functionality of <function>lo_read</function> and
    <function>lo_write</function> is also available via server-side calls,
    but the names of the server-side functions differ from the client side
    interfaces in that they do not contain underscores.  You must call
    these functions as <function>loread</function> and <function>lowrite</function>.
  </para>
________________________________________________________-->
  <para>
    函数<function>lo_read</function>和
    <function>lo_write</function>的功能也可以在服务器端调用，但是在服务器端的名称与客户端接口不同：它们的名称中不包含下划线。我们必须以<function>loread</function>和<function>lowrite</function>调用这些函数。
  </para>
<!-- pgdoc-cn_end sig_en=fad033ce2db065499f45aba697169f8c -->

</sect1>

<sect1 id="lo-examplesect">
<!-- pgdoc-cn_start sig_en=63dbe0181099726b491f6f1a2e98b6d9 sig_cn_org=None source=14.1 
<title>Example Program</title>
________________________________________________________-->
<title>例子程序</title>
<!-- pgdoc-cn_end sig_en=63dbe0181099726b491f6f1a2e98b6d9 -->

<!-- pgdoc-cn_start sig_en=0e1316c082147d4ba56de517d91220b5 sig_cn_org=None source=14.1 
<para>
     <xref linkend="lo-example"/> is a sample program which shows how the large object
     interface
     in <application>libpq</application> can be used.  Parts of the program are
     commented out but are left in the source for  the  reader's
     benefit.  This program can also be found in
     <filename>src/test/examples/testlo.c</filename> in the source distribution.
</para>
________________________________________________________-->
<para>
     <xref linkend="lo-example"/>是一个展示<application>libpq</application>中大对象接口如何使用的例子程序。部分程序被注释但仍保留在代码中，用户可以利用之。该程序可以在源代码的<filename>src/test/examples/testlo.c</filename>中找到。
</para>
<!-- pgdoc-cn_end sig_en=0e1316c082147d4ba56de517d91220b5 -->

  <example id="lo-example">
<!-- pgdoc-cn_start sig_en=720a1fd7a0e2faddd2629a578899b4ab sig_cn_org=None source=14.1 
   <title>Large Objects with <application>libpq</application> Example Program</title>
________________________________________________________-->
   <title>用<application>libpq</application>操作大对象的例子程序</title>
<!-- pgdoc-cn_end sig_en=720a1fd7a0e2faddd2629a578899b4ab -->
<programlisting><![CDATA[
/*-----------------------------------------------------------------
 *
 * testlo.c
 *    test using large objects with libpq
 *
 * Portions Copyright (c) 1996-2022, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *    src/test/examples/testlo.c
 *
 *-----------------------------------------------------------------
 */
#include <stdio.h>
#include <stdlib.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#include "libpq-fe.h"
#include "libpq/libpq-fs.h"

#define BUFSIZE         1024

/*
 * importFile -
 *    import file "in_filename" into database as large object "lobjOid"
 *
 */
static Oid
importFile(PGconn *conn, char *filename)
{
    Oid         lobjId;
    int         lobj_fd;
    char        buf[BUFSIZE];
    int         nbytes,
                tmp;
    int         fd;

    /*
     * open the file to be read in
     */
    fd = open(filename, O_RDONLY, 0666);
    if (fd < 0)
    {                           /* error */
        fprintf(stderr, "cannot open unix file\"%s\"\n", filename);
    }

    /*
     * create the large object
     */
    lobjId = lo_creat(conn, INV_READ | INV_WRITE);
    if (lobjId == 0)
        fprintf(stderr, "cannot create large object");

    lobj_fd = lo_open(conn, lobjId, INV_WRITE);

    /*
     * read in from the Unix file and write to the inversion file
     */
    while ((nbytes = read(fd, buf, BUFSIZE)) > 0)
    {
        tmp = lo_write(conn, lobj_fd, buf, nbytes);
        if (tmp < nbytes)
            fprintf(stderr, "error while reading \"%s\"", filename);
    }

    close(fd);
    lo_close(conn, lobj_fd);

    return lobjId;
}

static void
pickout(PGconn *conn, Oid lobjId, int start, int len)
{
    int         lobj_fd;
    char       *buf;
    int         nbytes;
    int         nread;

    lobj_fd = lo_open(conn, lobjId, INV_READ);
    if (lobj_fd < 0)
        fprintf(stderr, "cannot open large object %u", lobjId);

    lo_lseek(conn, lobj_fd, start, SEEK_SET);
    buf = malloc(len + 1);

    nread = 0;
    while (len - nread > 0)
    {
        nbytes = lo_read(conn, lobj_fd, buf, len - nread);
        buf[nbytes] = '\0';
        fprintf(stderr, ">>> %s", buf);
        nread += nbytes;
        if (nbytes <= 0)
            break;              /* no more data? */
    }
    free(buf);
    fprintf(stderr, "\n");
    lo_close(conn, lobj_fd);
}

static void
overwrite(PGconn *conn, Oid lobjId, int start, int len)
{
    int         lobj_fd;
    char       *buf;
    int         nbytes;
    int         nwritten;
    int         i;

    lobj_fd = lo_open(conn, lobjId, INV_WRITE);
    if (lobj_fd < 0)
        fprintf(stderr, "cannot open large object %u", lobjId);

    lo_lseek(conn, lobj_fd, start, SEEK_SET);
    buf = malloc(len + 1);

    for (i = 0; i < len; i++)
        buf[i] = 'X';
    buf[i] = '\0';

    nwritten = 0;
    while (len - nwritten > 0)
    {
        nbytes = lo_write(conn, lobj_fd, buf + nwritten, len - nwritten);
        nwritten += nbytes;
        if (nbytes <= 0)
        {
            fprintf(stderr, "\nWRITE FAILED!\n");
            break;
        }
    }
    free(buf);
    fprintf(stderr, "\n");
    lo_close(conn, lobj_fd);
}


/*
 * exportFile -
 *    export large object "lobjOid" to file "out_filename"
 *
 */
static void
exportFile(PGconn *conn, Oid lobjId, char *filename)
{
    int         lobj_fd;
    char        buf[BUFSIZE];
    int         nbytes,
                tmp;
    int         fd;

    /*
     * open the large object
     */
    lobj_fd = lo_open(conn, lobjId, INV_READ);
    if (lobj_fd < 0)
        fprintf(stderr, "cannot open large object %u", lobjId);

    /*
     * open the file to be written to
     */
    fd = open(filename, O_CREAT | O_WRONLY | O_TRUNC, 0666);
    if (fd < 0)
    {                           /* error */
        fprintf(stderr, "cannot open unix file\"%s\"",
                filename);
    }

    /*
     * read in from the inversion file and write to the Unix file
     */
    while ((nbytes = lo_read(conn, lobj_fd, buf, BUFSIZE)) > 0)
    {
        tmp = write(fd, buf, nbytes);
        if (tmp < nbytes)
        {
            fprintf(stderr, "error while writing \"%s\"",
                    filename);
        }
    }

    lo_close(conn, lobj_fd);
    close(fd);
}

static void
exit_nicely(PGconn *conn)
{
    PQfinish(conn);
    exit(1);
}

int
main(int argc, char **argv)
{
    char       *in_filename,
               *out_filename;
    char       *database;
    Oid         lobjOid;
    PGconn     *conn;
    PGresult   *res;

    if (argc != 4)
    {
        fprintf(stderr, "Usage: %s database_name in_filename out_filename\n",
                argv[0]);
        exit(1);
    }

    database = argv[1];
    in_filename = argv[2];
    out_filename = argv[3];

    /*
     * set up the connection
     */
    conn = PQsetdb(NULL, NULL, NULL, NULL, database);

    /* check to see that the backend connection was successfully made */
    if (PQstatus(conn) != CONNECTION_OK)
    {
        fprintf(stderr, "%s", PQerrorMessage(conn));
        exit_nicely(conn);
    }

    /* Set always-secure search path, so malicious users can't take control. */
    res = PQexec(conn,
                 "SELECT pg_catalog.set_config('search_path', '', false)");
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
    {
        fprintf(stderr, "SET failed: %s", PQerrorMessage(conn));
        PQclear(res);
        exit_nicely(conn);
    }
    PQclear(res);

    res = PQexec(conn, "begin");
    PQclear(res);
    printf("importing file \"%s\" ...\n", in_filename);
/*  lobjOid = importFile(conn, in_filename); */
    lobjOid = lo_import(conn, in_filename);
    if (lobjOid == 0)
        fprintf(stderr, "%s\n", PQerrorMessage(conn));
    else
    {
        printf("\tas large object %u.\n", lobjOid);

        printf("picking out bytes 1000-2000 of the large object\n");
        pickout(conn, lobjOid, 1000, 1000);

        printf("overwriting bytes 1000-2000 of the large object with X's\n");
        overwrite(conn, lobjOid, 1000, 1000);

        printf("exporting large object to file \"%s\" ...\n", out_filename);
/*      exportFile(conn, lobjOid, out_filename); */
        if (lo_export(conn, lobjOid, out_filename) < 0)
            fprintf(stderr, "%s\n", PQerrorMessage(conn));
    }

    res = PQexec(conn, "end");
    PQclear(res);
    PQfinish(conn);
    return 0;
}
]]>
</programlisting>
</example>

</sect1>
</chapter>
