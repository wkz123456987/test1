<!-- doc/src/sgml/mvcc.sgml -->

 <chapter id="mvcc">
<!-- pgdoc-cn_start sig_en=39257e4d86be5c7f7132e8c38436e434 sig_cn_org=None source=14.1 
  <title>Concurrency Control</title>
________________________________________________________-->
  <title>并发控制</title>
<!-- pgdoc-cn_end sig_en=39257e4d86be5c7f7132e8c38436e434 -->

<!-- pgdoc-cn_start sig_en=86e8309528da48aa2fb0dcef93bba615 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>concurrency</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>并发</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=86e8309528da48aa2fb0dcef93bba615 -->

<!-- pgdoc-cn_start sig_en=e8aad133193589449ea1dfbb5b2a477e sig_cn_org=None source=14.1 
  <para>
   This chapter describes the behavior of the
   <productname>PostgreSQL</productname> database system when two or
   more sessions try to access the same data at the same time.  The
   goals in that situation are to allow efficient access for all
   sessions while maintaining strict data integrity.  Every developer
   of database applications should be familiar with the topics covered
   in this chapter.
  </para>
________________________________________________________-->
  <para>
   本章描述<productname>PostgreSQL</productname>数据库系统在多个会话试图同时访问同一数据时的行为。 这种情况的目标是为所有会话提供高效的访问，同时还要维护严格的数据完整性。每个数据库应用开发人员都应该熟悉本章讨论的话题。
  </para>
<!-- pgdoc-cn_end sig_en=e8aad133193589449ea1dfbb5b2a477e -->

  <sect1 id="mvcc-intro">
<!-- pgdoc-cn_start sig_en=c2fcf93c611ba5f3baff759a5cc428dd sig_cn_org=None source=14.1 
   <title>Introduction</title>
________________________________________________________-->
   <title>介绍</title>
<!-- pgdoc-cn_end sig_en=c2fcf93c611ba5f3baff759a5cc428dd -->

<!-- pgdoc-cn_start sig_en=8119c881adc3b1ad6e8e1d587b6f0cb3 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>Multiversion Concurrency Control</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>多版本并发控制</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=8119c881adc3b1ad6e8e1d587b6f0cb3 -->

<!-- pgdoc-cn_start sig_en=513f10212cb91fe464e1e849982c2183 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>MVCC</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>MVCC</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=513f10212cb91fe464e1e849982c2183 -->

<!-- pgdoc-cn_start sig_en=1c322f4d343b2539fb57eed7eb382651 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>Serializable Snapshot Isolation</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>可序列化快照隔离</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=1c322f4d343b2539fb57eed7eb382651 -->

<!-- pgdoc-cn_start sig_en=b8761ee8ef536d5f5c035d31331d4334 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>SSI</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>SSI</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=b8761ee8ef536d5f5c035d31331d4334 -->

<!-- pgdoc-cn_start sig_en=c7c977844a39dbfe3d1a637661a43caa sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> provides a rich set of tools
    for developers to manage concurrent access to data.  Internally,
    data consistency is maintained by using a multiversion
    model (Multiversion Concurrency Control, <acronym>MVCC</acronym>).
    This means that each SQL statement sees
    a snapshot of data (a <firstterm>database version</firstterm>)
    as it was some
    time ago, regardless of the current state of the underlying data.
    This prevents statements from viewing inconsistent data produced
    by concurrent transactions performing updates on the same
    data rows, providing <firstterm>transaction isolation</firstterm>
    for each database session.  <acronym>MVCC</acronym>, by eschewing
    the locking methodologies of traditional database systems,
    minimizes lock contention in order to allow for reasonable
    performance in multiuser environments.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>为开发者提供了一组丰富的工具来管理对数据的并发访问。在内部，数据一致性通过使用一种多版本模型（多版本并发控制，<acronym>MVCC</acronym>）来维护。这就意味着每个 SQL 语句看到的都只是一小段时间之前的数据快照（一个<firstterm>数据库版本</firstterm>），而不管底层数据的当前状态。这样可以保护语句不会看到可能由其他在相同数据行上执行更新的并发事务造成的不一致数据，为每一个数据库会话提供<firstterm>事务隔离</firstterm>。<acronym>MVCC</acronym>避免了传统的数据库系统的锁定方法，将锁争夺最小化来允许多用户环境中的合理性能。
   </para>
<!-- pgdoc-cn_end sig_en=c7c977844a39dbfe3d1a637661a43caa -->

<!-- pgdoc-cn_start sig_en=affe366565ff849738e1a6008dc21bef sig_cn_org=None source=14.1 
   <para>
    The main advantage of using the <acronym>MVCC</acronym> model of
    concurrency control rather than locking is that in
    <acronym>MVCC</acronym> locks acquired for querying (reading) data
    do not conflict with locks acquired for writing data, and so
    reading never blocks writing and writing never blocks reading.
    <productname>PostgreSQL</productname> maintains this guarantee
    even when providing the strictest level of transaction
    isolation through the use of an innovative <firstterm>Serializable
    Snapshot Isolation</firstterm> (<acronym>SSI</acronym>) level.
   </para>
________________________________________________________-->
   <para>
    使用<acronym>MVCC</acronym>并发控制模型而不是锁定的主要优点是在<acronym>MVCC</acronym>中，对查询（读）数据的锁请求与写数据的锁请求不冲突，所以读不会阻塞写，而写也从不阻塞读。甚至在通过使用革新的<firstterm>可序列化快照隔离</firstterm>（<acronym>SSI</acronym>）级别提供最严格的事务隔离级别时，<productname>PostgreSQL</productname>也维持这个保证。
   </para>
<!-- pgdoc-cn_end sig_en=affe366565ff849738e1a6008dc21bef -->

<!-- pgdoc-cn_start sig_en=b3f9d7e44d817b4aa602f3acb9187088 sig_cn_org=None source=14.1 
   <para>
    Table- and row-level locking facilities are also available in
    <productname>PostgreSQL</productname> for applications which don't
    generally need full transaction isolation and prefer to explicitly
    manage particular points of conflict.  However, proper
    use of <acronym>MVCC</acronym> will generally provide better
    performance than locks.  In addition, application-defined advisory
    locks provide a mechanism for acquiring locks that are not tied
    to a single transaction.
   </para>
________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname>里也有表和行级别的锁功能，用于那些通常不需要完整事务隔离并且想要显式管理特定冲突点的应用。不过，恰当地使用<acronym>MVCC</acronym>通常会提供比锁更好的性能。另外，由应用定义的咨询锁提供了一个获得不依赖于单一事务的锁的机制。
   </para>
<!-- pgdoc-cn_end sig_en=b3f9d7e44d817b4aa602f3acb9187088 -->
  </sect1>

  <sect1 id="transaction-iso">
<!-- pgdoc-cn_start sig_en=77d4331124cf8e800f7cc3f8a73debf9 sig_cn_org=None source=14.1 
   <title>Transaction Isolation</title>
________________________________________________________-->
   <title>事务隔离</title>
<!-- pgdoc-cn_end sig_en=77d4331124cf8e800f7cc3f8a73debf9 -->

<!-- pgdoc-cn_start sig_en=187f354111615071050282a444357ea2 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>transaction isolation</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>事务隔离</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=187f354111615071050282a444357ea2 -->

<!-- pgdoc-cn_start sig_en=95f3e35ed98f4a1c040a94c2cf14a05c sig_cn_org=None source=14.1 
   <para>
    The <acronym>SQL</acronym> standard defines four levels of
    transaction isolation.  The most strict is Serializable,
    which is defined by the standard in a paragraph which says that any
    concurrent execution of a set of Serializable transactions is guaranteed
    to produce the same effect as running them one at a time in some order.
    The other three levels are defined in terms of phenomena, resulting from
    interaction between concurrent transactions, which must not occur at
    each level.  The standard notes that due to the definition of
    Serializable, none of these phenomena are possible at that level.  (This
    is hardly surprising -&minus; if the effect of the transactions must be
    consistent with having been run one at a time, how could you see any
    phenomena caused by interactions?)
   </para>
________________________________________________________-->
   <para>
    <acronym>SQL</acronym>标准定义了四种隔离级别。最严格的是可序列化，在标准中用了一整段来定义它，其中说到一组可序列化事务的任意并发执行被保证效果和以某种顺序一个一个执行这些事务一样。其他三种级别使用并发事务之间交互产生的现象来定义，每一个级别中都要求必须不出现一种现象。注意由于可序列化的定义，在该级别上这些现象都不可能发生（这并不令人惊讶--如果事务的效果与每个时刻只运行一个的相同，你怎么可能看见由于交互产生的现象？）。
   </para>
<!-- pgdoc-cn_end sig_en=95f3e35ed98f4a1c040a94c2cf14a05c -->

<!-- pgdoc-cn_start sig_en=97de4c94bc7ce8c3e227194f938771f9 sig_cn_org=499669c0f58195ef3b7bdaea32fd1868 source=15.7 
   <para>
    The phenomena which are prohibited at various levels are:

    <variablelist>
     <varlistentry>
      <term>
       dirty read
       <indexterm><primary>dirty read</primary></indexterm>
      </term>
      <listitem>
       <para>
        A transaction reads data written by a concurrent uncommitted transaction.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       nonrepeatable read
       <indexterm><primary>nonrepeatable read</primary></indexterm>
      </term>
      <listitem>
       <para>
        A transaction re-reads data it has previously read and finds that data
        has been modified by another transaction (that committed since the
        initial read).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       phantom read
       <indexterm><primary>phantom read</primary></indexterm>
      </term>
      <listitem>
       <para>
        A transaction re-executes a query returning a set of rows that satisfy a
        search condition and finds that the set of rows satisfying the condition
        has changed due to another recently-committed transaction.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       serialization anomaly
       <indexterm><primary>serialization anomaly</primary></indexterm>
      </term>
      <listitem>
       <para>
        The result of successfully committing a group of transactions
        is inconsistent with all possible orderings of running those
        transactions one at a time.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    在各个级别上被禁止的现象包括：

    <variablelist>
     <varlistentry>
      <term>
       脏读
       <indexterm><primary>脏读</primary></indexterm>
      </term>
      <listitem>
       <para>
        一个事务读取了由另一个并发未提交事务写入的数据。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       不可重复读
       <indexterm><primary>不可重复读</primary></indexterm>
      </term>
      <listitem>
       <para>
        一个事务重新读取了之前读取过的数据，发现数据已被另一个事务修改（自初始读取以来已提交）。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       幻读
       <indexterm><primary>幻读</primary></indexterm>
      </term>
      <listitem>
       <para>
        一个事务重新执行一个返回满足搜索条件的一组行的查询，并发现由于另一个最近提交的事务而导致满足条件的行集发生了变化。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       序列化异常
       <indexterm><primary>序列化异常</primary></indexterm>
      </term>
      <listitem>
       <para>
        成功提交一组事务的结果与依次运行这些事务的所有可能顺序不一致。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=97de4c94bc7ce8c3e227194f938771f9 -->

<!-- pgdoc-cn_start sig_en=26687120a033cdcc6275d8d30e385b37 sig_cn_org=None source=14.1 
   <para>
    <indexterm>
     <primary>transaction isolation level</primary>
    </indexterm>
    The SQL standard and PostgreSQL-implemented transaction isolation levels
    are described in <xref linkend="mvcc-isolevel-table"/>.
   </para>
________________________________________________________-->
   <para>
    <indexterm>
     <primary>事务隔离级别</primary>
    </indexterm>
    SQL 标准和 PostgreSQL 实现的事务隔离级别在
    <xref linkend="mvcc-isolevel-table"/>中描述。
   </para>
<!-- pgdoc-cn_end sig_en=26687120a033cdcc6275d8d30e385b37 -->

    <table tocentry="1" id="mvcc-isolevel-table">
<!-- pgdoc-cn_start sig_en=dc8db93b6323f69d9dca75da126b8571 sig_cn_org=None source=14.1 
     <title>Transaction Isolation Levels</title>
________________________________________________________-->
     <title>事务隔离级别</title>
<!-- pgdoc-cn_end sig_en=dc8db93b6323f69d9dca75da126b8571 -->
     <tgroup cols="5">
      <thead>
<!-- pgdoc-cn_start sig_en=7f02529bc02c5c0edf18de16683b40bb sig_cn_org=None source=14.1 
       <row>
        <entry>
         Isolation Level
        </entry>
        <entry>
         Dirty Read
        </entry>
        <entry>
         Nonrepeatable Read
        </entry>
        <entry>
         Phantom Read
        </entry>
        <entry>
         Serialization Anomaly
        </entry>
       </row>
________________________________________________________-->
       <row>
        <entry>
         隔离级别
        </entry>
        <entry>
         脏读
        </entry>
        <entry>
         不可重复读
        </entry>
        <entry>
         幻读
        </entry>
        <entry>
         序列化异常
        </entry>
       </row>
<!-- pgdoc-cn_end sig_en=7f02529bc02c5c0edf18de16683b40bb -->
      </thead>
      <tbody>
<!-- pgdoc-cn_start sig_en=facd3ad328bfb3dfee056aa798214cc5 sig_cn_org=None source=14.1 
       <row>
        <entry>
         Read uncommitted
        </entry>
        <entry>
         Allowed, but not in PG
        </entry>
        <entry>
         Possible
        </entry>
        <entry>
         Possible
        </entry>
        <entry>
         Possible
        </entry>
       </row>
________________________________________________________-->
       <row>
        <entry>
         读未提交
        </entry>
        <entry>
         允许，但不在 PG 中
        </entry>
        <entry>
         可能
        </entry>
        <entry>
         可能
        </entry>
        <entry>
         可能
        </entry>
       </row>
<!-- pgdoc-cn_end sig_en=facd3ad328bfb3dfee056aa798214cc5 -->

<!-- pgdoc-cn_start sig_en=fc3de4431b9e4afd0deb36d3fadca3ce sig_cn_org=None source=14.1 
       <row>
        <entry>
         Read committed
        </entry>
        <entry>
         Not possible
        </entry>
        <entry>
         Possible
        </entry>
        <entry>
         Possible
        </entry>
        <entry>
         Possible
        </entry>
       </row>
________________________________________________________-->
       <row>
        <entry>
         读已提交
        </entry>
        <entry>
         不可能
        </entry>
        <entry>
         可能
        </entry>
        <entry>
         可能
        </entry>
        <entry>
         可能
        </entry>
       </row>
<!-- pgdoc-cn_end sig_en=fc3de4431b9e4afd0deb36d3fadca3ce -->

<!-- pgdoc-cn_start sig_en=dfb660f727eb79c1a74097dc9d71383e sig_cn_org=None source=14.1 
       <row>
        <entry>
         Repeatable read
        </entry>
        <entry>
         Not possible
        </entry>
        <entry>
         Not possible
        </entry>
        <entry>
         Allowed, but not in PG
        </entry>
        <entry>
         Possible
        </entry>
       </row>
________________________________________________________-->
       <row>
        <entry>
         可重复读
        </entry>
        <entry>
         不可能
        </entry>
        <entry>
         不可能
        </entry>
        <entry>
         允许，但不在 PG 中
        </entry>
        <entry>
         可能
        </entry>
       </row>
<!-- pgdoc-cn_end sig_en=dfb660f727eb79c1a74097dc9d71383e -->

<!-- pgdoc-cn_start sig_en=c1292789eeab2c097cf075cccf3848a1 sig_cn_org=None source=14.1 
       <row>
        <entry>
         Serializable
        </entry>
        <entry>
         Not possible
        </entry>
        <entry>
         Not possible
        </entry>
        <entry>
         Not possible
        </entry>
        <entry>
         Not possible
        </entry>
       </row>
________________________________________________________-->
       <row>
        <entry>
         可序列化
        </entry>
        <entry>
         不可能
        </entry>
        <entry>
         不可能
        </entry>
        <entry>
         不可能
        </entry>
        <entry>
         不可能
        </entry>
       </row>
<!-- pgdoc-cn_end sig_en=c1292789eeab2c097cf075cccf3848a1 -->
      </tbody>
     </tgroup>
    </table>

<!-- pgdoc-cn_start sig_en=407f42461d63750b9b4c2cecd984683d sig_cn_org=None source=14.1 
   <para>
    In <productname>PostgreSQL</productname>, you can request any of
    the four standard transaction isolation levels, but internally only
    three distinct isolation levels are implemented, i.e., PostgreSQL's
    Read Uncommitted mode behaves like Read Committed.  This is because
    it is the only sensible way to map the standard isolation levels to
    PostgreSQL's multiversion concurrency control architecture.
   </para>
________________________________________________________-->
   <para>
    在<productname>PostgreSQL</productname>中，你可以请求四种标准事务隔离级别中的任意一种，但是内部只实现了三种不同的隔离级别，即 PostgreSQL 的读未提交模式的行为和读已提交相同。这是因为把标准隔离级别映射到 PostgreSQL 的多版本并发控制架构的唯一合理的方法。
   </para>
<!-- pgdoc-cn_end sig_en=407f42461d63750b9b4c2cecd984683d -->

<!-- pgdoc-cn_start sig_en=ca190de9bdb17d9850d5ad7b2d293867 sig_cn_org=8f1d2f79e145cf703c8856a54b70ee2b source=15.7 
   <para>
    The table also shows that PostgreSQL's Repeatable Read implementation
    does not allow phantom reads.  This is acceptable under the SQL
    standard because the standard specifies which anomalies must
    <emphasis>not</emphasis> occur at certain isolation levels;  higher
    guarantees are acceptable.
    The behavior of the available isolation levels is detailed in the
    following subsections.
   </para>
________________________________________________________-->
   <para>
    这个表还显示，PostgreSQL的可重复读实现不允许幻读。这在SQL标准下是可以接受的，因为标准规定了在某些隔离级别下<emphasis>不得</emphasis>发生哪些异常；更高的保证是可以接受的。
    可用隔离级别的行为在以下子章节中详细说明。
</para>
<!-- pgdoc-cn_end sig_en=ca190de9bdb17d9850d5ad7b2d293867 -->

<!-- pgdoc-cn_start sig_en=eb381b590aaadd508403ddc20ff3ac04 sig_cn_org=None source=14.1 
   <para>
    To set the transaction isolation level of a transaction, use the
    command <xref linkend="sql-set-transaction"/>.
   </para>
________________________________________________________-->
   <para>
    要设置一个事务的事务隔离级别，使用<xref linkend="sql-set-transaction"/>命令。
   </para>
<!-- pgdoc-cn_end sig_en=eb381b590aaadd508403ddc20ff3ac04 -->

   <important>
<!-- pgdoc-cn_start sig_en=f8b8297163c358408b15353f97f642e9 sig_cn_org=None source=14.1 
     <para>
       Some <productname>PostgreSQL</productname> data types and functions have
       special rules regarding transactional behavior.  In particular, changes
       made to a sequence (and therefore the counter of a
       column declared using <type>serial</type>) are immediately visible
       to all other transactions and are not rolled back if the transaction
       that made the changes aborts.  See <xref linkend="functions-sequence"/>
       and <xref linkend="datatype-serial"/>.
     </para>
________________________________________________________-->
     <para>
       某些<productname>PostgreSQL</productname>数据类型和函数关于事务的行为有特殊的规则。特别是，对一个序列的修改（以及用<type>serial</type>声明的一列的计数器）是立刻对所有其他事务可见的，并且在作出该修改的事务中断时也不会被回滚。见<xref linkend="functions-sequence"/>和<xref linkend="datatype-serial"/>。
     </para>
<!-- pgdoc-cn_end sig_en=f8b8297163c358408b15353f97f642e9 -->
   </important>

  <sect2 id="xact-read-committed">
<!-- pgdoc-cn_start sig_en=e73ab8bc9030435e8e453f1eae867fcf sig_cn_org=None source=14.1 
   <title>Read Committed Isolation Level</title>
________________________________________________________-->
   <title>读已提交隔离级别</title>
<!-- pgdoc-cn_end sig_en=e73ab8bc9030435e8e453f1eae867fcf -->

<!-- pgdoc-cn_start sig_en=8a011827e866e971a9a0b034a9e8abb6 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>transaction isolation level</primary>
    <secondary>read committed</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>事务隔离级别</primary>
    <secondary>读已提交</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=8a011827e866e971a9a0b034a9e8abb6 -->

<!-- pgdoc-cn_start sig_en=59da1a090bf9cacbc5b898ca90f89540 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>read committed</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>读已提交</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=59da1a090bf9cacbc5b898ca90f89540 -->

<!-- pgdoc-cn_start sig_en=3c84264e9839818cb39a95903f9dba5b sig_cn_org=None source=14.1 
   <para>
    <firstterm>Read Committed</firstterm> is the default isolation
    level in <productname>PostgreSQL</productname>.  When a transaction
    uses this isolation level, a <command>SELECT</command> query
    (without a <literal>FOR UPDATE/SHARE</literal> clause) sees only data
    committed before the query began; it never sees either uncommitted
    data or changes committed during query execution by concurrent
    transactions.  In effect, a <command>SELECT</command> query sees
    a snapshot of the database as of the instant the query begins to
    run.   However, <command>SELECT</command> does see the effects
    of previous updates executed within its own transaction, even
    though they are not yet committed.  Also note that two successive
    <command>SELECT</command> commands can see different data, even
    though they are within a single transaction, if other transactions
    commit changes after the first <command>SELECT</command> starts and
    before the second <command>SELECT</command> starts.
   </para>
________________________________________________________-->
   <para>
    <firstterm>读已提交</firstterm>是<productname>PostgreSQL</productname>中的默认隔离级别。 当一个事务运行使用这个隔离级别时， 一个查询（没有<literal>FOR UPDATE/SHARE</literal>子句）只能看到查询开始之前已经被提交的数据， 而无法看到未提交的数据或在查询执行期间其它事务提交的数据。实际上，<command>SELECT</command>查询看到的是一个在查询开始运行的瞬间该数据库的一个快照。不过<command>SELECT</command>可以看见在它自身事务中之前执行的更新的效果，即使它们还没有被提交。还要注意的是，即使在同一个事务里两个相邻的<command>SELECT</command>命令可能看到不同的数据， 因为其它事务可能会在第一个<command>SELECT</command>开始和第二个<command>SELECT</command>开始之间提交。
   </para>
<!-- pgdoc-cn_end sig_en=3c84264e9839818cb39a95903f9dba5b -->

<!-- pgdoc-cn_start sig_en=ca43b243a7e8016dcfcc6c95ffc7c83d sig_cn_org=None source=14.1 
   <para>
    <command>UPDATE</command>, <command>DELETE</command>, <command>SELECT
    FOR UPDATE</command>, and <command>SELECT FOR SHARE</command> commands
    behave the same as <command>SELECT</command>
    in terms of searching for target rows: they will only find target rows
    that were committed as of the command start time.  However, such a target
    row might have already been updated (or deleted or locked) by
    another concurrent transaction by the time it is found.  In this case, the
    would-be updater will wait for the first updating transaction to commit or
    roll back (if it is still in progress).  If the first updater rolls back,
    then its effects are negated and the second updater can proceed with
    updating the originally found row.  If the first updater commits, the
    second updater will ignore the row if the first updater deleted it,
    otherwise it will attempt to apply its operation to the updated version of
    the row.  The search condition of the command (the <literal>WHERE</literal> clause) is
    re-evaluated to see if the updated version of the row still matches the
    search condition.  If so, the second updater proceeds with its operation
    using the updated version of the row.  In the case of
    <command>SELECT FOR UPDATE</command> and <command>SELECT FOR
    SHARE</command>, this means it is the updated version of the row that is
    locked and returned to the client.
   </para>
________________________________________________________-->
   <para>
    <command>UPDATE</command>、<command>DELETE</command>、<command>SELECT FOR UPDATE</command>和<command>SELECT FOR SHARE</command>命令在搜索目标行时的行为和<command>SELECT</command>一样： 它们将只找到在命令开始时已经被提交的行。 不过，在被找到时，这样的目标行可能已经被其它并发事务更新（或删除或锁住）。在这种情况下， 即将进行的更新将等待第一个更新事务提交或者回滚（如果它还在进行中）。 如果第一个更新事务回滚，那么它的作用将被忽略并且第二个事务可以继续更新最初发现的行。 如果第一个更新事务提交，若该行被第一个更新者删除，则第二个更新事务将忽略该行，否则第二个更新者将试图在该行的已被更新的版本上应用它的操作。该命令的搜索条件（<literal>WHERE</literal>子句）将被重新计算来看该行被更新的版本是否仍然符合搜索条件。如果符合，则第二个更新者使用该行的已更新版本继续其操作。在<command>SELECT FOR UPDATE</command>和<command>SELECT FOR SHARE</command>的情况下，这意味着把该行的已更新版本锁住并返回给客户端。
   </para>
<!-- pgdoc-cn_end sig_en=ca43b243a7e8016dcfcc6c95ffc7c83d -->

<!-- pgdoc-cn_start sig_en=166cbbdbffe1a85d41a0eb0b6463f558 sig_cn_org=ee79420583922b00699c5f96cb3b703b source=15.7 
   <para>
    <command>INSERT</command> with an <literal>ON CONFLICT DO UPDATE</literal> clause
    behaves similarly. In Read Committed mode, each row proposed for insertion
    will either insert or update. Unless there are unrelated errors, one of
    those two outcomes is guaranteed.  If a conflict originates in another
    transaction whose effects are not yet visible to the <command>INSERT</command>,
    the <command>UPDATE</command> clause will affect that row,
    even though possibly <emphasis>no</emphasis> version of that row is
    conventionally visible to the command.
   </para>
________________________________________________________-->
   <para>
    <command>INSERT</command>带有<literal>ON CONFLICT DO UPDATE</literal>子句的行为类似。
    在读取提交模式下，每个提议插入的行将插入或更新。除非存在不相关的错误，否则两者中的一个是有保证的。
    如果冲突源自另一个事务，其效果对<command>INSERT</command>尚不可见，
    则<command>UPDATE</command>子句将影响该行，即使可能<emphasis>没有</emphasis>该行的任何版本
    传统上对命令可见。
</para>
<!-- pgdoc-cn_end sig_en=166cbbdbffe1a85d41a0eb0b6463f558 -->

<!-- pgdoc-cn_start sig_en=060e29958336a63cac56eaa71bab7261 sig_cn_org=None source=14.1 
   <para>
    <command>INSERT</command> with an <literal>ON CONFLICT DO
    NOTHING</literal> clause may have insertion not proceed for a row due to
    the outcome of another transaction whose effects are not visible
    to the <command>INSERT</command> snapshot.  Again, this is only
    the case in Read Committed mode.
   </para>
________________________________________________________-->
   <para>
    带有<literal>ON CONFLICT DO NOTHING</literal>子句的
    <command>INSERT</command>有可能因为另一个效果对
    <command>INSERT</command>快照不可见的事务的结果无法让插入进行
    下去。再一次，这只是读已提交模式中的情况。
   </para>
<!-- pgdoc-cn_end sig_en=060e29958336a63cac56eaa71bab7261 -->

<!-- pgdoc-cn_start sig_en=04b4c0901a425816e48c53ef29eefc9b sig_cn_org=584179a324ac542960bb2c62a40d24ed source=15.7 
   <para>
    <command>MERGE</command> allows the user to specify various
    combinations of <command>INSERT</command>, <command>UPDATE</command>
    and <command>DELETE</command> subcommands. A <command>MERGE</command>
    command with both <command>INSERT</command> and <command>UPDATE</command>
    subcommands looks similar to <command>INSERT</command> with an
    <literal>ON CONFLICT DO UPDATE</literal> clause but does not
    guarantee that either <command>INSERT</command> or
    <command>UPDATE</command> will occur.
    If <command>MERGE</command> attempts an <command>UPDATE</command> or
    <command>DELETE</command> and the row is concurrently updated but
    the join condition still passes for the current target and the
    current source tuple, then <command>MERGE</command> will behave
    the same as the <command>UPDATE</command> or
    <command>DELETE</command> commands and perform its action on the
    updated version of the row.  However, because <command>MERGE</command>
    can specify several actions and they can be conditional, the
    conditions for each action are re-evaluated on the updated version of
    the row, starting from the first action, even if the action that had
    originally matched appears later in the list of actions.
    On the other hand, if the row is concurrently updated or deleted so
    that the join condition fails, then <command>MERGE</command> will
    evaluate the condition's <literal>NOT MATCHED</literal> actions next,
    and execute the first one that succeeds.
    If <command>MERGE</command> attempts an <command>INSERT</command>
    and a unique index is present and a duplicate row is concurrently
    inserted, then a uniqueness violation error is raised;
    <command>MERGE</command> does not attempt to avoid such
    errors by restarting evaluation of <literal>MATCHED</literal>
    conditions.
   </para>
________________________________________________________-->
   <para>
    <command>MERGE</command>允许用户指定各种<command>INSERT</command>、<command>UPDATE</command>和<command>DELETE</command>子命令的组合。
    一个同时包含<command>INSERT</command>和<command>UPDATE</command>子命令的<command>MERGE</command>命令看起来类似于带有<literal>ON CONFLICT DO UPDATE</literal>子句的<command>INSERT</command>，
    但不能保证<command>INSERT</command>或<command>UPDATE</command>中的任何一个会发生。
    如果<command>MERGE</command>尝试<command>UPDATE</command>或<command>DELETE</command>，并且行正在并发更新，但连接条件仍然通过当前目标和当前源元组，
    那么<command>MERGE</command>将表现得与<command>UPDATE</command>或<command>DELETE</command>命令相同，并对行的更新版本执行其操作。
    然而，由于<command>MERGE</command>可以指定多个操作，并且它们可以是有条件的，因此每个操作的条件都将在行的更新版本上重新评估，从第一个操作开始，
    即使最初匹配的操作出现在操作列表中的后面。
    另一方面，如果行被并发更新或删除，导致连接条件失败，那么<command>MERGE</command>将接下来评估条件的<literal>NOT MATCHED</literal>操作，并执行第一个成功的操作。
    如果<command>MERGE</command>尝试<command>INSERT</command>，并且存在唯一索引并且同时插入了重复行，则会引发唯一性违规错误；
    <command>MERGE</command>不会尝试通过重新启动<literal>MATCHED</literal>条件的评估来避免这种错误。
</para>
<!-- pgdoc-cn_end sig_en=04b4c0901a425816e48c53ef29eefc9b -->

<!-- pgdoc-cn_start sig_en=bdec6d5cb9a608602e5dcfd5589980cd sig_cn_org=None source=14.1 
   <para>
    Because of the above rules, it is possible for an updating command to see
    an inconsistent snapshot: it can see the effects of concurrent updating
    commands on the same rows it is trying to update, but it
    does not see effects of those commands on other rows in the database.
    This behavior makes Read Committed mode unsuitable for commands that
    involve complex search conditions; however, it is just right for simpler
    cases.  For example, consider updating bank balances with transactions
    like:

<screen>
BEGIN;
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 12345;
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 7534;
COMMIT;
</screen>

    If two such transactions concurrently try to change the balance of account
    12345, we clearly want the second transaction to start with the updated
    version of the account's row.  Because each command is affecting only a
    predetermined row, letting it see the updated version of the row does
    not create any troublesome inconsistency.
   </para>
________________________________________________________-->
   <para>
    因为上面的规则，正在更新的命令可能会看到一个不一致的快照： 它们可以看到并发更新命令在它尝试更新的相同行上的作用，但是却看不到那些命令对数据库里其它行的作用。 这样的行为令读已提交模式不适合用于涉及复杂搜索条件的命令。不过，它对于更简单的情况是正确的。 例如，考虑用这样的命令更新银行余额：

<screen>
BEGIN;
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 12345;
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 7534;
COMMIT;
</screen>

    如果两个这样的事务同时尝试修改帐号 12345 的余额，那我们很明显希望第二个事务从账户行的已更新版本上开始工作。 因为每个命令只影响一个已经决定了的行，让它看到行的已更新版本不会导致任何麻烦的不一致性。
   </para>
<!-- pgdoc-cn_end sig_en=bdec6d5cb9a608602e5dcfd5589980cd -->

<!-- pgdoc-cn_start sig_en=ec98e3cad60fee0835751221f8823f9c sig_cn_org=None source=14.1 
   <para>
    More complex usage can produce undesirable results in Read Committed
    mode.  For example, consider a <command>DELETE</command> command
    operating on data that is being both added and removed from its
    restriction criteria by another command, e.g., assume
    <literal>website</literal> is a two-row table with
    <literal>website.hits</literal> equaling <literal>9</literal> and
    <literal>10</literal>:

<screen>
BEGIN;
UPDATE website SET hits = hits + 1;
-&minus; run from another session:  DELETE FROM website WHERE hits = 10;
COMMIT;
</screen>

    The <command>DELETE</command> will have no effect even though
    there is a <literal>website.hits = 10</literal> row before and
    after the <command>UPDATE</command>. This occurs because the
    pre-update row value <literal>9</literal> is skipped, and when the
    <command>UPDATE</command> completes and <command>DELETE</command>
    obtains a lock, the new row value is no longer <literal>10</literal> but
    <literal>11</literal>, which no longer matches the criteria.
   </para>
________________________________________________________-->
   <para>
    在读已提交模式中，更复杂的使用可能产生不符合需要的结果。例如： 考虑一个在数据上操作的<command>DELETE</command>命令，它操作的数据正被另一个命令从它的限制条件中移除或者加入，例如，假定<literal>website</literal>是一个两行的表，两行的<literal>website.hits</literal>等于<literal>9</literal>和<literal>10</literal>：

<screen>
BEGIN;
UPDATE website SET hits = hits + 1;
-- run from another session:  DELETE FROM website WHERE hits = 10;
COMMIT;
</screen>

    即便在<command>UPDATE</command>之前有一个<literal>website.hits = 10</literal>的行，<command>DELETE</command>将不会产生效果。这是因为更新之前的行值<literal>9</literal>被跳过，并且当<command>UPDATE</command>完成并且<command>DELETE</command>获得一个锁，新行值不再是<literal>10</literal>而是<literal>11</literal>，这再也不匹配条件了。
   </para>
<!-- pgdoc-cn_end sig_en=ec98e3cad60fee0835751221f8823f9c -->

<!-- pgdoc-cn_start sig_en=10890a2da9451620077c450c9664ae74 sig_cn_org=None source=14.1 
   <para>
    Because Read Committed mode starts each command with a new snapshot
    that includes all transactions committed up to that instant,
    subsequent commands in the same transaction will see the effects
    of the committed concurrent transaction in any case.  The point
    at issue above is whether or not a <emphasis>single</emphasis> command
    sees an absolutely consistent view of the database.
   </para>
________________________________________________________-->
   <para>
    因为在读已提交模式中，每个命令都是从一个新的快照开始的，而这个快照包含在该时刻已提交的事务， 因此同一事务中的后续命令将看到任何已提交的并行事务的效果。以上的焦点在于<emphasis>单个</emphasis>命令是否看到数据库的绝对一致的视图。
   </para>
<!-- pgdoc-cn_end sig_en=10890a2da9451620077c450c9664ae74 -->

<!-- pgdoc-cn_start sig_en=8f2c6d80441a0bf92e80ff5367b2cf40 sig_cn_org=None source=14.1 
   <para>
    The partial transaction isolation provided by Read Committed mode
    is adequate for many applications, and this mode is fast and simple
    to use;  however, it is not sufficient for all cases.  Applications
    that do complex queries and updates might require a more rigorously
    consistent view of the database than Read Committed mode provides.
   </para>
________________________________________________________-->
   <para>
    读已提交模式提供的部分事务隔离对于许多应用而言是足够的，并且这个模式速度快并且使用简单。 不过，它不是对于所有情况都够用。做复杂查询和更新的应用可能需要比读已提交模式提供的更严格一致的数据库视图。
   </para>
<!-- pgdoc-cn_end sig_en=8f2c6d80441a0bf92e80ff5367b2cf40 -->
  </sect2>

  <sect2 id="xact-repeatable-read">
<!-- pgdoc-cn_start sig_en=1f6663261e439c9b545b3bfe41fbc65d sig_cn_org=None source=14.1 
   <title>Repeatable Read Isolation Level</title>
________________________________________________________-->
   <title>可重复读隔离级别</title>
<!-- pgdoc-cn_end sig_en=1f6663261e439c9b545b3bfe41fbc65d -->

<!-- pgdoc-cn_start sig_en=3c096bb036449b0c84458f715431d754 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>transaction isolation level</primary>
    <secondary>repeatable read</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>事务隔离级别</primary>
    <secondary>可重复读</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=3c096bb036449b0c84458f715431d754 -->

<!-- pgdoc-cn_start sig_en=ab3b5e1f21a5941daa1483b538da519b sig_cn_org=None source=14.1 
   <indexterm>
    <primary>repeatable read</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>重复读</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=ab3b5e1f21a5941daa1483b538da519b -->

<!-- pgdoc-cn_start sig_en=6c21cdb1718a8676ee0139064c64fd55 sig_cn_org=None source=14.1 
   <para>
    The <firstterm>Repeatable Read</firstterm> isolation level only sees
    data committed before the transaction began; it never sees either
    uncommitted data or changes committed during transaction execution
    by concurrent transactions.  (However, the query does see the
    effects of previous updates executed within its own transaction,
    even though they are not yet committed.)  This is a stronger
    guarantee than is required by the <acronym>SQL</acronym> standard
    for this isolation level, and prevents all of the phenomena described
    in <xref linkend="mvcc-isolevel-table"/> except for serialization
    anomalies.  As mentioned above, this is
    specifically allowed by the standard, which only describes the
    <emphasis>minimum</emphasis> protections each isolation level must
    provide.
   </para>
________________________________________________________-->
   <para>
    <firstterm>可重复读</firstterm>隔离级别只看到在事务开始之前被提交的数据；它从来看不到未提交的数据或者并行事务在本事务执行期间提交的修改（不过，查询能够看见在它的事务中之前执行的更新，即使它们还没有被提交）。这是比<acronym>SQL</acronym>标准对此隔离级别所要求的更强的保证，并且阻止<xref linkend="mvcc-isolevel-table"/>中描述的除了序列化异常之外的所有现象。如上面所提到的，这是标准特别允许的，标准只描述了每种隔离级别必须提供的<emphasis>最小</emphasis>保护。
   </para>
<!-- pgdoc-cn_end sig_en=6c21cdb1718a8676ee0139064c64fd55 -->

<!-- pgdoc-cn_start sig_en=09fba19f2fc307179d627b69c86eefe2 sig_cn_org=None source=14.1 
   <para>
    This level is different from Read Committed in that a query in a
    repeatable read transaction sees a snapshot as of the start of the
    first non-transaction-control statement in the
    <emphasis>transaction</emphasis>, not as of the start
    of the current statement within the transaction.  Thus, successive
    <command>SELECT</command> commands within a <emphasis>single</emphasis>
    transaction see the same data, i.e., they do not see changes made by
    other transactions that committed after their own transaction started.
   </para>
________________________________________________________-->
   <para>
    这个级别与读已提交不同之处在于，一个可重复读事务中的查询可以看见在<emphasis>事务</emphasis>中第一个非事务控制语句开始时的一个快照，而不是事务中当前语句开始时的快照。因此，在一个<emphasis>单一</emphasis>事务中的后续<command>SELECT</command>命令看到的是相同的数据，即它们看不到其他事务在本事务启动后提交的修改。
   </para>
<!-- pgdoc-cn_end sig_en=09fba19f2fc307179d627b69c86eefe2 -->

<!-- pgdoc-cn_start sig_en=ffad4aaf288992e03bffae761ca0057f sig_cn_org=None source=14.1 
   <para>
    Applications using this level must be prepared to retry transactions
    due to serialization failures.
   </para>
________________________________________________________-->
   <para>
    使用这个级别的应用必须准备好由于序列化失败而重试事务。
   </para>
<!-- pgdoc-cn_end sig_en=ffad4aaf288992e03bffae761ca0057f -->

<!-- pgdoc-cn_start sig_en=7de24a673979237586fd8604910cdc84 sig_cn_org=6c184c99d4da23d892ec6b9a551077d8 source=15.7 
   <para>
    <command>UPDATE</command>, <command>DELETE</command>,
    <command>MERGE</command>, <command>SELECT FOR UPDATE</command>,
    and <command>SELECT FOR SHARE</command> commands
    behave the same as <command>SELECT</command>
    in terms of searching for target rows: they will only find target rows
    that were committed as of the transaction start time.  However, such a
    target row might have already been updated (or deleted or locked) by
    another concurrent transaction by the time it is found.  In this case, the
    repeatable read transaction will wait for the first updating transaction to commit or
    roll back (if it is still in progress).  If the first updater rolls back,
    then its effects are negated and the repeatable read transaction can proceed
    with updating the originally found row.  But if the first updater commits
    (and actually updated or deleted the row, not just locked it)
    then the repeatable read transaction will be rolled back with the message

<screen>
ERROR:  could not serialize access due to concurrent update
</screen>

    because a repeatable read transaction cannot modify or lock rows changed by
    other transactions after the repeatable read transaction began.
   </para>
________________________________________________________-->
   <para>
    <command>UPDATE</command>，<command>DELETE</command>，
    <command>MERGE</command>，<command>SELECT FOR UPDATE</command>，
    和<command>SELECT FOR SHARE</command>命令
    在搜索目标行方面与<command>SELECT</command>相同：
    它们只会找到在事务开始时已提交的目标行。
    然而，这样的目标行可能在找到时已被另一个并发事务更新（或删除或锁定）。
    在这种情况下，可重复读事务将等待第一个更新事务提交或回滚（如果仍在进行）。
    如果第一个更新者回滚，则其效果将被取消，可重复读事务可以继续更新最初找到的行。
    但如果第一个更新者提交了（并实际更新或删除了行，而不仅仅是锁定了它），
    那么可重复读事务将被回滚，并显示以下消息：

<screen>
ERROR:  could not serialize access due to concurrent update
</screen>

    因为可重复读事务不能修改或锁定在可重复读事务开始后被其他事务更改的行。
</para>
<!-- pgdoc-cn_end sig_en=7de24a673979237586fd8604910cdc84 -->

<!-- pgdoc-cn_start sig_en=c7e01bacd74b6da5d1a8dc37a31eaa6b sig_cn_org=None source=14.1 
   <para>
    When an application receives this error message, it should abort
    the current transaction and retry the whole transaction from
    the beginning.  The second time through, the transaction will see the
    previously-committed change as part of its initial view of the database,
    so there is no logical conflict in using the new version of the row
    as the starting point for the new transaction's update.
   </para>
________________________________________________________-->
   <para>
    当一个应用接收到这个错误消息，它应该中断当前事务并且从开头重试整个事务。在第二次执行中，该事务将见到作为其初始数据库视图一部分的之前提交的改变，这样在使用行的新版本作为新事务更新的起点时就不会有逻辑冲突。
   </para>
<!-- pgdoc-cn_end sig_en=c7e01bacd74b6da5d1a8dc37a31eaa6b -->

<!-- pgdoc-cn_start sig_en=7302120239ff1e507011d875deeb240d sig_cn_org=None source=14.1 
   <para>
    Note that only updating transactions might need to be retried; read-only
    transactions will never have serialization conflicts.
   </para>
________________________________________________________-->
   <para>
    注意只有更新事务可能需要被重试；只读事务将永远不会有序列化冲突。
   </para>
<!-- pgdoc-cn_end sig_en=7302120239ff1e507011d875deeb240d -->

<!-- pgdoc-cn_start sig_en=2ccfb28314fb3d33a2023f11ec57166f sig_cn_org=None source=14.1 
   <para>
    The Repeatable Read mode provides a rigorous guarantee that each
    transaction sees a completely stable view of the database.  However,
    this view will not necessarily always be consistent with some serial
    (one at a time) execution of concurrent transactions of the same level.
    For example, even a read-only transaction at this level may see a
    control record updated to show that a batch has been completed but
    <emphasis>not</emphasis> see one of the detail records which is logically
    part of the batch because it read an earlier revision of the control
    record.  Attempts to enforce business rules by transactions running at
    this isolation level are not likely to work correctly without careful use
    of explicit locks to block conflicting transactions.
   </para>
________________________________________________________-->
   <para>
    可重复读模式提供了一种严格的保证，在其中每一个事务看到数据库的一个完全稳定的视图。不过，这个视图并不需要总是和同一级别上并发事务的某些序列化（一次一个）执行保持一致。例如，即使这个级别上的一个只读事务可能看到一个控制记录被更新，这显示一个批处理已经被完成但是<emphasis>不能</emphasis>看见作为该批处理的逻辑组成部分的一个细节记录，因为它读取空值记录的一个较早的版本。如果不小心地使用显式锁来阻塞冲突事务，尝试用运行在这个隔离级别的事务来强制业务规则不太可能正确地工作。
   </para>
<!-- pgdoc-cn_end sig_en=2ccfb28314fb3d33a2023f11ec57166f -->

<!-- pgdoc-cn_start sig_en=993adf1b3be9e019c128af7554aac1d5 sig_cn_org=None source=14.1 
   <para>
    The Repeatable Read isolation level is implemented using a technique
    known in academic database literature and in some other database products
    as <firstterm>Snapshot Isolation</firstterm>.  Differences in behavior
    and performance may be observed when compared with systems that use a
    traditional locking technique that reduces concurrency.  Some other
    systems may even offer Repeatable Read and Snapshot Isolation as distinct
    isolation levels with different behavior.  The permitted phenomena that
    distinguish the two techniques were not formalized by database researchers
    until after the SQL standard was developed, and are outside the scope of
    this manual.  For a full treatment, please see
    <xref linkend="berenson95"/>.
   </para>
________________________________________________________-->
   <para>
    可重复读隔离级别是使用学术数据库文献和一些其他数据库产品中称为<firstterm>Snapshot Isolation</firstterm>的已知的技术来实现的。
    与使用传统锁技术并降低并发性的系统相比，可以观察到行为和性能方面的差异。
    一些其他系统甚至可以提供可重复读取和快照隔离作为具有不同行为的不同隔离级别。
    直到SQL标准开发出来之后，数据库研究人员才正式确定区分这两种技术的允许现象，并且超出了本手册的范围。全面的阐述，请参阅<xref linkend="berenson95"/>。
   </para>
<!-- pgdoc-cn_end sig_en=993adf1b3be9e019c128af7554aac1d5 -->

   <note>
<!-- pgdoc-cn_start sig_en=30c862644ce24125ecf93b392d3d84c3 sig_cn_org=None source=14.1 
    <para>
     Prior to <productname>PostgreSQL</productname> version 9.1, a request
     for the Serializable transaction isolation level provided exactly the
     same behavior described here.  To retain the legacy Serializable
     behavior, Repeatable Read should now be requested.
    </para>
________________________________________________________-->
    <para>
     在<productname>PostgreSQL</productname>版本 9.1 之前，一个对于可序列化事务隔离级别的请求会提供和这里描述的完全一样的行为。为了保持可序列化行为，现在应该请求可重复读。
    </para>
<!-- pgdoc-cn_end sig_en=30c862644ce24125ecf93b392d3d84c3 -->
   </note>
  </sect2>

  <sect2 id="xact-serializable">
<!-- pgdoc-cn_start sig_en=94a7775a526907b040e266bf8311c6a8 sig_cn_org=None source=14.1 
   <title>Serializable Isolation Level</title>
________________________________________________________-->
   <title>可序列化隔离级别</title>
<!-- pgdoc-cn_end sig_en=94a7775a526907b040e266bf8311c6a8 -->

<!-- pgdoc-cn_start sig_en=2fdfa92de63e704f64106c30362d7dc0 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>transaction isolation level</primary>
    <secondary>serializable</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>事务隔离级别</primary>
    <secondary>可序列化</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=2fdfa92de63e704f64106c30362d7dc0 -->

<!-- pgdoc-cn_start sig_en=cd6656eaa01523946e8ca2eb3bcab561 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>serializable</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>可序列化</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=cd6656eaa01523946e8ca2eb3bcab561 -->

<!-- pgdoc-cn_start sig_en=e65c0bf8dabd67635b763b19ec9217c2 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>predicate locking</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>谓词锁</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=e65c0bf8dabd67635b763b19ec9217c2 -->

<!-- pgdoc-cn_start sig_en=734c8e6cd5ef4143510a5fc07d0604da sig_cn_org=None source=14.1 
   <indexterm>
    <primary>serialization anomaly</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>序列化异常</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=734c8e6cd5ef4143510a5fc07d0604da -->

<!-- pgdoc-cn_start sig_en=8e7293bce28d4c2e3fb92cb81a07cf94 sig_cn_org=4c366fa0744b112cb1ffb2d1dc1a9710 source=15.7 
   <para>
    The <firstterm>Serializable</firstterm> isolation level provides
    the strictest transaction isolation.  This level emulates serial
    transaction execution for all committed transactions;
    as if transactions had been executed one after another, serially,
    rather than concurrently.  However, like the Repeatable Read level,
    applications using this level must
    be prepared to retry transactions due to serialization failures.
    In fact, this isolation level works exactly the same as Repeatable
    Read except that it also monitors for conditions which could make
    execution of a concurrent set of serializable transactions behave
    in a manner inconsistent with all possible serial (one at a time)
    executions of those transactions.  This monitoring does not
    introduce any blocking beyond that present in repeatable read, but
    there is some overhead to the monitoring, and detection of the
    conditions which could cause a
    <firstterm>serialization anomaly</firstterm> will trigger a
    <firstterm>serialization failure</firstterm>.
   </para>
________________________________________________________-->
   <para>
    <firstterm>Serializable</firstterm>隔离级别提供了最严格的事务隔离。
    该级别模拟了所有已提交事务的串行事务执行；
    就好像事务是依次串行执行而不是并发执行一样。然而，与可重复读级别一样，
    使用该级别的应用程序必须准备好由于串行化失败而重试事务。
    实际上，这种隔离级别的工作方式与可重复读完全相同，只是它还监视可能导致并发可串行化事务集的执行
    与所有可能的串行（一次一个）执行这些事务的方式不一致的条件。这种监视不会引入除了可重复读中存在的阻塞之外的任何阻塞，
    但是监视会带来一些开销，并且检测可能导致<firstterm>串行化异常</firstterm>的条件将触发一个
    <firstterm>串行化失败</firstterm>。
</para>
<!-- pgdoc-cn_end sig_en=8e7293bce28d4c2e3fb92cb81a07cf94 -->

<!-- pgdoc-cn_start sig_en=572b4c2cd39e10051d8ce48d56fbf24e sig_cn_org=None source=14.1 
   <para>
    As an example,
    consider a table <structname>mytab</structname>, initially containing:
<screen>
 class | value
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-
     1 |    10
     1 |    20
     2 |   100
     2 |   200
</screen>
    Suppose that serializable transaction A computes:
<screen>
SELECT SUM(value) FROM mytab WHERE class = 1;
</screen>
    and then inserts the result (30) as the <structfield>value</structfield> in a
    new row with <structfield>class</structfield><literal> = 2</literal>.  Concurrently, serializable
    transaction B computes:
<screen>
SELECT SUM(value) FROM mytab WHERE class = 2;
</screen>
    and obtains the result 300, which it inserts in a new row with
    <structfield>class</structfield><literal> = 1</literal>.  Then both transactions try to commit.
    If either transaction were running at the Repeatable Read isolation level,
    both would be allowed to commit; but since there is no serial order of execution
    consistent with the result, using Serializable transactions will allow one
    transaction to commit and will roll the other back with this message:

<screen>
ERROR:  could not serialize access due to read/write dependencies among transactions
</screen>

    This is because if A had
    executed before B, B would have computed the sum 330, not 300, and
    similarly the other order would have resulted in a different sum
    computed by A.
   </para>
________________________________________________________-->
   <para>
    例如，考虑一个表<structname>mytab</structname>，它初始时包含：
<screen>
 class | value
-------+-------
     1 |    10
     1 |    20
     2 |   100
     2 |   200
</screen>
    假设可序列化事务 A 计算：
<screen>
SELECT SUM(value) FROM mytab WHERE class = 1;
</screen>
    并且接着把结果（30）作为一个新行的<structfield>value</structfield>插入，新行的<structfield>class</structfield><literal> = 2</literal>。同时，可序列化事务 B 计算：
<screen>
SELECT SUM(value) FROM mytab WHERE class = 2;
</screen>
    并得到结果 300，它会将其与<structfield>class</structfield><literal> = 1</literal>插入到一个新行中。然后两个事务都尝试提交。如果其中一个事务运行在可重复读隔离级别，两者都被允许提交；但是由于不同的执行顺序可能导致不同结果，使用可序列化事务将允许一个事务提交并且将回滚另一个并伴有这个消息：

<screen>
ERROR:  could not serialize access due to read/write dependencies among transactions
</screen>

    这是因为，如果 A 在 B 之前执行，B 将计算得到合计值 330 而不是 300，而且相似地另一种顺序将导致 A 计算出一个不同的合计值。
   </para>
<!-- pgdoc-cn_end sig_en=572b4c2cd39e10051d8ce48d56fbf24e -->

<!-- pgdoc-cn_start sig_en=9e51b39170da00727bb6c67f396a0547 sig_cn_org=None source=14.1 
   <para>
    When relying on Serializable transactions to prevent anomalies, it is
    important that any data read from a permanent user table not be
    considered valid until the transaction which read it has successfully
    committed.  This is true even for read-only transactions, except that
    data read within a <firstterm>deferrable</firstterm> read-only
    transaction is known to be valid as soon as it is read, because such a
    transaction waits until it can acquire a snapshot guaranteed to be free
    from such problems before starting to read any data.  In all other cases
    applications must not depend on results read during a transaction that
    later aborted; instead, they should retry the transaction until it
    succeeds.
   </para>
________________________________________________________-->
   <para>
    当依赖可序列化事务来阻止异常时，重要的一点是任何从一个持久化用户表读出数据都不被认为是有效的，直到读它的事务已经成功提交为止。即便是对只读事务也是如此，除了在一个<firstterm>可推迟的</firstterm>只读事务中读取的数据是读出以后立刻有效的，因为这样的一个事务在开始读取任何数据之前会等待，直到它能获得一个快照保证来避免这种问题为止。在所有其他情况下，应用不能依靠在一个后来被中断的事务中读取的结果；相反，它们应当重试事务直到它成功。
   </para>
<!-- pgdoc-cn_end sig_en=9e51b39170da00727bb6c67f396a0547 -->

<!-- pgdoc-cn_start sig_en=a1c749bce3388baa78371cb63e2d0847 sig_cn_org=None source=14.1 
   <para>
    To guarantee true serializability <productname>PostgreSQL</productname>
    uses <firstterm>predicate locking</firstterm>, which means that it keeps locks
    which allow it to determine when a write would have had an impact on
    the result of a previous read from a concurrent transaction, had it run
    first.  In <productname>PostgreSQL</productname> these locks do not
    cause any blocking and therefore can <emphasis>not</emphasis> play any part in
    causing a deadlock.  They are used to identify and flag dependencies
    among concurrent Serializable transactions which in certain combinations
    can lead to serialization anomalies.  In contrast, a Read Committed or
    Repeatable Read transaction which wants to ensure data consistency may
    need to take out a lock on an entire table, which could block other
    users attempting to use that table, or it may use <literal>SELECT FOR
    UPDATE</literal> or <literal>SELECT FOR SHARE</literal> which not only
    can block other transactions but cause disk access.
   </para>
________________________________________________________-->
   <para>
    要保证真正的可序列化，<productname>PostgreSQL</productname>使用了<firstterm>谓词锁</firstterm>，这意味着它会保持锁，这些锁让它能够判断在它先运行的情况下，什么时候一个写操作会对一个并发事务中之前读取的结果产生影响。在<productname>PostgreSQL</productname>中，这些锁并不导致任何阻塞，并且因此<emphasis>不</emphasis>会导致一个死锁。它们被用来标识和标志并发可序列化事务之间的依赖性，这些事务的组合可能导致序列化异常。相反，一个想要保证数据一致性的读已提交或可重复读事务可能需要拿走一个在整个表上的锁，这可能阻塞其他尝试使用该表的用户，或者它可能会使用不仅会阻塞其他事务还会导致磁盘访问的<literal>SELECT FOR UPDATE</literal>或<literal>SELECT FOR SHARE</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=a1c749bce3388baa78371cb63e2d0847 -->

<!-- pgdoc-cn_start sig_en=a5feb0cb53bc650cbb614682130e1d28 sig_cn_org=None source=14.1 
   <para>
    Predicate locks in <productname>PostgreSQL</productname>, like in most
    other database systems, are based on data actually accessed by a
    transaction.  These will show up in the
    <link linkend="view-pg-locks"><structname>pg_locks</structname></link>
    system view with a <literal>mode</literal> of <literal>SIReadLock</literal>.  The
    particular locks
    acquired during execution of a query will depend on the plan used by
    the query, and multiple finer-grained locks (e.g., tuple locks) may be
    combined into fewer coarser-grained locks (e.g., page locks) during the
    course of the transaction to prevent exhaustion of the memory used to
    track the locks.  A <literal>READ ONLY</literal> transaction may be able to
    release its SIRead locks before completion, if it detects that no
    conflicts can still occur which could lead to a serialization anomaly.
    In fact, <literal>READ ONLY</literal> transactions will often be able to
    establish that fact at startup and avoid taking any predicate locks.
    If you explicitly request a <literal>SERIALIZABLE READ ONLY DEFERRABLE</literal>
    transaction, it will block until it can establish this fact.  (This is
    the <emphasis>only</emphasis> case where Serializable transactions block but
    Repeatable Read transactions don't.)  On the other hand, SIRead locks
    often need to be kept past transaction commit, until overlapping read
    write transactions complete.
   </para>
________________________________________________________-->
   <para>
    像大部分其他数据库系统，<productname>PostgreSQL</productname>中的谓词锁基于被一个事务真正访问的数据。这些谓词锁将显示在<link linkend="view-pg-locks"><structname>pg_locks</structname></link>系统视图中，它们的<literal>mode</literal>为<literal>SIReadLock</literal>。这种在一个查询执行期间获得的特别的锁将依赖于该查询所使用的计划，并且在事务过程中多个细粒度锁（如元组锁）可能和少量粗粒度锁（如页面锁）相结合来防止耗尽用于跟踪锁的内存。如果一个<literal>READ ONLY</literal>事务检测到不会有导致序列化异常的冲突发生，它可以在完成前释放其 SIRead 锁。事实上，<literal>READ ONLY</literal>事务将常常可以在启动时确立这一事实并避免拿到任何谓词锁。如果你显式地请求一个<literal>SERIALIZABLE READ ONLY DEFERRABLE</literal>事务，它将阻塞直到它能够确立这一事实（这是<emphasis>唯一</emphasis>一种可序列化事务阻塞但可重复读事务不阻塞的情况）。在另一方面，SIRead 锁常常需要被保持到事务提交之后，直到重叠的读写事务完成。
   </para>
<!-- pgdoc-cn_end sig_en=a5feb0cb53bc650cbb614682130e1d28 -->

<!-- pgdoc-cn_start sig_en=e8e01fafb82727ade22f79b9852a545d sig_cn_org=None source=14.1 
   <para>
    Consistent use of Serializable transactions can simplify development.
    The guarantee that any set of successfully committed concurrent
    Serializable transactions will have the same effect as if they were run
    one at a time means that if you can demonstrate that a single transaction,
    as written, will do the right thing when run by itself, you can have
    confidence that it will do the right thing in any mix of Serializable
    transactions, even without any information about what those other
    transactions might do, or it will not successfully commit.  It is
    important that an environment which uses this technique have a
    generalized way of handling serialization failures (which always return
    with an SQLSTATE value of '40001'), because it will be very hard to
    predict exactly which transactions might contribute to the read/write
    dependencies and need to be rolled back to prevent serialization
    anomalies.  The monitoring of read/write dependencies has a cost, as does
    the restart of transactions which are terminated with a serialization
    failure, but balanced against the cost and blocking involved in use of
    explicit locks and <literal>SELECT FOR UPDATE</literal> or <literal>SELECT FOR
    SHARE</literal>, Serializable transactions are the best performance choice
    for some environments.
   </para>
________________________________________________________-->
   <para>
    坚持使用可序列化事务可以简化开发。成功提交的并发可序列化事务的任意集合将得到和一次运行一个相同效果的这种保证意味着，如果你能证明一个单一事务在独自运行时能做正确的事情，则你可以相信它在任何混合的可序列化事务中也能做正确的事情，即使它不知道那些其他事务做了些什么，否则它将不会成功提交。重要的是使用这种技术的环境有一种普遍的方法来处理序列化失败（总是会返回一个 SQLSTATE 值 '40001'），因为它将很难准确地预计哪些事务可能为读/写依赖性做贡献并且需要被回滚来阻止序列化异常。读/写依赖性的监控会产生开销，如重启被序列化失败中止的事务，但是作为在该开销和显式锁及<literal>SELECT FOR UPDATE</literal>或<literal>SELECT FOR SHARE</literal>导致的阻塞之间的一种平衡，可序列化事务是在某些环境中最好性能的选择。
   </para>
<!-- pgdoc-cn_end sig_en=e8e01fafb82727ade22f79b9852a545d -->

<!-- pgdoc-cn_start sig_en=eb17adce8be616c4e1b1f434680c7419 sig_cn_org=None source=14.1 
   <para>
    While <productname>PostgreSQL</productname>'s Serializable transaction isolation
    level only allows concurrent transactions to commit if it can prove there
    is a serial order of execution that would produce the same effect, it
    doesn't always prevent errors from being raised that would not occur in
    true serial execution.  In particular, it is possible to see unique
    constraint violations caused by conflicts with overlapping Serializable
    transactions even after explicitly checking that the key isn't present
    before attempting to insert it.  This can be avoided by making sure
    that <emphasis>all</emphasis> Serializable transactions that insert potentially
    conflicting keys explicitly check if they can do so first.  For example,
    imagine an application that asks the user for a new key and then checks
    that it doesn't exist already by trying to select it first, or generates
    a new key by selecting the maximum existing key and adding one.  If some
    Serializable transactions insert new keys directly without following this
    protocol, unique constraints violations might be reported even in cases
    where they could not occur in a serial execution of the concurrent
    transactions.
   </para>
________________________________________________________-->
   <para>
    虽然<productname>PostgreSQL</productname>的可序列化事务隔离级别只允许并发事务在能够证明有一种串行执行能够产生相同效果的前提下提交，但它却不能总是阻止在真正的串行执行中不会发生的错误产生。尤其是可能会看到由于可序列化事务重叠执行导致的唯一约束被违背的情况，这些情况即便在尝试插入键之前就显式地检查过该键不存在也会发生。避免这种问题的方法是，确保<emphasis>所有</emphasis>插入可能会冲突的键的可序列化事务首先显式地检查它们能不能那样做。例如，试想一个要求用户输入新键的应用，它会通过尝试查询用户给出的键来检查键是否已经存在，或者是通过选取现有最大的键并且加一来产生一个新键。如果某些可序列化事务不遵循这种协议而直接插入新键，则也可能会报告唯一约束被违背，即便在并发事务串行执行的情况下不会发生唯一约束被违背也是如此。
   </para>
<!-- pgdoc-cn_end sig_en=eb17adce8be616c4e1b1f434680c7419 -->

<!-- pgdoc-cn_start sig_en=8d7ac4ceab3eb9a623f54e1338c8152a sig_cn_org=None source=14.1 
   <para>
    For optimal performance when relying on Serializable transactions for
    concurrency control, these issues should be considered:

    <itemizedlist>
     <listitem>
      <para>
       Declare transactions as <literal>READ ONLY</literal> when possible.
      </para>
     </listitem>
     <listitem>
      <para>
       Control the number of active connections, using a connection pool if
       needed.  This is always an important performance consideration, but
       it can be particularly important in a busy system using Serializable
       transactions.
      </para>
     </listitem>
     <listitem>
      <para>
       Don't put more into a single transaction than needed for integrity
       purposes.
      </para>
     </listitem>
     <listitem>
      <para>
       Don't leave connections dangling <quote>idle in transaction</quote>
       longer than necessary.  The configuration parameter
       <xref linkend="guc-idle-in-transaction-session-timeout"/> may be used to
       automatically disconnect lingering sessions.
      </para>
     </listitem>
     <listitem>
      <para>
       Eliminate explicit locks, <literal>SELECT FOR UPDATE</literal>, and
       <literal>SELECT FOR SHARE</literal> where no longer needed due to the
       protections automatically provided by Serializable transactions.
      </para>
     </listitem>
     <listitem>
      <para>
       When the system is forced to combine multiple page-level predicate
       locks into a single relation-level predicate lock because the predicate
       lock table is short of memory, an increase in the rate of serialization
       failures may occur.  You can avoid this by increasing
       <xref linkend="guc-max-pred-locks-per-transaction"/>,
       <xref linkend="guc-max-pred-locks-per-relation"/>, and/or
       <xref linkend="guc-max-pred-locks-per-page"/>.
      </para>
     </listitem>
     <listitem>
      <para>
       A sequential scan will always necessitate a relation-level predicate
       lock.  This can result in an increased rate of serialization failures.
       It may be helpful to encourage the use of index scans by reducing
       <xref linkend="guc-random-page-cost"/> and/or increasing
       <xref linkend="guc-cpu-tuple-cost"/>.  Be sure to weigh any decrease
       in transaction rollbacks and restarts against any overall change in
       query execution time.
      </para>
     </listitem>
    </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    当依赖可序列化事务进行并发控制时，为了最佳性能应该考虑以下问题：

    <itemizedlist>
     <listitem>
      <para>
       在可能时声明事务为<literal>READ ONLY</literal>。
      </para>
     </listitem>
     <listitem>
      <para>
       控制活动连接的数量，如果需要使用一个连接池。这总是一个重要的性能考虑，但是在一个使用可序列化事务的繁忙系统中这尤为重要。
      </para>
     </listitem>
     <listitem>
      <para>
       只在一个单一事务中放完整性目的所需要的东西。
      </para>
     </listitem>
     <listitem>
      <para>
       不要让连接不必要地<quote>闲置在事务中</quote>。配置参数<xref linkend="guc-idle-in-transaction-session-timeout"/>可以被用来自动断开拖延会话的连接。
      </para>
     </listitem>
     <listitem>
      <para>
       在那些由于使用可序列化事务自动提供的保护的地方消除不再需要的显式锁、<literal>SELECT FOR UPDATE</literal>和<literal>SELECT FOR SHARE</literal>。
      </para>
     </listitem>
     <listitem>
      <para>
       当系统因为谓词锁表内存短缺而被强制结合多个页面级谓词锁为一个单一的关系级谓词锁时，序列化失败的比例可能会上升。你可以通过增加<xref linkend="guc-max-pred-locks-per-transaction"/>、<xref linkend="guc-max-pred-locks-per-relation"/>和<xref linkend="guc-max-pred-locks-per-page"/>来避免这种情况。
      </para>
     </listitem>
     <listitem>
      <para>
       一次顺序扫描将总是需要一个关系级谓词锁。这可能导致序列化失败的比例上升。通过缩减<xref linkend="guc-random-page-cost"/>和/或增加<xref linkend="guc-cpu-tuple-cost"/>来鼓励使用索引扫描将有助于此。一定要在事务回滚和重启数目的任何减少与查询执行时间的任何全面改变之间进行权衡。
      </para>
     </listitem>
    </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=8d7ac4ceab3eb9a623f54e1338c8152a -->

<!-- pgdoc-cn_start sig_en=beac147cc1e49819c5e2e73fc50a21c0 sig_cn_org=None source=14.1 
   <para>
    The Serializable isolation level is implemented using a technique known
    in academic database literature as Serializable Snapshot Isolation, which
    builds on Snapshot Isolation by adding checks for serialization anomalies.
    Some differences in behavior and performance may be observed when compared
    with other systems that use a traditional locking technique.  Please see
    <xref linkend="ports12"/> for detailed information.
   </para>
________________________________________________________-->
   <para>
    可序列化隔离级别是使用学术数据库文献中称为可序列化快照隔离的技术实现的，通过添加序列化异常事务的检查的方式构建在快照隔离的基础之上。
    与使用传统锁技术的其他系统相比，可以观察到行为和性能方面的一些差异。详细信息请参阅<xref linkend="ports12"/>。
   </para>
<!-- pgdoc-cn_end sig_en=beac147cc1e49819c5e2e73fc50a21c0 -->
  </sect2>
 </sect1>

  <sect1 id="explicit-locking">
<!-- pgdoc-cn_start sig_en=397918053b5bc2747c684a2a4d3bc4ad sig_cn_org=None source=14.1 
   <title>Explicit Locking</title>
________________________________________________________-->
   <title>显式锁定</title>
<!-- pgdoc-cn_end sig_en=397918053b5bc2747c684a2a4d3bc4ad -->

<!-- pgdoc-cn_start sig_en=bd78078cbf805300f1fc40b9f4097f46 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>lock</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>锁</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=bd78078cbf805300f1fc40b9f4097f46 -->

<!-- pgdoc-cn_start sig_en=6ee05f9335fdcebd097b5f18d5dabc66 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> provides various lock modes
    to control concurrent access to data in tables.  These modes can
    be used for application-controlled locking in situations where
    <acronym>MVCC</acronym> does not give the desired behavior.  Also,
    most <productname>PostgreSQL</productname> commands automatically
    acquire locks of appropriate modes to ensure that referenced
    tables are not dropped or modified in incompatible ways while the
    command executes.  (For example, <command>TRUNCATE</command> cannot safely be
    executed concurrently with other operations on the same table, so it
    obtains an <literal>ACCESS EXCLUSIVE</literal> lock on the table to
    enforce that.)
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>提供了多种锁模式用于控制对表中数据的并发访问。 这些模式可以用于在<acronym>MVCC</acronym>无法给出期望行为的情境中由应用控制的锁。 同样，大多数<productname>PostgreSQL</productname>命令会自动要求恰当的锁以保证被引用的表在命令的执行过程中 不会以一种不兼容的方式删除或修改（例如，<command>TRUNCATE</command>无法安全地与同一表中上的其他操作并发地执行，因此它在表上获得一个<literal>ACCESS EXCLUSIVE</literal> 锁来强制这种行为）。
   </para>
<!-- pgdoc-cn_end sig_en=6ee05f9335fdcebd097b5f18d5dabc66 -->

<!-- pgdoc-cn_start sig_en=dfb111b3d2e7b6741ee9e4bee166817c sig_cn_org=None source=14.1 
   <para>
    To examine a list of the currently outstanding locks in a database
    server, use the
    <link linkend="view-pg-locks"><structname>pg_locks</structname></link>
    system view. For more information on monitoring the status of the lock
    manager subsystem, refer to <xref linkend="monitoring"/>.
   </para>
________________________________________________________-->
   <para>
    要检查在一个数据库服务器中当前未解除的锁列表，可以使用<link linkend="view-pg-locks"><structname>pg_locks</structname></link>系统视图。 有关监控锁管理器子系统状态的更多信息，请参考<xref linkend="monitoring"/>。
   </para>
<!-- pgdoc-cn_end sig_en=dfb111b3d2e7b6741ee9e4bee166817c -->

  <sect2 id="locking-tables">
<!-- pgdoc-cn_start sig_en=b99fde43e594ea2a49c5c0cdc6399120 sig_cn_org=None source=14.1 
   <title>Table-Level Locks</title>
________________________________________________________-->
   <title>表级锁</title>
<!-- pgdoc-cn_end sig_en=b99fde43e594ea2a49c5c0cdc6399120 -->

<!-- pgdoc-cn_start sig_en=a441c61faa23ed04242ab07652723eb3 sig_cn_org=None source=14.1 
   <indexterm zone="locking-tables">
    <primary>LOCK</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="locking-tables">
    <primary>LOCK</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=a441c61faa23ed04242ab07652723eb3 -->

<!-- pgdoc-cn_start sig_en=63a349c254c3d812f92442b9aeeda48a sig_cn_org=None source=14.1 
   <para>
    The list below shows the available lock modes and the contexts in
    which they are used automatically by
    <productname>PostgreSQL</productname>.  You can also acquire any
    of these locks explicitly with the command <xref
    linkend="sql-lock"/>.
    Remember that all of these lock modes are table-level locks,
    even if the name contains the word
    <quote>row</quote>; the names of the lock modes are historical.
    To some extent the names reflect the typical usage of each lock
    mode &mdash; but the semantics are all the same.  The only real difference
    between one lock mode and another is the set of lock modes with
    which each conflicts (see <xref linkend="table-lock-compatibility"/>).
    Two transactions cannot hold locks of conflicting
    modes on the same table at the same time.  (However, a transaction
    never conflicts with itself.  For example, it might acquire
    <literal>ACCESS EXCLUSIVE</literal> lock and later acquire
    <literal>ACCESS SHARE</literal> lock on the same table.)  Non-conflicting
    lock modes can be held concurrently by many transactions.  Notice in
    particular that some lock modes are self-conflicting (for example,
    an <literal>ACCESS EXCLUSIVE</literal> lock cannot be held by more than one
    transaction at a time) while others are not self-conflicting (for example,
    an <literal>ACCESS SHARE</literal> lock can be held by multiple transactions).
   </para>
________________________________________________________-->
   <para>
    下面的列表显示了可用的锁模式和<productname>PostgreSQL</productname>自动使用它们的场合。 你也可以用<xref linkend="sql-lock"/>命令显式获得这些锁。请记住所有这些锁模式都是表级锁，即使它们的名字包含<quote>row</quote>单词（这些名称是历史遗产）。 在一定程度上，这些名字反应了每种锁模式的典型用法 &mdash; 但是语意却都是一样的。 两种锁模式之间真正的区别是它们有着不同的冲突锁模式集合（参考<xref linkend="table-lock-compatibility"/>）。 两个事务在同一时刻不能在同一个表上持有属于相互冲突模式的锁（但是，一个事务决不会和自身冲突。例如，它可以在同一个表上获得<literal>ACCESS EXCLUSIVE</literal>锁然后接着获取<literal>ACCESS SHARE</literal>锁）。非冲突锁模式可以由许多事务同时持有。 请特别注意有些锁模式是自冲突的（例如，在一个时刻<literal>ACCESS EXCLUSIVE</literal>锁不能被多于一个事务持有)而其他锁模式不是自冲突的（例如，<literal>ACCESS SHARE</literal>锁可以被多个事务持有)。
   </para>
<!-- pgdoc-cn_end sig_en=63a349c254c3d812f92442b9aeeda48a -->

     <variablelist>
<!-- pgdoc-cn_start sig_en=4d67b937710c810dbc0e08e7a1a3def7 sig_cn_org=None source=14.1 
      <title>Table-Level Lock Modes</title>
________________________________________________________-->
      <title>表级锁模式</title>
<!-- pgdoc-cn_end sig_en=4d67b937710c810dbc0e08e7a1a3def7 -->
      <varlistentry>
<!-- pgdoc-cn_start sig_en=dc2f4a157f9bcb4de72ae8331e08cfcb sig_cn_org=36f898712b8a4e1b4b76f9bfb36f1ec7 source=15.7 
       <term>
        <literal>ACCESS SHARE</literal> (<literal>AccessShareLock</literal>)
       </term>
________________________________________________________-->
       <term>
        <literal>ACCESS SHARE</literal> (<literal>AccessShareLock</literal>)
       </term>
<!-- pgdoc-cn_end sig_en=dc2f4a157f9bcb4de72ae8331e08cfcb -->
       <listitem>
<!-- pgdoc-cn_start sig_en=374bf274ff09b3f065bc1d72e56ccece sig_cn_org=None source=14.1 
        <para>
         Conflicts with the <literal>ACCESS EXCLUSIVE</literal> lock
         mode only.
        </para>
________________________________________________________-->
        <para>
         只与<literal>ACCESS EXCLUSIVE</literal>锁模式冲突。
        </para>
<!-- pgdoc-cn_end sig_en=374bf274ff09b3f065bc1d72e56ccece -->

<!-- pgdoc-cn_start sig_en=438f83c77202c01bf3dc93e56e832e5d sig_cn_org=None source=14.1 
        <para>
         The <command>SELECT</command> command acquires a lock of this mode on
         referenced tables.  In general, any query that only <emphasis>reads</emphasis> a table
         and does not modify it will acquire this lock mode.
        </para>
________________________________________________________-->
        <para>
         <command>SELECT</command>命令在被引用的表上获得一个这种模式的锁。通常，任何只<emphasis>读取</emphasis>表而不修改它的查询都将获得这种锁模式。
        </para>
<!-- pgdoc-cn_end sig_en=438f83c77202c01bf3dc93e56e832e5d -->
       </listitem>
      </varlistentry>

      <varlistentry>
<!-- pgdoc-cn_start sig_en=16a24bc7af99ce90be8d7ee013e9a6dc sig_cn_org=b62e63541e7a7935d2cabb9553ad3be8 source=15.7 
       <term>
        <literal>ROW SHARE</literal> (<literal>RowShareLock</literal>)
       </term>
________________________________________________________-->
       <term>
        <literal>ROW SHARE</literal>（<literal>RowShareLock</literal>）
       </term>
<!-- pgdoc-cn_end sig_en=16a24bc7af99ce90be8d7ee013e9a6dc -->
       <listitem>
<!-- pgdoc-cn_start sig_en=8d0bf6f944afe68821975a139823ece4 sig_cn_org=None source=14.1 
        <para>
         Conflicts with the <literal>EXCLUSIVE</literal> and
         <literal>ACCESS EXCLUSIVE</literal> lock modes.
        </para>
________________________________________________________-->
        <para>
         与<literal>EXCLUSIVE</literal>和<literal>ACCESS EXCLUSIVE</literal>锁模式冲突。
        </para>
<!-- pgdoc-cn_end sig_en=8d0bf6f944afe68821975a139823ece4 -->

<!-- pgdoc-cn_start sig_en=c9c18d5a52c315c1955ad69e40da1e67 sig_cn_org=7a6583af15056383eadbd0f8ef7f5a45 source=15.7 
        <para>
         The <command>SELECT</command> command acquires a lock of this mode
         on all tables on which one of the <option>FOR UPDATE</option>,
         <option>FOR NO KEY UPDATE</option>,
         <option>FOR SHARE</option>, or
         <option>FOR KEY SHARE</option> options is specified
         (in addition to <literal>ACCESS SHARE</literal> locks on any other
         tables that are referenced without any explicit
         <option>FOR ...</option> locking option).
        </para>
________________________________________________________-->
        <para>
         <command>SELECT</command>命令在所有指定了<option>FOR UPDATE</option>、
         <option>FOR NO KEY UPDATE</option>、<option>FOR SHARE</option>或
         <option>FOR KEY SHARE</option>选项的表上以此模式获取锁
         （除了在没有任何显式<option>FOR ...</option>锁定选项的情况下引用的其他表上的
         <literal>ACCESS SHARE</literal>锁）。
        </para>
<!-- pgdoc-cn_end sig_en=c9c18d5a52c315c1955ad69e40da1e67 -->
       </listitem>
      </varlistentry>

      <varlistentry>
<!-- pgdoc-cn_start sig_en=d97fae6938a9e5f9c9848bce19c089dd sig_cn_org=2b2b53848ec070beb0200a256116aee0 source=15.7 
       <term>
        <literal>ROW EXCLUSIVE</literal> (<literal>RowExclusiveLock</literal>)
       </term>
________________________________________________________-->
       <term>
        <literal>ROW EXCLUSIVE</literal> (<literal>RowExclusiveLock</literal>)
       </term>
<!-- pgdoc-cn_end sig_en=d97fae6938a9e5f9c9848bce19c089dd -->
       <listitem>
<!-- pgdoc-cn_start sig_en=c76fcbcab485c69745e4f4b176067224 sig_cn_org=None source=14.1 
        <para>
         Conflicts with the <literal>SHARE</literal>, <literal>SHARE ROW
         EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal>, and
         <literal>ACCESS EXCLUSIVE</literal> lock modes.
        </para>
________________________________________________________-->
        <para>
         与<literal>SHARE</literal>、<literal>SHARE ROW EXCLUSIVE</literal>、<literal>EXCLUSIVE</literal>和<literal>ACCESS EXCLUSIVE</literal>锁模式冲突。
        </para>
<!-- pgdoc-cn_end sig_en=c76fcbcab485c69745e4f4b176067224 -->

<!-- pgdoc-cn_start sig_en=85e3ca0cf7b9f520332e8ba804c8e359 sig_cn_org=e77cb12377e4059d67f93953ed0460eb source=15.7 
        <para>
         The commands <command>UPDATE</command>,
         <command>DELETE</command>, <command>INSERT</command>, and
         <command>MERGE</command>
         acquire this lock mode on the target table (in addition to
         <literal>ACCESS SHARE</literal> locks on any other referenced
         tables).  In general, this lock mode will be acquired by any
         command that <emphasis>modifies data</emphasis> in a table.
        </para>
________________________________________________________-->
        <para>
         命令<command>UPDATE</command>、<command>DELETE</command>、<command>INSERT</command>和
         <command>MERGE</command>
         在目标表上获取这种锁模式（除了对任何其他引用表的<literal>ACCESS SHARE</literal>锁）。一般来说，任何<emphasis>修改表中数据</emphasis>的命令都会获取这种锁模式。
        </para>
<!-- pgdoc-cn_end sig_en=85e3ca0cf7b9f520332e8ba804c8e359 -->
       </listitem>
      </varlistentry>

      <varlistentry>
<!-- pgdoc-cn_start sig_en=e63259b7f8bd794e1f71732f627f9d9c sig_cn_org=93c32909817229bba8249eb334d31851 source=15.7 
       <term>
        <literal>SHARE UPDATE EXCLUSIVE</literal> (<literal>ShareUpdateExclusiveLock</literal>)
       </term>
________________________________________________________-->
       <term>
        <literal>SHARE UPDATE EXCLUSIVE</literal> (<literal>ShareUpdateExclusiveLock</literal>)
       </term>
<!-- pgdoc-cn_end sig_en=e63259b7f8bd794e1f71732f627f9d9c -->
       <listitem>
<!-- pgdoc-cn_start sig_en=4c37db7f79e4b189bc7b602eb570233e sig_cn_org=None source=14.1 
        <para>
         Conflicts with the <literal>SHARE UPDATE EXCLUSIVE</literal>,
         <literal>SHARE</literal>, <literal>SHARE ROW
         EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal>, and
         <literal>ACCESS EXCLUSIVE</literal> lock modes.
         This mode protects a table against
         concurrent schema changes and <command>VACUUM</command> runs.
        </para>
________________________________________________________-->
        <para>
         与<literal>SHARE UPDATE EXCLUSIVE</literal>、<literal>SHARE</literal>、<literal>SHARE ROW EXCLUSIVE</literal>、<literal>EXCLUSIVE</literal>和<literal>ACCESS EXCLUSIVE</literal>锁模式冲突。这种模式保护一个表不受并发模式改变和<command>VACUUM</command>运行的影响。
        </para>
<!-- pgdoc-cn_end sig_en=4c37db7f79e4b189bc7b602eb570233e -->

<!-- pgdoc-cn_start sig_en=bca499843e7e4e70c929320d346f86bc sig_cn_org=9185b609e8b75c4d7f9dce86b634060d source=15.7 
        <para>
         Acquired by <command>VACUUM</command> (without <option>FULL</option>),
         <command>ANALYZE</command>, <command>CREATE INDEX CONCURRENTLY</command>,
         <command>CREATE STATISTICS</command>, <command>COMMENT ON</command>,
         <command>REINDEX CONCURRENTLY</command>,
         and certain <link linkend="sql-alterindex"><command>ALTER INDEX</command></link>
         and <link linkend="sql-altertable"><command>ALTER TABLE</command></link> variants
         (for full details see the documentation of these commands).
        </para>
________________________________________________________-->
        <para>
         通过<command>VACUUM</command>（不使用<option>FULL</option>），
         <command>ANALYZE</command>，<command>CREATE INDEX CONCURRENTLY</command>，
         <command>CREATE STATISTICS</command>，<command>COMMENT ON</command>，
         <command>REINDEX CONCURRENTLY</command>，
         以及某些<link linkend="sql-alterindex"><command>ALTER INDEX</command></link>
         和<link linkend="sql-altertable"><command>ALTER TABLE</command></link>变体
         （有关详细信息，请参阅这些命令的文档）。
        </para>
<!-- pgdoc-cn_end sig_en=bca499843e7e4e70c929320d346f86bc -->
       </listitem>
      </varlistentry>

      <varlistentry>
<!-- pgdoc-cn_start sig_en=1198d2221c339ea05aae58a5e027ccc0 sig_cn_org=b2e52f89fc8c4e0c7772b4f1fee6c219 source=15.7 
       <term>
        <literal>SHARE</literal> (<literal>ShareLock</literal>)
       </term>
________________________________________________________-->
       <term>
        <literal>SHARE</literal> (<literal>共享锁</literal>)
       </term>
<!-- pgdoc-cn_end sig_en=1198d2221c339ea05aae58a5e027ccc0 -->
       <listitem>
<!-- pgdoc-cn_start sig_en=a0090237bf4670fbb9a82f069ee71d76 sig_cn_org=None source=14.1 
        <para>
         Conflicts with the <literal>ROW EXCLUSIVE</literal>,
         <literal>SHARE UPDATE EXCLUSIVE</literal>, <literal>SHARE ROW
         EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal>, and
         <literal>ACCESS EXCLUSIVE</literal> lock modes.
         This mode protects a table against concurrent data changes.
        </para>
________________________________________________________-->
        <para>
         与<literal>ROW EXCLUSIVE</literal>、<literal>SHARE UPDATE EXCLUSIVE</literal>、<literal>SHARE ROW EXCLUSIVE</literal>、<literal>EXCLUSIVE</literal>和<literal>ACCESS EXCLUSIVE</literal>锁模式冲突。这种模式保护一个表不受并发数据改变的影响。
        </para>
<!-- pgdoc-cn_end sig_en=a0090237bf4670fbb9a82f069ee71d76 -->

<!-- pgdoc-cn_start sig_en=9a10178ae0aa84ac8c85092855bda4dc sig_cn_org=None source=14.1 
        <para>
         Acquired by <command>CREATE INDEX</command>
         (without <option>CONCURRENTLY</option>).
        </para>
________________________________________________________-->
        <para>
         由<command>CREATE INDEX</command>（不带<option>CONCURRENTLY</option>）取得。
        </para>
<!-- pgdoc-cn_end sig_en=9a10178ae0aa84ac8c85092855bda4dc -->
       </listitem>
      </varlistentry>

      <varlistentry>
<!-- pgdoc-cn_start sig_en=75e293d63131c2e423335a9bde49b7ee sig_cn_org=f84c07209dc2e45379a88f5f447f7fb6 source=15.7 
       <term>
        <literal>SHARE ROW EXCLUSIVE</literal> (<literal>ShareRowExclusiveLock</literal>)
       </term>
________________________________________________________-->
       <term>
        <literal>SHARE ROW EXCLUSIVE</literal> (<literal>ShareRowExclusiveLock</literal>)
       </term>
<!-- pgdoc-cn_end sig_en=75e293d63131c2e423335a9bde49b7ee -->
       <listitem>
<!-- pgdoc-cn_start sig_en=5529728656ff4b60bfd79041e9f967e1 sig_cn_org=None source=14.1 
        <para>
         Conflicts with the <literal>ROW EXCLUSIVE</literal>,
         <literal>SHARE UPDATE EXCLUSIVE</literal>,
         <literal>SHARE</literal>, <literal>SHARE ROW
         EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal>, and
         <literal>ACCESS EXCLUSIVE</literal> lock modes.
         This mode protects a table against concurrent data changes, and
         is self-exclusive so that only one session can hold it at a time.
        </para>
________________________________________________________-->
        <para>
         与<literal>ROW EXCLUSIVE</literal>、<literal>SHARE UPDATE EXCLUSIVE</literal>、<literal>SHARE</literal>、<literal>SHARE ROW EXCLUSIVE</literal>、<literal>EXCLUSIVE</literal>和<literal>ACCESS EXCLUSIVE</literal>锁模式冲突。这种模式保护一个表不受并发数据修改所影响，并且是自排他的，这样在一个时刻只能有一个会话持有它。
        </para>
<!-- pgdoc-cn_end sig_en=5529728656ff4b60bfd79041e9f967e1 -->

<!-- pgdoc-cn_start sig_en=d64b05f550d9f1ac4002e495ef56305c sig_cn_org=None source=14.1 
        <para>
         Acquired by <command>CREATE TRIGGER</command> and some forms of
         <link linkend="sql-altertable"><command>ALTER TABLE</command></link>.
        </para>
________________________________________________________-->
        <para>
         由<command>CREATE TRIGGER</command>和某些形式的
         <link linkend="sql-altertable"><command>ALTER TABLE</command></link>所获得。
        </para>
<!-- pgdoc-cn_end sig_en=d64b05f550d9f1ac4002e495ef56305c -->
       </listitem>
      </varlistentry>

      <varlistentry>
<!-- pgdoc-cn_start sig_en=05c26647e061ccece5ede0622627e1e5 sig_cn_org=44c35d4b81650cb8dfe5a6b6946724c3 source=15.7 
       <term>
        <literal>EXCLUSIVE</literal> (<literal>ExclusiveLock</literal>)
       </term>
________________________________________________________-->
       <term>
        <literal>EXCLUSIVE</literal> (<literal>独占</literal>)
       </term>
<!-- pgdoc-cn_end sig_en=05c26647e061ccece5ede0622627e1e5 -->
       <listitem>
<!-- pgdoc-cn_start sig_en=01549ff4679710b9524b0faa633e3abc sig_cn_org=None source=14.1 
        <para>
         Conflicts with the <literal>ROW SHARE</literal>, <literal>ROW
         EXCLUSIVE</literal>, <literal>SHARE UPDATE
         EXCLUSIVE</literal>, <literal>SHARE</literal>, <literal>SHARE
         ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal>, and
         <literal>ACCESS EXCLUSIVE</literal> lock modes.
         This mode allows only concurrent <literal>ACCESS SHARE</literal> locks,
         i.e., only reads from the table can proceed in parallel with a
         transaction holding this lock mode.
        </para>
________________________________________________________-->
        <para>
         与<literal>ROW SHARE</literal>、<literal>ROW EXCLUSIVE</literal>、<literal>SHARE UPDATE EXCLUSIVE</literal>、<literal>SHARE</literal>、<literal>SHARE ROW EXCLUSIVE</literal>、<literal>EXCLUSIVE</literal>和<literal>ACCESS EXCLUSIVE</literal>锁模式冲突。这种模式只允许并发的<literal>ACCESS SHARE</literal>锁，即只有来自于表的读操作可以与一个持有该锁模式的事务并行处理。
        </para>
<!-- pgdoc-cn_end sig_en=01549ff4679710b9524b0faa633e3abc -->

<!-- pgdoc-cn_start sig_en=8384adf91e38ebd464ce684bdf48e028 sig_cn_org=None source=14.1 
        <para>
         Acquired by <command>REFRESH MATERIALIZED VIEW CONCURRENTLY</command>.
        </para>
________________________________________________________-->
        <para>
         由<command>REFRESH MATERIALIZED VIEW CONCURRENTLY</command>获得。
        </para>
<!-- pgdoc-cn_end sig_en=8384adf91e38ebd464ce684bdf48e028 -->
       </listitem>
      </varlistentry>

      <varlistentry>
<!-- pgdoc-cn_start sig_en=b500831bffa975c73a961117385728c8 sig_cn_org=b64dd7d64a11e2c0966a335c021a59ff source=15.7 
       <term>
        <literal>ACCESS EXCLUSIVE</literal> (<literal>AccessExclusiveLock</literal>)
       </term>
________________________________________________________-->
       <term>
        <literal>ACCESS EXCLUSIVE</literal> (<literal>AccessExclusiveLock</literal>)
       </term>
<!-- pgdoc-cn_end sig_en=b500831bffa975c73a961117385728c8 -->
       <listitem>
<!-- pgdoc-cn_start sig_en=7eedb22250995dca4d33bbfe0c61815a sig_cn_org=None source=14.1 
        <para>
         Conflicts with locks of all modes (<literal>ACCESS
         SHARE</literal>, <literal>ROW SHARE</literal>, <literal>ROW
         EXCLUSIVE</literal>, <literal>SHARE UPDATE
         EXCLUSIVE</literal>, <literal>SHARE</literal>, <literal>SHARE
         ROW EXCLUSIVE</literal>, <literal>EXCLUSIVE</literal>, and
         <literal>ACCESS EXCLUSIVE</literal>).
         This mode guarantees that the
         holder is the only transaction accessing the table in any way.
        </para>
________________________________________________________-->
        <para>
         与所有模式的锁冲突（<literal>ACCESS SHARE</literal>、<literal>ROW SHARE</literal>、<literal>ROW EXCLUSIVE</literal>、<literal>SHARE UPDATE EXCLUSIVE</literal>、<literal>SHARE</literal>、<literal>SHARE ROW EXCLUSIVE</literal>、<literal>EXCLUSIVE</literal>和<literal>ACCESS EXCLUSIVE</literal>）。这种模式保证持有者是访问该表的唯一事务。
        </para>
<!-- pgdoc-cn_end sig_en=7eedb22250995dca4d33bbfe0c61815a -->

<!-- pgdoc-cn_start sig_en=493e725923168828d0f4e8575be5a8c1 sig_cn_org=None source=14.1 
        <para>
         Acquired by the <command>DROP TABLE</command>,
         <command>TRUNCATE</command>, <command>REINDEX</command>,
         <command>CLUSTER</command>, <command>VACUUM FULL</command>,
         and <command>REFRESH MATERIALIZED VIEW</command> (without
         <option>CONCURRENTLY</option>)
         commands. Many forms of <command>ALTER INDEX</command> and <command>ALTER TABLE</command> also acquire
         a lock at this level. This is also the default lock mode for
         <command>LOCK TABLE</command> statements that do not specify
         a mode explicitly.
        </para>
________________________________________________________-->
        <para>
         由<command>ALTER TABLE</command>、<command>DROP TABLE</command>、<command>TRUNCATE</command>、<command>REINDEX</command>、<command>CLUSTER</command>、<command>VACUUM FULL</command>和<command>REFRESH MATERIALIZED VIEW</command>（不带<option>CONCURRENTLY</option>）命令获取。
         很多形式的<command>ALTER INDEX</command>和<command>ALTER TABLE</command>也在这个层面上获得锁（见<xref linkend="sql-altertable"/>）。这也是未显式指定模式的<command>LOCK TABLE</command>命令的默认锁模式。
        </para>
<!-- pgdoc-cn_end sig_en=493e725923168828d0f4e8575be5a8c1 -->
       </listitem>
      </varlistentry>
     </variablelist>

     <tip>
<!-- pgdoc-cn_start sig_en=f4dd4ba336201e1756a272a1813e180a sig_cn_org=None source=14.1 
      <para>
       Only an <literal>ACCESS EXCLUSIVE</literal> lock blocks a
       <command>SELECT</command> (without <option>FOR UPDATE/SHARE</option>)
       statement.
      </para>
________________________________________________________-->
      <para>
       只有一个<literal>ACCESS EXCLUSIVE</literal>锁阻塞一个<command>SELECT</command>（不带<option>FOR UPDATE/SHARE</option>）语句。
      </para>
<!-- pgdoc-cn_end sig_en=f4dd4ba336201e1756a272a1813e180a -->
     </tip>

<!-- pgdoc-cn_start sig_en=ad33be6d9b234481a647fd163ed7ff24 sig_cn_org=None source=14.1 
   <para>
    Once acquired, a lock is normally held until the end of the transaction.  But if a
    lock is acquired after establishing a savepoint, the lock is released
    immediately if the savepoint is rolled back to.  This is consistent with
    the principle that <command>ROLLBACK</command> cancels all effects of the
    commands since the savepoint.  The same holds for locks acquired within a
    <application>PL/pgSQL</application> exception block: an error escape from the block
    releases locks acquired within it.
   </para>
________________________________________________________-->
   <para>
    一旦被获取，一个锁通常将被持有直到事务结束。 但是如果在建立保存点之后才获得锁，那么在回滚到这个保存点的时候将立即释放该锁。 这与<command>ROLLBACK</command>取消保存点之后所有的影响的原则保持一致。 同样的原则也适用于在<application>PL/pgSQL</application>异常块中获得的锁：一个跳出块的错误将释放在块中获得的锁。
   </para>
<!-- pgdoc-cn_end sig_en=ad33be6d9b234481a647fd163ed7ff24 -->



    <table tocentry="1" id="table-lock-compatibility">
<!-- pgdoc-cn_start sig_en=868763e0e7660a99a86a3929b666b446 sig_cn_org=None source=14.1 
     <title>Conflicting Lock Modes</title>
________________________________________________________-->
     <title>冲突的锁模式</title>
<!-- pgdoc-cn_end sig_en=868763e0e7660a99a86a3929b666b446 -->
     <tgroup cols="9">
      <colspec colnum="1" colwidth="1.25*"/>
      <colspec colnum="2" colwidth="1*" colname="lockst"/>
      <colspec colnum="3" colwidth="1*"/>
      <colspec colnum="4" colwidth="1*"/>
      <colspec colnum="5" colwidth="1*"/>
      <colspec colnum="6" colwidth="1*"/>
      <colspec colnum="7" colwidth="1*"/>
      <colspec colnum="8" colwidth="1*"/>
      <colspec colnum="9" colwidth="1*" colname="lockend"/>
      <spanspec spanname="lockreq" namest="lockst" nameend="lockend" align="center"/>
      <thead>
<!-- pgdoc-cn_start sig_en=4379871356c61a0f3b3cee04a4ec80ce sig_cn_org=None source=14.1 
       <row>
        <entry morerows="1">Requested Lock Mode</entry>
        <entry spanname="lockreq">Existing Lock Mode</entry>
       </row>
________________________________________________________-->
       <row>
        <entry morerows="1">请求的锁模式</entry>
        <entry spanname="lockreq">已存在的锁模式</entry>
       </row>
<!-- pgdoc-cn_end sig_en=4379871356c61a0f3b3cee04a4ec80ce -->
       <row>
        <entry><literal>ACCESS SHARE</literal></entry>
        <entry><literal>ROW SHARE</literal></entry>
        <entry><literal>ROW EXCL.</literal></entry>
        <entry><literal>SHARE UPDATE EXCL.</literal></entry>
        <entry><literal>SHARE</literal></entry>
        <entry><literal>SHARE ROW EXCL.</literal></entry>
        <entry><literal>EXCL.</literal></entry>
        <entry><literal>ACCESS EXCL.</literal></entry>
       </row>
      </thead>
      <tbody>
<!-- pgdoc-cn_start sig_en=3530258e913181dc67f876c09192ab53 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>ACCESS SHARE</literal></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>ACCESS SHARE</literal></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
       </row>
<!-- pgdoc-cn_end sig_en=3530258e913181dc67f876c09192ab53 -->
<!-- pgdoc-cn_start sig_en=c17d7c60b28d081ec520fdf172c08d7f sig_cn_org=None source=14.1 
       <row>
        <entry><literal>ROW SHARE</literal></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>ROW SHARE</literal></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
<!-- pgdoc-cn_end sig_en=c17d7c60b28d081ec520fdf172c08d7f -->
<!-- pgdoc-cn_start sig_en=418e8a7be489782db6daf882f302acd6 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>ROW EXCL.</literal></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>ROW EXCL.</literal></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
<!-- pgdoc-cn_end sig_en=418e8a7be489782db6daf882f302acd6 -->
<!-- pgdoc-cn_start sig_en=94d5246e336238ceec712c8c22bc2899 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>SHARE UPDATE EXCL.</literal></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>SHARE UPDATE EXCL.</literal></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
<!-- pgdoc-cn_end sig_en=94d5246e336238ceec712c8c22bc2899 -->
<!-- pgdoc-cn_start sig_en=d6c83f2cfe4e2a9f6ffaf608ec3281af sig_cn_org=None source=14.1 
       <row>
        <entry><literal>SHARE</literal></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>SHARE</literal></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
<!-- pgdoc-cn_end sig_en=d6c83f2cfe4e2a9f6ffaf608ec3281af -->
<!-- pgdoc-cn_start sig_en=5ca5de19bbaef2ed785c27f20d631675 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>SHARE ROW EXCL.</literal></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>SHARE ROW EXCL.</literal></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
<!-- pgdoc-cn_end sig_en=5ca5de19bbaef2ed785c27f20d631675 -->
<!-- pgdoc-cn_start sig_en=d19c80115f1f2686c766e8d6a35f7148 sig_cn_org=None source=14.1 
       <row>
        <entry><literal>EXCL.</literal></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>EXCL.</literal></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
<!-- pgdoc-cn_end sig_en=d19c80115f1f2686c766e8d6a35f7148 -->
<!-- pgdoc-cn_start sig_en=c8e1fa88fa29054b074f89db3720423b sig_cn_org=None source=14.1 
       <row>
        <entry><literal>ACCESS EXCL.</literal></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><literal>ACCESS EXCL.</literal></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
<!-- pgdoc-cn_end sig_en=c8e1fa88fa29054b074f89db3720423b -->
      </tbody>
     </tgroup>
    </table>
   </sect2>

   <sect2 id="locking-rows">
<!-- pgdoc-cn_start sig_en=661ef45fe56bd23106ce0cd2e8857dac sig_cn_org=None source=14.1 
    <title>Row-Level Locks</title>
________________________________________________________-->
    <title>行级锁</title>
<!-- pgdoc-cn_end sig_en=661ef45fe56bd23106ce0cd2e8857dac -->

<!-- pgdoc-cn_start sig_en=7298578a3ecc4fa818ff7ce51f6a8bf2 sig_cn_org=None source=14.1 
    <para>
     In addition to table-level locks, there are row-level locks, which
     are listed as below with the contexts in which they are used
     automatically by <productname>PostgreSQL</productname>.  See
     <xref linkend="row-lock-compatibility"/> for a complete table of
     row-level lock conflicts.  Note that a transaction can hold
     conflicting locks on the same row, even in different subtransactions;
     but other than that, two transactions can never hold conflicting locks
     on the same row.  Row-level locks do not affect data querying; they
     block only <emphasis>writers and lockers</emphasis> to the same
     row.  Row-level locks are released at transaction end or during
     savepoint rollback, just like table-level locks.

    </para>
________________________________________________________-->
    <para>
     除了表级锁以外，还有行级锁，在下文列出了行级锁以及在哪些情境下<productname>PostgreSQL</productname>会自动使用它们。
     行级锁的完整冲突表请见<xref linkend="row-lock-compatibility"/>。注意一个事务可能会在相同的行上保持冲突的锁，甚至是在不同的子事务中。
     但是除此之外，两个事务永远不可能在相同的行上持有冲突的锁。行级锁不影响数据查询，它们只阻塞对同一行的<emphasis>写入者和加锁者</emphasis>。
     行级锁在事务结束时或保存点回滚的时候释放，就像表级锁一样。
    </para>
<!-- pgdoc-cn_end sig_en=7298578a3ecc4fa818ff7ce51f6a8bf2 -->

     <variablelist>
<!-- pgdoc-cn_start sig_en=e33a3f58315334b783afe15100cc27b0 sig_cn_org=None source=14.1 
      <title>Row-Level Lock Modes</title>
________________________________________________________-->
      <title>行级锁模式</title>
<!-- pgdoc-cn_end sig_en=e33a3f58315334b783afe15100cc27b0 -->
      <varlistentry>
       <term>
        <literal>FOR UPDATE</literal>
       </term>
       <listitem>
<!-- pgdoc-cn_start sig_en=0a7c2f0934bb9153b981d2f666083b02 sig_cn_org=None source=14.1 
        <para>
         <literal>FOR UPDATE</literal> causes the rows retrieved by the
         <command>SELECT</command> statement to be locked as though for
         update.  This prevents them from being locked, modified or deleted by
         other transactions until the current transaction ends.  That is,
         other transactions that attempt <command>UPDATE</command>,
         <command>DELETE</command>,
         <command>SELECT FOR UPDATE</command>,
         <command>SELECT FOR NO KEY UPDATE</command>,
         <command>SELECT FOR SHARE</command> or
         <command>SELECT FOR KEY SHARE</command>
         of these rows will be blocked until the current transaction ends;
         conversely, <command>SELECT FOR UPDATE</command> will wait for a
         concurrent transaction that has run any of those commands on the
         same row,
         and will then lock and return the updated row (or no row, if the
         row was deleted).  Within a <literal>REPEATABLE READ</literal> or
         <literal>SERIALIZABLE</literal> transaction,
         however, an error will be thrown if a row to be locked has changed
         since the transaction started.  For further discussion see
         <xref linkend="applevel-consistency"/>.
        </para>
________________________________________________________-->
        <para>
         <literal>FOR UPDATE</literal>会导致由<command>SELECT</command>语句检索到的行被锁定，就好像它们要被更新。这可以阻止它们被其他事务锁定、修改或者删除，一直到当前事务结束。也就是说其他尝试<command>UPDATE</command>、<command>DELETE</command>、<command>SELECT FOR UPDATE</command>、<command>SELECT FOR NO KEY UPDATE</command>、<command>SELECT FOR SHARE</command>或者<command>SELECT FOR KEY SHARE</command>这些行的事务将被阻塞，直到当前事务结束。反过来，<command>SELECT FOR UPDATE</command>将等待已经在相同行上运行以上这些命令的并发事务，并且接着锁定并且返回被更新的行（或者没有行，因为行可能已被删除）。不过，在一个<literal>REPEATABLE READ</literal>或<literal>SERIALIZABLE</literal>事务中，如果一个要被锁定的行在事务开始后被更改，将会抛出一个错误。进一步的讨论请见<xref linkend="applevel-consistency"/>。
        </para>
<!-- pgdoc-cn_end sig_en=0a7c2f0934bb9153b981d2f666083b02 -->
<!-- pgdoc-cn_start sig_en=cfe8fd93dd4f78d1a155012e1b03ed3e sig_cn_org=None source=14.1 
        <para>
         The <literal>FOR UPDATE</literal> lock mode
         is also acquired by any <command>DELETE</command> on a row, and also by an
         <command>UPDATE</command> that modifies the values of certain columns.  Currently,
         the set of columns considered for the <command>UPDATE</command> case are those that
         have a unique index on them that can be used in a foreign key (so partial
         indexes and expressional indexes are not considered), but this may change
         in the future.
        </para>
________________________________________________________-->
        <para>        
         任何在一行上的<command>DELETE</command>命令也会获得<literal>FOR UPDATE</literal>锁模式，以及修改某些列的值的<command>UPDATE</command>也会获得该锁模式。
         当前<command>UPDATE</command>情况中被考虑的列集合是那些具有能用于外键的唯一索引的列（所以部分索引和表达式索引不被考虑），但是这种要求未来有可能会改变。
        </para>
<!-- pgdoc-cn_end sig_en=cfe8fd93dd4f78d1a155012e1b03ed3e -->
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>FOR NO KEY UPDATE</literal>
       </term>
       <listitem>
<!-- pgdoc-cn_start sig_en=9be9e455907c55a35b392ae5aa090c23 sig_cn_org=None source=14.1 
        <para>
         Behaves similarly to <literal>FOR UPDATE</literal>, except that the lock
         acquired is weaker: this lock will not block
         <literal>SELECT FOR KEY SHARE</literal> commands that attempt to acquire
         a lock on the same rows. This lock mode is also acquired by any
         <command>UPDATE</command> that does not acquire a <literal>FOR UPDATE</literal> lock.
        </para>
________________________________________________________-->
        <para>
         行为与<literal>FOR UPDATE</literal>类似，不过获得的锁较弱：这种锁将不会阻塞尝试在相同行上获得锁的<literal>SELECT FOR KEY SHARE</literal>命令。任何不获取<literal>FOR UPDATE</literal>锁的<command>UPDATE</command>也会获得这种锁模式。
        </para>
<!-- pgdoc-cn_end sig_en=9be9e455907c55a35b392ae5aa090c23 -->
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>FOR SHARE</literal>
       </term>
       <listitem>
<!-- pgdoc-cn_start sig_en=ebfea61970c3aecc40573585857cfeb4 sig_cn_org=None source=14.1 
        <para>
         Behaves similarly to <literal>FOR NO KEY UPDATE</literal>, except that it
         acquires a shared lock rather than exclusive lock on each retrieved
         row.  A shared lock blocks other transactions from performing
         <command>UPDATE</command>, <command>DELETE</command>,
         <command>SELECT FOR UPDATE</command> or
         <command>SELECT FOR NO KEY UPDATE</command> on these rows, but it does not
         prevent them from performing <command>SELECT FOR SHARE</command> or
         <command>SELECT FOR KEY SHARE</command>.
        </para>
________________________________________________________-->
        <para>
         行为与<literal>FOR NO KEY UPDATE</literal>类似，不过它在每个检索到的行上获得一个共享锁而不是排他锁。一个共享锁会阻塞其他事务在这些行上执行<command>UPDATE</command>、<command>DELETE</command>、<command>SELECT FOR UPDATE</command>或者<command>SELECT FOR NO KEY UPDATE</command>，但是它不会阻止它们执行<command>SELECT FOR SHARE</command>或者<command>SELECT FOR KEY SHARE</command>。
        </para>
<!-- pgdoc-cn_end sig_en=ebfea61970c3aecc40573585857cfeb4 -->
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>
        <literal>FOR KEY SHARE</literal>
       </term>
       <listitem>
<!-- pgdoc-cn_start sig_en=e22c763671f2c67ec9eb685f9fb61c3b sig_cn_org=None source=14.1 
        <para>
         Behaves similarly to <literal>FOR SHARE</literal>, except that the
         lock is weaker: <literal>SELECT FOR UPDATE</literal> is blocked, but not
         <literal>SELECT FOR NO KEY UPDATE</literal>.  A key-shared lock blocks
         other transactions from performing <command>DELETE</command> or
         any <command>UPDATE</command> that changes the key values, but not
         other <command>UPDATE</command>, and neither does it prevent
         <command>SELECT FOR NO KEY UPDATE</command>, <command>SELECT FOR SHARE</command>,
         or <command>SELECT FOR KEY SHARE</command>.
        </para>
________________________________________________________-->
        <para>
         行为与<literal>FOR SHARE</literal>类似，不过锁较弱：<literal>SELECT FOR UPDATE</literal>会被阻塞，但是<literal>SELECT FOR NO KEY UPDATE</literal>不会被阻塞。一个键共享锁会阻塞其他事务执行修改键值的<command>DELETE</command>或者<command>UPDATE</command>，但不会阻塞其他<command>UPDATE</command>，也不会阻止<command>SELECT FOR NO KEY UPDATE</command>、<command>SELECT FOR SHARE</command>或者<command>SELECT FOR KEY SHARE</command>。
        </para>
<!-- pgdoc-cn_end sig_en=e22c763671f2c67ec9eb685f9fb61c3b -->
       </listitem>
      </varlistentry>
     </variablelist>

<!-- pgdoc-cn_start sig_en=4cb1a2bd1990346153b93ba6375b41c3 sig_cn_org=None source=14.1 
    <para>
     <productname>PostgreSQL</productname> doesn't remember any
     information about modified rows in memory, so there is no limit on
     the number of rows locked at one time.  However, locking a row
     might cause a disk write, e.g., <command>SELECT FOR
     UPDATE</command> modifies selected rows to mark them locked, and so
     will result in disk writes.
    </para>
________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>不会在内存里保存任何关于已修改行的信息，因此对一次锁定的行数没有限制。 不过，锁住一行会导致一次磁盘写，例如， <command>SELECT FOR UPDATE</command>将修改选中的行以标记它们被锁住，并且因此会导致磁盘写入。
    </para>
<!-- pgdoc-cn_end sig_en=4cb1a2bd1990346153b93ba6375b41c3 -->

    <table tocentry="1" id="row-lock-compatibility">
<!-- pgdoc-cn_start sig_en=a162ae0e7ec36fab26e1d183ee6fc4b8 sig_cn_org=None source=14.1 
     <title>Conflicting Row-Level Locks</title>
________________________________________________________-->
     <title>冲突的行级锁</title>
<!-- pgdoc-cn_end sig_en=a162ae0e7ec36fab26e1d183ee6fc4b8 -->
     <tgroup cols="5">
      <colspec colname="col1"    colwidth="1.5*"/>
      <colspec colname="lockst"  colwidth="1*"/>
      <colspec colname="col3"    colwidth="1*"/>
      <colspec colname="col4"    colwidth="1*"/>
      <colspec colname="lockend" colwidth="1*"/>
      <spanspec namest="lockst" nameend="lockend" spanname="lockreq"/>
      <thead>
<!-- pgdoc-cn_start sig_en=79212bb995f849c076ae3f36fe61df3e sig_cn_org=None source=14.1 
       <row>
        <entry morerows="1">Requested Lock Mode</entry>
        <entry spanname="lockreq">Current Lock Mode</entry>
       </row>
________________________________________________________-->
       <row>
        <entry morerows="1">要求的锁模式</entry>
        <entry spanname="lockreq">当前的锁模式</entry>
       </row>
<!-- pgdoc-cn_end sig_en=79212bb995f849c076ae3f36fe61df3e -->
<!-- pgdoc-cn_start sig_en=1ae984143d63d7bdf80fa7ccf00379d3 sig_cn_org=None source=14.1 
       <row>
        <entry>FOR KEY SHARE</entry>
        <entry>FOR SHARE</entry>
        <entry>FOR NO KEY UPDATE</entry>
        <entry>FOR UPDATE</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>FOR KEY SHARE</entry>
        <entry>FOR SHARE</entry>
        <entry>FOR NO KEY UPDATE</entry>
        <entry>FOR UPDATE</entry>
       </row>
<!-- pgdoc-cn_end sig_en=1ae984143d63d7bdf80fa7ccf00379d3 -->
      </thead>
      <tbody>
<!-- pgdoc-cn_start sig_en=1d68514ce3d02f5a83112d43f10988e2 sig_cn_org=None source=14.1 
       <row>
        <entry>FOR KEY SHARE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>FOR KEY SHARE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
       </row>
<!-- pgdoc-cn_end sig_en=1d68514ce3d02f5a83112d43f10988e2 -->
<!-- pgdoc-cn_start sig_en=b75e176bd4909dc0ae23c83e241ec819 sig_cn_org=None source=14.1 
       <row>
        <entry>FOR SHARE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>FOR SHARE</entry>
        <entry align="center"></entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
<!-- pgdoc-cn_end sig_en=b75e176bd4909dc0ae23c83e241ec819 -->
<!-- pgdoc-cn_start sig_en=f7d6b20cf727626991ffd39c5a238de1 sig_cn_org=None source=14.1 
       <row>
        <entry>FOR NO KEY UPDATE</entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>FOR NO KEY UPDATE</entry>
        <entry align="center"></entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
<!-- pgdoc-cn_end sig_en=f7d6b20cf727626991ffd39c5a238de1 -->
<!-- pgdoc-cn_start sig_en=03d754b372ea80f0fde230f8a15ed0ed sig_cn_org=None source=14.1 
       <row>
        <entry>FOR UPDATE</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
________________________________________________________-->
       <row>
        <entry>FOR UPDATE</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
        <entry align="center">X</entry>
       </row>
<!-- pgdoc-cn_end sig_en=03d754b372ea80f0fde230f8a15ed0ed -->
      </tbody>
     </tgroup>
    </table>
   </sect2>

   <sect2 id="locking-pages">
<!-- pgdoc-cn_start sig_en=e4f37926422f25878867ca205c5ec16d sig_cn_org=None source=14.1 
    <title>Page-Level Locks</title>
________________________________________________________-->
    <title>页级锁</title>
<!-- pgdoc-cn_end sig_en=e4f37926422f25878867ca205c5ec16d -->

<!-- pgdoc-cn_start sig_en=0f223311c0e47ae44daad4c6dbe09415 sig_cn_org=None source=14.1 
    <para>
     In addition to table and row locks, page-level share/exclusive locks are
     used to control read/write access to table pages in the shared buffer
     pool.  These locks are released immediately after a row is fetched or
     updated.  Application developers normally need not be concerned with
     page-level locks, but they are mentioned here for completeness.
    </para>
________________________________________________________-->
    <para>
     除了表级别和行级别的锁以外，页面级别的共享/排他锁被用来控制对共享缓冲池中表页面的读/写。 这些锁在行被抓取或者更新后马上被释放。应用开发者通常不需要关心页级锁，我们在这里提到它们只是为了完整。
    </para>
<!-- pgdoc-cn_end sig_en=0f223311c0e47ae44daad4c6dbe09415 -->

   </sect2>

   <sect2 id="locking-deadlocks">
<!-- pgdoc-cn_start sig_en=bbf3216119a3bed94acc339cbd3c1890 sig_cn_org=None source=14.1 
    <title>Deadlocks</title>
________________________________________________________-->
    <title>死锁</title>
<!-- pgdoc-cn_end sig_en=bbf3216119a3bed94acc339cbd3c1890 -->

<!-- pgdoc-cn_start sig_en=fe29d045ab4978ec74c120bdf904408c sig_cn_org=None source=14.1 
    <indexterm zone="locking-deadlocks">
     <primary>deadlock</primary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="locking-deadlocks">
     <primary>死锁</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=fe29d045ab4978ec74c120bdf904408c -->

<!-- pgdoc-cn_start sig_en=21aa3548deaa7e2cab169bf6456e1cf9 sig_cn_org=None source=14.1 
    <para>
     The use of explicit locking can increase the likelihood of
     <firstterm>deadlocks</firstterm>, wherein two (or more) transactions each
     hold locks that the other wants.  For example, if transaction 1
     acquires an exclusive lock on table A and then tries to acquire
     an exclusive lock on table B, while transaction 2 has already
     exclusive-locked table B and now wants an exclusive lock on table
     A, then neither one can proceed.
     <productname>PostgreSQL</productname> automatically detects
     deadlock situations and resolves them by aborting one of the
     transactions involved, allowing the other(s) to complete.
     (Exactly which transaction will be aborted is difficult to
     predict and should not be relied upon.)
    </para>
________________________________________________________-->
    <para>
     显式锁定的使用可能会增加<firstterm>死锁</firstterm>的可能性，死锁是指两个（或多个）事务相互持有对方想要的锁。例如，如果事务 1 在表 A 上获得一个排他锁，同时试图获取一个在表 B 上的排他锁， 而事务 2 已经持有表 B 的排他锁，同时却正在请求表 A 上的一个排他锁，那么两个事务就都不能进行下去。<productname>PostgreSQL</productname>能够自动检测到死锁情况并且会通过中断其中一个事务从而允许其它事务完成来解决这个问题（具体哪个事务会被中断是很难预测的，而且也不应该依靠这样的预测）。
    </para>
<!-- pgdoc-cn_end sig_en=21aa3548deaa7e2cab169bf6456e1cf9 -->

<!-- pgdoc-cn_start sig_en=f81e48b7556ec63760d457295eec38ad sig_cn_org=None source=14.1 
    <para>
     Note that deadlocks can also occur as the result of row-level
     locks (and thus, they can occur even if explicit locking is not
     used). Consider the case in which two concurrent
     transactions modify a table. The first transaction executes:

<screen>
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 11111;
</screen>

     This acquires a row-level lock on the row with the specified
     account number. Then, the second transaction executes:

<screen>
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 22222;
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 11111;
</screen>

     The first <command>UPDATE</command> statement successfully
     acquires a row-level lock on the specified row, so it succeeds in
     updating that row. However, the second <command>UPDATE</command>
     statement finds that the row it is attempting to update has
     already been locked, so it waits for the transaction that
     acquired the lock to complete. Transaction two is now waiting on
     transaction one to complete before it continues execution. Now,
     transaction one executes:

<screen>
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 22222;
</screen>

     Transaction one attempts to acquire a row-level lock on the
     specified row, but it cannot: transaction two already holds such
     a lock. So it waits for transaction two to complete. Thus,
     transaction one is blocked on transaction two, and transaction
     two is blocked on transaction one: a deadlock
     condition. <productname>PostgreSQL</productname> will detect this
     situation and abort one of the transactions.
    </para>
________________________________________________________-->
    <para>
     要注意死锁也可能会作为行级锁的结果而发生（并且因此，它们即使在没有使用显式锁定的情况下也会发生)。考虑如下情况，两个并发事务在修改一个表。第一个事务执行：

<screen>
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 11111;
</screen>

     这样就在指定帐号的行上获得了一个行级锁。然后，第二个事务执行：

<screen>
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 22222;
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 11111;
</screen>

     第一个<command>UPDATE</command>语句成功地在指定行上获得了一个行级锁，因此它成功更新了该行。 但是第二个<command>UPDATE</command>语句发现它试图更新的行已经被锁住了，因此它等待持有该锁的事务结束。事务二现在就在等待事务一结束，然后再继续执行。现在，事务一执行：

<screen>
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 22222;
</screen>

     事务一试图在指定行上获得一个行级锁，但是它得不到：事务二已经持有了这样的锁。所以它要等待事务二完成。因此，事务一被事务二阻塞，而事务二也被事务一阻塞：一个死锁。 <productname>PostgreSQL</productname>将检测这样的情况并中断其中一个事务。
    </para>
<!-- pgdoc-cn_end sig_en=f81e48b7556ec63760d457295eec38ad -->

<!-- pgdoc-cn_start sig_en=d10074f7ac9b25de7780716306c3283a sig_cn_org=None source=14.1 
    <para>
     The best defense against deadlocks is generally to avoid them by
     being certain that all applications using a database acquire
     locks on multiple objects in a consistent order. In the example
     above, if both transactions
     had updated the rows in the same order, no deadlock would have
     occurred. One should also ensure that the first lock acquired on
     an object in a transaction is the most restrictive mode that will be
     needed for that object.  If it is not feasible to verify this in
     advance, then deadlocks can be handled on-the-fly by retrying
     transactions that abort due to deadlocks.
    </para>
________________________________________________________-->
    <para>
     防止死锁的最好方法通常是保证所有使用一个数据库的应用都以一致的顺序在多个对象上获得锁。在上面的例子里，如果两个事务以同样的顺序更新那些行，那么就不会发生死锁。 我们也应该保证一个事务中在一个对象上获得的第一个锁是该对象需要的最严格的锁模式。如果我们无法提前验证这些，那么可以通过重试因死锁而中断的事务来即时处理死锁。
    </para>
<!-- pgdoc-cn_end sig_en=d10074f7ac9b25de7780716306c3283a -->

<!-- pgdoc-cn_start sig_en=b325502bff37bbcc8cb9e8f358816a8e sig_cn_org=None source=14.1 
    <para>
     So long as no deadlock situation is detected, a transaction seeking
     either a table-level or row-level lock will wait indefinitely for
     conflicting locks to be released.  This means it is a bad idea for
     applications to hold transactions open for long periods of time
     (e.g., while waiting for user input).
    </para>
________________________________________________________-->
    <para>
     只要没有检测到死锁情况，寻求一个表级或行级锁的事务将无限等待冲突锁被释放。这意味着一个应用长时间保持事务开启不是什么好事（例如等待用户输入）。
    </para>
<!-- pgdoc-cn_end sig_en=b325502bff37bbcc8cb9e8f358816a8e -->
   </sect2>

   <sect2 id="advisory-locks">
<!-- pgdoc-cn_start sig_en=c5ec9df8b0409db0356d23c42fa95c90 sig_cn_org=None source=14.1 
    <title>Advisory Locks</title>
________________________________________________________-->
    <title>咨询锁</title>
<!-- pgdoc-cn_end sig_en=c5ec9df8b0409db0356d23c42fa95c90 -->

<!-- pgdoc-cn_start sig_en=1cc270c9c4f3f3a47b1ea789a9b69b70 sig_cn_org=None source=14.1 
    <indexterm zone="advisory-locks">
     <primary>advisory lock</primary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="advisory-locks">
     <primary>咨询锁</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=1cc270c9c4f3f3a47b1ea789a9b69b70 -->

<!-- pgdoc-cn_start sig_en=2d7bf8b778bc85a4de8f173ea4f19957 sig_cn_org=None source=14.1 
    <indexterm zone="advisory-locks">
     <primary>lock</primary>
     <secondary>advisory</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="advisory-locks">
     <primary>锁</primary>
     <secondary>咨询</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=2d7bf8b778bc85a4de8f173ea4f19957 -->

<!-- pgdoc-cn_start sig_en=6e8d4a536ccf432c7b09858fb3a1f51b sig_cn_org=None source=14.1 
    <para>
     <productname>PostgreSQL</productname> provides a means for
     creating locks that have application-defined meanings.  These are
     called <firstterm>advisory locks</firstterm>, because the system does not
     enforce their use &mdash; it is up to the application to use them
     correctly.  Advisory locks can be useful for locking strategies
     that are an awkward fit for the MVCC model.
     For example, a common use of advisory locks is to emulate pessimistic
     locking strategies typical of so-called <quote>flat file</quote> data
     management systems.
     While a flag stored in a table could be used for the same purpose,
     advisory locks are faster, avoid table bloat, and are automatically
     cleaned up by the server at the end of the session.
    </para>
________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>提供了一种方法创建由应用定义其含义的锁。这种锁被称为<firstterm>咨询锁</firstterm>，因为系统并不强迫其使用 &mdash; 而是由应用来保证其正确的使用。咨询锁可用于 MVCC 模型不适用的锁定策略。例如，咨询锁的一种常用用法是模拟所谓<quote>平面文件</quote>数据管理系统典型的悲观锁策略。虽然一个存储在表中的标志可以被用于相同目的，但咨询锁更快、可以避免表膨胀并且会由服务器在会话结束时自动清理。
    </para>
<!-- pgdoc-cn_end sig_en=6e8d4a536ccf432c7b09858fb3a1f51b -->

<!-- pgdoc-cn_start sig_en=78a8fc4103c622c7af451cb2423cdc45 sig_cn_org=None source=14.1 
    <para>
     There are two ways to acquire an advisory lock in
     <productname>PostgreSQL</productname>: at session level or at
     transaction level.
     Once acquired at session level, an advisory lock is held until
     explicitly released or the session ends.  Unlike standard lock requests,
     session-level advisory lock requests do not honor transaction semantics:
     a lock acquired during a transaction that is later rolled back will still
     be held following the rollback, and likewise an unlock is effective even
     if the calling transaction fails later.  A lock can be acquired multiple
     times by its owning process; for each completed lock request there must
     be a corresponding unlock request before the lock is actually released.
     Transaction-level lock requests, on the other hand, behave more like
     regular lock requests: they are automatically released at the end of the
     transaction, and there is no explicit unlock operation.  This behavior
     is often more convenient than the session-level behavior for short-term
     usage of an advisory lock.
     Session-level and transaction-level lock requests for the same advisory
     lock identifier will block each other in the expected way.
     If a session already holds a given advisory lock, additional requests by
     it will always succeed, even if other sessions are awaiting the lock; this
     statement is true regardless of whether the existing lock hold and new
     request are at session level or transaction level.
    </para>
________________________________________________________-->
    <para>
     有两种方法在<productname>PostgreSQL</productname>中获取一个咨询锁：在会话级别或在事务级别。一旦在会话级别获得了咨询锁，它将被保持直到被显式释放或会话结束。不同于标准锁请求，会话级咨询锁请求不尊重事务语义：在一个后来被回滚的事务中得到的锁在回滚后仍然被保持，并且同样即使调用它的事务后来失败一个解锁也是有效的。一个锁在它所属的进程中可以被获取多次；对于每一个完成的锁请求必须有一个相应的解锁请求，直至锁被真正释放。在另一方面，事务级锁请求的行为更像普通锁请求：在事务结束时会自动释放它们，并且没有显式的解锁操作。这种行为通常比会话级别的行为更方便，因为它使用一个咨询锁的时间更短。对于同一咨询锁标识符的会话级别和事务级别的锁请求按照期望将彼此阻塞。如果一个会话已经持有了一个给定的咨询锁，由它发出的附加请求将总是成功，即使有其他会话在等待该锁；不管现有的锁和新请求是处在会话级别还是事务级别，这种说法都是真的。
    </para>
<!-- pgdoc-cn_end sig_en=78a8fc4103c622c7af451cb2423cdc45 -->

<!-- pgdoc-cn_start sig_en=4679f7249f8129ccce16a2be007d6ff8 sig_cn_org=None source=14.1 
    <para>
     Like all locks in
     <productname>PostgreSQL</productname>, a complete list of advisory locks
     currently held by any session can be found in the <link
     linkend="view-pg-locks"><structname>pg_locks</structname></link> system
     view.
    </para>
________________________________________________________-->
    <para>
     和所有<productname>PostgreSQL</productname>中的锁一样，当前被任何会话所持有的咨询锁的完整列表可以在<link linkend="view-pg-locks"><structname>pg_locks</structname></link>系统视图中找到。
    </para>
<!-- pgdoc-cn_end sig_en=4679f7249f8129ccce16a2be007d6ff8 -->

<!-- pgdoc-cn_start sig_en=a15a0aa003df20ab36c240cfbfd5815a sig_cn_org=None source=14.1 
    <para>
     Both advisory locks and regular locks are stored in a shared memory
     pool whose size is defined by the configuration variables
     <xref linkend="guc-max-locks-per-transaction"/> and
     <xref linkend="guc-max-connections"/>.
     Care must be taken not to exhaust this
     memory or the server will be unable to grant any locks at all.
     This imposes an upper limit on the number of advisory locks
     grantable by the server, typically in the tens to hundreds of thousands
     depending on how the server is configured.
    </para>
________________________________________________________-->
    <para>
     咨询锁和普通锁都被存储在一个共享内存池中，它的尺寸由<xref linkend="guc-max-locks-per-transaction"/>和<xref linkend="guc-max-connections"/>配置变量定义。 必须当心不要耗尽这些内存，否则服务器将不能再授予任何锁。这对服务器可以授予的咨询锁数量设置了一个上限，根据服务器的配置不同，这个限制通常是数万到数十万。
    </para>
<!-- pgdoc-cn_end sig_en=a15a0aa003df20ab36c240cfbfd5815a -->

<!-- pgdoc-cn_start sig_en=73471ee4eaa6e222859f8ad2c547372e sig_cn_org=None source=14.1 
    <para>
     In certain cases using advisory locking methods, especially in queries
     involving explicit ordering and <literal>LIMIT</literal> clauses, care must be
     taken to control the locks acquired because of the order in which SQL
     expressions are evaluated.  For example:
<screen>
SELECT pg_advisory_lock(id) FROM foo WHERE id = 12345; -&minus; ok
SELECT pg_advisory_lock(id) FROM foo WHERE id &gt; 12345 LIMIT 100; -&minus; danger!
SELECT pg_advisory_lock(q.id) FROM
(
  SELECT id FROM foo WHERE id &gt; 12345 LIMIT 100
) q; -&minus; ok
</screen>
     In the above queries, the second form is dangerous because the
     <literal>LIMIT</literal> is not guaranteed to be applied before the locking
     function is executed.  This might cause some locks to be acquired
     that the application was not expecting, and hence would fail to release
     (until it ends the session).
     From the point of view of the application, such locks
     would be dangling, although still viewable in
     <structname>pg_locks</structname>.
    </para>
________________________________________________________-->
    <para>
     在使用咨询锁方法的特定情况下，特别是查询中涉及显式排序和<literal>LIMIT</literal>子句时，由于 SQL 表达式被计算的顺序，必须小心控制锁的获取。例如：
<screen>
SELECT pg_advisory_lock(id) FROM foo WHERE id = 12345; -- ok
SELECT pg_advisory_lock(id) FROM foo WHERE id &gt; 12345 LIMIT 100; -- danger!
SELECT pg_advisory_lock(q.id) FROM
(
  SELECT id FROM foo WHERE id &gt; 12345 LIMIT 100
) q; -- ok
</screen>
     在上述查询中，第二种形式是危险的，因为不能保证在锁定函数被执行之前应用<literal>LIMIT</literal>。这可能导致获得某些应用不期望的锁，并因此在会话结束之前无法释放。 从应用的角度来看，这样的锁将被挂起，虽然它们仍然在<structname>pg_locks</structname>中可见。
    </para>
<!-- pgdoc-cn_end sig_en=73471ee4eaa6e222859f8ad2c547372e -->

<!-- pgdoc-cn_start sig_en=e410660304887edb6d7ba928e06da950 sig_cn_org=None source=14.1 
    <para>
     The functions provided to manipulate advisory locks are described in
     <xref linkend="functions-advisory-locks"/>.
    </para>
________________________________________________________-->
    <para>
     提供的操作咨询锁函数在<xref linkend="functions-advisory-locks"/>中描述。
    </para>
<!-- pgdoc-cn_end sig_en=e410660304887edb6d7ba928e06da950 -->
   </sect2>

  </sect1>

  <sect1 id="applevel-consistency">
<!-- pgdoc-cn_start sig_en=89d6963c426fd75d647522f8677bd6f0 sig_cn_org=None source=14.1 
   <title>Data Consistency Checks at the Application Level</title>
________________________________________________________-->
   <title>应用级别的数据完整性检查</title>
<!-- pgdoc-cn_end sig_en=89d6963c426fd75d647522f8677bd6f0 -->

<!-- pgdoc-cn_start sig_en=975493dbe68524cde8ae37eaee66bc30 sig_cn_org=None source=14.1 
   <para>
    It is very difficult to enforce business rules regarding data integrity
    using Read Committed transactions because the view of the data is
    shifting with each statement, and even a single statement may not
    restrict itself to the statement's snapshot if a write conflict occurs.
   </para>
________________________________________________________-->
   <para>
    对于使用读已提交事务的数据完整性强制业务规则非常困难，因为对每一个语句数据视图都在变化，并且如果一个写冲突发生即使一个单一语句也不能把它自己限制到该语句的快照。
   </para>
<!-- pgdoc-cn_end sig_en=975493dbe68524cde8ae37eaee66bc30 -->

<!-- pgdoc-cn_start sig_en=afc10fde996f1c5281097249b861dd52 sig_cn_org=None source=14.1 
   <para>
    While a Repeatable Read transaction has a stable view of the data
    throughout its execution, there is a subtle issue with using
    <acronym>MVCC</acronym> snapshots for data consistency checks, involving
    something known as <firstterm>read/write conflicts</firstterm>.
    If one transaction writes data and a concurrent transaction attempts
    to read the same data (whether before or after the write), it cannot
    see the work of the other transaction.  The reader then appears to have
    executed first regardless of which started first or which committed
    first.  If that is as far as it goes, there is no problem, but
    if the reader also writes data which is read by a concurrent transaction
    there is now a transaction which appears to have run before either of
    the previously mentioned transactions.  If the transaction which appears
    to have executed last actually commits first, it is very easy for a
    cycle to appear in a graph of the order of execution of the transactions.
    When such a cycle appears, integrity checks will not work correctly
    without some help.
   </para>
________________________________________________________-->
   <para>
    虽然一个可重复读事务在其执行期间有一个稳定的数据视图，在使用<acronym>MVCC</acronym>快照进行数据一致性检查时也有一个小问题，它涉及到被称为<firstterm>读/写冲突</firstterm>的东西。如果一个事务写数据并且一个并发事务尝试读相同的数据（不管是在写之前还是之后），它不能看到其他事务的工作。读取事务看起来是第一个执行的，不管哪个是第一个启动或者哪个是第一个提交。如果就到此为止，则没有问题，但是如果读取者也写入被一个并发事务读取的数据，现在有一个事务好像是已经在前面提到的任何一个事务之前运行。如果看起来最后执行的事务实际上第一个提交，在这些事务的执行顺序图中很容易出现一个环。当这样一个环出现时，完整性检查在没有任何帮助的情况下将不会正确地工作。
   </para>
<!-- pgdoc-cn_end sig_en=afc10fde996f1c5281097249b861dd52 -->

<!-- pgdoc-cn_start sig_en=9b84d2fdb3a3fdd0b453d620e2ea99cb sig_cn_org=None source=14.1 
   <para>
    As mentioned in <xref linkend="xact-serializable"/>, Serializable
    transactions are just Repeatable Read transactions which add
    nonblocking monitoring for dangerous patterns of read/write conflicts.
    When a pattern is detected which could cause a cycle in the apparent
    order of execution, one of the transactions involved is rolled back to
    break the cycle.
   </para>
________________________________________________________-->
   <para>
    正如<xref linkend="xact-serializable"/>中提到的，可序列化事务仅仅是可重复读事务增加了对读/写冲突的危险模式的非阻塞监控。当检测到一个可能导致表面的执行顺序中产生环的模式，涉及到的一个事务将被回滚来打破该环。
   </para>
<!-- pgdoc-cn_end sig_en=9b84d2fdb3a3fdd0b453d620e2ea99cb -->

   <sect2 id="serializable-consistency">
<!-- pgdoc-cn_start sig_en=4c771a366a6921833fbeffd0276a5bc8 sig_cn_org=None source=14.1 
    <title>Enforcing Consistency with Serializable Transactions</title>
________________________________________________________-->
    <title>用可序列化事务来强制一致性</title>
<!-- pgdoc-cn_end sig_en=4c771a366a6921833fbeffd0276a5bc8 -->

<!-- pgdoc-cn_start sig_en=b77a40795c05d2c32b0a21f9e3d63a74 sig_cn_org=None source=14.1 
    <para>
     If the Serializable transaction isolation level is used for all writes
     and for all reads which need a consistent view of the data, no other
     effort is required to ensure consistency.  Software from other
     environments which is written to use serializable transactions to
     ensure consistency should <quote>just work</quote> in this regard in
     <productname>PostgreSQL</productname>.
    </para>
________________________________________________________-->
    <para>
     如果可序列化事务隔离级别被用于所有需要一个一致数据视图的写入和读取，不需要其他的工作来保证一致性。在<productname>PostgreSQL</productname>中，来自于其他环境的被编写成使用可序列化事务来保证一致性的软件应该<quote>只工作</quote>在这一点上。
    </para>
<!-- pgdoc-cn_end sig_en=b77a40795c05d2c32b0a21f9e3d63a74 -->

<!-- pgdoc-cn_start sig_en=fcb1dcec9b09cffe0fb7dade79c72a0e sig_cn_org=None source=14.1 
    <para>
     When using this technique, it will avoid creating an unnecessary burden
     for application programmers if the application software goes through a
     framework which automatically retries transactions which are rolled
     back with a serialization failure.  It may be a good idea to set
     <literal>default_transaction_isolation</literal> to <literal>serializable</literal>.
     It would also be wise to take some action to ensure that no other
     transaction isolation level is used, either inadvertently or to
     subvert integrity checks, through checks of the transaction isolation
     level in triggers.
    </para>
________________________________________________________-->
    <para>
     当使用这种技术时，如果应用软件通过一个框架来自动重试由于序列化错误而回滚的事务，它将避免为应用程序员带来不必要的负担。把<literal>default_transaction_isolation</literal>设置为<literal>serializable</literal>可能是个好主意。通过触发器中的事务隔离级别检查来采取某些动作来保证没有其他事务隔离级别被使用（由于疏忽或者为了破坏完整性检查）也是明智的。
    </para>
<!-- pgdoc-cn_end sig_en=fcb1dcec9b09cffe0fb7dade79c72a0e -->

<!-- pgdoc-cn_start sig_en=c19d915a68b355f17edae3da255d606f sig_cn_org=None source=14.1 
    <para>
     See <xref linkend="xact-serializable"/> for performance suggestions.
    </para>
________________________________________________________-->
    <para>
     性能建议见<xref linkend="xact-serializable"/>。
    </para>
<!-- pgdoc-cn_end sig_en=c19d915a68b355f17edae3da255d606f -->

    <warning>
<!-- pgdoc-cn_start sig_en=d35aa1fa4608235fce62e55e45942ca0 sig_cn_org=None source=14.1 
     <para>
      This level of integrity protection using Serializable transactions
      does not yet extend to hot standby mode (<xref linkend="hot-standby"/>).
      Because of that, those using hot standby may want to use Repeatable
      Read and explicit locking on the primary.
     </para>
________________________________________________________-->
     <para>
      这个级别的使用可序列化事务的完整性保护还没有扩展到热备份模式（<xref linkend="hot-standby"/>）。由于这个原因，那些使用热备份的系统可能想要在主数据库上使用可重复读和显式锁定。
     </para>
<!-- pgdoc-cn_end sig_en=d35aa1fa4608235fce62e55e45942ca0 -->
    </warning>
   </sect2>

   <sect2 id="non-serializable-consistency">
<!-- pgdoc-cn_start sig_en=0cf575f487ae16a0582f8080018f5d0d sig_cn_org=None source=14.1 
    <title>Enforcing Consistency with Explicit Blocking Locks</title>
________________________________________________________-->
    <title>使用显式锁定强制一致性</title>
<!-- pgdoc-cn_end sig_en=0cf575f487ae16a0582f8080018f5d0d -->

<!-- pgdoc-cn_start sig_en=73f9ddd32238d8b09122aad388bd58df sig_cn_org=None source=14.1 
    <para>
     When non-serializable writes are possible,
     to ensure the current validity of a row and protect it against
     concurrent updates one must use <command>SELECT FOR UPDATE</command>,
     <command>SELECT FOR SHARE</command>, or an appropriate <command>LOCK
     TABLE</command> statement.  (<command>SELECT FOR UPDATE</command>
     and <command>SELECT FOR SHARE</command> lock just the
     returned rows against concurrent updates, while <command>LOCK
     TABLE</command> locks the whole table.)  This should be taken into
     account when porting applications to
     <productname>PostgreSQL</productname> from other environments.
    </para>
________________________________________________________-->
    <para>
     当可以使用非可序列化写时，要保证一行的当前有效性并保护它不受并发更新的影响，我们必须使用<command>SELECT FOR UPDATE</command>、<command>SELECT FOR SHARE</command>或一个合适的<command>LOCK TABLE</command> 语句（<command>SELECT FOR UPDATE</command>和<command>SELECT FOR SHARE</command>锁只针对并发更新返回行，而<command>LOCK TABLE</command>会锁住整个表）。当从其他环境移植应用到<productname>PostgreSQL</productname>时需要考虑这些。
    </para>
<!-- pgdoc-cn_end sig_en=73f9ddd32238d8b09122aad388bd58df -->

<!-- pgdoc-cn_start sig_en=caf61eb939d4c7de1315d59c8d11721f sig_cn_org=None source=14.1 
    <para>
     Also of note to those converting from other environments is the fact
     that <command>SELECT FOR UPDATE</command> does not ensure that a
     concurrent transaction will not update or delete a selected row.
     To do that in <productname>PostgreSQL</productname> you must actually
     update the row, even if no values need to be changed.
     <command>SELECT FOR UPDATE</command> <emphasis>temporarily blocks</emphasis>
     other transactions from acquiring the same lock or executing an
     <command>UPDATE</command> or <command>DELETE</command> which would
     affect the locked row, but once the transaction holding this lock
     commits or rolls back, a blocked transaction will proceed with the
     conflicting operation unless an actual <command>UPDATE</command> of
     the row was performed while the lock was held.
    </para>
________________________________________________________-->
    <para>
     关于这些来自其他环境的转换还需要注意的是<command>SELECT FOR UPDATE</command>不保证一个并发事务将不会更新或删除一个被选中的行。要在<productname>PostgreSQL</productname>中这样做，你必须真正地更新该行，即便没有值需要被改变。<command>SELECT FOR UPDATE</command> <emphasis>临时阻塞</emphasis>其他事务，让它们不能获取该相同的锁或者执行一个会影响被锁定行的<command>UPDATE</command>或<command>DELETE</command>，但是一旦正持有该所锁的事务提交或回滚，一个被阻塞的事务将继续执行冲突操作，除非当锁被持有时一个该行的实际<command>UPDATE</command>被执行。
    </para>
<!-- pgdoc-cn_end sig_en=caf61eb939d4c7de1315d59c8d11721f -->

<!-- pgdoc-cn_start sig_en=a44530b15f364e79415b516ee7b30e2c sig_cn_org=None source=14.1 
    <para>
     Global validity checks require extra thought under
     non-serializable <acronym>MVCC</acronym>.
     For example, a banking application might wish to check that the sum of
     all credits in one table equals the sum of debits in another table,
     when both tables are being actively updated.  Comparing the results of two
     successive <literal>SELECT sum(...)</literal> commands will not work reliably in
     Read Committed mode, since the second query will likely include the results
     of transactions not counted by the first.  Doing the two sums in a
     single repeatable read transaction will give an accurate picture of only the
     effects of transactions that committed before the repeatable read transaction
     started &mdash; but one might legitimately wonder whether the answer is still
     relevant by the time it is delivered.  If the repeatable read transaction
     itself applied some changes before trying to make the consistency check,
     the usefulness of the check becomes even more debatable, since now it
     includes some but not all post-transaction-start changes.  In such cases
     a careful person might wish to lock all tables needed for the check,
     in order to get an indisputable picture of current reality.  A
     <literal>SHARE</literal> mode (or higher) lock guarantees that there are no
     uncommitted changes in the locked table, other than those of the current
     transaction.
    </para>
________________________________________________________-->
    <para>
     在非可序列化<acronym>MVCC</acronym>环境下，全局有效性检查需要一些额外的考虑。例如，一个银行应用可能会希望检查一个表中的所有扣款总和等于另外一个表中的收款总和，同时两个表还会被更新。比较两个连续的在读已提交模式下不会可靠工作的<literal>SELECT sum(...)</literal>命令， 因为第二个查询很可能会包含没有被第一个查询考虑的事务提交的结果。在一个单一的可重复读事务里进行两个求和则给出在可串行化事务开始之前提交的所有事务产生的准确结果 &mdash; 但有人可能会合理地置疑在结果被递交的时候，它们是否仍然相关。 如果可重复读事务本身在尝试做一致性检查之前应用了某些变更，那么检查的有用性就更加值得讨论了， 因为现在它包含了一些（但不是全部）事务开始后的变化。 在这种情况下，一个小心的人可能希望锁住所有需要检查的表，这样才能获得一个无可置疑的当前现状的图像。 一个<literal>SHARE</literal>模式（或者更高）的锁保证在被锁定表中除了当前事务所作的更改之外，没有未提交的更改。
    </para>
<!-- pgdoc-cn_end sig_en=a44530b15f364e79415b516ee7b30e2c -->

<!-- pgdoc-cn_start sig_en=5be51d1b82e7dab9bcfa991b2f75434b sig_cn_org=5c7b83a0859791f62cfc7954fd73b7c0 source=15.7 
    <para>
     Note also that if one is relying on explicit locking to prevent concurrent
     changes, one should either use Read Committed mode, or in Repeatable Read
     mode be careful to obtain
     locks before performing queries.  A lock obtained by a
     repeatable read transaction guarantees that no other transactions modifying
     the table are still running, but if the snapshot seen by the
     transaction predates obtaining the lock, it might predate some now-committed
     changes in the table.  A repeatable read transaction's snapshot is actually
     frozen at the start of its first query or data-modification command
     (<literal>SELECT</literal>, <literal>INSERT</literal>,
     <literal>UPDATE</literal>, <literal>DELETE</literal>, or
     <literal>MERGE</literal>), so it is possible to obtain locks explicitly
     before the snapshot is frozen.
    </para>
________________________________________________________-->
    <para>
     注意，如果依赖显式锁定来防止并发更改，应该使用读提交模式，或者在可重复读模式下在执行查询之前小心获取锁定。
     可重复读事务获取的锁定保证没有其他修改表的事务仍在运行，但如果事务看到的快照早于获取锁定，则可能早于表中现在已提交的某些更改。
     可重复读事务的快照实际上在其第一个查询或数据修改命令（<literal>SELECT</literal>、<literal>INSERT</literal>、
     <literal>UPDATE</literal>、<literal>DELETE</literal>或<literal>MERGE</literal>）开始时被冻结，因此可以在快照被冻结之前显式获取锁定。
    </para>
<!-- pgdoc-cn_end sig_en=5be51d1b82e7dab9bcfa991b2f75434b -->
   </sect2>
  </sect1>

  <sect1 id="mvcc-serialization-failure-handling">
<!-- pgdoc-cn_start sig_en=7b532bcc0973cd4e98d1200ad909f652 sig_cn_org=d1d8caac0363a941a63e0e38bd921ef8 source=15.7 
   <title>Serialization Failure Handling</title>
________________________________________________________-->
   <title>序列化失败处理</title>
<!-- pgdoc-cn_end sig_en=7b532bcc0973cd4e98d1200ad909f652 -->

<!-- pgdoc-cn_start sig_en=f5068fc4996279e5d01060d97ea0e44b sig_cn_org=3e0131bba13a733f4a3e9c708251e3cc source=15.7 
   <indexterm>
    <primary>serialization failure</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>序列化失败</primary>
</indexterm>
<!-- pgdoc-cn_end sig_en=f5068fc4996279e5d01060d97ea0e44b -->
<!-- pgdoc-cn_start sig_en=6fe4d18f2f9f9ae293b2cd12b8c69d02 sig_cn_org=12f40b98a18158cb8db569079a13f670 source=15.7 
   <indexterm>
    <primary>retryable error</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>可重试错误</primary>
</indexterm>
<!-- pgdoc-cn_end sig_en=6fe4d18f2f9f9ae293b2cd12b8c69d02 -->

<!-- pgdoc-cn_start sig_en=a17640679d03f7cc55873467e8d79a34 sig_cn_org=faf3ca508a84ca26b9e8621dfeba715e source=15.7 
   <para>
    Both Repeatable Read and Serializable isolation levels can produce
    errors that are designed to prevent serialization anomalies.  As
    previously stated, applications using these levels must be prepared to
    retry transactions that fail due to serialization errors.  Such an
    error's message text will vary according to the precise circumstances,
    but it will always have the SQLSTATE code <literal>40001</literal>
    (<literal>serialization_failure</literal>).
   </para>
________________________________________________________-->
   <para>
    重复读取和可序列化隔离级别都可能产生旨在防止序列化异常的错误。如前所述，
    使用这些级别的应用程序必须准备好重新尝试由于序列化错误而失败的事务。
    这种错误的消息文本将根据具体情况而变化，但它将始终具有SQLSTATE代码
    <literal>40001</literal>（<literal>serialization_failure</literal>）。
</para>
<!-- pgdoc-cn_end sig_en=a17640679d03f7cc55873467e8d79a34 -->

<!-- pgdoc-cn_start sig_en=3db2e4b90040ec884fb8fe4668b7cd00 sig_cn_org=ac73c4c0421393bb903bdc87d888f519 source=15.7 
   <para>
    It may also be advisable to retry deadlock failures.
    These have the SQLSTATE code <literal>40P01</literal>
    (<literal>deadlock_detected</literal>).
   </para>
________________________________________________________-->
   <para>
    也许值得尝试重新执行死锁失败。这些具有SQLSTATE代码<literal>40P01</literal>
    (<literal>deadlock_detected</literal>)。
   </para>
<!-- pgdoc-cn_end sig_en=3db2e4b90040ec884fb8fe4668b7cd00 -->

<!-- pgdoc-cn_start sig_en=28eb6f5735aab2810ea785330cb1d1ee sig_cn_org=b3f6d5d0841acb92730dd6ecd7fa96c5 source=15.7 
   <para>
    In some cases it is also appropriate to retry unique-key failures,
    which have SQLSTATE code <literal>23505</literal>
    (<literal>unique_violation</literal>), and exclusion constraint
    failures, which have SQLSTATE code <literal>23P01</literal>
    (<literal>exclusion_violation</literal>).  For example, if the
    application selects a new value for a primary key column after
    inspecting the currently stored keys, it could get a unique-key
    failure because another application instance selected the same new key
    concurrently.  This is effectively a serialization failure, but the
    server will not detect it as such because it cannot <quote>see</quote>
    the connection between the inserted value and the previous reads.
    There are also some corner cases in which the server will issue a
    unique-key or exclusion constraint error even though in principle it
    has enough information to determine that a serialization problem
    is the underlying cause.  While it's recommendable to just
    retry <literal>serialization_failure</literal> errors unconditionally,
    more care is needed when retrying these other error codes, since they
    might represent persistent error conditions rather than transient
    failures.
   </para>
________________________________________________________-->
   <para>
    在某些情况下，重新尝试唯一键失败是合适的，这些失败具有SQLSTATE代码<literal>23505</literal>
    (<literal>unique_violation</literal>)，以及排除约束失败，这些失败具有SQLSTATE代码<literal>23P01</literal>
    (<literal>exclusion_violation</literal>)。例如，如果应用程序在检查当前存储的键后为主键列选择一个新值，
    并且在并发情况下另一个应用程序实例选择了相同的新键，则可能会发生唯一键失败。这实际上是一个串行化失败，
    但服务器不会将其检测为这样，因为它无法<quote>看到</quote>插入值与先前读取之间的连接。还有一些边缘情况，
    在这些情况下，服务器将发出唯一键或排除约束错误，即使原则上它有足够的信息来确定串行化问题是根本原因。
    虽然建议无条件重试<literal>serialization_failure</literal>错误，但在重试这些其他错误代码时需要更加小心，
    因为它们可能代表持久性错误条件而不是瞬态失败。
</para>
<!-- pgdoc-cn_end sig_en=28eb6f5735aab2810ea785330cb1d1ee -->

<!-- pgdoc-cn_start sig_en=0dbbe9a8e415ce462ff4cdd6ea619b73 sig_cn_org=58ac1fc25f1654ae3f905a3f7177fbfb source=15.7 
   <para>
    It is important to retry the complete transaction, including all logic
    that decides which SQL to issue and/or which values to use.
    Therefore, <productname>PostgreSQL</productname> does not offer an
    automatic retry facility, since it cannot do so with any guarantee of
    correctness.
   </para>
________________________________________________________-->
   <para>
    重试完整的事务非常重要，包括所有决定要发出哪个SQL和/或使用哪些值的逻辑。
    因此，<productname>PostgreSQL</productname>不提供自动重试功能，因为无法保证正确性。
   </para>
<!-- pgdoc-cn_end sig_en=0dbbe9a8e415ce462ff4cdd6ea619b73 -->

<!-- pgdoc-cn_start sig_en=7e737cc661f83d3217cc87146fef69dc sig_cn_org=5e24f901a6f53598f152cdf561a2a372 source=15.7 
   <para>
    Transaction retry does not guarantee that the retried transaction will
    complete; multiple retries may be needed.  In cases with very high
    contention, it is possible that completion of a transaction may take
    many attempts.  In cases involving a conflicting prepared transaction,
    it may not be possible to make progress until the prepared transaction
    commits or rolls back.
   </para>
________________________________________________________-->
   <para>
    事务重试并不保证重试的事务会完成；可能需要多次重试。在存在非常高的争用情况下，
    完成事务可能需要多次尝试。在涉及冲突的已准备事务的情况下，可能无法取得进展，
    直到已准备事务提交或回滚。
</para>
<!-- pgdoc-cn_end sig_en=7e737cc661f83d3217cc87146fef69dc -->
  </sect1>

  <sect1 id="mvcc-caveats">
<!-- pgdoc-cn_start sig_en=6aecf7221ae7403619467c1e1a1a629b sig_cn_org=None source=14.1 
   <title>Caveats</title>
________________________________________________________-->
   <title>提醒</title>
<!-- pgdoc-cn_end sig_en=6aecf7221ae7403619467c1e1a1a629b -->

<!-- pgdoc-cn_start sig_en=f1d28fceb4c6c0a2f3e8462de4796ed1 sig_cn_org=None source=14.1 
   <para>
    Some DDL commands, currently only <link linkend="sql-truncate"><command>TRUNCATE</command></link> and the
    table-rewriting forms of <link linkend="sql-altertable"><command>ALTER TABLE</command></link>, are not
    MVCC-safe.  This means that after the truncation or rewrite commits, the
    table will appear empty to concurrent transactions, if they are using a
    snapshot taken before the DDL command committed.  This will only be an
    issue for a transaction that did not access the table in question
    before the DDL command started &mdash; any transaction that has done so
    would hold at least an <literal>ACCESS SHARE</literal> table lock,
    which would block the DDL command until that transaction completes.
    So these commands will not cause any apparent inconsistency in the
    table contents for successive queries on the target table, but they
    could cause visible inconsistency between the contents of the target
    table and other tables in the database.
   </para>
________________________________________________________-->
   <para>
    一些 DDL 命令（当前只有<link linkend="sql-truncate"><command>TRUNCATE</command></link>和<link linkend="sql-altertable"><command>ALTER TABLE</command></link>的表重写形式）不是 MVCC 安全的。这意味着在截断或者重写提交之后，该表将对并发事务（如果它们使用的快照是在 DDL 命令提交前取得的）呈现出空表的形态。这只对没有在该 DDL 命令开始前访问所讨论的表的事务存在问题 &mdash; 任何在 DDL 命令开始前访问过该表的事务将持有至少一个 <literal>ACCESS SHARE</literal> 表锁，这将阻塞该 DDL 命令直到该事务完成。因此这些命令对于目标表上的连续查询将不会造成任何明显的表内容不一致，但是它们可能导致目标表内容和数据库中其他表内容之间的不一致。
   </para>
<!-- pgdoc-cn_end sig_en=f1d28fceb4c6c0a2f3e8462de4796ed1 -->

<!-- pgdoc-cn_start sig_en=c4ed7818b5f6fbdb1c2d01bc58e3a78b sig_cn_org=5d4950fed03a956d849b173d9dd7909b source=15.7 
   <para>
    Support for the Serializable transaction isolation level has not yet
    been added to hot standby replication targets (described in
    <xref linkend="hot-standby"/>).  The strictest isolation level currently
    supported in hot standby mode is Repeatable Read.  While performing all
    permanent database writes within Serializable transactions on the
    primary will ensure that all standbys will eventually reach a consistent
    state, a Repeatable Read transaction run on the standby can sometimes
    see a transient state that is inconsistent with any serial execution
    of the transactions on the primary.
   </para>
________________________________________________________-->
   <para>
    对于可序列化事务隔离级别的支持尚未添加到热备复制目标（在<xref linkend="hot-standby"/>中描述）。
    当前在热备模式下支持的最严格的隔离级别是可重复读。
    在主服务器上在可序列化事务中执行所有永久性数据库写操作将确保所有备机最终达到一致状态，
    但在备机上运行的可重复读事务有时可能会看到与主服务器上事务的任何串行执行不一致的瞬态状态。
</para>
<!-- pgdoc-cn_end sig_en=c4ed7818b5f6fbdb1c2d01bc58e3a78b -->

<!-- pgdoc-cn_start sig_en=4e15d0835c8adc5606f76d3327e6c69c sig_cn_org=None source=14.1 
   <para>
    Internal access to the system catalogs is not done using the isolation
    level of the current transaction.  This means that newly created database
    objects such as tables are visible to concurrent Repeatable Read and
    Serializable transactions, even though the rows they contain are not.  In
    contrast, queries that explicitly examine the system catalogs don't see
    rows representing concurrently created database objects, in the higher
    isolation levels.
   </para>
________________________________________________________-->
   <para>
    系统目录的内部访问不是使用当前事务的隔离级别来完成的。
    这意味着新创建的数据库对象，例如表，对于并发的可重复读和可序列化事务是可见的，即使它们包含的行并非如此。
    相比之下，显式检查系统目录的查询不会看到表示并发创建的数据库对象的行，在更高的隔离级别中。
   </para>
<!-- pgdoc-cn_end sig_en=4e15d0835c8adc5606f76d3327e6c69c -->
  </sect1>

  <sect1 id="locking-indexes">
<!-- pgdoc-cn_start sig_en=72af535e13baa7659eb7aee45c336d6f sig_cn_org=None source=14.1 
   <title>Locking and Indexes</title>
________________________________________________________-->
   <title>锁定和索引</title>
<!-- pgdoc-cn_end sig_en=72af535e13baa7659eb7aee45c336d6f -->

<!-- pgdoc-cn_start sig_en=5ead058c798f1641b42cb17e0c19cc70 sig_cn_org=None source=14.1 
   <indexterm zone="locking-indexes">
    <primary>index</primary>
    <secondary>locks</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="locking-indexes">
    <primary>索引</primary>
    <secondary>锁</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=5ead058c798f1641b42cb17e0c19cc70 -->

<!-- pgdoc-cn_start sig_en=9df3f7e8d76d2aa810415e1764306696 sig_cn_org=None source=14.1 
   <para>
    Though <productname>PostgreSQL</productname>
    provides nonblocking read/write access to table
    data, nonblocking read/write access is not currently offered for every
    index access method implemented
    in <productname>PostgreSQL</productname>.
    The various index types are handled as follows:

    <variablelist>
     <varlistentry>
      <term>
       B-tree, <acronym>GiST</acronym> and <acronym>SP-GiST</acronym> indexes
      </term>
      <listitem>
       <para>
        Short-term share/exclusive page-level locks are used for
        read/write access. Locks are released immediately after each
        index row is fetched or inserted.  These index types provide
        the highest concurrency without deadlock conditions.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       Hash indexes
      </term>
      <listitem>
       <para>
        Share/exclusive hash-bucket-level locks are used for read/write
        access.  Locks are released after the whole bucket is processed.
        Bucket-level locks provide better concurrency than index-level
        ones, but deadlock is possible since the locks are held longer
        than one index operation.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       <acronym>GIN</acronym> indexes
      </term>
      <listitem>
       <para>
        Short-term share/exclusive page-level locks are used for
        read/write access. Locks are released immediately after each
        index row is fetched or inserted. But note that insertion of a
        GIN-indexed value usually produces several index key insertions
        per row, so GIN might do substantial work for a single value's
        insertion.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
________________________________________________________-->
   <para>
    尽管<productname>PostgreSQL</productname>提供对表数据访问的非阻塞读/写， 但并非<productname>PostgreSQL</productname>中实现的每一个索引访问方法当前都能够提供非阻塞读/写访问。 不同的索引类型按照下面方法操作：

    <variablelist>
     <varlistentry>
      <term>
       B-tree、<acronym>GiST</acronym>和<acronym>SP-GiST</acronym>索引
      </term>
      <listitem>
       <para>
        短期的页面级共享/排他锁被用于读/写访问。每个索引行被取得或被插入后立即释放锁。 这些索引类型提供了无死锁情况的最高并发性。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       Hash索引
      </term>
      <listitem>
       <para>
        Hash 桶级别的共享/排他锁被用于读/写访问。锁在整个 Hash 桶处理完成后释放。Hash 桶级锁比索引级的锁提供了更好的并发性但是可能产生死锁，因为锁持有的时间比一次索引操作时间长。
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>
       <acronym>GIN</acronym>索引
      </term>
      <listitem>
       <para>
        短期的页面级共享/排他锁被用于读/写访问。 锁在索引行被插入/抓取后立即释放。但要注意的是一个 GIN 索引值的插入通常导致对每行产生几个索引键的插入，因此 GIN 可能为了插入一个单一值而做大量的工作。
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
<!-- pgdoc-cn_end sig_en=9df3f7e8d76d2aa810415e1764306696 -->

<!-- pgdoc-cn_start sig_en=23bb9b3d774ceeb9aa2736f9d33dc37a sig_cn_org=None source=14.1 
   <para>
    Currently, B-tree indexes offer the best performance for concurrent
    applications; since they also have more features than hash
    indexes, they are the recommended index type for concurrent
    applications that need to index scalar data. When dealing with
    non-scalar data, B-trees are not useful, and GiST, SP-GiST or GIN
    indexes should be used instead.
   </para>
________________________________________________________-->
   <para>
    目前，B-tree 索引为并发应用提供了最好的性能。因为它还有比 Hash 索引更多的特性，在那些需要对标量数据进行索引的并发应用中，我们建议使用 B-tree 索引类型。在处理非标量类型数据的时候，B-tree 就没什么用了，应该使用 GiST、SP-GiST 或 GIN 索引替代。
   </para>
<!-- pgdoc-cn_end sig_en=23bb9b3d774ceeb9aa2736f9d33dc37a -->
  </sect1>
 </chapter>
