<!-- doc/src/sgml/sources.sgml -->

 <chapter id="source">
<!-- pgdoc-cn_start sig_en=019fdfeaff5dd99641ca2c0905c36a04 sig_cn_org=None source=14.1 
  <title>PostgreSQL Coding Conventions</title>
________________________________________________________-->
  <title>PostgreSQL编码习惯</title>
<!-- pgdoc-cn_end sig_en=019fdfeaff5dd99641ca2c0905c36a04 -->

  <sect1 id="source-format">
<!-- pgdoc-cn_start sig_en=700672607b3510a0e81ca582055566b7 sig_cn_org=None source=14.1 
   <title>Formatting</title>
________________________________________________________-->
   <title>格式化</title>
<!-- pgdoc-cn_end sig_en=700672607b3510a0e81ca582055566b7 -->

<!-- pgdoc-cn_start sig_en=f11954d2d63b4897109834bd6f544b92 sig_cn_org=None source=14.1 
   <para>
    Source code formatting uses 4 column tab spacing, with
    tabs preserved (i.e., tabs are not expanded to spaces).
    Each logical indentation level is one additional tab stop.
   </para>
________________________________________________________-->
   <para>
    源代码格式化使用 4 列制表间隔，并且保留制表符（即制表符不会被扩展成空格）。每一个逻辑缩进层就是一个额外的制表位。
   </para>
<!-- pgdoc-cn_end sig_en=f11954d2d63b4897109834bd6f544b92 -->

<!-- pgdoc-cn_start sig_en=81c4827c79bf7a949f7db4636a49650f sig_cn_org=c7776bbc8275702b6a4c66a3bf3fd19d source=15.7 
   <para>
    Layout rules (brace positioning, etc.) follow BSD conventions.  In
    particular, curly braces for the controlled blocks of <literal>if</literal>,
    <literal>while</literal>, <literal>switch</literal>, etc. go on their own lines.
   </para>
________________________________________________________-->
   <para>
    布局规则（大括号位置等）遵循BSD约定。特别是，<literal>if</literal>、
    <literal>while</literal>、<literal>switch</literal>等控制块的大括号放在自己的行上。
   </para>
<!-- pgdoc-cn_end sig_en=81c4827c79bf7a949f7db4636a49650f -->

<!-- pgdoc-cn_start sig_en=6d867d3bea017b3bbd6f9b8d056d32bd sig_cn_org=None source=14.1 
   <para>
    Limit line lengths so that the code is readable in an 80-column window.
    (This doesn't mean that you must never go past 80 columns.  For instance,
    breaking a long error message string in arbitrary places just to keep the
    code within 80 columns is probably not a net gain in readability.)
   </para>
________________________________________________________-->
   <para>
    限制行长度，这样在 80 列窗口中代码也是可读的（这并不意味着你不能超过 80 列。例如，为了保持代码在 80 列以内而在任意位置打断一段长的错误消息字符串可能不会给可读性带来什么好处）。
   </para>
<!-- pgdoc-cn_end sig_en=6d867d3bea017b3bbd6f9b8d056d32bd -->

<!-- pgdoc-cn_start sig_en=403456a6002117df5d73c3eb5bc1f820 sig_cn_org=None source=14.1 
   <para>
    To maintain a consistent coding style, do not use C++ style comments
    (<literal>//</literal> comments).  <application>pgindent</application>
    will replace them with <literal>/* ... */</literal>.
   </para>
________________________________________________________-->
   <para>
    要保持一致的编码风格，请勿使用C++风格注释（<literal>//</literal> comments）。<application>pgindent</application> 会用 <literal>/* ... */</literal>替换它们。
   </para>
<!-- pgdoc-cn_end sig_en=403456a6002117df5d73c3eb5bc1f820 -->

<!-- pgdoc-cn_start sig_en=84c39be41ce2a77f1ed8936abca5235f sig_cn_org=None source=14.1 
   <para>
    The preferred style for multi-line comment blocks is
<programlisting>
/*
 * comment text begins here
 * and continues here
 */
</programlisting>
    Note that comment blocks that begin in column 1 will be preserved as-is
    by <application>pgindent</application>, but it will re-flow indented comment blocks
    as though they were plain text.  If you want to preserve the line breaks
    in an indented block, add dashes like this:
<programlisting>
    /*-&minus;-&minus;-&minus;-&minus;-&minus;
     * comment text begins here
     * and continues here
     *-&minus;-&minus;-&minus;-&minus;-&minus;
     */
</programlisting>
   </para>
________________________________________________________-->
   <para>
    多行注释块更好的风格是
<programlisting>
/*
 * 注释文本从这里开始
 * 延续到这里
 */
</programlisting>
    注意从列 1 开始的注释块将被<application>pgindent</application>原样保留，但是它将重新对缩进的注释块断行，好像它们是纯文本一样。如果你想要保留一个缩进块中的换行，可以像这样增加破折号：
<programlisting>
    /*----------
     * 注释文本从这里开始
     * 延续到这里
     *----------
     */
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=84c39be41ce2a77f1ed8936abca5235f -->

<!-- pgdoc-cn_start sig_en=9b73f80a9e1b599c1bdef4943ea48832 sig_cn_org=None source=14.1 
   <para>
    While submitted patches do not absolutely have to follow these formatting
    rules, it's a good idea to do so.  Your code will get run through
    <application>pgindent</application> before the next release, so there's no point in
    making it look nice under some other set of formatting conventions.
    A good rule of thumb for patches is <quote>make the new code look like
    the existing code around it</quote>.
   </para>
________________________________________________________-->
   <para>
    虽然在提交补丁时并不是一定要遵守这些格式化规则，但是最好能遵守。在下一次发行前你提交的代码将会通过<application>pgindent</application>，因此使用某种其他格式化习惯无法使代码被编排得很好。对于补丁，一种比较好的经验规则是<quote>让新代码看起来像它周围的原有代码</quote>。
   </para>
<!-- pgdoc-cn_end sig_en=9b73f80a9e1b599c1bdef4943ea48832 -->

<!-- pgdoc-cn_start sig_en=48678ef3dd220c63497d9a42508cd0e7 sig_cn_org=4381baf549ffeea8f97a2bad2009506e source=15.7 
   <para>
    The <filename>src/tools/editors</filename> directory contains sample settings
    files that can be used with the <productname>Emacs</productname>,
    <productname>xemacs</productname> or <productname>vim</productname>
    editors to help ensure that they format code according to these
    conventions.
   </para>
________________________________________________________-->
   <para>
    <filename>src/tools/editors</filename>目录包含可用于<productname>Emacs</productname>、
    <productname>xemacs</productname>或<productname>vim</productname>编辑器的示例设置文件，
    以确保它们根据这些约定格式化代码。
</para>
<!-- pgdoc-cn_end sig_en=48678ef3dd220c63497d9a42508cd0e7 -->

<!-- pgdoc-cn_start sig_en=8c5cd5e6665a4f68129e5f7d03f8054d sig_cn_org=a2e012dba77d454efbc31cb90bfe39c8 source=15.7 
   <para>
    If you'd like to run <application>pgindent</application> locally
    to help make your code match project style, see
    the <filename>src/tools/pgindent</filename> directory.
   </para>
________________________________________________________-->
   <para>
    如果您想在本地运行<application>pgindent</application>来帮助使您的代码符合项目风格，
    请参阅<filename>src/tools/pgindent</filename>目录。
   </para>
<!-- pgdoc-cn_end sig_en=8c5cd5e6665a4f68129e5f7d03f8054d -->

<!-- pgdoc-cn_start sig_en=ee506618adf0210f32f33f7a2d8e1526 sig_cn_org=None source=14.1 
   <para>
    The text browsing tools <application>more</application> and
    <application>less</application> can be invoked as:
<programlisting>
more -x4
less -x4
</programlisting>
    to make them show tabs appropriately.
   </para>
________________________________________________________-->
   <para>
    可以这样调用文本浏览工具<application>more</application>和<application>less</application>：
<programlisting>
more -x4
less -x4
</programlisting>
    来让它们以合适的方式显示制表符。
   </para>
<!-- pgdoc-cn_end sig_en=ee506618adf0210f32f33f7a2d8e1526 -->
  </sect1>

  <sect1 id="error-message-reporting">
<!-- pgdoc-cn_start sig_en=0ccc9d74ed5d0d026fa4d23aabbecdb6 sig_cn_org=None source=14.1 
   <title>Reporting Errors Within the Server</title>
________________________________________________________-->
   <title>在服务器中报告错误</title>
<!-- pgdoc-cn_end sig_en=0ccc9d74ed5d0d026fa4d23aabbecdb6 -->

<!-- pgdoc-cn_start sig_en=9b21b53642718a5eed1eafcb497aad5e sig_cn_org=None source=14.1 
   <indexterm>
    <primary>ereport</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>ereport</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=9b21b53642718a5eed1eafcb497aad5e -->
<!-- pgdoc-cn_start sig_en=8013bfa59b8852954733fa6e7027bc7c sig_cn_org=None source=14.1 
   <indexterm>
    <primary>elog</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>elog</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=8013bfa59b8852954733fa6e7027bc7c -->

<!-- pgdoc-cn_start sig_en=210427acf9ef6d2cc6297ce8306f631f sig_cn_org=None source=14.1 
   <para>
    Error, warning, and log messages generated within the server code
    should be created using <function>ereport</function>, or its older cousin
    <function>elog</function>.  The use of this function is complex enough to
    require some explanation.
   </para>
________________________________________________________-->
   <para>
    服务器代码内产生的错误、警告和日志消息应该使用<function>ereport</function>或者更老的<function>elog</function>生成。这个函数的使用有些复杂，因此有必要做一些解释。
   </para>
<!-- pgdoc-cn_end sig_en=210427acf9ef6d2cc6297ce8306f631f -->

<!-- pgdoc-cn_start sig_en=571d8cfd9e3af82e84843cc66ba8b7c9 sig_cn_org=None source=14.1 
   <para>
    There are two required elements for every message: a severity level
    (ranging from <literal>DEBUG</literal> to <literal>PANIC</literal>) and a primary
    message text.  In addition there are optional elements, the most
    common of which is an error identifier code that follows the SQL spec's
    SQLSTATE conventions.
    <function>ereport</function> itself is just a shell macro that exists
    mainly for the syntactic convenience of making message generation
    look like a single function call in the C source code.  The only parameter
    accepted directly by <function>ereport</function> is the severity level.
    The primary message text and any optional message elements are
    generated by calling auxiliary functions, such as <function>errmsg</function>,
    within the <function>ereport</function> call.
   </para>
________________________________________________________-->
   <para>
    对于每一个消息都有两个必要的元素：一个严重性级别（从<literal>DEBUG</literal>到<literal>PANIC</literal>）和一个主消息文本。此外还有一些可选元素，其中最常见的是一个遵守 SQL 规范中 SQLSTATE 习惯的错误标识符代码。<function>ereport</function>本身只是一个 shell 宏，它的存在主要是为了在语法习惯上让消息的产生更像 C 源代码中的单个函数调用而已。<function>ereport</function>直接接受的唯一参数是严重性级别。主消息文本和任何其他可选消息元素通过在<function>ereport</function>调用中使用辅助函数产生，例如<function>errmsg</function>。
   </para>
<!-- pgdoc-cn_end sig_en=571d8cfd9e3af82e84843cc66ba8b7c9 -->

<!-- pgdoc-cn_start sig_en=b9c5fa38ab613d873882ef6034357f61 sig_cn_org=None source=14.1 
   <para>
    A typical call to <function>ereport</function> might look like this:
<programlisting>
ereport(ERROR,
        errcode(ERRCODE_DIVISION_BY_ZERO),
        errmsg("division by zero"));
</programlisting>
    This specifies error severity level <literal>ERROR</literal> (a run-of-the-mill
    error).  The <function>errcode</function> call specifies the SQLSTATE error code
    using a macro defined in <filename>src/include/utils/errcodes.h</filename>.  The
    <function>errmsg</function> call provides the primary message text.
   </para>
________________________________________________________-->
   <para>
    对于<function>ereport</function>的一次典型调用可能看起来像：
<programlisting>
ereport(ERROR,
        (errcode(ERRCODE_DIVISION_BY_ZERO),
         errmsg("division by zero")));
</programlisting>
    这会指定错误严重性级别为<literal>ERROR</literal>（一个普通错误）。<function>errcode</function>调用使用<filename>src/include/utils/errcodes.h</filename>中定义的一个宏指定 SQLSTATE 错误代码。<function>errmsg</function>调用提供主消息文本。
   </para>
<!-- pgdoc-cn_end sig_en=b9c5fa38ab613d873882ef6034357f61 -->

<!-- pgdoc-cn_start sig_en=dd7679aa2a664e4cd291b223eb749f28 sig_cn_org=None source=14.1 
   <para>
    You will also frequently see this older style, with an extra set of
    parentheses surrounding the auxiliary function calls:
<programlisting>
ereport(ERROR,
        (errcode(ERRCODE_DIVISION_BY_ZERO),
         errmsg("division by zero")));
</programlisting>
    The extra parentheses were required
    before <productname>PostgreSQL</productname> version 12, but are now
    optional.
   </para>
________________________________________________________-->
   <para>
    您还会经常看到这种较旧的样式，在辅助函数调用周围有一组额外的圆括号：
<programlisting>
ereport(ERROR,
        (errcode(ERRCODE_DIVISION_BY_ZERO),
         errmsg("division by zero")));
</programlisting>
    在 <productname>PostgreSQL</productname> 版本 12 之前需要额外的括号，但现在是可选的。
   </para>
<!-- pgdoc-cn_end sig_en=dd7679aa2a664e4cd291b223eb749f28 -->

<!-- pgdoc-cn_start sig_en=e2888c807f8372d73487930da25370dd sig_cn_org=None source=14.1 
   <para>
    Here is a more complex example:
<programlisting>
ereport(ERROR,
        errcode(ERRCODE_AMBIGUOUS_FUNCTION),
        errmsg("function %s is not unique",
               func_signature_string(funcname, nargs,
                                     NIL, actual_arg_types)),
        errhint("Unable to choose a best candidate function. "
                "You might need to add explicit typecasts."));
</programlisting>
    This illustrates the use of format codes to embed run-time values into
    a message text.  Also, an optional <quote>hint</quote> message is provided.
    The auxiliary function calls can be written in any order, but
    conventionally <function>errcode</function>
    and <function>errmsg</function> appear first.
   </para>
________________________________________________________-->
   <para>
    这里有一个更复杂的例子：
<programlisting>
ereport(ERROR,
        errcode(ERRCODE_AMBIGUOUS_FUNCTION),
        errmsg("function %s is not unique",
               func_signature_string(funcname, nargs,
                                     NIL, actual_arg_types)),
        errhint("Unable to choose a best candidate function. "
                "You might need to add explicit typecasts."));
</programlisting>
    这展示了使用格式代码把运行时值嵌入到一个消息文本中的方法，其中还提供了一个可选的<quote>hint</quote>消息。
    辅助函数调用可以按任何顺序写入，但通常先出现<function>errcode</function>和<function>errmsg</function>。
   </para>
<!-- pgdoc-cn_end sig_en=e2888c807f8372d73487930da25370dd -->

<!-- pgdoc-cn_start sig_en=cd091144f67929a9103150219007cb70 sig_cn_org=None source=14.1 
   <para>
    If the severity level is <literal>ERROR</literal> or higher,
    <function>ereport</function> aborts execution of the current query
    and does not return to the caller. If the severity level is
    lower than <literal>ERROR</literal>, <function>ereport</function> returns normally.
   </para>
________________________________________________________-->
   <para>
    如果严重级别是<literal>ERROR</literal>或更高，<function>ereport</function>
    会中止当前查询的执行并且不会返回到调用者。如果严重级别低于
    <literal>ERROR</literal>，<function>ereport</function>会正常返回。
   </para>
<!-- pgdoc-cn_end sig_en=cd091144f67929a9103150219007cb70 -->

<!-- pgdoc-cn_start sig_en=4828ec3da98607df3daed39a20576674 sig_cn_org=None source=14.1 
   <para>
    The available auxiliary routines for <function>ereport</function> are:
  <itemizedlist>
   <listitem>
    <para>
     <function>errcode(sqlerrcode)</function> specifies the SQLSTATE error identifier
     code for the condition.  If this routine is not called, the error
     identifier defaults to
     <literal>ERRCODE_INTERNAL_ERROR</literal> when the error severity level is
     <literal>ERROR</literal> or higher, <literal>ERRCODE_WARNING</literal> when the
     error level is <literal>WARNING</literal>, otherwise (for <literal>NOTICE</literal>
     and below) <literal>ERRCODE_SUCCESSFUL_COMPLETION</literal>.
     While these defaults are often convenient, always think whether they
     are appropriate before omitting the <function>errcode()</function> call.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errmsg(const char *msg, ...)</function> specifies the primary error
     message text, and possibly run-time values to insert into it.  Insertions
     are specified by <function>sprintf</function>-style format codes.  In addition to
     the standard format codes accepted by <function>sprintf</function>, the format
     code <literal>%m</literal> can be used to insert the error message returned
     by <function>strerror</function> for the current value of <literal>errno</literal>.
     <footnote>
      <para>
       That is, the value that was current when the <function>ereport</function> call
       was reached; changes of <literal>errno</literal> within the auxiliary reporting
       routines will not affect it.  That would not be true if you were to
       write <literal>strerror(errno)</literal> explicitly in <function>errmsg</function>'s
       parameter list; accordingly, do not do so.
      </para>
     </footnote>
     <literal>%m</literal> does not require any
     corresponding entry in the parameter list for <function>errmsg</function>.
     Note that the message string will be run through <function>gettext</function>
     for possible localization before format codes are processed.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errmsg_internal(const char *msg, ...)</function> is the same as
     <function>errmsg</function>, except that the message string will not be
     translated nor included in the internationalization message dictionary.
     This should be used for <quote>cannot happen</quote> cases that are probably
     not worth expending translation effort on.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errmsg_plural(const char *fmt_singular, const char *fmt_plural,
     unsigned long n, ...)</function> is like <function>errmsg</function>, but with
     support for various plural forms of the message.
     <replaceable>fmt_singular</replaceable> is the English singular format,
     <replaceable>fmt_plural</replaceable> is the English plural format,
     <replaceable>n</replaceable> is the integer value that determines which plural
     form is needed, and the remaining arguments are formatted according
     to the selected format string.  For more information see
     <xref linkend="nls-guidelines"/>.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdetail(const char *msg, ...)</function> supplies an optional
     <quote>detail</quote> message; this is to be used when there is additional
     information that seems inappropriate to put in the primary message.
     The message string is processed in just the same way as for
     <function>errmsg</function>.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdetail_internal(const char *msg, ...)</function> is the same
     as <function>errdetail</function>, except that the message string will not be
     translated nor included in the internationalization message dictionary.
     This should be used for detail messages that are not worth expending
     translation effort on, for instance because they are too technical to be
     useful to most users.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdetail_plural(const char *fmt_singular, const char *fmt_plural,
     unsigned long n, ...)</function> is like <function>errdetail</function>, but with
     support for various plural forms of the message.
     For more information see <xref linkend="nls-guidelines"/>.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdetail_log(const char *msg, ...)</function> is the same as
     <function>errdetail</function> except that this string goes only to the server
     log, never to the client.  If both <function>errdetail</function> (or one of
     its equivalents above) and
     <function>errdetail_log</function> are used then one string goes to the client
     and the other to the log.  This is useful for error details that are
     too security-sensitive or too bulky to include in the report
     sent to the client.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdetail_log_plural(const char *fmt_singular, const char
     *fmt_plural, unsigned long n, ...)</function> is like
     <function>errdetail_log</function>, but with support for various plural forms of
     the message.
     For more information see <xref linkend="nls-guidelines"/>.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errhint(const char *msg, ...)</function> supplies an optional
     <quote>hint</quote> message; this is to be used when offering suggestions
     about how to fix the problem, as opposed to factual details about
     what went wrong.
     The message string is processed in just the same way as for
     <function>errmsg</function>.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errhint_plural(const char *fmt_singular, const char *fmt_plural,
     unsigned long n, ...)</function> is like <function>errhint</function>, but with
     support for various plural forms of the message.
     For more information see <xref linkend="nls-guidelines"/>.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errcontext(const char *msg, ...)</function> is not normally called
     directly from an <function>ereport</function> message site; rather it is used
     in <literal>error_context_stack</literal> callback functions to provide
     information about the context in which an error occurred, such as the
     current location in a PL function.
     The message string is processed in just the same way as for
     <function>errmsg</function>.  Unlike the other auxiliary functions, this can
     be called more than once per <function>ereport</function> call; the successive
     strings thus supplied are concatenated with separating newlines.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errposition(int cursorpos)</function> specifies the textual location
     of an error within a query string.  Currently it is only useful for
     errors detected in the lexical and syntactic analysis phases of
     query processing.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errtable(Relation rel)</function> specifies a relation whose
     name and schema name should be included as auxiliary fields in the error
     report.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errtablecol(Relation rel, int attnum)</function> specifies
     a column whose name, table name, and schema name should be included as
     auxiliary fields in the error report.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errtableconstraint(Relation rel, const char *conname)</function>
     specifies a table constraint whose name, table name, and schema name
     should be included as auxiliary fields in the error report.  Indexes
     should be considered to be constraints for this purpose, whether or
     not they have an associated <structname>pg_constraint</structname> entry.  Be
     careful to pass the underlying heap relation, not the index itself, as
     <literal>rel</literal>.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdatatype(Oid datatypeOid)</function> specifies a data
     type whose name and schema name should be included as auxiliary fields
     in the error report.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdomainconstraint(Oid datatypeOid, const char *conname)</function>
     specifies a domain constraint whose name, domain name, and schema name
     should be included as auxiliary fields in the error report.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errcode_for_file_access()</function> is a convenience function that
     selects an appropriate SQLSTATE error identifier for a failure in a
     file-access-related system call.  It uses the saved
     <literal>errno</literal> to determine which error code to generate.
     Usually this should be used in combination with <literal>%m</literal> in the
     primary error message text.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errcode_for_socket_access()</function> is a convenience function that
     selects an appropriate SQLSTATE error identifier for a failure in a
     socket-related system call.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errhidestmt(bool hide_stmt)</function> can be called to specify
     suppression of the <literal>STATEMENT:</literal> portion of a message in the
     postmaster log.  Generally this is appropriate if the message text
     includes the current statement already.
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errhidecontext(bool hide_ctx)</function> can be called to
     specify suppression of the <literal>CONTEXT:</literal> portion of a message in
     the postmaster log.  This should only be used for verbose debugging
     messages where the repeated inclusion of context would bloat the log
     too much.
    </para>
   </listitem>
  </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    <function>ereport</function>可用的辅助例程是：
  <itemizedlist>
   <listitem>
    <para>
     <function>errcode(sqlerrcode)</function>指定对于该情况的 SQLSTATE 错误标识符代码。如果没有调用这个例程，错误严重性级别是<literal>ERROR</literal>或更高时错误标识符会默认成<literal>ERRCODE_INTERNAL_ERROR</literal>，错误级别是<literal>WARNING</literal>时标识符为<literal>ERRCODE_WARNING</literal>，否则（对于<literal>NOTICE</literal>及以下的级别）标识符会被设置为<literal>ERRCODE_SUCCESSFUL_COMPLETION</literal>。虽然这些默认值常常很方便，在忽略<function>errcode()</function>调用之前请总是思考一下它们是否合适。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errmsg(const char *msg, ...)</function>指定主错误消息文本，以及需要插入其中的运行时值。这种插入以<function>sprintf</function>-风格的格式代码指定。除了<function>sprintf</function>接受的标准格式代码，格式代码<literal>%m</literal>可以用来插入由<function>strerror</function>为<literal>errno</literal>的当前值返回的错误消息。
     <footnote>
      <para>
       也就是说，该值时到达<function>ereport</function>调用时的当前值，在辅助报告例程内<literal>errno</literal>的改变不会影响它。但如果你在<function>errmsg</function>的参数列表中显式地写了<literal>strerror(errno)</literal>则不是这样，因此不要那样做。
      </para>
     </footnote>
     <literal>%m</literal>不要求<function>errmsg</function>参数列表中的任何对应项。注意在格式代码被处理之前，消息字符串将通过<function>gettext</function>来进行可能的本地化。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errmsg_internal(const char *msg, ...)</function>与<function>errmsg</function>相同，不过消息串将不会被翻译，也不会被包括在国际化的消息字典中。这不应该被用于<quote>不能发生</quote>的情况中，因为那些情况下不值得花费精力去做翻译。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errmsg_plural(const char *fmt_singular, const char *fmt_plural,
     unsigned long n, ...)</function>很像<function>errmsg</function>，但是支持消息的多种复数形式。<replaceable>fmt_singular</replaceable>是英语单数格式，<replaceable>fmt_plural</replaceable>是英语复数格式，<replaceable>n</replaceable>是决定需要何种复数形式的整数值，剩下的参数会被根据选中的格式字符串进行格式化。详见<xref linkend="nls-guidelines"/>。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdetail(const char *msg, ...)</function>提供了一个可选的<quote>详情</quote>消息，如果有额外的信息但不适合放在主消息中时就可以使用这种方式。消息字符串的处理与<function>errmsg</function>相同。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdetail_internal(const char *msg, ...)</function>与<function>errdetail</function>相同，不过消息串将不会被翻译，也不会被包括在国际化的消息字典中。这应该被用于不值得花费精力翻译的详情消息上，例如它们对大部分用户太过技术化而没什么用处。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdetail_plural(const char *fmt_singular, const char *fmt_plural,
     unsigned long n, ...)</function>与<function>errdetail</function>相似，但是支持消息的多种复数形式。详见<xref linkend="nls-guidelines"/>。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdetail_log(const char *msg, ...)</function>与<function>errdetail</function>相同，除了这个字符串只会进入服务器的日志而不会发往客户端。如果同时使用了<function>errdetail</function>（或者上述的一种等效函数）以及<function>errdetail_log</function>，那么一个字符串会被发往客户端而另一个会被发往日志。如果错误细节的安全性过于敏感或者体积过于庞大而不适合于发往客户端，这个函数就非常有用。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdetail_log_plural(const char *fmt_singular, const char
     *fmt_plural, unsigned long n, ...)</function>与<function>errdetail_log</function>
     相似，但是支持多种复数形式的消息。详见<xref linkend="nls-guidelines"/>。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errhint(const char *msg, ...)</function>提供一个可选的<quote>hint</quote>消息，它被用来提供关于如何修复该问题的建议。该消息字符串以和<function>errmsg</function>相同的方式处理。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errhint_plural(const char *fmt_singular, const char *fmt_plural,
     unsigned long n, ...)</function>与<function>errhint</function>相似，但是支持多种复数形式的消息。详见<xref linkend="nls-guidelines"/>。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errcontext(const char *msg, ...)</function>通常不会被直接从一个<function>ereport</function>消息站点调用，它被用在<literal>error_context_stack</literal>回调函数中来提供错误发生的上下文，例如一个 PL 函数中的当前位置。该消息字符串以和<function>errmsg</function>相同的方式处理。不同于其他辅助函数，在每次<function>ereport</function>调用中可以多次调用这个函数，这样提供的连续的字符串将被用单独的新行串接在一起。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errposition(int cursorpos)</function>指定一个查询字符串中错误的文本位置。当前，它只对查询处理的词法和语法分析阶段中检测到的错误有用。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errtable(Relation rel)</function>指定一个关系，它的名称和模式名称应该被包括在错误报告中作为辅助域。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errtablecol(Relation rel, int attnum)</function>指定一个列，它的名称、表名和模式名称应该被包括在错误报告中作为辅助域。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errtableconstraint(Relation rel, const char *conname)</function>指定一个约束，它的名称、表名和模式名称应该被包括在错误报告中作为辅助域。索引应当为考虑成用于这种目的的约束，不管它们有没有一个相关联的<structname>pg_constraint</structname>项。要小心地以<literal>rel</literal>传递底层堆关系而不是索引本身。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdatatype(Oid datatypeOid)</function>指定一个数据类型，它的名称和模式名称应该被包括在错误报告中作为辅助域。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errdomainconstraint(Oid datatypeOid, const char *conname)</function>指定一个域约束，它的名称、域名和模式名称应该被包括在错误报告中作为辅助域。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errcode_for_file_access()</function>是一个便捷函数，它可以在一个文件访问相关的系统调用中为一个失败选择一个合适的 SQLSTATE 错误标识符。它使用保存下来的<literal>errno</literal>来决定要差生哪种错误代码。通常，应该把它和主错误消息文本中的<literal>%m</literal>联合使用。
    </para>
   </listitem>
   <listitem>
    <para>
     <function>errcode_for_socket_access()</function>是一个便捷函数，它可以在一个套接字相关的系统调用中为一个失败选择一个合适的 SQLSTATE 错误标识符。
    </para>
   </listitem>
   <listitem>
    <para>
     可以调用<function>errhidestmt(bool hide_stmt)</function>来指定抑制 postmaster 日志中消息里的<literal>STATEMENT:</literal>部分。 如果消息文本已经包含当前语句，通常这是合适的。
    </para>
   </listitem>
   <listitem>
    <para>
     可以调用<function>errhidecontext(bool hide_ctx)</function>来指示抑制 postmaster 日志中消息里的<literal>CONTEXT:</literal>部分。这只应该被用于 verbose 模式的调试消息，这类消息中被重复包含的上下文信息会让日志膨胀得非常厉害。
    </para>
   </listitem>
  </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=4828ec3da98607df3daed39a20576674 -->

   <note>
<!-- pgdoc-cn_start sig_en=a09fd0caf999644bcf5fb29590a9516a sig_cn_org=None source=14.1 
    <para>
     At most one of the functions <function>errtable</function>,
     <function>errtablecol</function>, <function>errtableconstraint</function>,
     <function>errdatatype</function>, or <function>errdomainconstraint</function> should
     be used in an <function>ereport</function> call.  These functions exist to
     allow applications to extract the name of a database object associated
     with the error condition without having to examine the
     potentially-localized error message text.
     These functions should be used in error reports for which it's likely
     that applications would wish to have automatic error handling.  As of
     <productname>PostgreSQL</productname> 9.3, complete coverage exists only for
     errors in SQLSTATE class 23 (integrity constraint violation), but this
     is likely to be expanded in future.
    </para>
________________________________________________________-->
    <para>
     在一个<function>ereport</function>调用中，最多可以使用一个<function>errtable</function>、<function>errtablecol</function>、<function>errtableconstraint</function>、<function>errdatatype</function>或者<function>errdomainconstraint</function>函数。这些函数存在是为了允许应用抽取与错误情况相关的数据库对象名，而不需要检查可能已被本地化的错误消息文本。这些函数应该被用在应用需要对其进行自动错误处理的错误报告中。从<productname>PostgreSQL</productname> 9.3 开始，完整的覆盖只为 SQLSTATE 类别 23 中的错误存在（完整性约束违背），但是在未来这些很可能会被扩展。
    </para>
<!-- pgdoc-cn_end sig_en=a09fd0caf999644bcf5fb29590a9516a -->
   </note>

<!-- pgdoc-cn_start sig_en=e1376925692fae319bfa67b07c9f2666 sig_cn_org=None source=14.1 
   <para>
    There is an older function <function>elog</function> that is still heavily used.
    An <function>elog</function> call:
<programlisting>
elog(level, "format string", ...);
</programlisting>
    is exactly equivalent to:
<programlisting>
ereport(level, errmsg_internal("format string", ...));
</programlisting>
    Notice that the SQLSTATE error code is always defaulted, and the message
    string is not subject to translation.
    Therefore, <function>elog</function> should be used only for internal errors and
    low-level debug logging.  Any message that is likely to be of interest to
    ordinary users should go through <function>ereport</function>.  Nonetheless,
    there are enough internal <quote>cannot happen</quote> error checks in the
    system that <function>elog</function> is still widely used; it is preferred for
    those messages for its notational simplicity.
   </para>
________________________________________________________-->
   <para>
    有一个还在大量使用的旧的函数<function>elog</function>。一个<function>elog</function>调用：
<programlisting>
elog(level, "format string", ...);
</programlisting>
    完全等效于：
<programlisting>
ereport(level, errmsg_internal("format string", ...));
</programlisting>
    注意 SQLSTATE 错误代码总是被给予默认值，并且消息字符串不受翻译影响。因此，<function>elog</function>应该只被用于内部错误和低层次的调试日志。任何普通用户感兴趣的消息应该通过<function>ereport</function>。不管怎样，在仍广泛使用<function>elog</function>的系统中，有足够多的内部<quote>不可能发生</quote>的错误检查，出于记号简洁的目的这更适合于那些消息。
   </para>
<!-- pgdoc-cn_end sig_en=e1376925692fae319bfa67b07c9f2666 -->

<!-- pgdoc-cn_start sig_en=079b43e6e3f97a6b93a1f8f0d41b3d30 sig_cn_org=None source=14.1 
   <para>
    Advice about writing good error messages can be found in
    <xref linkend="error-style-guide"/>.
   </para>
________________________________________________________-->
   <para>
    有关编写好的错误消息的建议可见<xref linkend="error-style-guide"/>。
   </para>
<!-- pgdoc-cn_end sig_en=079b43e6e3f97a6b93a1f8f0d41b3d30 -->
  </sect1>

  <sect1 id="error-style-guide">
<!-- pgdoc-cn_start sig_en=8c5bf95ab6a0badaf6340c5794f86bfb sig_cn_org=None source=14.1 
   <title>Error Message Style Guide</title>
________________________________________________________-->
   <title>错误消息风格指导</title>
<!-- pgdoc-cn_end sig_en=8c5bf95ab6a0badaf6340c5794f86bfb -->

<!-- pgdoc-cn_start sig_en=28d1c301e4fdfa9d4da4976d1b78c867 sig_cn_org=None source=14.1 
   <para>
    This style guide is offered in the hope of maintaining a consistent,
    user-friendly style throughout all the messages generated by
    <productname>PostgreSQL</productname>.
   </para>
________________________________________________________-->
   <para>
    提供这个风格指导是希望在所有由<productname>PostgreSQL</productname>产生的消息间维护一种一致的、用户友好的风格。
   </para>
<!-- pgdoc-cn_end sig_en=28d1c301e4fdfa9d4da4976d1b78c867 -->

  <simplesect>
<!-- pgdoc-cn_start sig_en=c59a6d68e32c3093c18291a48a3d3add sig_cn_org=None source=14.1 
   <title>What Goes Where</title>
________________________________________________________-->
   <title>哪儿该放什么</title>
<!-- pgdoc-cn_end sig_en=c59a6d68e32c3093c18291a48a3d3add -->

<!-- pgdoc-cn_start sig_en=19c03d55e398eb62cef0f97b5ea77c9c sig_cn_org=None source=14.1 
   <para>
    The primary message should be short, factual, and avoid reference to
    implementation details such as specific function names.
    <quote>Short</quote> means <quote>should fit on one line under normal
    conditions</quote>.  Use a detail message if needed to keep the primary
    message short, or if you feel a need to mention implementation details
    such as the particular system call that failed. Both primary and detail
    messages should be factual.  Use a hint message for suggestions about what
    to do to fix the problem, especially if the suggestion might not always be
    applicable.
   </para>
________________________________________________________-->
   <para>
    主要的消息应该简短、实事求是并且避免引用诸如特定函数名这样的实现细节。<quote>简短</quote>意味着<quote>在正常情况下应该能放在一行内</quote>。如果需要保持主要消息简短，或者如果你觉得有必要提到诸如特定系统调用失败这样的实现细节，可以使用一个详细消息。主要消息和详细消息都应该实事求是。对于有关如何修复问题的建议可以使用一个提示消息，特别是该建议可能不总是合适时。
   </para>
<!-- pgdoc-cn_end sig_en=19c03d55e398eb62cef0f97b5ea77c9c -->

<!-- pgdoc-cn_start sig_en=04bec6bc07863720187b356f400eb889 sig_cn_org=None source=14.1 
   <para>
    For example, instead of:
<programlisting>
IpcMemoryCreate: shmget(key=%d, size=%u, 0%o) failed: %m
(plus a long addendum that is basically a hint)
</programlisting>
    write:
<programlisting>
Primary:    could not create shared memory segment: %m
Detail:     Failed syscall was shmget(key=%d, size=%u, 0%o).
Hint:       the addendum
</programlisting>
   </para>
________________________________________________________-->
   <para>
    例如，与其用：
<programlisting>
IpcMemoryCreate: shmget(key=%d, size=%u, 0%o) failed: %m
(plus a long addendum that is basically a hint)
</programlisting>
    不如写：
<programlisting>
Primary:    could not create shared memory segment: %m
Detail:     Failed syscall was shmget(key=%d, size=%u, 0%o).
Hint:       the addendum
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=04bec6bc07863720187b356f400eb889 -->

<!-- pgdoc-cn_start sig_en=34fad3e62ee9b5935ca4e315b1e4f040 sig_cn_org=None source=14.1 
   <para>
    Rationale: keeping the primary message short helps keep it to the point,
    and lets clients lay out screen space on the assumption that one line is
    enough for error messages.  Detail and hint messages can be relegated to a
    verbose mode, or perhaps a pop-up error-details window.  Also, details and
    hints would normally be suppressed from the server log to save
    space. Reference to implementation details is best avoided since users
    aren't expected to know the details.
   </para>
________________________________________________________-->
   <para>
    原理：保持主要消息简短有助于扣住主题并且有助于客户端基于错误消息放在一行足以的假设来安排屏幕空间。详细消息和提示消息可以被归入一种详情模式，或者可能是一种弹出式错误细节窗口。还有，详细消息和提示消息通常会被排除在服务器日志之外以节省空间。最好避免对实现细节的引用，因为用户根本就不想知道细节。
   </para>
<!-- pgdoc-cn_end sig_en=34fad3e62ee9b5935ca4e315b1e4f040 -->

  </simplesect>

  <simplesect>
<!-- pgdoc-cn_start sig_en=700672607b3510a0e81ca582055566b7 sig_cn_org=None source=14.1 
   <title>Formatting</title>
________________________________________________________-->
   <title>格式化</title>
<!-- pgdoc-cn_end sig_en=700672607b3510a0e81ca582055566b7 -->

<!-- pgdoc-cn_start sig_en=23c67ac48108568a102fb6b4852562ed sig_cn_org=None source=14.1 
   <para>
    Don't put any specific assumptions about formatting into the message
    texts.  Expect clients and the server log to wrap lines to fit their own
    needs.  In long messages, newline characters (\n) can be used to indicate
    suggested paragraph breaks.  Don't end a message with a newline.  Don't
    use tabs or other formatting characters.  (In error context displays,
    newlines are automatically added to separate levels of context such as
    function calls.)
   </para>
________________________________________________________-->
   <para>
    不要对消息文本的格式化做任何特定假设。可以期望客户端和服务器日志换行来适应其自身的需要。在长消息中，新行字符（\n）可以被用来指示建议的分段。不要用一个新行结束一个消息。不要使用制表符或其他格式化字符（在错误上下文显示中，新行会自动被增加来分割上下文的层次，例如函数调用）。
   </para>
<!-- pgdoc-cn_end sig_en=23c67ac48108568a102fb6b4852562ed -->

<!-- pgdoc-cn_start sig_en=69a7d989eec519c45745aadd1733f5c0 sig_cn_org=None source=14.1 
   <para>
    Rationale: Messages are not necessarily displayed on terminal-type
    displays.  In GUI displays or browsers these formatting instructions are
    at best ignored.
   </para>
________________________________________________________-->
   <para>
    原理：消息不一定非得显示在终端上。在 GUI 显示或浏览器中，这些格式化指令最多会被忽略。
   </para>
<!-- pgdoc-cn_end sig_en=69a7d989eec519c45745aadd1733f5c0 -->

  </simplesect>

  <simplesect>
<!-- pgdoc-cn_start sig_en=5e5caae2453564bff79d7cf9500993d8 sig_cn_org=None source=14.1 
   <title>Quotation Marks</title>
________________________________________________________-->
   <title>引号</title>
<!-- pgdoc-cn_end sig_en=5e5caae2453564bff79d7cf9500993d8 -->

<!-- pgdoc-cn_start sig_en=902e5fd52052429a20bb61e678e5e31f sig_cn_org=None source=14.1 
   <para>
    English text should use double quotes when quoting is appropriate.
    Text in other languages should consistently use one kind of quotes that is
    consistent with publishing customs and computer output of other programs.
   </para>
________________________________________________________-->
   <para>
    在引用时，英语文本应该使用双引号。其他语言中的文本应该一致地使用一种符合出版习惯和其他程序计算机输出的引号。
   </para>
<!-- pgdoc-cn_end sig_en=902e5fd52052429a20bb61e678e5e31f -->

<!-- pgdoc-cn_start sig_en=93c699c80a82209cecaca9cabe1c0997 sig_cn_org=None source=14.1 
   <para>
    Rationale: The choice of double quotes over single quotes is somewhat
    arbitrary, but tends to be the preferred use.  Some have suggested
    choosing the kind of quotes depending on the type of object according to
    SQL conventions (namely, strings single quoted, identifiers double
    quoted).  But this is a language-internal technical issue that many users
    aren't even familiar with, it won't scale to other kinds of quoted terms,
    it doesn't translate to other languages, and it's pretty pointless, too.
   </para>
________________________________________________________-->
   <para>
    原理：选择双引号而不是单引号其实有点武断，但是更倾向于是首选用法。有人建议过按照 SQL 习惯根据对象类型来选择引号的种类（即，字符串单引号，标识符双引号）。但是这是一个很多用户根本不熟悉的语言内部的技术问题，它不会扩散到其他种类的被引用术语，也不会翻译成其他语言，并且也相当没有意义。
   </para>
<!-- pgdoc-cn_end sig_en=93c699c80a82209cecaca9cabe1c0997 -->

  </simplesect>

  <simplesect>
<!-- pgdoc-cn_start sig_en=d4302b592631376277da52ad0e2537d6 sig_cn_org=None source=14.1 
   <title>Use of Quotes</title>
________________________________________________________-->
   <title>引号的使用</title>
<!-- pgdoc-cn_end sig_en=d4302b592631376277da52ad0e2537d6 -->

<!-- pgdoc-cn_start sig_en=fb937bdc7fb53641f6ed9b2eac84b58f sig_cn_org=None source=14.1 
   <para>
    Always use quotes to delimit file names, user-supplied identifiers, and
    other variables that might contain words.  Do not use them to mark up
    variables that will not contain words (for example, operator names).
   </para>
________________________________________________________-->
   <para>
    总是用引号界定文件名、用户提供的标识符以及其他可能包含词的变量。不要用它们来标记不会包含词的变量（例如，操作符名称）。
   </para>
<!-- pgdoc-cn_end sig_en=fb937bdc7fb53641f6ed9b2eac84b58f -->

<!-- pgdoc-cn_start sig_en=b9422787554a7f741fc7288aced06033 sig_cn_org=None source=14.1 
   <para>
    There are functions in the backend that will double-quote their own output
    as needed (for example, <function>format_type_be()</function>).  Do not put
    additional quotes around the output of such functions.
   </para>
________________________________________________________-->
   <para>
    在后端有函数会根据需要对其自身的输出加上双引号（例如<function>format_type_be()</function>）。不要在这种函数的输出周围再加上额外的引号。
   </para>
<!-- pgdoc-cn_end sig_en=b9422787554a7f741fc7288aced06033 -->

<!-- pgdoc-cn_start sig_en=39f2841c55d54462b4b88f2f7bf7837c sig_cn_org=None source=14.1 
   <para>
    Rationale: Objects can have names that create ambiguity when embedded in a
    message.  Be consistent about denoting where a plugged-in name starts and
    ends.  But don't clutter messages with unnecessary or duplicate quote
    marks.
   </para>
________________________________________________________-->
   <para>
    原理：在被嵌入到一个消息时，对象可能具有产生歧义的名称。对于标记一个插入名称的开始和结束要始终如一。但不要在消息中混入不必要的或者重复的引号。
   </para>
<!-- pgdoc-cn_end sig_en=39f2841c55d54462b4b88f2f7bf7837c -->

  </simplesect>

  <simplesect>
<!-- pgdoc-cn_start sig_en=821bcdd07007694c718b80d460cfa1af sig_cn_org=None source=14.1 
   <title>Grammar and Punctuation</title>
________________________________________________________-->
   <title>语法和标点</title>
<!-- pgdoc-cn_end sig_en=821bcdd07007694c718b80d460cfa1af -->

<!-- pgdoc-cn_start sig_en=55204c92e193a45de6423842a12e315e sig_cn_org=None source=14.1 
   <para>
    The rules are different for primary error messages and for detail/hint
    messages:
   </para>
________________________________________________________-->
   <para>
    主要错误消息的规则与详细/提示消息的规则不同：
   </para>
<!-- pgdoc-cn_end sig_en=55204c92e193a45de6423842a12e315e -->

<!-- pgdoc-cn_start sig_en=e3b706a1133dfcc0ee438fc95164a4eb sig_cn_org=None source=14.1 
   <para>
    Primary error messages: Do not capitalize the first letter.  Do not end a
    message with a period.  Do not even think about ending a message with an
    exclamation point.
   </para>
________________________________________________________-->
   <para>
    主要错误消息：不要大写第一个字母。不要用一个句号结束一个消息。甚至不要考虑用一个感叹号结束一个消息。
   </para>
<!-- pgdoc-cn_end sig_en=e3b706a1133dfcc0ee438fc95164a4eb -->

<!-- pgdoc-cn_start sig_en=31b640d82aa0377da60e7a8bbaa38afc sig_cn_org=None source=14.1 
   <para>
    Detail and hint messages: Use complete sentences, and end each with
    a period.  Capitalize the first word of sentences.  Put two spaces after
    the period if another sentence follows (for English text; might be
    inappropriate in other languages).
   </para>
________________________________________________________-->
   <para>
    详细和提示消息：使用完整的句子，并且每一个都用句号结束。对句子的第一个词进行首字母大写。如果后面跟着另一个句子，在句号后面放两个空格（对于英语文本有效，在其他语言中可能不合适）。
   </para>
<!-- pgdoc-cn_end sig_en=31b640d82aa0377da60e7a8bbaa38afc -->

<!-- pgdoc-cn_start sig_en=14d99d66322ce0c5a4bf599f44727e27 sig_cn_org=None source=14.1 
   <para>
    Error context strings: Do not capitalize the first letter and do
    not end the string with a period.  Context strings should normally
    not be complete sentences.
   </para>
________________________________________________________-->
   <para>
    错误上下文字符串：不要大写第一个字母并且不要用一个句号结束字符串。上下文字符串通常不应该是完整的句子。
   </para>
<!-- pgdoc-cn_end sig_en=14d99d66322ce0c5a4bf599f44727e27 -->

<!-- pgdoc-cn_start sig_en=e0179ee7f35c8500610a24873a5dc4a5 sig_cn_org=None source=14.1 
   <para>
    Rationale: Avoiding punctuation makes it easier for client applications to
    embed the message into a variety of grammatical contexts.  Often, primary
    messages are not grammatically complete sentences anyway.  (And if they're
    long enough to be more than one sentence, they should be split into
    primary and detail parts.)  However, detail and hint messages are longer
    and might need to include multiple sentences.  For consistency, they should
    follow complete-sentence style even when there's only one sentence.
   </para>
________________________________________________________-->
   <para>
    原理：避免标点让客户端应用能更容易地把消息嵌入到各种各样的语法上下文中。通常主要消息不是语法上完整的句子（并且如果它们比一个句子还长，它们应该被分成主要和详细部分）。不过，详细和提示消息会更长并且需要包括多个句子。为了一致，即便它们只是一个句子，它们也应该遵循完整句子的风格。
   </para>
<!-- pgdoc-cn_end sig_en=e0179ee7f35c8500610a24873a5dc4a5 -->

  </simplesect>

  <simplesect>
<!-- pgdoc-cn_start sig_en=6474e5bf1814aaa86ef44027476eb59d sig_cn_org=None source=14.1 
   <title>Upper Case vs. Lower Case</title>
________________________________________________________-->
   <title>大写 vs. 小写</title>
<!-- pgdoc-cn_end sig_en=6474e5bf1814aaa86ef44027476eb59d -->

<!-- pgdoc-cn_start sig_en=3135dc514ddce2667b5fcdc0750de6c8 sig_cn_org=None source=14.1 
   <para>
    Use lower case for message wording, including the first letter of a
    primary error message.  Use upper case for SQL commands and key words if
    they appear in the message.
   </para>
________________________________________________________-->
   <para>
    对消息使用小写形式，包括一个主要错误消息的第一个字母。如果 SQL 命令或者关键词出现在消息中，为它们使用大写形式。
   </para>
<!-- pgdoc-cn_end sig_en=3135dc514ddce2667b5fcdc0750de6c8 -->

<!-- pgdoc-cn_start sig_en=ebb81055407616c568d4324c7d4fad60 sig_cn_org=None source=14.1 
   <para>
    Rationale: It's easier to make everything look more consistent this
    way, since some messages are complete sentences and some not.
   </para>
________________________________________________________-->
   <para>
    原理：用这种方式能更容易使所有的东西看起来更加一致，因为一些消息是完整的句子而另一些不是。
   </para>
<!-- pgdoc-cn_end sig_en=ebb81055407616c568d4324c7d4fad60 -->

  </simplesect>

  <simplesect>
<!-- pgdoc-cn_start sig_en=deb6e0932b793b70fed078d74cd22eae sig_cn_org=None source=14.1 
   <title>Avoid Passive Voice</title>
________________________________________________________-->
   <title>避免被动态</title>
<!-- pgdoc-cn_end sig_en=deb6e0932b793b70fed078d74cd22eae -->

<!-- pgdoc-cn_start sig_en=b09b627e7efce648fe1da74f16ca6ade sig_cn_org=None source=14.1 
   <para>
    Use the active voice.  Use complete sentences when there is an acting
    subject (<quote>A could not do B</quote>).  Use telegram style without
    subject if the subject would be the program itself; do not use
    <quote>I</quote> for the program.
   </para>
________________________________________________________-->
   <para>
    使用主动语态。在有主语时使用完整句子（<quote>A could not do B</quote>）。如果主语是程序本身，使用没有主语的电报风格，但不要为程序使用<quote>I</quote>。
   </para>
<!-- pgdoc-cn_end sig_en=b09b627e7efce648fe1da74f16ca6ade -->

<!-- pgdoc-cn_start sig_en=779e6f5975b9865be9b0765c5a18a3cf sig_cn_org=None source=14.1 
   <para>
    Rationale: The program is not human.  Don't pretend otherwise.
   </para>
________________________________________________________-->
   <para>
    原理：程序不是人类。所以不要假装。
   </para>
<!-- pgdoc-cn_end sig_en=779e6f5975b9865be9b0765c5a18a3cf -->

  </simplesect>

  <simplesect>
<!-- pgdoc-cn_start sig_en=4a1e5e41d12576efddccf43cd1d9efd8 sig_cn_org=None source=14.1 
   <title>Present vs. Past Tense</title>
________________________________________________________-->
   <title>现在式 vs. 过去式</title>
<!-- pgdoc-cn_end sig_en=4a1e5e41d12576efddccf43cd1d9efd8 -->

<!-- pgdoc-cn_start sig_en=233cee4f018e1420256aa83168c4d626 sig_cn_org=None source=14.1 
   <para>
    Use past tense if an attempt to do something failed, but could perhaps
    succeed next time (perhaps after fixing some problem).  Use present tense
    if the failure is certainly permanent.
   </para>
________________________________________________________-->
   <para>
    如果一次尝试做某事失败但是可能在下一次成功（也许在修复某个问题之后），则使用过去式。如果失败必定是持久的，使用现在式。
   </para>
<!-- pgdoc-cn_end sig_en=233cee4f018e1420256aa83168c4d626 -->

<!-- pgdoc-cn_start sig_en=5eb45a9dfee1e31819defa3c035e4417 sig_cn_org=None source=14.1 
   <para>
    There is a nontrivial semantic difference between sentences of the form:
<programlisting>
could not open file "%s": %m
</programlisting>
and:
<programlisting>
cannot open file "%s"
</programlisting>
    The first one means that the attempt to open the file failed.  The
    message should give a reason, such as <quote>disk full</quote> or
    <quote>file doesn't exist</quote>.  The past tense is appropriate because
    next time the disk might not be full anymore or the file in question might
    exist.
   </para>
________________________________________________________-->
   <para>
    在以下形式的句子之间存在着非平凡的语义区别：
<programlisting>
could not open file "%s": %m
</programlisting>
和
<programlisting>
cannot open file "%s"
</programlisting>
    第一个表示打开文件的尝试失败。该消息应该给出一个原因，例如<quote>磁盘满</quote>或者<quote>文件不存在</quote>。过去式更合适，因为下一次磁盘可能不再满或者请求的文件可能就存在了。
   </para>
<!-- pgdoc-cn_end sig_en=5eb45a9dfee1e31819defa3c035e4417 -->

<!-- pgdoc-cn_start sig_en=82c7ca12221c99846d0600a227d9d73a sig_cn_org=None source=14.1 
   <para>
    The second form indicates that the functionality of opening the named file
    does not exist at all in the program, or that it's conceptually
    impossible.  The present tense is appropriate because the condition will
    persist indefinitely.
   </para>
________________________________________________________-->
   <para>
    第二种形式指示打开所提及文件的功能在程序中根本就不存在，或者概念上是不可能的。现在式更合适，因为该情况将无限期保持。
   </para>
<!-- pgdoc-cn_end sig_en=82c7ca12221c99846d0600a227d9d73a -->

<!-- pgdoc-cn_start sig_en=9ff90d9b111b461f4a4e3646cb3ea59f sig_cn_org=None source=14.1 
   <para>
    Rationale: Granted, the average user will not be able to draw great
    conclusions merely from the tense of the message, but since the language
    provides us with a grammar we should use it correctly.
   </para>
________________________________________________________-->
   <para>
    原理：诚然，普通用户没有能力从消息的时态上得出重要的结论，但是既然语言为我们提供了语法，我们就应该正确地使用它。
   </para>
<!-- pgdoc-cn_end sig_en=9ff90d9b111b461f4a4e3646cb3ea59f -->

  </simplesect>

  <simplesect>
<!-- pgdoc-cn_start sig_en=d77131a9b00c0d18b1195600860de264 sig_cn_org=None source=14.1 
   <title>Type of the Object</title>
________________________________________________________-->
   <title>对象类型</title>
<!-- pgdoc-cn_end sig_en=d77131a9b00c0d18b1195600860de264 -->

<!-- pgdoc-cn_start sig_en=30934801d121d11f17aa5a2d6c29d333 sig_cn_org=None source=14.1 
   <para>
    When citing the name of an object, state what kind of object it is.
   </para>
________________________________________________________-->
   <para>
    在引用一个对象的名称时，说明该对象的种类。
   </para>
<!-- pgdoc-cn_end sig_en=30934801d121d11f17aa5a2d6c29d333 -->

<!-- pgdoc-cn_start sig_en=b891147f1b15c42fe94801cc3d002d69 sig_cn_org=None source=14.1 
   <para>
    Rationale: Otherwise no one will know what <quote>foo.bar.baz</quote>
    refers to.
   </para>
________________________________________________________-->
   <para>
    原理：否则没有人会知道 <quote>foo.bar.baz</quote> 是什么。
   </para>
<!-- pgdoc-cn_end sig_en=b891147f1b15c42fe94801cc3d002d69 -->

  </simplesect>

  <simplesect>
<!-- pgdoc-cn_start sig_en=a4a8c59eacb5eb2c164217d0da8daa12 sig_cn_org=None source=14.1 
   <title>Brackets</title>
________________________________________________________-->
   <title>括号</title>
<!-- pgdoc-cn_end sig_en=a4a8c59eacb5eb2c164217d0da8daa12 -->

<!-- pgdoc-cn_start sig_en=413b6b8dc021c696da5c62463f3e1f2a sig_cn_org=None source=14.1 
   <para>
    Square brackets are only to be used (1) in command synopses to denote
    optional arguments, or (2) to denote an array subscript.
   </para>
________________________________________________________-->
   <para>
    方括号只被用于： (1) 在命令对照表中标记可选参数，或者 (2) 用于标记一个数组下标。
   </para>
<!-- pgdoc-cn_end sig_en=413b6b8dc021c696da5c62463f3e1f2a -->

<!-- pgdoc-cn_start sig_en=0ec411c3dc43d60616529039931ae790 sig_cn_org=None source=14.1 
   <para>
    Rationale: Anything else does not correspond to widely-known customary
    usage and will confuse people.
   </para>
________________________________________________________-->
   <para>
    原理：任何其他用法都无法符合众所周知的使用习惯，并且会使人们感到困惑。
   </para>
<!-- pgdoc-cn_end sig_en=0ec411c3dc43d60616529039931ae790 -->

  </simplesect>

  <simplesect>
<!-- pgdoc-cn_start sig_en=7ce7fcab19d96dc29361d05eb8d5ad5b sig_cn_org=None source=14.1 
   <title>Assembling Error Messages</title>
________________________________________________________-->
   <title>组装错误消息</title>
<!-- pgdoc-cn_end sig_en=7ce7fcab19d96dc29361d05eb8d5ad5b -->

<!-- pgdoc-cn_start sig_en=00350b2a4bbf1be8a805bc86ca85107d sig_cn_org=None source=14.1 
   <para>
   When a message includes text that is generated elsewhere, embed it in
   this style:
<programlisting>
could not open file %s: %m
</programlisting>
   </para>
________________________________________________________-->
   <para>
   当一个消息包括在别处产生的文本时，这样将它嵌入：
<programlisting>
could not open file %s: %m
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=00350b2a4bbf1be8a805bc86ca85107d -->

<!-- pgdoc-cn_start sig_en=0758a61de17588226d807ddf7562502b sig_cn_org=None source=14.1 
   <para>
    Rationale: It would be difficult to account for all possible error codes
    to paste this into a single smooth sentence, so some sort of punctuation
    is needed.  Putting the embedded text in parentheses has also been
    suggested, but it's unnatural if the embedded text is likely to be the
    most important part of the message, as is often the case.
   </para>
________________________________________________________-->
   <para>
    原理：将这种文本粘贴到一个单一的语句中很难解释所有可能的错误代码，因此需要某种标点。也有人建议把被嵌入的文本放在圆括号中，但是如果被嵌入的文本可能是消息中最重要的一部分（这是常有的事）时就显得不自然。
   </para>
<!-- pgdoc-cn_end sig_en=0758a61de17588226d807ddf7562502b -->

  </simplesect>

  <simplesect>
<!-- pgdoc-cn_start sig_en=d84325768808be6477e3c6e63d63b4d8 sig_cn_org=None source=14.1 
   <title>Reasons for Errors</title>
________________________________________________________-->
   <title>错误原因</title>
<!-- pgdoc-cn_end sig_en=d84325768808be6477e3c6e63d63b4d8 -->

<!-- pgdoc-cn_start sig_en=0ba2ec5f68f9226b951a36afc6a12660 sig_cn_org=None source=14.1 
   <para>
    Messages should always state the reason why an error occurred.
    For example:
<programlisting>
BAD:    could not open file %s
BETTER: could not open file %s (I/O failure)
</programlisting>
    If no reason is known you better fix the code.
   </para>
________________________________________________________-->
   <para>
    消息应该总是说明为什么错误会发生的原因。例如：
<programlisting>
BAD:    could not open file %s
BETTER: could not open file %s (I/O failure)
</programlisting>
    如果不知道原因，你最好修复代码。
   </para>
<!-- pgdoc-cn_end sig_en=0ba2ec5f68f9226b951a36afc6a12660 -->

  </simplesect>

  <simplesect>
<!-- pgdoc-cn_start sig_en=c7eaf75f53d78185aaeb411783c9cba9 sig_cn_org=None source=14.1 
   <title>Function Names</title>
________________________________________________________-->
   <title>函数名</title>
<!-- pgdoc-cn_end sig_en=c7eaf75f53d78185aaeb411783c9cba9 -->

<!-- pgdoc-cn_start sig_en=73a67413bd65015950cfcb9d181cbab2 sig_cn_org=None source=14.1 
   <para>
    Don't include the name of the reporting routine in the error text. We have
    other mechanisms for finding that out when needed, and for most users it's
    not helpful information.  If the error text doesn't make as much sense
    without the function name, reword it.
<programlisting>
BAD:    pg_strtoint32: error in "z": cannot parse "z"
BETTER: invalid input syntax for type integer: "z"
</programlisting>
   </para>
________________________________________________________-->
   <para>
    不要在错误文本中包括报告例程的名称。需要时，我们有其他机制能够知道这些，并且对于大部分用户来说这种信息没有用处。如果没有函数名错误文本就没有意义，那么请重写它。
<programlisting>
BAD:    pg_strtoint32: error in "z": cannot parse "z"
BETTER: invalid input syntax for type integer: "z"
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=73a67413bd65015950cfcb9d181cbab2 -->

<!-- pgdoc-cn_start sig_en=8950e9a31a3cfbc58dbbc6f0578591b5 sig_cn_org=None source=14.1 
   <para>
    Avoid mentioning called function names, either; instead say what the code
    was trying to do:
<programlisting>
BAD:    open() failed: %m
BETTER: could not open file %s: %m
</programlisting>
    If it really seems necessary, mention the system call in the detail
    message.  (In some cases, providing the actual values passed to the
    system call might be appropriate information for the detail message.)
   </para>
________________________________________________________-->
   <para>
    也要避免提及被调用的函数名，而是说出代码试图做什么：
<programlisting>
BAD:    open() failed: %m
BETTER: could not open file %s: %m
</programlisting>
    如果它真地看起来必要，在详细消息中提及系统调用（在某些情况中，可以为详细消息提供传递给系统调用的实际值）。
   </para>
<!-- pgdoc-cn_end sig_en=8950e9a31a3cfbc58dbbc6f0578591b5 -->

<!-- pgdoc-cn_start sig_en=cd60e0323e48425873d2c35c5213b32e sig_cn_org=None source=14.1 
   <para>
    Rationale: Users don't know what all those functions do.
   </para>
________________________________________________________-->
   <para>
    原理：用户不知道所有那些函数做了什么。
   </para>
<!-- pgdoc-cn_end sig_en=cd60e0323e48425873d2c35c5213b32e -->

  </simplesect>

  <simplesect>
<!-- pgdoc-cn_start sig_en=930c6102e08f6aa7b5e3be10a7b4ce19 sig_cn_org=None source=14.1 
   <title>Tricky Words to Avoid</title>
________________________________________________________-->
   <title>应该避免的捣蛋词</title>
<!-- pgdoc-cn_end sig_en=930c6102e08f6aa7b5e3be10a7b4ce19 -->

  <formalpara>
<!-- pgdoc-cn_start sig_en=72fd992b17c974ea9d76aa699b8360c6 sig_cn_org=None source=14.1 
    <title>Unable</title>
________________________________________________________-->
    <title>Unable</title>
<!-- pgdoc-cn_end sig_en=72fd992b17c974ea9d76aa699b8360c6 -->
<!-- pgdoc-cn_start sig_en=395f4872126643b3624c1b25e26ca029 sig_cn_org=None source=14.1 
   <para>
    <quote>Unable</quote> is nearly the passive voice.  Better use
    <quote>cannot</quote> or <quote>could not</quote>, as appropriate.
   </para>
________________________________________________________-->
   <para>
    <quote>Unable</quote>接近于被动态。酌情使用<quote>cannot</quote>或者<quote>could not</quote>更好。
   </para>
<!-- pgdoc-cn_end sig_en=395f4872126643b3624c1b25e26ca029 -->
  </formalpara>

  <formalpara>
<!-- pgdoc-cn_start sig_en=fea1018cdc1d69efa5bf607c5285645b sig_cn_org=None source=14.1 
    <title>Bad</title>
________________________________________________________-->
    <title>Bad</title>
<!-- pgdoc-cn_end sig_en=fea1018cdc1d69efa5bf607c5285645b -->
<!-- pgdoc-cn_start sig_en=83ec5667acc8401ee13e58b484b143d4 sig_cn_org=None source=14.1 
   <para>
    Error messages like <quote>bad result</quote> are really hard to interpret
    intelligently.  It's better to write why the result is <quote>bad</quote>,
    e.g., <quote>invalid format</quote>.
   </para>
________________________________________________________-->
   <para>
    <quote>bad result</quote>之类的错误消息实在很难被解释。最好写出为什么结果<quote>不好</quote>，例如<quote>无效格式</quote>。
   </para>
<!-- pgdoc-cn_end sig_en=83ec5667acc8401ee13e58b484b143d4 -->
  </formalpara>

  <formalpara>
<!-- pgdoc-cn_start sig_en=b1b499e6d3d9410147e36282088e6554 sig_cn_org=None source=14.1 
    <title>Illegal</title>
________________________________________________________-->
    <title>Illegal</title>
<!-- pgdoc-cn_end sig_en=b1b499e6d3d9410147e36282088e6554 -->
<!-- pgdoc-cn_start sig_en=09268d3031f25b880f9734812cbdd4d8 sig_cn_org=None source=14.1 
   <para>
    <quote>Illegal</quote> stands for a violation of the law, the rest is
    <quote>invalid</quote>. Better yet, say why it's invalid.
   </para>
________________________________________________________-->
   <para>
    <quote>Illegal</quote>表示违背了法律，类似的还有<quote>invalid</quote>。更好的是，说明为什么无效。
   </para>
<!-- pgdoc-cn_end sig_en=09268d3031f25b880f9734812cbdd4d8 -->
  </formalpara>

  <formalpara>
<!-- pgdoc-cn_start sig_en=45656c324aae85d8528690fa50058dad sig_cn_org=None source=14.1 
    <title>Unknown</title>
________________________________________________________-->
    <title>Unknown</title>
<!-- pgdoc-cn_end sig_en=45656c324aae85d8528690fa50058dad -->
<!-- pgdoc-cn_start sig_en=2611d5c843afd3cb8fa4c6e16ac912df sig_cn_org=None source=14.1 
   <para>
    Try to avoid <quote>unknown</quote>.  Consider <quote>error: unknown
    response</quote>.  If you don't know what the response is, how do you know
    it's erroneous? <quote>Unrecognized</quote> is often a better choice.
    Also, be sure to include the value being complained of.
<programlisting>
BAD:    unknown node type
BETTER: unrecognized node type: 42
</programlisting>
   </para>
________________________________________________________-->
   <para>
    尝试避免<quote>unknown</quote>。考虑<quote>error: unknown
    response</quote>。如果你不知道响应是什么，你怎么知道它是错误的？<quote>Unrecognized</quote>常常是一个更好的选择。还有，一定要包括被抱怨的值。
<programlisting>
BAD:    unknown node type
BETTER: unrecognized node type: 42
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=2611d5c843afd3cb8fa4c6e16ac912df -->
  </formalpara>

  <formalpara>
<!-- pgdoc-cn_start sig_en=ed078524a798f782ad092b06cde4cd6f sig_cn_org=None source=14.1 
    <title>Find vs. Exists</title>
________________________________________________________-->
    <title>找到 vs. 存在</title>
<!-- pgdoc-cn_end sig_en=ed078524a798f782ad092b06cde4cd6f -->
<!-- pgdoc-cn_start sig_en=4731b32139da2a671589609e0cf50802 sig_cn_org=None source=14.1 
   <para>
    If the program uses a nontrivial algorithm to locate a resource (e.g., a
    path search) and that algorithm fails, it is fair to say that the program
    couldn't <quote>find</quote> the resource.  If, on the other hand, the
    expected location of the resource is known but the program cannot access
    it there then say that the resource doesn't <quote>exist</quote>.  Using
    <quote>find</quote> in this case sounds weak and confuses the issue.
   </para>
________________________________________________________-->
   <para>
    如果程序使用了一个非平凡的算法来定位一个资源（例如一个路径搜索）并且该算法失败了，说该程序无法<quote>找到</quote>该资源比较公平。换句话说，如果该资源应该在的位置是已知的，但是程序无法在那里访问它，那么才说该资源不<quote>存在</quote>。在这种情况中使用<quote>找到</quote>听起来很弱并且会使问题混淆。
   </para>
<!-- pgdoc-cn_end sig_en=4731b32139da2a671589609e0cf50802 -->
  </formalpara>

  <formalpara>
<!-- pgdoc-cn_start sig_en=1766c7b7b40d9cb413954c98f8df87df sig_cn_org=None source=14.1 
    <title>May vs. Can vs. Might</title>
________________________________________________________-->
    <title>May vs. Can vs. Might</title>
<!-- pgdoc-cn_end sig_en=1766c7b7b40d9cb413954c98f8df87df -->
<!-- pgdoc-cn_start sig_en=060a18cb5e36c5e614816b8929060be9 sig_cn_org=None source=14.1 
   <para>
    <quote>May</quote> suggests permission (e.g., "You may borrow my rake."),
    and has little use in documentation or error messages.
    <quote>Can</quote> suggests ability (e.g., "I can lift that log."),
    and <quote>might</quote> suggests possibility (e.g., "It might rain
    today.").  Using the proper word clarifies meaning and assists
    translation.
   </para>
________________________________________________________-->
   <para>
    <quote>May</quote>表示权限（例如，"You may borrow my rake."），并且在文档或错误消息中用处有限。
    <quote>Can</quote>表示能力（例如，"I can lift that log."），而<quote>might</quote>表示可能性（例如，"It might rain
    today."）。请使用合适的词来使含义清晰并且便于翻译。
   </para>
<!-- pgdoc-cn_end sig_en=060a18cb5e36c5e614816b8929060be9 -->
  </formalpara>

  <formalpara>
<!-- pgdoc-cn_start sig_en=f3a7d5c411cfd41c9a4d6d2ea09633ce sig_cn_org=None source=14.1 
    <title>Contractions</title>
________________________________________________________-->
    <title>缩略形式</title>
<!-- pgdoc-cn_end sig_en=f3a7d5c411cfd41c9a4d6d2ea09633ce -->
<!-- pgdoc-cn_start sig_en=3593070b3e549bf476983a4d0ecc624b sig_cn_org=None source=14.1 
   <para>
    Avoid contractions, like <quote>can't</quote>;  use
    <quote>cannot</quote> instead.
   </para>
________________________________________________________-->
   <para>
    避免缩略，如<quote>can't</quote>，请使用<quote>cannot</quote>。
   </para>
<!-- pgdoc-cn_end sig_en=3593070b3e549bf476983a4d0ecc624b -->
  </formalpara>

  <formalpara>
<!-- pgdoc-cn_start sig_en=197d2e09b346b5fd03f8b27e82b85488 sig_cn_org=None source=14.1 
    <title>Non-negative</title>
________________________________________________________-->
    <title>Non-negative</title>
<!-- pgdoc-cn_end sig_en=197d2e09b346b5fd03f8b27e82b85488 -->
<!-- pgdoc-cn_start sig_en=30b800a3f39ed7855259bcd3b6b30ed2 sig_cn_org=None source=14.1 
   <para>
    Avoid <quote>non-negative</quote> as it is ambiguous
    about whether it accepts zero.  It's better to use
    <quote>greater than zero</quote> or
    <quote>greater than or equal to zero</quote>.
   </para>
________________________________________________________-->
   <para>
    避免<quote>non-negative</quote>，因为它不能清楚表达是否接受0。最好使用<quote>greater than zero</quote>或<quote>greater than or equal to zero</quote>。
   </para>
<!-- pgdoc-cn_end sig_en=30b800a3f39ed7855259bcd3b6b30ed2 -->
  </formalpara>

  </simplesect>

  <simplesect>
<!-- pgdoc-cn_start sig_en=cad03d58a1520bd0805f2e149a4bbeaf sig_cn_org=None source=14.1 
   <title>Proper Spelling</title>
________________________________________________________-->
   <title>适当的拼写</title>
<!-- pgdoc-cn_end sig_en=cad03d58a1520bd0805f2e149a4bbeaf -->

<!-- pgdoc-cn_start sig_en=f57372d4d0e5774a6b0ead65f39f818f sig_cn_org=None source=14.1 
   <para>
    Spell out words in full.  For instance, avoid:
  <itemizedlist>
   <listitem>
    <para>
     spec
    </para>
   </listitem>
   <listitem>
    <para>
     stats
    </para>
   </listitem>
   <listitem>
    <para>
     parens
    </para>
   </listitem>
   <listitem>
    <para>
     auth
    </para>
   </listitem>
   <listitem>
    <para>
     xact
    </para>
   </listitem>
  </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    完整地拼出单词。例如，避免：
  <itemizedlist>
   <listitem>
    <para>
     spec
    </para>
   </listitem>
   <listitem>
    <para>
     stats
    </para>
   </listitem>
   <listitem>
    <para>
     parens
    </para>
   </listitem>
   <listitem>
    <para>
     auth
    </para>
   </listitem>
   <listitem>
    <para>
     xact
    </para>
   </listitem>
  </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=f57372d4d0e5774a6b0ead65f39f818f -->

<!-- pgdoc-cn_start sig_en=92903bc7f0b63f1b3be3d8d1251f9f77 sig_cn_org=None source=14.1 
   <para>
    Rationale: This will improve consistency.
   </para>
________________________________________________________-->
   <para>
    基本原理：这将增强一致性。
   </para>
<!-- pgdoc-cn_end sig_en=92903bc7f0b63f1b3be3d8d1251f9f77 -->

  </simplesect>

  <simplesect>
<!-- pgdoc-cn_start sig_en=41959eb28084b2bfff21336961fd28d1 sig_cn_org=None source=14.1 
   <title>Localization</title>
________________________________________________________-->
   <title>本地化</title>
<!-- pgdoc-cn_end sig_en=41959eb28084b2bfff21336961fd28d1 -->

<!-- pgdoc-cn_start sig_en=dabb177f6b2347330a6fc358e3e3490b sig_cn_org=None source=14.1 
   <para>
    Keep in mind that error message texts need to be translated into other
    languages.  Follow the guidelines in <xref linkend="nls-guidelines"/>
    to avoid making life difficult for translators.
   </para>
________________________________________________________-->
   <para>
    记住错误消息文本需要被翻译成其他语言。请遵循<xref linkend="nls-guidelines"/>中的方针以避免让翻译者为难。
   </para>
<!-- pgdoc-cn_end sig_en=dabb177f6b2347330a6fc358e3e3490b -->
  </simplesect>

  </sect1>

  <sect1 id="source-conventions">
<!-- pgdoc-cn_start sig_en=f0d9c97973ff67e2be568cbe19f2f5e1 sig_cn_org=None source=14.1 
   <title>Miscellaneous Coding Conventions</title>
________________________________________________________-->
   <title>其他编码习惯</title>
<!-- pgdoc-cn_end sig_en=f0d9c97973ff67e2be568cbe19f2f5e1 -->

   <simplesect>
<!-- pgdoc-cn_start sig_en=0664a37afb9e8d9db5fb037858adf438 sig_cn_org=None source=14.1 
    <title>C Standard</title>
________________________________________________________-->
    <title>C 标准</title>
<!-- pgdoc-cn_end sig_en=0664a37afb9e8d9db5fb037858adf438 -->
<!-- pgdoc-cn_start sig_en=2c5aec3becab3f1d033cb9e957d52e41 sig_cn_org=None source=14.1 
    <para>
     Code in <productname>PostgreSQL</productname> should only rely on language
     features available in the C99 standard. That means a conforming
     C99 compiler has to be able to compile postgres, at least aside
     from a few platform dependent pieces.
    </para>
________________________________________________________-->
    <para>
     <productname>PostgreSQL</productname>中的代码应该只依赖于 C99 标准中的语言特性。这意味着遵循 C99 的编译器一定能编译 postgres，至少除开少数平台依赖问题之外。
    </para>
<!-- pgdoc-cn_end sig_en=2c5aec3becab3f1d033cb9e957d52e41 -->
<!-- pgdoc-cn_start sig_en=66ba33accdae103c972be6dbbba7c738 sig_cn_org=None source=14.1 
    <para>
     A few features included in the C99 standard are, at this time, not
     permitted to be used in core <productname>PostgreSQL</productname>
     code. This currently includes variable length arrays, intermingled
     declarations and code, <literal>//</literal> comments, universal
     character names. Reasons for that include portability and historical
     practices.
    </para>
________________________________________________________-->
    <para>
     目前，C99 标准中包含的一些特性，不允许用于核心功能 <productname>PostgreSQL</productname>代码。
     这当前包括可变长度数组、混合声明和代码、<literal>//</literal> 注释、通用字符名称。原因包括可移植性和历史实践。
    </para>
<!-- pgdoc-cn_end sig_en=66ba33accdae103c972be6dbbba7c738 -->
<!-- pgdoc-cn_start sig_en=360229d94615a9a125450734ef5f6d68 sig_cn_org=None source=14.1 
    <para>
     Features from later revisions of the C standard or compiler specific
     features can be used, if a fallback is provided.
    </para>
________________________________________________________-->
    <para>
     如果提供了回退，则可以使用 C 标准或编译器后续版本中的特性。
    </para>
<!-- pgdoc-cn_end sig_en=360229d94615a9a125450734ef5f6d68 -->
<!-- pgdoc-cn_start sig_en=405090928a42c0791b7896bcdde305df sig_cn_org=None source=14.1 
    <para>
     For example <literal>_Static_assert()</literal> and
     <literal>__builtin_constant_p</literal> are currently used, even though
     they are from newer revisions of the C standard and a
     <productname>GCC</productname> extension respectively. If not available
     we respectively fall back to using a C99 compatible replacement that
     performs the same checks, but emits rather cryptic messages and do not
     use <literal>__builtin_constant_p</literal>.
    </para>
________________________________________________________-->
    <para>
     例如当前使用的 <literal>_Static_assert()</literal> 和 <literal>__builtin_constant_p</literal> , 即使它们分别来自 C 标准的更新修订和 <productname>GCC</productname>扩展。
     如果没有，我们分别回退到 C99 兼容替换来执行相同的检查，但会发出相当神秘的消息，并且不使用<literal>__builtin_constant_p</literal>。
    </para>
<!-- pgdoc-cn_end sig_en=405090928a42c0791b7896bcdde305df -->
   </simplesect>

   <simplesect>
<!-- pgdoc-cn_start sig_en=70b9c07c24788fe1b839b188bd851e70 sig_cn_org=None source=14.1 
    <title>Function-Like Macros and Inline Functions</title>
________________________________________________________-->
    <title>类函数的宏以及内联函数</title>
<!-- pgdoc-cn_end sig_en=70b9c07c24788fe1b839b188bd851e70 -->
<!-- pgdoc-cn_start sig_en=cd83399a805e5c9ff2a25288c3199932 sig_cn_org=d8496905dd85864213271ed7aaac04da source=15.7 
    <para>
     Both macros with arguments and <literal>static inline</literal>
     functions may be used. The latter are preferable if there are
     multiple-evaluation hazards when written as a macro, as e.g., the
     case with
<programlisting>
#define Max(x, y)       ((x) > (y) ? (x) : (y))
</programlisting>
     or when the macro would be very long. In other cases it's only
     possible to use macros, or at least easier.  For example because
     expressions of various types need to be passed to the macro.
    </para>
________________________________________________________-->
    <para>
     带参数的宏和<literal>静态内联</literal>函数都可以使用。如果在宏中存在多次评估的风险，
     则后者更可取，例如，像下面这样写一个宏的情况：
<programlisting>
#define Max(x, y)       ((x) > (y) ? (x) : (y))
</programlisting>
     或者当宏会非常长时。在其他情况下，只能使用宏，或者至少更容易。例如，因为需要将各种类型的表达式传递给宏。
    </para>
<!-- pgdoc-cn_end sig_en=cd83399a805e5c9ff2a25288c3199932 -->
<!-- pgdoc-cn_start sig_en=c38526dd7367829d7aec13aa1ff062e2 sig_cn_org=None source=14.1 
    <para>
     When the definition of an inline function references symbols
     (i.e., variables, functions) that are only available as part of the
     backend, the function may not be visible when included from frontend
     code.
<programlisting>
#ifndef FRONTEND
static inline MemoryContext
MemoryContextSwitchTo(MemoryContext context)
{
    MemoryContext old = CurrentMemoryContext;

    CurrentMemoryContext = context;
    return old;
}
#endif   /* FRONTEND */
</programlisting>
     In this example <literal>CurrentMemoryContext</literal>, which is only
     available in the backend, is referenced and the function thus
     hidden with a <literal>#ifndef FRONTEND</literal>. This rule
     exists because some compilers emit references to symbols
     contained in inline functions even if the function is not used.
    </para>
________________________________________________________-->
    <para>
     当一个内联函数的定义引用只在后端中可用的符号（即变量、函数）时，从前端代码引用该函数时该函数可能不可见。
<programlisting>
#ifndef FRONTEND
static inline MemoryContext
MemoryContextSwitchTo(MemoryContext context)
{
    MemoryContext old = CurrentMemoryContext;

    CurrentMemoryContext = context;
    return old;
}
#endif   /* FRONTEND */
</programlisting>
     在这个例子中，<literal>CurrentMemoryContext</literal>只在后端中可用，但该函数引用了它并且该函数因此被<literal>#ifndef FRONTEND</literal>隐藏。之所以存在这条规则，是因为即使内联函数中包含的符号没有被使用，有些编译器也会发出对它们的引用。
    </para>
<!-- pgdoc-cn_end sig_en=c38526dd7367829d7aec13aa1ff062e2 -->
   </simplesect>

   <simplesect>
<!-- pgdoc-cn_start sig_en=e71f13b086e05e01ae0f814e2c429aaf sig_cn_org=None source=14.1 
    <title>Writing Signal Handlers</title>
________________________________________________________-->
    <title>编写信号处理器</title>
<!-- pgdoc-cn_end sig_en=e71f13b086e05e01ae0f814e2c429aaf -->
<!-- pgdoc-cn_start sig_en=efee4680a07acae4b23397c1556565f1 sig_cn_org=None source=14.1 
    <para>
     To be suitable to run inside a signal handler code has to be
     written very carefully. The fundamental problem is that, unless
     blocked, a signal handler can interrupt code at any time. If code
     inside the signal handler uses the same state as code outside
     chaos may ensue. As an example consider what happens if a signal
     handler tries to acquire a lock that's already held in the
     interrupted code.
    </para>
________________________________________________________-->
    <para>
     为了能适合在信号处理器中运行，代码必须被非常仔细地编写。根本问题是，除非被阻塞，信号处理器能在任何时候打断代码。如果信号处理器内部的代码使用和外面代码相同的状态，很可能会出现混乱。例如，可以想想如果一个信号处理器试图取得已经在被打断代码中持有的锁时会发生什么。
    </para>
<!-- pgdoc-cn_end sig_en=efee4680a07acae4b23397c1556565f1 -->
<!-- pgdoc-cn_start sig_en=a5d9dcd218bd4f17d37340236291a906 sig_cn_org=None source=14.1 
    <para>
     Barring special arrangements code in signal handlers may only
     call async-signal safe functions (as defined in POSIX) and access
     variables of type <literal>volatile sig_atomic_t</literal>. A few
     functions in <command>postgres</command> are also deemed signal safe, importantly
     <function>SetLatch()</function>.
    </para>
________________________________________________________-->
    <para>
     除特殊安排的代码之外，在信号处理器中只应该调用对异步信号安全的函数（如 POSIX 中定义的那样）并且只访问<literal>volatile sig_atomic_t</literal>类型的变量。一些<command>postgres</command>中的函数也被视作是信号安全的，其中很重要的一个是<function>SetLatch()</function>。
    </para>
<!-- pgdoc-cn_end sig_en=a5d9dcd218bd4f17d37340236291a906 -->
<!-- pgdoc-cn_start sig_en=f85d138b3edc4cbfd45831b0407f4d11 sig_cn_org=None source=14.1 
    <para>
     In most cases signal handlers should do nothing more than note
     that a signal has arrived, and wake up code running outside of
     the handler using a latch. An example of such a handler is the
     following:
<programlisting>
static void
handle_sighup(SIGNAL_ARGS)
{
    int         save_errno = errno;

    got_SIGHUP = true;
    SetLatch(MyLatch);

    errno = save_errno;
}
</programlisting>
     <varname>errno</varname> is saved and restored because
     <function>SetLatch()</function> might change it. If that were not done
     interrupted code that's currently inspecting <varname>errno</varname> might see the wrong
     value.
    </para>
________________________________________________________-->
    <para>
     在大部分情况下，信号处理器应该只提示一个信号已经到达，并且使用一个 latch 唤醒运行在处理器之外的代码。这样一个处理器的例子如下：
<programlisting>
static void
handle_sighup(SIGNAL_ARGS)
{
    int         save_errno = errno;

    got_SIGHUP = true;
    SetLatch(MyLatch);

    errno = save_errno;
}
</programlisting>
     <varname>errno</varname>会被保存并且恢复，因为<function>SetLatch()</function>可能会更改它。如果不这样做，当前正在观测<varname>errno</varname>的被中断代码可能会看到错误的值。
    </para>
<!-- pgdoc-cn_end sig_en=f85d138b3edc4cbfd45831b0407f4d11 -->
   </simplesect>

   <simplesect>
<!-- pgdoc-cn_start sig_en=3adf1b964e33d8ee924f6697b28b5c7b sig_cn_org=None source=14.1 
    <title>Calling Function Pointers</title>
________________________________________________________-->
    <title>调用函数指针</title>
<!-- pgdoc-cn_end sig_en=3adf1b964e33d8ee924f6697b28b5c7b -->

<!-- pgdoc-cn_start sig_en=7bb707ba0e2f320dd8424372c84f5313 sig_cn_org=None source=14.1 
    <para>
     For clarity, it is preferred to explicitly dereference a function pointer
     when calling the pointed-to function if the pointer is a simple variable,
     for example:
<programlisting>
(*emit_log_hook) (edata);
</programlisting>
     (even though <literal>emit_log_hook(edata)</literal> would also work).
     When the function pointer is part of a structure, then the extra
     punctuation can and usually should be omitted, for example:
<programlisting>
paramInfo->paramFetch(paramInfo, paramId);
</programlisting>
    </para>
________________________________________________________-->
    <para>
     为了清晰，如果函数指针是一个简单的变量，在调用指向的函数时显式地对其解除引用会更好。例如：
<programlisting>
(*emit_log_hook) (edata);
</programlisting>
     （虽然<literal>emit_log_hook(edata)</literal>还会有效）。当函数指针是一个结构的组成部分时，则额外的标点符号能够被省略并且通常也应该被省略，例如：
<programlisting>
paramInfo->paramFetch(paramInfo, paramId);
</programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=7bb707ba0e2f320dd8424372c84f5313 -->
   </simplesect>
  </sect1>
 </chapter>
