<!-- doc/src/sgml/user-manag.sgml -->

<chapter id="user-manag">
<!-- pgdoc-cn_start sig_en=92d836d494feb6dbc612b950418f1c71 sig_cn_org=None source=14.1 
 <title>Database Roles</title>
________________________________________________________-->
 <title>数据库角色</title>
<!-- pgdoc-cn_end sig_en=92d836d494feb6dbc612b950418f1c71 -->

<!-- pgdoc-cn_start sig_en=b9ea7a65c1b26b473d10ddc874306d39 sig_cn_org=None source=14.1 
 <para>
  <productname>PostgreSQL</productname> manages database access permissions
  using the concept of <firstterm>roles</firstterm>.  A role can be thought of as
  either a database user, or a group of database users, depending on how
  the role is set up.  Roles can own database objects (for example, tables
  and functions) and can assign privileges on those objects to other roles to
  control who has access to which objects.  Furthermore, it is possible
  to grant <firstterm>membership</firstterm> in a role to another role, thus
  allowing the member role to use privileges assigned to another role.
 </para>
________________________________________________________-->
 <para>
  <productname>PostgreSQL</productname>使用<firstterm>角色</firstterm>的概念管理数据库访问权限。一个角色可以被看成是一个数据库用户或者是一个数据库用户组，这取决于角色被怎样设置。角色可以拥有数据库对象（例如，表和函数）并且能够把那些对象上的权限赋予给其他角色来控制谁能访问哪些对象。此外，还可以把一个角色中的<firstterm>成员资格</firstterm>授予给另一个角色，这样允许成员角色使用被赋予给另一个角色的权限。
 </para>
<!-- pgdoc-cn_end sig_en=b9ea7a65c1b26b473d10ddc874306d39 -->

<!-- pgdoc-cn_start sig_en=a42643078c454e6e048960d9d02aa8d5 sig_cn_org=None source=14.1 
 <para>
  The concept of roles subsumes the concepts of <quote>users</quote> and
  <quote>groups</quote>.  In <productname>PostgreSQL</productname> versions
  before 8.1, users and groups were distinct kinds of entities, but now
  there are only roles.  Any role can act as a user, a group, or both.
 </para>
________________________________________________________-->
 <para>
  角色的概念把<quote>用户</quote>和<quote>组</quote>的概念都包括在内。在<productname>PostgreSQL</productname>版本 8.1 之前，用户和组是完全不同的两种实体，但是现在只有角色。任意角色都可以扮演用户、组或者两者。
 </para>
<!-- pgdoc-cn_end sig_en=a42643078c454e6e048960d9d02aa8d5 -->

<!-- pgdoc-cn_start sig_en=f2b13f0deb4a64545e11ba94f23794c6 sig_cn_org=None source=14.1 
 <para>
  This chapter describes how to create and manage roles.
  More information about the effects of role privileges on various
  database objects can be found in <xref linkend="ddl-priv"/>.
 </para>
________________________________________________________-->
 <para>
  本章描述如何创建和管理角色。更多角色权限在多个数据库对象上的效果可以在<xref linkend="ddl-priv"/>中找到。
 </para>
<!-- pgdoc-cn_end sig_en=f2b13f0deb4a64545e11ba94f23794c6 -->

 <sect1 id="database-roles">
<!-- pgdoc-cn_start sig_en=92d836d494feb6dbc612b950418f1c71 sig_cn_org=None source=14.1 
  <title>Database Roles</title>
________________________________________________________-->
  <title>数据库角色</title>
<!-- pgdoc-cn_end sig_en=92d836d494feb6dbc612b950418f1c71 -->

<!-- pgdoc-cn_start sig_en=125c3303be5a97aa7b2b13e4e7d9ada6 sig_cn_org=None source=14.1 
  <indexterm zone="database-roles">
   <primary>role</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="database-roles">
   <primary>角色</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=125c3303be5a97aa7b2b13e4e7d9ada6 -->

<!-- pgdoc-cn_start sig_en=0dc7ae32e5ca5f5f1ee347de724ed953 sig_cn_org=None source=14.1 
  <indexterm zone="database-roles">
   <primary>user</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="database-roles">
   <primary>用户</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=0dc7ae32e5ca5f5f1ee347de724ed953 -->

<!-- pgdoc-cn_start sig_en=3000f6f70efaf336251f9d40820c1195 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>CREATE ROLE</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>CREATE ROLE</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=3000f6f70efaf336251f9d40820c1195 -->

<!-- pgdoc-cn_start sig_en=ccdcc25a48a9ab619d0c39ce2034fbfe sig_cn_org=None source=14.1 
  <indexterm>
   <primary>DROP ROLE</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>DROP ROLE</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=ccdcc25a48a9ab619d0c39ce2034fbfe -->

<!-- pgdoc-cn_start sig_en=cd440fb215a2f726468a72c01526237f sig_cn_org=None source=14.1 
  <para>
   Database roles are conceptually completely separate from
   operating system users. In practice it might be convenient to
   maintain a correspondence, but this is not required. Database roles
   are global across a database cluster installation (and not
   per individual database). To create a role use the <link
   linkend="sql-createrole"><command>CREATE ROLE</command></link> SQL command:
<synopsis>
CREATE ROLE <replaceable>name</replaceable>;
</synopsis>
   <replaceable>name</replaceable> follows the rules for SQL
   identifiers: either unadorned without special characters, or
   double-quoted.  (In practice, you will usually want to add additional
   options, such as <literal>LOGIN</literal>, to the command.  More details appear
   below.)  To remove an existing role, use the analogous
   <link linkend="sql-droprole"><command>DROP ROLE</command></link> command:
<synopsis>
DROP ROLE <replaceable>name</replaceable>;
</synopsis>
  </para>
________________________________________________________-->
  <para>
   数据库角色在概念上已经完全与操作系统用户独立开来。
   事实上可能维护一个对应关系会比较方便，但是这并非必需。
   数据库角色在一个数据库集簇安装范围内是全局的（而不是独立数据库内）。
   要创建一个角色，可使用<link linkend="sql-createrole"><command>CREATE ROLE</command></link> SQL 命令：
<synopsis>
CREATE ROLE <replaceable>name</replaceable>;
</synopsis>
   <replaceable>name</replaceable>遵循 SQL 标识符的规则：或是未经装饰没有特殊字符，或是用双引号包围（实际上，你将总是给该命令要加上额外选项，例如<literal>LOGIN</literal>。更多细节可见下文）。
   要移除一个已有的角色，使用相似的<link linkend="sql-droprole"><command>DROP ROLE</command></link>命令：
<synopsis>
DROP ROLE <replaceable>name</replaceable>;
</synopsis>
  </para>
<!-- pgdoc-cn_end sig_en=cd440fb215a2f726468a72c01526237f -->

<!-- pgdoc-cn_start sig_en=5646c3fbb5fa13b06e777f0a94ccf80f sig_cn_org=None source=14.1 
  <indexterm>
   <primary>createuser</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>createuser</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=5646c3fbb5fa13b06e777f0a94ccf80f -->

<!-- pgdoc-cn_start sig_en=a8246ae97b32fa863501f5daeaa0d0fd sig_cn_org=None source=14.1 
  <indexterm>
   <primary>dropuser</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>dropuser</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=a8246ae97b32fa863501f5daeaa0d0fd -->

<!-- pgdoc-cn_start sig_en=9202ccc20bd71b1dbf3d5a64f44f9c0a sig_cn_org=None source=14.1 
  <para>
   For convenience, the programs <xref linkend="app-createuser"/>
   and <xref linkend="app-dropuser"/> are provided as wrappers
   around these SQL commands that can be called from the shell command
   line:
<synopsis>
createuser <replaceable>name</replaceable>
dropuser <replaceable>name</replaceable>
</synopsis>
  </para>
________________________________________________________-->
  <para>
   为了方便，<xref linkend="app-createuser"/>和<xref linkend="app-dropuser"/>程序被提供作为这些 SQL 命令的包装器，它们可以从 shell 命令行调用：
<synopsis>
createuser <replaceable>name</replaceable>
dropuser <replaceable>name</replaceable>
</synopsis>
  </para>
<!-- pgdoc-cn_end sig_en=9202ccc20bd71b1dbf3d5a64f44f9c0a -->

<!-- pgdoc-cn_start sig_en=2a68358a00929b496ec922bcd284798c sig_cn_org=None source=14.1 
  <para>
   To determine the set of existing roles, examine the <structname>pg_roles</structname>
   system catalog, for example
<synopsis>
SELECT rolname FROM pg_roles;
</synopsis>
   The <xref linkend="app-psql"/> program's <literal>\du</literal> meta-command
   is also useful for listing the existing roles.
  </para>
________________________________________________________-->
  <para>
   要决定现有角色的集合，检查<structname>pg_roles</structname>系统目录，例如：
<synopsis>
SELECT rolname FROM pg_roles;
</synopsis>
   <xref linkend="app-psql"/>程序的<literal>\du</literal>元命令也可以用来列出现有角色。
  </para>
<!-- pgdoc-cn_end sig_en=2a68358a00929b496ec922bcd284798c -->

<!-- pgdoc-cn_start sig_en=19f1620dcbb607e84469b9837db9e8ca sig_cn_org=None source=14.1 
  <para>
   In order to bootstrap the database system, a freshly initialized
   system always contains one predefined role. This role is always
   a <quote>superuser</quote>, and by default (unless altered when running
   <command>initdb</command>) it will have the same name as the
   operating system user that initialized the database
   cluster. Customarily, this role will be named
   <literal>postgres</literal>. In order to create more roles you
   first have to connect as this initial role.
  </para>
________________________________________________________-->
  <para>
   为了引导数据库系统，一个刚刚被初始化好的系统总是包含一个预定义角色。这个角色总是一个<quote>superuser</quote>，并且默认情况下（除非在运行<command>initdb</command>时修改）它的名字和初始化数据库集簇的操作系统用户相同。习惯上，这个角色将被命名为<literal>postgres</literal>。为了创建更多角色，你首先必须以初始角色的身份连接。
  </para>
<!-- pgdoc-cn_end sig_en=19f1620dcbb607e84469b9837db9e8ca -->

<!-- pgdoc-cn_start sig_en=ebd5f2c200edb1b01dc453c9009ff076 sig_cn_org=None source=14.1 
  <para>
   Every connection to the database server is made using the name of some
   particular role, and this role determines the initial access privileges for
   commands issued in that connection.
   The role name to use for a particular database
   connection is indicated by the client that is initiating the
   connection request in an application-specific fashion. For example,
   the <command>psql</command> program uses the
   <option>-U</option> command line option to indicate the role to
   connect as.  Many applications assume the name of the current
   operating system user by default (including
   <command>createuser</command> and <command>psql</command>).  Therefore it
   is often convenient to maintain a naming correspondence between
   roles and operating system users.
  </para>
________________________________________________________-->
  <para>
   每一个到数据库服务器的连接都是使用某个特定角色名建立的，并且这个角色决定发起连接的命令的初始访问权限。要使用一个特定数据库连接的角色名由客户端指示，该客户端以一种应用相关的风格发起连接请求。例如，<command>psql</command>程序使用<option>-U</option>命令行选项来指定要以哪个角色连接。很多应用假定该名字默认是当前操作系统用户（包括<command>createuser</command>和<command>psql</command>）。因此在角色和操作系统用户之间维护一个名字对应关系通常是很方便的。
  </para>
<!-- pgdoc-cn_end sig_en=ebd5f2c200edb1b01dc453c9009ff076 -->

<!-- pgdoc-cn_start sig_en=6d4dc32caf9e52d06370b47a77f893fd sig_cn_org=None source=14.1 
  <para>
   The set of database roles a given client connection can connect as
   is determined by the client authentication setup, as explained in
   <xref linkend="client-authentication"/>. (Thus, a client is not
   limited to connect as the role matching
   its operating system user, just as a person's login name
   need not match his or her real name.)  Since the role
   identity determines the set of privileges available to a connected
   client, it is important to carefully configure privileges when setting up
   a multiuser environment.
  </para>
________________________________________________________-->
  <para>
   一个给定客户端连接能够用来连接的数据库角色的集合由该客户端的认证设置决定，这些在<xref linkend="client-authentication"/>中有解释（因此，一个客户端不止限于以匹配其操作系统用户的角色连接，就像一个人的登录名不需要匹配她的真实名字一样）。因为角色身份决定一个已连接客户端可用的权限集合，在设置一个多用户环境时要小心地配置权限。
  </para>
<!-- pgdoc-cn_end sig_en=6d4dc32caf9e52d06370b47a77f893fd -->
 </sect1>

 <sect1 id="role-attributes">
<!-- pgdoc-cn_start sig_en=dfe1822bdbcfa56bc60ef59bf5be3631 sig_cn_org=None source=14.1 
  <title>Role Attributes</title>
________________________________________________________-->
  <title>角色属性</title>
<!-- pgdoc-cn_end sig_en=dfe1822bdbcfa56bc60ef59bf5be3631 -->

<!-- pgdoc-cn_start sig_en=92bda52aec08dff41a2f301ffa887f11 sig_cn_org=b7b0b5c19d5335d0c7951ccc41b2ce07 source=15.7 
   <para>
    A database role can have a number of attributes that define its
    privileges and interact with the client authentication system.

    <variablelist>
     <varlistentry>
________________________________________________________-->
   <para>
    数据库角色可以具有多个属性，定义其特权并与客户端身份验证系统交互。

    <variablelist>
     <varlistentry>
<!-- pgdoc-cn_end sig_en=92bda52aec08dff41a2f301ffa887f11 -->
<!-- pgdoc-cn_start sig_en=5b67e3b992093f2bdb9aae7381510a98 sig_cn_org=9d9ac6ef9d6426bbdd89b0c7af9a193f source=15.7 
      <term>login privilege<indexterm><primary>login privilege</primary></indexterm></term>
________________________________________________________-->
      <term>登录权限<indexterm><primary>登录权限</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=5b67e3b992093f2bdb9aae7381510a98 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=ccaaa5624e81da2f30ff206bc51ae4a1 sig_cn_org=bd7803ea937fc22c67b3dfc5428f6c41 source=15.7 
       <para>
        Only roles that have the <literal>LOGIN</literal> attribute can be used
        as the initial role name for a database connection.  A role with
        the <literal>LOGIN</literal> attribute can be considered the same
        as a <quote>database user</quote>.  To create a role with login privilege,
        use either:
<programlisting>
CREATE ROLE <replaceable>name</replaceable> LOGIN;
CREATE USER <replaceable>name</replaceable>;
</programlisting>
        (<command>CREATE USER</command> is equivalent to <command>CREATE ROLE</command>
        except that <command>CREATE USER</command> includes <literal>LOGIN</literal> by
        default, while <command>CREATE ROLE</command> does not.)
       </para>
________________________________________________________-->
       <para>
        只有具有<literal>LOGIN</literal>属性的角色才能用作数据库连接的初始角色名称。
        具有<literal>LOGIN</literal>属性的角色可以被视为<quote>数据库用户</quote>的同义词。
        要创建具有登录权限的角色，请使用以下任一方法：
<programlisting>
CREATE ROLE <replaceable>name</replaceable> LOGIN;
CREATE USER <replaceable>name</replaceable>;
</programlisting>
        （<command>CREATE USER</command>等同于<command>CREATE ROLE</command>，
        但<command>CREATE USER</command>默认包含<literal>LOGIN</literal>，而<command>CREATE ROLE</command>不包含。）
       </para>
<!-- pgdoc-cn_end sig_en=ccaaa5624e81da2f30ff206bc51ae4a1 -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=96b3c0a35d061eb43020f7575b58963f sig_cn_org=387a91fd6622fc39ad722b2c18bdeba8 source=15.7 
      <term>superuser status<indexterm><primary>superuser</primary></indexterm></term>
________________________________________________________-->
      <term>超级用户状态<indexterm><primary>超级用户</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=96b3c0a35d061eb43020f7575b58963f -->
      <listitem>
<!-- pgdoc-cn_start sig_en=54cc44943f347334e821ac1a394beefd sig_cn_org=a6565a4954e97cde5855d76b953efb3d source=15.7 
       <para>
        A database superuser bypasses all permission checks, except the right
        to log in.  This is a dangerous privilege and should not be used
        carelessly; it is best to do most of your work as a role that is not a
        superuser.  To create a new database superuser, use <literal>CREATE
        ROLE <replaceable>name</replaceable> SUPERUSER</literal>.  You must do
        this as a role that is already a superuser.
       </para>
________________________________________________________-->
       <para>
        数据库超级用户绕过所有权限检查，除了登录权限。这是一个危险的特权，不应该随意使用；最好将大部分工作作为一个不是超级用户的角色来完成。
        要创建一个新的数据库超级用户，使用<literal>CREATE ROLE <replaceable>name</replaceable> SUPERUSER</literal>。您必须以已经是超级用户的角色来执行此操作。
       </para>
<!-- pgdoc-cn_end sig_en=54cc44943f347334e821ac1a394beefd -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=1fdf81b8e0e5f3e1fb5115d811964251 sig_cn_org=847f6bf810a986cac3838371bb6d6acf source=15.7 
      <term>database creation<indexterm><primary>database</primary><secondary>privilege to create</secondary></indexterm></term>
________________________________________________________-->
      <term>数据库创建<indexterm><primary>数据库</primary><secondary>创建权限</secondary></indexterm></term>
<!-- pgdoc-cn_end sig_en=1fdf81b8e0e5f3e1fb5115d811964251 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=b2a222c793a6660605537c26d50eb8d7 sig_cn_org=cda43c03067ca9ce102bae2027e8b059 source=15.7 
       <para>
        A role must be explicitly given permission to create databases
        (except for superusers, since those bypass all permission
        checks). To create such a role, use <literal>CREATE ROLE
        <replaceable>name</replaceable> CREATEDB</literal>.
       </para>
________________________________________________________-->
       <para>
        角色必须明确获得权限才能创建数据库（超级用户除外，因为他们可以绕过所有权限检查）。
        要创建这样的角色，请使用<literal>CREATE ROLE <replaceable>name</replaceable> CREATEDB</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=b2a222c793a6660605537c26d50eb8d7 -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=36f876760036bbb65da9c6018e223aea sig_cn_org=77d2d1affbaa8178f7313ff72b2e00eb source=15.7 
      <term id='role-creation'>role creation<indexterm><primary>role</primary><secondary>privilege to create</secondary></indexterm></term>
________________________________________________________-->
      <term id='role-creation'>角色创建<indexterm><primary>角色</primary><secondary>创建权限</secondary></indexterm></term>
<!-- pgdoc-cn_end sig_en=36f876760036bbb65da9c6018e223aea -->
      <listitem>
<!-- pgdoc-cn_start sig_en=96213dea50cfe7d0203de9b365972135 sig_cn_org=cbca4b06fb77015242bd6032e7f313f2 source=15.7 
       <para>
        A role must be explicitly given permission to create more roles
        (except for superusers, since those bypass all permission
        checks). To create such a role, use <literal>CREATE ROLE
        <replaceable>name</replaceable> CREATEROLE</literal>.
        A role with <literal>CREATEROLE</literal> privilege can alter and drop
        other roles, too, as well as grant or revoke membership in them.
        Altering a role includes most changes that can be made using
        <literal>ALTER ROLE</literal>, including, for example, changing
        passwords.  It also includes modifications to a role that can
        be made using the <literal>COMMENT</literal> and
        <literal>SECURITY LABEL</literal> commands.
       </para>
________________________________________________________-->
       <para>
        角色必须明确获得权限才能创建更多的角色（除了超级用户，因为他们可以绕过所有权限检查）。
        要创建这样的角色，请使用<literal>CREATE ROLE <replaceable>name</replaceable> CREATEROLE</literal>。
        拥有<literal>CREATEROLE</literal>特权的角色也可以修改和删除其他角色，以及授予或撤销其成员资格。
        修改角色包括大多数可以使用<literal>ALTER ROLE</literal>进行的更改，例如更改密码。
        还包括可以使用<literal>COMMENT</literal>和<literal>SECURITY LABEL</literal>命令进行的对角色的修改。
       </para>
<!-- pgdoc-cn_end sig_en=96213dea50cfe7d0203de9b365972135 -->
<!-- pgdoc-cn_start sig_en=2df1471fc35dda743bd714d2f24e0b01 sig_cn_org=975a9f35c52897146ad13d8f68e58631 source=15.7 
       <para>
        However, <literal>CREATEROLE</literal> does not convey the ability to
        create <literal>SUPERUSER</literal> roles, nor does it convey any
        power over <literal>SUPERUSER</literal> roles that already exist.
        Furthermore, <literal>CREATEROLE</literal> does not convey the power
        to create <literal>REPLICATION</literal> users, nor the ability to
        grant or revoke the <literal>REPLICATION</literal> privilege, nor the
        ability to modify the role properties of such users.  However, it does
        allow <literal>ALTER ROLE ... SET</literal> and
        <literal>ALTER ROLE ... RENAME</literal> to be used on
        <literal>REPLICATION</literal> roles, as well as the use of
        <literal>COMMENT ON ROLE</literal>,
        <literal>SECURITY LABEL ON ROLE</literal>,
        and <literal>DROP ROLE</literal>.
        Finally, <literal>CREATEROLE</literal> does not
        confer the ability to grant or revoke the <literal>BYPASSRLS</literal>
        privilege.
       </para>
________________________________________________________-->
       <para>
        然而，<literal>CREATEROLE</literal>并不包含创建<literal>SUPERUSER</literal>角色的能力，
		也不包含对已经存在的<literal>SUPERUSER</literal>角色的任何控制权。
        此外，<literal>CREATEROLE</literal>也不包含创建<literal>REPLICATION</literal>用户的权力，
		也不能授予或撤销<literal>REPLICATION</literal>特权，也不能修改这些用户的角色属性。
        然而，它允许在<literal>REPLICATION</literal>角色上使用<literal>ALTER ROLE ... SET</literal>和<literal>ALTER ROLE ... RENAME</literal>，以及使用<literal>COMMENT ON ROLE</literal>、<literal>SECURITY LABEL ON ROLE</literal>和<literal>DROP ROLE</literal>。
        最后，<literal>CREATEROLE</literal>也不授予授予或撤销<literal>BYPASSRLS</literal>特权的能力。
       </para>
<!-- pgdoc-cn_end sig_en=2df1471fc35dda743bd714d2f24e0b01 -->
<!-- pgdoc-cn_start sig_en=d7a7d6a7dbdfa39a94def3841c7e76e1 sig_cn_org=10ba1725a92779a40ed8866988777c34 source=15.7 
       <para>
        Because the <literal>CREATEROLE</literal> privilege allows a user
        to grant or revoke membership even in roles to which it does not (yet)
        have any access, a <literal>CREATEROLE</literal> user can obtain access
        to the capabilities of every predefined role in the system, including
        highly privileged roles such as
        <literal>pg_execute_server_program</literal> and
        <literal>pg_write_server_files</literal>.
       </para>
________________________________________________________-->
       <para>
        因为<literal>CREATEROLE</literal>权限允许用户授予或撤销即使在尚未具有任何访问权限的角色中的成员身份，一个<literal>CREATEROLE</literal>用户可以获得对系统中每个预定义角色的功能的访问权限，包括高度特权角色，如<literal>pg_execute_server_program</literal>和<literal>pg_write_server_files</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=d7a7d6a7dbdfa39a94def3841c7e76e1 -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=5946bab8b1aa3fc240464356d6536016 sig_cn_org=c36682a503907598ca61a9f3791467b2 source=15.7 
      <term>initiating replication<indexterm><primary>role</primary><secondary>privilege to initiate replication</secondary></indexterm></term>
________________________________________________________-->
      <term>启动复制<indexterm><primary>角色</primary><secondary>具有启动复制的特权</secondary></indexterm></term>
<!-- pgdoc-cn_end sig_en=5946bab8b1aa3fc240464356d6536016 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=5e3640342dc36e1fdfdb3b1c50c84971 sig_cn_org=55672e507826bc787d75b18b33d3c62c source=15.7 
       <para>
        A role must explicitly be given permission to initiate streaming
        replication (except for superusers, since those bypass all permission
        checks). A role used for streaming replication must
        have <literal>LOGIN</literal> permission as well. To create such a role, use
        <literal>CREATE ROLE <replaceable>name</replaceable> REPLICATION
        LOGIN</literal>.
       </para>
________________________________________________________-->
       <para>
        一个角色必须明确被授予权限来启动流复制（除了超级用户，因为他们可以绕过所有权限检查）。
        用于流复制的角色必须也具有<literal>LOGIN</literal>权限。要创建这样的角色，使用
        <literal>CREATE ROLE <replaceable>name</replaceable> REPLICATION
        LOGIN</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=5e3640342dc36e1fdfdb3b1c50c84971 -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=a0659b0d12c13af0aa86e74112e26c72 sig_cn_org=2c293c3ba5e4268201f37f2e3a6b363f source=15.7 
      <term>password<indexterm><primary>password</primary></indexterm></term>
________________________________________________________-->
      <term>密码<indexterm><primary>密码</primary></indexterm></term>
<!-- pgdoc-cn_end sig_en=a0659b0d12c13af0aa86e74112e26c72 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=69c91a8146a9e179c767bef5d13860a0 sig_cn_org=4e1ae4c0bf69de89685827675d354223 source=15.7 
       <para>
        A password is only significant if the client authentication
        method requires the user to supply a password when connecting
        to the database. The <option>password</option> and
        <option>md5</option> authentication methods
        make use of passwords. Database passwords are separate from
        operating system passwords. Specify a password upon role
        creation with <literal>CREATE ROLE
        <replaceable>name</replaceable> PASSWORD '<replaceable>string</replaceable>'</literal>.
       </para>
________________________________________________________-->
       <para>
        密码仅在客户端身份验证方法要求用户在连接到数据库时提供密码时才有意义。
        <option>password</option>和<option>md5</option>身份验证方法都使用密码。
        数据库密码与操作系统密码分开。在角色创建时指定密码为
        <literal>CREATE ROLE
        <replaceable>name</replaceable> PASSWORD '<replaceable>string</replaceable>'</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=69c91a8146a9e179c767bef5d13860a0 -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=92294cda4453c03387804e6c48d44c4d sig_cn_org=76051ffeec1f7d80911fd9200ceac687 source=15.7 
      <term>inheritance of privileges<indexterm><primary>role</primary><secondary>privilege to inherit</secondary></indexterm></term>
________________________________________________________-->
      <term>权限继承<indexterm><primary>角色</primary><secondary>继承权限</secondary></indexterm></term>
<!-- pgdoc-cn_end sig_en=92294cda4453c03387804e6c48d44c4d -->
      <listitem>
<!-- pgdoc-cn_start sig_en=8e818e6563c00fca3319c9e9ea06c80e sig_cn_org=6af5bb5f575dea7d81288e27f0ad8190 source=15.7 
       <para>
        A role is given permission to inherit the privileges of roles it is a
        member of, by default. However, to create a role without the permission,
        use <literal>CREATE ROLE <replaceable>name</replaceable> NOINHERIT</literal>.
       </para>
________________________________________________________-->
       <para>
        默认情况下，角色被授予继承其成员角色特权的权限。但是，要创建一个没有此权限的角色，
        使用<literal>CREATE ROLE <replaceable>name</replaceable> NOINHERIT</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=8e818e6563c00fca3319c9e9ea06c80e -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=76d705f6a0478311bafec1ccdb56bed8 sig_cn_org=c9a2248f9fb8e5e20419c54e4eeb36f1 source=15.7 
      <term>bypassing row-level security<indexterm><primary>role</primary><secondary>privilege to bypass</secondary></indexterm></term>
________________________________________________________-->
      <term>绕过行级安全性<indexterm><primary>角色</primary><secondary>绕过的特权</secondary></indexterm></term>
<!-- pgdoc-cn_end sig_en=76d705f6a0478311bafec1ccdb56bed8 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=99b9b3992ecc0c019f8a586019973cf1 sig_cn_org=e7c5ca7efed08c936b98809894cbd3ce source=15.7 
       <para>
        A role must be explicitly given permission to bypass every row-level security (RLS) policy
        (except for superusers, since those bypass all permission checks).
        To create such a role, use <literal>CREATE ROLE <replaceable>name</replaceable> BYPASSRLS</literal> as a superuser.
       </para>
________________________________________________________-->
       <para>
        一个角色必须明确获得权限来绕过每个行级安全（RLS）策略（除了超级用户，因为他们可以绕过所有权限检查）。
        要创建这样一个角色，请使用<literal>CREATE ROLE <replaceable>name</replaceable> BYPASSRLS</literal>作为超级用户。
        (意思是以超级用户执行这个命令)
       </para>
<!-- pgdoc-cn_end sig_en=99b9b3992ecc0c019f8a586019973cf1 -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=1fdea587353a09d133cd5fea9069a8f1 sig_cn_org=d14537673595c99cfbb34aadf2207746 source=15.7 
      <term>connection limit<indexterm><primary>role</primary><secondary>privilege to limit connection</secondary></indexterm></term>
________________________________________________________-->
      <term>连接限制<indexterm><primary>角色</primary><secondary>限制连接的特权</secondary></indexterm></term>
<!-- pgdoc-cn_end sig_en=1fdea587353a09d133cd5fea9069a8f1 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=74057944a136e0b0e30cfe2805bd5c84 sig_cn_org=a67f69dd5eef6cd836124f7a2941d386 source=15.7 
       <para>
        Connection limit can specify how many concurrent connections a role can make.
        -1 (the default) means no limit. Specify connection limit upon role creation with
        <literal>CREATE ROLE <replaceable>name</replaceable> CONNECTION LIMIT '<replaceable>integer</replaceable>'</literal>.
       </para>
________________________________________________________-->
       <para>
        连接限制可以指定一个角色可以建立多少并发连接。
        -1（默认值）表示没有限制。在创建角色时指定连接限制，使用
        <literal>CREATE ROLE <replaceable>name</replaceable> CONNECTION LIMIT '<replaceable>integer</replaceable>'</literal>。
</para>
<!-- pgdoc-cn_end sig_en=74057944a136e0b0e30cfe2805bd5c84 -->
<!-- pgdoc-cn_start sig_en=5b8c215c116ce51b7cfefdb618a0afe6 sig_cn_org=c95b28a051349b3bc2d311440a53bd62 source=15.7 
      </listitem>
     </varlistentry>
    </variablelist>

    A role's attributes can be modified after creation with
    <command>ALTER ROLE</command>.
________________________________________________________-->
          </listitem>
     </varlistentry>
    </variablelist>

    角色的属性可以在创建后使用<command>ALTER ROLE</command>进行修改。
<!-- pgdoc-cn_end sig_en=5b8c215c116ce51b7cfefdb618a0afe6 -->
<!-- pgdoc-cn_start sig_en=e8986347ef08262592f5b5288b077df1 sig_cn_org=c7dcf28e04ea261594065853be5363d9 source=15.7 
<indexterm><primary>ALTER ROLE</primary></indexterm>
________________________________________________________-->
<indexterm><primary>ALTER ROLE</primary></indexterm>
<!-- pgdoc-cn_end sig_en=e8986347ef08262592f5b5288b077df1 -->
<!-- pgdoc-cn_start sig_en=5a9eaa3221b74919781e310d3e076e9a sig_cn_org=1326fe22ea8f3dbb3ad29d10f43c5558 source=15.7 
    See the reference pages for the <xref linkend="sql-createrole"/>
    and <xref linkend="sql-alterrole"/> commands for details.
   </para>
________________________________________________________-->
查看有关<xref linkend="sql-createrole"/>和<xref linkend="sql-alterrole"/>命令的参考页面以获取详细信息。
   </para>
<!-- pgdoc-cn_end sig_en=5a9eaa3221b74919781e310d3e076e9a -->

<!-- pgdoc-cn_start sig_en=2f6b5b72bb9c1061557aba1643cdcf0b sig_cn_org=None source=14.1 
  <para>
   A role can also have role-specific defaults for many of the run-time
   configuration settings described in <xref
   linkend="runtime-config"/>.  For example, if for some reason you
   want to disable index scans (hint: not a good idea) anytime you
   connect, you can use:
<programlisting>
ALTER ROLE myname SET enable_indexscan TO off;
</programlisting>
   This will save the setting (but not set it immediately).  In
   subsequent connections by this role it will appear as though
   <literal>SET enable_indexscan TO off</literal> had been executed
   just before the session started.
   You can still alter this setting during the session; it will only
   be the default. To remove a role-specific default setting, use
   <literal>ALTER ROLE <replaceable>rolename</replaceable> RESET <replaceable>varname</replaceable></literal>.
   Note that role-specific defaults attached to roles without
   <literal>LOGIN</literal> privilege are fairly useless, since they will never
   be invoked.
  </para>
________________________________________________________-->
  <para>
   对于<xref linkend="runtime-config"/>中描述的运行时配置设置，一个角色也可以有角色相关的默认值。例如，如果出于某些原因你希望在每次连接时禁用索引扫描（提示：不是好主意），你可以使用：
<programlisting>
ALTER ROLE myname SET enable_indexscan TO off;
</programlisting>
   这将保存设置（但是不会立刻设置它）。在这个角色的后续连接中，它就表现得像在会话开始之前执行过<literal>SET enable_indexscan TO off</literal>。你也可以在会话期间改变该设置，它将只是作为默认值。要移除一个角色相关的默认设置，使用<literal>ALTER ROLE <replaceable>rolename</replaceable> RESET <replaceable>varname</replaceable></literal>。注意附加到没有<literal>LOGIN</literal>权限的角色的角色相关默认值相当无用，因为它们从不会被调用。
  </para>
<!-- pgdoc-cn_end sig_en=2f6b5b72bb9c1061557aba1643cdcf0b -->
 </sect1>

 <sect1 id="role-membership">
<!-- pgdoc-cn_start sig_en=28f183d6f3255b488a0a725dfc3c70a9 sig_cn_org=None source=14.1 
  <title>Role Membership</title>
________________________________________________________-->
  <title>角色成员关系</title>
<!-- pgdoc-cn_end sig_en=28f183d6f3255b488a0a725dfc3c70a9 -->

<!-- pgdoc-cn_start sig_en=180da3272eeafb546d2c75ab17143632 sig_cn_org=None source=14.1 
  <indexterm zone="role-membership">
   <primary>role</primary><secondary>membership in</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="role-membership">
   <primary>role</primary><secondary>membership in</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=180da3272eeafb546d2c75ab17143632 -->

<!-- pgdoc-cn_start sig_en=ae6e2bbc7698794fa7b21d0b1c394594 sig_cn_org=None source=14.1 
  <para>
   It is frequently convenient to group users together to ease
   management of privileges: that way, privileges can be granted to, or
   revoked from, a group as a whole.  In <productname>PostgreSQL</productname>
   this is done by creating a role that represents the group, and then
   granting <firstterm>membership</firstterm> in the group role to individual user
   roles.
  </para>
________________________________________________________-->
  <para>
   把用户分组在一起来便于管理权限常常很方便：那样，权限可以被授予一整个组或从一整个组回收。在<productname>PostgreSQL</productname>中通过创建一个表示组的角色来实现，并且然后将在该组角色中的<firstterm>成员关系</firstterm>授予给单独的用户角色。
  </para>
<!-- pgdoc-cn_end sig_en=ae6e2bbc7698794fa7b21d0b1c394594 -->

<!-- pgdoc-cn_start sig_en=c6a5a33a3e121b433fc4e957919a185f sig_cn_org=None source=14.1 
  <para>
   To set up a group role, first create the role:
<synopsis>
CREATE ROLE <replaceable>name</replaceable>;
</synopsis>
   Typically a role being used as a group would not have the <literal>LOGIN</literal>
   attribute, though you can set it if you wish.
  </para>
________________________________________________________-->
  <para>
   要建立一个组角色，首先创建该角色：
<synopsis>
CREATE ROLE <replaceable>name</replaceable>;
</synopsis>
   通常被用作一个组的角色不需要有<literal>LOGIN</literal>属性，不过如果你希望你也可以设置它。
  </para>
<!-- pgdoc-cn_end sig_en=c6a5a33a3e121b433fc4e957919a185f -->

<!-- pgdoc-cn_start sig_en=29e5ccff32bd008e00bf29ed902c5eb3 sig_cn_org=None source=14.1 
  <para>
   Once the group role exists, you can add and remove members using the
   <link linkend="sql-grant"><command>GRANT</command></link> and
   <link linkend="sql-revoke"><command>REVOKE</command></link> commands:
<synopsis>
GRANT <replaceable>group_role</replaceable> TO <replaceable>role1</replaceable>, ... ;
REVOKE <replaceable>group_role</replaceable> FROM <replaceable>role1</replaceable>, ... ;
</synopsis>
   You can grant membership to other group roles, too (since there isn't
   really any distinction between group roles and non-group roles).  The
   database will not let you set up circular membership loops.  Also,
   it is not permitted to grant membership in a role to
   <literal>PUBLIC</literal>.
  </para>
________________________________________________________-->
  <para>
   一旦组角色存在，你可以使用<link linkend="sql-grant"><command>GRANT</command></link> 和 <link linkend="sql-revoke"><command>REVOKE</command></link> commands:命令增加和移除成员：
<synopsis>
GRANT <replaceable>group_role</replaceable> TO <replaceable>role1</replaceable>, ... ;
REVOKE <replaceable>group_role</replaceable> FROM <replaceable>role1</replaceable>, ... ;
</synopsis>
   你也可以为其他组角色授予成员关系（因为组角色和非组角色之间其实没有任何区别）。数据库将不会让你设置环状的成员关系。另外，不允许把一个角色中的成员关系授予给<literal>PUBLIC</literal>。
  </para>
<!-- pgdoc-cn_end sig_en=29e5ccff32bd008e00bf29ed902c5eb3 -->

<!-- pgdoc-cn_start sig_en=11c2468796685fb94361ff3fa013921d sig_cn_org=None source=14.1 
  <para>
   The members of a group role can use the privileges of the role in two
   ways.  First, every member of a group can explicitly do
   <link linkend="sql-set-role"><command>SET ROLE</command></link> to
   temporarily <quote>become</quote> the group role.  In this state, the
   database session has access to the privileges of the group role rather
   than the original login role, and any database objects created are
   considered owned by the group role not the login role.  Second, member
   roles that have the <literal>INHERIT</literal> attribute automatically have use
   of the privileges of roles of which they are members, including any
   privileges inherited by those roles.
   As an example, suppose we have done:
<programlisting>
CREATE ROLE joe LOGIN INHERIT;
CREATE ROLE admin NOINHERIT;
CREATE ROLE wheel NOINHERIT;
GRANT admin TO joe;
GRANT wheel TO admin;
</programlisting>
   Immediately after connecting as role <literal>joe</literal>, a database
   session will have use of privileges granted directly to <literal>joe</literal>
   plus any privileges granted to <literal>admin</literal>, because <literal>joe</literal>
   <quote>inherits</quote> <literal>admin</literal>'s privileges.  However, privileges
   granted to <literal>wheel</literal> are not available, because even though
   <literal>joe</literal> is indirectly a member of <literal>wheel</literal>, the
   membership is via <literal>admin</literal> which has the <literal>NOINHERIT</literal>
   attribute.  After:
<programlisting>
SET ROLE admin;
</programlisting>
   the session would have use of only those privileges granted to
   <literal>admin</literal>, and not those granted to <literal>joe</literal>.  After:
<programlisting>
SET ROLE wheel;
</programlisting>
   the session would have use of only those privileges granted to
   <literal>wheel</literal>, and not those granted to either <literal>joe</literal>
   or <literal>admin</literal>.  The original privilege state can be restored
   with any of:
<programlisting>
SET ROLE joe;
SET ROLE NONE;
RESET ROLE;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   组角色的成员可以以两种方式使用角色的权限。
   第一，一个组的每一个成员可以显式地做<link linkend="sql-set-role"><command>SET ROLE</command></link>来临时<quote>成为</quote>组角色。
   在这种状态中，数据库会话可以访问组角色而不是原始登录角色的权限，并且任何被创建的数据库对象被认为属于组角色而不是登录角色。
   第二，有<literal>INHERIT</literal>属性的成员角色自动地具有它们所属角色的权限，包括任何组角色继承得到的权限。
   作为一个例子，假设我们已经有：
<programlisting>
CREATE ROLE joe LOGIN INHERIT;
CREATE ROLE admin NOINHERIT;
CREATE ROLE wheel NOINHERIT;
GRANT admin TO joe;
GRANT wheel TO admin;
</programlisting>
   在作为角色<literal>joe</literal>连接后，一个数据库会话将立即拥有直接授予给<literal>joe</literal>的权限，外加任何授予给<literal>admin</literal>的权限，因为<literal>joe</literal><quote>继承了</quote> <literal>admin</literal>的权限。然而，授予给<literal>wheel</literal>的权限不可用，因为即使<literal>joe</literal>是<literal>wheel</literal>的一个间接成员，但是该成员关系是通过带<literal>NOINHERIT</literal>属性的<literal>admin</literal>得到的。在：
<programlisting>
SET ROLE admin;
</programlisting>
   之后，该会话将只拥有授予给<literal>admin</literal>的权限，但是没有授予给<literal>joe</literal>的权限。在执行：
<programlisting>
SET ROLE wheel;
</programlisting>
   之后，该会话将只拥有授予给<literal>wheel</literal>的权限，但是没有授予给<literal>joe</literal>或<literal>admin</literal>的权限。初始的权限状态可以使用下面命令之一恢复：
<programlisting>
SET ROLE joe;
SET ROLE NONE;
RESET ROLE;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=11c2468796685fb94361ff3fa013921d -->

  <note>
<!-- pgdoc-cn_start sig_en=41b4c6facb5eff56e44ed6ceab85fe8d sig_cn_org=None source=14.1 
   <para>
    The <command>SET ROLE</command> command always allows selecting any role
    that the original login role is directly or indirectly a member of.
    Thus, in the above example, it is not necessary to become
    <literal>admin</literal> before becoming <literal>wheel</literal>.
   </para>
________________________________________________________-->
   <para>
    <command>SET ROLE</command>命令总是允许选择原始登录角色的直接或间接组角色。因此，在上面的例子中，在成为<literal>wheel</literal>之前不必先成为<literal>admin</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=41b4c6facb5eff56e44ed6ceab85fe8d -->
  </note>

  <note>
<!-- pgdoc-cn_start sig_en=f8d542061e10bb7a444ed9c8b46fc22a sig_cn_org=None source=14.1 
   <para>
    In the SQL standard, there is a clear distinction between users and roles,
    and users do not automatically inherit privileges while roles do.  This
    behavior can be obtained in <productname>PostgreSQL</productname> by giving
    roles being used as SQL roles the <literal>INHERIT</literal> attribute, while
    giving roles being used as SQL users the <literal>NOINHERIT</literal> attribute.
    However, <productname>PostgreSQL</productname> defaults to giving all roles
    the <literal>INHERIT</literal> attribute, for backward compatibility with pre-8.1
    releases in which users always had use of permissions granted to groups
    they were members of.
   </para>
________________________________________________________-->
   <para>
    在 SQL 标准中，用户和角色之间的区别很清楚，并且用户不会自动继承权限而角色会继承。这种行为在<productname>PostgreSQL</productname>中也可以实现：为要用作 SQL 角色的角色给予<literal>INHERIT</literal>属性，而为要用作 SQL 用户的角色给予<literal>NOINHERIT</literal>属性。不过，为了向后兼容 8.1 以前的发布（在其中用户总是拥有它们所在组的权限），<productname>PostgreSQL</productname>默认给所有的角色<literal>INHERIT</literal>属性。
   </para>
<!-- pgdoc-cn_end sig_en=f8d542061e10bb7a444ed9c8b46fc22a -->
  </note>

<!-- pgdoc-cn_start sig_en=3156e670883763c6d4071a2c4a84aaca sig_cn_org=None source=14.1 
  <para>
   The role attributes <literal>LOGIN</literal>, <literal>SUPERUSER</literal>,
   <literal>CREATEDB</literal>, and <literal>CREATEROLE</literal> can be thought of as
   special privileges, but they are never inherited as ordinary privileges
   on database objects are.  You must actually <command>SET ROLE</command> to a
   specific role having one of these attributes in order to make use of
   the attribute.  Continuing the above example, we might choose to
   grant <literal>CREATEDB</literal> and <literal>CREATEROLE</literal> to the
   <literal>admin</literal> role.  Then a session connecting as role <literal>joe</literal>
   would not have these privileges immediately, only after doing
   <command>SET ROLE admin</command>.
  </para>
________________________________________________________-->
  <para>
   角色属性<literal>LOGIN</literal>、<literal>SUPERUSER</literal>、<literal>CREATEDB</literal>和<literal>CREATEROLE</literal>可以被认为是一种特殊权限，但是它们从来不会像数据库对象上的普通权限那样被继承。要使用这些属性，你必须实际<command>SET ROLE</command>到一个有这些属性之一的特定角色。继续上述例子，我们可以选择授予<literal>CREATEDB</literal>和<literal>CREATEROLE</literal>给<literal>admin</literal>角色。然后一个以<literal>joe</literal>角色连接的会话将不会立即有这些权限，只有在执行了<command>SET ROLE admin</command>之后才会拥有。
  </para>
<!-- pgdoc-cn_end sig_en=3156e670883763c6d4071a2c4a84aaca -->

  <para>
  </para>

<!-- pgdoc-cn_start sig_en=80fa6cd42b46f9c9baf5f2be137a8e6a sig_cn_org=None source=14.1 
  <para>
   To destroy a group role, use <link
   linkend="sql-droprole"><command>DROP ROLE</command></link>:
<synopsis>
DROP ROLE <replaceable>name</replaceable>;
</synopsis>
   Any memberships in the group role are automatically revoked (but the
   member roles are not otherwise affected).
  </para>
________________________________________________________-->
  <para>
   要销毁一个组角色，使用<link linkend="sql-droprole"><command>DROP ROLE</command></link>：
<synopsis>
DROP ROLE <replaceable>name</replaceable>;
</synopsis>
   任何在该组角色中的成员关系会被自动撤销（但是成员角色不会受到影响）。
  </para>
<!-- pgdoc-cn_end sig_en=80fa6cd42b46f9c9baf5f2be137a8e6a -->
 </sect1>

 <sect1 id="role-removal">
<!-- pgdoc-cn_start sig_en=4898a57f3f051818c42e899e341f8857 sig_cn_org=None source=14.1 
  <title>Dropping Roles</title>
________________________________________________________-->
  <title>删除角色</title>
<!-- pgdoc-cn_end sig_en=4898a57f3f051818c42e899e341f8857 -->

<!-- pgdoc-cn_start sig_en=d4ab5275226ea432d4fd920f7d00985b sig_cn_org=None source=14.1 
  <para>
   Because roles can own database objects and can hold privileges
   to access other objects, dropping a role is often not just a matter of a
   quick <link linkend="sql-droprole"><command>DROP ROLE</command></link>.  Any objects owned by the role must
   first be dropped or reassigned to other owners; and any permissions
   granted to the role must be revoked.
  </para>
________________________________________________________-->
  <para>
   由于角色可以拥有数据库对象并且能持有访问其他对象的特权，删除一个角色常常并非一次<link linkend="sql-droprole"><command>DROP ROLE</command></link>就能解决。
   任何被该用户所拥有的对象必须首先被删除或者转移给其他拥有者，并且任何已被授予给该角色的权限必须被收回。
  </para>
<!-- pgdoc-cn_end sig_en=d4ab5275226ea432d4fd920f7d00985b -->

<!-- pgdoc-cn_start sig_en=7956a0aa3c94a1bac20f83213d1e27c5 sig_cn_org=None source=14.1 
  <para>
   Ownership of objects can be transferred one at a time
   using <command>ALTER</command> commands, for example:
<programlisting>
ALTER TABLE bobs_table OWNER TO alice;
</programlisting>
   Alternatively, the <link linkend="sql-reassign-owned"><command>REASSIGN OWNED</command></link> command can be
   used to reassign ownership of all objects owned by the role-to-be-dropped
   to a single other role.  Because <command>REASSIGN OWNED</command> cannot access
   objects in other databases, it is necessary to run it in each database
   that contains objects owned by the role.  (Note that the first
   such <command>REASSIGN OWNED</command> will change the ownership of any
   shared-across-databases objects, that is databases or tablespaces, that
   are owned by the role-to-be-dropped.)
  </para>
________________________________________________________-->
  <para>
   对象的拥有关系可以使用<link linkend="sql-reassign-owned"><command>REASSIGN OWNED</command></link>命令一次转移出去，例如：
<programlisting>
ALTER TABLE bobs_table OWNER TO alice;
</programlisting>
   此外，<xref linkend="sql-reassign-owned"/>命令可以被用来把要被删除的
   角色所拥有的所有对象的拥有关系转移给另一个角色。由于
   <command>REASSIGN OWNED</command>不能访问其他数据库中的对象，有必要
   在每一个包含该角色所拥有对象的数据库中运行该命令（注意第一个这样的
   <command>REASSIGN OWNED</command>将更改任何在数据库间共享的该角色拥
   有的对象的拥有关系，即数据库或者表空间）。
  </para>
<!-- pgdoc-cn_end sig_en=7956a0aa3c94a1bac20f83213d1e27c5 -->

<!-- pgdoc-cn_start sig_en=5cfa686faa5efb3e70dab1a6086fa009 sig_cn_org=None source=14.1 
  <para>
   Once any valuable objects have been transferred to new owners, any
   remaining objects owned by the role-to-be-dropped can be dropped with
   the <link linkend="sql-drop-owned"><command>DROP OWNED</command></link> command.  Again, this command cannot
   access objects in other databases, so it is necessary to run it in each
   database that contains objects owned by the role.  Also, <command>DROP
   OWNED</command> will not drop entire databases or tablespaces, so it is
   necessary to do that manually if the role owns any databases or
   tablespaces that have not been transferred to new owners.
  </para>
________________________________________________________-->
  <para>
   一旦任何有价值的对象已经被转移给新的拥有者，任何由被删除角色拥有的剩余对象就可以用<link linkend="sql-drop-owned"><command>DROP OWNED</command></link>命令删除。
   再次，由于这个命令不能访问其他数据库中的对象， 有必要在每一个包含该角色所拥有对象的数据库中运行该命令。
   还有，<command>DROP OWNED</command>将不会删除整个数据库或者表空间，因此如果该角色拥有任何还没有被转移给新拥有者的数据库或者表空间，有必要手工删除它们。
  </para>
<!-- pgdoc-cn_end sig_en=5cfa686faa5efb3e70dab1a6086fa009 -->

<!-- pgdoc-cn_start sig_en=bc7eb96066ae473ffcaa2e393ee8b952 sig_cn_org=None source=14.1 
  <para>
   <command>DROP OWNED</command> also takes care of removing any privileges granted
   to the target role for objects that do not belong to it.
   Because <command>REASSIGN OWNED</command> does not touch such objects, it's
   typically necessary to run both <command>REASSIGN OWNED</command>
   and <command>DROP OWNED</command> (in that order!) to fully remove the
   dependencies of a role to be dropped.
  </para>
________________________________________________________-->
  <para>
   <command>DROP OWNED</command>也会注意移除为不属于目标角色的对象授予给目标
   角色的任何特权。因为<command>REASSIGN OWNED</command>不会触碰这类对象，通
   常有必要运行<command>REASSIGN OWNED</command>和
   <command>DROP OWNED</command>（按照这个顺序！）以完全地移除要被删除对象的
   从属物。
  </para>
<!-- pgdoc-cn_end sig_en=bc7eb96066ae473ffcaa2e393ee8b952 -->

<!-- pgdoc-cn_start sig_en=890ac66aa0054d0c07b24e27721dfab2 sig_cn_org=None source=14.1 
  <para>
   In short then, the most general recipe for removing a role that has been
   used to own objects is:
  </para>
________________________________________________________-->
  <para>
   总之，移除曾经拥有过对象的角色的方法是：
  </para>
<!-- pgdoc-cn_end sig_en=890ac66aa0054d0c07b24e27721dfab2 -->
<!-- pgdoc-cn_start sig_en=dd1628e4f1670b18eff90c2a060f4b7e sig_cn_org=None source=14.1 
<programlisting>
REASSIGN OWNED BY doomed_role TO successor_role;
DROP OWNED BY doomed_role;
-&minus; repeat the above commands in each database of the cluster
DROP ROLE doomed_role;
</programlisting>
________________________________________________________-->
<programlisting>
REASSIGN OWNED BY doomed_role TO successor_role;
DROP OWNED BY doomed_role;
-- 在集簇中的每一个数据库中重复上述命令
DROP ROLE doomed_role;
</programlisting>
<!-- pgdoc-cn_end sig_en=dd1628e4f1670b18eff90c2a060f4b7e -->

<!-- pgdoc-cn_start sig_en=9ce59fe62f2c9eeb8f7a9036c6be5641 sig_cn_org=None source=14.1 
  <para>
   When not all owned objects are to be transferred to the same successor
   owner, it's best to handle the exceptions manually and then perform
   the above steps to mop up.
  </para>
________________________________________________________-->
  <para>
   如果不是所有的拥有对象都被转移给了同一个后继拥有者，最好手工处理异常
   然后执行上述步骤直到结束。
  </para>
<!-- pgdoc-cn_end sig_en=9ce59fe62f2c9eeb8f7a9036c6be5641 -->

<!-- pgdoc-cn_start sig_en=ad683cf5b5a77fe90d38d708644c012f sig_cn_org=None source=14.1 
  <para>
   If <command>DROP ROLE</command> is attempted while dependent objects still
   remain, it will issue messages identifying which objects need to be
   reassigned or dropped.
  </para>
________________________________________________________-->
  <para>
   如果在依赖对象还存在时尝试了<command>DROP ROLE</command>，它将发出
   消息标识哪些对象需要被重新授予或者删除。
  </para>
<!-- pgdoc-cn_end sig_en=ad683cf5b5a77fe90d38d708644c012f -->
 </sect1>

 <sect1 id="predefined-roles">
<!-- pgdoc-cn_start sig_en=064859285c4ad0052d5713a97e1faf80 sig_cn_org=None source=14.1 
  <title>Predefined Roles</title>
________________________________________________________-->
  <title>预定义角色</title>
<!-- pgdoc-cn_end sig_en=064859285c4ad0052d5713a97e1faf80 -->

<!-- pgdoc-cn_start sig_en=0d41207bad0845b9ec7125cc2dfd7235 sig_cn_org=None source=14.1 
  <indexterm zone="predefined-roles">
   <primary>role</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="predefined-roles">
   <primary>角色</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=0d41207bad0845b9ec7125cc2dfd7235 -->

<!-- pgdoc-cn_start sig_en=b81415af88886a2858d2381f9663bd11 sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> provides a set of predefined roles
   that provide access to certain, commonly needed, privileged capabilities
   and information.  Administrators (including roles that have the
   <literal>CREATEROLE</literal> privilege) can <command>GRANT</command> these
   roles to users and/or other roles in their environment, providing those
   users with access to the specified capabilities and information.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>提供了一组预定义角色，它们提供对特定的、通常需要的、需要特权的功能和信息的访问。
   管理员(包括具有<literal>CREATEROLE</literal> 权限的角色)可以把这些角色<command>GRANT</command>给其环境中的用户或者其他角色，让这些用户能够访问指定的功能和信息。
  </para>
<!-- pgdoc-cn_end sig_en=b81415af88886a2858d2381f9663bd11 -->

<!-- pgdoc-cn_start sig_en=152dbe9055c3df191a7e74ff998f900b sig_cn_org=None source=14.1 
  <para>
   The predefined roles are described in <xref linkend="predefined-roles-table"/>.
   Note that the specific permissions for each of the roles may change in
   the future as additional capabilities are added.  Administrators
   should monitor the release notes for changes.
  </para>
________________________________________________________-->
  <para>
   <xref linkend="predefined-roles-table"/>中描述了预定义的角色。
   注意由于额外功能的增加，每一种角色相关的权限可能会在未来被改变。
   管理员应该关注发行注记中提到的这方面的变化。
  </para>
<!-- pgdoc-cn_end sig_en=152dbe9055c3df191a7e74ff998f900b -->

   <table tocentry="1" id="predefined-roles-table">
<!-- pgdoc-cn_start sig_en=064859285c4ad0052d5713a97e1faf80 sig_cn_org=None source=14.1 
    <title>Predefined Roles</title>
________________________________________________________-->
    <title>预定义角色</title>
<!-- pgdoc-cn_end sig_en=064859285c4ad0052d5713a97e1faf80 -->
    <tgroup cols="2">
     <colspec colname="col1" colwidth="1*"/>
     <colspec colname="col2" colwidth="2*"/>
     <thead>
<!-- pgdoc-cn_start sig_en=9e23ad49c3c2dca8d257dd7048f96a8c sig_cn_org=None source=14.1 
      <row>
       <entry>Role</entry>
       <entry>Allowed Access</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>角色</entry>
       <entry>允许的访问</entry>
      </row>
<!-- pgdoc-cn_end sig_en=9e23ad49c3c2dca8d257dd7048f96a8c -->
     </thead>
     <tbody>
<!-- pgdoc-cn_start sig_en=608e303e15171d57c53d859719ee6e93 sig_cn_org=None source=14.1 
      <row>
       <entry>pg_read_all_data</entry>
       <entry>Read all data (tables, views, sequences), as if having
       <command>SELECT</command> rights on those objects, and USAGE rights on
       all schemas, even without having it explicitly.  This role does not have
       the role attribute <literal>BYPASSRLS</literal> set.  If RLS is being
       used, an administrator may wish to set <literal>BYPASSRLS</literal> on
       roles which this role is GRANTed to.</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>pg_read_all_data</entry>
       <entry>读所有数据(表，视图，序列), 如同在那些对象上有 <command>SELECT</command> 权限，在所有模式上有USAGE权限，即使没有显式拥有它。
       这个角色没有角色属性<literal>BYPASSRLS</literal>集。
       如果使用了RLS，管理员可能希望设置角色上的被GRANTed给该角色的<literal>BYPASSRLS</literal>。</entry>
      </row>
<!-- pgdoc-cn_end sig_en=608e303e15171d57c53d859719ee6e93 -->
<!-- pgdoc-cn_start sig_en=cfbd93110d31df7f37d791a7e65bf175 sig_cn_org=None source=14.1 
      <row>
       <entry>pg_write_all_data</entry>
       <entry>Write all data (tables, views, sequences), as if having
       <command>INSERT</command>, <command>UPDATE</command>, and
       <command>DELETE</command> rights on those objects, and USAGE rights on
       all schemas, even without having it explicitly.  This role does not have
       the role attribute <literal>BYPASSRLS</literal> set.  If RLS is being
       used, an administrator may wish to set <literal>BYPASSRLS</literal> on
       roles which this role is GRANTed to.</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>pg_write_all_data</entry>
       <entry>写全部数据(表，视图，序列)， 如果在那些对象上有<command>INSERT</command>、<command>UPDATE</command>和<command>DELETE</command>权限，以及在全部模式上有USAGE权限，即使没有显式拥有它。
       这个角色没有角色属性<literal>BYPASSRLS</literal> 集。
       如果使用了RLS，管理员可能希望设置角色上的被GRANTed给该角色的<literal>BYPASSRLS</literal>。</entry>
      </row>
<!-- pgdoc-cn_end sig_en=cfbd93110d31df7f37d791a7e65bf175 -->
<!-- pgdoc-cn_start sig_en=9c93bca376ac49f5191cdaca310cae5e sig_cn_org=None source=14.1 
      <row>
       <entry>pg_read_all_settings</entry>
       <entry>Read all configuration variables, even those normally visible only to
       superusers.</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>pg_read_all_settings</entry>
       <entry>读取所有配置变量，甚至是那些通常只对超级用户可见的变量。</entry>
      </row>
<!-- pgdoc-cn_end sig_en=9c93bca376ac49f5191cdaca310cae5e -->
<!-- pgdoc-cn_start sig_en=c183da705e86ffafb7e3014b1fd18f39 sig_cn_org=None source=14.1 
      <row>
       <entry>pg_read_all_stats</entry>
       <entry>Read all pg_stat_* views and use various statistics related extensions,
       even those normally visible only to superusers.</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>pg_read_all_stats</entry>
       <entry>读取所有的pg_stat_*视图并且使用与扩展相关的各种统计信息，甚至是那些通常只对超级用户可见的信息。</entry>
      </row>
<!-- pgdoc-cn_end sig_en=c183da705e86ffafb7e3014b1fd18f39 -->
<!-- pgdoc-cn_start sig_en=b2d0d2b6a24d5a87f0ef99a50af064e9 sig_cn_org=None source=14.1 
      <row>
       <entry>pg_stat_scan_tables</entry>
       <entry>Execute monitoring functions that may take <literal>ACCESS SHARE</literal> locks on tables,
       potentially for a long time.</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>pg_stat_scan_tables</entry>
       <entry>执行可能会在表上取得<literal>ACCESS SHARE</literal>锁的监控函数（可能会持锁很长时间）。</entry>
      </row>
<!-- pgdoc-cn_end sig_en=b2d0d2b6a24d5a87f0ef99a50af064e9 -->
<!-- pgdoc-cn_start sig_en=891d0331d5092b38be816ac200d664dc sig_cn_org=None source=14.1 
      <row>
       <entry>pg_monitor</entry>
       <entry>Read/execute various monitoring views and functions.
       This role is a member of <literal>pg_read_all_settings</literal>,
       <literal>pg_read_all_stats</literal> and
       <literal>pg_stat_scan_tables</literal>.</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>pg_monitor</entry>
       <entry>读取/执行各种不同的监控视图和函数。
       这角色是<literal>pg_read_all_settings</literal>，<literal>pg_read_all_stats</literal>和<literal>pg_stat_scan_tables</literal>的成员。</entry>
      </row>
<!-- pgdoc-cn_end sig_en=891d0331d5092b38be816ac200d664dc -->
<!-- pgdoc-cn_start sig_en=a750830d3fe214bbd24d09e2df455b48 sig_cn_org=None source=14.1 
      <row>
       <entry>pg_database_owner</entry>
       <entry>None.  Membership consists, implicitly, of the current database owner.</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>pg_database_owner</entry>
       <entry>无.  成员构成，隐式的，当前数据库的所有者。</entry>
      </row>
<!-- pgdoc-cn_end sig_en=a750830d3fe214bbd24d09e2df455b48 -->
<!-- pgdoc-cn_start sig_en=8e3a18743ce26d4c0c8ef0e472b32664 sig_cn_org=None source=14.1 
      <row>
       <entry>pg_signal_backend</entry>
       <entry>Signal another backend to cancel a query or terminate its session.</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>pg_signal_backend</entry>
       <entry>发信号到其他后端以取消查询或中止它的会话。</entry>
      </row>
<!-- pgdoc-cn_end sig_en=8e3a18743ce26d4c0c8ef0e472b32664 -->
<!-- pgdoc-cn_start sig_en=dbad323e761ad94ecdafeee4e54d1336 sig_cn_org=None source=14.1 
      <row>
       <entry>pg_read_server_files</entry>
       <entry>Allow reading files from any location the database can access on the server with COPY and
       other file-access functions.</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>pg_read_server_files</entry>
       <entry>允许使用COPY以及其他文件访问函数从服务器上该数据库可访问的任意位置读取文件。</entry>
      </row>
<!-- pgdoc-cn_end sig_en=dbad323e761ad94ecdafeee4e54d1336 -->
<!-- pgdoc-cn_start sig_en=71a25b32c38268b2eb8509c3f579454f sig_cn_org=None source=14.1 
      <row>
       <entry>pg_write_server_files</entry>
       <entry>Allow writing to files in any location the database can access on the server with COPY and
       other file-access functions.</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>pg_write_server_files</entry>
       <entry>允许使用COPY以及其他文件访问函数在服务器上该数据库可访问的任意位置中写入文件。</entry>
      </row>
<!-- pgdoc-cn_end sig_en=71a25b32c38268b2eb8509c3f579454f -->
<!-- pgdoc-cn_start sig_en=a2c0be59e4b21f9401b9598ecd17000e sig_cn_org=None source=14.1 
      <row>
       <entry>pg_execute_server_program</entry>
       <entry>Allow executing programs on the database server as the user the database runs as with
       COPY and other functions which allow executing a server-side program.</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>pg_execute_server_program</entry>
       <entry>允许用运行该数据库的用户执行数据库服务器上的程序来配合COPY和其他允许执行服务器端程序的函数。</entry>
      </row>
<!-- pgdoc-cn_end sig_en=a2c0be59e4b21f9401b9598ecd17000e -->
<!-- pgdoc-cn_start sig_en=6bf805a36c987a1c95e4fd8863249fdb sig_cn_org=aafc95d4f8a85c4fdf106a5ff7e505d1 source=15.7 
      <row>
       <entry>pg_checkpoint</entry>
       <entry>Allow executing
       the <link linkend="sql-checkpoint"><command>CHECKPOINT</command></link>
       command.</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>pg_checkpoint</entry>
       <entry>允许执行<link linkend="sql-checkpoint"><command>CHECKPOINT</command></link>命令。</entry>
      </row>
<!-- pgdoc-cn_end sig_en=6bf805a36c987a1c95e4fd8863249fdb -->
     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=9913dc9e4b00225bdc5d5a7827f63b56 sig_cn_org=None source=14.1 
  <para>
  The <literal>pg_monitor</literal>, <literal>pg_read_all_settings</literal>,
  <literal>pg_read_all_stats</literal> and <literal>pg_stat_scan_tables</literal>
  roles are intended to allow administrators to easily configure a role for the
  purpose of monitoring the database server. They grant a set of common privileges
  allowing the role to read various useful configuration settings, statistics and
  other system information normally restricted to superusers.
  </para>
________________________________________________________-->
  <para>
  <literal>pg_monitor</literal>、<literal>pg_read_all_settings</literal>、<literal>pg_read_all_stats</literal>和<literal>pg_stat_scan_tables</literal>角色的目的是允许管理员能为监控数据库服务器的目的很容易地配置角色。它们授予一组常用的特权，这些特权允许角色读取各种有用的配置设置、统计信息以及通常仅限于超级用户的其他系统信息。
  </para>
<!-- pgdoc-cn_end sig_en=9913dc9e4b00225bdc5d5a7827f63b56 -->

<!-- pgdoc-cn_start sig_en=3002494ada715e5b9620908c8902b988 sig_cn_org=a566f04be9c9361f728a3abe594b0bb5 source=15.7 
  <para>
  The <literal>pg_database_owner</literal> role has one implicit,
  situation-dependent member, namely the owner of the current database.  Like
  any role, it can own objects or receive grants of access privileges.
  Consequently, once <literal>pg_database_owner</literal> has rights within a
  template database, each owner of a database instantiated from that template
  will exercise those rights.  <literal>pg_database_owner</literal> cannot be
  a member of any role, and it cannot have non-implicit members.  Initially,
  this role owns the <literal>public</literal> schema, so each database owner
  governs local use of the schema.
  </para>
________________________________________________________-->
  <para>
  <literal>pg_database_owner</literal>角色有一个隐式的、情况相关的成员，即当前数据库的所有者。
  像任何角色一样，它可以拥有对象或接收访问权限的授予。因此，一旦<literal>pg_database_owner</literal>在模板数据库中拥有权限，
  从该模板实例化的每个数据库的所有者都将行使这些权限。<literal>pg_database_owner</literal>不能是任何角色的成员，也不能有非隐式成员。
  最初，该角色拥有<literal>public</literal>模式，因此每个数据库所有者都可以管理该模式的本地使用。
</para>
<!-- pgdoc-cn_end sig_en=3002494ada715e5b9620908c8902b988 -->

<!-- pgdoc-cn_start sig_en=e3235d1946d156ac74a692f9f6037c2b sig_cn_org=None source=14.1 
  <para>
  The <literal>pg_signal_backend</literal> role is intended to allow
  administrators to enable trusted, but non-superuser, roles to send signals
  to other backends. Currently this role enables sending of signals for
  canceling a query on another backend or terminating its session. A user
  granted this role cannot however send signals to a backend owned by a
  superuser.  See <xref linkend="functions-admin-signal"/>.
  </para>
________________________________________________________-->
  <para>
  <literal>pg_signal_backend</literal>角色想要允许管理员启用受信任的、但是非超级用户的、发送信号给其他后端的角色。
  当前，此角色允许发送信号以取消另一个后端上的查询或终止其会话。不过授予此角色的用户不能向属于超级用户的后端发送信号。
  参见<xref linkend="functions-admin-signal"/>
  </para>
<!-- pgdoc-cn_end sig_en=e3235d1946d156ac74a692f9f6037c2b -->

<!-- pgdoc-cn_start sig_en=daeb6fb7a2c47264ec18ba080736a82c sig_cn_org=None source=14.1 
  <para>
  The <literal>pg_read_server_files</literal>, <literal>pg_write_server_files</literal> and
  <literal>pg_execute_server_program</literal> roles are intended to allow administrators to have
  trusted, but non-superuser, roles which are able to access files and run programs on the
  database server as the user the database runs as.  As these roles are able to access any file on
  the server file system, they bypass all database-level permission checks when accessing files
  directly and they could be used to gain superuser-level access, therefore
  great care should be taken when granting these roles to users.
  </para>
________________________________________________________-->
  <para>
  <literal>pg_read_server_files</literal>、<literal>pg_write_server_files</literal>以及<literal>pg_execute_server_program</literal>角色的目的是允许管理员有一些可信但不是超级用户的角色来访问文件以及以运行数据库的用户在数据库服务器上运行程序。
  由于这些角色能够访问服务器文件系统上的任何文件，因此在直接访问文件时它们会绕过任何数据库级别的权限检查并且它们可以被用来得到超级用户级别的访问，因此在把这些角色授予给用户时应当特别小心。
  </para>
<!-- pgdoc-cn_end sig_en=daeb6fb7a2c47264ec18ba080736a82c -->

<!-- pgdoc-cn_start sig_en=aba9f99c36644d7196db97bdbb5e57af sig_cn_org=None source=14.1 
  <para>
  Care should be taken when granting these roles to ensure they are only used where
  needed and with the understanding that these roles grant access to privileged
  information.
  </para>
________________________________________________________-->
  <para>
  在授予这些角色时应当非常小心，以确保它们只被用在需要的地方，并且要理解这些角色会授予对特权信息的访问。
  </para>
<!-- pgdoc-cn_end sig_en=aba9f99c36644d7196db97bdbb5e57af -->

<!-- pgdoc-cn_start sig_en=5ec0e84cc340e9f78dd8177ed515426a sig_cn_org=None source=14.1 
  <para>
   Administrators can grant access to these roles to users using the
   <link linkend="sql-grant"><command>GRANT</command></link> command, for example:

<programlisting>
GRANT pg_signal_backend TO admin_user;
</programlisting>
  </para>
________________________________________________________-->
  <para>
   管理员可以用<link linkend="sql-grant"><command>GRANT</command></link>命令把对这些角色的访问授予给用户，例如：

<programlisting>
GRANT pg_signal_backend TO admin_user;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=5ec0e84cc340e9f78dd8177ed515426a -->

 </sect1>

 <sect1 id="perm-functions">
<!-- pgdoc-cn_start sig_en=d505e2afd078162d2c2a422c47b0572a sig_cn_org=None source=14.1 
  <title>Function Security</title>
________________________________________________________-->
  <title>函数和触发器安全性</title>
<!-- pgdoc-cn_end sig_en=d505e2afd078162d2c2a422c47b0572a -->

<!-- pgdoc-cn_start sig_en=f49c31157051c4ea218a290e28dbe9af sig_cn_org=ec0e8a8c8153c6425e6604b23955fb26 source=15.7 
  <para>
   Functions, triggers and row-level security policies allow users to insert
   code into the backend server that other users might execute
   unintentionally. Hence, these mechanisms permit users to <quote>Trojan
   horse</quote> others with relative ease. The strongest protection is tight
   control over who can define objects. Where that is infeasible, write
   queries referring only to objects having trusted owners.  Remove
   from <varname>search_path</varname> any schemas that permit untrusted users
   to create objects.
  </para>
________________________________________________________-->
  <para>
   函数、触发器和行级安全策略允许用户将代码插入到后端服务器中，其他用户可能会无意中执行。
   因此，这些机制允许用户相对容易地<quote>特洛伊木马</quote>其他用户。最强大的保护方式是：允许哪些角色可以定义对象，进行严格控制。
   如果这是不可行的，那么编写查询时只引用具有受信任所有者的对象。从<varname>search_path</varname>中删除任何允许不受信任用户创建对象的模式。
</para>
<!-- pgdoc-cn_end sig_en=f49c31157051c4ea218a290e28dbe9af -->

<!-- pgdoc-cn_start sig_en=7f2de5a150fcc44d12bc5b61d7ceca43 sig_cn_org=None source=14.1 
  <para>
   Functions run inside the backend
   server process with the operating system permissions of the
   database server daemon.  If the programming language
   used for the function allows unchecked memory accesses, it is
   possible to change the server's internal data structures.
   Hence, among many other things, such functions can circumvent any
   system access controls.  Function languages that allow such access
   are considered <quote>untrusted</quote>, and
   <productname>PostgreSQL</productname> allows only superusers to
   create functions written in those languages.
  </para>
________________________________________________________-->
  <para>
   在后端服务器进程中运行的函数带有数据库服务器守护进程的操作系统权限。如果用于函数的编程语言允许非检查的内存访问，它就可能改变服务器的内部数据结构。因此，在很多其他事情中，这些函数可能绕开任何系统访问控制。允许这种访问的函数语言被认为是<quote>不可信的</quote>，并且<productname>PostgreSQL</productname>只允许超级用户创建用这些语言编写的函数。
  </para>
<!-- pgdoc-cn_end sig_en=7f2de5a150fcc44d12bc5b61d7ceca43 -->
 </sect1>

</chapter>
