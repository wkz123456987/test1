<!-- doc/src/sgml/query.sgml -->

 <chapter id="tutorial-sql">
<!-- pgdoc-cn_start sig_en=60f1edf095950892d4bccab5db73e483 sig_cn_org=None source=14.1 
  <title>The <acronym>SQL</acronym> Language</title>
________________________________________________________-->
  <title><acronym>SQL</acronym>语言</title>
<!-- pgdoc-cn_end sig_en=60f1edf095950892d4bccab5db73e483 -->

  <sect1 id="tutorial-sql-intro">
<!-- pgdoc-cn_start sig_en=c2fcf93c611ba5f3baff759a5cc428dd sig_cn_org=None source=14.1 
   <title>Introduction</title>
________________________________________________________-->
   <title>引言</title>
<!-- pgdoc-cn_end sig_en=c2fcf93c611ba5f3baff759a5cc428dd -->

<!-- pgdoc-cn_start sig_en=bd695591022d9c0771032fd39ac84dd8 sig_cn_org=None source=14.1 
   <para>
    This chapter provides an overview of how to use
    <acronym>SQL</acronym> to perform simple operations.  This
    tutorial is only intended to give you an introduction and is in no
    way a complete tutorial on <acronym>SQL</acronym>.  Numerous books
    have been written on <acronym>SQL</acronym>, including <xref
    linkend="melt93"/> and <xref linkend="date97"/>.
    You should be aware that some <productname>PostgreSQL</productname>
    language features are extensions to the standard.
   </para>
________________________________________________________-->
   <para>
    本章提供一个如何使用<acronym>SQL</acronym>执行简单操作的概述。本教程的目的只是给你一个介绍，并非完整的<acronym>SQL</acronym>教程。有许多关于<acronym>SQL</acronym>的书籍，包括<xref linkend="melt93"/>和<xref linkend="date97"/>。你还要知道有些<productname>PostgreSQL</productname>语言特性是对标准的扩展。
   </para>
<!-- pgdoc-cn_end sig_en=bd695591022d9c0771032fd39ac84dd8 -->

<!-- pgdoc-cn_start sig_en=addf1e1b8f0f7b8df3c541722a2558ea sig_cn_org=None source=14.1 
   <para>
    In the examples that follow, we assume that you have created a
    database named <literal>mydb</literal>, as described in the previous
    chapter, and have been able to start <application>psql</application>.
   </para>
________________________________________________________-->
   <para>
    在随后的例子里，我们假设你已经创建了名为<literal>mydb</literal>的数据库，就象在前面的章里面介绍的一样，并且已经能够启动<application>psql</application>。
   </para>
<!-- pgdoc-cn_end sig_en=addf1e1b8f0f7b8df3c541722a2558ea -->

<!-- pgdoc-cn_start sig_en=045caea25c20be53481b818f85b6a5cf sig_cn_org=None source=14.1 
   <para>
    Examples in this manual can also be found in the
    <productname>PostgreSQL</productname> source distribution
    in the directory <filename>src/tutorial/</filename>.  (Binary
    distributions of <productname>PostgreSQL</productname> might not
    provide those files.)  To use those
    files, first change to that directory and run <application>make</application>:

<screen>
<prompt>$</prompt> <userinput>cd <replaceable>...</replaceable>/src/tutorial</userinput>
<prompt>$</prompt> <userinput>make</userinput>
</screen>

    This creates the scripts and compiles the C files containing user-defined
    functions and types.  Then, to start the tutorial, do the following:

<screen>
<prompt>$</prompt> <userinput>psql -s mydb</userinput>
<computeroutput>
...
</computeroutput>
<prompt>mydb=&gt;</prompt> <userinput>\i basics.sql</userinput>
</screen>

    The <literal>\i</literal> command reads in commands from the
    specified file. <command>psql</command>'s <literal>-s</literal> option puts you in
    single step mode which pauses before sending each statement to the
    server.  The commands used in this section are in the file
    <filename>basics.sql</filename>.
   </para>
________________________________________________________-->
   <para>
    本手册的例子也可以在<productname>PostgreSQL</productname>源代码的目录<filename>src/tutorial/</filename>中找到（二进制<productname>PostgreSQL</productname>发布中可能没有提供这些文件）。要使用这些文件，首先进入该目录然后运行<application>make</application>：

<screen>
<prompt>$</prompt> <userinput>cd <replaceable>...</replaceable>/src/tutorial</userinput>
<prompt>$</prompt> <userinput>make</userinput>
</screen>

    这样就创建了那些脚本并编译了包含用户定义函数和类型的 C 文件。接下来，要开始本教程，按照下面说的做：

<screen>
<prompt>$</prompt> <userinput>psql -s mydb</userinput>
<computeroutput>
...
</computeroutput>
<prompt>mydb=&gt;</prompt> <userinput>\i basics.sql</userinput>
</screen>

    <literal>\i</literal>命令从指定的文件中读取命令。<command>psql</command>的<literal>-s</literal>选项把你置于单步模式，它在向服务器发送每个语句之前暂停。 在本节使用的命令都在文件<filename>basics.sql</filename>中。
   </para>
<!-- pgdoc-cn_end sig_en=045caea25c20be53481b818f85b6a5cf -->
  </sect1>


  <sect1 id="tutorial-concepts">
<!-- pgdoc-cn_start sig_en=0ca21601189d34eb9ae91c750107a8ca sig_cn_org=None source=14.1 
   <title>Concepts</title>
________________________________________________________-->
   <title>概念</title>
<!-- pgdoc-cn_end sig_en=0ca21601189d34eb9ae91c750107a8ca -->

<!-- pgdoc-cn_start sig_en=08ea3cfda50ed0ca15d2e711bcbba7a3 sig_cn_org=None source=14.1 
   <para>
    <indexterm><primary>relational database</primary></indexterm>
    <indexterm><primary>hierarchical database</primary></indexterm>
    <indexterm><primary>object-oriented database</primary></indexterm>
    <indexterm><primary>relation</primary></indexterm>
    <indexterm><primary>table</primary></indexterm>

    <productname>PostgreSQL</productname> is a <firstterm>relational
    database management system</firstterm> (<acronym>RDBMS</acronym>).
    That means it is a system for managing data stored in
    <firstterm>relations</firstterm>.  Relation is essentially a
    mathematical term for <firstterm>table</firstterm>.  The notion of
    storing data in tables is so commonplace today that it might
    seem inherently obvious, but there are a number of other ways of
    organizing databases.  Files and directories on Unix-like
    operating systems form an example of a hierarchical database.  A
    more modern development is the object-oriented database.
   </para>
________________________________________________________-->
   <para>
    <indexterm><primary>关系数据库</primary></indexterm>
    <indexterm><primary>层次数据库</primary></indexterm>
    <indexterm><primary>面向对象数据库</primary></indexterm>
    <indexterm><primary>关系</primary></indexterm>
    <indexterm><primary>表</primary></indexterm>

    <productname>PostgreSQL</productname>是一种<firstterm>关系型数据库管理系统</firstterm> （<acronym>RDBMS</acronym>）。这意味着它是一种用于管理存储在<firstterm>关系</firstterm>中的数据的系统。关系实际上是<firstterm>表</firstterm>的数学术语。 今天，把数据存储在表里的概念已经快成了固有的常识了， 但是还有其它的一些方法用于组织数据库。在类 Unix 操作系统上的文件和目录就形成了一种层次数据库的例子。 更现代的发展是面向对象数据库。
   </para>
<!-- pgdoc-cn_end sig_en=08ea3cfda50ed0ca15d2e711bcbba7a3 -->

<!-- pgdoc-cn_start sig_en=f3c079dcd3030f0203ef8e6a949beacb sig_cn_org=None source=14.1 
   <para>
    <indexterm><primary>row</primary></indexterm>
    <indexterm><primary>column</primary></indexterm>

    Each table is a named collection of <firstterm>rows</firstterm>.
    Each row of a given table has the same set of named
    <firstterm>columns</firstterm>,
    and each column is of a specific data type.  Whereas columns have
    a fixed order in each row, it is important to remember that SQL
    does not guarantee the order of the rows within the table in any
    way (although they can be explicitly sorted for display).
   </para>
________________________________________________________-->
   <para>
    <indexterm><primary>行</primary></indexterm>
    <indexterm><primary>列</primary></indexterm>

    每个表都是一个命名的<firstterm>行</firstterm>集合。一个给定表的每一行由同一组的命名<firstterm>列</firstterm>组成，而且每一列都有一个特定的数据类型。虽然列在每行里的顺序是固定的， 但一定要记住 SQL 并不对行在表中的顺序做任何保证（但你可以为了显示的目的对它们进行显式地排序）。
   </para>
<!-- pgdoc-cn_end sig_en=f3c079dcd3030f0203ef8e6a949beacb -->

<!-- pgdoc-cn_start sig_en=c4c7810261229558c237c8da6174db8e sig_cn_org=None source=14.1 
   <para>
    <indexterm><primary>database cluster</primary></indexterm>
    <indexterm><primary>cluster</primary><secondary>of databases</secondary><see>database cluster</see></indexterm>

    Tables are grouped into databases, and a collection of databases
    managed by a single <productname>PostgreSQL</productname> server
    instance constitutes a database <firstterm>cluster</firstterm>.
   </para>
________________________________________________________-->
   <para>
    <indexterm><primary>数据库集簇</primary></indexterm>
    <indexterm><primary>集簇</primary><secondary>数据库</secondary><see>数据库集簇</see></indexterm>

    表被分组成数据库，一个由单个<productname>PostgreSQL</productname>服务器实例管理的数据库集合组成一个数据库<firstterm>集簇</firstterm>。
   </para>
<!-- pgdoc-cn_end sig_en=c4c7810261229558c237c8da6174db8e -->
  </sect1>


  <sect1 id="tutorial-table">
<!-- pgdoc-cn_start sig_en=6cb208fa17b966f973a8c5dd193be2d2 sig_cn_org=None source=14.1 
   <title>Creating a New Table</title>
________________________________________________________-->
   <title>创建一个新表</title>
<!-- pgdoc-cn_end sig_en=6cb208fa17b966f973a8c5dd193be2d2 -->

<!-- pgdoc-cn_start sig_en=bffccfd910c0fcbd54bc7dd98b97c936 sig_cn_org=None source=14.1 
   <indexterm zone="tutorial-table">
    <primary>CREATE TABLE</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="tutorial-table">
    <primary>CREATE TABLE</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=bffccfd910c0fcbd54bc7dd98b97c936 -->

<!-- pgdoc-cn_start sig_en=a3bcf4f81e1fa345ba64bedd1e99a299 sig_cn_org=None source=14.1 
   <para>
    You  can  create  a  new  table by specifying the table
    name, along with all column names and their types:

<programlisting>
CREATE TABLE weather (
    city            varchar(80),
    temp_lo         int,           -&minus; low temperature
    temp_hi         int,           -&minus; high temperature
    prcp            real,          -&minus; precipitation
    date            date
);
</programlisting>

    You can enter this into <command>psql</command> with the line
    breaks.  <command>psql</command> will recognize that the command
    is not terminated until the semicolon.
   </para>
________________________________________________________-->
   <para>
    你可以通过指定表的名字和所有列的名字及其类型来创建表∶

<programlisting>
CREATE TABLE weather (
    city            varchar(80),
    temp_lo         int,           -- 最低温度
    temp_hi         int,           -- 最高温度
    prcp            real,          -- 湿度
    date            date
);
</programlisting>

    你可以在<command>psql</command>输入这些命令以及换行符。<command>psql</command>可以识别该命令直到分号才结束。
   </para>
<!-- pgdoc-cn_end sig_en=a3bcf4f81e1fa345ba64bedd1e99a299 -->

<!-- pgdoc-cn_start sig_en=533f0b73644f670b79d5bf1fa8749690 sig_cn_org=None source=14.1 
   <para>
    White space (i.e., spaces, tabs, and newlines) can be used freely
    in SQL commands.  That means you can type the command aligned
    differently than above, or even all on one line.  Two dashes
    (<quote><literal>-&minus;</literal></quote>) introduce comments.
    Whatever follows them is ignored up to the end of the line.  SQL
    is case insensitive about key words and identifiers, except
    when identifiers are double-quoted to preserve the case (not done
    above).
   </para>
________________________________________________________-->
   <para>
    你可以在 SQL 命令中自由使用空白（即空格、制表符和换行符）。 这就意味着你可以用和上面不同的对齐方式键入命令，或者将命令全部放在一行中。两个划线（<quote><literal>--</literal></quote>）引入注释。 任何跟在它后面直到行尾的东西都会被忽略。SQL 是对关键字和标识符大小写不敏感的语言，只有在标识符用双引号包围时才能保留它们的大小写（上例没有这么做）。
   </para>
<!-- pgdoc-cn_end sig_en=533f0b73644f670b79d5bf1fa8749690 -->

<!-- pgdoc-cn_start sig_en=f98a77753151ceb6c7e6d6e34681bdf7 sig_cn_org=None source=14.1 
   <para>
    <type>varchar(80)</type> specifies a data type that can store
    arbitrary character strings up to 80 characters in length.
    <type>int</type> is the normal integer type.  <type>real</type> is
    a type for storing single precision floating-point numbers.
    <type>date</type> should be self-explanatory.  (Yes, the column of
    type <type>date</type> is also named <structfield>date</structfield>.
    This might be convenient or confusing &mdash; you choose.)
   </para>
________________________________________________________-->
   <para>
    <type>varchar(80)</type>指定了一个可以存储最长 80 个字符的任意字符串的数据类型。<type>int</type>是普通的整数类型。<type>real</type>是一种用于存储单精度浮点数的类型。<type>date</type>类型应该可以自解释（没错，类型为<type>date</type>的列名字也是<structfield>date</structfield>。 这么做可能比较方便或者容易让人混淆 &mdash; 你自己选择）。
   </para>
<!-- pgdoc-cn_end sig_en=f98a77753151ceb6c7e6d6e34681bdf7 -->

<!-- pgdoc-cn_start sig_en=edd269fa86e716e87e645404ad9e38a7 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> supports the standard
    <acronym>SQL</acronym> types <type>int</type>,
    <type>smallint</type>, <type>real</type>, <type>double
    precision</type>, <type>char(<replaceable>N</replaceable>)</type>,
    <type>varchar(<replaceable>N</replaceable>)</type>, <type>date</type>,
    <type>time</type>, <type>timestamp</type>, and
    <type>interval</type>, as well as other types of general utility
    and a rich set of geometric types.
    <productname>PostgreSQL</productname> can be customized with an
    arbitrary number of user-defined data types.  Consequently, type
    names are not key words in the syntax, except where required to
    support special cases in the <acronym>SQL</acronym> standard.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>支持标准的<acronym>SQL</acronym>类型<type>int</type>、<type>smallint</type>、<type>real</type>、<type>double precision</type>、<type>char(<replaceable>N</replaceable>)</type>、<type>varchar(<replaceable>N</replaceable>)</type>、<type>date</type>、<type>time</type>、<type>timestamp</type>和<type>interval</type>，还支持其他的通用功能的类型和丰富的几何类型。<productname>PostgreSQL</productname>中可以定制任意数量的用户定义数据类型。因而类型名并不是语法关键字，除了<acronym>SQL</acronym>标准要求支持的特例外。
   </para>
<!-- pgdoc-cn_end sig_en=edd269fa86e716e87e645404ad9e38a7 -->

<!-- pgdoc-cn_start sig_en=ec985c4c17ff0a16953fb6197e42d3e5 sig_cn_org=None source=14.1 
   <para>
    The second example will store cities and their associated
    geographical location:
<programlisting>
CREATE TABLE cities (
    name            varchar(80),
    location        point
);
</programlisting>
    The <type>point</type> type is an example of a
    <productname>PostgreSQL</productname>-specific data type.
   </para>
________________________________________________________-->
   <para>
    第二个例子将保存城市和它们相关的地理位置：
<programlisting>
CREATE TABLE cities (
    name            varchar(80),
    location        point
);
</programlisting>
    类型<type>point</type>就是一种<productname>PostgreSQL</productname>特有数据类型的例子。
   </para>
<!-- pgdoc-cn_end sig_en=ec985c4c17ff0a16953fb6197e42d3e5 -->

<!-- pgdoc-cn_start sig_en=44d087b8796dd5020a50bc42289a1af1 sig_cn_org=None source=14.1 
   <para>
    <indexterm>
     <primary>DROP TABLE</primary>
    </indexterm>

    Finally, it should be mentioned that if you don't need a table any
    longer or want to recreate it differently you can remove it using
    the following command:
<synopsis>
DROP TABLE <replaceable>tablename</replaceable>;
</synopsis>
   </para>
________________________________________________________-->
   <para>
    <indexterm>
     <primary>DROP TABLE</primary>
    </indexterm>

    最后，我们还要提到如果你不再需要某个表，或者你想以不同的形式重建它，那么你可以用下面的命令删除它：
<synopsis>
DROP TABLE <replaceable>tablename</replaceable>;
</synopsis>
   </para>
<!-- pgdoc-cn_end sig_en=44d087b8796dd5020a50bc42289a1af1 -->
  </sect1>


  <sect1 id="tutorial-populate">
<!-- pgdoc-cn_start sig_en=4a611f71c34fa3481fe08775edd3f827 sig_cn_org=None source=14.1 
   <title>Populating a Table With Rows</title>
________________________________________________________-->
   <title>在表中增加行</title>
<!-- pgdoc-cn_end sig_en=4a611f71c34fa3481fe08775edd3f827 -->

<!-- pgdoc-cn_start sig_en=51328d29b46f9fe6846044db5a68082c sig_cn_org=None source=14.1 
   <indexterm zone="tutorial-populate">
    <primary>INSERT</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="tutorial-populate">
    <primary>INSERT</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=51328d29b46f9fe6846044db5a68082c -->

<!-- pgdoc-cn_start sig_en=ddc5da26f29bfcc0bb81c2a9bad1b18f sig_cn_org=None source=14.1 
   <para>
    The <command>INSERT</command> statement is used to populate a table  with
    rows:

<programlisting>
INSERT INTO weather VALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');
</programlisting>

    Note that all data types use rather obvious input formats.
    Constants that are not simple numeric values usually must be
    surrounded by single quotes (<literal>'</literal>), as in the example.
    The
    <type>date</type> type is actually quite flexible in what it
    accepts, but for this tutorial we will stick to the unambiguous
    format shown here.
   </para>
________________________________________________________-->
   <para>
    <command>INSERT</command>语句用于向表中添加行：

<programlisting>
INSERT INTO weather VALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');
</programlisting>

    请注意所有数据类型都使用了相当明了的输入格式。那些不是简单数字值的常量通常必需用单引号（<literal>'</literal>）包围，就象在例子里一样。<type>date</type>类型实际上对可接收的格式相当灵活，不过在本教程里，我们应该坚持使用这种清晰的格式。
   </para>
<!-- pgdoc-cn_end sig_en=ddc5da26f29bfcc0bb81c2a9bad1b18f -->

<!-- pgdoc-cn_start sig_en=6e4d65b1453b6731e91c9daca1b57ca5 sig_cn_org=None source=14.1 
   <para>
    The <type>point</type> type requires a coordinate pair as input,
    as shown here:
<programlisting>
INSERT INTO cities VALUES ('San Francisco', '(-194.0, 53.0)');
</programlisting>
   </para>
________________________________________________________-->
   <para>
    <type>point</type>类型要求一个座标对作为输入，如下：
<programlisting>
INSERT INTO cities VALUES ('San Francisco', '(-194.0, 53.0)');
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=6e4d65b1453b6731e91c9daca1b57ca5 -->

<!-- pgdoc-cn_start sig_en=9c22f82ea86ea7c5315402ad863bb22e sig_cn_org=None source=14.1 
   <para>
    The syntax used so far requires you to remember the order of the
    columns.  An alternative syntax allows you to list the columns
    explicitly:
<programlisting>
INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)
    VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');
</programlisting>
    You can list the columns in a different order if you wish or
    even omit some columns, e.g., if the precipitation is unknown:
<programlisting>
INSERT INTO weather (date, city, temp_hi, temp_lo)
    VALUES ('1994-11-29', 'Hayward', 54, 37);
</programlisting>
    Many developers consider explicitly listing the columns better
    style than relying on the order implicitly.
   </para>
________________________________________________________-->
   <para>
    到目前为止使用的语法要求你记住列的顺序。一个可选的语法允许你明确地列出列：
<programlisting>
INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)
    VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');
</programlisting>
    如果你需要，你可以用另外一个顺序列出列或者是忽略某些列， 比如说，我们不知道降水量：
<programlisting>
INSERT INTO weather (date, city, temp_hi, temp_lo)
    VALUES ('1994-11-29', 'Hayward', 54, 37);
</programlisting>
    许多开发人员认为明确列出列要比依赖隐含的顺序是更好的风格。
   </para>
<!-- pgdoc-cn_end sig_en=9c22f82ea86ea7c5315402ad863bb22e -->

<!-- pgdoc-cn_start sig_en=fb01ef3d95abf3006a8ee1e1f8c589d1 sig_cn_org=None source=14.1 
   <para>
    Please enter all the commands shown above so you have some data to
    work with in the following sections.
   </para>
________________________________________________________-->
   <para>
    请输入上面显示的所有命令，这样你在随后的各节中才有可用的数据。
   </para>
<!-- pgdoc-cn_end sig_en=fb01ef3d95abf3006a8ee1e1f8c589d1 -->

<!-- pgdoc-cn_start sig_en=cf6ecf68479b6a11e569473f263f561b sig_cn_org=None source=14.1 
   <para>
    <indexterm>
     <primary>COPY</primary>
    </indexterm>

    You could also have used <command>COPY</command> to load large
    amounts of data from flat-text files.  This is usually faster
    because the <command>COPY</command> command is optimized for this
    application while allowing less flexibility than
    <command>INSERT</command>.  An example would be:

<programlisting>
COPY weather FROM '/home/user/weather.txt';
</programlisting>

    where the file name for the source file must be available on the
    machine running the backend process, not the client, since the backend process
    reads the file directly.  You can read more about the
    <command>COPY</command> command in <xref linkend="sql-copy"/>.
   </para>
________________________________________________________-->
   <para>
    <indexterm>
     <primary>COPY</primary>
    </indexterm>

    你还可以使用<command>COPY</command>从文本文件中装载大量数据。这种方式通常更快，因为<command>COPY</command>命令就是为这类应用优化的， 只是比 <command>INSERT</command>少一些灵活性。比如：

<programlisting>
COPY weather FROM '/home/user/weather.txt';
</programlisting>

    这里源文件的文件名必须在运行后端进程的机器上是可用的， 而不是在客户端上，因为后端进程将直接读取该文件。你可以在<xref linkend="sql-copy"/>中读到更多有关<command>COPY</command>命令的信息。
   </para>
<!-- pgdoc-cn_end sig_en=cf6ecf68479b6a11e569473f263f561b -->
  </sect1>


  <sect1 id="tutorial-select">
<!-- pgdoc-cn_start sig_en=581e0394c43af0d4903e1bd6cb6e35c4 sig_cn_org=None source=14.1 
   <title>Querying a Table</title>
________________________________________________________-->
   <title>查询一个表</title>
<!-- pgdoc-cn_end sig_en=581e0394c43af0d4903e1bd6cb6e35c4 -->

<!-- pgdoc-cn_start sig_en=a8ba35a1dca340ac652c3363b5b7244b sig_cn_org=None source=14.1 
   <para>
    <indexterm><primary>query</primary></indexterm>
    <indexterm><primary>SELECT</primary></indexterm>

    To retrieve data from a table, the table is
    <firstterm>queried</firstterm>.  An <acronym>SQL</acronym>
    <command>SELECT</command> statement is used to do this.  The
    statement is divided into a select list (the part that lists the
    columns to be returned), a table list (the part that lists the
    tables from which to retrieve the data), and an optional
    qualification (the part that specifies any restrictions).  For
    example, to retrieve all the rows of table
    <structname>weather</structname>, type:
<programlisting>
SELECT * FROM weather;
</programlisting>
    Here <literal>*</literal> is a shorthand for <quote>all columns</quote>.
     <footnote>
      <para>
       While <literal>SELECT *</literal> is useful for off-the-cuff
       queries, it is widely considered bad style in production code,
       since adding a column to the table would change the results.
      </para>
     </footnote>
    So the same result would be had with:
<programlisting>
SELECT city, temp_lo, temp_hi, prcp, date FROM weather;
</programlisting>

    The output should be:

<screen>
     city      | temp_lo | temp_hi | prcp |    date
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      43 |      57 |    0 | 1994-11-29
 Hayward       |      37 |      54 |      | 1994-11-29
(3 rows)
</screen>
   </para>
________________________________________________________-->
   <para>
    <indexterm><primary>查询</primary></indexterm>
    <indexterm><primary>SELECT</primary></indexterm>

    要从一个表中检索数据就是<firstterm>查询</firstterm>这个表。<acronym>SQL</acronym>的<command>SELECT</command>语句就是做这个用途的。 该语句分为选择列表（列出要返回的列）、表列表（列出从中检索数据的表）以及可选的条件（指定任意的限制）。比如，要检索表<structname>weather</structname>的所有行，键入：
<programlisting>
SELECT * FROM weather;
</programlisting>
    这里<literal>*</literal>是<quote>所有列</quote>的缩写。
     <footnote>
      <para>
       虽然<literal>SELECT *</literal>对于即席查询很有用，但我们普遍认为在生产代码中这是很糟糕的风格，因为给表增加一个列就改变了结果。
      </para>
     </footnote>
    因此相同的结果应该这样获得：
<programlisting>
SELECT city, temp_lo, temp_hi, prcp, date FROM weather;
</programlisting>

    而输出应该是：

<screen>
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      43 |      57 |    0 | 1994-11-29
 Hayward       |      37 |      54 |      | 1994-11-29
(3 rows)
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=a8ba35a1dca340ac652c3363b5b7244b -->

<!-- pgdoc-cn_start sig_en=6a7492ac776e292845e5a21565d8ba31 sig_cn_org=None source=14.1 
   <para>
    You can write expressions, not just simple column references, in the
    select list.  For example, you can do:
<programlisting>
SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;
</programlisting>
    This should give:
<screen>
     city      | temp_avg |    date
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 San Francisco |       48 | 1994-11-27
 San Francisco |       50 | 1994-11-29
 Hayward       |       45 | 1994-11-29
(3 rows)
</screen>
    Notice how the <literal>AS</literal> clause is used to relabel the
    output column.  (The <literal>AS</literal> clause is optional.)
   </para>
________________________________________________________-->
   <para>
    你可以在选择列表中写任意表达式，而不仅仅是列的列表。比如，你可以：
<programlisting>
SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;
</programlisting>
    这样应该得到：
<screen>
     city      | temp_avg |    date
---------------+----------+------------
 San Francisco |       48 | 1994-11-27
 San Francisco |       50 | 1994-11-29
 Hayward       |       45 | 1994-11-29
(3 rows)
</screen>
    请注意这里的<literal>AS</literal>子句是如何给输出列重新命名的（<literal>AS</literal>子句是可选的）。
   </para>
<!-- pgdoc-cn_end sig_en=6a7492ac776e292845e5a21565d8ba31 -->

<!-- pgdoc-cn_start sig_en=1450af778acca48a55d1a25aa1457410 sig_cn_org=None source=14.1 
   <para>
    A query can be <quote>qualified</quote> by adding a <literal>WHERE</literal>
    clause that specifies which rows are wanted.  The <literal>WHERE</literal>
    clause contains a Boolean (truth value) expression, and only rows for
    which the Boolean expression is true are returned.  The usual
    Boolean operators (<literal>AND</literal>,
    <literal>OR</literal>, and <literal>NOT</literal>) are allowed in
    the qualification.  For example, the following
    retrieves the weather of San Francisco on rainy days:

<programlisting>
SELECT * FROM weather
    WHERE city = 'San Francisco' AND prcp &gt; 0.0;
</programlisting>
    Result:
<screen>
     city      | temp_lo | temp_hi | prcp |    date
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
(1 row)
</screen>
   </para>
________________________________________________________-->
   <para>
    一个查询可以使用<literal>WHERE</literal>子句<quote>修饰</quote>，它指定需要哪些行。<literal>WHERE</literal>子句包含一个布尔（真值）表达式，只有那些使布尔表达式为真的行才会被返回。在条件中可以使用常用的布尔操作符（<literal>AND</literal>、<literal>OR</literal>和<literal>NOT</literal>）。 比如，下面的查询检索旧金山的下雨天的天气：

<programlisting>
SELECT * FROM weather
    WHERE city = 'San Francisco' AND prcp &gt; 0.0;
</programlisting>
    结果：
<screen>
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
(1 row)
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=1450af778acca48a55d1a25aa1457410 -->

<!-- pgdoc-cn_start sig_en=a0f2023393d4141cedc4dbd8966c6591 sig_cn_org=None source=14.1 
   <para>
    <indexterm><primary>ORDER BY</primary></indexterm>

    You can request that the results of a query
    be returned in sorted order:

<programlisting>
SELECT * FROM weather
    ORDER BY city;
</programlisting>

<screen>
     city      | temp_lo | temp_hi | prcp |    date
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 Hayward       |      37 |      54 |      | 1994-11-29
 San Francisco |      43 |      57 |    0 | 1994-11-29
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
</screen>

    In this example, the sort order isn't fully specified, and so you
    might get the San Francisco rows in either order.  But you'd always
    get the results shown above if you do:

<programlisting>
SELECT * FROM weather
    ORDER BY city, temp_lo;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    <indexterm><primary>ORDER BY</primary></indexterm>

    你可以要求返回的查询结果是排好序的：

<programlisting>
SELECT * FROM weather
    ORDER BY city;
</programlisting>

<screen>
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 Hayward       |      37 |      54 |      | 1994-11-29
 San Francisco |      43 |      57 |    0 | 1994-11-29
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
</screen>

    在这个例子里，排序的顺序并未完全被指定，因此你可能看到属于旧金山的行被随机地排序。但是如果你使用下面的语句，那么就总是会得到上面的结果：

<programlisting>
SELECT * FROM weather
    ORDER BY city, temp_lo;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=a0f2023393d4141cedc4dbd8966c6591 -->

<!-- pgdoc-cn_start sig_en=1903af8b56f5a695653eeb3597d3d9cf sig_cn_org=None source=14.1 
   <para>
    <indexterm><primary>DISTINCT</primary></indexterm>
    <indexterm><primary>duplicate</primary></indexterm>

    You can request that duplicate rows be removed from the result of
    a query:

<programlisting>
SELECT DISTINCT city
    FROM weather;
</programlisting>

<screen>
     city
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 Hayward
 San Francisco
(2 rows)
</screen>

    Here again, the result row ordering might vary.
    You can ensure consistent results by using <literal>DISTINCT</literal> and
    <literal>ORDER BY</literal> together:
     <footnote>
      <para>
       In some database systems, including older versions of
       <productname>PostgreSQL</productname>, the implementation of
       <literal>DISTINCT</literal> automatically orders the rows and
       so <literal>ORDER BY</literal> is unnecessary.  But this is not
       required by the SQL standard, and current
       <productname>PostgreSQL</productname> does not guarantee that
       <literal>DISTINCT</literal> causes the rows to be ordered.
      </para>
     </footnote>

<programlisting>
SELECT DISTINCT city
    FROM weather
    ORDER BY city;
</programlisting>
   </para>
________________________________________________________-->
   <para>
    <indexterm><primary>DISTINCT</primary></indexterm>
    <indexterm><primary>重复</primary></indexterm>

    你可以要求在查询的结果中消除重复的行：

<programlisting>
SELECT DISTINCT city
    FROM weather;
</programlisting>

<screen>
     city
---------------
 Hayward
 San Francisco
(2 rows)
</screen>

    再次声明，结果行的顺序可能变化。你可以组合使用<literal>DISTINCT</literal>和<literal>ORDER BY</literal>来保证获取一致的结果：
     <footnote>
      <para>
       在一些数据库系统里，包括老版本的<productname>PostgreSQL</productname>，<literal>DISTINCT</literal>的实现自动对行进行排序，因此<literal>ORDER BY</literal>是多余的。但是这一点并不是 SQL 标准的要求，并且目前的<productname>PostgreSQL</productname>并不保证<literal>DISTINCT</literal>会导致行被排序。
      </para>
     </footnote>

<programlisting>
SELECT DISTINCT city
    FROM weather
    ORDER BY city;
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=1903af8b56f5a695653eeb3597d3d9cf -->
  </sect1>


  <sect1 id="tutorial-join">
<!-- pgdoc-cn_start sig_en=15a483d6732d643f4364791dff5fe538 sig_cn_org=None source=14.1 
   <title>Joins Between Tables</title>
________________________________________________________-->
   <title>在表之间连接</title>
<!-- pgdoc-cn_end sig_en=15a483d6732d643f4364791dff5fe538 -->

<!-- pgdoc-cn_start sig_en=c4abd87b4d83975f5ae0e67d496ec752 sig_cn_org=None source=14.1 
   <indexterm zone="tutorial-join">
    <primary>join</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="tutorial-join">
    <primary>连接</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=c4abd87b4d83975f5ae0e67d496ec752 -->

<!-- pgdoc-cn_start sig_en=7bde47dba15f75f157393263fc3b9c74 sig_cn_org=None source=14.1 
   <para>
    Thus far, our queries have only accessed one table at a time.
    Queries can access multiple tables at once, or access the same
    table in such a way that multiple rows of the table are being
    processed at the same time.  Queries that access multiple tables
    (or multiple instances of the same table) at one time are called
    <firstterm>join</firstterm> queries.  They combine rows from one table
    with rows from a second table, with an expression specifying which rows
    are to be paired.  For example, to return all the weather records together
    with the location of the associated city, the database needs to compare
    the <structfield>city</structfield>
    column of each row of the <structname>weather</structname> table with the
    <structfield>name</structfield> column of all rows in the <structname>cities</structname>
    table, and select the pairs of rows where these values match.<footnote>
     <para>
      This  is only a conceptual model.  The join is usually performed
      in a more efficient manner than actually comparing each possible
      pair of rows, but this is invisible to the user.
     </para>
    </footnote>
    This would be accomplished by the following query:

<programlisting>
SELECT * FROM weather JOIN cities ON city = name;
</programlisting>

<screen>
     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
(2 rows)
</screen>

   </para>
________________________________________________________-->
   <para>
    到目前为止，我们的查询一次只访问一个表。查询可以一次访问多个表，或者用这种方式访问一个表而同时处理该表的多个行。 一次同时访问多张表（或者多个实例的同一张表）的查询叫<firstterm>join</firstterm>查询。它们将一个表中的行与另一个表中的行结合起来，用一个表达式来指定哪些行将被配对。例如，返回所有天气记录以及相关的城市位置。数据库需要拿 <structname>weather</structname>表每行的<structfield>city</structfield>列和<structname>cities</structname>表所有行的<structfield>name</structfield>列进行比较， 并选取那些在该值上相匹配的行。
    <footnote>
     <para>
      这里只是一个概念上的模型。连接通常以比实际比较每个可能的行对更高效的方式执行， 但这些是用户看不到的。
     </para>
    </footnote>
    这个任务可以用下面的查询来实现：

<programlisting>
SELECT * FROM weather JOIN cities ON city = name;
</programlisting>

<screen>
     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
---------------+---------+---------+------+------------+---------------+-----------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
(2 rows)
</screen>

   </para>
<!-- pgdoc-cn_end sig_en=7bde47dba15f75f157393263fc3b9c74 -->

<!-- pgdoc-cn_start sig_en=7d4bc4bdba07d79e318b150d6c6c120e sig_cn_org=None source=14.1 
   <para>
    Observe two things about the result set:
    <itemizedlist>
     <listitem>
      <para>
       There is no result row for the city of Hayward.  This is
       because there is no matching entry in the
       <structname>cities</structname> table for Hayward, so the join
       ignores the unmatched rows in the <structname>weather</structname> table.  We will see
       shortly how this can be fixed.
      </para>
     </listitem>

     <listitem>
      <para>
       There are two columns containing the city name.  This is
       correct because the lists of columns from the
       <structname>weather</structname> and
       <structname>cities</structname> tables are concatenated.  In
       practice this is undesirable, though, so you will probably want
       to list the output columns explicitly rather than using
       <literal>*</literal>:
<programlisting>
SELECT city, temp_lo, temp_hi, prcp, date, location
    FROM weather JOIN cities ON city = name;
</programlisting>
      </para>
     </listitem>
    </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    观察结果集的两个方面：
    <itemizedlist>
     <listitem>
      <para>
       没有城市Hayward的结果行。这是因为在<structname>cities</structname>表里面没有Hayward的匹配行，所以连接忽略 <structname>weather</structname>表里的不匹配行。我们稍后将看到如何修补它。
      </para>
     </listitem>

     <listitem>
      <para>
       有两个列包含城市名字。这是正确的， 因为<structname>weather</structname>和<structname>cities</structname>表的列被串接在一起。不过，实际上我们不想要这些， 因此你将可能希望明确列出输出列而不是使用<literal>*</literal>：
<programlisting>
SELECT city, temp_lo, temp_hi, prcp, date, location
    FROM weather JOIN cities ON city = name;
</programlisting>
      </para>
     </listitem>
    </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=7d4bc4bdba07d79e318b150d6c6c120e -->

<!-- pgdoc-cn_start sig_en=1f4ef5ac067bfab82d91509b314d9826 sig_cn_org=None source=14.1 
   <para>
    Since the columns all had different names, the parser
    automatically found which table they belong to.  If there
    were duplicate column names in the two tables you'd need to
    <firstterm>qualify</firstterm> the column names to show which one you
    meant, as in:

<programlisting>
SELECT weather.city, weather.temp_lo, weather.temp_hi,
       weather.prcp, weather.date, cities.location
    FROM weather JOIN cities ON weather.city = cities.name;
</programlisting>

    It is widely considered good style to qualify all column names
    in a join query, so that the query won't fail if a duplicate
    column name is later added to one of the tables.
   </para>
________________________________________________________-->
   <para>
    因为这些列的名字都不一样，所以规划器自动地找出它们属于哪个表。如果在两个表里有重名的列，你需要<firstterm>限定</firstterm>列名来说明你究竟想要哪一个，如：

<programlisting>
SELECT weather.city, weather.temp_lo, weather.temp_hi,
       weather.prcp, weather.date, cities.location
    FROM weather JOIN cities ON weather.city = cities.name;
</programlisting>

    人们广泛认为在一个连接查询中限定所有列名是一种好的风格，这样即使未来向其中一个表里添加重名列也不会导致查询失败。
   </para>
<!-- pgdoc-cn_end sig_en=1f4ef5ac067bfab82d91509b314d9826 -->

<!-- pgdoc-cn_start sig_en=01d3fc0ee5b3dba5ca70bd278c6d43cc sig_cn_org=None source=14.1 
   <para>
    Join queries of the kind seen thus far can also be written in this
    form:

<programlisting>
SELECT *
    FROM weather, cities
    WHERE city = name;
</programlisting>

    This syntax pre-dates the <literal>JOIN</literal>/<literal>ON</literal>
    syntax, which was introduced in SQL-92.  The tables are simply listed in
    the <literal>FROM</literal> clause, and the comparison expression is added
    to the <literal>WHERE</literal> clause.  The results from this older
    implicit syntax and the newer explicit
    <literal>JOIN</literal>/<literal>ON</literal> syntax are identical.  But
    for a reader of the query, the explicit syntax makes its meaning easier to
    understand: The join condition is introduced by its own key word whereas
    previously the condition was mixed into the <literal>WHERE</literal>
    clause together with other conditions.
   </para>
________________________________________________________-->
   <para>
    到目前为止，这种类型的连接查询也可以用下面这样的形式写出来：

<programlisting>
SELECT *
    FROM weather, cities
    WHERE city = name;
</programlisting>

    这个语法比<literal>JOIN</literal>/<literal>ON</literal>早，它是在SQL-92中引入的。
    这种语法是在<literal>FROM</literal>子句中简单地列出表，比较表达式被添加到<literal>WHERE</literal>子句中。  这种旧的隐式语法和新的显式<literal>JOIN</literal>/<literal>ON</literal>语法的结果是相同的。  But
    对于查询的读者来说，显示的语法使其含义更容易理解。连接条件是由它自己的关键词引入的，而以前这个条件是和<literal>WHERE</literal>子句中其他条件混在一起的。
   </para>
<!-- pgdoc-cn_end sig_en=01d3fc0ee5b3dba5ca70bd278c6d43cc -->

<!-- pgdoc-cn_start sig_en=7c5f38be410de427cbe35edb2f5fa6a4 sig_cn_org=None source=14.1 
   <indexterm><primary>join</primary><secondary>outer</secondary></indexterm>
________________________________________________________-->
   <indexterm><primary>join</primary><secondary>outer</secondary></indexterm>
<!-- pgdoc-cn_end sig_en=7c5f38be410de427cbe35edb2f5fa6a4 -->

<!-- pgdoc-cn_start sig_en=e64f303e4e7dac1098a9409db7b5fb03 sig_cn_org=None source=14.1 
   <para>
    Now we will figure out how we can get the Hayward records back in.
    What we want the query to do is to scan the
    <structname>weather</structname> table and for each row to find the
    matching <structname>cities</structname> row(s).  If no matching row is
    found we want some <quote>empty values</quote> to be substituted
    for the <structname>cities</structname> table's columns.  This kind
    of query is called an <firstterm>outer join</firstterm>.  (The
    joins we have seen so far are <firstterm>inner joins</firstterm>.)
    The command looks like this:

<programlisting>
SELECT *
    FROM weather LEFT OUTER JOIN cities ON weather.city = cities.name;
</programlisting>

<screen>
     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-
 Hayward       |      37 |      54 |      | 1994-11-29 |               |
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
(3 rows)
</screen>

    This query is called a <firstterm>left outer
    join</firstterm> because the table mentioned on the left of the
    join operator will have each of its rows in the output at least
    once, whereas the table on the right will only have those rows
    output that match some row of the left table.  When outputting a
    left-table row for which there is no right-table match, empty (null)
    values are substituted for the right-table columns.
   </para>
________________________________________________________-->
   <para>
    现在我们将看看如何能把Hayward记录找回来。我们想让查询干的事是扫描<structname>weather</structname>表， 并且对每一行都找出匹配的<structname>cities</structname>表行。如果我们没有找到匹配的行，那么我们需要一些<quote>空值</quote>代替cities表的列。 这种类型的查询叫<firstterm>外连接</firstterm> （我们在此之前看到的连接都是<firstterm>inner joins</firstterm>）。这样的命令看起来象这样：

<programlisting>
SELECT *
    FROM weather LEFT OUTER JOIN cities ON weather.city = cities.name;
</programlisting>

<screen>
     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
---------------+---------+---------+------+------------+---------------+-----------
 Hayward       |      37 |      54 |      | 1994-11-29 |               |
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
(3 rows)
</screen>

    这个查询是一个<firstterm>左外连接</firstterm>， 因为在连接操作符左部的表中的行在输出中至少要出现一次， 而在右部的表的行只有在能找到匹配的左部表行时才被输出。 如果输出的左部表的行没有对应匹配的右部表的行，那么右部表行的列将填充空值（null）。
   </para>
<!-- pgdoc-cn_end sig_en=e64f303e4e7dac1098a9409db7b5fb03 -->

   <formalpara>
<!-- pgdoc-cn_start sig_en=70100ad80107681738d26d096387d429 sig_cn_org=None source=14.1 
    <title>Exercise:</title>
________________________________________________________-->
    <title>练习：</title>
<!-- pgdoc-cn_end sig_en=70100ad80107681738d26d096387d429 -->

<!-- pgdoc-cn_start sig_en=7f6805cd442c34b18572e11180e5c282 sig_cn_org=None source=14.1 
    <para>
     There are also right outer joins and full outer joins.  Try to
     find out what those do.
    </para>
________________________________________________________-->
    <para>
      还有右外连接和全外连接。试着找出来它们能干什么。
    </para>
<!-- pgdoc-cn_end sig_en=7f6805cd442c34b18572e11180e5c282 -->
   </formalpara>

<!-- pgdoc-cn_start sig_en=9636b73361d811290f5266afb595854f sig_cn_org=None source=14.1 
   <indexterm><primary>join</primary><secondary>self</secondary></indexterm>
________________________________________________________-->
   <indexterm><primary>join</primary><secondary>self</secondary></indexterm>
<!-- pgdoc-cn_end sig_en=9636b73361d811290f5266afb595854f -->
<!-- pgdoc-cn_start sig_en=df6dc1630ba1960297728431f09d4169 sig_cn_org=None source=14.1 
   <indexterm><primary>alias</primary><secondary>for table name in query</secondary></indexterm>
________________________________________________________-->
   <indexterm><primary>alias</primary><secondary>for table name in query</secondary></indexterm>
<!-- pgdoc-cn_end sig_en=df6dc1630ba1960297728431f09d4169 -->
<!-- pgdoc-cn_start sig_en=0db31d19b9c80f6ca681eb227c32ecdd sig_cn_org=None source=14.1 
   <para>
    We can also join a table against itself.  This is called a
    <firstterm>self join</firstterm>.  As an example, suppose we wish
    to find all the weather records that are in the temperature range
    of other weather records.  So we need to compare the
    <structfield>temp_lo</structfield> and <structfield>temp_hi</structfield> columns of
    each <structname>weather</structname> row to the
    <structfield>temp_lo</structfield> and
    <structfield>temp_hi</structfield> columns of all other
    <structname>weather</structname> rows.  We can do this with the
    following query:

<programlisting>
SELECT w1.city, w1.temp_lo AS low, w1.temp_hi AS high,
       w2.city, w2.temp_lo AS low, w2.temp_hi AS high
    FROM weather w1 JOIN weather w2
        ON w1.temp_lo &lt; w2.temp_lo AND w1.temp_hi &gt; w2.temp_hi;
</programlisting>

<screen>
     city      | low | high |     city      | low | high
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-&minus;
 San Francisco |  43 |   57 | San Francisco |  46 |   50
 Hayward       |  37 |   54 | San Francisco |  46 |   50
(2 rows)
</screen>

    Here we have relabeled the weather table as <literal>w1</literal> and
    <literal>w2</literal> to be able to distinguish the left and right side
    of the join.  You can also use these kinds of aliases in other
    queries to save some typing, e.g.:
<programlisting>
SELECT *
    FROM weather w JOIN cities c ON w.city = c.name;
</programlisting>
    You will encounter this style of abbreviating quite frequently.
   </para>
________________________________________________________-->
   <para>
    我们也可以把一个表和自己连接起来。这叫做<firstterm>自连接</firstterm>。 比如，假设我们想找出那些在其它天气记录的温度范围之外的天气记录。这样我们就需要拿 <structname>weather</structname>表里每行的<structfield>temp_lo</structfield>和<structfield>temp_hi</structfield>列与<structname>weather</structname>表里其它行的<structfield>temp_lo</structfield>和<structfield>temp_hi</structfield>列进行比较。我们可以用下面的查询实现这个目标：

<programlisting>
SELECT w1.city, w1.temp_lo AS low, w1.temp_hi AS high,
       w2.city, w2.temp_lo AS low, w2.temp_hi AS high
    FROM weather w1 JOIN weather w2
        ON w1.temp_lo &lt; w2.temp_lo AND w1.temp_hi &gt; w2.temp_hi;
</programlisting>

<screen>
     city      | low | high |     city      | low | high
---------------+-----+------+---------------+-----+------
 San Francisco |  43 |   57 | San Francisco |  46 |   50
 Hayward       |  37 |   54 | San Francisco |  46 |   50
(2 rows)
</screen>

    在这里我们把weather表重新标记为<literal>w1</literal>和<literal>w2</literal>以区分连接的左部和右部。你还可以用这样的别名在其它查询里节约一些敲键，比如：
<programlisting>
SELECT *
    FROM weather w JOIN cities c ON w.city = c.name;
</programlisting>
    你以后会经常碰到这样的缩写的。
   </para>
<!-- pgdoc-cn_end sig_en=0db31d19b9c80f6ca681eb227c32ecdd -->
  </sect1>


  <sect1 id="tutorial-agg">
<!-- pgdoc-cn_start sig_en=3ace9aa56a8bc975efb162241768b2f9 sig_cn_org=None source=14.1 
   <title>Aggregate Functions</title>
________________________________________________________-->
   <title>聚集函数</title>
<!-- pgdoc-cn_end sig_en=3ace9aa56a8bc975efb162241768b2f9 -->

<!-- pgdoc-cn_start sig_en=2e127072f1f6ca3a59307e9577dcefd3 sig_cn_org=None source=14.1 
   <indexterm zone="tutorial-agg">
    <primary>aggregate function</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="tutorial-agg">
    <primary>聚集函数</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=2e127072f1f6ca3a59307e9577dcefd3 -->

<!-- pgdoc-cn_start sig_en=52bace3adac7abb7cbaf20e6eb2469fe sig_cn_org=None source=14.1 
   <para>
    Like  most  other relational database products,
    <productname>PostgreSQL</productname> supports
    <firstterm>aggregate functions</firstterm>.
    An aggregate function computes a single result from multiple input rows.
    For example, there are aggregates to compute the
    <function>count</function>, <function>sum</function>,
    <function>avg</function> (average), <function>max</function> (maximum) and
    <function>min</function> (minimum) over a set of rows.
   </para>
________________________________________________________-->
   <para>
    和大多数其它关系数据库产品一样，<productname>PostgreSQL</productname>支持<firstterm>聚集函数</firstterm>。 一个聚集函数从多个输入行中计算出一个结果。 比如，我们有在一个行集合上计算<function>count</function>（计数）、<function>sum</function>（和）、<function>avg</function>（均值）、<function>max</function>（最大值）和<function>min</function>（最小值）的函数。
   </para>
<!-- pgdoc-cn_end sig_en=52bace3adac7abb7cbaf20e6eb2469fe -->

<!-- pgdoc-cn_start sig_en=dc79d4b77b800511a2dfed2847976622 sig_cn_org=None source=14.1 
   <para>
    As an example, we can find the highest low-temperature reading anywhere
    with:

<programlisting>
SELECT max(temp_lo) FROM weather;
</programlisting>

<screen>
 max
-&minus;-&minus;-
  46
(1 row)
</screen>
   </para>
________________________________________________________-->
   <para>
    比如，我们可以用下面的语句找出所有记录中最低温度中的最高温度：

<programlisting>
SELECT max(temp_lo) FROM weather;
</programlisting>

<screen>
 max
-----
  46
(1 row)
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=dc79d4b77b800511a2dfed2847976622 -->

<!-- pgdoc-cn_start sig_en=6d72eba6f5d5ea28e36d4631871190e8 sig_cn_org=None source=14.1 
   <para>
    <indexterm><primary>subquery</primary></indexterm>

    If we wanted to know what city (or cities) that reading occurred in,
    we might try:

<programlisting>
SELECT city FROM weather WHERE temp_lo = max(temp_lo);     <lineannotation>WRONG</lineannotation>
</programlisting>

    but this will not work since the aggregate
    <function>max</function> cannot be used in the
    <literal>WHERE</literal> clause.  (This restriction exists because
    the <literal>WHERE</literal> clause determines which rows will be
    included in the aggregate calculation; so obviously it has to be evaluated
    before aggregate functions are computed.)
    However, as is often the case
    the query can be restated to accomplish the desired result, here
    by using a <firstterm>subquery</firstterm>:

<programlisting>
SELECT city FROM weather
    WHERE temp_lo = (SELECT max(temp_lo) FROM weather);
</programlisting>

<screen>
     city
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-
 San Francisco
(1 row)
</screen>

    This is OK because the subquery is an independent computation
    that computes its own aggregate separately from what is happening
    in the outer query.
   </para>
________________________________________________________-->
   <para>
    <indexterm><primary>子查询</primary></indexterm>

    如果我们想知道该读数发生在哪个城市，我们可以用：

<programlisting>
SELECT city FROM weather WHERE temp_lo = max(temp_lo);     <lineannotation>错误</lineannotation>
</programlisting>

    不过这个方法不能运转，因为聚集<function>max</function>不能被用于<literal>WHERE</literal>子句中（存在这个限制是因为<literal>WHERE</literal>子句决定哪些行可以被聚集计算包括；因此显然它必需在聚集函数之前被计算）。 不过，我们通常都可以用其它方法实现我们的目的；这里我们就可以使用<firstterm>子查询</firstterm>：

<programlisting>
SELECT city FROM weather
    WHERE temp_lo = (SELECT max(temp_lo) FROM weather);
</programlisting>

<screen>
     city
---------------
 San Francisco
(1 row)
</screen>

    这样做是 OK 的，因为子查询是一次独立的计算，它独立于外层的查询计算出自己的聚集。
   </para>
<!-- pgdoc-cn_end sig_en=6d72eba6f5d5ea28e36d4631871190e8 -->

<!-- pgdoc-cn_start sig_en=809c0954a0c3e3972f2b55dc31536085 sig_cn_org=1136cdf2435d2fc20215d7b6b2612fd3 source=15.7 
   <para>
    <indexterm><primary>GROUP BY</primary></indexterm>
    <indexterm><primary>HAVING</primary></indexterm>

    Aggregates are also very useful in combination with <literal>GROUP
    BY</literal> clauses.  For example, we can get the number of readings
    and the maximum low temperature observed in each city with:

<programlisting>
SELECT city, count(*), max(temp_lo)
    FROM weather
    GROUP BY city;
</programlisting>

<screen>
     city      | count | max
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-
 Hayward       |     1 |  37
 San Francisco |     2 |  46
(2 rows)
</screen>

    which gives us one output row per city.  Each aggregate result is
    computed over the table rows matching that city.
    We can filter these grouped
    rows using <literal>HAVING</literal>:

<programlisting>
SELECT city, count(*), max(temp_lo)
    FROM weather
    GROUP BY city
    HAVING max(temp_lo) &lt; 40;
</programlisting>

<screen>
  city   | count | max
-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-
 Hayward |     1 |  37
(1 row)
</screen>

    which gives us the same results for only the cities that have all
    <structfield>temp_lo</structfield> values below 40.  Finally, if we only care about
    cities whose
    names begin with <quote><literal>S</literal></quote>, we might do:

<programlisting>
SELECT city, count(*), max(temp_lo)
    FROM weather
    WHERE city LIKE 'S%'            -&minus; <co id="co.tutorial-agg-like"/>
    GROUP BY city;
</programlisting>

<screen>
     city      | count | max
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-
 San Francisco |     2 |  46
(1 row)
</screen>
   <calloutlist>
    <callout arearefs="co.tutorial-agg-like">
     <para>
      The <literal>LIKE</literal> operator does pattern matching and
      is explained in <xref linkend="functions-matching"/>.
     </para>
    </callout>
   </calloutlist>
   </para>
________________________________________________________-->
   <para>
    <indexterm><primary>GROUP BY</primary></indexterm>
    <indexterm><primary>HAVING</primary></indexterm>

    聚合函数在与<literal>GROUP BY</literal>子句结合时也非常有用。例如，我们可以通过以下查询获取每个城市的读数和观察到的最低温度：

<programlisting>
SELECT city, count(*), max(temp_lo)
    FROM weather
    GROUP BY city;
</programlisting>

<screen>
     city      | count | max
---------------+-------+-----
 Hayward       |     1 |  37
 San Francisco |     2 |  46
(2 rows)
</screen>

    这使我们每个城市得到一个输出行。每个聚合结果是在匹配该城市的表行上计算的。
    我们可以使用<literal>HAVING</literal>来过滤这些分组的行：

<programlisting>
SELECT city, count(*), max(temp_lo)
    FROM weather
    GROUP BY city
    HAVING max(temp_lo) &lt; 40;
</programlisting>

<screen>
  city   | count | max
---------+-------+-----
 Hayward |     1 |  37
(1 row)
</screen>

    这使我们仅获取所有<structfield>temp_lo</structfield>值低于40的城市的相同结果。最后，如果我们只关心以<quote><literal>S</literal></quote>开头的城市的话，我们可以这样做：

<programlisting>
SELECT city, count(*), max(temp_lo)
    FROM weather
    WHERE city LIKE 'S%'            -- <co id="co.tutorial-agg-like"/>
    GROUP BY city;
</programlisting>

<screen>
     city      | count | max
---------------+-------+-----
 San Francisco |     2 |  46
(1 row)
</screen>
   <calloutlist>
    <callout arearefs="co.tutorial-agg-like">
     <para>
      <literal>LIKE</literal>操作符进行模式匹配，详细说明请参见<xref linkend="functions-matching"/>。
     </para>
    </callout>
   </calloutlist>
   </para>
<!-- pgdoc-cn_end sig_en=809c0954a0c3e3972f2b55dc31536085 -->

<!-- pgdoc-cn_start sig_en=0a6ff56675b57a2afd23eedefb39c2c3 sig_cn_org=None source=14.1 
   <para>
    It is important to understand the interaction between aggregates and
    <acronym>SQL</acronym>'s <literal>WHERE</literal> and <literal>HAVING</literal> clauses.
    The fundamental difference between <literal>WHERE</literal> and
    <literal>HAVING</literal> is this: <literal>WHERE</literal> selects
    input rows before groups and aggregates are computed (thus, it controls
    which rows go into the aggregate computation), whereas
    <literal>HAVING</literal> selects group rows after groups and
    aggregates are computed.  Thus, the
    <literal>WHERE</literal> clause must not contain aggregate functions;
    it makes no sense to try to use an aggregate to determine which rows
    will be inputs to the aggregates.  On the other hand, the
    <literal>HAVING</literal> clause always contains aggregate functions.
    (Strictly speaking, you are allowed to write a <literal>HAVING</literal>
    clause that doesn't use aggregates, but it's seldom useful. The same
    condition could be used more efficiently at the <literal>WHERE</literal>
    stage.)
   </para>
________________________________________________________-->
   <para>
    理解聚集和<acronym>SQL</acronym>的<literal>WHERE</literal>以及<literal>HAVING</literal>子句之间的关系对我们非常重要。<literal>WHERE</literal>和<literal>HAVING</literal>的基本区别如下：<literal>WHERE</literal>在分组和聚集计算之前选取输入行（因此，它控制哪些行进入聚集计算）， 而<literal>HAVING</literal>在分组和聚集之后选取分组行。因此，<literal>WHERE</literal>子句不能包含聚集函数； 因为试图用聚集函数判断哪些行应输入给聚集运算是没有意义的。相反，<literal>HAVING</literal>子句总是包含聚集函数（严格说来，你可以写不使用聚集的<literal>HAVING</literal>子句， 但这样做很少有用。同样的条件用在<literal>WHERE</literal>阶段会更有效）。
   </para>
<!-- pgdoc-cn_end sig_en=0a6ff56675b57a2afd23eedefb39c2c3 -->

<!-- pgdoc-cn_start sig_en=fc0a21dd557bd4e2cefea4f3b9a543ab sig_cn_org=None source=14.1 
   <para>
    In the previous example, we can apply the city name restriction in
    <literal>WHERE</literal>, since it needs no aggregate.  This is
    more efficient than adding the restriction to <literal>HAVING</literal>,
    because we avoid doing the grouping and aggregate calculations
    for all rows that fail the <literal>WHERE</literal> check.
   </para>
________________________________________________________-->
   <para>
    在前面的例子里，我们可以在<literal>WHERE</literal>里应用城市名称限制，因为它不需要聚集。这样比放在<literal>HAVING</literal>里更加高效，因为可以避免那些未通过 <literal>WHERE</literal>检查的行参与到分组和聚集计算中。
   </para>
<!-- pgdoc-cn_end sig_en=fc0a21dd557bd4e2cefea4f3b9a543ab -->

<!-- pgdoc-cn_start sig_en=17de22832bcbdf6e99592b9b1c93dfef sig_cn_org=df71a05c826ec78a60e1fd5ac5fea396 source=15.7 
   <para>
    Another way to select the rows that go into an aggregate
    computation is to use <literal>FILTER</literal>, which is a
    per-aggregate option:

<programlisting>
SELECT city, count(*) FILTER (WHERE temp_lo &lt; 45), max(temp_lo)
    FROM weather
    GROUP BY city;
</programlisting>

<screen>
     city      | count | max
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-
 Hayward       |     1 |  37
 San Francisco |     1 |  46
(2 rows)
</screen>

    <literal>FILTER</literal> is much like <literal>WHERE</literal>,
    except that it removes rows only from the input of the particular
    aggregate function that it is attached to.
    Here, the <literal>count</literal> aggregate counts only
    rows with <literal>temp_lo</literal> below 45; but the
    <literal>max</literal> aggregate is still applied to all rows,
    so it still finds the reading of 46.
   </para>
________________________________________________________-->
   <para>
    选择进入聚合计算的行的另一种方法是使用<literal>FILTER</literal>，这是一个每个聚合的选项：

<programlisting>
SELECT city, count(*) FILTER (WHERE temp_lo &lt; 45), max(temp_lo)
    FROM weather
    GROUP BY city;
</programlisting>

<screen>
     city      | count | max
---------------+-------+-----
 Hayward       |     1 |  37
 San Francisco |     1 |  46
(2 rows)
</screen>

    <literal>FILTER</literal>与<literal>WHERE</literal>非常相似，
    不同之处在于它仅从附加到特定聚合函数的输入中删除行。
    在这里，<literal>count</literal>聚合仅计算
    <literal>temp_lo</literal>低于45的行；但是
    <literal>max</literal>聚合仍然应用于所有行，
    因此仍然找到46的读数。
</para>
<!-- pgdoc-cn_end sig_en=17de22832bcbdf6e99592b9b1c93dfef -->
  </sect1>


  <sect1 id="tutorial-update">
<!-- pgdoc-cn_start sig_en=a23e709173abf0453ae90fac446a7c60 sig_cn_org=None source=14.1 
   <title>Updates</title>
________________________________________________________-->
   <title>更新</title>
<!-- pgdoc-cn_end sig_en=a23e709173abf0453ae90fac446a7c60 -->

<!-- pgdoc-cn_start sig_en=940625f86eaeb57559cbb3164749be68 sig_cn_org=None source=14.1 
   <indexterm zone="tutorial-update">
    <primary>UPDATE</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="tutorial-update">
    <primary>UPDATE</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=940625f86eaeb57559cbb3164749be68 -->

<!-- pgdoc-cn_start sig_en=a7e015e17b0b7b54bfcaeb610e923f44 sig_cn_org=None source=14.1 
   <para>
    You can update existing rows using the
    <command>UPDATE</command> command.
    Suppose you discover the temperature readings are
    all off by 2 degrees after November 28.  You can correct the
    data as follows:

<programlisting>
UPDATE weather
    SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2
    WHERE date &gt; '1994-11-28';
</programlisting>
   </para>
________________________________________________________-->
   <para>
    你可以用<command>UPDATE</command>命令更新现有的行。假设你发现所有 11 月 28 日以后的温度读数都低了两度，那么你就可以用下面的方式改正数据：

<programlisting>
UPDATE weather
    SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2
    WHERE date &gt; '1994-11-28';
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=a7e015e17b0b7b54bfcaeb610e923f44 -->

<!-- pgdoc-cn_start sig_en=ad1bf3352cd5d668a2382d40b00931fd sig_cn_org=None source=14.1 
   <para>
    Look at the new state of the data:
<programlisting>
SELECT * FROM weather;

     city      | temp_lo | temp_hi | prcp |    date
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      41 |      55 |    0 | 1994-11-29
 Hayward       |      35 |      52 |      | 1994-11-29
(3 rows)
</programlisting>
   </para>
________________________________________________________-->
   <para>
    看看数据的新状态：
<programlisting>
SELECT * FROM weather;

     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      41 |      55 |    0 | 1994-11-29
 Hayward       |      35 |      52 |      | 1994-11-29
(3 rows)
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=ad1bf3352cd5d668a2382d40b00931fd -->
  </sect1>

  <sect1 id="tutorial-delete">
<!-- pgdoc-cn_start sig_en=65ed64241fe0d118777f0cf63c993113 sig_cn_org=None source=14.1 
   <title>Deletions</title>
________________________________________________________-->
   <title>删除</title>
<!-- pgdoc-cn_end sig_en=65ed64241fe0d118777f0cf63c993113 -->

<!-- pgdoc-cn_start sig_en=3b10a2c9cbdd7383d3ad5ea13ca3e445 sig_cn_org=None source=14.1 
   <indexterm zone="tutorial-delete">
    <primary>DELETE</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="tutorial-delete">
    <primary>DELETE</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=3b10a2c9cbdd7383d3ad5ea13ca3e445 -->

<!-- pgdoc-cn_start sig_en=867855f4a534eec413c2e6cfa1d08ebf sig_cn_org=None source=14.1 
   <para>
    Rows can be removed from a table using the <command>DELETE</command>
    command.
    Suppose you are no longer interested in the weather of Hayward.
    Then you can do the following to delete those rows from the table:
<programlisting>
DELETE FROM weather WHERE city = 'Hayward';
</programlisting>

    All weather records belonging to Hayward are removed.

<programlisting>
SELECT * FROM weather;
</programlisting>

<screen>
     city      | temp_lo | temp_hi | prcp |    date
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      41 |      55 |    0 | 1994-11-29
(2 rows)
</screen>
   </para>
________________________________________________________-->
   <para>
    数据行可以用<command>DELETE</command>命令从表中删除。假设你对Hayward的天气不再感兴趣，那么你可以用下面的方法把那些行从表中删除：
<programlisting>
DELETE FROM weather WHERE city = 'Hayward';
</programlisting>

    所有属于Hayward的天气记录都被删除。

<programlisting>
SELECT * FROM weather;
</programlisting>

<screen>
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      41 |      55 |    0 | 1994-11-29
(2 rows)
</screen>
   </para>
<!-- pgdoc-cn_end sig_en=867855f4a534eec413c2e6cfa1d08ebf -->

<!-- pgdoc-cn_start sig_en=8896a406b9585092686620e187d68167 sig_cn_org=None source=14.1 
   <para>
    One should be wary of statements of the form
<synopsis>
DELETE FROM <replaceable>tablename</replaceable>;
</synopsis>

    Without a qualification, <command>DELETE</command> will
    remove  <emphasis>all</emphasis>  rows from the given table, leaving it
    empty.  The system will not request confirmation before
    doing this!
   </para>
________________________________________________________-->
   <para>
    我们用下面形式的语句的时候一定要小心
<synopsis>
DELETE FROM <replaceable>tablename</replaceable>;
</synopsis>

    如果没有一个限制，<command>DELETE</command>将从指定表中删除所有行，把它清空。做这些之前系统不会请求你确认！
   </para>
<!-- pgdoc-cn_end sig_en=8896a406b9585092686620e187d68167 -->
  </sect1>

 </chapter>
