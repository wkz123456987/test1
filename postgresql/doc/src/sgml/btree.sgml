<!-- doc/src/sgml/btree.sgml -->

<chapter id="btree">
<!-- pgdoc-cn_start sig_en=f1d08cc38056c4429f4021be92850183 sig_cn_org=None source=14.1 
<title>B-Tree Indexes</title>
________________________________________________________-->
<title>B-树索引</title>
<!-- pgdoc-cn_end sig_en=f1d08cc38056c4429f4021be92850183 -->

<!-- pgdoc-cn_start sig_en=1cf0633673e08f102277e2678d6d36f4 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>index</primary>
    <secondary>B-Tree</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>index</primary>
    <secondary>B-Tree</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=1cf0633673e08f102277e2678d6d36f4 -->

<sect1 id="btree-intro">
<!-- pgdoc-cn_start sig_en=c2fcf93c611ba5f3baff759a5cc428dd sig_cn_org=None source=14.1 
 <title>Introduction</title>
________________________________________________________-->
 <title>简介</title>
<!-- pgdoc-cn_end sig_en=c2fcf93c611ba5f3baff759a5cc428dd -->

<!-- pgdoc-cn_start sig_en=3c46746737ee9de095fb40a59da8206e sig_cn_org=None source=14.1 
 <para>
  <productname>PostgreSQL</productname> includes an implementation of the
  standard <acronym>btree</acronym> (multi-way balanced tree) index data
  structure.  Any data type that can be sorted into a well-defined linear
  order can be indexed by a btree index.  The only limitation is that an
  index entry cannot exceed approximately one-third of a page (after TOAST
  compression, if applicable).
 </para>
________________________________________________________-->
 <para>
  <productname>PostgreSQL</productname>包括了对标准<acronym>btree</acronym>（多路平衡树）索引数据结构的一个实现。任何能够被排序为良定义线性顺序的数据结构都可以用一个btree来索引。唯一的限制是一个索引项不能超过大约三分之一个页面（如果适用，可以是TOAST压缩后的大小）。
 </para>
<!-- pgdoc-cn_end sig_en=3c46746737ee9de095fb40a59da8206e -->

<!-- pgdoc-cn_start sig_en=a3933fd9e25437971593a6a65872cb80 sig_cn_org=None source=14.1 
 <para>
  Because each btree operator class imposes a sort order on its data type,
  btree operator classes (or, really, operator families) have come to be
  used as <productname>PostgreSQL</productname>'s general representation
  and understanding of sorting semantics.  Therefore, they've acquired
  some features that go beyond what would be needed just to support btree
  indexes, and parts of the system that are quite distant from the
  btree AM make use of them.
 </para>
________________________________________________________-->
 <para>
  因为每一种btree操作符类都会在其数据类型上施加一种排序顺序，btree的操作符类（或者实际上是操作符族）已经被用作<productname>PostgreSQL</productname>对排序语义的一般表达和理解。因此，它们需要一些支持btree索引之外的特性，并且这个系统的一些部分与利用它们的btree访问方法有较大的不同。
 </para>
<!-- pgdoc-cn_end sig_en=a3933fd9e25437971593a6a65872cb80 -->

</sect1>

<sect1 id="btree-behavior">
<!-- pgdoc-cn_start sig_en=21e46c5eaf98d13d0b9aef6f5d8e529f sig_cn_org=None source=14.1 
 <title>Behavior of B-Tree Operator Classes</title>
________________________________________________________-->
 <title>B-树操作符类的行为</title>
<!-- pgdoc-cn_end sig_en=21e46c5eaf98d13d0b9aef6f5d8e529f -->

<!-- pgdoc-cn_start sig_en=d925a866bcc0c7d606f61e6108a0b12f sig_cn_org=None source=14.1 
 <para>
  As shown in <xref linkend="xindex-btree-strat-table"/>, a btree operator
  class must provide five comparison operators,
  <literal>&lt;</literal>,
  <literal>&lt;=</literal>,
  <literal>=</literal>,
  <literal>&gt;=</literal> and
  <literal>&gt;</literal>.
  One might expect that <literal>&lt;&gt;</literal> should also be part of
  the operator class, but it is not, because it would almost never be
  useful to use a <literal>&lt;&gt;</literal> WHERE clause in an index
  search.  (For some purposes, the planner treats <literal>&lt;&gt;</literal>
  as associated with a btree operator class; but it finds that operator via
  the <literal>=</literal> operator's negator link, rather than
  from <structname>pg_amop</structname>.)
 </para>
________________________________________________________-->
 <para>
  如<xref linkend="xindex-btree-strat-table"/>中所示，一个btree操作符类必须提供五种比较操作符：<literal>&lt;</literal>、<literal>&lt;=</literal>、<literal>=</literal>、<literal>&gt;=</literal>以及<literal>&gt;</literal>。有人可能会想<literal>&lt;&gt;</literal>应该也是操作符类的一部分，但不是这样，因为几乎从不会在索引搜索中使用有<literal>&lt;&gt;</literal>的WHERE子句（出于某种原因，规划器会认为<literal>&lt;&gt;</literal>与一个btree操作符类相关，但它是通过<literal>=</literal>操作符的逆操作符链接来找到这个操作符，而不是从<structname>pg_amop</structname>中查找）。
 </para>
<!-- pgdoc-cn_end sig_en=d925a866bcc0c7d606f61e6108a0b12f -->

<!-- pgdoc-cn_start sig_en=c11478e7f46f394191b6a49b6699e90e sig_cn_org=None source=14.1 
 <para>
  When several data types share near-identical sorting semantics, their
  operator classes can be grouped into an operator family.  Doing so is
  advantageous because it allows the planner to make deductions about
  cross-type comparisons.  Each operator class within the family should
  contain the single-type operators (and associated support functions)
  for its input data type, while cross-type comparison operators and
  support functions are <quote>loose</quote> in the family.  It is
  recommendable that a complete set of cross-type operators be included
  in the family, thus ensuring that the planner can represent any
  comparison conditions that it deduces from transitivity.
 </para>
________________________________________________________-->
 <para>
  当一些数据类型共享近乎相同的排序语义时，它们的操作符类可以被组合成一个操作符族。这样做是有好处的，因为这样就允许规划器对跨类型比较进行推演。在操作符族中的每一种操作符类对其输入数据类型应该包含单一类型的操作符（及其相关的支持函数），而跨类型比较操作符及其支持函数则<quote>松散</quote>地放在操作符族中。推荐在操作符族中包括一套完整的跨类型操作符，这样能确保规划器可以表达它通过传递性推演出的任何比较条件。
 </para>
<!-- pgdoc-cn_end sig_en=c11478e7f46f394191b6a49b6699e90e -->

<!-- pgdoc-cn_start sig_en=68df555082de8c835f7103fa25c6ebef sig_cn_org=None source=14.1 
 <para>
  There are some basic assumptions that a btree operator family must
  satisfy:
 </para>
________________________________________________________-->
 <para>
  这里有一些btree操作符类必须满足的基本假设：
 </para>
<!-- pgdoc-cn_end sig_en=68df555082de8c835f7103fa25c6ebef -->

 <itemizedlist>
  <listitem>
<!-- pgdoc-cn_start sig_en=c59975657d4b56ba28edecebd2eff342 sig_cn_org=None source=14.1 
   <para>
    An <literal>=</literal> operator must be an equivalence relation; that
    is, for all non-null values <replaceable>A</replaceable>,
    <replaceable>B</replaceable>, <replaceable>C</replaceable> of the
    data type:

    <itemizedlist>
     <listitem>
      <para>
       <replaceable>A</replaceable> <literal>=</literal>
       <replaceable>A</replaceable> is true
       (<firstterm>reflexive law</firstterm>)
      </para>
     </listitem>
     <listitem>
      <para>
       if <replaceable>A</replaceable> <literal>=</literal>
       <replaceable>B</replaceable>,
       then <replaceable>B</replaceable> <literal>=</literal>
       <replaceable>A</replaceable>
       (<firstterm>symmetric law</firstterm>)
      </para>
     </listitem>
     <listitem>
      <para>
       if <replaceable>A</replaceable> <literal>=</literal>
       <replaceable>B</replaceable> and <replaceable>B</replaceable>
       <literal>=</literal> <replaceable>C</replaceable>,
       then <replaceable>A</replaceable> <literal>=</literal>
       <replaceable>C</replaceable>
       (<firstterm>transitive law</firstterm>)
      </para>
     </listitem>
    </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    一个<literal>=</literal>操作符必须是一种等值关系。也就是说，对于该数据类型的所有非空值<replaceable>A</replaceable>、<replaceable>B</replaceable>、<replaceable>C</replaceable>：

    <itemizedlist>
     <listitem>
      <para>
       <replaceable>A</replaceable> <literal>=</literal> <replaceable>A</replaceable>为真（<firstterm>自反律</firstterm>）
      </para>
     </listitem>
     <listitem>
      <para>
       如果<replaceable>A</replaceable> <literal>=</literal> <replaceable>B</replaceable>，则有<replaceable>B</replaceable> <literal>=</literal>
       <replaceable>A</replaceable>（<firstterm>对称律</firstterm>）
      </para>
     </listitem>
     <listitem>
      <para>
       如果<replaceable>A</replaceable> <literal>=</literal> <replaceable>B</replaceable>并且<replaceable>B</replaceable> <literal>=</literal> <replaceable>C</replaceable>，则有<replaceable>A</replaceable> <literal>=</literal> <replaceable>C</replaceable>（<firstterm>传递律</firstterm>）
      </para>
     </listitem>
    </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=c59975657d4b56ba28edecebd2eff342 -->
  </listitem>

  <listitem>
<!-- pgdoc-cn_start sig_en=625d97bf4c90b0e852836895f7bae35e sig_cn_org=None source=14.1 
   <para>
    A <literal>&lt;</literal> operator must be a strong ordering relation;
    that is, for all non-null values <replaceable>A</replaceable>,
    <replaceable>B</replaceable>, <replaceable>C</replaceable>:

    <itemizedlist>
     <listitem>
      <para>
       <replaceable>A</replaceable> <literal>&lt;</literal>
       <replaceable>A</replaceable> is false
       (<firstterm>irreflexive law</firstterm>)
      </para>
     </listitem>
     <listitem>
      <para>
       if <replaceable>A</replaceable> <literal>&lt;</literal>
       <replaceable>B</replaceable>
       and <replaceable>B</replaceable> <literal>&lt;</literal>
       <replaceable>C</replaceable>,
       then <replaceable>A</replaceable> <literal>&lt;</literal>
       <replaceable>C</replaceable>
       (<firstterm>transitive law</firstterm>)
      </para>
     </listitem>
    </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    一个<literal>&lt;</literal>操作符必须是一种强排序关系。也就是说，对于所有的非空值<replaceable>A</replaceable>、<replaceable>B</replaceable>、<replaceable>C</replaceable>：

    <itemizedlist>
     <listitem>
      <para>
       <replaceable>A</replaceable> <literal>&lt;</literal> <replaceable>A</replaceable>为假（<firstterm>非自反律</firstterm>）
      </para>
     </listitem>
     <listitem>
      <para>
       如果<replaceable>A</replaceable> <literal>&lt;</literal> <replaceable>B</replaceable>以及<replaceable>B</replaceable> <literal>&lt;</literal> <replaceable>C</replaceable>，则有<replaceable>A</replaceable> <literal>&lt;</literal> <replaceable>C</replaceable>（<firstterm>传递律</firstterm>）
      </para>
     </listitem>
    </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=625d97bf4c90b0e852836895f7bae35e -->
  </listitem>

  <listitem>
<!-- pgdoc-cn_start sig_en=9ee0584d45d988fe8ad79e09c26ef122 sig_cn_org=None source=14.1 
   <para>
    Furthermore, the ordering is total; that is, for all non-null
    values <replaceable>A</replaceable>, <replaceable>B</replaceable>:

    <itemizedlist>
     <listitem>
      <para>
       exactly one of <replaceable>A</replaceable> <literal>&lt;</literal>
       <replaceable>B</replaceable>, <replaceable>A</replaceable>
       <literal>=</literal> <replaceable>B</replaceable>, and
       <replaceable>B</replaceable> <literal>&lt;</literal>
       <replaceable>A</replaceable> is true
       (<firstterm>trichotomy law</firstterm>)
      </para>
     </listitem>
    </itemizedlist>

    (The trichotomy law justifies the definition of the comparison support
    function, of course.)
   </para>
________________________________________________________-->
   <para>
    此外，该排序是完全的。也就是说，对于所有非空值<replaceable>A</replaceable>、<replaceable>B</replaceable>：

    <itemizedlist>
     <listitem>
      <para>
       <replaceable>A</replaceable> <literal>&lt;</literal> <replaceable>B</replaceable>、<replaceable>A</replaceable> <literal>=</literal> <replaceable>B</replaceable>和<replaceable>B</replaceable> <literal>&lt;</literal> <replaceable>A</replaceable>之中恰好有一个为真（<firstterm>三分律</firstterm>）
      </para>
     </listitem>
    </itemizedlist>

    （三分律无疑证明了比较支持函数定义的正确性。）
   </para>
<!-- pgdoc-cn_end sig_en=9ee0584d45d988fe8ad79e09c26ef122 -->
  </listitem>
 </itemizedlist>

<!-- pgdoc-cn_start sig_en=283d00248bcf8c4953df9a626497f66c sig_cn_org=None source=14.1 
 <para>
  The other three operators are defined in terms of <literal>=</literal>
  and <literal>&lt;</literal> in the obvious way, and must act consistently
  with them.
 </para>
________________________________________________________-->
 <para>
  其他三种操作符可以以显而易见的方式用<literal>=</literal>和<literal>&lt;</literal>来定义，并且必须和它们的行为保持一致。
 </para>
<!-- pgdoc-cn_end sig_en=283d00248bcf8c4953df9a626497f66c -->

<!-- pgdoc-cn_start sig_en=4f2383457815e28441e77e90221d004f sig_cn_org=None source=14.1 
 <para>
  For an operator family supporting multiple data types, the above laws must
  hold when <replaceable>A</replaceable>, <replaceable>B</replaceable>,
  <replaceable>C</replaceable> are taken from any data types in the family.
  The transitive laws are the trickiest to ensure, as in cross-type
  situations they represent statements that the behaviors of two or three
  different operators are consistent.
  As an example, it would not work to put <type>float8</type>
  and <type>numeric</type> into the same operator family, at least not with
  the current semantics that <type>numeric</type> values are converted
  to <type>float8</type> for comparison to a <type>float8</type>.  Because
  of the limited accuracy of <type>float8</type>, this means there are
  distinct <type>numeric</type> values that will compare equal to the
  same <type>float8</type> value, and thus the transitive law would fail.
 </para>
________________________________________________________-->
 <para>
  对于一个支持多种数据类型的操作符族来说，当<replaceable>A</replaceable>、<replaceable>B</replaceable>、<replaceable>C</replaceable>取自该族中任意数据类型时，上述定律都必须保持。传递律是最难以保证的，因为在跨类型的情况中，传递律说明两种或者三种不同的操作符的行为是一致的。举个例子，把<type>float8</type>和<type>numeric</type>放在同一个操作符族中是行不通的，至少在当前的语义（为了和一个<type>float8</type>比较，<type>numeric</type>值会被转换成<type>float8</type>）下不行。因为<type>float8</type>有限的精度，这意味着不同的<type>numeric</type>值将被认为等于同一个<type>float8</type>值，因此传递律将被破坏。
 </para>
<!-- pgdoc-cn_end sig_en=4f2383457815e28441e77e90221d004f -->

<!-- pgdoc-cn_start sig_en=ebebf88c50e239bd21b6d731ae7f45a6 sig_cn_org=None source=14.1 
 <para>
  Another requirement for a multiple-data-type family is that any implicit
  or binary-coercion casts that are defined between data types included in
  the operator family must not change the associated sort ordering.
 </para>
________________________________________________________-->
 <para>
  对于多数据类型操作符族的另一个要求是，其中包括的定义在数据类型之间的任何隐式或者二进制强制造型不能改变相关的排序顺序。
 </para>
<!-- pgdoc-cn_end sig_en=ebebf88c50e239bd21b6d731ae7f45a6 -->

<!-- pgdoc-cn_start sig_en=dcd38a0e225051b75b64620edfe14ac9 sig_cn_org=None source=14.1 
 <para>
  It should be fairly clear why a btree index requires these laws to hold
  within a single data type: without them there is no ordering to arrange
  the keys with.  Also, index searches using a comparison key of a
  different data type require comparisons to behave sanely across two
  data types.  The extensions to three or more data types within a family
  are not strictly required by the btree index mechanism itself, but the
  planner relies on them for optimization purposes.
 </para>
________________________________________________________-->
 <para>
  为何一个btree索引要求这些定律在单一数据类型中必须保持的原因应该相对比较清楚：没有这些定律就不存在用于安排键的顺序。此外，使用不同数据类型键的比较的索引搜索也要求比较操作在两种数据类型之间表现得稳定。btree索引机制本身并不严格要求在一个操作符族中扩展到三种或者更多种数据类型，但是规划器依赖于这种扩展来实现其优化的目的。
 </para>
<!-- pgdoc-cn_end sig_en=dcd38a0e225051b75b64620edfe14ac9 -->

</sect1>

<sect1 id="btree-support-funcs">
<!-- pgdoc-cn_start sig_en=41b235984593727b61d0481466af5373 sig_cn_org=None source=14.1 
 <title>B-Tree Support Functions</title>
________________________________________________________-->
 <title>B-树支持函数</title>
<!-- pgdoc-cn_end sig_en=41b235984593727b61d0481466af5373 -->

<!-- pgdoc-cn_start sig_en=e420556142bff2bdfdfabfc325cd66ed sig_cn_org=None source=14.1 
 <para>
  As shown in <xref linkend="xindex-btree-support-table"/>, btree defines
  one required and four optional support functions.  The five
  user-defined methods are:
 </para>
________________________________________________________-->
 <para>
  如<xref linkend="xindex-btree-support-table"/>中所示，btree定义了一种必需的和四种可选的支持函数。这五种用户定义的方法为：
 </para>
<!-- pgdoc-cn_end sig_en=e420556142bff2bdfdfabfc325cd66ed -->
 <variablelist>
  <varlistentry>
   <term><function>order</function></term>
   <listitem>
<!-- pgdoc-cn_start sig_en=fbf7c6911b5e2638612d27788da1246d sig_cn_org=None source=14.1 
    <para>
     For each combination of data types that a btree operator family
     provides comparison operators for, it must provide a comparison
     support function, registered in
     <structname>pg_amproc</structname> with support function number 1
     and
     <structfield>amproclefttype</structfield>/<structfield>amprocrighttype</structfield>
     equal to the left and right data types for the comparison (i.e.,
     the same data types that the matching operators are registered
     with in <structname>pg_amop</structname>).  The comparison
     function must take two non-null values
     <replaceable>A</replaceable> and <replaceable>B</replaceable> and
     return an <type>int32</type> value that is
     <literal>&lt;</literal> <literal>0</literal>,
     <literal>0</literal>, or <literal>&gt;</literal>
     <literal>0</literal> when <replaceable>A</replaceable>
     <literal>&lt;</literal> <replaceable>B</replaceable>,
     <replaceable>A</replaceable> <literal>=</literal>
     <replaceable>B</replaceable>, or <replaceable>A</replaceable>
     <literal>&gt;</literal> <replaceable>B</replaceable>,
     respectively.  A null result is disallowed: all values of the
     data type must be comparable.  See
     <filename>src/backend/access/nbtree/nbtcompare.c</filename> for
     examples.
    </para>
________________________________________________________-->
    <para>
     对于btree操作符族为其提供了比较操作符的每一种数据类型组合，操作符族必须提供一个比较支持函数，在<structname>pg_amproc</structname>中注册：支持函数编号为1，<structfield>amproclefttype</structfield>/<structfield>amprocrighttype</structfield>等于比较的左右数据类型（即匹配的操作符注册在<structname>pg_amop</structname>中的数据类型）。
     比较函数必须接收两个非空值<replaceable>A</replaceable>和<replaceable>B</replaceable>并且返回一个<type>int32</type>值，返回值在<replaceable>A</replaceable> <literal>&lt;</literal> <replaceable>B</replaceable>、<replaceable>A</replaceable> <literal>=</literal> <replaceable>B</replaceable>以及<replaceable>A</replaceable> <literal>&gt;</literal> <replaceable>B</replaceable>时分别为<literal>&lt;</literal> <literal>0</literal>、<literal>0</literal>和<literal>&gt;</literal> <literal>0</literal>。
     不允许空值结果：该数据类型的所有值必须是可比较的。
     例子请见<filename>src/backend/access/nbtree/nbtcompare.c</filename>。
    </para>
<!-- pgdoc-cn_end sig_en=fbf7c6911b5e2638612d27788da1246d -->

<!-- pgdoc-cn_start sig_en=b3218f1f85a650a793478766a9211048 sig_cn_org=None source=14.1 
    <para>
     If the compared values are of a collatable data type, the
     appropriate collation OID will be passed to the comparison
     support function, using the standard
     <function>PG_GET_COLLATION()</function> mechanism.
    </para>
________________________________________________________-->
    <para>
     如果被比较的值是一种可排序的数据类型，合适的排序规则OID将使用标准的PG_GET_COLLATION()机制被传递给比较支持函数。
    </para>
<!-- pgdoc-cn_end sig_en=b3218f1f85a650a793478766a9211048 -->
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><function>sortsupport</function></term>
   <listitem>
<!-- pgdoc-cn_start sig_en=7c65acaa7ed7bf2087f44033dc8280ec sig_cn_org=None source=14.1 
    <para>
     Optionally, a btree operator family may provide <firstterm>sort
      support</firstterm> function(s), registered under support
     function number 2.  These functions allow implementing
     comparisons for sorting purposes in a more efficient way than
     naively calling the comparison support function.  The APIs
     involved in this are defined in
     <filename>src/include/utils/sortsupport.h</filename>.
    </para>
________________________________________________________-->
    <para>
     可选地，btree操作符族可以提供<firstterm>排序支持</firstterm>函数，它们以支持函数编号2注册。
     这些函数允许以一种比单纯调用比较支持函数更加高效的方式实现排序比较。
     涉及的API在<filename>src/include/utils/sortsupport.h</filename>中定义。
    </para>
<!-- pgdoc-cn_end sig_en=7c65acaa7ed7bf2087f44033dc8280ec -->
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><function>in_range</function></term>
   <listitem>
<!-- pgdoc-cn_start sig_en=46ad3bb36b371d83580dcf44273320c3 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>in_range support functions</primary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>in_range support functions</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=46ad3bb36b371d83580dcf44273320c3 -->

<!-- pgdoc-cn_start sig_en=0c3003863f953c1b2f5e3ec8a5cbf8e7 sig_cn_org=None source=14.1 
    <indexterm>
     <primary>support functions</primary>
     <secondary>in_range</secondary>
    </indexterm>
________________________________________________________-->
    <indexterm>
     <primary>support functions</primary>
     <secondary>in_range</secondary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=0c3003863f953c1b2f5e3ec8a5cbf8e7 -->
<!-- pgdoc-cn_start sig_en=fceec4fe40fc2f0bb551ba63bfffcc71 sig_cn_org=None source=14.1 
    <para>
     Optionally, a btree operator family may provide
     <firstterm>in_range</firstterm> support function(s), registered
     under support function number 3.  These are not used during btree
     index operations; rather, they extend the semantics of the
     operator family so that it can support window clauses containing
     the <literal>RANGE</literal> <replaceable>offset</replaceable>
     <literal>PRECEDING</literal> and <literal>RANGE</literal>
     <replaceable>offset</replaceable> <literal>FOLLOWING</literal>
     frame bound types (see <xref
      linkend="syntax-window-functions"/>).  Fundamentally, the extra
     information provided is how to add or subtract an
     <replaceable>offset</replaceable> value in a way that is
     compatible with the family's data ordering.
    </para>
________________________________________________________-->
    <para>
     可选地，btree操作符族可以提供<firstterm>in_range</firstterm>支持函数，它们以支持函数编号3注册。
     在btree索引操作期间不会用到这些函数，它们扩展了操作符族的语义，这样就能支持包含<literal>RANGE</literal> <replaceable>offset</replaceable> <literal>PRECEDING</literal>以及<literal>RANGE</literal> <replaceable>offset</replaceable> <literal>FOLLOWING</literal>窗口帧界类型（见<xref linkend="syntax-window-functions"/>）的窗口子句。
     归根到底，这些函数所提供的额外信息是如何以一种与该操作符族的数据排序相兼容的方式加上或者减去一个<replaceable>offset</replaceable>值。
    </para>
<!-- pgdoc-cn_end sig_en=fceec4fe40fc2f0bb551ba63bfffcc71 -->

<!-- pgdoc-cn_start sig_en=aaf73db73d63d1626e1d9d89dc56bbdc sig_cn_org=None source=14.1 
    <para>
     An <function>in_range</function> function must have the signature
<synopsis>
in_range(<replaceable>val</replaceable> type1, <replaceable>base</replaceable> type1, <replaceable>offset</replaceable> type2, <replaceable>sub</replaceable> bool, <replaceable>less</replaceable> bool)
returns bool
</synopsis>
     <replaceable>val</replaceable> and
     <replaceable>base</replaceable> must be of the same type, which
     is one of the types supported by the operator family (i.e., a
     type for which it provides an ordering).  However,
     <replaceable>offset</replaceable> could be of a different type,
     which might be one otherwise unsupported by the family.  An
     example is that the built-in <literal>time_ops</literal> family
     provides an <function>in_range</function> function that has
     <replaceable>offset</replaceable> of type <type>interval</type>.
     A family can provide <function>in_range</function> functions for
     any of its supported types and one or more
     <replaceable>offset</replaceable> types.  Each
     <function>in_range</function> function should be entered in
     <structname>pg_amproc</structname> with
     <structfield>amproclefttype</structfield> equal to
     <type>type1</type> and <structfield>amprocrighttype</structfield>
     equal to <type>type2</type>.
    </para>
________________________________________________________-->
    <para>
     An <function>in_range</function> 函数必须有签名
<synopsis>
in_range(<replaceable>val</replaceable> type1, <replaceable>base</replaceable> type1, <replaceable>offset</replaceable> type2, <replaceable>sub</replaceable> bool, <replaceable>less</replaceable> bool)
returns bool
</synopsis>
     <replaceable>val</replaceable>和<replaceable>base</replaceable>必须是同一种类型，该类型也是操作符族所支持的类型之一（即它提供排序的一种类型）。
     不过，<replaceable>offset</replaceable>可以是一种不同的类型，该类型有可能不被该操作符族所支持。例如内建的<literal>time_ops</literal>族提供了一个<function>in_range</function>函数，其<replaceable>offset</replaceable>是类型<type>interval</type>。
     一个操作符族可以为其所支持的任意类型提供<function>in_range</function>函数以及一个或者更多种<replaceable>offset</replaceable>类型。
     每一个<function>in_range</function>函数在进入到<structname>pg_amproc</structname>时，需要有<structfield>amproclefttype</structfield>等于<type>type1</type>以及<structfield>amprocrighttype</structfield>等于<type>type2</type>。
    </para>
<!-- pgdoc-cn_end sig_en=aaf73db73d63d1626e1d9d89dc56bbdc -->

<!-- pgdoc-cn_start sig_en=35c8c9af3a3c27a4927a0a8d37e10379 sig_cn_org=None source=14.1 
    <para>
     The essential semantics of an <function>in_range</function>
     function depend on the two Boolean flag parameters.  It should
     add or subtract <replaceable>base</replaceable> and
     <replaceable>offset</replaceable>, then compare
     <replaceable>val</replaceable> to the result, as follows:
     <itemizedlist>
      <listitem>
       <para>
        if <literal>!</literal><replaceable>sub</replaceable> and
        <literal>!</literal><replaceable>less</replaceable>, return
        <replaceable>val</replaceable> <literal>&gt;=</literal>
        (<replaceable>base</replaceable> <literal>+</literal>
        <replaceable>offset</replaceable>)
       </para>
      </listitem>
      <listitem>
       <para>
        if <literal>!</literal><replaceable>sub</replaceable> and
        <replaceable>less</replaceable>, return
        <replaceable>val</replaceable> <literal>&lt;=</literal>
        (<replaceable>base</replaceable> <literal>+</literal>
        <replaceable>offset</replaceable>)
       </para>
      </listitem>
      <listitem>
       <para>
        if <replaceable>sub</replaceable> and
        <literal>!</literal><replaceable>less</replaceable>, return
        <replaceable>val</replaceable> <literal>&gt;=</literal>
        (<replaceable>base</replaceable> <literal>-</literal>
        <replaceable>offset</replaceable>)
       </para>
      </listitem>
      <listitem>
       <para>
        if <replaceable>sub</replaceable> and
        <replaceable>less</replaceable>, return
        <replaceable>val</replaceable> <literal>&lt;=</literal>
        (<replaceable>base</replaceable> <literal>-</literal>
        <replaceable>offset</replaceable>)
       </para>
      </listitem>
     </itemizedlist>
     Before doing so, the function should check the sign of
     <replaceable>offset</replaceable>: if it is less than zero, raise
     error
     <literal>ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE</literal>
     (22013) with error text like <quote>invalid preceding or
      following size in window function</quote>.  (This is required by
     the SQL standard, although nonstandard operator families might
     perhaps choose to ignore this restriction, since there seems to
     be little semantic necessity for it.) This requirement is
     delegated to the <function>in_range</function> function so that
     the core code needn't understand what <quote>less than
      zero</quote> means for a particular data type.
    </para>
________________________________________________________-->
    <para>
     <function>in_range</function>函数的本质语义取决于两个布尔标志参数。
	 它应该将<replaceable>base</replaceable>和<replaceable>offset</replaceable>相加或者相减，然后用<replaceable>val</replaceable>与其结果比较：
     <itemizedlist>
      <listitem>
       <para>
        如果<literal>!</literal><replaceable>sub</replaceable>并且<literal>!</literal><replaceable>less</replaceable>，则返回<replaceable>val</replaceable> <literal>&gt;=</literal> (<replaceable>base</replaceable> <literal>+</literal> <replaceable>offset</replaceable>)
       </para>
      </listitem>
      <listitem>
       <para>
        如果<literal>!</literal><replaceable>sub</replaceable>并且<replaceable>less</replaceable>，则返回<replaceable>val</replaceable> <literal>&lt;=</literal> (<replaceable>base</replaceable> <literal>+</literal> <replaceable>offset</replaceable>)
       </para>
      </listitem>
      <listitem>
       <para>
        如果<replaceable>sub</replaceable>并且<literal>!</literal><replaceable>less</replaceable>，则返回<replaceable>val</replaceable> <literal>&gt;=</literal> (<replaceable>base</replaceable> <literal>-</literal> <replaceable>offset</replaceable>)
       </para>
      </listitem>
      <listitem>
       <para>
        如果<replaceable>sub</replaceable>并且<replaceable>less</replaceable>，则返回<replaceable>val</replaceable> <literal>&lt;=</literal> (<replaceable>base</replaceable> <literal>-</literal> <replaceable>offset</replaceable>)
       </para>
      </listitem>
     </itemizedlist>
     在这样做之前，该函数应该检查<replaceable>offset</replaceable>的符号：如果它小于零，则抛出错误<literal>ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE</literal> (22013)外加<quote>invalid preceding or following size in window function</quote>这样的错误文本（这是SQL标准所要求的，不过非标准操作符族可能会选择忽视这一限制，因为似乎其语义必要性很小）。
     这种要求被委托给了<function>in_range</function>函数，这样核心代码不需要理解对一种特定数据类型<quote>less than zero</quote>表示什么。
    </para>
<!-- pgdoc-cn_end sig_en=35c8c9af3a3c27a4927a0a8d37e10379 -->

<!-- pgdoc-cn_start sig_en=77e3c4bfc8df15084a0d2ea09e7cab10 sig_cn_org=None source=14.1 
    <para>
     An additional expectation is that <function>in_range</function>
     functions should, if practical, avoid throwing an error if
     <replaceable>base</replaceable> <literal>+</literal>
     <replaceable>offset</replaceable> or
     <replaceable>base</replaceable> <literal>-</literal>
     <replaceable>offset</replaceable> would overflow.  The correct
     comparison result can be determined even if that value would be
     out of the data type's range.  Note that if the data type
     includes concepts such as <quote>infinity</quote> or
     <quote>NaN</quote>, extra care may be needed to ensure that
     <function>in_range</function>'s results agree with the normal
     sort order of the operator family.
    </para>
________________________________________________________-->
    <para>
     一个额外的期望是，如果可行，<function>in_range</function>函数应当在<replaceable>base</replaceable> <literal>+</literal> <replaceable>offset</replaceable>或者<replaceable>base</replaceable> <literal>-</literal> <replaceable>offset</replaceable>溢出时避免抛出错误。
     即便值超过了该数据类型的范围，也可以确定正确的比较结果。
     注意，如果数据类型包括诸如<quote>infinity</quote>或者<quote>NaN</quote>之类的概念，就需要额外的注意确保<function>in_range</function>的结果符合该操作符族的正常排序顺序。
    </para>
<!-- pgdoc-cn_end sig_en=77e3c4bfc8df15084a0d2ea09e7cab10 -->

<!-- pgdoc-cn_start sig_en=0e72299682033f607a7a99bbe6c1274d sig_cn_org=None source=14.1 
    <para>
     The results of the <function>in_range</function> function must be
     consistent with the sort ordering imposed by the operator family.
     To be precise, given any fixed values of
     <replaceable>offset</replaceable> and
     <replaceable>sub</replaceable>, then:
     <itemizedlist>
      <listitem>
       <para>
        If <function>in_range</function> with
        <replaceable>less</replaceable> = true is true for some
        <replaceable>val1</replaceable> and
        <replaceable>base</replaceable>, it must be true for every
        <replaceable>val2</replaceable> <literal>&lt;=</literal>
        <replaceable>val1</replaceable> with the same
        <replaceable>base</replaceable>.
       </para>
      </listitem>
      <listitem>
       <para>
        If <function>in_range</function> with
        <replaceable>less</replaceable> = true is false for some
        <replaceable>val1</replaceable> and
        <replaceable>base</replaceable>, it must be false for every
        <replaceable>val2</replaceable> <literal>&gt;=</literal>
        <replaceable>val1</replaceable> with the same
        <replaceable>base</replaceable>.
       </para>
      </listitem>
      <listitem>
       <para>
        If <function>in_range</function> with
        <replaceable>less</replaceable> = true is true for some
        <replaceable>val</replaceable> and
        <replaceable>base1</replaceable>, it must be true for every
        <replaceable>base2</replaceable> <literal>&gt;=</literal>
        <replaceable>base1</replaceable> with the same
        <replaceable>val</replaceable>.
       </para>
      </listitem>
      <listitem>
       <para>
        If <function>in_range</function> with
        <replaceable>less</replaceable> = true is false for some
        <replaceable>val</replaceable> and
        <replaceable>base1</replaceable>, it must be false for every
        <replaceable>base2</replaceable> <literal>&lt;=</literal>
        <replaceable>base1</replaceable> with the same
        <replaceable>val</replaceable>.
       </para>
      </listitem>
     </itemizedlist>
     Analogous statements with inverted conditions hold when
     <replaceable>less</replaceable> = false.
    </para>
________________________________________________________-->
    <para>
     <function>in_range</function>函数的结果必须与操作符族施加的排序顺序保持一致。
     准确的来说，给定任意固定的<replaceable>offset</replaceable>值以及<replaceable>sub</replaceable>值，那么：
     <itemizedlist>
      <listitem>
       <para>
        如果带有<replaceable>less</replaceable> = true的<function>in_range</function>对某个<replaceable>val1</replaceable>和<replaceable>base</replaceable>为真，则它必须对每一个有相同<replaceable>base</replaceable>的<replaceable>val2</replaceable> <literal>&lt;=</literal> <replaceable>val1</replaceable>为真。
       </para>
      </listitem>
      <listitem>
       <para>
        如果带有<replaceable>less</replaceable> = true的<function>in_range</function>对某个<replaceable>val1</replaceable>和<replaceable>base</replaceable>为假，则它必须对每一个有相同<replaceable>base</replaceable>的<replaceable>val2</replaceable> <literal>&gt;=</literal> <replaceable>val1</replaceable>为假。
       </para>
      </listitem>
      <listitem>
       <para>
        如果带有<replaceable>less</replaceable> = true的<function>in_range</function>对于某些<replaceable>val</replaceable>和<replaceable>base1</replaceable>为真,那么它对于每一个有相同<replaceable>val</replaceable>的<replaceable>base2</replaceable> <literal>&gt;=</literal> <replaceable>base1</replaceable>也必须为真。
       </para>
      </listitem>
      <listitem>
       <para>
        如果带有<replaceable>less</replaceable> = true的<function>in_range</function>对于某些<replaceable>val</replaceable>和<replaceable>base1</replaceable>为假, name它对于每一个有相同<replaceable>val</replaceable>的<replaceable>base2</replaceable> <literal>&lt;=</literal> <replaceable>base1</replaceable>也必须为假。
       </para>
      </listitem>
     </itemizedlist>
     当<replaceable>less</replaceable> = false时，类似的具有相逆条件的语句成立。
    </para>
<!-- pgdoc-cn_end sig_en=0e72299682033f607a7a99bbe6c1274d -->

<!-- pgdoc-cn_start sig_en=db17271c1cc6afa9b5aaece3924bdea1 sig_cn_org=None source=14.1 
    <para>
     If the type being ordered (<type>type1</type>) is collatable, the
     appropriate collation OID will be passed to the
     <function>in_range</function> function, using the standard
     PG_GET_COLLATION() mechanism.
    </para>
________________________________________________________-->
    <para>
     如果被排序的类型（<type>type1</type>）是可排序的，合适的排序规则OID将使用标准的PG_GET_COLLATION()机制被传递给<function>in_range</function>函数。
    </para>
<!-- pgdoc-cn_end sig_en=db17271c1cc6afa9b5aaece3924bdea1 -->

<!-- pgdoc-cn_start sig_en=f28deec02246b449615eae8912d77f99 sig_cn_org=None source=14.1 
    <para>
     <function>in_range</function> functions need not handle NULL
     inputs, and typically will be marked strict.
    </para>
________________________________________________________-->
    <para>
     <function>in_range</function>函数不需要处理NULL输入，并且通常将被标记为strict。
    </para>
<!-- pgdoc-cn_end sig_en=f28deec02246b449615eae8912d77f99 -->
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><function>equalimage</function></term>
   <listitem>
<!-- pgdoc-cn_start sig_en=fe3bb0189b81697ff75b114599cd3949 sig_cn_org=None source=14.1 
    <para>
     Optionally, a btree operator family may provide
     <function>equalimage</function> (<quote>equality implies image
      equality</quote>) support functions, registered under support
     function number 4.  These functions allow the core code to
     determine when it is safe to apply the btree deduplication
     optimization.  Currently, <function>equalimage</function>
     functions are only called when building or rebuilding an index.
    </para>
________________________________________________________-->
    <para>
     可选地，btree 操作符系列可以提供<function>equalimage</function>（<quote>equality implies image equality</quote>）支持功能，注册在支持函数 4 下面。
     这些函数允许核心代码确定何时可以安全地应用 btree 重复数据消除进行优化。
     目前，<function>equalimage</function>函数仅在生成或重建索引时调用。
    </para>
<!-- pgdoc-cn_end sig_en=fe3bb0189b81697ff75b114599cd3949 -->
<!-- pgdoc-cn_start sig_en=e465e6d3f9c85c1be203b039aecc390d sig_cn_org=None source=14.1 
    <para>
     An <function>equalimage</function> function must have the
     signature
<synopsis>
equalimage(<replaceable>opcintype</replaceable> <type>oid</type>) returns bool
</synopsis>
     The return value is static information about an operator class
     and collation.  Returning <literal>true</literal> indicates that
     the <function>order</function> function for the operator class is
     guaranteed to only return <literal>0</literal> (<quote>arguments
      are equal</quote>) when its <replaceable>A</replaceable> and
     <replaceable>B</replaceable> arguments are also interchangeable
     without any loss of semantic information.  Not registering an
     <function>equalimage</function> function or returning
     <literal>false</literal> indicates that this condition cannot be
     assumed to hold.
    </para>
________________________________________________________-->
    <para>
     一个 <function>equalimage</function> 函数必须包含签名
<synopsis>
equalimage(<replaceable>opcintype</replaceable> <type>oid</type>) returns bool
</synopsis>
     返回值是有关运算符类和排序规则的静态信息。 
     返回<literal>true</literal>表示运算符类的 <function>order</function> 函数保证仅返回<literal>0</literal> (<quote>arguments are equal</quote>) 时，<replaceable>A</replaceable>和 <replaceable>B</replaceable>参数也可以互换，而不会丢失任何语义信息。 
     不注册<function>equalimage</function>函数或返回<literal>false</literal>表示不能假定此条件成立。
    </para>
<!-- pgdoc-cn_end sig_en=e465e6d3f9c85c1be203b039aecc390d -->
<!-- pgdoc-cn_start sig_en=64fafcf3de1d7ba36c0d7b45f776f35a sig_cn_org=None source=14.1 
    <para>
     The <replaceable>opcintype</replaceable> argument is the
     <literal><structname>pg_type</structname>.oid</literal> of the
     data type that the operator class indexes.  This is a convenience
     that allows reuse of the same underlying
     <function>equalimage</function> function across operator classes.
     If <replaceable>opcintype</replaceable> is a collatable data
     type, the appropriate collation OID will be passed to the
     <function>equalimage</function> function, using the standard
     <function>PG_GET_COLLATION()</function> mechanism.
    </para>
________________________________________________________-->
    <para>
     <replaceable>opcintype</replaceable>参数是操作符类索引的数据类型的<literal><structname>pg_type</structname>.oid</literal>。 
     这提供一种便利，允许在操作符类之间重用相同的底层<function>equalimage</function>函数。
     如果<replaceable>opcintype</replaceable>是可排序数据类型，则相应的排序规则 OID 将传递给 <function>equalimage</function> 函数，使用标准的 <function>PG_GET_COLLATION()</function> 机制。
    </para>
<!-- pgdoc-cn_end sig_en=64fafcf3de1d7ba36c0d7b45f776f35a -->
<!-- pgdoc-cn_start sig_en=2a9b878c5273298b5f2f87634432ae21 sig_cn_org=None source=14.1 
    <para>
     As far as the operator class is concerned, returning
     <literal>true</literal> indicates that deduplication is safe (or
     safe for the collation whose OID was passed to its
     <function>equalimage</function> function).  However, the core
     code will only deem deduplication safe for an index when
     <emphasis>every</emphasis> indexed column uses an operator class
     that registers an <function>equalimage</function> function, and
     each function actually returns <literal>true</literal> when
     called.
    </para>
________________________________________________________-->
    <para>
     就操作符类而言，返回<literal>true</literal>意味着重复数据删除是安全的（或安全排序规则，其OID传递给它的<function>equalimage</function>函数）。
     但是，核心代码只有在<emphasis>every</emphasis> 索引列使用注册了 <function>equalimage</function> 函数的操作符类时，并且每个函数在调用时实际返回 <literal>true</literal> 时，才会认为重复数据删除是安全的。
    </para>
<!-- pgdoc-cn_end sig_en=2a9b878c5273298b5f2f87634432ae21 -->
<!-- pgdoc-cn_start sig_en=b087269ea05d58f68cfed6093b58463b sig_cn_org=None source=14.1 
    <para>
     Image equality is <emphasis>almost</emphasis> the same condition
     as simple bitwise equality.  There is one subtle difference: When
     indexing a varlena data type, the on-disk representation of two
     image equal datums may not be bitwise equal due to inconsistent
     application of <acronym>TOAST</acronym> compression on input.
     Formally, when an operator class's
     <function>equalimage</function> function returns
     <literal>true</literal>, it is safe to assume that the
     <literal>datum_image_eq()</literal> C function will always agree
     with the operator class's <function>order</function> function
     (provided that the same collation OID is passed to both the
     <function>equalimage</function> and <function>order</function>
     functions).
    </para>
________________________________________________________-->
    <para>
     图像相等<emphasis>几乎</emphasis>与简单位元(simple bitwise)相等的条件相同。
     有一个细微的区别：在索引 varlena 数据类型时，由于输入上<acronym>TOAST</acronym>压缩应用不一致，两个图像相等基准的磁盘表示可能不是位相等的。
     从形式上看，当操作符类的 <function>equalimage</function>函数返回 <literal>true</literal> 时，可以安全的地假定 <literal>datum_image_eq()</literal> C 函数将始终与操作符类的 <function>order</function> 函数一致（前提是将同一个排序规则 OID 传递给 <function>equalimage</function> 和 <function>order</function> 函数）。
    </para>
<!-- pgdoc-cn_end sig_en=b087269ea05d58f68cfed6093b58463b -->
<!-- pgdoc-cn_start sig_en=939b5fc9c278162970a6a3daebef3036 sig_cn_org=None source=14.1 
    <para>
     The core code is fundamentally unable to deduce anything about
     the <quote>equality implies image equality</quote> status of an
     operator class within a multiple-data-type family based on
     details from other operator classes in the same family.  Also, it
     is not sensible for an operator family to register a cross-type
     <function>equalimage</function> function, and attempting to do so
     will result in an error.  This is because <quote>equality implies
      image equality</quote> status does not just depend on
     sorting/equality semantics, which are more or less defined at the
     operator family level.  In general, the semantics that one
     particular data type implements must be considered separately.
    </para>
________________________________________________________-->
    <para>
     核心代码从根本上无法推断出任何关于基于同一系列中其他运算符类的详细信息的具有多数据类型系列中的操作符类的<quote>equality implies image equality</quote>状态。 
     此外，操作符系列注册跨类型 <function>equalimage</function>函数是不明智的，尝试这样做将导致错误。
     这是因为<quote>equality implies image equality</quote>状态不仅仅取决于排序/相等语义，这些语义或多或少在操作符系列级别定义。 
     通常，特定数据类型实现的语义必须单独考虑。
    </para>
<!-- pgdoc-cn_end sig_en=939b5fc9c278162970a6a3daebef3036 -->
<!-- pgdoc-cn_start sig_en=81b546e382f66ed06df4f00fac63196e sig_cn_org=None source=14.1 
    <para>
     The convention followed by the operator classes included with the
     core <productname>PostgreSQL</productname> distribution is to
     register a stock, generic <function>equalimage</function>
     function.  Most operator classes register
     <function>btequalimage()</function>, which indicates that
     deduplication is safe unconditionally.  Operator classes for
     collatable data types such as <type>text</type> register
     <function>btvarstrequalimage()</function>, which indicates that
     deduplication is safe with deterministic collations.  Best
     practice for third-party extensions is to register their own
     custom function to retain control.
    </para>
________________________________________________________-->
    <para>
     核心 <productname>PostgreSQL</productname> 分发中包含的操作符类所遵循的约定是注册股票(register a stock)，通用<function>equalimage</function>函数。
     大多数操作符类注册<function>btequalimage()</function>，这表明重复数据删除是安全的。 
     可排序数据类型的操作符类（如 <type>text</type>注册<function>btvarstrequalimage()</function>，这表明在确定性排序规则下应用重复数据删除是安全的。 
     第三方扩展的最佳实践是注册自己的自定义函数以保持控制。
    </para>
<!-- pgdoc-cn_end sig_en=81b546e382f66ed06df4f00fac63196e -->
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><function>options</function></term>
   <listitem>
<!-- pgdoc-cn_start sig_en=dca458e5813475d04951213310342f41 sig_cn_org=None source=14.1 
    <para>
     Optionally, a B-tree operator family may provide
     <function>options</function> (<quote>operator class specific
     options</quote>) support functions, registered under support
     function number 5.  These functions define a set of user-visible
     parameters that control operator class behavior.
    </para>
________________________________________________________-->
    <para>
	 可选地，B 树操作符系列可以提供<function>options</function>（<quote>操作符类指定选项</quote>）支持功能，注册在支持函数 5 下面。
	 这些函数定义一组用户可见的参数，用于控制操作符类行为。
    </para>
<!-- pgdoc-cn_end sig_en=dca458e5813475d04951213310342f41 -->
<!-- pgdoc-cn_start sig_en=b797ffdfa315f3986e8d30c99e657328 sig_cn_org=None source=14.1 
    <para>
     An <function>options</function> support function must have the
     signature
<synopsis>
options(<replaceable>relopts</replaceable> <type>local_relopts *</type>) returns void
</synopsis>
     The function is passed a pointer to a <structname>local_relopts</structname>
     struct, which needs to be filled with a set of operator class
     specific options.  The options can be accessed from other support
     functions using the <literal>PG_HAS_OPCLASS_OPTIONS()</literal> and
     <literal>PG_GET_OPCLASS_OPTIONS()</literal> macros.
    </para>
________________________________________________________-->
    <para>
      <function>options</function> 支持函数必须具有签名
<synopsis>
options(<replaceable>relopts</replaceable> <type>local_relopts *</type>) returns void
</synopsis>
     函数传递一个指向<structname>local_relopts</structname>结构的指针，需要用一组操作符类特定的选项来填充。
	 这些选项可以通过<literal>PG_HAS_OPCLASS_OPTIONS()</literal> 和 <literal>PG_GET_OPCLASS_OPTIONS()</literal> 宏，从其他支持的函数进行访问。
    </para>
<!-- pgdoc-cn_end sig_en=b797ffdfa315f3986e8d30c99e657328 -->
<!-- pgdoc-cn_start sig_en=9f69b5e3438c945636f2244abdbf4e75 sig_cn_org=None source=14.1 
    <para>
     Currently, no B-Tree operator class has an <function>options</function>
     support function.  B-tree doesn't allow flexible representation of keys
     like GiST, SP-GiST, GIN and BRIN do.  So, <function>options</function>
     probably doesn't have much application in the current B-tree index
     access method.  Nevertheless, this support function was added to B-tree
     for uniformity, and will probably find uses during further
     evolution of B-tree in <productname>PostgreSQL</productname>.
    </para>
________________________________________________________-->
    <para>
     目前，没有 B-Tree 操作符类具有 <function>options</function>支持功能。 
     B-tree不允许灵活表示键， 例如 GiST, SP-GiST, GIN 和 BRIN。 
     因此，<function>options</function>在当前的B-tree索引访问方法中可能没有太多的应用。 
     不过，此支持函数已添加到 B-tree中以保持一致性，并且可能会在<productname>PostgreSQL</productname>中B-tree的进一步演进中找到更多应用。
    </para>
<!-- pgdoc-cn_end sig_en=9f69b5e3438c945636f2244abdbf4e75 -->
   </listitem>
  </varlistentry>
 </variablelist>

</sect1>

<sect1 id="btree-implementation">
<!-- pgdoc-cn_start sig_en=05afc0ba076ec1f3b376592bf28077e0 sig_cn_org=None source=14.1 
 <title>Implementation</title>
________________________________________________________-->
 <title>实现</title>
<!-- pgdoc-cn_end sig_en=05afc0ba076ec1f3b376592bf28077e0 -->

<!-- pgdoc-cn_start sig_en=42de90581e655c0c5efda8c28e558f50 sig_cn_org=None source=14.1 
 <para>
  This section covers B-Tree index implementation details that may be
  of use to advanced users.  See
  <filename>src/backend/access/nbtree/README</filename> in the source
  distribution for a much more detailed, internals-focused description
  of the B-Tree implementation.
 </para>
________________________________________________________-->
 <para>
  本节介绍 B-Tree 索引实现详细信息，这些对高级用户可能有用。
  更多信息请参见在源分发中的<filename>src/backend/access/nbtree/README</filename>文件，内部聚焦的 B-Tree实现描述。
 </para>
<!-- pgdoc-cn_end sig_en=42de90581e655c0c5efda8c28e558f50 -->
 <sect2 id="btree-structure">
<!-- pgdoc-cn_start sig_en=96fa6afc483deaf2eb5871d2a5f3b590 sig_cn_org=None source=14.1 
  <title>B-Tree Structure</title>
________________________________________________________-->
  <title>B-Tree 结构</title>
<!-- pgdoc-cn_end sig_en=96fa6afc483deaf2eb5871d2a5f3b590 -->
<!-- pgdoc-cn_start sig_en=22b28079372ad46702ed09d7c8b5c66b sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> B-Tree indexes are
   multi-level tree structures, where each level of the tree can be
   used as a doubly-linked list of pages.  A single metapage is stored
   in a fixed position at the start of the first segment file of the
   index.  All other pages are either leaf pages or internal pages.
   Leaf pages are the pages on the lowest level of the tree.  All
   other levels consist of internal pages.  Each leaf page contains
   tuples that point to table rows.  Each internal page contains
   tuples that point to the next level down in the tree.  Typically,
   over 99% of all pages are leaf pages.  Both internal pages and leaf
   pages use the standard page format described in <xref
    linkend="storage-page-layout"/>.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname> B-Tree 索引是多级树结构，其中树的每个级别都可以用作双链接的页列表。
   单个元页存储在索引的第一个段文件开始时的固定位置。所有其他页都是叶页或内部页。叶页是在树的最低层上的页。 
   所有其他层级由内部页组成。每个叶页都包含指向表行的元组。每个内部页都包含指向树中下一级别的元组。 
   通常，超过 99% 的页面是叶页。 内部页和叶页都使用 <xref linkend="storage-page-layout"/>中描述的标准页格式。
  </para>
<!-- pgdoc-cn_end sig_en=22b28079372ad46702ed09d7c8b5c66b -->
<!-- pgdoc-cn_start sig_en=f6680947d784ca3900ffabbfd8a8b7de sig_cn_org=None source=14.1 
  <para>
   New leaf pages are added to a B-Tree index when an existing leaf
   page cannot fit an incoming tuple.  A <firstterm>page
    split</firstterm> operation makes room for items that originally
   belonged on the overflowing page by moving a portion of the items
   to a new page.  Page splits must also insert a new
   <firstterm>downlink</firstterm> to the new page in the parent page,
   which may cause the parent to split in turn.  Page splits
   <quote>cascade upwards</quote> in a recursive fashion.  When the
   root page finally cannot fit a new downlink, a <firstterm>root page
    split</firstterm> operation takes place.  This adds a new level to
   the tree structure by creating a new root page that is one level
   above the original root page.
  </para>
________________________________________________________-->
  <para>
   当已有叶页不能适应传入元组时，新叶页将添加到B-Tree索引中。 
   <firstterm>page split</firstterm>操作通过将部分项目移动到新页面为最初属于溢出页上的项目提供空间。
   页拆分还必须插入新的<firstterm>downlink</firstterm>到父页中的新页，这可能会导致父页依次拆分。 
   页拆分<quote>cascade upwards</quote>以递归的方式。 
   当根页最终无法适合新的下行链接时，发生<firstterm>root page split</firstterm>操作。
   通过创建比原始根页高一个级别的新根页，为树结构添加新级别。
  </para>
<!-- pgdoc-cn_end sig_en=f6680947d784ca3900ffabbfd8a8b7de -->
 </sect2>

 <sect2 id="btree-deletion">
<!-- pgdoc-cn_start sig_en=05f60a7e4cc9d01c7731734990020c7a sig_cn_org=None source=14.1 
  <title>Bottom-up Index Deletion</title>
________________________________________________________-->
  <title>Bottom-up 索引删除</title>
<!-- pgdoc-cn_end sig_en=05f60a7e4cc9d01c7731734990020c7a -->
<!-- pgdoc-cn_start sig_en=331a557106942683050b88edc5e0526b sig_cn_org=3d35d99721a7492c043ec91248747a48 source=15.7 
  <para>
   B-Tree indexes are not directly aware that under MVCC, there might
   be multiple extant versions of the same logical table row; to an
   index, each tuple is an independent object that needs its own index
   entry.  <quote>Version churn</quote> tuples may sometimes
   accumulate and adversely affect query latency and throughput.  This
   typically occurs with <command>UPDATE</command>-heavy workloads
   where most individual updates cannot apply the
   <link linkend="storage-hot"><acronym>HOT</acronym> optimization.</link>
   Changing the value of only
   one column covered by one index during an <command>UPDATE</command>
   <emphasis>always</emphasis> necessitates a new set of index tuples
   &mdash; one for <emphasis>each and every</emphasis> index on the
   table.  Note in particular that this includes indexes that were not
   <quote>logically modified</quote> by the <command>UPDATE</command>.
   All indexes will need a successor physical index tuple that points
   to the latest version in the table.  Each new tuple within each
   index will generally need to coexist with the original
   <quote>updated</quote> tuple for a short period of time (typically
   until shortly after the <command>UPDATE</command> transaction
   commits).
  </para>
________________________________________________________-->
  <para>
   B-Tree索引并不直接意识到在MVCC下，同一个逻辑表行可能存在多个现存版本；对于索引，每个元组都是一个独立的对象，需要自己的索引条目。<quote>版本变动</quote>的元组有时会累积并对查询延迟和吞吐量产生不利影响。这通常发生在以<command>UPDATE</command>为主的工作负载中，其中大多数单个更新无法应用<link linkend="storage-hot"><acronym>HOT</acronym>优化。</link>在<command>UPDATE</command>期间仅更改一个索引覆盖的列的值<emphasis>总是</emphasis>需要一组新的索引元组 &mdash; 对于表上的<emphasis>每一个</emphasis>索引都需要一个。特别注意，这包括那些并未被<command>UPDATE</command><quote>逻辑修改</quote>的索引。所有索引都需要一个指向表中最新版本的后继物理索引元组。每个索引中的新元组通常需要与原始<quote>更新</quote>元组共存一段时间（通常直到<command>UPDATE</command>事务提交后不久）。
</para>
<!-- pgdoc-cn_end sig_en=331a557106942683050b88edc5e0526b -->
<!-- pgdoc-cn_start sig_en=4a56c46921a901562b0969620afc70ba sig_cn_org=None source=14.1 
  <para>
   B-Tree indexes incrementally delete version churn index tuples by
   performing <firstterm>bottom-up index deletion</firstterm> passes.
   Each deletion pass is triggered in reaction to an anticipated
   <quote>version churn page split</quote>.  This only happens with
   indexes that are not logically modified by
   <command>UPDATE</command> statements, where concentrated build up
   of obsolete versions in particular pages would occur otherwise.  A
   page split will usually be avoided, though it's possible that
   certain implementation-level heuristics will fail to identify and
   delete even one garbage index tuple (in which case a page split or
   deduplication pass resolves the issue of an incoming new tuple not
   fitting on a leaf page).  The worst-case number of versions that
   any index scan must traverse (for any single logical row) is an
   important contributor to overall system responsiveness and
   throughput.  A bottom-up index deletion pass targets suspected
   garbage tuples in a single leaf page based on
   <emphasis>qualitative</emphasis> distinctions involving logical
   rows and versions.  This contrasts with the <quote>top-down</quote>
   index cleanup performed by autovacuum workers, which is triggered
   when certain <emphasis>quantitative</emphasis> table-level
   thresholds are exceeded (see <xref linkend="autovacuum"/>).
  </para>
________________________________________________________-->
  <para>
   B-Tree索引通过执行<firstterm>bottom-up index deletion</firstterm>传递，增量地删除版本混杂索引元组。
   每个删除传递都是在预期的<quote>version churn page split</quote>反应时触发的。
   这只发生在没有被<command>UPDATE</command>语句逻辑修改的索引上，否则将会出现集中生成特定页面中的过时版本。
   通常会避免页分割，尽管某些实现级别的启发式方法可能无法识别和删除即使一个垃圾索引元组(在这种情况下，页分割或重复数据删除传递解决传入的新元组不适合叶页的问题)。
   任何索引扫描必须遍历的最坏版本数(对于单个逻辑行)，是整个系统响应能力和吞吐量的重要因素。
   自下而上的索引删除通道基于涉及逻辑行和版本的定性区分，针对单个叶页中的可疑垃圾元组。
   bottom-up的索引删除传递针对单个叶页中的可疑垃圾元组，基于涉及逻辑行和版本的<emphasis>quantitative</emphasis>差异。
   这与autovacuum workers执行的<quote>top-down</quote>索引清理形成对比，其在某些<emphasis>quantitative</emphasis>表级阈值超过时触发(参见 <xref linkend="autovacuum"/>)。
  </para>
<!-- pgdoc-cn_end sig_en=4a56c46921a901562b0969620afc70ba -->
  <note>
<!-- pgdoc-cn_start sig_en=c9e0fddc3bbfafb8c6ae5dbbb6e89d86 sig_cn_org=None source=14.1 
   <para>
    Not all deletion operations that are performed within B-Tree
    indexes are bottom-up deletion operations.  There is a distinct
    category of index tuple deletion: <firstterm>simple index tuple
     deletion</firstterm>.  This is a deferred maintenance operation
    that deletes index tuples that are known to be safe to delete
    (those whose item identifier's <literal>LP_DEAD</literal> bit is
    already set).  Like bottom-up index deletion, simple index
    deletion takes place at the point that a page split is anticipated
    as a way of avoiding the split.
   </para>
________________________________________________________-->
   <para>
    不是所有在B-Tree索引中执行的删除操作，都是bottom-up删除操作。
    这有一个索引元组删除的独特类别：<firstterm>simple index tuple deletion</firstterm>.  
    这是一个延迟维护操作，用以删除已知的可以安全删除的索引元组(那些项标识符<literal>LP_DEAD</literal>位已经被设置的)。
    就像bottom-up索引删除，简单索引删除发生在预期将进行页分割的时候，作为避免分割的一种方式。
   </para>
<!-- pgdoc-cn_end sig_en=c9e0fddc3bbfafb8c6ae5dbbb6e89d86 -->
<!-- pgdoc-cn_start sig_en=dde642c793d00234c1c75ea2f193c9bd sig_cn_org=None source=14.1 
   <para>
    Simple deletion is opportunistic in the sense that it can only
    take place when recent index scans set the
    <literal>LP_DEAD</literal> bits of affected items in passing.
    Prior to <productname>PostgreSQL</productname> 14, the only
    category of B-Tree deletion was simple deletion.  The main
    differences between it and bottom-up deletion are that only the
    former is opportunistically driven by the activity of passing
    index scans, while only the latter specifically targets version
    churn from <command>UPDATE</command>s that do not logically modify
    indexed columns.
   </para>
________________________________________________________-->
   <para>
    某种意义上说，简单删除是具有机会性的，因为它只能在当前索引扫描设定传递所影响项目的<literal>LP_DEAD</literal>位的时候发生。
    在<productname>PostgreSQL</productname> 14之前，唯一的B-Tree删除类别是简单删除。
    它和bottom-up删除的主要区别是，前者(简单删除)是由传递索引扫描活动在适当的时候驱动的，而后者专门针对没有进行逻辑修改索引列的<command>UPDATE</command>所带来的版本混杂。
   </para>
<!-- pgdoc-cn_end sig_en=dde642c793d00234c1c75ea2f193c9bd -->
  </note>
<!-- pgdoc-cn_start sig_en=0134d334ac82d3d5dd41623f1d72b7fe sig_cn_org=None source=14.1 
  <para>
   Bottom-up index deletion performs the vast majority of all garbage
   index tuple cleanup for particular indexes with certain workloads.
   This is expected with any B-Tree index that is subject to
   significant version churn from <command>UPDATE</command>s that
   rarely or never logically modify the columns that the index covers.
   The average and worst-case number of versions per logical row can
   be kept low purely through targeted incremental deletion passes.
   It's quite possible that the on-disk size of certain indexes will
   never increase by even one single page/block despite
   <emphasis>constant</emphasis> version churn from
   <command>UPDATE</command>s.  Even then, an exhaustive <quote>clean
    sweep</quote> by a <command>VACUUM</command> operation (typically
   run in an autovacuum worker process) will eventually be required as
   a part of <emphasis>collective</emphasis> cleanup of the table and
   each of its indexes.
  </para>
________________________________________________________-->
  <para>
   Bottom-up索引删除为具有某些工作负载的特定索引执行绝大多数垃圾索引元组清理。
   对任何B-Tree索引，如果它从<command>UPDATE</command>受到明显的版本混杂，而几乎没有或从未有逻辑更改该索引所覆盖的列，这是可以预见的。
   每个逻辑行的平均和最坏情况的版本数可以通过目标增量删除传递以保持较低。
   尽管从 <command>UPDATE</command><emphasis>constant</emphasis> 进行了版本混杂，但某些索引的磁盘大小很可能永远不会增加哪怕一个页面/块。
   尽管如此，一个由<command>VACUUM</command>操作(通常在autovacuum worker进程中运行)的彻底的<quote>clean sweep</quote> 将最终需要作为表和它的每个索引的<emphasis>集体</emphasis>清理的一部分。
  </para>
<!-- pgdoc-cn_end sig_en=0134d334ac82d3d5dd41623f1d72b7fe -->
<!-- pgdoc-cn_start sig_en=28d6791387b54dd3b3bbd538a6543ee8 sig_cn_org=None source=14.1 
  <para>
   Unlike <command>VACUUM</command>, bottom-up index deletion does not
   provide any strong guarantees about how old the oldest garbage
   index tuple may be.  No index can be permitted to retain
   <quote>floating garbage</quote> index tuples that became dead prior
   to a conservative cutoff point shared by the table and all of its
   indexes collectively.  This fundamental table-level invariant makes
   it safe to recycle table <acronym>TID</acronym>s.  This is how it
   is possible for distinct logical rows to reuse the same table
   <acronym>TID</acronym> over time (though this can never happen with
   two logical rows whose lifetimes span the same
   <command>VACUUM</command> cycle).
  </para>
________________________________________________________-->
  <para>
   不像<command>VACUUM</command>，bottom-up索引删除不提供任何关于最古老的垃圾索引元组有多长时间的强保证。
   没有索引可以被允许保留在由表和所有它的索引共享的保守截止点之前已经失效的<quote>floating garbage</quote>索引元组。
   这个基本的表级不变量使得回收利用表的<acronym>TID</acronym>是安全的。
   这就是为什么不同的逻辑行可以随着时间的推移而重新使用相同的表<acronym>TID</acronym>(尽管这在生命周期跨越相同的<command>VACUUM</command>周期的两个逻辑行中永远不会发生)。
  </para>
<!-- pgdoc-cn_end sig_en=28d6791387b54dd3b3bbd538a6543ee8 -->
 </sect2>

 <sect2 id="btree-deduplication">
<!-- pgdoc-cn_start sig_en=925d6e066fe2917a3ade7b84cbac0d41 sig_cn_org=None source=14.1 
  <title>Deduplication</title>
________________________________________________________-->
  <title>Deduplication</title>
<!-- pgdoc-cn_end sig_en=925d6e066fe2917a3ade7b84cbac0d41 -->
<!-- pgdoc-cn_start sig_en=b861368d809ee95e5a026c8d445ab343 sig_cn_org=None source=14.1 
  <para>
   A duplicate is a leaf page tuple (a tuple that points to a table
   row) where <emphasis>all</emphasis> indexed key columns have values
   that match corresponding column values from at least one other leaf
   page tuple in the same index.  Duplicate tuples are quite common in
   practice.  B-Tree indexes can use a special, space-efficient
   representation for duplicates when an optional technique is
   enabled: <firstterm>deduplication</firstterm>.
  </para>
________________________________________________________-->
  <para>
   重复项是叶页元组（指向表行的元组），其中<emphasis>所有</emphasis> 索引键列的值与同一索引中至少一个其他叶页元组的相应列值匹配。 
   重复元组在实践中很常见。 
   当启用可选技术：<firstterm>重复</firstterm>时，B-Tree 索引可以对重复项使用特殊的、节省空间的表达方式。
  </para>
<!-- pgdoc-cn_end sig_en=b861368d809ee95e5a026c8d445ab343 -->
<!-- pgdoc-cn_start sig_en=8ad5efb4f03b45636960413b80b94988 sig_cn_org=None source=14.1 
  <para>
   Deduplication works by periodically merging groups of duplicate
   tuples together, forming a single <firstterm>posting list</firstterm> tuple for each
   group.  The column key value(s) only appear once in this
   representation.  This is followed by a sorted array of
   <acronym>TID</acronym>s that point to rows in the table.  This
   significantly reduces the storage size of indexes where each value
   (or each distinct combination of column values) appears several
   times on average.  The latency of queries can be reduced
   significantly.  Overall query throughput may increase
   significantly.  The overhead of routine index vacuuming may also be
   reduced significantly.
  </para>
________________________________________________________-->
  <para>
   重复数据删除的工作为通过定期将重复元组合并在一起，为每个组构建一个<firstterm>posting list</firstterm>元组。 
   列键值在此表示形式中仅显示一次。 后面跟着指向表中行的<acronym>TID</acronym>的排序数组。
   这显著减少了索引的存储大小，在其中每个值（或列值的每个不同组合）平均出现多次时。 
   查询的延迟可以显著降低。 总体查询吞吐量可能会显著增加。 常规索引清空的开销也可以显著降低。
  </para>
<!-- pgdoc-cn_end sig_en=8ad5efb4f03b45636960413b80b94988 -->
  <note>
<!-- pgdoc-cn_start sig_en=1af55dd74c95d66d191628476957770f sig_cn_org=None source=14.1 
   <para>
    B-Tree deduplication is just as effective with
    <quote>duplicates</quote> that contain a NULL value, even though
    NULL values are never equal to each other according to the
    <literal>=</literal> member of any B-Tree operator class.  As far
    as any part of the implementation that understands the on-disk
    B-Tree structure is concerned, NULL is just another value from the
    domain of indexed values.
   </para>
________________________________________________________-->
   <para>
    B-Tree重复数据删除对于包含 NULL 值的<quote>duplicates</quote>同样有效，即使根据任何 B-Tree 操作符类的 <literal>=</literal> 成员，NULL 值永远不会彼此相等。 
    对于理解磁盘上 B-Tree 结构的实现的任何部分，NULL 只是索引值域中的另一个值。
   </para>
<!-- pgdoc-cn_end sig_en=1af55dd74c95d66d191628476957770f -->
  </note>
<!-- pgdoc-cn_start sig_en=57239ef77795789433e3cdf771b5efe7 sig_cn_org=None source=14.1 
  <para>
   The deduplication process occurs lazily, when a new item is
   inserted that cannot fit on an existing leaf page, though only when
   index tuple deletion could not free sufficient space for the new
   item (typically deletion is briefly considered and then skipped
   over).  Unlike GIN posting list tuples, B-Tree posting list tuples
   do not need to expand every time a new duplicate is inserted; they
   are merely an alternative physical representation of the original
   logical contents of the leaf page.  This design prioritizes
   consistent performance with mixed read-write workloads.  Most
   client applications will at least see a moderate performance
   benefit from using deduplication.  Deduplication is enabled by
   default.
  </para>
________________________________________________________-->
  <para>
   当插入的新项无法适应现有叶页时，重复数据删除过程进行缓慢，虽然只有当索引元组删除不能为新项释放足够的空间时(通常删除会被简单考虑然后跳过)
   不像 GIN 倒排列表元组，B-Tree倒排列表元组不需要在每次插入新重复项时展开;它们仅仅是叶页原始逻辑内容的替代物理表示方式。 
   此设计优先考虑混合读写工作负载的一致性能。 
   大多数客户端应用程序可以从使用重复数据删除中获得适度的性能收益。默认情况下，将启用重复数据删除。
  </para>
<!-- pgdoc-cn_end sig_en=57239ef77795789433e3cdf771b5efe7 -->
<!-- pgdoc-cn_start sig_en=caf76620294233b469f6829b54925b52 sig_cn_org=None source=14.1 
  <para>
   <command>CREATE INDEX</command> and <command>REINDEX</command>
   apply deduplication to create posting list tuples, though the
   strategy they use is slightly different.  Each group of duplicate
   ordinary tuples encountered in the sorted input taken from the
   table is merged into a posting list tuple
   <emphasis>before</emphasis> being added to the current pending leaf
   page.  Individual posting list tuples are packed with as many
   <acronym>TID</acronym>s as possible.  Leaf pages are written out in
   the usual way, without any separate deduplication pass.  This
   strategy is well-suited to <command>CREATE INDEX</command> and
   <command>REINDEX</command> because they are once-off batch
   operations.
  </para>
________________________________________________________-->
  <para>
   <command>CREATE INDEX</command>和 <command>REINDEX</command> 应用重复数据删除来创建倒排列表元组，尽管它们使用的策略有所不同。
   每组重复的普通元组遇到从表中取出的排序输入将合并到倒排列表元组，在添加到当前挂起的叶页<emphasis>之前</emphasis>。 
   单独倒排列表元组尽可能以<acronym>TID</acronym>s封装。 叶页以通常的方式写出，没有任何分开的重复数据删除步骤。 
   此策略非常适合<command>CREATE INDEX</command>和<command>REINDEX</command>，因为它们是一次性的批处理操作。
  </para>
<!-- pgdoc-cn_end sig_en=caf76620294233b469f6829b54925b52 -->
<!-- pgdoc-cn_start sig_en=ecbdf3a6994aea93c1fd5bc817c028b9 sig_cn_org=None source=14.1 
  <para>
   Write-heavy workloads that don't benefit from deduplication due to
   having few or no duplicate values in indexes will incur a small,
   fixed performance penalty (unless deduplication is explicitly
   disabled).  The <literal>deduplicate_items</literal> storage
   parameter can be used to disable deduplication within individual
   indexes.  There is never any performance penalty with read-only
   workloads, since reading posting list tuples is at least as
   efficient as reading the standard tuple representation.  Disabling
   deduplication isn't usually helpful.
  </para>
________________________________________________________-->
  <para>
   由于索引中重复值很少或没有重复值，因此无法从重复数据删除中获益的写频繁工作负载将产生少量的、固定性能损耗（除非显式禁用重复数据删除）。 
   <literal>deduplicate_items</literal>存储参数可用于禁用单个索引中的重复数据消除。 
   只读工作负载永远不会有任何性能损失，因为读取倒排列表元组至少与读取标准元组表示一样高效。 禁用重复数据删除通常没有帮助。
  </para>
<!-- pgdoc-cn_end sig_en=ecbdf3a6994aea93c1fd5bc817c028b9 -->
<!-- pgdoc-cn_start sig_en=f150301879f860feb6c1294de6b351ab sig_cn_org=None source=14.1 
  <para>
   It is sometimes possible for unique indexes (as well as unique
   constraints) to use deduplication.  This allows leaf pages to
   temporarily <quote>absorb</quote> extra version churn duplicates.
   Deduplication in unique indexes augments bottom-up index deletion,
   especially in cases where a long-running transaction holds a
   snapshot that blocks garbage collection.  The goal is to buy time
   for the bottom-up index deletion strategy to become effective
   again.  Delaying page splits until a single long-running
   transaction naturally goes away can allow a bottom-up deletion pass
   to succeed where an earlier deletion pass failed.
  </para>
________________________________________________________-->
  <para>
   有的时候惟一索引(以及惟一约束)可能被使用重复数据删除。
   这允许叶页临时<quote>absorb</quote> 额外的版本混杂副本。
   唯一索引中的重复数据删除增强了bottom-up索引删除，特别是在长时间运行的事务持有块垃圾收集的快照的情况下。
   目的是为了bottom-up索引删除策略变得再次生效争取时间。
   延迟分页分割，直到单个长时间运行的事务自然消失，可以允许bottom-up删除传递成功，在较早的删除传递失败的地方。
  </para>
<!-- pgdoc-cn_end sig_en=f150301879f860feb6c1294de6b351ab -->
  <tip>
<!-- pgdoc-cn_start sig_en=5bf98832fc0175fca3c01067ce005e8f sig_cn_org=None source=14.1 
   <para>
    A special heuristic is applied to determine whether a
    deduplication pass in a unique index should take place.  It can
    often skip straight to splitting a leaf page, avoiding a
    performance penalty from wasting cycles on unhelpful deduplication
    passes.  If you're concerned about the overhead of deduplication,
    consider setting <literal>deduplicate_items = off</literal>
    selectively.  Leaving deduplication enabled in unique indexes has
    little downside.
   </para>
________________________________________________________-->
   <para>
    应用一种特殊的启发式方法来确定是否应在唯一索引中进行重复数据删除操作。 
    它通常可以直接跳到拆分叶页，避免在无益的重复数据删除传递上浪费周期会降低性能。 
    如果你担心重复数据删除的开销，可以考虑<literal>deduplicate_items = off</literal>。 在唯一索引中启用重复数据删除没有什么坏处。
   </para>
<!-- pgdoc-cn_end sig_en=5bf98832fc0175fca3c01067ce005e8f -->
  </tip>
<!-- pgdoc-cn_start sig_en=720133333962c38a469043522ac83187 sig_cn_org=None source=14.1 
  <para>
   Deduplication cannot be used in all cases due to
   implementation-level restrictions.  Deduplication safety is
   determined when <command>CREATE INDEX</command> or
   <command>REINDEX</command> is run.
  </para>
________________________________________________________-->
  <para>
   由于实现级别的限制，不能在所有情况下使用重复数据消除。 
   在<command>CREATE INDEX</command> 或 <command>REINDEX</command>时决定重复数据删除安全性。
  </para>
<!-- pgdoc-cn_end sig_en=720133333962c38a469043522ac83187 -->
<!-- pgdoc-cn_start sig_en=12d8cd3fbeb42b76154e58b5761fe6de sig_cn_org=None source=14.1 
  <para>
   Note that deduplication is deemed unsafe and cannot be used in the
   following cases involving semantically significant differences
   among equal datums:
  </para>
________________________________________________________-->
  <para>
   请注意，重复数据删除被认为是不安全的，不能用于下列涉及相同数据之间语义显著差异的情况:
  </para>
<!-- pgdoc-cn_end sig_en=12d8cd3fbeb42b76154e58b5761fe6de -->
<!-- pgdoc-cn_start sig_en=c6c12cc10159d985b12c6665275c5208 sig_cn_org=None source=14.1 
  <para>
   <itemizedlist>
    <listitem>
     <para>
      <type>text</type>, <type>varchar</type>, and <type>char</type>
      cannot use deduplication when a
      <emphasis>nondeterministic</emphasis> collation is used.  Case
      and accent differences must be preserved among equal datums.
     </para>
    </listitem>

    <listitem>
     <para>
      <type>numeric</type> cannot use deduplication.  Numeric display
      scale must be preserved among equal datums.
     </para>
    </listitem>

    <listitem>
     <para>
      <type>jsonb</type> cannot use deduplication, since the
      <type>jsonb</type> B-Tree operator class uses
      <type>numeric</type> internally.
     </para>
    </listitem>

    <listitem>
     <para>
      <type>float4</type> and <type>float8</type> cannot use
      deduplication.  These types have distinct representations for
      <literal>-0</literal> and <literal>0</literal>, which are
      nevertheless considered equal.  This difference must be
      preserved.
     </para>
    </listitem>
   </itemizedlist>
  </para>
________________________________________________________-->
  <para>
   <itemizedlist>
    <listitem>
     <para>
      <type>text</type>, <type>varchar</type>, 和 <type>char</type>在使用<emphasis>nondeterministic</emphasis>排序规则时不能使用重复数据删除。 
      在等值基准之间必须保留大小写和重音差异。
     </para>
    </listitem>

    <listitem>
     <para>
      <type>numeric</type>重复数据删除。 数字显示比例必须在相等的基准之间保留。
     </para>
    </listitem>

    <listitem>
     <para>
      <type>jsonb</type>不能使用重复数据消除，因为<type>jsonb</type>B-Tree操作符类在内部使用<type>numeric</type>。
     </para>
    </listitem>

    <listitem>
     <para>
      <type>float4</type>和<type>float8</type>不能使用重复数据删除。
      这些类型对 <literal>-0</literal> 和 <literal>0</literal>具有不同的表示形式，但被视为相等。 必须保留此差异。
     </para>
    </listitem>
   </itemizedlist>
  </para>
<!-- pgdoc-cn_end sig_en=c6c12cc10159d985b12c6665275c5208 -->
<!-- pgdoc-cn_start sig_en=2dc1a98fbfea9ed9b54fb255eb7f2ade sig_cn_org=None source=14.1 
  <para>
   There is one further implementation-level restriction that may be
   lifted in a future version of
   <productname>PostgreSQL</productname>:
  </para>
________________________________________________________-->
  <para>
   在未来版本的<productname>PostgreSQL</productname>中，还有一个实现级限制可能取消：
  </para>
<!-- pgdoc-cn_end sig_en=2dc1a98fbfea9ed9b54fb255eb7f2ade -->
<!-- pgdoc-cn_start sig_en=258b4ac9d0c4d844d75476f6e0962bb3 sig_cn_org=None source=14.1 
  <para>
   <itemizedlist>
    <listitem>
     <para>
      Container types (such as composite types, arrays, or range
      types) cannot use deduplication.
     </para>
    </listitem>
   </itemizedlist>
  </para>
________________________________________________________-->
  <para>
   <itemizedlist>
    <listitem>
     <para>
      容器类型（例如复合类型、数组或范围类型）不能使用重复数据删除。
     </para>
    </listitem>
   </itemizedlist>
  </para>
<!-- pgdoc-cn_end sig_en=258b4ac9d0c4d844d75476f6e0962bb3 -->
<!-- pgdoc-cn_start sig_en=9b2e9cf2212ecb8dadf66afe44325de9 sig_cn_org=None source=14.1 
  <para>
   There is one further implementation-level restriction that applies
   regardless of the operator class or collation used:
  </para>
________________________________________________________-->
  <para>
   无论使用操作符类或排序规则如何，还有一个实现级别限制适用：
  </para>
<!-- pgdoc-cn_end sig_en=9b2e9cf2212ecb8dadf66afe44325de9 -->
<!-- pgdoc-cn_start sig_en=17f4cc0d26582caca3bd3e4b9846ec01 sig_cn_org=None source=14.1 
  <para>
   <itemizedlist>
    <listitem>
     <para>
      <literal>INCLUDE</literal> indexes can never use deduplication.
     </para>
    </listitem>
   </itemizedlist>
  </para>
________________________________________________________-->
  <para>
   <itemizedlist>
    <listitem>
     <para>
      <literal>INCLUDE</literal> 索引不能使用重复数据删除.
     </para>
    </listitem>
   </itemizedlist>
  </para>
<!-- pgdoc-cn_end sig_en=17f4cc0d26582caca3bd3e4b9846ec01 -->

 </sect2>
</sect1>

</chapter>
