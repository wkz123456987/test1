<!-- doc/src/sgml/runtime.sgml -->

<chapter id="runtime">
<!-- pgdoc-cn_start sig_en=89d555b02aaf3e6f55e1c146265d54b0 sig_cn_org=None source=14.1 
 <title>Server Setup and Operation</title>
________________________________________________________-->
 <title>服务器设置和操作</title>
<!-- pgdoc-cn_end sig_en=89d555b02aaf3e6f55e1c146265d54b0 -->

<!-- pgdoc-cn_start sig_en=47f39eae53d117e63a1f868f37979761 sig_cn_org=None source=14.1 
 <para>
  This chapter discusses how to set up and run the database server,
  and its interactions with the operating system.
 </para>
________________________________________________________-->
 <para>
  本章讨论如何设置和运行数据库服务器，以及它与操作系统的交互。
 </para>
<!-- pgdoc-cn_end sig_en=47f39eae53d117e63a1f868f37979761 -->

<!-- pgdoc-cn_start sig_en=d4ffad1cf5b5b3eab247eb2277de1a23 sig_cn_org=None source=14.1 
 <para>
  The directions in this chapter assume that you are working with
  plain <productname>PostgreSQL</productname> without any additional
  infrastructure, for example a copy that you built from source
  according to the directions in the preceding chapters.
  If you are working with a pre-packaged or vendor-supplied
  version of <productname>PostgreSQL</productname>, it is likely that
  the packager has made special provisions for installing and starting
  the database server according to your system's conventions.
  Consult the package-level documentation for details.
 </para>
________________________________________________________-->
 <para>
  本章中的说明假设您使用的是纯 <productname>PostgreSQL</productname>，没有任何额外的基础设施，例如，您根据前面章节中的说明从源代码构建的副本。 如果您使用的是预先打包或供应商提供的 <productname>PostgreSQL</productname> 版本，那么打包者很可能已经根据您的系统约定为安装和启动数据库服务器做出了特殊规定。 有关详细信息，请参阅包级文档。
 </para>
<!-- pgdoc-cn_end sig_en=d4ffad1cf5b5b3eab247eb2277de1a23 -->

 <sect1 id="postgres-user">
<!-- pgdoc-cn_start sig_en=f5fa68998512d4fea5d8f0996d6a950c sig_cn_org=None source=14.1 
  <title>The <productname>PostgreSQL</productname> User Account</title>
________________________________________________________-->
  <title><productname>PostgreSQL</productname>用户账户</title>
<!-- pgdoc-cn_end sig_en=f5fa68998512d4fea5d8f0996d6a950c -->

<!-- pgdoc-cn_start sig_en=61158bf31dbea7026c625c4942d2d6b5 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>postgres user</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>postgres user</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=61158bf31dbea7026c625c4942d2d6b5 -->

<!-- pgdoc-cn_start sig_en=97de943ffb91fe6d6129473615ac18c3 sig_cn_org=None source=14.1 
  <para>
   As with any server daemon that is accessible to the outside world,
   it is advisable to run <productname>PostgreSQL</productname> under a
   separate user account. This user account should only own the data
   that is managed by the server, and should not be shared with other
   daemons. (For example, using the user <literal>nobody</literal> is a bad
   idea.) In particular, it is advisable that this user account not own
   the <productname>PostgreSQL</productname> executable files, to ensure
   that a compromised server process could not modify those executables.
  </para>
________________________________________________________-->
  <para>
   和对外部世界可访问的任何服务器守护进程一样，我们也建议在一个独立的用户账户下运行<productname>PostgreSQL</productname>。这个用户账户应该只拥有被该服务器管理的数据，并且应该不能被其他守护进程共享（例如，使用用户<literal>nobody</literal>是一个坏主意）。特别是，建议<productname>PostgreSQL</productname>不为此用户帐户所有，以确保受感染的服务器进程无法修改这些可执行文件。
  </para>
<!-- pgdoc-cn_end sig_en=97de943ffb91fe6d6129473615ac18c3 -->

<!-- pgdoc-cn_start sig_en=5c0bc32e1f466cd510fd88d982162a82 sig_cn_org=None source=14.1 
  <para>
   Pre-packaged versions of <productname>PostgreSQL</productname> will
   typically create a suitable user account automatically during
   package installation.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname> 的预打包版本通常会在包安装期间自动创建一个合适的用户帐户。
  </para>
<!-- pgdoc-cn_end sig_en=5c0bc32e1f466cd510fd88d982162a82 -->

<!-- pgdoc-cn_start sig_en=5bd90ded63da1f61fc5fd8e61034bc05 sig_cn_org=None source=14.1 
  <para>
   To add a Unix user account to your system, look for a command
   <command>useradd</command> or <command>adduser</command>. The user
   name <systemitem>postgres</systemitem> is often used, and is assumed
   throughout this book, but you can use another name if you like.
  </para>
________________________________________________________-->
  <para>
   要在你的系统中增加一个 Unix 用户账户，查看一个命令<command>useradd</command>或<command>adduser</command>。通常会用<systemitem>postgres</systemitem>（本书中也假定用这个账户），但是你可以使用另一个名称。
  </para>
<!-- pgdoc-cn_end sig_en=5bd90ded63da1f61fc5fd8e61034bc05 -->
 </sect1>

 <sect1 id="creating-cluster">
<!-- pgdoc-cn_start sig_en=f03860ebe54f5a0e61ee014cafed0c70 sig_cn_org=None source=14.1 
  <title>Creating a Database Cluster</title>
________________________________________________________-->
  <title>创建一个数据库集簇</title>
<!-- pgdoc-cn_end sig_en=f03860ebe54f5a0e61ee014cafed0c70 -->

<!-- pgdoc-cn_start sig_en=8fbeaab88985218aa2716281bf4c815f sig_cn_org=None source=14.1 
  <indexterm>
   <primary>database cluster</primary>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>数据库集簇</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=8fbeaab88985218aa2716281bf4c815f -->

<!-- pgdoc-cn_start sig_en=fc0df12d35921b5b02e6eb4fe893ac78 sig_cn_org=None source=14.1 
  <indexterm>
   <primary>data area</primary>
   <see>database cluster</see>
  </indexterm>
________________________________________________________-->
  <indexterm>
   <primary>数据区域</primary>
   <see>数据库集簇</see>
  </indexterm>
<!-- pgdoc-cn_end sig_en=fc0df12d35921b5b02e6eb4fe893ac78 -->

<!-- pgdoc-cn_start sig_en=8f1390568ecf923dd7ad339e0630b5f8 sig_cn_org=5de06b3fdbd60c23dcc1111cb03d7dac source=15.7 
  <para>
   Before you can do anything, you must initialize a database storage
   area on disk. We call this a <firstterm>database cluster</firstterm>.
   (The <acronym>SQL</acronym> standard uses the term catalog cluster.) A
   database cluster is a collection of databases that is managed by a
   single instance of a running database server. After initialization, a
   database cluster will contain a database named <literal>postgres</literal>,
   which is meant as a default database for use by utilities, users and third
   party applications.  The database server itself does not require the
   <literal>postgres</literal> database to exist, but many external utility
   programs assume it exists.  There are two more databases created within
   each cluster during initialization, named <literal>template1</literal>
   and <literal>template0</literal>.  As the names suggest, these will be
   used as templates for subsequently-created databases; they should not be
   used for actual work.  (See <xref linkend="managing-databases"/> for
   information about creating new databases within a cluster.)
  </para>
________________________________________________________-->
  <para>
   在你做任何事情之前，你必须在磁盘上初始化一个数据库存储区域。我们称之为<firstterm>集簇(database cluster)</firstterm>。
   （<acronym>SQL</acronym>标准使用术语目录集群。）集簇是由运行中的数据库服务器的单个实例管理的数据库集合。
   初始化后，集簇将包含一个名为<literal>postgres</literal>的数据库，这是一个默认数据库，供实用程序、用户和第三方应用程序使用。
   数据库服务器本身不需要<literal>postgres</literal>数据库存在，但许多外部实用程序假定它存在。
   在初始化期间，每个集簇内创建两个更多的数据库，分别命名为<literal>template1</literal>和<literal>template0</literal>。
   正如名称所示，这些将被用作随后创建的数据库的模板；它们不应该用于实际工作。（有关在集簇内创建新数据库的信息，请参见<xref linkend="managing-databases"/>。）
</para>
<!-- pgdoc-cn_end sig_en=8f1390568ecf923dd7ad339e0630b5f8 -->

<!-- pgdoc-cn_start sig_en=2ddb0c03f87c867f0c9e5988b8dba367 sig_cn_org=None source=14.1 
  <para>
   In file system terms, a database cluster is a single directory
   under which all data will be stored. We call this the <firstterm>data
   directory</firstterm> or <firstterm>data area</firstterm>. It is
   completely up to you where you choose to store your data.  There is no
   default, although locations such as
   <filename>/usr/local/pgsql/data</filename> or
   <filename>/var/lib/pgsql/data</filename> are popular.
   The data directory must be initialized before being used, using the program
   <xref linkend="app-initdb"/><indexterm><primary>initdb</primary></indexterm>
   which is installed with <productname>PostgreSQL</productname>.
  </para>
________________________________________________________-->
  <para>
   在文件系统术语中，一个数据库集簇是一个单一目录，所有数据都将被存储在其中。我们称它为<firstterm>数据目录</firstterm>或<firstterm>数据区域</firstterm>。在哪里存储你的数据完全由你选择。没有默认的位置，不过<filename>/usr/local/pgsql/data</filename> 或 <filename>/var/lib/pgsql/data</filename>位置比较流行。
   数据目录必须在使用前初始化，必须使用与<productname>PostgreSQL</productname>一起安装的程序<xref linkend="app-initdb"/><indexterm><primary>initdb</primary></indexterm>。
  </para>
<!-- pgdoc-cn_end sig_en=2ddb0c03f87c867f0c9e5988b8dba367 -->

<!-- pgdoc-cn_start sig_en=1f06ada1f1301ad3b185f6007008a2f7 sig_cn_org=None source=14.1 
  <para>
   If you are using a pre-packaged version
   of <productname>PostgreSQL</productname>, it may well have a specific
   convention for where to place the data directory, and it may also
   provide a script for creating the data directory.  In that case you
   should use that script in preference to
   running <command>initdb</command> directly.
   Consult the package-level documentation for details.
  </para>
________________________________________________________-->
  <para>
   如果您使用的是 <productname>PostgreSQL</productname> 的预打包版本，它可能有一个特定的约定来放置数据目录的位置，并且它还可能提供用于创建数据目录的脚本。 在这种情况下，您应该优先使用该脚本而不是直接运行 <command>initdb</command>。 有关详细信息，请参阅包级文档。
  </para>
<!-- pgdoc-cn_end sig_en=1f06ada1f1301ad3b185f6007008a2f7 -->

<!-- pgdoc-cn_start sig_en=c0afc21391836670af93addeae04f332 sig_cn_org=None source=14.1 
  <para>
   To initialize a database cluster manually,
   run <command>initdb</command> and specify the desired
   file system location of the database cluster with the
   <option>-D</option> option, for example:
<screen>
<prompt>$</prompt> <userinput>initdb -D /usr/local/pgsql/data</userinput>
</screen>
   Note that you must execute this command while logged into the
   <productname>PostgreSQL</productname> user account, which is
   described in the previous section.
  </para>
________________________________________________________-->
  <para>
   要手动初始化数据库集群，请运行 <command>initdb</command> 并使用 <option>-D</option> 选项指定所需的数据库集群文件系统位置，例如：
<screen>
<prompt>$</prompt> <userinput>initdb -D /usr/local/pgsql/data</userinput>
</screen>
   请注意，您必须在登录 <productname>PostgreSQL</productname> 用户帐户时执行此命令，这在上一节中进行了描述。
  </para>
<!-- pgdoc-cn_end sig_en=c0afc21391836670af93addeae04f332 -->

  <tip>
<!-- pgdoc-cn_start sig_en=a6ad9580179a4ff3492a7ce47ad66a78 sig_cn_org=None source=14.1 
   <para>
    As an alternative to the <option>-D</option> option, you can set
    the environment variable <envar>PGDATA</envar>.
    <indexterm><primary><envar>PGDATA</envar></primary></indexterm>
   </para>
________________________________________________________-->
   <para>
    作为<option>-D</option>选项的一种替换方案，你可以设置环境变量<envar>PGDATA</envar>。
    <indexterm><primary><envar>PGDATA</envar></primary></indexterm>
   </para>
<!-- pgdoc-cn_end sig_en=a6ad9580179a4ff3492a7ce47ad66a78 -->
  </tip>

<!-- pgdoc-cn_start sig_en=c7d9332e9faf1ad109d98e2305ff4d05 sig_cn_org=None source=14.1 
  <para>
   Alternatively, you can run <command>initdb</command> via
   the <xref linkend="app-pg-ctl"/>
   program<indexterm><primary>pg_ctl</primary></indexterm> like so:
<screen>
<prompt>$</prompt> <userinput>pg_ctl -D /usr/local/pgsql/data initdb</userinput>
</screen>
   This may be more intuitive if you are
   using <command>pg_ctl</command> for starting and stopping the
   server (see <xref linkend="server-start"/>), so
   that <command>pg_ctl</command> would be the sole command you use
   for managing the database server instance.
  </para>
________________________________________________________-->
  <para>
   另一种替代方案是，你可以通过<xref linkend="app-pg-ctl"/><indexterm><primary>pg_ctl</primary></indexterm>程序来运行<command>initdb</command>：
<screen>
<prompt>$</prompt> <userinput>pg_ctl -D /usr/local/pgsql/data initdb</userinput>
</screen>
   如果你使用<command>pg_ctl</command>来启停服务器（见<xref linkend="server-start"/>），这种方法可能更直观，以为这样<command>pg_ctl</command>将是你用来管理数据库服务器实例的唯一命令。
  </para>
<!-- pgdoc-cn_end sig_en=c7d9332e9faf1ad109d98e2305ff4d05 -->

<!-- pgdoc-cn_start sig_en=ff4d4df657a3c8d0af0f85eefb701e2b sig_cn_org=None source=14.1 
  <para>
   <command>initdb</command> will attempt to create the directory you
   specify if it does not already exist.  Of course, this will fail if
   <command>initdb</command> does not have permissions to write in the
   parent directory.  It's generally recommendable that the
   <productname>PostgreSQL</productname> user own not just the data
   directory but its parent directory as well, so that this should not
   be a problem.  If the desired parent directory doesn't exist either,
   you will need to create it first, using root privileges if the
   grandparent directory isn't writable.  So the process might look
   like this:
<screen>
root# <userinput>mkdir /usr/local/pgsql</userinput>
root# <userinput>chown postgres /usr/local/pgsql</userinput>
root# <userinput>su postgres</userinput>
postgres$ <userinput>initdb -D /usr/local/pgsql/data</userinput>
</screen>
  </para>
________________________________________________________-->
  <para>
   如果你指定的目录还不存在，<command>initdb</command>将尝试创建它。当然，如果<command>initdb</command>没有在父目录中的写权限，这将会失败。通常推荐让<productname>PostgreSQL</productname>用户拥有数据目录及其父目录，这样就不存在上面的问题了。如果想要的父目录也不存在，你将需要先创建它，如果父父目录不可写则使用 root 特权。因此，该过程可能像这样：
<screen>
root# <userinput>mkdir /usr/local/pgsql</userinput>
root# <userinput>chown postgres /usr/local/pgsql</userinput>
root# <userinput>su postgres</userinput>
postgres$ <userinput>initdb -D /usr/local/pgsql/data</userinput>
</screen>
  </para>
<!-- pgdoc-cn_end sig_en=ff4d4df657a3c8d0af0f85eefb701e2b -->

<!-- pgdoc-cn_start sig_en=75b896792de3654a1e2edd89d592d6ff sig_cn_org=None source=14.1 
  <para>
   <command>initdb</command> will refuse to run if the data directory
   exists and already contains files; this is to prevent accidentally
   overwriting an existing installation.
  </para>
________________________________________________________-->
  <para>
   如果数据目录存在并且已经包含文件，<command>initdb</command>将拒绝运行。这可以避免无意中覆盖一个已有的安装。</para>
<!-- pgdoc-cn_end sig_en=75b896792de3654a1e2edd89d592d6ff -->

<!-- pgdoc-cn_start sig_en=c2b9727d99144cdcd363c081bd40c400 sig_cn_org=None source=14.1 
  <para>
   Because the data directory contains all the data stored in the
   database, it is essential that it be secured from unauthorized
   access. <command>initdb</command> therefore revokes access
   permissions from everyone but the
   <productname>PostgreSQL</productname> user, and optionally, group.
   Group access, when enabled, is read-only.  This allows an unprivileged
   user in the same group as the cluster owner to take a backup of the
   cluster data or perform other operations that only require read access.
  </para>
________________________________________________________-->
  <para>
   因为数据目录包含所有存储在数据库里的数据，所以最重要的是保护这个目录不受未授权的访问。因此，<command>initdb</command>会回收禁止除<productname>PostgreSQL</productname>用户，也可以选择组，之外所有用户的访问权限。当组访问启用时，是只读的。它允许相同组中未被授权的用户作为集簇属主，备份集簇数据或者执行其他只需要读访问权限的操作。
  </para>
<!-- pgdoc-cn_end sig_en=c2b9727d99144cdcd363c081bd40c400 -->

<!-- pgdoc-cn_start sig_en=09bb470ed0ddcc9ff13c919170bd2443 sig_cn_org=None source=14.1 
  <para>
   Note that enabling or disabling group access on an existing cluster requires
   the cluster to be shut down and the appropriate mode to be set on all
   directories and files before restarting
   <productname>PostgreSQL</productname>.  Otherwise, a mix of modes might
   exist in the data directory.  For clusters that allow access only by the
   owner, the appropriate modes are <literal>0700</literal> for directories
   and <literal>0600</literal> for files.  For clusters that also allow
   reads by the group, the appropriate modes are <literal>0750</literal>
   for directories and <literal>0640</literal> for files.
  </para>
________________________________________________________-->
  <para>
   注意在现有集群启用或禁用组访问时，需要关闭集群，且重新启动<productname>PostgreSQL</productname>之前设置所有的目录和文件到恰当的模式。否则，数据目录中会存在多种模式。集群仅可以被其属主访问，恰当的模式应该是，其目录设置为<literal>0700</literal>，普通文件设置为<literal>0600</literal>。允许集群被组可读，恰当的模式应该是，其目录设置为<literal>0750</literal>，普通文件设置为<literal>0640</literal>。
  </para>
<!-- pgdoc-cn_end sig_en=09bb470ed0ddcc9ff13c919170bd2443 -->

<!-- pgdoc-cn_start sig_en=64858a2f9cdf8db7470b38432209a86f sig_cn_org=fd87e224aa3de54d21ed8ae8665aa259 source=15.7 
  <para>
   However, while the directory contents are secure, the default
   client authentication setup allows any local user to connect to the
   database and even become the database superuser. If you do not
   trust other local users, we recommend you use one of
   <command>initdb</command>'s <option>-W</option>, <option>-&minus;pwprompt</option>
   or <option>-&minus;pwfile</option> options to assign a password to the
   database superuser.<indexterm>
     <primary>password</primary>
     <secondary>of the superuser</secondary>
   </indexterm>
   Also, specify <option>-A scram-sha-256</option>
   so that the default <literal>trust</literal> authentication
   mode is not used; or modify the generated <filename>pg_hba.conf</filename>
   file after running <command>initdb</command>, but
   <emphasis>before</emphasis> you start the server for the first time. (Other
   reasonable approaches include using <literal>peer</literal> authentication
   or file system permissions to restrict connections. See <xref
   linkend="client-authentication"/> for more information.)
  </para>
________________________________________________________-->
  <para>
   然而，虽然目录内容是安全的，但默认的客户端身份验证设置允许任何本地用户连接到数据库，甚至成为数据库超级用户。
   如果您不信任其他本地用户，我们建议您使用<command>initdb</command>的<option>-W</option>、<option>--pwprompt</option>
   或<option>--pwfile</option>选项之一为数据库超级用户分配密码。<indexterm>
     <primary>密码</primary>
     <secondary>超级用户的</secondary>
   </indexterm>
   另外，指定<option>-A scram-sha-256</option>
   以便不使用默认的<literal>trust</literal>身份验证模式；或在运行<command>initdb</command>后修改生成的<filename>pg_hba.conf</filename>
   文件，但在您首次启动服务器<emphasis>之前</emphasis>。 （其他合理的方法包括使用<literal>peer</literal>身份验证
   或文件系统权限来限制连接。有关更多信息，请参见<xref linkend="client-authentication"/>。）
</para>
<!-- pgdoc-cn_end sig_en=64858a2f9cdf8db7470b38432209a86f -->

<!-- pgdoc-cn_start sig_en=2fa90536e74ada8087dc84359847b108 sig_cn_org=None source=14.1 
  <para>
   <command>initdb</command> also initializes the default
   locale<indexterm><primary>locale</primary></indexterm> for the database cluster.
   Normally, it will just take the locale settings in the environment
   and apply them to the initialized database.  It is possible to
   specify a different locale for the database; more information about
   that can be found in <xref linkend="locale"/>.  The default sort order used
   within the particular database cluster is set by
   <command>initdb</command>, and while you can create new databases using
   different sort order, the order used in the template databases that initdb
   creates cannot be changed without dropping and recreating them.
   There is also a performance impact for using locales
   other than <literal>C</literal> or <literal>POSIX</literal>. Therefore, it is
   important to make this choice correctly the first time.
  </para>
________________________________________________________-->
  <para>
   <command>initdb</command>同时也为数据库集簇初始化默认区域<indexterm><primary>locale</primary></indexterm>。 通常，它将只是使用环境中的区域设置并且把它们应用于被初始化的数据库。 可以为数据库指定一个不同的区域；有关于此的更多信息可以在<xref linkend="locale"/>中找到。 特定数据库集簇中使用的默认排序顺序是通过<command>initdb</command>设置的， 虽然你可以创建使用不同排序顺序的新数据库，但在 initdb 创建的模板数据库中使用的顺序不能更改（除非删除并重建它们）。使用非<literal>C</literal>或<literal>POSIX</literal>的区域还会对性能造成影响。因此，第一次就正确地选择很重要。
  </para>
<!-- pgdoc-cn_end sig_en=2fa90536e74ada8087dc84359847b108 -->

<!-- pgdoc-cn_start sig_en=ff01eba197448e6787db555e172d35f0 sig_cn_org=None source=14.1 
  <para>
   <command>initdb</command> also sets the default character set encoding
   for the database cluster.  Normally this should be chosen to match the
   locale setting.  For details see <xref linkend="multibyte"/>.
  </para>
________________________________________________________-->
  <para>
   <command>initdb</command>还为数据库集簇设置默认的字符集编码。通常字符集编码应该选择与区域设置匹配。详见<xref linkend="multibyte"/>。
  </para>
<!-- pgdoc-cn_end sig_en=ff01eba197448e6787db555e172d35f0 -->

<!-- pgdoc-cn_start sig_en=3e6450db2b595455349b02d41e943875 sig_cn_org=None source=14.1 
  <para>
   Non-<literal>C</literal> and non-<literal>POSIX</literal> locales rely on the
   operating system's collation library for character set ordering.
   This controls the ordering of keys stored in indexes.  For this reason,
   a cluster cannot switch to an incompatible collation library version,
   either through snapshot restore, binary streaming replication, a
   different operating system, or an operating system upgrade.
  </para>
________________________________________________________-->
  <para>
   非<literal>C</literal>以及非<literal>POSIX</literal>区域对于字符集排序依赖于操作系统的排序规则库。这控制着索引中存储的键的排序。为此，通过快照恢复、二进制流复制、更换不同的操作系统或者升级操作系统都不能把一个集簇切换到一种不兼容的排序规则库版本。
  </para>
<!-- pgdoc-cn_end sig_en=3e6450db2b595455349b02d41e943875 -->

  <sect2 id="creating-cluster-mount-points">
<!-- pgdoc-cn_start sig_en=13e07813e0b712f1784d464022e4eff0 sig_cn_org=None source=14.1 
   <title>Use of Secondary File Systems</title>
________________________________________________________-->
   <title>二级文件系统的使用</title>
<!-- pgdoc-cn_end sig_en=13e07813e0b712f1784d464022e4eff0 -->

<!-- pgdoc-cn_start sig_en=07195c3b5530d0dfbe3afd6aefb837db sig_cn_org=None source=14.1 
   <indexterm zone="creating-cluster-mount-points">
    <primary>file system mount points</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="creating-cluster-mount-points">
    <primary>文件系统挂载点</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=07195c3b5530d0dfbe3afd6aefb837db -->

<!-- pgdoc-cn_start sig_en=ff4086a1926f4462912c774621f885ff sig_cn_org=None source=14.1 
   <para>
    Many installations create their database clusters on file systems
    (volumes) other than the machine's <quote>root</quote> volume.  If you
    choose to do this, it is not advisable to try to use the secondary
    volume's topmost directory (mount point) as the data directory.
    Best practice is to create a directory within the mount-point
    directory that is owned by the <productname>PostgreSQL</productname>
    user, and then create the data directory within that.  This avoids
    permissions problems, particularly for operations such
    as <application>pg_upgrade</application>, and it also ensures clean failures if
    the secondary volume is taken offline.
   </para>
________________________________________________________-->
   <para>
    很多安装会在文件系统（卷）而不是机器的<quote>根</quote>卷上创建它们的数据库集簇。如果你选择这样做，我们不建议尝试使用二级卷的顶层目录（挂载点）作为数据目录。最好的做法是在<productname>PostgreSQL</productname>用户拥有的挂载点目录中创建一个目录，然后在其中创建数据目录。这可以避免权限问题，特别是对于<application>pg_upgrade</application>这类操作，并且它也能在二级卷被断线后确保干净的失败。
   </para>
<!-- pgdoc-cn_end sig_en=ff4086a1926f4462912c774621f885ff -->

  </sect2>

  <sect2 id="creating-cluster-filesystem">
<!-- pgdoc-cn_start sig_en=d8526724d50f015504884cb8a99134b6 sig_cn_org=None source=14.1 
   <title>File Systems</title>
________________________________________________________-->
   <title>文件系统</title>
<!-- pgdoc-cn_end sig_en=d8526724d50f015504884cb8a99134b6 -->

<!-- pgdoc-cn_start sig_en=8720cce6afd70fb34008e6ac30c57ef0 sig_cn_org=None source=14.1 
   <para>
    Generally, any file system with POSIX semantics can be used for
    PostgreSQL.  Users prefer different file systems for a variety of reasons,
    including vendor support, performance, and familiarity.  Experience
    suggests that, all other things being equal, one should not expect major
    performance or behavior changes merely from switching file systems or
    making minor file system configuration changes.
   </para>
________________________________________________________-->
   <para>
    通常来说，任何具有 POSIX 语义的文件系统都可用于 PostgreSQL。用户出于各种原因会喜欢不同的文件系统，包括供应商支持、性能和熟悉程度等。 
    经验表明，在其他方面相同的情况下，人们不应期望仅仅通过切换文件系统或进行较小的文件系统配置调整以造成明显的性能或行为更改。
   </para>
<!-- pgdoc-cn_end sig_en=8720cce6afd70fb34008e6ac30c57ef0 -->

   <sect3 id="creating-cluster-nfs">
<!-- pgdoc-cn_start sig_en=4b83f796ef819eff3ceb1fc9e8eda8a2 sig_cn_org=None source=14.1 
    <title>NFS</title>
________________________________________________________-->
    <title>NFS</title>
<!-- pgdoc-cn_end sig_en=4b83f796ef819eff3ceb1fc9e8eda8a2 -->

<!-- pgdoc-cn_start sig_en=a344f5cd6d03d921498405b3d2c4d90a sig_cn_org=None source=14.1 
    <indexterm zone="creating-cluster-nfs">
     <primary>NFS</primary>
    </indexterm>
________________________________________________________-->
    <indexterm zone="creating-cluster-nfs">
     <primary>NFS</primary>
    </indexterm>
<!-- pgdoc-cn_end sig_en=a344f5cd6d03d921498405b3d2c4d90a -->

<!-- pgdoc-cn_start sig_en=e46c66efac1879103faf1c7aaa25cf56 sig_cn_org=None source=14.1 
    <para>
     It is possible to use an <acronym>NFS</acronym> file system for storing
     the <productname>PostgreSQL</productname> data directory.
     <productname>PostgreSQL</productname> does nothing special for
     <acronym>NFS</acronym> file systems, meaning it assumes
     <acronym>NFS</acronym> behaves exactly like locally-connected drives.
     <productname>PostgreSQL</productname> does not use any functionality that
     is known to have nonstandard behavior on <acronym>NFS</acronym>, such as
     file locking.
    </para>
________________________________________________________-->
    <para>
     可以用 <acronym>NFS</acronym>文件系统来存储 <productname>PostgreSQL</productname>数据目录。
     <productname>PostgreSQL</productname>没有特殊对待<acronym>NFS</acronym>文件系统，这意味着它假定<acronym>NFS</acronym>的行为与本地连接的驱动器完全一样。
     <productname>PostgreSQL</productname>不使用任何已知在<acronym>NFS</acronym>上非标准的功能，例如文件锁定。
    </para>
<!-- pgdoc-cn_end sig_en=e46c66efac1879103faf1c7aaa25cf56 -->

<!-- pgdoc-cn_start sig_en=2289225006777a66baa88100d508f8a5 sig_cn_org=None source=14.1 
    <para>
     The only firm requirement for using <acronym>NFS</acronym> with
     <productname>PostgreSQL</productname> is that the file system is mounted
     using the <literal>hard</literal> option.  With the
     <literal>hard</literal> option, processes can <quote>hang</quote>
     indefinitely if there are network problems, so this configuration will
     require a careful monitoring setup.  The <literal>soft</literal> option
     will interrupt system calls in case of network problems, but
     <productname>PostgreSQL</productname> will not repeat system calls
     interrupted in this way, so any such interruption will result in an I/O
     error being reported.
    </para>
________________________________________________________-->
    <para>
     在<productname>PostgreSQL</productname>使用<acronym>NFS</acronym> 的唯一硬性要求是，文件系统需要使用 <literal>hard</literal> 选项挂载。 
     使用<literal>hard</literal>选项，如果存在网络问题，进程可以无限期地<quote>hang</quote>，因此这个配置需要仔细的监视设置。 
     <literal>soft</literal> 选项将在出现网络问题时中断系统调用，但 <productname>PostgreSQL</productname> 不会重复系统呼叫以这种方式中断，因此任何此类中断都将导致报告 I/O 错误。
    </para>
<!-- pgdoc-cn_end sig_en=2289225006777a66baa88100d508f8a5 -->

<!-- pgdoc-cn_start sig_en=3d3a3ef4bc79fc9dce1a01c99e923081 sig_cn_org=None source=14.1 
    <para>
     It is not necessary to use the <literal>sync</literal> mount option.  The
     behavior of the <literal>async</literal> option is sufficient, since
     <productname>PostgreSQL</productname> issues <literal>fsync</literal>
     calls at appropriate times to flush the write caches.  (This is analogous
     to how it works on a local file system.)  However, it is strongly
     recommended to use the <literal>sync</literal> export option on the NFS
     <emphasis>server</emphasis> on systems where it exists (mainly Linux).
     Otherwise, an <literal>fsync</literal> or equivalent on the NFS client is
     not actually guaranteed to reach permanent storage on the server, which
     could cause corruption similar to running with the parameter <xref
     linkend="guc-fsync"/> off.  The defaults of these mount and export
     options differ between vendors and versions, so it is recommended to
     check and perhaps specify them explicitly in any case to avoid any
     ambiguity.
    </para>
________________________________________________________-->
    <para>
     <literal>sync</literal>挂载选项不是必须的。 
     <literal>async</literal>选项的特性是足够的，因为 <productname>PostgreSQL</productname> 发出 <literal>fsync</literal>调用，会在适当的时候刷新写缓存。（这与它在本地文件系统上的工作方式相类似。）
     但是，强烈建议在部署NFS <emphasis>server</emphasis> 的系统上使用<literal>sync</literal>导出选项（主要是Linux）。
     否则，NFS 客户端上的 <literal>fsync</literal> 或等效项实际上不能保证实现服务器上的永久存储，这可能会导致损坏，类似于使用参数 <xref linkend="guc-fsync"/>关闭。 
     这些挂载和导出选项的默认值在供应商和版本之间有所不同，因此建议在任何情况下检查并明确指定它们，以避免任何歧义。
    </para>
<!-- pgdoc-cn_end sig_en=3d3a3ef4bc79fc9dce1a01c99e923081 -->

<!-- pgdoc-cn_start sig_en=4de467b78cea1da6ec674a5ad9d109ea sig_cn_org=None source=14.1 
    <para>
     In some cases, an external storage product can be accessed either via NFS
     or a lower-level protocol such as iSCSI.  In the latter case, the storage
     appears as a block device and any available file system can be created on
     it.  That approach might relieve the DBA from having to deal with some of
     the idiosyncrasies of NFS, but of course the complexity of managing
     remote storage then happens at other levels.
    </para>
________________________________________________________-->
    <para>
     在某些情况下，可以通过 NFS 或较低级别的协议，例如 iSCSI，访问外部存储产品。 
     在后一种情况下，存储显示为块设备，可以在其上创建任何可用的文件系统。
     这种方法可能会使 DBA 不必处理 NFS 的一些特性，但是在其他级别当然会出现管理远程存储的复杂性。
    </para>
<!-- pgdoc-cn_end sig_en=4de467b78cea1da6ec674a5ad9d109ea -->
   </sect3>
  </sect2>

 </sect1>

 <sect1 id="server-start">
<!-- pgdoc-cn_start sig_en=832643deb51c60e29d8f7a197a831038 sig_cn_org=None source=14.1 
  <title>Starting the Database Server</title>
________________________________________________________-->
  <title>启动数据库服务器</title>
<!-- pgdoc-cn_end sig_en=832643deb51c60e29d8f7a197a831038 -->

<!-- pgdoc-cn_start sig_en=98f40cd8e4ededbb1040fd65a769bace sig_cn_org=None source=14.1 
  <para>
   Before anyone can access the database, you must start the database
   server. The database server program is called
   <command>postgres</command>.<indexterm><primary>postgres</primary></indexterm>
  </para>
________________________________________________________-->
  <para>
   在任何人可以访问数据库前，你必须启动数据库服务器。 数据库服务器程序是<command>postgres</command><indexterm><primary>postgres</primary></indexterm>
  </para>
<!-- pgdoc-cn_end sig_en=98f40cd8e4ededbb1040fd65a769bace -->

<!-- pgdoc-cn_start sig_en=810403b83ecd73f0e5efc8dfd1b43897 sig_cn_org=None source=14.1 
  <para>
   If you are using a pre-packaged version
   of <productname>PostgreSQL</productname>, it almost certainly includes
   provisions for running the server as a background task according to the
   conventions of your operating system.  Using the package's
   infrastructure to start the server will be much less work than figuring
   out how to do this yourself.  Consult the package-level documentation
   for details.
  </para>
________________________________________________________-->
  <para>
   如果您使用的是 <productname>PostgreSQL</productname> 的预打包版本，那么几乎可以肯定的是，它包含了根据操作系统的约定将服务器作为后台任务运行的规定。
   使用包的基础设施来启动服务器比自己弄清楚如何启动要简单得多。有关详细信息，请参阅包级文档。
  </para>
<!-- pgdoc-cn_end sig_en=810403b83ecd73f0e5efc8dfd1b43897 -->

<!-- pgdoc-cn_start sig_en=c00bbea317bc826859559cc82445a4d8 sig_cn_org=None source=14.1 
  <para>
   The bare-bones way to start the server manually is just to invoke
   <command>postgres</command> directly, specifying the location of the
   data directory with the <option>-D</option> option, for example:
<screen>
$ <userinput>postgres -D /usr/local/pgsql/data</userinput>
</screen>
   which will leave the server running in the foreground. This must be
   done while logged into the <productname>PostgreSQL</productname> user
   account. Without <option>-D</option>, the server will try to use
   the data directory named by the environment variable <envar>PGDATA</envar>.
   If that variable is not provided either, it will fail.
  </para>
________________________________________________________-->
  <para>
   手动启动服务器的基本方法是直接调用 <command>postgres</command>，使用 <option>-D</option> 选项指定数据目录的位置，例如：
<screen>
$ <userinput>postgres -D /usr/local/pgsql/data</userinput>
</screen>
   这将把服务器放在前台运行。这个步骤同样必须以<productname>PostgreSQL</productname>用户帐户登录来操作。如果没有<option>-D</option>选项，服务器将尝试使用环境变量<envar>PGDATA</envar>命名的目录。如果这个环境变量也没有提供则导致失败。
  </para>
<!-- pgdoc-cn_end sig_en=c00bbea317bc826859559cc82445a4d8 -->

<!-- pgdoc-cn_start sig_en=bd73181e0ee5e48c90a24611858ea397 sig_cn_org=None source=14.1 
  <para>
   Normally it is better to start <command>postgres</command> in the
   background.  For this, use the usual Unix shell syntax:
<screen>
$ <userinput>postgres -D /usr/local/pgsql/data &gt;logfile 2&gt;&amp;1 &amp;</userinput>
</screen>
   It is important to store the server's <systemitem>stdout</systemitem> and
   <systemitem>stderr</systemitem> output somewhere, as shown above. It will help
   for auditing purposes and to diagnose problems. (See <xref
   linkend="logfile-maintenance"/> for a more thorough discussion of log
   file handling.)
  </para>
________________________________________________________-->
  <para>
   通常最好在后台启动<command>postgres</command>。要这样做，使用常用的 Unix shell 语法：
<screen>
$ <userinput>postgres -D /usr/local/pgsql/data &gt;logfile 2&gt;&amp;1 &amp;</userinput>
</screen>
   如上所示，把服务器的<systemitem>stdout</systemitem>和<systemitem>stderr</systemitem>输出存储到某个地方是非常重要的。这将对审计目的和诊断问题有所帮助（更深入的有关日志文件处理的讨论请见（<xref linkend="logfile-maintenance"/>）。
  </para>
<!-- pgdoc-cn_end sig_en=bd73181e0ee5e48c90a24611858ea397 -->

<!-- pgdoc-cn_start sig_en=592e61fae7c4836a5d39e5f050882a91 sig_cn_org=None source=14.1 
  <para>
   The <command>postgres</command> program also takes a number of other
   command-line options. For more information, see the
   <xref linkend="app-postgres"/> reference page
   and <xref linkend="runtime-config"/> below.
  </para>
________________________________________________________-->
  <para>
   <command>postgres</command>还接受其它一些命令行选项。更多的信息请见<xref linkend="app-postgres"/>参考页 和下面的<xref linkend="runtime-config"/>。
  </para>
<!-- pgdoc-cn_end sig_en=592e61fae7c4836a5d39e5f050882a91 -->

<!-- pgdoc-cn_start sig_en=ec4b41752d90f9e722cf3da2358fb1e7 sig_cn_org=None source=14.1 
  <para>
   This shell syntax can get tedious quickly.  Therefore the wrapper
   program
   <xref linkend="app-pg-ctl"/><indexterm><primary>pg_ctl</primary></indexterm>
   is provided to simplify some tasks.  For example:
<programlisting>
pg_ctl start -l logfile
</programlisting>
   will start the server in the background and put the output into the
   named log file. The <option>-D</option> option has the same meaning
   here as for <command>postgres</command>. <command>pg_ctl</command>
   is also capable of stopping the server.
  </para>
________________________________________________________-->
  <para>
   这些 shell 语法很容易让人觉得无聊。因此我们提供了包装器程序<xref linkend="app-pg-ctl"/><indexterm><primary>pg_ctl</primary></indexterm>以简化一些任务。例如：
<programlisting>
pg_ctl start -l logfile
</programlisting>
   将在后台启动服务器并且把输出放到指定的日志文件中。<option>-D</option>选项和<command>postgres</command>中的一样。<command>pg_ctl</command>还可以用于停止服务器。
  </para>
<!-- pgdoc-cn_end sig_en=ec4b41752d90f9e722cf3da2358fb1e7 -->

<!-- pgdoc-cn_start sig_en=8e57601a3c2a9065094d0d0d810966e5 sig_cn_org=None source=14.1 
  <para>
   Normally, you will want to start the database server when the
   computer boots.<indexterm>
     <primary>booting</primary>
     <secondary>starting the server during</secondary>
   </indexterm>
   Autostart scripts are operating-system-specific.
   There are a few example scripts distributed with
   <productname>PostgreSQL</productname> in the
   <filename>contrib/start-scripts</filename> directory. Installing one will require
   root privileges.
  </para>
________________________________________________________-->
  <para>
   通常，你会希望在计算机启动的时候启动数据库服务器。<indexterm><primary>booting</primary><secondary>starting the server during</secondary></indexterm>自动启动脚本是操作系统相关的。在 <filename>contrib/start-scripts</filename> 目录中有一些随 <productname>PostgreSQL</productname> 分发的示例脚本。安装将需要 root 权限。
  </para>
<!-- pgdoc-cn_end sig_en=8e57601a3c2a9065094d0d0d810966e5 -->

<!-- pgdoc-cn_start sig_en=48ee61e9b26bd716e0f4725d4bc6a4ab sig_cn_org=None source=14.1 
  <para>
   Different systems have different conventions for starting up daemons
   at boot time. Many systems have a file
   <filename>/etc/rc.local</filename> or
   <filename>/etc/rc.d/rc.local</filename>. Others use <filename>init.d</filename> or
   <filename>rc.d</filename> directories. Whatever you do, the server must be
   run by the <productname>PostgreSQL</productname> user account
   <emphasis>and not by root</emphasis> or any other user. Therefore you
   probably should form your commands using
   <literal>su postgres -c '...'</literal>.  For example:
<programlisting>
su postgres -c 'pg_ctl start -D /usr/local/pgsql/data -l serverlog'
</programlisting>
  </para>
________________________________________________________-->
  <para>
   不同的系统在引导时有不同的启动守护进程的习惯。许多系统有一个文件<filename>/etc/rc.local</filename>或<filename>/etc/rc.d/rc.local</filename>。其他的使用<filename>init.d</filename>或<filename>rc.d</filename>目录。不管你做什么，服务器必须由<productname>PostgreSQL</productname>用户账户<emphasis>而不是 root</emphasis>或任何其他用户启动。因此你可能应该在你的命令中使用<literal>su postgres -c '...'</literal>这种形式。例如：
<programlisting>
su postgres -c 'pg_ctl start -D /usr/local/pgsql/data -l serverlog'
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=48ee61e9b26bd716e0f4725d4bc6a4ab -->

<!-- pgdoc-cn_start sig_en=5257449f5d30451617f8c5b14f4397a0 sig_cn_org=0f24c4c74785e4a2b1911a6e94cf182c source=15.7 
  <para>
   Here are a few more operating-system-specific suggestions. (In each
   case be sure to use the proper installation directory and user
   name where we show generic values.)

   <itemizedlist>
    <listitem>
     <para>
      For <productname>FreeBSD</productname>, look at the file
      <filename>contrib/start-scripts/freebsd</filename> in the
      <productname>PostgreSQL</productname> source distribution.
      <indexterm><primary>FreeBSD</primary><secondary>start script</secondary></indexterm>
     </para>
    </listitem>

    <listitem>
     <para>
      On <productname>OpenBSD</productname>, add the following lines
      to the file <filename>/etc/rc.local</filename>:
      <indexterm><primary>OpenBSD</primary><secondary>start script</secondary></indexterm>
<programlisting>
if [ -x /usr/local/pgsql/bin/pg_ctl -a -x /usr/local/pgsql/bin/postgres ]; then
    su -l postgres -c '/usr/local/pgsql/bin/pg_ctl start -s -l /var/postgresql/log -D /usr/local/pgsql/data'
    echo -n ' postgresql'
fi
</programlisting>
     </para>
    </listitem>

    <listitem>
     <para>
      On <productname>Linux</productname> systems either add
      <indexterm><primary>Linux</primary><secondary>start script</secondary></indexterm>
<programlisting>
/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/data
</programlisting>
      to <filename>/etc/rc.d/rc.local</filename>
      or <filename>/etc/rc.local</filename> or look at the file
      <filename>contrib/start-scripts/linux</filename> in the
      <productname>PostgreSQL</productname> source distribution.
     </para>

     <para>
      When using <application>systemd</application>, you can use the following
      service unit file (e.g.,
      at <filename>/etc/systemd/system/postgresql.service</filename>):<indexterm><primary>systemd</primary></indexterm>
<programlisting>
[Unit]
Description=PostgreSQL database server
Documentation=man:postgres(1)
After=network-online.target
Wants=network-online.target

[Service]
Type=notify
User=postgres
ExecStart=/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data
ExecReload=/bin/kill -HUP $MAINPID
KillMode=mixed
KillSignal=SIGINT
TimeoutSec=infinity

[Install]
WantedBy=multi-user.target
</programlisting>
      Using <literal>Type=notify</literal> requires that the server binary was
      built with <literal>configure -&minus;with-systemd</literal>.
     </para>

     <para>
      Consider carefully the timeout
      setting.  <application>systemd</application> has a default timeout of 90
      seconds as of this writing and will kill a process that does not report
      readiness within that time.  But a <productname>PostgreSQL</productname>
      server that might have to perform crash recovery at startup could take
      much longer to become ready.  The suggested value
      of <literal>infinity</literal> disables the timeout logic.
     </para>
    </listitem>

    <listitem>
     <para>
      On <productname>NetBSD</productname>, use either the
      <productname>FreeBSD</productname> or
      <productname>Linux</productname> start scripts, depending on
      preference.
      <indexterm><primary>NetBSD</primary><secondary>start script</secondary></indexterm>
     </para>
    </listitem>

    <listitem>
     <para>
      On <productname>Solaris</productname>, create a file called
      <filename>/etc/init.d/postgresql</filename> that contains
      the following line:
      <indexterm><primary>Solaris</primary><secondary>start script</secondary></indexterm>
<programlisting>
su - postgres -c "/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/data"
</programlisting>
      Then, create a symbolic link to it in <filename>/etc/rc3.d</filename> as
      <filename>S99postgresql</filename>.
     </para>
    </listitem>
   </itemizedlist>

  </para>
________________________________________________________-->
  <para>
   这里有一些更多的操作系统特定建议。（在每种情况下，请确保使用正确的安装目录和用户名称，我们展示的是通用值。）

   <itemizedlist>
    <listitem>
     <para>
      对于<productname>FreeBSD</productname>，查看<filename>contrib/start-scripts/freebsd</filename>文件在<productname>PostgreSQL</productname>源分发中。
      <indexterm><primary>FreeBSD</primary><secondary>start script</secondary></indexterm>
     </para>
    </listitem>

    <listitem>
     <para>
      在<productname>OpenBSD</productname>上，添加以下行到文件<filename>/etc/rc.local</filename>：
      <indexterm><primary>OpenBSD</primary><secondary>start script</secondary></indexterm>
<programlisting>
if [ -x /usr/local/pgsql/bin/pg_ctl -a -x /usr/local/pgsql/bin/postgres ]; then
    su -l postgres -c '/usr/local/pgsql/bin/pg_ctl start -s -l /var/postgresql/log -D /usr/local/pgsql/data'
    echo -n ' postgresql'
fi
</programlisting>
     </para>
    </listitem>

    <listitem>
     <para>
      在<productname>Linux</productname>系统上，要么添加
      <indexterm><primary>Linux</primary><secondary>start script</secondary></indexterm>
<programlisting>
/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/data
</programlisting>
      到<filename>/etc/rc.d/rc.local</filename>
      或<filename>/etc/rc.local</filename>，或查看<filename>contrib/start-scripts/linux</filename>文件在<productname>PostgreSQL</productname>源分发中。
     </para>

     <para>
      当使用<application>systemd</application>时，可以使用以下服务单元文件（例如，在<filename>/etc/systemd/system/postgresql.service</filename>）：<indexterm><primary>systemd</primary></indexterm>
<programlisting>
[Unit]
Description=PostgreSQL database server
Documentation=man:postgres(1)
After=network-online.target
Wants=network-online.target

[Service]
Type=notify
User=postgres
ExecStart=/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data
ExecReload=/bin/kill -HUP $MAINPID
KillMode=mixed
KillSignal=SIGINT
TimeoutSec=infinity

[Install]
WantedBy=multi-user.target
</programlisting>
      使用<literal>Type=notify</literal>要求服务器二进制文件使用<literal>configure --with-systemd</literal>构建。
     </para>

     <para>
      仔细考虑超时设置。<application>systemd</application>在撰写本文时有一个默认超时为90秒，并将在该时间内未报告准备就绪的进程。但是，一个可能需要在启动时执行崩溃恢复的<productname>PostgreSQL</productname>服务器可能需要更长时间才能准备就绪。建议值为<literal>infinity</literal>可禁用超时逻辑。
     </para>
    </listitem>

    <listitem>
     <para>
      在<productname>NetBSD</productname>上，根据偏好使用<productname>FreeBSD</productname>或<productname>Linux</productname>启动脚本。
      <indexterm><primary>NetBSD</primary><secondary>start script</secondary></indexterm>
     </para>
    </listitem>

    <listitem>
     <para>
      在<productname>Solaris</productname>上，创建一个名为<filename>/etc/init.d/postgresql</filename>的文件，其中包含以下行：
      <indexterm><primary>Solaris</primary><secondary>start script</secondary></indexterm>
<programlisting>
su - postgres -c "/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/data"
</programlisting>
      然后，在<filename>/etc/rc3.d</filename>中创建一个符号链接为<filename>S99postgresql</filename>。
     </para>
    </listitem>
   </itemizedlist>

  </para>
<!-- pgdoc-cn_end sig_en=5257449f5d30451617f8c5b14f4397a0 -->

<!-- pgdoc-cn_start sig_en=502361ad880a4bc5a6e28fb3603ef6ba sig_cn_org=None source=14.1 
   <para>
    While the server is running, its
    <acronym>PID</acronym> is stored in the file
    <filename>postmaster.pid</filename> in the data directory. This is
    used to prevent multiple server instances from
    running in the same data directory and can also be used for
    shutting down the server.
   </para>
________________________________________________________-->
   <para>
    当服务器在运行时，它的<acronym>PID</acronym>被保存在数据目录中的<filename>postmaster.pid</filename>文件。这样做 可以防止多个服务器实例运行在同一个数据目录中，并且也可以被用来关闭服务器。
   </para>
<!-- pgdoc-cn_end sig_en=502361ad880a4bc5a6e28fb3603ef6ba -->

   <sect2 id="server-start-failures">
<!-- pgdoc-cn_start sig_en=ddd721cae0db79505c0bd455a0f42db2 sig_cn_org=None source=14.1 
    <title>Server Start-up Failures</title>
________________________________________________________-->
    <title>服务器启动失败</title>
<!-- pgdoc-cn_end sig_en=ddd721cae0db79505c0bd455a0f42db2 -->

<!-- pgdoc-cn_start sig_en=e0264042bc0e7cf80ab996e6c99a308c sig_cn_org=None source=14.1 
    <para>
     There are several common reasons the server might fail to
     start. Check the server's log file, or start it by hand (without
     redirecting standard output or standard error) and see what error
     messages appear. Below we explain some of the most common error
     messages in more detail.
    </para>
________________________________________________________-->
    <para>
     有几个常见的原因会导致服务器启动失败。通过检查服务器日志或使用手工启动的方法（不做标准输出或标准错误的重定向）， 就可以看到出现什么错误消息。下面我们详细地解释一些最常见的错误消息。
    </para>
<!-- pgdoc-cn_end sig_en=e0264042bc0e7cf80ab996e6c99a308c -->

<!-- pgdoc-cn_start sig_en=ca439a6e37281e701d8b11958675ad15 sig_cn_org=None source=14.1 
    <para>
<screen>
LOG:  could not bind IPv4 address "127.0.0.1": Address already in use
HINT:  Is another postmaster already running on port 5432? If not, wait a few seconds and retry.
FATAL:  could not create any TCP/IP sockets
</screen>
     This usually means just what it suggests: you tried to start
     another server on the same port where one is already running.
     However, if the kernel error message is not <computeroutput>Address
     already in use</computeroutput> or some variant of that, there might
     be a different problem. For example, trying to start a server
     on a reserved port number might draw something like:
<screen>
$ <userinput>postgres -p 666</userinput>
LOG:  could not bind IPv4 address "127.0.0.1": Permission denied
HINT:  Is another postmaster already running on port 666? If not, wait a few seconds and retry.
FATAL:  could not create any TCP/IP sockets
</screen>
    </para>
________________________________________________________-->
    <para>
<screen>
LOG:  could not bind IPv4 address "127.0.0.1": Address already in use
HINT:  Is another postmaster already running on port 5432? If not, wait a few seconds and retry.
FATAL:  could not create any TCP/IP sockets
</screen>
     正如这个消息所说的，这表示：你试图在一个已经有服务器运行着的端口上再启动另一个服务器。不过，如果核心错误消息不是<computeroutput>Address already in use</computeroutput>或其变体，那就有可能是别的问题。 例如，试图在一个被保留的端口上启动服务器会收到下面这样的消息：
<screen>
$ <userinput>postgres -p 666</userinput>
LOG:  could not bind IPv4 address "127.0.0.1": Permission denied
HINT:  Is another postmaster already running on port 666? If not, wait a few seconds and retry.
FATAL:  could not create any TCP/IP sockets
</screen>
    </para>
<!-- pgdoc-cn_end sig_en=ca439a6e37281e701d8b11958675ad15 -->

<!-- pgdoc-cn_start sig_en=9514fd9b4ab9394a04e0677b6f5d5a78 sig_cn_org=None source=14.1 
    <para>
     A message like:
<screen>
FATAL:  could not create shared memory segment: Invalid argument
DETAIL:  Failed system call was shmget(key=5440001, size=4011376640, 03600).
</screen>
     probably means your kernel's limit on the size of shared memory is
     smaller than the work area <productname>PostgreSQL</productname>
     is trying to create (4011376640 bytes in this example).
     This is only likely to happen if you have set <literal>shared_memory_type</literal>
     to <literal>sysv</literal>.  In that case, you
     can try starting the server with a smaller-than-normal number of
     buffers (<xref linkend="guc-shared-buffers"/>), or
     reconfigure your kernel to increase the allowed shared memory
     size. You might also see this message when trying to start multiple
     servers on the same machine, if their total space requested
     exceeds the kernel limit.
    </para>
________________________________________________________-->
    <para>
     像这样的消息：
<screen>
FATAL:  could not create shared memory segment: Invalid argument
DETAIL:  Failed system call was shmget(key=5440001, size=4011376640, 03600).
</screen>
     可能意味着你的内核对共享内存区的限制小于<productname>PostgreSQL</productname>试图创建的工作区域（本例中是 4011376640 字节）。这只有在您将 <literal>shared_memory_type</literal> 设置为 <literal>sysv</literal> 时才有可能发生。在这种情况下，你可以试着以小于正常数量的缓冲区（<xref linkend="guc-shared-buffers"/>）启动服务器，或者重新配置内核以增加共享内存允许的尺寸。 当你试图在同一台机器上启动多个服务器，并且它们所需的总空间超过了内核的限制，也会报这个错。
    </para>
<!-- pgdoc-cn_end sig_en=9514fd9b4ab9394a04e0677b6f5d5a78 -->

<!-- pgdoc-cn_start sig_en=30437d9c2f0c082a6f017899dc28bab0 sig_cn_org=None source=14.1 
    <para>
     An error like:
<screen>
FATAL:  could not create semaphores: No space left on device
DETAIL:  Failed system call was semget(5440126, 17, 03600).
</screen>
     does <emphasis>not</emphasis> mean you've run out of disk
     space. It means your kernel's limit on the number of <systemitem
     class="osname">System V</systemitem> semaphores is smaller than the number
     <productname>PostgreSQL</productname> wants to create. As above,
     you might be able to work around the problem by starting the
     server with a reduced number of allowed connections
     (<xref linkend="guc-max-connections"/>), but you'll eventually want to
     increase the kernel limit.
    </para>
________________________________________________________-->
    <para>
     一个这样的错误：
<screen>
FATAL:  could not create semaphores: No space left on device
DETAIL:  Failed system call was semget(5440126, 17, 03600).
</screen>
     并<emphasis>不</emphasis>意味着你已经用光了磁盘空间。它的意思是你的内核对<systemitem class="osname">System V</systemitem>信号量的限制小于<productname>PostgreSQL</productname>想创建的数量。和上面一样，你可以通过减少允许的连接数（<xref linkend="guc-max-connections"/>）来绕开这个限制，但最终你还是会希望提高内核的限制。
    </para>
<!-- pgdoc-cn_end sig_en=30437d9c2f0c082a6f017899dc28bab0 -->

<!-- pgdoc-cn_start sig_en=fe946ff2173cafe8d469fbf5522c2fa8 sig_cn_org=None source=14.1 
    <para>
     Details about configuring <systemitem class="osname">System V</systemitem>
     <acronym>IPC</acronym> facilities are given in <xref linkend="sysvipc"/>.
    </para>
________________________________________________________-->
    <para>
     关于配置<systemitem class="osname">System V</systemitem> <acronym>IPC</acronym>功能的细节请见<xref linkend="sysvipc"/>。
    </para>
<!-- pgdoc-cn_end sig_en=fe946ff2173cafe8d469fbf5522c2fa8 -->
   </sect2>

   <sect2 id="client-connection-problems">
<!-- pgdoc-cn_start sig_en=eb358ddf8ccadb03136aa83b5001c40d sig_cn_org=None source=14.1 
    <title>Client Connection Problems</title>
________________________________________________________-->
    <title>客户端连接问题</title>
<!-- pgdoc-cn_end sig_en=eb358ddf8ccadb03136aa83b5001c40d -->

<!-- pgdoc-cn_start sig_en=f2614090fe34c213eb135b8669574b96 sig_cn_org=None source=14.1 
    <para>
     Although the error conditions possible on the client side are quite
     varied and application-dependent, a few of them might be directly
     related to how the server was started. Conditions other than
     those shown below should be documented with the respective client
     application.
    </para>
________________________________________________________-->
    <para>
     尽管可能在客户端出现的错误情况范围宽广而且是应用相关的，但的确有几种与服务器的启动方式直接相关。除了下面提到的几种错误之外的问题都应该在相应的客户端应用文档中。
    </para>
<!-- pgdoc-cn_end sig_en=f2614090fe34c213eb135b8669574b96 -->

<!-- pgdoc-cn_start sig_en=02d9a713e3f8e15d81cd5eb7c132514a sig_cn_org=None source=14.1 
    <para>
<screen>
psql: error: connection to server at "server.joe.com" (123.123.123.123), port 5432 failed: Connection refused
        Is the server running on that host and accepting TCP/IP connections?
</screen>
     This is the generic <quote>I couldn't find a server to talk
     to</quote> failure. It looks like the above when TCP/IP
     communication is attempted. A common mistake is to forget to
     configure the server to allow TCP/IP connections.
    </para>
________________________________________________________-->
    <para>
<screen>
psql: error: connection to server at "server.joe.com" (123.123.123.123), port 5432 failed: Connection refused
        Is the server running on that host and accepting TCP/IP connections?
</screen>
     这是常见的<quote>I couldn't find a server to talk to</quote>失败。上面的情况看起来是发生在尝试 TCP/IP 通信时。常见的错误是忘记把服务器配置成允许 TCP/IP 连接。
    </para>
<!-- pgdoc-cn_end sig_en=02d9a713e3f8e15d81cd5eb7c132514a -->

<!-- pgdoc-cn_start sig_en=3a93532ed6549e678d220375143e0c34 sig_cn_org=None source=14.1 
    <para>
     Alternatively, you might get this when attempting Unix-domain socket
     communication to a local server:
<screen>
psql: error: connection to server on socket "/tmp/.s.PGSQL.5432" failed: No such file or directory
        Is the server running locally and accepting connections on that socket?
</screen>
     If the server is indeed running, check that the client's idea of the
     socket path (here <literal>/tmp</literal>) agrees with the server's
     <xref linkend="guc-unix-socket-directories"/> setting.
    </para>
________________________________________________________-->
    <para>
     另外，当试图通过 Unix 域套接字与本地服务器通信时，你会看到这个：
<screen>
psql: error: connection to server on socket "/tmp/.s.PGSQL.5432" failed: No such file or directory
        Is the server running locally and accepting connections on that socket?
</screen>
     如果服务器确实在运行，检查客户端的套接字路径(这里是 <literal>/tmp</literal>)的理解与服务器的<xref linkend="guc-unix-socket-directories"/>设置的一致性。
    </para>
<!-- pgdoc-cn_end sig_en=3a93532ed6549e678d220375143e0c34 -->

<!-- pgdoc-cn_start sig_en=78ea6d882d1f20f8fd77ef4983c9a554 sig_cn_org=None source=14.1 
    <para>
     A connection failure message always shows the server address or socket
     path name, which is useful in verifying that the client is trying to
     connect to the right place. If there is in fact no server
     listening there, the kernel error message will typically be either
     <computeroutput>Connection refused</computeroutput> or
     <computeroutput>No such file or directory</computeroutput>, as
     illustrated. (It is important to realize that
     <computeroutput>Connection refused</computeroutput> in this context
     does <emphasis>not</emphasis> mean that the server got your
     connection request and rejected it. That case will produce a
     different message, as shown in <xref
     linkend="client-authentication-problems"/>.) Other error messages
     such as <computeroutput>Connection timed out</computeroutput> might
     indicate more fundamental problems, like lack of network
     connectivity, or a firewall blocking the connection.
    </para>
________________________________________________________-->
    <para>
     连接失败信息总是显示服务器地址或套接字路径名，有助于验证客户端是不是尝试连接到正确的位置。
     如果实际上没有服务器在那里监听，典型的核心错误消息将是<computeroutput>Connection refused</computeroutput>或<computeroutput>No such file or directory</computeroutput>（值得注意的是这种环境中的<computeroutput>Connection refused</computeroutput>并<emphasis>不</emphasis>表示服务器得到了你的连接请求并拒绝了它。
     那种情况会产生一个不同的消息，如<xref linkend="client-authentication-problems"/>中所示）。
     其它像<computeroutput>Connection timed out</computeroutput>这样的消息可能表示更基础的问题，如缺少网络连接，或者有防火墙阻塞了连接。
    </para>
<!-- pgdoc-cn_end sig_en=78ea6d882d1f20f8fd77ef4983c9a554 -->
   </sect2>
  </sect1>

 <sect1 id="kernel-resources">
<!-- pgdoc-cn_start sig_en=435b2792a7a16d0d36eebf1462b66d20 sig_cn_org=None source=14.1 
  <title>Managing Kernel Resources</title>
________________________________________________________-->
  <title>管理内核资源</title>
<!-- pgdoc-cn_end sig_en=435b2792a7a16d0d36eebf1462b66d20 -->

<!-- pgdoc-cn_start sig_en=cc6fff861c767421229a639d1cb9432a sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> can sometimes exhaust various operating system
   resource limits, especially when multiple copies of the server are running
   on the same system, or in very large installations.  This section explains
   the kernel resources used by <productname>PostgreSQL</productname> and the steps you
   can take to resolve problems related to kernel resource consumption.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>某些时候会耗尽操作系统的各种资源限制，当同一个系统上运行着多个拷贝的服务器或在一个非常大的安装中时尤其如此。本节解释了<productname>PostgreSQL</productname>使用的内核资源以及你可以采取的用于解决内核资源消耗相关问题的步骤。
  </para>
<!-- pgdoc-cn_end sig_en=cc6fff861c767421229a639d1cb9432a -->

  <sect2 id="sysvipc">
<!-- pgdoc-cn_start sig_en=6fc77ec8db37bc10c9bbd17911e52470 sig_cn_org=None source=14.1 
   <title>Shared Memory and Semaphores</title>
________________________________________________________-->
   <title>共享内存和信号量</title>
<!-- pgdoc-cn_end sig_en=6fc77ec8db37bc10c9bbd17911e52470 -->

<!-- pgdoc-cn_start sig_en=dcbce599b0e03d2efb469fd13c1e4d83 sig_cn_org=None source=14.1 
   <indexterm zone="sysvipc">
    <primary>shared memory</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="sysvipc">
    <primary>共享内存</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=dcbce599b0e03d2efb469fd13c1e4d83 -->

<!-- pgdoc-cn_start sig_en=5f7487c57cec1a1cf3332b53cf93c520 sig_cn_org=None source=14.1 
   <indexterm zone="sysvipc">
    <primary>semaphores</primary>
   </indexterm>
________________________________________________________-->
   <indexterm zone="sysvipc">
    <primary>信号量</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=5f7487c57cec1a1cf3332b53cf93c520 -->

<!-- pgdoc-cn_start sig_en=0dde57ad331db74885f610773da2416f sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> requires the operating system to provide
    inter-process communication (<acronym>IPC</acronym>) features, specifically
    shared memory and semaphores.  Unix-derived systems typically provide
    <quote><systemitem class="osname">System V</systemitem></quote> <acronym>IPC</acronym>,
    <quote><systemitem class="osname">POSIX</systemitem></quote> <acronym>IPC</acronym>, or both.
    <systemitem class="osname">Windows</systemitem> has its own implementation of
    these features and is not discussed here.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>需要操作系统提供进程间通信(<acronym>IPC</acronym>)特性，
    特别是共享内存和信号量。Unix驱动的系统通常提供
    <quote><systemitem class="osname">System V</systemitem></quote> <acronym>IPC</acronym>、
    <quote><systemitem class="osname">POSIX</systemitem></quote> <acronym>IPC</acronym>，或者两者都有。
    <systemitem class="osname">Windows</systemitem>有它自己的这些功能的实现，这里不讨论。
   </para>
<!-- pgdoc-cn_end sig_en=0dde57ad331db74885f610773da2416f -->

<!-- pgdoc-cn_start sig_en=b087f57460c1041f3af9ace0f7150e83 sig_cn_org=None source=14.1 
   <para>
    By default, <productname>PostgreSQL</productname> allocates
    a very small amount of System V shared memory, as well as a much larger
    amount of anonymous <function>mmap</function> shared memory.
    Alternatively, a single large System V shared memory region can be used
    (see <xref linkend="guc-shared-memory-type"/>).

    In addition a significant number of semaphores, which can be either
    System V or POSIX style, are created at server startup.  Currently,
    POSIX semaphores are used on Linux and FreeBSD systems while other
    platforms use System V semaphores.
   </para>
________________________________________________________-->
   <para>
    默认情况下，<productname>PostgreSQL</productname>分配很少量的System V共享内存，和大量的匿名的<function>mmap</function> 共享内存。
    或者，可以使用单个大型System V共享内存区域。(参见 <xref linkend="guc-shared-memory-type"/>)。
    另外，在服务器启动时会创建大量信号量，这些信号量可以是System V或POSIX风格。目前，POSIX信号量用于Linux和FreeBSD系统，而其他平台则使用System V信号量。
   </para>
<!-- pgdoc-cn_end sig_en=b087f57460c1041f3af9ace0f7150e83 -->

<!-- pgdoc-cn_start sig_en=901ba6c07d54b525983edfe681b7e65a sig_cn_org=None source=14.1 
   <para>
    System V <acronym>IPC</acronym> features are typically constrained by
    system-wide allocation limits.
    When <productname>PostgreSQL</productname> exceeds one of these limits,
    the server will refuse to start and
    should leave an instructive error message describing the problem
    and what to do about it. (See also <xref
    linkend="server-start-failures"/>.) The relevant kernel
    parameters are named consistently across different systems; <xref
    linkend="sysvipc-parameters"/> gives an overview. The methods to set
    them, however, vary. Suggestions for some platforms are given below.
   </para>
________________________________________________________-->
   <para>
    System V <acronym>IPC</acronym>特性通常受系统范围分配限制的限制。
    当<productname>PostgreSQL</productname>超出了这些限制之一时，服务器会拒绝启动并且并且留下一条有指导性的错误消息，其中描述了问题以及应该怎么做（又见<xref linkend="server-start-failures"/>）。相关的内核参数在不同系统之间的命名方式一致，<xref linkend="sysvipc-parameters"/>给出了一个概述。不过，设置它们的方法却多种多样。下面给出了对于某些平台的建议：
   </para>
<!-- pgdoc-cn_end sig_en=901ba6c07d54b525983edfe681b7e65a -->

   <table id="sysvipc-parameters">
<!-- pgdoc-cn_start sig_en=5bfa21551e6e172bb423e1bbe252ae23 sig_cn_org=None source=14.1 
    <title><systemitem class="osname">System V</systemitem> <acronym>IPC</acronym> Parameters</title>
________________________________________________________-->
    <title><systemitem class="osname">System V</systemitem> <acronym>IPC</acronym>参数</title>
<!-- pgdoc-cn_end sig_en=5bfa21551e6e172bb423e1bbe252ae23 -->

    <tgroup cols="3">
     <colspec colname="col1" colwidth="1*"/>
     <colspec colname="col2" colwidth="3*"/>
     <colspec colname="col3" colwidth="3*"/>
     <thead>
<!-- pgdoc-cn_start sig_en=8ea946533637e4ff034f87a873fecc88 sig_cn_org=None source=14.1 
      <row>
       <entry>Name</entry>
       <entry>Description</entry>
       <entry>Values needed to run one <productname>PostgreSQL</productname> instance</entry>
      </row>
________________________________________________________-->
      <row>
       <entry>名称</entry>
       <entry>描述</entry>
       <entry>运行一个<productname>PostgreSQL</productname>实例所需的值值</entry>
      </row>
<!-- pgdoc-cn_end sig_en=8ea946533637e4ff034f87a873fecc88 -->
     </thead>

     <tbody>
<!-- pgdoc-cn_start sig_en=6cf27cb562cbb618bc6644ad9908e43a sig_cn_org=None source=14.1 
      <row>
       <entry><varname>SHMMAX</varname></entry>
       <entry>Maximum size of shared memory segment (bytes)</entry>
       <entry>at least 1kB, but the default is usually much higher</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><varname>SHMMAX</varname></entry>
       <entry>共享内存段的最大尺寸（字节）</entry>
       <entry>至少 1kB，但是默认值通常要高一些</entry>
      </row>
<!-- pgdoc-cn_end sig_en=6cf27cb562cbb618bc6644ad9908e43a -->

<!-- pgdoc-cn_start sig_en=4f7baa28771252627057aa90edb46a94 sig_cn_org=None source=14.1 
      <row>
       <entry><varname>SHMMIN</varname></entry>
       <entry>Minimum size of shared memory segment (bytes)</entry>
       <entry>1</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><varname>SHMMIN</varname></entry>
       <entry>共享内存段的最小尺寸（字节）</entry>
       <entry>1</entry>
      </row>
<!-- pgdoc-cn_end sig_en=4f7baa28771252627057aa90edb46a94 -->

<!-- pgdoc-cn_start sig_en=2750f72a21dbc3145624674da2565bed sig_cn_org=None source=14.1 
      <row>
       <entry><varname>SHMALL</varname></entry>
       <entry>Total amount of shared memory available (bytes or pages)</entry>
       <entry>same as <varname>SHMMAX</varname> if bytes,
        or <literal>ceil(SHMMAX/PAGE_SIZE)</literal> if pages,
        plus room for other applications</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><varname>SHMALL</varname></entry>
       <entry>可用共享内存的总量（字节或页面）</entry>
       <entry>如果是字节，同<varname>SHMMAX</varname>；如果是页面，
	   为<literal>ceil(SHMMAX/PAGE_SIZE)</literal>，加上其他应用程序的空间</entry>
      </row>
<!-- pgdoc-cn_end sig_en=2750f72a21dbc3145624674da2565bed -->

<!-- pgdoc-cn_start sig_en=1488bfdc7dcf3020bcae0c87dfa26fce sig_cn_org=None source=14.1 
      <row>
       <entry><varname>SHMSEG</varname></entry>
       <entry>Maximum number of shared memory segments per process</entry>
       <entry>only 1 segment is needed, but the default is much higher</entry>
      </row>
________________________________________________________-->
      <row>
       <entry><varname>SHMSEG</varname></entry>
       <entry>每个进程的最大共享内存段数目</entry>
       <entry>只需要 1 段，但是默认值高很多</entry>
      </row>
<!-- pgdoc-cn_end sig_en=1488bfdc7dcf3020bcae0c87dfa26fce -->

<!-- pgdoc-cn_start sig_en=56b426eec20f7573e9a5d177733437b2 sig_cn_org=None source=14.1 
       <row>
        <entry><varname>SHMMNI</varname></entry>
        <entry>Maximum number of shared memory segments system-wide</entry>
        <entry>like <varname>SHMSEG</varname> plus room for other applications</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><varname>SHMMNI</varname></entry>
        <entry>系统范围内的最大共享内存段数目</entry>
        <entry>像<varname>SHMSEG</varname>外加其他应用的空间</entry>
       </row>
<!-- pgdoc-cn_end sig_en=56b426eec20f7573e9a5d177733437b2 -->

<!-- pgdoc-cn_start sig_en=100cf0c582d8bf9a44dd93d3566fe1fd sig_cn_org=None source=14.1 
       <row>
        <entry><varname>SEMMNI</varname></entry>
        <entry>Maximum number of semaphore identifiers (i.e., sets)</entry>
        <entry>at least <literal>ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)</literal> plus room for other applications</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><varname>SEMMNI</varname></entry>
        <entry>信号量标识符（即，集合）的最大数目</entry>
        <entry>at least <literal>ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)</literal> plus room for other applications</entry>
       </row>
<!-- pgdoc-cn_end sig_en=100cf0c582d8bf9a44dd93d3566fe1fd -->

<!-- pgdoc-cn_start sig_en=8776e20358a63a11d981e5fa82a02799 sig_cn_org=None source=14.1 
       <row>
        <entry><varname>SEMMNS</varname></entry>
        <entry>Maximum number of semaphores system-wide</entry>
        <entry><literal>ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16) * 17</literal> plus room for other applications</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><varname>SEMMNS</varname></entry>
        <entry>系统范围内的最大信号量数目</entry>
        <entry><literal>ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16) * 17</literal> plus room for other applications</entry>
       </row>
<!-- pgdoc-cn_end sig_en=8776e20358a63a11d981e5fa82a02799 -->

<!-- pgdoc-cn_start sig_en=b1c5d86e75bc51ceca227a8ce4487f9c sig_cn_org=None source=14.1 
       <row>
        <entry><varname>SEMMSL</varname></entry>
        <entry>Maximum number of semaphores per set</entry>
        <entry>at least 17</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><varname>SEMMSL</varname></entry>
        <entry>每个集合中信号量的最大数目</entry>
        <entry>至少 17</entry>
       </row>
<!-- pgdoc-cn_end sig_en=b1c5d86e75bc51ceca227a8ce4487f9c -->

<!-- pgdoc-cn_start sig_en=4085bfecf00a843438fb0e6dada09443 sig_cn_org=None source=14.1 
       <row>
        <entry><varname>SEMMAP</varname></entry>
        <entry>Number of entries in semaphore map</entry>
        <entry>see text</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><varname>SEMMAP</varname></entry>
        <entry>信号量映射中的项数</entry>
        <entry>见文本</entry>
       </row>
<!-- pgdoc-cn_end sig_en=4085bfecf00a843438fb0e6dada09443 -->

<!-- pgdoc-cn_start sig_en=c350db3dd7ea809c3919dea643e3b29d sig_cn_org=None source=14.1 
       <row>
        <entry><varname>SEMVMX</varname></entry>
        <entry>Maximum value of semaphore</entry>
        <entry>at least 1000 (The default is often 32767; do not change unless necessary)</entry>
       </row>
________________________________________________________-->
       <row>
        <entry><varname>SEMVMX</varname></entry>
        <entry>信号量的最大值</entry>
        <entry>至少 1000 （默认值常常是 32767，如非必要不要更改）</entry>
       </row>
<!-- pgdoc-cn_end sig_en=c350db3dd7ea809c3919dea643e3b29d -->

     </tbody>
    </tgroup>
   </table>

<!-- pgdoc-cn_start sig_en=c048e38e7a1d32084edb2809c72e9a56 sig_cn_org=None source=14.1 
   <para>
    <productname>PostgreSQL</productname> requires a few bytes of System V shared memory
    (typically 48 bytes, on 64-bit platforms) for each copy of the server.
    On most modern operating systems, this amount can easily be allocated.
    However, if you are running many copies of the server or you explicitly
    configure the server to use large amounts of System V shared memory (see
    <xref linkend="guc-shared-memory-type"/> and <xref
    linkend="guc-dynamic-shared-memory-type"/>), it may be necessary to
    increase <varname>SHMALL</varname>, which is the total amount of System V shared
    memory system-wide.  Note that <varname>SHMALL</varname> is measured in pages
    rather than bytes on many systems.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>要求少量字节的 System V 共享内存（在 64 位平台上通常是 48 字节）用于每一个服务器拷贝。在大多数现代操作系统上，这个量很容易得到。
    但是，如果你运行了很多个服务器副本，或者显式配置服务器以使用大量 System V 共享内存(参见 <xref linkend="guc-shared-memory-type"/> 和 <xref linkend="guc-dynamic-shared-memory-type"/>)，
    可能需要增加<varname>SHMALL</varname>（系统范围内 System V 共享内存的总量）。注意在很多系统上<varname>SHMALL</varname>是以页面而不是字节来度量。
   </para>
<!-- pgdoc-cn_end sig_en=c048e38e7a1d32084edb2809c72e9a56 -->

<!-- pgdoc-cn_start sig_en=aa21ebc303c024b62dcd9b16b9d49760 sig_cn_org=None source=14.1 
   <para>
    Less likely to cause problems is the minimum size for shared
    memory segments (<varname>SHMMIN</varname>), which should be at most
    approximately 32 bytes for <productname>PostgreSQL</productname> (it is
    usually just 1). The maximum number of segments system-wide
    (<varname>SHMMNI</varname>) or per-process (<varname>SHMSEG</varname>) are unlikely
    to cause a problem unless your system has them set to zero.
   </para>
________________________________________________________-->
   <para>
    不太可能出问题的是共享内存段的最小尺寸（<varname>SHMMIN</varname>），对<productname>PostgreSQL</productname>来说应该最多大约是 32 字节（通常只是1）。而系统范围（<varname>SHMMNI</varname>）或每个进程（<varname>SHMSEG</varname>）的最大共享内存段数目不太可能会导致问题，除非你的系统把它们设成零。
   </para>
<!-- pgdoc-cn_end sig_en=aa21ebc303c024b62dcd9b16b9d49760 -->

<!-- pgdoc-cn_start sig_en=98e50dd463996e20d86223eed2a813bc sig_cn_org=None source=14.1 
   <para>
    When using System V semaphores,
    <productname>PostgreSQL</productname> uses one semaphore per allowed connection
    (<xref linkend="guc-max-connections"/>), allowed autovacuum worker process
    (<xref linkend="guc-autovacuum-max-workers"/>) and allowed background
    process (<xref linkend="guc-max-worker-processes"/>), in sets of 16.
    Each such set will
    also contain a 17th semaphore which contains a <quote>magic
    number</quote>, to detect collision with semaphore sets used by
    other applications. The maximum number of semaphores in the system
    is set by <varname>SEMMNS</varname>, which consequently must be at least
    as high as <varname>max_connections</varname> plus
    <varname>autovacuum_max_workers</varname> plus <varname>max_wal_senders</varname>,
    plus <varname>max_worker_processes</varname>, plus one extra for each 16
    allowed connections plus workers (see the formula in <xref
    linkend="sysvipc-parameters"/>).  The parameter <varname>SEMMNI</varname>
    determines the limit on the number of semaphore sets that can
    exist on the system at one time.  Hence this parameter must be at
    least <literal>ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)</literal>.
    Lowering the number
    of allowed connections is a temporary workaround for failures,
    which are usually confusingly worded <quote>No space
    left on device</quote>, from the function <function>semget</function>.
   </para>
________________________________________________________-->
   <para>
    当使用System V信号量时，<productname>PostgreSQL</productname>对每个允许的连接（<xref linkend="guc-max-connections"/>）、每个允许的自动清理工作者进程（<xref linkend="guc-autovacuum-max-workers"/>）和每个允许的后台进程（<xref linkend="guc-max-worker-processes"/>）使用一个信号量， 以16个为一个集合。
    每个这种集合还包含第 17 个信号量， 其中存储一个<quote>magic number</quote>，以检测和其它应用使用的信号量集合的冲突。 
    系统里的最大信号量数目是由<varname>SEMMNS</varname>设置的， 因此这个值必须至少和<varname>max_connections</varname>加<varname>autovacuum_max_workers</varname>加<varname>max_wal_senders</varname>加<varname>max_worker_processes</varname>一样大， 并且每 16 个连接外加工作者还要另外加一个（见<xref linkend="sysvipc-parameters"/>中的公式）。
    参数<varname>SEMMNI</varname> 决定系统中同一时刻可以存在的信号量集合的数目限制。因此这个参数必须至少为<literal>ceil((max_connections + autovacuum_max_workers + max_wal_senders + max_worker_processes + 5) / 16)</literal>。降低允许的连接数目是一种临时的绕开失败（来自函数<function>semget</function>）的方法，通常使用让人混乱的措辞<quote>No space left on device</quote>。
   </para>
<!-- pgdoc-cn_end sig_en=98e50dd463996e20d86223eed2a813bc -->

<!-- pgdoc-cn_start sig_en=bf84af9c458a2cc0f66eb0c0ef690281 sig_cn_org=None source=14.1 
   <para>
    In some cases it might also be necessary to increase
    <varname>SEMMAP</varname> to be at least on the order of
    <varname>SEMMNS</varname>.  If the system has this parameter
    (many do not), it defines the size of the semaphore
    resource map, in which each contiguous block of available semaphores
    needs an entry. When a semaphore set is freed it is either added to
    an existing entry that is adjacent to the freed block or it is
    registered under a new map entry. If the map is full, the freed
    semaphores get lost (until reboot). Fragmentation of the semaphore
    space could over time lead to fewer available semaphores than there
    should be.
   </para>
________________________________________________________-->
   <para>
    在某些情况下可能还有必要增大<varname>SEMMAP</varname>，使之至少与<varname>SEMMNS</varname>相近。如果系统有这个参数(很多系统没有)，这个参数定义信号量资源映射的尺寸，在其中每个连续的可用信号量块都需要一项。 每当一个信号量集合被释放，那么它要么会被加入到该与被释放块相邻的一个现有项，或者它会被注册在一个新映射项中。如果映射被填满，被释放的信号量将丢失（直到重启）。因此信号量空间的碎片时间长了会导致可用的信号量比应有的信号量少。
   </para>
<!-- pgdoc-cn_end sig_en=bf84af9c458a2cc0f66eb0c0ef690281 -->

<!-- pgdoc-cn_start sig_en=eb171e68cd3a7faaa59af0e061998c54 sig_cn_org=None source=14.1 
   <para>
    Various other settings related to <quote>semaphore undo</quote>, such as
    <varname>SEMMNU</varname> and <varname>SEMUME</varname>, do not affect
    <productname>PostgreSQL</productname>.
   </para>
________________________________________________________-->
   <para>
    与<quote>semaphore undo</quote>有关的其他各种设置，如<varname>SEMMNU</varname>和<varname>SEMUME</varname>
	不会影响<productname>PostgreSQL</productname>。
   </para>
<!-- pgdoc-cn_end sig_en=eb171e68cd3a7faaa59af0e061998c54 -->

<!-- pgdoc-cn_start sig_en=9be3318418f0b97bbcfeaf4d6e5497ac sig_cn_org=None source=14.1 
   <para>
    When using POSIX semaphores, the number of semaphores needed is the
    same as for System V, that is one semaphore per allowed connection
    (<xref linkend="guc-max-connections"/>), allowed autovacuum worker process
    (<xref linkend="guc-autovacuum-max-workers"/>) and allowed background
    process (<xref linkend="guc-max-worker-processes"/>).
    On the platforms where this option is preferred, there is no specific
    kernel limit on the number of POSIX semaphores.
   </para>
________________________________________________________-->
   <para>
    当使用POSIX信号量时，所需的信号量数量与System V相同，
	即每个允许的连接(<xref linkend="guc-max-connections"/>)、允许的自动清理工作进程
	(<xref linkend="guc-autovacuum-max-workers"/>)和允许的后台进程
	(<xref linkend="guc-max-worker-processes"/>)一个信号量。
	在首选此选项的平台上，POSIX信号量的数量没有特定的内核限制。
   </para>
<!-- pgdoc-cn_end sig_en=9be3318418f0b97bbcfeaf4d6e5497ac -->


    <variablelist>
     <varlistentry>
<!-- pgdoc-cn_start sig_en=6a85332beb59946d3d72b9bdec2e3244 sig_cn_org=None source=14.1 
      <term><systemitem class="osname">AIX</systemitem>
      <indexterm><primary>AIX</primary><secondary>IPC configuration</secondary></indexterm>
      </term>
________________________________________________________-->
      <term><systemitem class="osname">AIX</systemitem>
      <indexterm><primary>AIX</primary><secondary>IPC 配置</secondary></indexterm>
      </term>
<!-- pgdoc-cn_end sig_en=6a85332beb59946d3d72b9bdec2e3244 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=a9b7ee723cbca3866f9fe53c295d484d sig_cn_org=None source=14.1 
       <para>
        It should not be necessary to do
        any special configuration for such parameters as
        <varname>SHMMAX</varname>, as it appears this is configured to
        allow all memory to be used as shared memory.  That is the
        sort of configuration commonly used for other databases such
        as <application>DB/2</application>.</para>
________________________________________________________-->
       <para>
        不再需要对这些参数（例如<varname>SHMMAX</varname>）做任何特殊的配置，这看起来就像是被配置成允许所有内存都被用作共享内存。这是一种通常被用于其他数据库（<application>DB/2</application>）的配置。</para>
<!-- pgdoc-cn_end sig_en=a9b7ee723cbca3866f9fe53c295d484d -->

<!-- pgdoc-cn_start sig_en=06b6d86e865b4bd264e4fdd98a3ed8d2 sig_cn_org=None source=14.1 
       <para> It might, however, be necessary to modify the global
       <command>ulimit</command> information in
       <filename>/etc/security/limits</filename>, as the default hard
       limits for file sizes (<varname>fsize</varname>) and numbers of
       files (<varname>nofiles</varname>) might be too low.
       </para>
________________________________________________________-->
       <para>但是，可能需要修改<filename>/etc/security/limits</filename>中的全局<command>ulimit</command>信息，默认的文件尺寸硬限制（<varname>fsize</varname>）和文件数量（<varname>nofiles</varname>）可能太低。
       </para>
<!-- pgdoc-cn_end sig_en=06b6d86e865b4bd264e4fdd98a3ed8d2 -->
      </listitem>
     </varlistentry>


     <varlistentry>
<!-- pgdoc-cn_start sig_en=63a3e95bf7a3a5f67a0e19a4b3571fe7 sig_cn_org=None source=14.1 
      <term><systemitem class="osname">FreeBSD</systemitem>
      <indexterm><primary>FreeBSD</primary><secondary>IPC configuration</secondary></indexterm>
      </term>
________________________________________________________-->
      <term><systemitem class="osname">FreeBSD</systemitem>
      <indexterm><primary>FreeBSD</primary><secondary>IPC 配置</secondary></indexterm>
      </term>
<!-- pgdoc-cn_end sig_en=63a3e95bf7a3a5f67a0e19a4b3571fe7 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=d1044e4ffdb040713212b310001ef3d7 sig_cn_org=None source=14.1 
       <para>
        The default shared memory settings are usually good enough, unless
        you have set <literal>shared_memory_type</literal> to <literal>sysv</literal>.
        System V semaphores are not used on this platform.
       </para>
________________________________________________________-->
       <para>
        默认共享内存设置通常就足够了，除非您已将 <literal>shared_memory_type</literal> 设置为 <literal>sysv</literal>。 在此平台上不使用 System V 信号量。
       </para>
<!-- pgdoc-cn_end sig_en=d1044e4ffdb040713212b310001ef3d7 -->

<!-- pgdoc-cn_start sig_en=c0a12ff6af70c3847142a396a8e7680d sig_cn_org=None source=14.1 
       <para>
        The default IPC settings can be changed using
        the <command>sysctl</command> or
        <command>loader</command> interfaces.  The following
        parameters can be set using <command>sysctl</command>:
<screen>
<prompt>#</prompt> <userinput>sysctl kern.ipc.shmall=32768</userinput>
<prompt>#</prompt> <userinput>sysctl kern.ipc.shmmax=134217728</userinput>
</screen>
        To make these settings persist over reboots, modify
        <filename>/etc/sysctl.conf</filename>.
       </para>
________________________________________________________-->
       <para>
        可以使用<command>sysctl</command>或<command>loader</command>接口来改变默认IPC配置。下列参数可以使用<command>sysctl</command>设置：
<screen>
<prompt>#</prompt> <userinput>sysctl kern.ipc.shmall=32768</userinput>
<prompt>#</prompt> <userinput>sysctl kern.ipc.shmmax=134217728</userinput>
</screen>
        要让这些设置在重启之后也保持，请修改<filename>/etc/sysctl.conf</filename>。
       </para>
<!-- pgdoc-cn_end sig_en=c0a12ff6af70c3847142a396a8e7680d -->

<!-- pgdoc-cn_start sig_en=90d7fb01fb58b0bfb31c69af767671a2 sig_cn_org=None source=14.1 
       <para>
        If you have set <literal>shared_memory_type</literal> to
        <literal>sysv</literal>, you might also want to configure your kernel
        to lock System V shared memory into RAM and prevent it from being paged
        out to swap.  This can be accomplished using the <command>sysctl</command>
        setting <literal>kern.ipc.shm_use_phys</literal>.
       </para>
________________________________________________________-->
       <para>
        如果您已将 <literal>shared_memory_type</literal> 设置为 <literal>sysv</literal>，您可能还想配置您的内核以将 System V 共享内存锁定到 RAM 中并防止它被调出以进行交换。 这可以使用 <command>sysctl</command> 设置 <literal>kern.ipc.shm_use_phys</literal> 来完成。
       </para>
<!-- pgdoc-cn_end sig_en=90d7fb01fb58b0bfb31c69af767671a2 -->

<!-- pgdoc-cn_start sig_en=7e560d707ea1ee07f5fe35a0eb3ddf55 sig_cn_org=None source=14.1 
       <para>
        If running in a FreeBSD jail, you should set its
        <literal>sysvshm</literal> parameter to <literal>new</literal>, so that
        it has its own separate System V shared memory namespace.
        (Before FreeBSD 11.0, it was necessary to enable shared access to
        the host's IPC namespace from jails, and take measures to avoid
        collisions.)
       </para>
________________________________________________________-->
       <para>
        如果在 FreeBSD jail 中运行，您应该将它的 <literal>sysvshm</literal> 参数设置为 <literal>new</literal>，这样它就有自己独立的 System V 共享内存命名空间。 （在 FreeBSD 11.0 之前，有必要从 jails 启用对主机 IPC 命名空间的共享访问，并采取措施避免冲突。）
       </para>
<!-- pgdoc-cn_end sig_en=7e560d707ea1ee07f5fe35a0eb3ddf55 -->

      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=0f956c7928ad14a91f87ee302c9a5f1e sig_cn_org=None source=14.1 
      <term><systemitem class="osname">NetBSD</systemitem>
      <indexterm><primary>NetBSD</primary><secondary>IPC configuration</secondary></indexterm>
      </term>
________________________________________________________-->
      <term><systemitem class="osname">NetBSD</systemitem>
      <indexterm><primary>NetBSD</primary><secondary>IPC 配置</secondary></indexterm>
      </term>
<!-- pgdoc-cn_end sig_en=0f956c7928ad14a91f87ee302c9a5f1e -->
      <listitem>
<!-- pgdoc-cn_start sig_en=09e8d177f62b40849f93830830086dcb sig_cn_org=None source=14.1 
       <para>
        The default shared memory settings are usually good enough, unless
        you have set <literal>shared_memory_type</literal> to <literal>sysv</literal>.
        You will usually want to increase <literal>kern.ipc.semmni</literal>
        and <literal>kern.ipc.semmns</literal>,
        as <systemitem class="osname">NetBSD</systemitem>'s default settings
        for these are uncomfortably small.
       </para>
________________________________________________________-->
       <para>
        默认共享内存设置通常就足够了，除非您已将 <literal>shared_memory_type</literal> 设置为 <literal>sysv</literal>。作为<systemitem class="osname">NetBSD</systemitem>的默认设置，你总是会想调大<literal>kern.ipc.semmni</literal>和<literal>kern.ipc.semmns</literal>的值，因为他们实在太小了。 
       </para>
<!-- pgdoc-cn_end sig_en=09e8d177f62b40849f93830830086dcb -->

<!-- pgdoc-cn_start sig_en=18f8553b2cce3e9334e23fbef3a4c71f sig_cn_org=None source=14.1 
       <para>
        IPC parameters can be adjusted using <command>sysctl</command>,
        for example:
<screen>
<prompt>#</prompt> <userinput>sysctl -w kern.ipc.semmni=100</userinput>
</screen>
        To make these settings persist over reboots, modify
        <filename>/etc/sysctl.conf</filename>.
       </para>
________________________________________________________-->
       <para>
        可以使用 <command>sysctl</command> 调整 IPC 参数，例如：
<screen>
<prompt>#</prompt> <userinput>sysctl -w kern.ipc.semmni=100</userinput>
</screen>
        要使这些设置在重新启动后保持不变，请修改 <filename>/etc/sysctl.conf</filename>。
       </para>
<!-- pgdoc-cn_end sig_en=18f8553b2cce3e9334e23fbef3a4c71f -->

<!-- pgdoc-cn_start sig_en=90d7fb01fb58b0bfb31c69af767671a2 sig_cn_org=None source=14.1 
       <para>
        If you have set <literal>shared_memory_type</literal> to
        <literal>sysv</literal>, you might also want to configure your kernel
        to lock System V shared memory into RAM and prevent it from being paged
        out to swap.  This can be accomplished using the <command>sysctl</command>
        setting <literal>kern.ipc.shm_use_phys</literal>.
       </para>
________________________________________________________-->
       <para>
        如果您已将 <literal>shared_memory_type</literal> 设置为 <literal>sysv</literal>，您可能还想配置您的内核以将 System V 共享内存锁定到 RAM 中并防止它被调出以进行交换。 这可以使用 <command>sysctl</command> 设置 <literal>kern.ipc.shm_use_phys</literal> 来完成。
       </para>
<!-- pgdoc-cn_end sig_en=90d7fb01fb58b0bfb31c69af767671a2 -->
      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=7fb1620cf54f32b7b6318fb6db164a72 sig_cn_org=None source=14.1 
      <term><systemitem class="osname">OpenBSD</systemitem>
      <indexterm><primary>OpenBSD</primary><secondary>IPC configuration</secondary></indexterm>
      </term>
________________________________________________________-->
      <term><systemitem class="osname">OpenBSD</systemitem>
      <indexterm><primary>OpenBSD</primary><secondary>IPC 配置</secondary></indexterm>
      </term>
<!-- pgdoc-cn_end sig_en=7fb1620cf54f32b7b6318fb6db164a72 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=ab41e5ec930c4f5a5ee2033cda68fb71 sig_cn_org=None source=14.1 
       <para>
        The default shared memory settings are usually good enough, unless
        you have set <literal>shared_memory_type</literal> to <literal>sysv</literal>.
        You will usually want to
        increase <literal>kern.seminfo.semmni</literal>
        and <literal>kern.seminfo.semmns</literal>,
        as <systemitem class="osname">OpenBSD</systemitem>'s default settings
        for these are uncomfortably small.
       </para>
________________________________________________________-->
       <para>
        默认共享内存设置通常就足够了，除非您已将 <literal>shared_memory_type</literal> 设置为 <literal>sysv</literal>。作为<systemitem class="osname">OpenBSD</systemitem>的默认配置，你总是会想调大<literal>kern.seminfo.semmni</literal>和<literal>kern.seminfo.semmns</literal>的值，因为他们实在太小了。
       </para>
<!-- pgdoc-cn_end sig_en=ab41e5ec930c4f5a5ee2033cda68fb71 -->

<!-- pgdoc-cn_start sig_en=c515913b57440d9e287e57f12cd1e63c sig_cn_org=None source=14.1 
       <para>
        IPC parameters can be adjusted using <command>sysctl</command>,
        for example:
<screen>
<prompt>#</prompt> <userinput>sysctl kern.seminfo.semmni=100</userinput>
</screen>
        To make these settings persist over reboots, modify
        <filename>/etc/sysctl.conf</filename>.
       </para>
________________________________________________________-->
       <para>
        可以使用 <command>sysctl</command> 调整 IPC 参数，例如：
<screen>
<prompt>#</prompt> <userinput>sysctl kern.seminfo.semmni=100</userinput>
</screen>
        要使这些设置在重新启动后保持不变，请修改 <filename>/etc/sysctl.conf</filename>。
       </para>
<!-- pgdoc-cn_end sig_en=c515913b57440d9e287e57f12cd1e63c -->

      </listitem>
     </varlistentry>

     <varlistentry>
<!-- pgdoc-cn_start sig_en=a73bebef4d57aab97d517924cc9d7762 sig_cn_org=None source=14.1 
      <term><systemitem class="osname">HP-UX</systemitem>
      <indexterm><primary>HP-UX</primary><secondary>IPC configuration</secondary></indexterm>
      </term>
________________________________________________________-->
      <term><systemitem class="osname">HP-UX</systemitem>
      <indexterm><primary>HP-UX</primary><secondary>IPC 配置</secondary></indexterm>
      </term>
<!-- pgdoc-cn_end sig_en=a73bebef4d57aab97d517924cc9d7762 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=9d568f3f96823a0160bdca50cb221fb0 sig_cn_org=None source=14.1 
       <para>
        The default settings tend to suffice for normal installations.
       </para>
________________________________________________________-->
       <para>
        默认的设置可以满足正常的安装。
       </para>
<!-- pgdoc-cn_end sig_en=9d568f3f96823a0160bdca50cb221fb0 -->
<!-- pgdoc-cn_start sig_en=1d0d2ae4265c4b4256b96abed0192502 sig_cn_org=None source=14.1 
       <para>
        <acronym>IPC</acronym> parameters can be set in the <application>System
        Administration Manager</application> (<acronym>SAM</acronym>) under
        <menuchoice><guimenu>Kernel
        Configuration</guimenu><guimenuitem>Configurable Parameters</guimenuitem></menuchoice>. Choose
        <guibutton>Create A New Kernel</guibutton> when you're done.
       </para>
________________________________________________________-->
       <para>
        <acronym>IPC</acronym>参数可以在<menuchoice><guimenu>Kernel Configuration</guimenu><guimenuitem>Configurable Parameters</guimenuitem></menuchoice>下的<application>System Administration Manager</application>（<acronym>SAM</acronym>）中被设置。当你完成时选择<guibutton>Create A New Kernel</guibutton>。
       </para>
<!-- pgdoc-cn_end sig_en=1d0d2ae4265c4b4256b96abed0192502 -->
      </listitem>
     </varlistentry>


     <varlistentry>
<!-- pgdoc-cn_start sig_en=2e47e685cb20730e62ece5a927ceab15 sig_cn_org=None source=14.1 
      <term><systemitem class="osname">Linux</systemitem>
      <indexterm><primary>Linux</primary><secondary>IPC configuration</secondary></indexterm>
      </term>
________________________________________________________-->
      <term><systemitem class="osname">Linux</systemitem>
      <indexterm><primary>Linux</primary><secondary>IPC 配置</secondary></indexterm>
      </term>
<!-- pgdoc-cn_end sig_en=2e47e685cb20730e62ece5a927ceab15 -->
      <listitem>
<!-- pgdoc-cn_start sig_en=77f23235373d83afeea6b52cdc518ba5 sig_cn_org=None source=14.1 
       <para>
        The default shared memory settings are usually good enough, unless
        you have set <literal>shared_memory_type</literal> to <literal>sysv</literal>,
        and even then only on older kernel versions that shipped with low defaults.
        System V semaphores are not used on this platform.
       </para>
________________________________________________________-->
       <para>
        默认的共享内存设置通常已经足够好了，除非您将<literal>shared_memory_type</literal>设置为<literal>sysv</literal>，即使这样，
        也只适用于低默认值的旧内核版本。System V信号量不在此平台上使用。
       </para>
<!-- pgdoc-cn_end sig_en=77f23235373d83afeea6b52cdc518ba5 -->

<!-- pgdoc-cn_start sig_en=00beac96392392a206c4657786573645 sig_cn_org=None source=14.1 
       <para>
        The shared memory size settings can be changed via the
        <command>sysctl</command> interface.  For example, to allow 16 GB:
<screen>
<prompt>$</prompt> <userinput>sysctl -w kernel.shmmax=17179869184</userinput>
<prompt>$</prompt> <userinput>sysctl -w kernel.shmall=4194304</userinput>
</screen>
        To make these settings persist over reboots, see
        <filename>/etc/sysctl.conf</filename>.
       </para>
________________________________________________________-->
       <para>
        共享内存大小设置可以通过<command>sysctl</command>界面更改。例如，允许 16 GB：
<screen>
<prompt>$</prompt> <userinput>sysctl -w kernel.shmmax=17179869184</userinput>
<prompt>$</prompt> <userinput>sysctl -w kernel.shmall=4194304</userinput>
</screen>
        要使这些设置在重新启动时保持不变，请参见<filename>/etc/sysctl.conf</filename>。
       </para>
<!-- pgdoc-cn_end sig_en=00beac96392392a206c4657786573645 -->

      </listitem>
     </varlistentry>


     <varlistentry>
<!-- pgdoc-cn_start sig_en=aea4c1a04bdd0c0fe7e6eb420e32b7aa sig_cn_org=None source=14.1 
      <term><systemitem class="osname">macOS</systemitem>
      <indexterm><primary>macOS</primary><secondary>IPC configuration</secondary></indexterm>
      </term>
________________________________________________________-->
      <term><systemitem class="osname">macOS</systemitem>
      <indexterm><primary>macOS</primary><secondary>IPC 配置</secondary></indexterm>
      </term>
<!-- pgdoc-cn_end sig_en=aea4c1a04bdd0c0fe7e6eb420e32b7aa -->
      <listitem>
<!-- pgdoc-cn_start sig_en=2a12869ff163f5a84a421c50415c1303 sig_cn_org=None source=14.1 
       <para>
        The default shared memory and semaphore settings are usually good enough, unless
        you have set <literal>shared_memory_type</literal> to <literal>sysv</literal>.
       </para>
________________________________________________________-->
       <para>
        默认共享内存和信号量设置通常就足够了，除非您已将 <literal>shared_memory_type</literal> 设置为 <literal>sysv</literal>。
       </para>
<!-- pgdoc-cn_end sig_en=2a12869ff163f5a84a421c50415c1303 -->
<!-- pgdoc-cn_start sig_en=bb68dc3fd8db378e38e524cb73980a14 sig_cn_org=None source=14.1 
       <para>
        The recommended method for configuring shared memory in macOS
        is to create a file named <filename>/etc/sysctl.conf</filename>,
        containing variable assignments such as:
<programlisting>
kern.sysv.shmmax=4194304
kern.sysv.shmmin=1
kern.sysv.shmmni=32
kern.sysv.shmseg=8
kern.sysv.shmall=1024
</programlisting>
        Note that in some macOS versions,
        <emphasis>all five</emphasis> shared-memory parameters must be set in
        <filename>/etc/sysctl.conf</filename>, else the values will be ignored.
       </para>
________________________________________________________-->
       <para>
        在 macOS 中配置共享内存的推荐方法是创建一个名为<filename>/etc/sysctl.conf</filename>的文件，其中包含这样的变量赋值：
<programlisting>
kern.sysv.shmmax=4194304
kern.sysv.shmmin=1
kern.sysv.shmmni=32
kern.sysv.shmseg=8
kern.sysv.shmall=1024
</programlisting>
        注意在某些 macOS 版本中，<emphasis>所有五个</emphasis>共享内存参数必须在<filename>/etc/sysctl.conf</filename>中设置，否则值将会被忽略。
       </para>
<!-- pgdoc-cn_end sig_en=bb68dc3fd8db378e38e524cb73980a14 -->

<!-- pgdoc-cn_start sig_en=2a5a9c1e52fc2f4c673de5846f334b5c sig_cn_org=None source=14.1 
       <para>
        <varname>SHMMAX</varname> can only be set to a multiple of 4096.
       </para>
________________________________________________________-->
       <para>
        <varname>SHMMAX</varname> 只能设置为 4096 的倍数。
       </para>
<!-- pgdoc-cn_end sig_en=2a5a9c1e52fc2f4c673de5846f334b5c -->

<!-- pgdoc-cn_start sig_en=4639467dac15951b143ad087a897c6cb sig_cn_org=None source=14.1 
       <para>
        <varname>SHMALL</varname> is measured in 4 kB pages on this platform.
       </para>
________________________________________________________-->
       <para>
        在这个平台上，<varname>SHMALL</varname>以 4kB 的页面度量。
       </para>
<!-- pgdoc-cn_end sig_en=4639467dac15951b143ad087a897c6cb -->

<!-- pgdoc-cn_start sig_en=70fd053789e14a27624b7962937f4fb3 sig_cn_org=None source=14.1 
       <para>
        It is possible to change all but <varname>SHMMNI</varname> on the fly, using
        <application>sysctl</application>.  But it's still best to set up your preferred
        values via <filename>/etc/sysctl.conf</filename>, so that the values will be
        kept across reboots.
       </para>
________________________________________________________-->
       <para>
        可以使用 <application>sysctl</application> 动态更改除 <varname>SHMMNI</varname> 之外的所有内容。但是最好还是通过<filename>/etc/sysctl.conf</filename>来设置你喜欢的值，这样重启之后这些值还能被保持。
       </para>
<!-- pgdoc-cn_end sig_en=70fd053789e14a27624b7962937f4fb3 -->

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">Solaris</systemitem></term>
      <term><systemitem class="osname">illumos</systemitem></term>
      <listitem>
<!-- pgdoc-cn_start sig_en=0ebbe0ef31b8c2743122a4ad2a2da909 sig_cn_org=None source=14.1 
       <para>
        The default shared memory and semaphore settings are usually good enough for most
        <productname>PostgreSQL</productname> applications.  Solaris defaults
        to a <varname>SHMMAX</varname> of one-quarter of system <acronym>RAM</acronym>.
        To further adjust this setting, use a project setting associated
        with the <literal>postgres</literal> user.  For example, run the
        following as <literal>root</literal>:
<programlisting>
projadd -c "PostgreSQL DB User" -K "project.max-shm-memory=(privileged,8GB,deny)" -U postgres -G postgres user.postgres
</programlisting>
       </para>
________________________________________________________-->
       <para>
        默认的共享内存和信号量设置对于大多数 <productname>PostgreSQL</productname> 应用程序来说通常已经足够了。Solaris 现在将<varname>SHMMAX</varname>的默认值设置为系统 <acronym>RAM</acronym>的四分之一。要进一步调整这个设置，使用与<literal>postgres</literal>用户有关的一个项目设置。例如，以<literal>root</literal>运行下列命令：
<programlisting>
projadd -c "PostgreSQL DB User" -K "project.max-shm-memory=(privileged,8GB,deny)" -U postgres -G postgres user.postgres
</programlisting>
       </para>
<!-- pgdoc-cn_end sig_en=0ebbe0ef31b8c2743122a4ad2a2da909 -->

<!-- pgdoc-cn_start sig_en=07fc41bc192b12cb07b2d2cbfd0c73d0 sig_cn_org=None source=14.1 
       <para>
        This command adds the <literal>user.postgres</literal> project and
        sets the shared memory maximum for the <literal>postgres</literal>
        user to 8GB, and takes effect the next time that user logs
        in, or when you restart <productname>PostgreSQL</productname> (not reload).
        The above assumes that <productname>PostgreSQL</productname> is run by
        the <literal>postgres</literal> user in the <literal>postgres</literal>
        group.  No server reboot is required.
       </para>
________________________________________________________-->
       <para>
        这个命令增加<literal>user.postgres</literal>项目并且将用于<literal>postgres</literal>用户的最大共享内存设置为 8GB，并且在下次用户登录进来时或重启<productname>PostgreSQL</productname>（不是重新载入）时生效。上述假定<productname>PostgreSQL</productname>是由<literal>postgres</literal>组中的<literal>postgres</literal>用户所运行。不需要重新启动服务器。
       </para>
<!-- pgdoc-cn_end sig_en=07fc41bc192b12cb07b2d2cbfd0c73d0 -->

<!-- pgdoc-cn_start sig_en=8fbf59096021bad9c464c59dfa0d8b3b sig_cn_org=None source=14.1 
       <para>
        Other recommended kernel setting changes for database servers which will
        have a large number of connections are:
<programlisting>
project.max-shm-ids=(priv,32768,deny)
project.max-sem-ids=(priv,4096,deny)
project.max-msg-ids=(priv,4096,deny)
</programlisting>
       </para>
________________________________________________________-->
       <para>
        对于将有巨大数量连接的数据库服务器，我们推荐的其他内核设置修改是：
<programlisting>
project.max-shm-ids=(priv,32768,deny)
project.max-sem-ids=(priv,4096,deny)
project.max-msg-ids=(priv,4096,deny)
</programlisting>
       </para>
<!-- pgdoc-cn_end sig_en=8fbf59096021bad9c464c59dfa0d8b3b -->

<!-- pgdoc-cn_start sig_en=5fb56e7bca890250b803a9cf2414d2ff sig_cn_org=None source=14.1 
       <para>
        Additionally, if you are running <productname>PostgreSQL</productname>
        inside a zone, you may need to raise the zone resource usage
        limits as well.  See "Chapter2:  Projects and Tasks" in the
        <citetitle>System Administrator's Guide</citetitle> for more
        information on <literal>projects</literal> and <command>prctl</command>.
       </para>
________________________________________________________-->
       <para>
        此外，如果你正在在一个区中运行<productname>PostgreSQL</productname>，你可能也需要提升该区的资源使用限制。更多关于<literal>projects</literal> 和<command>prctl</command>的信息请见<citetitle>System Administrator's Guide</citetitle>中的 "Chapter2:  Projects and Tasks"。
       </para>
<!-- pgdoc-cn_end sig_en=5fb56e7bca890250b803a9cf2414d2ff -->
      </listitem>
     </varlistentry>

    </variablelist>

  </sect2>

  <sect2 id="systemd-removeipc">
<!-- pgdoc-cn_start sig_en=cbddaefa2c37ab51ca7a31350feacd8d sig_cn_org=None source=14.1 
   <title>systemd RemoveIPC</title>
________________________________________________________-->
   <title>systemd RemoveIPC</title>
<!-- pgdoc-cn_end sig_en=cbddaefa2c37ab51ca7a31350feacd8d -->

<!-- pgdoc-cn_start sig_en=a898ca5476d5fd7c3283f61887c313bb sig_cn_org=None source=14.1 
   <indexterm>
    <primary>systemd</primary>
    <secondary>RemoveIPC</secondary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>systemd</primary>
    <secondary>RemoveIPC</secondary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=a898ca5476d5fd7c3283f61887c313bb -->

<!-- pgdoc-cn_start sig_en=b63c4136cdd7f1425c0cd487cb43cf51 sig_cn_org=None source=14.1 
   <para>
    If <productname>systemd</productname> is in use, some care must be taken
    that IPC resources (including shared memory) are not prematurely
    removed by the operating system.  This is especially of concern when
    installing PostgreSQL from source.  Users of distribution packages of
    PostgreSQL are less likely to be affected, as
    the <literal>postgres</literal> user is then normally created as a system
    user.
   </para>
________________________________________________________-->
   <para>
    如果正在使用<productname>systemd</productname>，则必须注意IPC资源（包括共享内存）
	不会被操作系统过早删除。从源代码安装PostgreSQL时，这尤其值得关注。
	PostgreSQL发布包的用户不太可能受到影响，因为<literal>postgres</literal>用户通常是作为系统用户创建的。
   </para>
<!-- pgdoc-cn_end sig_en=b63c4136cdd7f1425c0cd487cb43cf51 -->

<!-- pgdoc-cn_start sig_en=12990e7addd708d4f171b74a83401f1c sig_cn_org=None source=14.1 
   <para>
    The setting <literal>RemoveIPC</literal>
    in <filename>logind.conf</filename> controls whether IPC objects are
    removed when a user fully logs out.  System users are exempt.  This
    setting defaults to on in stock <productname>systemd</productname>, but
    some operating system distributions default it to off.
   </para>
________________________________________________________-->
   <para>
    控制当用户完全退出时是否移除IPC对象。系统用户免除。
	此设置在死板的<productname>systemd</productname>中默认为on，
	但某些操作系统分配默认为关闭。
   </para>
<!-- pgdoc-cn_end sig_en=12990e7addd708d4f171b74a83401f1c -->

<!-- pgdoc-cn_start sig_en=3a59bb257274ee629986ff89c46cf71b sig_cn_org=None source=14.1 
   <para>
    A typical observed effect when this setting is on is that shared memory
    objects used for parallel query execution are removed at apparently random
    times, leading to errors and warnings while attempting to open and remove
    them, like
<screen>
WARNING:  could not remove shared memory segment "/PostgreSQL.1450751626": No such file or directory
</screen>
    Different types of IPC objects (shared memory vs. semaphores, System V
    vs. POSIX) are treated slightly differently
    by <productname>systemd</productname>, so one might observe that some IPC
    resources are not removed in the same way as others.  But it is not
    advisable to rely on these subtle differences.
   </para>
________________________________________________________-->
   <para>
    当此设置打开时，典型的观察效果是用于并行查询执行的共享内存对象在明显随机的时间被删除，启用此设置时观察到的典型效果是用于并行查询执行的共享内存对象在明显随机的时间被删除，导致在尝试打开和删除它们时出现错误和警告，例如
<screen>
WARNING:  could not remove shared memory segment "/PostgreSQL.1450751626": No such file or directory
</screen>
    不同类型的IPC对象（共享内存与信号量，System V与POSIX）在<productname>systemd</productname>
	中略有不同，因此可能会发现某些IPC资源不会像其他IPC资源一样被删除。
	但依靠这些微妙的差异是不可取的。
   </para>
<!-- pgdoc-cn_end sig_en=3a59bb257274ee629986ff89c46cf71b -->

<!-- pgdoc-cn_start sig_en=6afb8144acb27c8d4ff1c75dc97e04ab sig_cn_org=None source=14.1 
   <para>
    A <quote>user logging out</quote> might happen as part of a maintenance
    job or manually when an administrator logs in as
    the <literal>postgres</literal> user or something similar, so it is hard
    to prevent in general.
   </para>
________________________________________________________-->
   <para>
    <quote>注销用户</quote>可能会作为维护工作的一部分发生，或者当管理员以
	<literal>postgres</literal>用户或类似名称登录时手动发生，所以通常难以防止。
   </para>
<!-- pgdoc-cn_end sig_en=6afb8144acb27c8d4ff1c75dc97e04ab -->

<!-- pgdoc-cn_start sig_en=70d72b75f0217d22ffea46137f156c63 sig_cn_org=None source=14.1 
   <para>
    What is a <quote>system user</quote> is determined
    at <productname>systemd</productname> compile time from
    the <symbol>SYS_UID_MAX</symbol> setting
    in <filename>/etc/login.defs</filename>.
   </para>
________________________________________________________-->
   <para>
    什么是<quote>系统用户</quote>是由<filename>/etc/login.defs</filename>中的
	<symbol>SYS_UID_MAX</symbol>设置在<productname>systemd</productname>编译时确定的。
   </para>
<!-- pgdoc-cn_end sig_en=70d72b75f0217d22ffea46137f156c63 -->

<!-- pgdoc-cn_start sig_en=3241bb70cb87127d01f2ce1557698eeb sig_cn_org=None source=14.1 
   <para>
    Packaging and deployment scripts should be careful to create
    the <literal>postgres</literal> user as a system user by
    using <literal>useradd -r</literal>, <literal>adduser -&minus;system</literal>,
    or equivalent.
   </para>
________________________________________________________-->
   <para>
    打包和部署脚本应该小心，通过使用<literal>useradd -r</literal>、
	<literal>adduser --system</literal>或等价物来创建<literal>postgres</literal>用户作为系统用户。
   </para>
<!-- pgdoc-cn_end sig_en=3241bb70cb87127d01f2ce1557698eeb -->

<!-- pgdoc-cn_start sig_en=d5ccb5aad7c52219dfd215c8dcd3878e sig_cn_org=None source=14.1 
   <para>
    Alternatively, if the user account was created incorrectly or cannot be
    changed, it is recommended to set
<programlisting>
RemoveIPC=no
</programlisting>
    in <filename>/etc/systemd/logind.conf</filename> or another appropriate
    configuration file.
   </para>
________________________________________________________-->
   <para>
    或者，如果用户帐户创建不正确或无法更改，建议设置
<programlisting>
RemoveIPC=no
</programlisting>
    在<filename>/etc/systemd/logind.conf</filename>或其他适当的配置文件中。
   </para>
<!-- pgdoc-cn_end sig_en=d5ccb5aad7c52219dfd215c8dcd3878e -->

   <caution>
<!-- pgdoc-cn_start sig_en=a2c7ee3143f1b187bf012b27d3fbde94 sig_cn_org=None source=14.1 
    <para>
     At least one of these two things has to be ensured, or the PostgreSQL
     server will be very unreliable.
    </para>
________________________________________________________-->
    <para>
     至少要确保这两件事中的一件，否则PostgreSQL服务器将非常不可靠。
    </para>
<!-- pgdoc-cn_end sig_en=a2c7ee3143f1b187bf012b27d3fbde94 -->
   </caution>
  </sect2>

  <sect2>
<!-- pgdoc-cn_start sig_en=95d1f7eb99eb75c7817ce23638664342 sig_cn_org=None source=14.1 
   <title>Resource Limits</title>
________________________________________________________-->
   <title>资源限制</title>
<!-- pgdoc-cn_end sig_en=95d1f7eb99eb75c7817ce23638664342 -->

<!-- pgdoc-cn_start sig_en=0976148c808e73ef66ba5340d7e903c8 sig_cn_org=None source=14.1 
   <para>
    Unix-like operating systems enforce various kinds of resource limits
    that might interfere with the operation of your
    <productname>PostgreSQL</productname> server. Of particular
    importance are limits on the number of processes per user, the
    number of open files per process, and the amount of memory available
    to each process. Each of these have a <quote>hard</quote> and a
    <quote>soft</quote> limit. The soft limit is what actually counts
    but it can be changed by the user up to the hard limit. The hard
    limit can only be changed by the root user. The system call
    <function>setrlimit</function> is responsible for setting these
    parameters. The shell's built-in command <command>ulimit</command>
    (Bourne shells) or <command>limit</command> (<application>csh</application>) is
    used to control the resource limits from the command line. On
    BSD-derived systems the file <filename>/etc/login.conf</filename>
    controls the various resource limits set during login. See the
    operating system documentation for details. The relevant
    parameters are <varname>maxproc</varname>,
    <varname>openfiles</varname>, and <varname>datasize</varname>. For
    example:
<programlisting>
default:\
...
        :datasize-cur=256M:\
        :maxproc-cur=256:\
        :openfiles-cur=256:\
...
</programlisting>
    (<literal>-cur</literal> is the soft limit.  Append
    <literal>-max</literal> to set the hard limit.)
   </para>
________________________________________________________-->
   <para>
    Unix类操作系统强制了许多种资源限制，这些限制可能干扰你的<productname>PostgreSQL</productname>服务器的操作。尤其重要的是对每个用户的进程数目的限制、每个进程打开文件数目的限制以及每个进程可用的内存的限制。这些限制中每个都有一个<quote>硬</quote>限制和一个<quote>软</quote>限制。实际使用的是软限制，但用户可以自己修改成最大为硬限制的数目。而硬限制只能由root用户修改。系统调用<function>setrlimit</function>负责设置这些参数。 shell的内建命令<command>ulimit</command>（Bourne shells）或<command>limit</command>（<application>csh</application>）被用来从命令行控制资源限制。 在 BSD 衍生的系统上，<filename>/etc/login.conf</filename>文件控制在登录期间设置的各种资源限制。详见操作系统文档。相关的参数是<varname>maxproc</varname>、<varname>openfiles</varname>和<varname>datasize</varname>。例如：
<programlisting>
default:\
...
        :datasize-cur=256M:\
        :maxproc-cur=256:\
        :openfiles-cur=256:\
...
</programlisting>
    （<literal>-cur</literal>是软限制。增加<literal>-max</literal>可设置硬限制）。
   </para>
<!-- pgdoc-cn_end sig_en=0976148c808e73ef66ba5340d7e903c8 -->

<!-- pgdoc-cn_start sig_en=01bf303e1cb4e07c9f8c474cbf9620ee sig_cn_org=2dd49833e7f95ebeadc62736805c2475 source=15.7 
   <para>
    Kernels can also have system-wide limits on some resources.
    <itemizedlist>
     <listitem>
      <para>
      On <productname>Linux</productname> the kernel parameter
      <varname>fs.file-max</varname> determines the maximum number of open
      files that the kernel will support.  It can be changed with
      <literal>sysctl -w fs.file-max=<replaceable>N</replaceable></literal>.
      To make the setting persist across reboots, add an assignment
      in <filename>/etc/sysctl.conf</filename>.
      The maximum limit of files per process is fixed at the time the
      kernel is compiled; see
      <filename>/usr/src/linux/Documentation/proc.txt</filename> for
      more information.
      </para>
     </listitem>
    </itemizedlist>
   </para>
________________________________________________________-->
   <para>
    内核还可以对一些资源，设置系统范围的限制。
    <itemizedlist>
     <listitem>
      <para>
      在<productname>Linux</productname>上，内核参数
      <varname>fs.file-max</varname>确定内核支持的最大打开文件数。
      可以使用<literal>sysctl -w fs.file-max=<replaceable>N</replaceable></literal>来更改它。
      要使设置在重新启动后保持不变，在<filename>/etc/sysctl.conf</filename>中添加一个赋值。
      每个进程的文件上限在内核编译时固定；请参阅
      <filename>/usr/src/linux/Documentation/proc.txt</filename>获取更多信息。
      </para>
     </listitem>
    </itemizedlist>
   </para>
<!-- pgdoc-cn_end sig_en=01bf303e1cb4e07c9f8c474cbf9620ee -->

<!-- pgdoc-cn_start sig_en=06a39b5a9060352b0a303fb543515593 sig_cn_org=None source=14.1 
   <para>
    The <productname>PostgreSQL</productname> server uses one process
    per connection so you should provide for at least as many processes
    as allowed connections, in addition to what you need for the rest
    of your system.  This is usually not a problem but if you run
    several servers on one machine things might get tight.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>服务器为每个连接都使用一个进程， 所以你应该至少和允许的连接同样多的进程，再加上系统其它部分所需要的进程数目。 通常这个并不是什么问题，但如果你在一台机器上运行多个服务器，资源使用可能就会紧张。
   </para>
<!-- pgdoc-cn_end sig_en=06a39b5a9060352b0a303fb543515593 -->

<!-- pgdoc-cn_start sig_en=45bc6be2a272d04677395145bab7f55d sig_cn_org=None source=14.1 
   <para>
    The factory default limit on open files is often set to
    <quote>socially friendly</quote> values that allow many users to
    coexist on a machine without using an inappropriate fraction of
    the system resources.  If you run many servers on a machine this
    is perhaps what you want, but on dedicated servers you might want to
    raise this limit.
   </para>
________________________________________________________-->
   <para>
    打开文件的出厂默认限制通常设置为<quote>socially friendly</quote>的值， 它允许许多用户在一台机器上共存，而不会导致不成比例的系统资源使用。 如果你在一台机器上运行许多服务器，这也许就是你想要的，但是在专门的服务器上， 你可能需要提高这个限制。
   </para>
<!-- pgdoc-cn_end sig_en=45bc6be2a272d04677395145bab7f55d -->

<!-- pgdoc-cn_start sig_en=883aea39328760c8a7e78dbfc9858214 sig_cn_org=None source=14.1 
   <para>
    On the other side of the coin, some systems allow individual
    processes to open large numbers of files; if more than a few
    processes do so then the system-wide limit can easily be exceeded.
    If you find this happening, and you do not want to alter the
    system-wide limit, you can set <productname>PostgreSQL</productname>'s <xref
    linkend="guc-max-files-per-process"/> configuration parameter to
    limit the consumption of open files.
   </para>
________________________________________________________-->
   <para>
    在另一方面，一些系统允许独立的进程打开非常多的文件；如果不止几个进程这么干，那系统范围的限制就很容易被超过。如果你发现这样的现像， 并且不想修改系统范围的限制，你就可以设置<productname>PostgreSQL</productname>的 <xref linkend="guc-max-files-per-process"/>配置参数来限制打开文件数的消耗。
   </para>
<!-- pgdoc-cn_end sig_en=883aea39328760c8a7e78dbfc9858214 -->

<!-- pgdoc-cn_start sig_en=0629916f0fa64279b0cb6be3dc206c56 sig_cn_org=86c9ad05671f85af6d032925645e2547 source=15.7 
   <para>
    Another kernel limit that may be of concern when supporting large
    numbers of client connections is the maximum socket connection queue
    length.  If more than that many connection requests arrive within a very
    short period, some may get rejected before the postmaster can service
    the requests, with those clients receiving unhelpful connection failure
    errors such as <quote>Resource temporarily unavailable</quote> or
    <quote>Connection refused</quote>.  The default queue length limit is 128
    on many platforms.  To raise it, adjust the appropriate kernel parameter
    via <application>sysctl</application>, then restart the postmaster.
    The parameter is variously named <varname>net.core.somaxconn</varname>
    on Linux, <varname>kern.ipc.soacceptqueue</varname> on newer FreeBSD,
    and <varname>kern.ipc.somaxconn</varname> on macOS and other BSD
    variants.
   </para>
________________________________________________________-->
   <para>
    另一个可能引起关注的内核限制是支持大量客户端连接时的最大套接字连接队列长度。
    如果在很短的时间内到达的连接请求超过了这个数量，一些请求可能会在postmaster
    能够处理请求之前被拒绝，这些客户端会收到不太有用的连接失败错误，比如
    <quote>Resource temporarily unavailable</quote>或<quote>Connection refused</quote>。在许多平台上，
    默认的队列长度限制是128。要提高它，通过<application>sysctl</application>
    调整适当的内核参数，然后重新启动postmaster。该参数在不同系统上有不同的名称：在Linux上是
    <varname>net.core.somaxconn</varname>，在较新的FreeBSD上是
    <varname>kern.ipc.soacceptqueue</varname>，在macOS和其他BSD变体上是
    <varname>kern.ipc.somaxconn</varname>。
   </para>
<!-- pgdoc-cn_end sig_en=0629916f0fa64279b0cb6be3dc206c56 -->
  </sect2>

  <sect2 id="linux-memory-overcommit">
<!-- pgdoc-cn_start sig_en=05c482a086253d28b649845a8e759ca3 sig_cn_org=None source=14.1 
   <title>Linux Memory Overcommit</title>
________________________________________________________-->
   <title>Linux 内存过量使用</title>
<!-- pgdoc-cn_end sig_en=05c482a086253d28b649845a8e759ca3 -->

<!-- pgdoc-cn_start sig_en=c2b675e1144eae8a8acde9a76666790d sig_cn_org=None source=14.1 
   <indexterm>
    <primary>memory overcommit</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>memory overcommit</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=c2b675e1144eae8a8acde9a76666790d -->

<!-- pgdoc-cn_start sig_en=2afaf354aebc4ef3a731d8783f2684c4 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>OOM</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>OOM</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=2afaf354aebc4ef3a731d8783f2684c4 -->

<!-- pgdoc-cn_start sig_en=848954e195e9a7dd995f32cf13f4e142 sig_cn_org=None source=14.1 
   <indexterm>
    <primary>overcommit</primary>
   </indexterm>
________________________________________________________-->
   <indexterm>
    <primary>overcommit</primary>
   </indexterm>
<!-- pgdoc-cn_end sig_en=848954e195e9a7dd995f32cf13f4e142 -->

<!-- pgdoc-cn_start sig_en=d62822679b3d28fb985b18a057b40f54 sig_cn_org=None source=14.1 
   <para>
    The default virtual memory behavior on Linux is not
    optimal for <productname>PostgreSQL</productname>. Because of the
    way that the kernel implements memory overcommit, the kernel might
    terminate the <productname>PostgreSQL</productname> postmaster (the
    supervisor server process) if the memory demands of either
    <productname>PostgreSQL</productname> or another process cause the
    system to run out of virtual memory.
   </para>
________________________________________________________-->
   <para>
    Linux上默认的虚拟内存行为对<productname>PostgreSQL</productname>不是最优的。
    由于内核实现内存过量使用的方法，如果<productname>PostgreSQL</productname>或其它进程的内存要求导致系统用光虚拟内存，那么内核可能会终止<productname>PostgreSQL</productname>的 postmaster 进程（主管服务器进程）。
   </para>
<!-- pgdoc-cn_end sig_en=d62822679b3d28fb985b18a057b40f54 -->

<!-- pgdoc-cn_start sig_en=dce8bb16d9bc4efe1aae3a9f2544ac42 sig_cn_org=None source=14.1 
   <para>
    If this happens, you will see a kernel message that looks like
    this (consult your system documentation and configuration on where
    to look for such a message):
<programlisting>
Out of Memory: Killed process 12345 (postgres).
</programlisting>
    This indicates that the <filename>postgres</filename> process
    has been terminated due to memory pressure.
    Although existing database connections will continue to function
    normally, no new connections will be accepted.  To recover,
    <productname>PostgreSQL</productname> will need to be restarted.
   </para>
________________________________________________________-->
   <para>
    如果发生了这样的事情，你会看到像下面这样的内核消息（参考你的系统文档和配置，看看在哪里能看到这样的消息）：
<programlisting>
Out of Memory: Killed process 12345 (postgres).
</programlisting>
    这表明<filename>postgres</filename>进程因为内存压力而被终止了。尽管现有的数据库连接将继续正常运转，但是新的连接将无法被接受。要想恢复，<productname>PostgreSQL</productname>应该被重启。
   </para>
<!-- pgdoc-cn_end sig_en=dce8bb16d9bc4efe1aae3a9f2544ac42 -->

<!-- pgdoc-cn_start sig_en=e9dca439eab53f6114aa227feddc4333 sig_cn_org=None source=14.1 
   <para>
    One way to avoid this problem is to run
    <productname>PostgreSQL</productname> on a machine where you can
    be sure that other processes will not run the machine out of
    memory.  If memory is tight, increasing the swap space of the
    operating system can help avoid the problem, because the
    out-of-memory (OOM) killer is invoked only when physical memory and
    swap space are exhausted.
   </para>
________________________________________________________-->
   <para>
    一种避免这个问题的方法是在一台你确信其它进程不会耗尽内存的机器上运行<productname>PostgreSQL</productname>。 如果内存资源紧张，增加操作系统的交换空间可以帮助避免这个问题，因为内存不足（OOM）杀手（即终止进程这种行为）只有当物理内存和交换空间都被用尽时才会被调用。
   </para>
<!-- pgdoc-cn_end sig_en=e9dca439eab53f6114aa227feddc4333 -->

<!-- pgdoc-cn_start sig_en=ad15a1f4d3caea8c9a0c96a956d95e19 sig_cn_org=None source=14.1 
   <para>
    If <productname>PostgreSQL</productname> itself is the cause of the
    system running out of memory, you can avoid the problem by changing
    your configuration.  In some cases, it may help to lower memory-related
    configuration parameters, particularly
    <link linkend="guc-shared-buffers"><varname>shared_buffers</varname></link>,
    <link linkend="guc-work-mem"><varname>work_mem</varname></link>, and
    <link linkend="guc-hash-mem-multiplier"><varname>hash_mem_multiplier</varname></link>.
    In other cases, the problem may be caused by allowing too many
    connections to the database server itself.  In many cases, it may
    be better to reduce
    <link linkend="guc-max-connections"><varname>max_connections</varname></link>
    and instead make use of external connection-pooling software.
   </para>
________________________________________________________-->
   <para>
    如果<productname>PostgreSQL</productname>本身是导致系统内存耗尽的原因，你可以通过改变你的配置来避免该问题。在某些情况中，降低内存相关的配置参数可能有所帮助，特别是<link linkend="guc-shared-buffers"><varname>shared_buffers</varname></link>、<link linkend="guc-work-mem"><varname>work_mem</varname></link>和<link linkend="guc-hash-mem-multiplier"><varname>hash_mem_multiplier</varname></link>。在其他情况中，允许太多连接到数据库服务器本身也可能导致该问题。在很多情况下，最好减小<link linkend="guc-max-connections"><varname>max_connections</varname></link>并且转而利用外部连接池软件。
   </para>
<!-- pgdoc-cn_end sig_en=ad15a1f4d3caea8c9a0c96a956d95e19 -->

<!-- pgdoc-cn_start sig_en=3cb59746234cf7ab577bbb21d5cad98e sig_cn_org=None source=14.1 
   <para>
    It is possible to modify the
    kernel's behavior so that it will not <quote>overcommit</quote> memory.
    Although this setting will not prevent the <ulink
    url="https://lwn.net/Articles/104179/">OOM killer</ulink> from being invoked
    altogether, it will lower the chances significantly and will therefore
    lead to more robust system behavior.  This is done by selecting strict
    overcommit mode via <command>sysctl</command>:
<programlisting>
sysctl -w vm.overcommit_memory=2
</programlisting>
    or placing an equivalent entry in <filename>/etc/sysctl.conf</filename>.
    You might also wish to modify the related setting
    <varname>vm.overcommit_ratio</varname>.  For details see the kernel documentation
    file <ulink url="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting"></ulink>.
   </para>
________________________________________________________-->
   <para>
    可以修改内核的行为，这样它将不会<quote>过量使用</quote>内存。尽管此设置不会阻止<ulink url="https://lwn.net/Articles/104179/">OOM 杀手</ulink>被调用，但它可以显著地降低其可能性并且将因此得到更鲁棒的系统行为。这可以通过用<command>sysctl</command>选择严格的过量使用模式来实现：
<programlisting>
sysctl -w vm.overcommit_memory=2
</programlisting>
    或者在<filename>/etc/sysctl.conf</filename>中放置一个等效的项。你可能还希望修改相关的设置<varname>vm.overcommit_ratio</varname>。 详细信息请参阅内核文档的<ulink url="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting"></ulink>文件。
   </para>
<!-- pgdoc-cn_end sig_en=3cb59746234cf7ab577bbb21d5cad98e -->

<!-- pgdoc-cn_start sig_en=1c8838367650f8d0ee0ef8ce77befe5f sig_cn_org=None source=14.1 
   <para>
    Another approach, which can be used with or without altering
    <varname>vm.overcommit_memory</varname>, is to set the process-specific
    <firstterm>OOM score adjustment</firstterm> value for the postmaster process to
    <literal>-1000</literal>, thereby guaranteeing it will not be targeted by the OOM
    killer.  The simplest way to do this is to execute
<programlisting>
echo -1000 > /proc/self/oom_score_adj
</programlisting>
    in the postmaster's startup script just before invoking the postmaster.
    Note that this action must be done as root, or it will have no effect;
    so a root-owned startup script is the easiest place to do it.  If you
    do this, you should also set these environment variables in the startup
    script before invoking the postmaster:
<programlisting>
export PG_OOM_ADJUST_FILE=/proc/self/oom_score_adj
export PG_OOM_ADJUST_VALUE=0
</programlisting>
    These settings will cause postmaster child processes to run with the
    normal OOM score adjustment of zero, so that the OOM killer can still
    target them at need.  You could use some other value for
    <envar>PG_OOM_ADJUST_VALUE</envar> if you want the child processes to run
    with some other OOM score adjustment.  (<envar>PG_OOM_ADJUST_VALUE</envar>
    can also be omitted, in which case it defaults to zero.)  If you do not
    set <envar>PG_OOM_ADJUST_FILE</envar>, the child processes will run with the
    same OOM score adjustment as the postmaster, which is unwise since the
    whole point is to ensure that the postmaster has a preferential setting.
   </para>
________________________________________________________-->
   <para>
    另一种方法，可以在改变或不改变<varname>vm.overcommit_memory</varname>的情况下使用。它将 postmaster 进程的进程相关的<firstterm>OOM score adjustment</firstterm>值设置为<literal>-1000</literal>，从而保证它不会成为 OOM 杀手的目标。 这样做最简单的方法是在 postmaster 的启动脚本中执行
<programlisting>
echo -1000 > /proc/self/oom_score_adj
</programlisting>
    并且要在调用 postmaster 之前执行。请注意这个动作必须以 root 完成，否则它将不会产生效果。所以一个被 root 拥有的启动脚本是放置这个动作最容易的地方。如果这样做，你还应该在调用 postmaster 之前在启动脚本中设置这些环境变量：
<programlisting>
export PG_OOM_ADJUST_FILE=/proc/self/oom_score_adj
export PG_OOM_ADJUST_VALUE=0
</programlisting>
    这些设置将导致 postmaster 子进程使用普通的值为零的 OOM score adjustment 运行，所以 OOM 杀手仍能在需要时把它们作为目标。如果你想要子进程用某些其他 OOM score adjustment 值运行，可以为<envar>PG_OOM_ADJUST_VALUE</envar>使用其他的值（<envar>PG_OOM_ADJUST_VALUE</envar>也能被省略，那时它会被默认为零）。如果你没有设置<envar>PG_OOM_ADJUST_FILE</envar>，子进程将使用和 postmaster 相同的 OOM score adjustment 运行，这是不明智的，因为重点是确保 postmaster 具有优先的设置。
   </para>
<!-- pgdoc-cn_end sig_en=1c8838367650f8d0ee0ef8ce77befe5f -->

  </sect2>

  <sect2 id="linux-huge-pages">
<!-- pgdoc-cn_start sig_en=20beabd0fd5809356c9a7dd38b2e604a sig_cn_org=None source=14.1 
   <title>Linux Huge Pages</title>
________________________________________________________-->
   <title>Linux 大页面</title>
<!-- pgdoc-cn_end sig_en=20beabd0fd5809356c9a7dd38b2e604a -->

<!-- pgdoc-cn_start sig_en=bdf8f8ca56c379d74f8212d7bd5755b8 sig_cn_org=5d2f86ce5db9839a008f87d572c3359a source=15.7 
   <para>
    Using huge pages reduces overhead when using large contiguous chunks of
    memory, as <productname>PostgreSQL</productname> does, particularly when
    using large values of <xref linkend="guc-shared-buffers"/>.  To use this
    feature in <productname>PostgreSQL</productname> you need a kernel
    with <varname>CONFIG_HUGETLBFS=y</varname> and
    <varname>CONFIG_HUGETLB_PAGE=y</varname>. You will also have to configure
    the operating system to provide enough huge pages of the desired size.
    To determine the number of huge pages needed, use the
    <command>postgres</command> command to see the value of
    <xref linkend="guc-shared-memory-size-in-huge-pages"/>.  Note that the
    server must be shut down to view this runtime-computed parameter.
    This might look like:
<programlisting>
$ <userinput>postgres -D $PGDATA -C shared_memory_size_in_huge_pages</userinput>
3170
$ <userinput>grep ^Hugepagesize /proc/meminfo</userinput>
Hugepagesize:       2048 kB
$ <userinput>ls /sys/kernel/mm/hugepages</userinput>
hugepages-1048576kB  hugepages-2048kB
</programlisting>

     In this example the default is 2MB, but you can also explicitly request
     either 2MB or 1GB with <xref linkend="guc-huge-page-size"/> to adapt
     the number of pages calculated by
     <varname>shared_memory_size_in_huge_pages</varname>.

     While we need at least <literal>3170</literal> huge pages in this example,
     a larger setting would be appropriate if other programs on the machine
     also need huge pages.
     We can set this with:
<programlisting>
# <userinput>sysctl -w vm.nr_hugepages=3170</userinput>
</programlisting>
     Don't forget to add this setting to <filename>/etc/sysctl.conf</filename>
     so that it is reapplied after reboots.  For non-default huge page sizes,
     we can instead use:
<programlisting>
# <userinput>echo 3170 > /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages</userinput>
</programlisting>
    It is also possible to provide these settings at boot time using
    kernel parameters such as <literal>hugepagesz=2M hugepages=3170</literal>.
   </para>
________________________________________________________-->
   <para>
    使用大页可以减少内存的开销，特别是在使用大值的<productname>PostgreSQL</productname>时，尤其是在使用大值的<xref linkend="guc-shared-buffers"/>时。
    要在<productname>PostgreSQL</productname>中使用此功能，您需要一个具有<varname>CONFIG_HUGETLBFS=y</varname>和<varname>CONFIG_HUGETLB_PAGE=y</varname>的内核。
    您还需要配置操作系统以提供所需大小的足够多的大页。
    要确定所需的大页数量，请使用<command>postgres</command>命令查看<xref linkend="guc-shared-memory-size-in-huge-pages"/>的值。
    请注意，必须关闭服务器才能查看此运行时计算的参数。
    这可能看起来像：
<programlisting>
$ <userinput>postgres -D $PGDATA -C shared_memory_size_in_huge_pages</userinput>
3170
$ <userinput>grep ^Hugepagesize /proc/meminfo</userinput>
Hugepagesize:       2048 kB
$ <userinput>ls /sys/kernel/mm/hugepages</userinput>
hugepages-1048576kB  hugepages-2048kB
</programlisting>

     在此示例中，默认值为2MB，但您也可以使用<xref linkend="guc-huge-page-size"/>显式请求2MB或1GB，以调整由<varname>shared_memory_size_in_huge_pages</varname>计算的页数。

     在此示例中，我们至少需要<literal>3170</literal>个大页，如果机器上的其他程序也需要大页，则应适当增加设置。
     我们可以这样设置：
<programlisting>
# <userinput>sysctl -w vm.nr_hugepages=3170</userinput>
</programlisting>
     不要忘记将此设置添加到<filename>/etc/sysctl.conf</filename>中，以便在重新启动后重新应用。
     对于非默认的大页大小，我们可以改为使用：
<programlisting>
# <userinput>echo 3170 > /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages</userinput>
</programlisting>
    还可以在启动时使用内核参数（例如<literal>hugepagesz=2M hugepages=3170</literal>）提供这些设置。
   </para>
<!-- pgdoc-cn_end sig_en=bdf8f8ca56c379d74f8212d7bd5755b8 -->

<!-- pgdoc-cn_start sig_en=b660f92b4d781aa33e547fe5427e8523 sig_cn_org=None source=14.1 
   <para>
    Sometimes the kernel is not able to allocate the desired number of huge
    pages immediately due to fragmentation, so it might be necessary
    to repeat the command or to reboot.  (Immediately after a reboot, most of
    the machine's memory should be available to convert into huge pages.)
    To verify the huge page allocation situation for a given size, use:
<programlisting>
$ <userinput>cat /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages</userinput>
</programlisting>
   </para>
________________________________________________________-->
   <para>
    有时候内核在分片期间会无法立即分配想要数量的大页面，所以可能有必要重复该命令或者重新启动。
    （在重新启动之后，应立即将大部分机器的内存转换为大页面。）
    要验证巨大的页面对给出大小的分配情况，请使用：
<programlisting>
$ <userinput>cat /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages</userinput>
</programlisting>
   </para>
<!-- pgdoc-cn_end sig_en=b660f92b4d781aa33e547fe5427e8523 -->

<!-- pgdoc-cn_start sig_en=6d20da8a0230a2e0c3121c95944b0c26 sig_cn_org=None source=14.1 
   <para>
    It may also be necessary to give the database server's operating system
    user permission to use huge pages by setting
    <varname>vm.hugetlb_shm_group</varname> via <application>sysctl</application>, and/or
    give permission to lock memory with <command>ulimit -l</command>.
   </para>
________________________________________________________-->
   <para>
    可能还需要赋予数据库服务器的操作系统用户权限，让他能通过<application>sysctl</application>
	设置<varname>vm.hugetlb_shm_group</varname>以使用大页面，
	和/或赋予使用<command>ulimit -l</command>锁定内存的权限。
   </para>
<!-- pgdoc-cn_end sig_en=6d20da8a0230a2e0c3121c95944b0c26 -->

<!-- pgdoc-cn_start sig_en=9377fe5c7419876b7de78f4bb7f1a0d3 sig_cn_org=None source=14.1 
   <para>
    The default behavior for huge pages in
    <productname>PostgreSQL</productname> is to use them when possible, with
    the system's default huge page size, and
    to fall back to normal pages on failure. To enforce the use of huge
    pages, you can set <xref linkend="guc-huge-pages"/>
    to <literal>on</literal> in <filename>postgresql.conf</filename>.
    Note that with this setting <productname>PostgreSQL</productname> will fail to
    start if not enough huge pages are available.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname>中大页面的默认行为是尽可能使用它们，用系统的默认大页面大小，并且在失败时转回到正常页面。
    要强制使用大页面，你可以在<filename>postgresql.conf</filename>中把<xref linkend="guc-huge-pages"/>设置成<literal>on</literal>。
    注意此设置下如果没有足够的大页面可用，<productname>PostgreSQL</productname>将会启动失败。
   </para>
<!-- pgdoc-cn_end sig_en=9377fe5c7419876b7de78f4bb7f1a0d3 -->

<!-- pgdoc-cn_start sig_en=54fbe74653a9f16dc5d36d47c95a86a0 sig_cn_org=None source=14.1 
   <para>
    For a detailed description of the <productname>Linux</productname> huge
    pages feature have a look
    at <ulink url="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt"></ulink>.
   </para>
________________________________________________________-->
   <para>
    <productname>Linux</productname>大页面特性的详细描述可见<ulink url="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt"></ulink>.
   </para>
<!-- pgdoc-cn_end sig_en=54fbe74653a9f16dc5d36d47c95a86a0 -->

  </sect2>
 </sect1>


 <sect1 id="server-shutdown">
<!-- pgdoc-cn_start sig_en=c234c79429a823f938b35a80a5fc2e18 sig_cn_org=None source=14.1 
  <title>Shutting Down the Server</title>
________________________________________________________-->
  <title>关闭服务器</title>
<!-- pgdoc-cn_end sig_en=c234c79429a823f938b35a80a5fc2e18 -->

<!-- pgdoc-cn_start sig_en=817e7c3fac01a9b72dda2429ad44ab43 sig_cn_org=None source=14.1 
  <indexterm zone="server-shutdown">
   <primary>shutdown</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="server-shutdown">
   <primary>关闭</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=817e7c3fac01a9b72dda2429ad44ab43 -->

<!-- pgdoc-cn_start sig_en=651bb776b77725ba85fada618ffa8802 sig_cn_org=None source=14.1 
  <para>
   There are several ways to shut down the database server.
   Under the hood, they all reduce to sending a signal to the supervisor
   <command>postgres</command> process.
  </para>
________________________________________________________-->
  <para>
   有几种关闭数据库服务器的方法。在后台，它们都简化为向主管 <command>postgres</command> 进程发送信号。
  </para>
<!-- pgdoc-cn_end sig_en=651bb776b77725ba85fada618ffa8802 -->

<!-- pgdoc-cn_start sig_en=b2570d580ce87b81e78674cc455dfb9c sig_cn_org=None source=14.1 
  <para>
   If you are using a pre-packaged version
   of <productname>PostgreSQL</productname>, and you used its provisions
   for starting the server, then you should also use its provisions for
   stopping the server.  Consult the package-level documentation for
   details.
  </para>
________________________________________________________-->
  <para>
   如果您使用的是 <productname>PostgreSQL</productname> 的预打包版本，并且您使用其规定来启动服务器，那么您还应该使用其规定来停止服务器。 有关详细信息，请参阅包级文档。
  </para>
<!-- pgdoc-cn_end sig_en=b2570d580ce87b81e78674cc455dfb9c -->

<!-- pgdoc-cn_start sig_en=e2272c41e6aaefce3050086e0e3cf71a sig_cn_org=081edda5101df503e5afa8bc2d3d1208 source=15.7 
  <para>
   When managing the server directly, you can control the type of shutdown
   by sending different signals to the <command>postgres</command>
   process:

   <variablelist>
    <varlistentry>
     <term><systemitem>SIGTERM</systemitem><indexterm><primary>SIGTERM</primary></indexterm></term>
     <listitem>
      <para>
       This is the <firstterm>Smart Shutdown</firstterm> mode.
       After receiving <systemitem>SIGTERM</systemitem>, the server
       disallows new connections, but lets existing sessions end their
       work normally. It shuts down only after all of the sessions terminate.
       If the server is in recovery when a smart
       shutdown is requested, recovery and streaming replication will be
       stopped only after all regular sessions have terminated.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><systemitem>SIGINT</systemitem><indexterm><primary>SIGINT</primary></indexterm></term>
     <listitem>
      <para>
       This is the <firstterm>Fast Shutdown</firstterm> mode.
       The server disallows new connections and sends all existing
       server processes <systemitem>SIGTERM</systemitem>, which will cause them
       to abort their current transactions and exit promptly. It then
       waits for all server processes to exit and finally shuts down.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><systemitem>SIGQUIT</systemitem><indexterm><primary>SIGQUIT</primary></indexterm></term>
     <listitem>
      <para>
      This is the <firstterm>Immediate Shutdown</firstterm> mode.
      The server will send <systemitem>SIGQUIT</systemitem> to all child
      processes and wait for them to terminate.  If any do not terminate
      within 5 seconds, they will be sent <systemitem>SIGKILL</systemitem>.
      The supervisor server process exits as soon as all child processes have
      exited, without doing normal database shutdown processing.
      This will lead to recovery (by
      replaying the WAL log) upon next start-up. This is recommended
      only in emergencies.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
________________________________________________________-->
  <para>
   当直接管理服务器时，您可以通过向<command>postgres</command>进程发送不同的信号来控制关闭类型：

   <variablelist>
    <varlistentry>
     <term><systemitem>SIGTERM</systemitem><indexterm><primary>SIGTERM</primary></indexterm></term>
     <listitem>
      <para>
       这是<firstterm>智能关闭</firstterm>模式。
       收到<systemitem>SIGTERM</systemitem>后，服务器禁止新连接，但允许现有会话正常结束工作。
       仅在所有会话终止后才会关闭。如果服务器在请求智能关闭时处于恢复状态，
       则只有在所有常规会话终止后，恢复和流复制才会停止。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><systemitem>SIGINT</systemitem><indexterm><primary>SIGINT</primary></indexterm></term>
     <listitem>
      <para>
       这是<firstterm>快速关闭</firstterm>模式。
       服务器禁止新连接并向所有现有服务器进程发送<systemitem>SIGTERM</systemitem>，
       这将导致它们中止当前事务并迅速退出。然后等待所有服务器进程退出，最后关闭。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><systemitem>SIGQUIT</systemitem><indexterm><primary>SIGQUIT</primary></indexterm></term>
     <listitem>
      <para>
      这是<firstterm>立即关闭</firstterm>模式。
      服务器将向所有子进程发送<systemitem>SIGQUIT</systemitem>并等待它们终止。
      如果有任何进程在5秒内未终止，它们将被发送<systemitem>SIGKILL</systemitem>。
      一旦所有子进程退出，监督服务器进程将立即退出，而不进行正常的数据库关闭处理。
      这将导致在下次启动时通过回放WAL日志进行恢复。仅在紧急情况下建议使用。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
<!-- pgdoc-cn_end sig_en=e2272c41e6aaefce3050086e0e3cf71a -->

<!-- pgdoc-cn_start sig_en=51151adccafac2d02ce1ce16dfa0516f sig_cn_org=None source=14.1 
  <para>
   The <xref linkend="app-pg-ctl"/> program provides a convenient
   interface for sending these signals to shut down the server.
   Alternatively, you can send the signal directly using <command>kill</command>
   on non-Windows systems.
   The <acronym>PID</acronym> of the <command>postgres</command> process can be
   found using the <command>ps</command> program, or from the file
   <filename>postmaster.pid</filename> in the data directory. For
   example, to do a fast shutdown:
<screen>
$ <userinput>kill -INT `head -1 /usr/local/pgsql/data/postmaster.pid`</userinput>
</screen>
  </para>
________________________________________________________-->
  <para>
   <xref linkend="app-pg-ctl"/>程序提供了一个发送这些信号关闭服务器的方便的接口。 另外，你在非 Windows 系统上可以用<command>kill</command>直接发送这些信号。可以用<command>ps</command>程序或者从数据目录的<filename>postmaster.pid</filename>文件中找到<command>postgres</command>进程的<acronym>PID</acronym>。例如，要做一次快速关闭：
<screen>
$ <userinput>kill -INT `head -1 /usr/local/pgsql/data/postmaster.pid`</userinput>
</screen>
  </para>
<!-- pgdoc-cn_end sig_en=51151adccafac2d02ce1ce16dfa0516f -->

  <important>
<!-- pgdoc-cn_start sig_en=79d24039e5dc358d3bf569868c557778 sig_cn_org=None source=14.1 
   <para>
    It is best not to use <systemitem>SIGKILL</systemitem> to shut down the
    server.  Doing so will prevent the server from releasing shared memory and
    semaphores.  Furthermore, <systemitem>SIGKILL</systemitem> kills
    the <command>postgres</command> process without letting it relay the
    signal to its subprocesses, so it might be necessary to kill the
    individual subprocesses by hand as well.
   </para>
________________________________________________________-->
   <para>
    最好不要使用<systemitem>SIGKILL</systemitem>关闭服务器。这样做将会阻止服务器释放共享内存和信号量。 
    此外，使用<systemitem>SIGKILL</systemitem>杀掉<command>postgres</command>进程时，<command>postgres</command>不会有机会将信号传播到它的子进程，所以可能也必须手工杀掉单个的子进程。
   </para>
<!-- pgdoc-cn_end sig_en=79d24039e5dc358d3bf569868c557778 -->
  </important>

<!-- pgdoc-cn_start sig_en=07e19b01f1f66fefa3b0957f526c87ec sig_cn_org=None source=14.1 
  <para>
   To terminate an individual session while allowing other sessions to
   continue, use <function>pg_terminate_backend()</function> (see <xref
   linkend="functions-admin-signal-table"/>) or send a
   <systemitem>SIGTERM</systemitem> signal to the child process associated with
   the session.
  </para>
________________________________________________________-->
  <para>
   要终止单个会话同时允许其他会话继续，使用<function>pg_terminate_backend()</function>（参阅<xref linkend="functions-admin-signal-table"/>） 或发送<systemitem>SIGTERM</systemitem>信号到该会话相关的子进程。
  </para>
<!-- pgdoc-cn_end sig_en=07e19b01f1f66fefa3b0957f526c87ec -->
 </sect1>

 <sect1 id="upgrading">
<!-- pgdoc-cn_start sig_en=0edde0a8e857943fbda566571105586b sig_cn_org=None source=14.1 
  <title>Upgrading a <productname>PostgreSQL</productname> Cluster</title>
________________________________________________________-->
  <title>升级一个<productname>PostgreSQL</productname>集簇</title>
<!-- pgdoc-cn_end sig_en=0edde0a8e857943fbda566571105586b -->

<!-- pgdoc-cn_start sig_en=75d2f3428670e2fd2b4a6356d5e335a7 sig_cn_org=None source=14.1 
  <indexterm zone="upgrading">
   <primary>upgrading</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="upgrading">
   <primary>upgrading</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=75d2f3428670e2fd2b4a6356d5e335a7 -->

<!-- pgdoc-cn_start sig_en=356c93d55f80c71c72484c37ddd47537 sig_cn_org=None source=14.1 
  <indexterm zone="upgrading">
   <primary>version</primary>
   <secondary>compatibility</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="upgrading">
   <primary>version</primary>
   <secondary>compatibility</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=356c93d55f80c71c72484c37ddd47537 -->

<!-- pgdoc-cn_start sig_en=36c4a2e8d494e13f5e768a0ef63507ba sig_cn_org=None source=14.1 
  <para>
   This section discusses how to upgrade your database data from one
   <productname>PostgreSQL</productname> release to a newer one.
  </para>
________________________________________________________-->
  <para>
   本节讨论如何把你的数据库数据从一个<productname>PostgreSQL</productname>发行升级到一个更新的发行。
  </para>
<!-- pgdoc-cn_end sig_en=36c4a2e8d494e13f5e768a0ef63507ba -->

<!-- pgdoc-cn_start sig_en=090f6e6d0f6f96f90ae8e32c41160093 sig_cn_org=None source=14.1 
  <para>
   Current <productname>PostgreSQL</productname> version numbers consist of a
   major and a minor version number.  For example, in the version number 10.1,
   the 10 is the major version number and the 1 is the minor version number,
   meaning this would be the first minor release of the major release 10.  For
   releases before <productname>PostgreSQL</productname> version 10.0, version
   numbers consist of three numbers, for example, 9.5.3.  In those cases, the
   major version consists of the first two digit groups of the version number,
   e.g., 9.5, and the minor version is the third number, e.g., 3, meaning this
   would be the third minor release of the major release 9.5.
  </para>
________________________________________________________-->
  <para>
   当前<productname>PostgreSQL</productname>版本号由主要版本号和次要版本号组成。
   例如，在版本号10.1中，10是主要版本号，1是次要版本号，这意味着这将是主版本10的第一个次要版本。
   对于<productname>PostgreSQL</productname>版本10.0之前的版本，版本号由三个数字组成，例如9.5.3。
   在这些情况下，主要版本由版本号的前两个数字组（例如9.5）组成，次要版本是第三个数字，
   例如3，这意味着这将是主要版本9.5的第三次要版本。
  </para>
<!-- pgdoc-cn_end sig_en=090f6e6d0f6f96f90ae8e32c41160093 -->

<!-- pgdoc-cn_start sig_en=9d8b222aec0292f8f8babba119a23223 sig_cn_org=None source=14.1 
  <para>
   Minor releases never change the internal storage format and are always
   compatible with earlier and later minor releases of the same major version
   number.  For example, version 10.1 is compatible with version 10.0 and
   version 10.6.  Similarly, for example, 9.5.3 is compatible with 9.5.0,
   9.5.1, and 9.5.6.  To update between compatible versions, you simply
   replace the executables while the server is down and restart the server.
   The data directory remains unchanged &mdash; minor upgrades are that
   simple.
  </para>
________________________________________________________-->
  <para>
   次要发行从来不改变内部存储格式并且总是向前并向后兼容同一主版本号中的次要发行。
   例如版本10.1与版本10.0和版本10.6兼容。类似的，例如9.5.3与9.5.0、9.5.1和9.5.6兼容。
   要在兼容的版本间升级，你只需要简单地在服务器关闭时替换可执行文件并重启服务器。
   数据目录则保持不变 &mdash; 次要升级就这么简单。
  </para>
<!-- pgdoc-cn_end sig_en=9d8b222aec0292f8f8babba119a23223 -->

<!-- pgdoc-cn_start sig_en=e9ffac63b9157b13d9f91638c8a2d453 sig_cn_org=d0dc325c6cb044873bd7d8098762bd11 source=15.7 
  <para>
   For <emphasis>major</emphasis> releases of <productname>PostgreSQL</productname>, the
   internal data storage format is subject to change, thus complicating
   upgrades.  The traditional method for moving data to a new major version
   is to dump and restore the database, though this can be slow.  A
   faster method is <xref linkend="pgupgrade"/>.  Replication methods are
   also available, as discussed below.
   (If you are using a pre-packaged version
   of <productname>PostgreSQL</productname>, it may provide scripts to
   assist with major version upgrades.  Consult the package-level
   documentation for details.)
  </para>
________________________________________________________-->
  <para>
   对于<emphasis>major</emphasis>版本的<productname>PostgreSQL</productname>，内部数据存储格式可能会发生变化，从而使升级变得复杂。
   将数据移动到新的主要版本的传统方法是转储和恢复数据库，尽管这可能很慢。
   更快的方法是<xref linkend="pgupgrade"/>。还可以使用复制方法，如下所述。
   （如果您使用的是<productname>PostgreSQL</productname>的预打包版本，它可能提供脚本来帮助进行主要版本升级。
   请查阅包级文档以获取详细信息。）
</para>
<!-- pgdoc-cn_end sig_en=e9ffac63b9157b13d9f91638c8a2d453 -->

<!-- pgdoc-cn_start sig_en=d31db7c21b6df6ad9d7f3d7c2ff39bb0 sig_cn_org=None source=14.1 
  <para>
   New major versions also typically introduce some user-visible
   incompatibilities, so application programming changes might be required.
   All user-visible changes are listed in the release notes (<xref
   linkend="release"/>);  pay particular attention to the section
   labeled "Migration".  Though you can upgrade from one major version
   to another without upgrading to intervening versions, you should read
   the major release notes of all intervening versions.
  </para>
________________________________________________________-->
  <para>
   新的主版本也通常会引入一些用户可见的不兼容性，因此可能需要应用程序编程上的改变。
   所有用户可见的更改都被列在发行注记（<xref linkend="release"/>）中，请特别注意标有 "Migration" 的小节。
   尽管你可能从一个主版本升级到另一个，而不用升级中间版本，你应该阅读全部中间版本的主要发行说明。
  </para>
<!-- pgdoc-cn_end sig_en=d31db7c21b6df6ad9d7f3d7c2ff39bb0 -->

<!-- pgdoc-cn_start sig_en=7af36b693552a3ed480e7f10edae7c6a sig_cn_org=None source=14.1 
  <para>
   Cautious users will want to test their client applications on the new
   version before switching over fully; therefore, it's often a good idea to
   set up concurrent installations of old and new versions.  When
   testing a <productname>PostgreSQL</productname> major upgrade, consider the
   following categories of possible changes:
  </para>
________________________________________________________-->
  <para>
   小心的用户在完全切换过去之前将希望在新版本上测试他们的客户端应用。因此，建立一个新旧版本的并存安装通常是一个好主意。在测试一个<productname>PostgreSQL</productname>主要升级时，考虑下列可能的改变类别：
  </para>
<!-- pgdoc-cn_end sig_en=7af36b693552a3ed480e7f10edae7c6a -->

  <variablelist>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=cfb3fd52be4338ca5acaf1efe8fa3f97 sig_cn_org=None source=14.1 
    <term>Administration</term>
________________________________________________________-->
    <term>管理</term>
<!-- pgdoc-cn_end sig_en=cfb3fd52be4338ca5acaf1efe8fa3f97 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=0f7bf58d70cebb5adaa1edba97828436 sig_cn_org=None source=14.1 
     <para>
      The capabilities available for administrators to monitor and control
      the server often change and improve in each major release.
     </para>
________________________________________________________-->
     <para>
      用于管理员监控和控制服务器的功能在每一个主发行中经常会改变和增加。
     </para>
<!-- pgdoc-cn_end sig_en=0f7bf58d70cebb5adaa1edba97828436 -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=54d6a3540dabb82a99381a90a8f8fca0 sig_cn_org=None source=14.1 
    <term>SQL</term>
________________________________________________________-->
    <term>SQL</term>
<!-- pgdoc-cn_end sig_en=54d6a3540dabb82a99381a90a8f8fca0 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=638f8b967c060878f570e7c52582ce1e sig_cn_org=None source=14.1 
     <para>
      Typically this includes new SQL command capabilities and not changes
      in behavior, unless specifically mentioned in the release notes.
     </para>
________________________________________________________-->
     <para>
      通常这包括新的 SQL 命令功能并且在行为上没有更改，除非在发行注记中有特别提到。
     </para>
<!-- pgdoc-cn_end sig_en=638f8b967c060878f570e7c52582ce1e -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=d54895691ffe8ea5395af95f258fdc75 sig_cn_org=None source=14.1 
    <term>Library API</term>
________________________________________________________-->
    <term>库 API</term>
<!-- pgdoc-cn_end sig_en=d54895691ffe8ea5395af95f258fdc75 -->
    <listitem>
<!-- pgdoc-cn_start sig_en=6dfe6216f75b60600eb0af8f2367cb13 sig_cn_org=None source=14.1 
     <para>
      Typically libraries like <application>libpq</application> only add new
      functionality, again unless mentioned in the release notes.
     </para>
________________________________________________________-->
     <para>
      通常<application>libpq</application>等库值增加新功能，除非在发行注记中有特别提到。
     </para>
<!-- pgdoc-cn_end sig_en=6dfe6216f75b60600eb0af8f2367cb13 -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=66663aedebd388132d28ee7d24da729e sig_cn_org=None source=14.1 
    <term>System Catalogs</term>
________________________________________________________-->
    <term>系统目录</term>
<!-- pgdoc-cn_end sig_en=66663aedebd388132d28ee7d24da729e -->
    <listitem>
<!-- pgdoc-cn_start sig_en=e4360c79f34d54a8f5ecb72d45b5120e sig_cn_org=None source=14.1 
     <para>
      System catalog changes usually only affect database management tools.
     </para>
________________________________________________________-->
     <para>
      系统目录改变通常只影响数据库管理工具。
     </para>
<!-- pgdoc-cn_end sig_en=e4360c79f34d54a8f5ecb72d45b5120e -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=d33425d3ee47a8fefada8539da3370de sig_cn_org=None source=14.1 
    <term>Server C-language API</term>
________________________________________________________-->
    <term>服务器 C-语言 API</term>
<!-- pgdoc-cn_end sig_en=d33425d3ee47a8fefada8539da3370de -->
    <listitem>
<!-- pgdoc-cn_start sig_en=4178d2acf58c19a1b106ac8ef98aa0c7 sig_cn_org=None source=14.1 
     <para>
      This involves changes in the backend function API, which is written
      in the C programming language.  Such changes affect code that
      references backend functions deep inside the server.
     </para>
________________________________________________________-->
     <para>
      这涉及到后端函数 API 中的改变，它使用 C 编程语言编写。这些改变影响引用服务器内部后端函数的代码。
     </para>
<!-- pgdoc-cn_end sig_en=4178d2acf58c19a1b106ac8ef98aa0c7 -->
    </listitem>
   </varlistentry>

  </variablelist>

  <sect2 id="upgrading-via-pgdumpall">
<!-- pgdoc-cn_start sig_en=5bd29347798bbaa259ce72071fb4ce23 sig_cn_org=None source=14.1 
   <title>Upgrading Data via <application>pg_dumpall</application></title>
________________________________________________________-->
   <title>通过<application>pg_dumpall</application>升级数据</title>
<!-- pgdoc-cn_end sig_en=5bd29347798bbaa259ce72071fb4ce23 -->

<!-- pgdoc-cn_start sig_en=ade233a928e555610bf8b062950746e2 sig_cn_org=d7b7aae6e9717f74118dbb467ce5a6ad source=15.7 
   <para>
    One upgrade method is to dump data from one major version of
    <productname>PostgreSQL</productname> and restore it in another &mdash;  to do
    this, you must use a <emphasis>logical</emphasis> backup tool like
    <application>pg_dumpall</application>; file system
    level backup methods will not work. (There are checks in place that prevent
    you from using a data directory with an incompatible version of
    <productname>PostgreSQL</productname>, so no great harm can be done by
    trying to start the wrong server version on a data directory.)
   </para>
________________________________________________________-->
   <para>
    一种升级方法是从一个主要版本的<productname>PostgreSQL</productname>中导出数据，
    然后在另一个版本中恢复 &mdash; 要做到这一点，您必须使用<emphasis>logical</emphasis>备份工具，
    如<application>pg_dumpall</application>; 文件系统级备份方法将不起作用。
    （有检查措施阻止您在不兼容版本的<productname>PostgreSQL</productname>上使用数据目录，
    因此尝试在数据目录上启动错误的服务器版本不会造成太大损害。）
   </para>
<!-- pgdoc-cn_end sig_en=ade233a928e555610bf8b062950746e2 -->

<!-- pgdoc-cn_start sig_en=ffd8358a789305a5b86265b4029472b6 sig_cn_org=ae5290fd461dad3856d2a2a08d9b917d source=15.7 
   <para>
    It is recommended that you use the <application>pg_dump</application> and
    <application>pg_dumpall</application> programs from the <emphasis>newer</emphasis>
    version of
    <productname>PostgreSQL</productname>, to take advantage of enhancements
    that might have been made in these programs.  Current releases of the
    dump programs can read data from any server version back to 9.2.
   </para>
________________________________________________________-->
   <para>
    建议您使用<application>pg_dump</application>和<application>pg_dumpall</application>程序来自<emphasis>更新</emphasis>版本的<productname>PostgreSQL</productname>，以利用这些程序可能进行的增强。当前版本的转储程序可以读取从9.2版本开始的任何服务器版本的数据。
   </para>
<!-- pgdoc-cn_end sig_en=ffd8358a789305a5b86265b4029472b6 -->

<!-- pgdoc-cn_start sig_en=356a7cc5d190c8a531f48a18976120a5 sig_cn_org=None source=14.1 
   <para>
    These instructions assume that your existing installation is under the
    <filename>/usr/local/pgsql</filename> directory, and that the data area is in
    <filename>/usr/local/pgsql/data</filename>.  Substitute your paths
    appropriately.
   </para>
________________________________________________________-->
   <para>
    这些指令假定你现有的安装位于<filename>/usr/local/pgsql</filename>目录，并且数据区域在<filename>/usr/local/pgsql/data</filename>。请用你的路径进行适当的替换。
   </para>
<!-- pgdoc-cn_end sig_en=356a7cc5d190c8a531f48a18976120a5 -->

   <procedure>
    <step>
<!-- pgdoc-cn_start sig_en=df347a9559dc228d61cf3d4107b08cc1 sig_cn_org=None source=14.1 
     <para>
      If making a backup, make sure that your database is not being updated.
      This does not affect the integrity of the backup, but the changed
      data would of course not be included. If necessary, edit the
      permissions in the file <filename>/usr/local/pgsql/data/pg_hba.conf</filename>
      (or equivalent) to disallow access from everyone except you.
      See <xref linkend="client-authentication"/> for additional information on
      access control.
     </para>
________________________________________________________-->
     <para>
      如果在创建一个备份，确认你的数据库没有在被更新。这不会影响备份的完整性，但是那些更改当然不会被包括在备份中。如果必要，编辑<filename>/usr/local/pgsql/data/pg_hba.conf</filename>文件中的权限（或等效的方法）来不允许除你之外的任何人使用数据库。关于访问控制的额外信息请见<xref linkend="client-authentication"/>。
     </para>
<!-- pgdoc-cn_end sig_en=df347a9559dc228d61cf3d4107b08cc1 -->

<!-- pgdoc-cn_start sig_en=7fe6bc5d3180ed4f4c3f997a4e3715f9 sig_cn_org=None source=14.1 
     <para>
      <indexterm>
       <primary>pg_dumpall</primary>
       <secondary>use during upgrade</secondary>
      </indexterm>

      To back up your database installation, type:
<screen>
<userinput>pg_dumpall &gt; <replaceable>outputfile</replaceable></userinput>
</screen>
     </para>
________________________________________________________-->
     <para>
      <indexterm>
       <primary>pg_dumpall</primary>
       <secondary>use during upgrade</secondary>
      </indexterm>

      要备份你的数据库安装，键入：
<screen>
<userinput>pg_dumpall &gt; <replaceable>outputfile</replaceable></userinput>
</screen>
     </para>
<!-- pgdoc-cn_end sig_en=7fe6bc5d3180ed4f4c3f997a4e3715f9 -->

<!-- pgdoc-cn_start sig_en=9c692cba5827c4dc64dde2f461d8510b sig_cn_org=None source=14.1 
     <para>
      To make the backup, you can use the <application>pg_dumpall</application>
      command from the version you are currently running;  see <xref
      linkend="backup-dump-all"/> for more details.  For best
      results, however, try to use the <application>pg_dumpall</application>
      command from <productname>PostgreSQL</productname> &version;,
      since this version contains bug fixes and improvements over older
      versions.  While this advice might seem idiosyncratic since you
      haven't installed the new version yet, it is advisable to follow
      it if you plan to install the new version in parallel with the
      old version.  In that case you can complete the installation
      normally and transfer the data later.  This will also decrease
      the downtime.
     </para>
________________________________________________________-->
     <para>
      要制作备份，你可以使用你正在运行版本的<application>pg_dumpall</application>命令，详见<xref linkend="backup-dump-all"/>。但是，要得到最好的结果，试试使用<productname>PostgreSQL</productname> &version; 的<application>pg_dumpall</application>命令，因为这个版本包含了对旧版本的缺陷修复和改进。虽然这个建议可能看起来很奇怪，因为你还没有安装新版本，但如果你计划平行地安装新版本，遵循这个建议是很明智的。在这种情况下，你可以正常完成安装并且稍后再来传输数据。这也将减少停机时间。
     </para>
<!-- pgdoc-cn_end sig_en=9c692cba5827c4dc64dde2f461d8510b -->
    </step>

    <step>
<!-- pgdoc-cn_start sig_en=f0200e5cb38e0b9aa7d84fdd22d9a588 sig_cn_org=None source=14.1 
     <para>
      Shut down the old server:
<screen>
<userinput>pg_ctl stop</userinput>
</screen>
      On systems that have <productname>PostgreSQL</productname> started at boot time,
      there is probably a start-up file that will accomplish the same thing. For
      example, on a <systemitem class="osname">Red Hat Linux</systemitem> system one
      might find that this works:
<screen>
<userinput>/etc/rc.d/init.d/postgresql stop</userinput>
</screen>
      See <xref linkend="runtime"/> for details about starting and
      stopping the server.
     </para>
________________________________________________________-->
     <para>
      关闭旧服务器：
<screen>
<userinput>pg_ctl stop</userinput>
</screen>
      在那些自动启动<productname>PostgreSQL</productname>的系统上，可能有一个启动文件将完成同样的事情。例如，在一个<systemitem class="osname">Red Hat Linux</systemitem>系统中，我们会发现这也能用：
<screen>
<userinput>/etc/rc.d/init.d/postgresql stop</userinput>
</screen>
      关于启动和停止服务器的细节请见<xref linkend="runtime"/>。
     </para>
<!-- pgdoc-cn_end sig_en=f0200e5cb38e0b9aa7d84fdd22d9a588 -->
    </step>

    <step>
<!-- pgdoc-cn_start sig_en=a21112273987765fbae0fbb1aaa0da79 sig_cn_org=None source=14.1 
     <para>
      If restoring from backup, rename or delete the old installation
      directory if it is not version-specific.  It is a good idea to
      rename the directory, rather than
      delete it, in case you have trouble and need to revert to it.  Keep
      in mind the directory might consume significant disk space.  To rename
      the directory, use a command like this:
<screen>
<userinput>mv /usr/local/pgsql /usr/local/pgsql.old</userinput>
</screen>
     (Be sure to move the directory as a single unit so relative paths
     remain unchanged.)
     </para>
________________________________________________________-->
     <para>
      如果从备份恢复，重命名或删除旧的安装目录（如果它不是针对特定版本的）。重命名该目录是一个好主意，而不是删除它，因为如果你碰到问题并需要返回到它，它还存在。记住该目录可能消耗可观的磁盘空间。要重命名该目录，使用类似的命令：
<screen>
<userinput>mv /usr/local/pgsql /usr/local/pgsql.old</userinput>
</screen>
     （注意将该目录作为一个单一单元移动，这样相对路径可以保持不变）。
     </para>
<!-- pgdoc-cn_end sig_en=a21112273987765fbae0fbb1aaa0da79 -->
    </step>

    <step>
<!-- pgdoc-cn_start sig_en=fdcea5d5c8964bffbaf60e5cee5d3b9e sig_cn_org=None source=14.1 
     <para>
      Install the new version of <productname>PostgreSQL</productname> as
      outlined in <xref linkend="install-procedure"/>.
     </para>
________________________________________________________-->
     <para>
      安装新版本的<productname>PostgreSQL</productname>在<xref linkend="install-procedure"/>
     </para>
<!-- pgdoc-cn_end sig_en=fdcea5d5c8964bffbaf60e5cee5d3b9e -->
    </step>

    <step>
<!-- pgdoc-cn_start sig_en=0d30d6e45f404ecf8889328bf95d7268 sig_cn_org=None source=14.1 
     <para>
      Create a new database cluster if needed.  Remember that you must
      execute these commands while logged in to the special database user
      account (which you already have if you are upgrading).
<programlisting>
<userinput>/usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data</userinput>
</programlisting>
     </para>
________________________________________________________-->
     <para>
      如果需要，创建一个新的数据库集簇。记住你必须在登录到一个特殊的数据库用户账户（如果你在升级，你就已经有了这个账户）时执行这些命令。
<programlisting>
<userinput>/usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data</userinput>
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=0d30d6e45f404ecf8889328bf95d7268 -->
    </step>

    <step>
<!-- pgdoc-cn_start sig_en=f9ae336df5d54277cbda5d2188854876 sig_cn_org=None source=14.1 
     <para>
      Restore your previous <filename>pg_hba.conf</filename> and any
      <filename>postgresql.conf</filename> modifications.
     </para>
________________________________________________________-->
     <para>
      恢复你之前的<filename>pg_hba.conf</filename>以及任何<filename>postgresql.conf</filename>修改。
     </para>
<!-- pgdoc-cn_end sig_en=f9ae336df5d54277cbda5d2188854876 -->
    </step>

    <step>
<!-- pgdoc-cn_start sig_en=8db75b759439aae81b774b81ae1bc785 sig_cn_org=None source=14.1 
     <para>
      Start the database server, again using the special database user
      account:
<programlisting>
<userinput>/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data</userinput>
</programlisting>
     </para>
________________________________________________________-->
     <para>
      启动数据库服务器，也要使用特殊的数据库用户账户：
<programlisting>
<userinput>/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data</userinput>
</programlisting>
     </para>
<!-- pgdoc-cn_end sig_en=8db75b759439aae81b774b81ae1bc785 -->
    </step>

    <step>
<!-- pgdoc-cn_start sig_en=275561f293faeb2ff3f3a0d370f4d050 sig_cn_org=None source=14.1 
     <para>
      Finally, restore your data from backup with:
<screen>
<userinput>/usr/local/pgsql/bin/psql -d postgres -f <replaceable>outputfile</replaceable></userinput>
</screen>
      using the <emphasis>new</emphasis> <application>psql</application>.
     </para>
________________________________________________________-->
     <para>
      最后，使用<emphasis>新的</emphasis> <application>psql</application>从备份恢复你的数据：
<screen>
<userinput>/usr/local/pgsql/bin/psql -d postgres -f <replaceable>outputfile</replaceable></userinput>
</screen>
      使用 <emphasis>new</emphasis> <application>psql</application>.
     </para>
<!-- pgdoc-cn_end sig_en=275561f293faeb2ff3f3a0d370f4d050 -->
    </step>
   </procedure>

<!-- pgdoc-cn_start sig_en=d65cf2923a3891344a1b06edefebf6c9 sig_cn_org=None source=14.1 
   <para>
    The least downtime can be achieved by installing the new server in
    a different directory and running both the old and the new servers
    in parallel, on different ports. Then you can use something like:

<programlisting>
pg_dumpall -p 5432 | psql -d postgres -p 5433
</programlisting>
    to transfer your data.
   </para>
________________________________________________________-->
   <para>
    通过在一个不同的目录中安装新的服务器并且并行地在不同的端口运行新旧两个服务器可以达到最低的停机时间。那么你可以这样用：

<programlisting>
pg_dumpall -p 5432 | psql -d postgres -p 5433
</programlisting>
    来转移你的数据。
   </para>
<!-- pgdoc-cn_end sig_en=d65cf2923a3891344a1b06edefebf6c9 -->

  </sect2>

  <sect2 id="upgrading-via-pg-upgrade">
<!-- pgdoc-cn_start sig_en=7fad35c0c6a8a1c6eee0ceb8b1297c76 sig_cn_org=None source=14.1 
   <title>Upgrading Data via <application>pg_upgrade</application></title>
________________________________________________________-->
   <title>通过<application>pg_upgrade</application>升级数据</title>
<!-- pgdoc-cn_end sig_en=7fad35c0c6a8a1c6eee0ceb8b1297c76 -->

<!-- pgdoc-cn_start sig_en=8a76f868ca5dce9990ac8c559341aaf4 sig_cn_org=None source=14.1 
   <para>
    The <xref linkend="pgupgrade"/> module allows an installation to
    be migrated in-place from one major <productname>PostgreSQL</productname>
    version to another.  Upgrades can be performed in minutes,
    particularly with <option>-&minus;link</option> mode.  It requires steps similar to
    <application>pg_dumpall</application> above, e.g.,  starting/stopping the server,
    running <application>initdb</application>.  The <application>pg_upgrade</application> <link
    linkend="pgupgrade">documentation</link> outlines the necessary steps.
   </para>
________________________________________________________-->
   <para>
    <xref linkend="pgupgrade"/>模块允许一个安装从一个
    <productname>PostgreSQL</productname>主版本“就地”升级成另一个主版本。
    升级可以在数分钟内被执行，特别是使用<option>--link</option>模式时。它
    要求和上面的<application>pg_dumpall</application>相似的步骤，例如启动/停止
    服务器、运行<application>initdb</application>。<application>pg_upgrade</application>
    <link linkend="pgupgrade">文档</link>概述了所需的步骤。
   </para>
<!-- pgdoc-cn_end sig_en=8a76f868ca5dce9990ac8c559341aaf4 -->

  </sect2>

  <sect2 id="upgrading-via-replication">
<!-- pgdoc-cn_start sig_en=c07a0d6b068c39f329f335381f987380 sig_cn_org=None source=14.1 
   <title>Upgrading Data via Replication</title>
________________________________________________________-->
   <title>通过复制升级数据</title>
<!-- pgdoc-cn_end sig_en=c07a0d6b068c39f329f335381f987380 -->

<!-- pgdoc-cn_start sig_en=532c7474bf905e3b9920dd9078a2853e sig_cn_org=None source=14.1 
   <para>
    It is also possible to use logical replication methods to create a standby
    server with the updated version of <productname>PostgreSQL</productname>.
    This is possible because logical replication supports
    replication between different major versions of
    <productname>PostgreSQL</productname>.  The standby can be on the same computer or
    a different computer.  Once it has synced up with the primary server
    (running the older version of <productname>PostgreSQL</productname>), you can
    switch primaries and make the standby the primary and shut down the older
    database instance.  Such a switch-over results in only several seconds
    of downtime for an upgrade.
   </para>
________________________________________________________-->
   <para>
    也可以用<productname>PostgreSQL</productname>的已更新版本逻辑复制来创建一个后备服务器，逻辑复制支持在不同主版本的<productname>PostgreSQL</productname>之间的复制。
    后备服务器可以在同一台计算机或者不同的计算机上。
    一旦它和主服务器（运行旧版本的<productname>PostgreSQL</productname>）同步好，你可以切换主机并且将后备服务器作为主机，然后关闭旧的数据库实例。
    这样一种切换使得一次升级的停机时间只有数秒。
   </para>
<!-- pgdoc-cn_end sig_en=532c7474bf905e3b9920dd9078a2853e -->

<!-- pgdoc-cn_start sig_en=1b031ea03f6fe10df9ffdc20eed71a14 sig_cn_org=None source=14.1 
   <para>
    This method of upgrading can be performed using the built-in logical
    replication facilities as well as using external logical replication
    systems such as <productname>pglogical</productname>,
    <productname>Slony</productname>, <productname>Londiste</productname>, and
    <productname>Bucardo</productname>.
   </para>
________________________________________________________-->
   <para>
    这种升级方法可以用内置的逻辑复制工具和外部的逻辑复制系统如<productname>pglogical</productname>，<productname>Slony</productname>，<productname>Londiste</productname>，和<productname>Bucardo</productname>。
   </para>
<!-- pgdoc-cn_end sig_en=1b031ea03f6fe10df9ffdc20eed71a14 -->
  </sect2>
 </sect1>

 <sect1 id="preventing-server-spoofing">
<!-- pgdoc-cn_start sig_en=eded371c926feef0d5386098dbe5fbbd sig_cn_org=None source=14.1 
  <title>Preventing Server Spoofing</title>
________________________________________________________-->
  <title>阻止服务器欺骗</title>
<!-- pgdoc-cn_end sig_en=eded371c926feef0d5386098dbe5fbbd -->

<!-- pgdoc-cn_start sig_en=6c0fbb39f87cac05cc0b7307bca4c032 sig_cn_org=None source=14.1 
  <indexterm zone="preventing-server-spoofing">
   <primary>server spoofing</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="preventing-server-spoofing">
   <primary>服务器欺骗</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=6c0fbb39f87cac05cc0b7307bca4c032 -->

<!-- pgdoc-cn_start sig_en=8e1ea283403f117759f96915839bf928 sig_cn_org=None source=14.1 
  <para>
   While the server is running, it is not possible for a malicious user
   to take the place of the normal database server.  However, when the
   server is down, it is possible for a local user to spoof the normal
   server by starting their own server.  The spoof server could read
   passwords and queries sent by clients, but could not return any data
   because the <varname>PGDATA</varname> directory would still be secure because
   of directory permissions. Spoofing is possible because any user can
   start a database server; a client cannot identify an invalid server
   unless it is specially configured.
  </para>
________________________________________________________-->
  <para>
   服务器在运行时，它不可能让恶意用户取代正常的数据库服务器。然而，当服务器关闭时， 一个本地用户可以通过启动它们自己的服务器来欺骗正常的服务器。行骗的服务器可以读取客户端发送的密码和查询语句， 但是不会返回任何数据，因为<varname>PGDATA</varname>这个目录是安全的（它有目录权限）。 欺骗是可能的，因为任何用户都可以启动一个数据库服务器；客户端无法识别一个无效的服务器，除非它被专门配置。
  </para>
<!-- pgdoc-cn_end sig_en=8e1ea283403f117759f96915839bf928 -->

<!-- pgdoc-cn_start sig_en=02f44d7c67842ddfb7ca8f77c01abd02 sig_cn_org=None source=14.1 
  <para>
   One way to prevent spoofing of <literal>local</literal>
   connections is to use a Unix domain socket directory (<xref
   linkend="guc-unix-socket-directories"/>) that has write permission only
   for a trusted local user.  This prevents a malicious user from creating
   their own socket file in that directory.  If you are concerned that
   some applications might still reference <filename>/tmp</filename> for the
   socket file and hence be vulnerable to spoofing, during operating system
   startup create a symbolic link <filename>/tmp/.s.PGSQL.5432</filename> that points
   to the relocated socket file.  You also might need to modify your
   <filename>/tmp</filename> cleanup script to prevent removal of the symbolic link.
  </para>
________________________________________________________-->
  <para>
   一种阻止<literal>local</literal>连接欺骗的方法是使用一个 Unix 域套接字目录 （<xref
   linkend="guc-unix-socket-directories"/>），该目录只对一个被信任的本地用户有写权限。 这可以防止恶意用户在该目录中创建自己的套接字文件。如果你担心有些应用程序可能仍然引用<filename>/tmp</filename>下的套接字文件并且因此容易受到欺骗，可在操作系统启动时创建一个符号链接<filename>/tmp/.s.PGSQL.5432</filename>指向一个被重定位的套接字文件。你也可能需要修改<filename>/tmp</filename>清除脚本防止删除这个符号链接。
  </para>
<!-- pgdoc-cn_end sig_en=02f44d7c67842ddfb7ca8f77c01abd02 -->

<!-- pgdoc-cn_start sig_en=34d852d43db1d0be1dd7317cc4a630df sig_cn_org=None source=14.1 
  <para>
   Another option for <literal>local</literal> connections is for clients to use
   <link linkend="libpq-connect-requirepeer"><literal>requirepeer</literal></link>
   to specify the required owner of the server process connected to
   the socket.
  </para>
________________________________________________________-->
  <para>
   <literal>local</literal>连接的另一个选项是对客户端使用<link linkend="libpq-connect-requirepeer"><literal>requirepeer</literal></link>指定所需的连接到该套接字的服务器进程的拥有者。
  </para>
<!-- pgdoc-cn_end sig_en=34d852d43db1d0be1dd7317cc4a630df -->

<!-- pgdoc-cn_start sig_en=e08eb8e0c6fde2a840b26c4ff3f3ad7e sig_cn_org=None source=14.1 
  <para>
   To prevent spoofing on TCP connections, either use
   SSL certificates and make sure that clients check the server's certificate,
   or use GSSAPI encryption (or both, if they're on separate connections).
  </para>
________________________________________________________-->
  <para>
   要在TCP连接上防止欺骗，要么使用 SSL 证书，并且确保客户检查服务器的证书，或者使用GSSAPI加密（或者两者都用，如果它们位于单独的连接上）。
  </para>
<!-- pgdoc-cn_end sig_en=e08eb8e0c6fde2a840b26c4ff3f3ad7e -->

<!-- pgdoc-cn_start sig_en=8654d97ad349ec4f1a1998c33a3fccda sig_cn_org=None source=14.1 
  <para>
   To prevent spoofing with SSL, the server
   must be configured to accept only <literal>hostssl</literal> connections (<xref
   linkend="auth-pg-hba-conf"/>) and have SSL key and certificate files
   (<xref linkend="ssl-tcp"/>). The TCP client must connect using
   <literal>sslmode=verify-ca</literal> or
   <literal>verify-full</literal> and have the appropriate root certificate
   file installed (<xref linkend="libq-ssl-certificates"/>).
  </para>
________________________________________________________-->
  <para>
   要防止 SSL 欺骗，服务器必须配置为仅接受<literal>hostssl</literal>连接（<xref linkend="auth-pg-hba-conf"/>），并且有 SSL 密钥和证书文件（<xref linkend="ssl-tcp"/>）。 TCP 客户端连接必须使用<literal>sslmode=verify-ca</literal>或<literal>verify-full</literal>进行连接，并且安装有适当的根证书文件<xref linkend="libq-ssl-certificates"/>）。
  </para>
<!-- pgdoc-cn_end sig_en=8654d97ad349ec4f1a1998c33a3fccda -->

<!-- pgdoc-cn_start sig_en=7645b1576b8a08dfdcd8fb08ac711965 sig_cn_org=None source=14.1 
  <para>
    To prevent spoofing with GSSAPI, the server must be configured to accept
    only <literal>hostgssenc</literal> connections
    (<xref linkend="auth-pg-hba-conf"/>) and use <literal>gss</literal>
    authentication with them.  The TCP client must connect
    using <literal>gssencmode=require</literal>.
  </para>
________________________________________________________-->
  <para>
    要防止 GSSAPI 欺骗，必须将服务器配置为仅接受<literal>hostgssenc</literal>连接 (<xref linkend="auth-pg-hba-conf"/>) 并对它们使用<literal>gss</literal>身份验证。
    TCP 客户端必须使用 <literal>gssencmode=require</literal>连接。
  </para>
<!-- pgdoc-cn_end sig_en=7645b1576b8a08dfdcd8fb08ac711965 -->
 </sect1>

 <sect1 id="encryption-options">
<!-- pgdoc-cn_start sig_en=47ab7f5e3a8a611f2576db7f63c662bb sig_cn_org=None source=14.1 
  <title>Encryption Options</title>
________________________________________________________-->
  <title>加密选项</title>
<!-- pgdoc-cn_end sig_en=47ab7f5e3a8a611f2576db7f63c662bb -->

<!-- pgdoc-cn_start sig_en=0a2cdf618513c5056b18b0f51a2f0c53 sig_cn_org=None source=14.1 
  <indexterm zone="encryption-options">
   <primary>encryption</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="encryption-options">
   <primary>加密</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=0a2cdf618513c5056b18b0f51a2f0c53 -->

<!-- pgdoc-cn_start sig_en=fa1ac6a2862e0f99927eef7c6899667e sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> offers encryption at several
   levels, and provides flexibility in protecting data from disclosure
   due to database server theft, unscrupulous administrators, and
   insecure networks. Encryption might also be required to secure
   sensitive data such as medical records or financial transactions.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>提供了几个不同级别的加密， 并且在保护数据不会因为数据库服务器偷窃、不道德的管理员、不安全网络等因素而泄漏方面 提供很高的灵活性。加密可能也是保护一些诸如医疗记录或财务交易等敏感数据所要求的。
  </para>
<!-- pgdoc-cn_end sig_en=fa1ac6a2862e0f99927eef7c6899667e -->

  <variablelist>

  <varlistentry>
<!-- pgdoc-cn_start sig_en=d512605c4d1ca31db04f88723c60ef36 sig_cn_org=None source=14.1 
   <term>Password Encryption</term>
________________________________________________________-->
   <term>口令加密</term>
<!-- pgdoc-cn_end sig_en=d512605c4d1ca31db04f88723c60ef36 -->
   <listitem>

<!-- pgdoc-cn_start sig_en=cad854b5a127afa9d44af91eabcb4782 sig_cn_org=None source=14.1 
    <para>
     Database user passwords are stored as hashes (determined by the setting
     <xref linkend="guc-password-encryption"/>), so the administrator cannot
     determine the actual password assigned to the user. If SCRAM or MD5
     encryption is used for client authentication, the unencrypted password is
     never even temporarily present on the server because the client encrypts
     it before being sent across the network. SCRAM is preferred, because it
     is an Internet standard and is more secure than the PostgreSQL-specific
     MD5 authentication protocol.
    </para>
________________________________________________________-->
    <para>
     数据库用户的口令都是以哈希(取决于<xref linkend="guc-password-encryption"/>配置)的方式存储， 所以管理员不能限定实际的口令赋予用户。如果 SCRAM 或者 MD5 加密算法被用于客户端认证， 那么未加密的口令甚至都不可能出现在服务器上，因为客户端在通过网络发送口令之前，就已经加密过。推荐使用SCRAM，因为它是互联网标准而且相比于PostgreSQL特定的MD5认证协议更安全。
    </para>
<!-- pgdoc-cn_end sig_en=cad854b5a127afa9d44af91eabcb4782 -->
   </listitem>
  </varlistentry>

  <varlistentry>
<!-- pgdoc-cn_start sig_en=1ca6c89f019cf81649eca6e0085bf0aa sig_cn_org=None source=14.1 
   <term>Encryption For Specific Columns</term>
________________________________________________________-->
   <term>指定列加密</term>
<!-- pgdoc-cn_end sig_en=1ca6c89f019cf81649eca6e0085bf0aa -->

   <listitem>
<!-- pgdoc-cn_start sig_en=cd3dab37fe87df93746de1882562eff1 sig_cn_org=None source=14.1 
    <para>
     The <xref linkend="pgcrypto"/> module allows certain fields to be
     stored encrypted.
     This is useful if only some of the data is sensitive.
     The client supplies the decryption key and the data is decrypted
     on the server and then sent to the client.
    </para>
________________________________________________________-->
    <para>
     <xref linkend="pgcrypto"/>模块允许对特定域进行加密存储。这个功能只对某些敏感数据有用。 客户端提供解密的密钥，然后数据在服务器端解密并发送给客户端。
    </para>
<!-- pgdoc-cn_end sig_en=cd3dab37fe87df93746de1882562eff1 -->

<!-- pgdoc-cn_start sig_en=c0a222b9478f629f9156ca30ce07fb16 sig_cn_org=None source=14.1 
    <para>
     The decrypted data and the decryption key are present on the
     server for a brief time while it is being decrypted and
     communicated between the client and server. This presents a brief
     moment where the data and keys can be intercepted by someone with
     complete access to the database server, such as the system
     administrator.
    </para>
________________________________________________________-->
    <para>
     在数据被解密和在服务器与客户端之间传递时，解密数据和解密密钥将会在服务器端存在短暂的一段时间。 这就给那些能完全访问数据库服务器的人提供了一个短暂的截获密钥和数据的时间，例如系统管理员。
    </para>
<!-- pgdoc-cn_end sig_en=c0a222b9478f629f9156ca30ce07fb16 -->
   </listitem>
  </varlistentry>

  <varlistentry>
<!-- pgdoc-cn_start sig_en=b90dfecba381ae907396f14cbef44ca7 sig_cn_org=None source=14.1 
   <term>Data Partition Encryption</term>
________________________________________________________-->
   <term>数据分区加密</term>
<!-- pgdoc-cn_end sig_en=b90dfecba381ae907396f14cbef44ca7 -->

   <listitem>
<!-- pgdoc-cn_start sig_en=c2dcfe2ace639caff7ebf46e564f81bf sig_cn_org=None source=14.1 
    <para>
     Storage encryption can be performed at the file system level or the
     block level.  Linux file system encryption options include eCryptfs
     and EncFS, while FreeBSD uses PEFS.  Block level or full disk
     encryption options include dm-crypt + LUKS on Linux and GEOM
     modules geli and gbde on FreeBSD.  Many other operating systems
     support this functionality, including Windows.
    </para>
________________________________________________________-->
    <para>
     存储加密可以在文件系统层面或者块层面上执行。Linux 文件系统加密
     选项包括 eCryptfs 和 EncFS，而 FreeBSD 使用 PEFS。快层面或者全
     盘加密选项包括 Linux 上的 dm-crypt + LUKS 以及 FreeBSD 上的
     GEOM 模块 geli 及 gbde。很多其他操作系统也支持这个功能，包括
     Windows。
    </para>
<!-- pgdoc-cn_end sig_en=c2dcfe2ace639caff7ebf46e564f81bf -->

<!-- pgdoc-cn_start sig_en=e0e43f56e562ea84919d79b39ff4b259 sig_cn_org=None source=14.1 
    <para>
     This mechanism prevents unencrypted data from being read from the
     drives if the drives or the entire computer is stolen. This does
     not protect against attacks while the file system is mounted,
     because when mounted, the operating system provides an unencrypted
     view of the data. However, to mount the file system, you need some
     way for the encryption key to be passed to the operating system,
     and sometimes the key is stored somewhere on the host that mounts
     the disk.
    </para>
________________________________________________________-->
    <para>
     这个机制避免了在整个计算机或者驱动器被盗的情况下， 未加密的数据被从驱动器中读取。它无法防止在文件系统被挂 载时的攻击，因为在挂载之后，操作系统提供数据的解密视图。不过，要想挂载该文件系统，你需要有一些方法把加密密钥传递给操作 系统，并且有时候这个密钥就存储在挂载该磁盘的主机上的某处。
    </para>
<!-- pgdoc-cn_end sig_en=e0e43f56e562ea84919d79b39ff4b259 -->
   </listitem>
  </varlistentry>

  <varlistentry>
<!-- pgdoc-cn_start sig_en=bdd74db6cffaefd11322f2c195aae788 sig_cn_org=None source=14.1 
   <term>Encrypting Data Across A Network</term>
________________________________________________________-->
   <term>跨网络加密数据</term>
<!-- pgdoc-cn_end sig_en=bdd74db6cffaefd11322f2c195aae788 -->

    <listitem>
<!-- pgdoc-cn_start sig_en=05a1ffad7c9bf239900c288e54ee2ca7 sig_cn_org=None source=14.1 
     <para>
      SSL connections encrypt all data sent across the network: the
      password, the queries, and the data returned. The
      <filename>pg_hba.conf</filename> file allows administrators to specify
      which hosts can use non-encrypted connections (<literal>host</literal>)
      and which require SSL-encrypted connections
      (<literal>hostssl</literal>). Also, clients can specify that they
      connect to servers only via SSL.
     </para>
________________________________________________________-->
     <para>
      SSL 连接加密所有跨网络发送的数据：口令、查询以及返回的数据。<filename>pg_hba.conf</filename>文件允许管理员指定哪些主机可以使用 非加密连接（<literal>host</literal>），以及哪些主机需要使用 SSL 加密的连接（<literal>hostssl</literal>）。
      客户端还可以指定它们只通过 SSL 连接到服务器。
     </para>
<!-- pgdoc-cn_end sig_en=05a1ffad7c9bf239900c288e54ee2ca7 -->

<!-- pgdoc-cn_start sig_en=b90270b58ac722c4f777fe09267a1f52 sig_cn_org=None source=14.1 
     <para>
      GSSAPI-encrypted connections encrypt all data sent across the network,
      including queries and data returned.  (No password is sent across the
      network.)  The <filename>pg_hba.conf</filename> file allows
      administrators to specify which hosts can use non-encrypted connections
      (<literal>host</literal>) and which require GSSAPI-encrypted connections
      (<literal>hostgssenc</literal>).  Also, clients can specify that they
      connect to servers only on GSSAPI-encrypted connections
      (<literal>gssencmode=require</literal>).
     </para>
________________________________________________________-->
     <para>
      GSSAPI 加密的连接加密通过网络发送的所有数据，包括查询和返回的数据。（不会在网络中发送密码。）
      <filename>pg_hba.conf</filename> 文件允许管理员指定哪些主机可以使用非加密连接 (<literal>host</literal>) 和哪些主机需要 GSSAPI-加密连接(<literal>hostgssenc</literal>。 
      此外，客户端还可以指定它们仅在GSSAPI-加密的连接上来连接服务器(<literal>gssencmode=require</literal>)。
     </para>
<!-- pgdoc-cn_end sig_en=b90270b58ac722c4f777fe09267a1f52 -->

<!-- pgdoc-cn_start sig_en=b46a4f83824f69def74060aeefcb5a11 sig_cn_org=None source=14.1 
     <para>
      <application>Stunnel</application> or
      <application>SSH</application> can also be used to encrypt
      transmissions.
     </para>
________________________________________________________-->
     <para>
      <application>Stunnel</application> 或 <application>SSH</application> 也能够被用于加密传输。
     </para>
<!-- pgdoc-cn_end sig_en=b46a4f83824f69def74060aeefcb5a11 -->
    </listitem>
  </varlistentry>

  <varlistentry>
<!-- pgdoc-cn_start sig_en=a54f594a2c731998cff5eb63fe2d7ae3 sig_cn_org=None source=14.1 
   <term>SSL Host Authentication</term>
________________________________________________________-->
   <term>SSL 主机认证</term>
<!-- pgdoc-cn_end sig_en=a54f594a2c731998cff5eb63fe2d7ae3 -->

   <listitem>
<!-- pgdoc-cn_start sig_en=1abdfb93d7bb17bb766a967ee9805e5a sig_cn_org=None source=14.1 
    <para>
     It is possible for both the client and server to provide SSL
     certificates to each other. It takes some extra configuration
     on each side, but this provides stronger verification of identity
     than the mere use of passwords. It prevents a computer from
     pretending to be the server just long enough to read the password
     sent by the client. It also helps prevent <quote>man in the middle</quote>
     attacks where a computer between the client and server pretends to
     be the server and reads and passes all data between the client and
     server.
    </para>
________________________________________________________-->
    <para>
     客户端和主机都可以提供 SSL 证书给对方。这在两边都需要一些额外的配置， 但是这种方式提供了比仅使用口令更强的身份验证。 它避免一个计算机伪装成服务器，这个时长只要足够读取客户端发送的口令就行了。它还避免了 <quote>中间人</quote>攻击，在其中有一台计算机处于客户端和服务器之间并伪装成服务器读取和传递两者之间的所有数据。
    </para>
<!-- pgdoc-cn_end sig_en=1abdfb93d7bb17bb766a967ee9805e5a -->
   </listitem>
  </varlistentry>

  <varlistentry>
<!-- pgdoc-cn_start sig_en=5baa1c4907ac1267b1a16e5763f40143 sig_cn_org=None source=14.1 
   <term>Client-Side Encryption</term>
________________________________________________________-->
   <term>客户端加密</term>
<!-- pgdoc-cn_end sig_en=5baa1c4907ac1267b1a16e5763f40143 -->

   <listitem>
<!-- pgdoc-cn_start sig_en=ebc8ba859c5edaeb46791a3665892cef sig_cn_org=None source=14.1 
    <para>
     If the system administrator for the server's machine cannot be trusted,
     it is necessary
     for the client to encrypt the data; this way, unencrypted data
     never appears on the database server. Data is encrypted on the
     client before being sent to the server, and database results have
     to be decrypted on the client before being used.
    </para>
________________________________________________________-->
    <para>
     如果服务器所在机器的系统管理员是不可信的，那么客户端加密数据也是必要的。在这种情况下，未加密的数据从来不会在数据库服务器上出现。数据在发送给服务器之前加密，而数据库结果在能使用之前必须在客户端上解密。
    </para>
<!-- pgdoc-cn_end sig_en=ebc8ba859c5edaeb46791a3665892cef -->
   </listitem>
  </varlistentry>

  </variablelist>

 </sect1>

 <sect1 id="ssl-tcp">
<!-- pgdoc-cn_start sig_en=edd75c470605c0ca8ce4895b3a1981c1 sig_cn_org=None source=14.1 
  <title>Secure TCP/IP Connections with SSL</title>
________________________________________________________-->
  <title>用 SSL 进行安全的 TCP/IP 连接</title>
<!-- pgdoc-cn_end sig_en=edd75c470605c0ca8ce4895b3a1981c1 -->

<!-- pgdoc-cn_start sig_en=325e531c30e52b5c04a531cc86fbc524 sig_cn_org=c79cfad4b0b9af6d960219b5e0f769c0 source=15.7 
  <indexterm zone="ssl-tcp">
   <primary>SSL</primary>
   <secondary>TLS</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="ssl-tcp">
   <primary>SSL</primary>
   <secondary>TLS</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=325e531c30e52b5c04a531cc86fbc524 -->

<!-- pgdoc-cn_start sig_en=2695c5c69e2d7b595fc0ea7dfe8ac517 sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> has native support for using
   <acronym>SSL</acronym> connections to encrypt client/server communications
   for increased security. This requires that
   <productname>OpenSSL</productname> is installed on both client and
   server systems and that support in <productname>PostgreSQL</productname> is
   enabled at build time (see <xref linkend="installation"/>).
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname> 有一个对使用 <acronym>SSL</acronym> 连接加密客户端/服务器通讯的本地支持，它可以增加安全性。这个特性要求在客户端和服务器端都安装 <productname>OpenSSL</productname> 并且在编译 <productname>PostgreSQL</productname> 的时候打开这个支持（见<xref linkend="installation"/>）。
  </para>
<!-- pgdoc-cn_end sig_en=2695c5c69e2d7b595fc0ea7dfe8ac517 -->

<!-- pgdoc-cn_start sig_en=82368a3bd49f80542db9fe201a1d3f2f sig_cn_org=c78cfb124cf6ec4e4fcbf81ac88d38af source=15.7 
  <para>
   The terms <acronym>SSL</acronym> and <acronym>TLS</acronym> are often used
   interchangeably to mean a secure encrypted connection using a
   <acronym>TLS</acronym> protocol. <acronym>SSL</acronym> protocols are the
   precursors to <acronym>TLS</acronym> protocols, and the term
   <acronym>SSL</acronym> is still used for encrypted connections even though
   <acronym>SSL</acronym> protocols are no longer supported.
   <acronym>SSL</acronym> is used interchangeably with <acronym>TLS</acronym>
   in <productname>PostgreSQL</productname>.

  </para>
________________________________________________________-->
  <para>
   术语<acronym>SSL</acronym>和<acronym>TLS</acronym>经常被互换使用，意思是使用<acronym>TLS</acronym>协议的安全加密连接。
   <acronym>SSL</acronym>协议是<acronym>TLS</acronym>协议的前身，即使<acronym>SSL</acronym>协议不再受支持，术语<acronym>SSL</acronym>仍然用于加密连接。
   在<productname>PostgreSQL</productname>中，<acronym>SSL</acronym>与<acronym>TLS</acronym>可以互换使用。
</para>
<!-- pgdoc-cn_end sig_en=82368a3bd49f80542db9fe201a1d3f2f -->
  <sect2 id="ssl-setup">
<!-- pgdoc-cn_start sig_en=53a0cd08279ef5a6ae801df170b2c9c2 sig_cn_org=None source=14.1 
   <title>Basic Setup</title>
________________________________________________________-->
   <title>Basic Setup</title>
<!-- pgdoc-cn_end sig_en=53a0cd08279ef5a6ae801df170b2c9c2 -->

<!-- pgdoc-cn_start sig_en=3be08cfea3f276dc61711a85e05e5f3b sig_cn_org=3dee11eae8d8b7b5f9554b3687059c46 source=15.7 
  <para>
   With <acronym>SSL</acronym> support compiled in, the
   <productname>PostgreSQL</productname> server can be started with
   support for encrypted connections using <acronym>TLS</acronym> protocols
   enabled by setting the parameter
   <xref linkend="guc-ssl"/> to <literal>on</literal> in
   <filename>postgresql.conf</filename>.  The server will listen for both normal
   and <acronym>SSL</acronym> connections on the same TCP port, and will negotiate
   with any connecting client on whether to use <acronym>SSL</acronym>.  By
   default, this is at the client's option; see <xref
   linkend="auth-pg-hba-conf"/> about how to set up the server to require
   use of <acronym>SSL</acronym> for some or all connections.
  </para>
________________________________________________________-->
  <para>
   使用已编译支持<acronym>SSL</acronym>的<productname>PostgreSQL</productname>服务器可以通过在<filename>postgresql.conf</filename>中将参数<xref linkend="guc-ssl"/>设置为<literal>on</literal>来启用对使用<acronym>TLS</acronym>协议的加密连接的支持。服务器将在同一TCP端口上同时监听普通连接和<acronym>SSL</acronym>连接，并将与任何连接的客户端协商是否使用<acronym>SSL</acronym>。默认情况下，这取决于客户端的选择；请参阅<xref linkend="auth-pg-hba-conf"/>了解如何设置服务器以要求对某些或所有连接使用<acronym>SSL</acronym>。
  </para>
<!-- pgdoc-cn_end sig_en=3be08cfea3f276dc61711a85e05e5f3b -->

<!-- pgdoc-cn_start sig_en=64fd6e851dcf56e76763c182f50e1e2c sig_cn_org=None source=14.1 
  <para>
   To start in <acronym>SSL</acronym> mode, files containing the server certificate
   and private key must exist.  By default, these files are expected to be
   named <filename>server.crt</filename> and <filename>server.key</filename>, respectively, in
   the server's data directory, but other names and locations can be specified
   using the configuration parameters <xref linkend="guc-ssl-cert-file"/>
   and <xref linkend="guc-ssl-key-file"/>.
  </para>
________________________________________________________-->
  <para>
   要<acronym>SSL</acronym>模式中启动服务器，包含服务器证书和私钥的文件必须存在。默认情况下，这些文件应该分别被命名为<filename>server.crt</filename>和<filename>server.key</filename>并且被放在服务器的数据目录中，但是可以通过配置参数<xref linkend="guc-ssl-cert-file"/>和<xref linkend="guc-ssl-key-file"/>指定其他名称和位置。
   </para>
<!-- pgdoc-cn_end sig_en=64fd6e851dcf56e76763c182f50e1e2c -->

<!-- pgdoc-cn_start sig_en=4e0f00c4fc6003b896d1a2bfbe2c998b sig_cn_org=None source=14.1 
  <para>
   On Unix systems, the permissions on <filename>server.key</filename> must
   disallow any access to world or group; achieve this by the command
   <command>chmod 0600 server.key</command>.  Alternatively, the file can be
   owned by root and have group read access (that is, <literal>0640</literal>
   permissions).  That setup is intended for installations where certificate
   and key files are managed by the operating system.  The user under which
   the <productname>PostgreSQL</productname> server runs should then be made a
   member of the group that has access to those certificate and key files.
  </para>
________________________________________________________-->
  <para>
   在 Unix 系统上，<filename>server.key</filename>上的权限必须不允许所有人或组的任何访问，通过命令<command>chmod 0600 server.key</command>可以做到。或者，该文件可以由 root 所拥有并且具有组读访问（也就是<literal>0640</literal>权限）。这种设置适用于由操作系统管理证书和密钥文件的安装。用于运行<productname>PostgreSQL</productname>服务器的用户应该被作为能够访问那些证书和密钥文件的组成员。
  </para>
<!-- pgdoc-cn_end sig_en=4e0f00c4fc6003b896d1a2bfbe2c998b -->

<!-- pgdoc-cn_start sig_en=36efc180d080940448d2ec28303e3dca sig_cn_org=None source=14.1 
  <para>
    If the data directory allows group read access then certificate files may
    need to be located outside of the data directory in order to conform to the
    security requirements outlined above.  Generally, group access is enabled
    to allow an unprivileged user to backup the database, and in that case the
    backup software will not be able to read the certificate files and will
    likely error.
  </para>
________________________________________________________-->
  <para>
    如果数据目录允许组读取访问，则证书文件可能需要位于数据目录之外，以符合上面概述的安全要求。通常，启用组访问权限是为了允许非特权用户备份数据库，在这种情况下，备份软件将无法读取证书文件，并且可能会出错。
  </para>
<!-- pgdoc-cn_end sig_en=36efc180d080940448d2ec28303e3dca -->

<!-- pgdoc-cn_start sig_en=a77dad46504e1ef677768a780265b81c sig_cn_org=None source=14.1 
  <para>
   If the private key is protected with a passphrase, the
   server will prompt for the passphrase and will not start until it has
   been entered.
   Using a passphrase by default disables the ability to change the server's
   SSL configuration without a server restart, but see <xref
   linkend="guc-ssl-passphrase-command-supports-reload"/>.
   Furthermore, passphrase-protected private keys cannot be used at all
   on Windows.
  </para>
________________________________________________________-->
  <para>
   如果私钥被一个密码保护着，服务器将提示要求这个密码，并且在它被输入前不会启动。
   默认情况下，使用密码禁用在不重启服务器的情况下更改服务器的SSL配置的功能，并且参见 <xref linkend="guc-ssl-passphrase-command-supports-reload"/>。
   此外，密码保护的私钥在Windows上根本无法使用。
  </para>
<!-- pgdoc-cn_end sig_en=a77dad46504e1ef677768a780265b81c -->

<!-- pgdoc-cn_start sig_en=537bcab3e4dca371a27b79c747687296 sig_cn_org=None source=14.1 
  <para>
   The first certificate in <filename>server.crt</filename> must be the
   server's certificate because it must match the server's private key.
   The certificates of <quote>intermediate</quote> certificate authorities
   can also be appended to the file.  Doing this avoids the necessity of
   storing intermediate certificates on clients, assuming the root and
   intermediate certificates were created with <literal>v3_ca</literal>
   extensions.  (This sets the certificate's basic constraint of
   <literal>CA</literal> to <literal>true</literal>.)
   This allows easier expiration of intermediate certificates.
  </para>
________________________________________________________-->
  <para>
   <filename>server.crt</filename>中的第一个证书必须是服务器的证书，因为它必须与服务器的私钥匹配。
   <quote>intermediate</quote>的证书颁发机构，也可以追加到文件。
   假设根证书和中间证书是使用<literal>v3_ca</literal>扩展名创建的，那么这样做避免了在客户端上存储中间证书的必要。
   （这将证书的 <literal>CA</literal> 的基本约束设置为 <literal>true</literal>。）这使得中间证书更容易到期。
  </para>
<!-- pgdoc-cn_end sig_en=537bcab3e4dca371a27b79c747687296 -->

<!-- pgdoc-cn_start sig_en=0617902a84afa29511cb634414bca217 sig_cn_org=None source=14.1 
  <para>
   It is not necessary to add the root certificate to
   <filename>server.crt</filename>.  Instead, clients must have the root
   certificate of the server's certificate chain.
  </para>
________________________________________________________-->
  <para>
  无需将根证书添加到中<filename>server.crt</filename>。相反，客户端必须具有服务器证书链的根证书。
  </para>
<!-- pgdoc-cn_end sig_en=0617902a84afa29511cb634414bca217 -->
  </sect2>

  <sect2 id="ssl-openssl-config">
<!-- pgdoc-cn_start sig_en=a51148412239ca7cbec767e963c288ce sig_cn_org=None source=14.1 
   <title>OpenSSL Configuration</title>
________________________________________________________-->
   <title>OpenSSL配置</title>
<!-- pgdoc-cn_end sig_en=a51148412239ca7cbec767e963c288ce -->

<!-- pgdoc-cn_start sig_en=72bddbabad9157630ad37ccd6469fe3d sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> reads the system-wide
   <productname>OpenSSL</productname> configuration file. By default, this
   file is named <filename>openssl.cnf</filename> and is located in the
   directory reported by <literal>openssl version -d</literal>.
   This default can be overridden by setting environment variable
   <envar>OPENSSL_CONF</envar> to the name of the desired configuration file.
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>读取系统范围的<productname>OpenSSL</productname>配置文件。默认情况下，该文件被命名为<filename>openssl.cnf</filename>并位于<literal>openssl version -d</literal>报告的目录中。通过将环境变量设置<envar>OPENSSL_CONF</envar>为所需配置文件的名称，可以覆盖此默认值。
  </para>
<!-- pgdoc-cn_end sig_en=72bddbabad9157630ad37ccd6469fe3d -->

<!-- pgdoc-cn_start sig_en=e7b668043fd547a25f58bd88d01c7cb8 sig_cn_org=None source=14.1 
  <para>
   <productname>OpenSSL</productname> supports a wide range of ciphers
   and authentication algorithms, of varying strength.  While a list of
   ciphers can be specified in the <productname>OpenSSL</productname>
   configuration file, you can specify ciphers specifically for use by
   the database server by modifying <xref linkend="guc-ssl-ciphers"/> in
   <filename>postgresql.conf</filename>.
  </para>
________________________________________________________-->
  <para>
   <productname>OpenSSL</productname>支持各种强度不同的密码和身份验证算法。虽然许多密码可以在<productname>OpenSSL</productname>的配置文件中被指定，您可以通过修改<filename>postgresql.conf</filename>配置文件中指定专门针对数据库服务器使用密码的<xref linkend="guc-ssl-ciphers"/> 配置。
  </para>
<!-- pgdoc-cn_end sig_en=e7b668043fd547a25f58bd88d01c7cb8 -->

  <note>
<!-- pgdoc-cn_start sig_en=cd66be2544582212736dca5088e7c3b0 sig_cn_org=None source=14.1 
   <para>
    It is possible to have authentication without encryption overhead by
    using <literal>NULL-SHA</literal> or <literal>NULL-MD5</literal> ciphers.  However,
    a man-in-the-middle could read and pass communications between client
    and server.  Also, encryption overhead is minimal compared to the
    overhead of authentication.  For these reasons NULL ciphers are not
    recommended.
   </para>
________________________________________________________-->
   <para>
    使用<literal>NULL-SHA</literal>或<literal>NULL-MD5</literal>可以得到身份验证但没有加密开销。
    不过，中间人能够读取和传递客户端和服务器之间的通信。
    此外，加密开销相比身份认证的开销是最小的。
    出于这些原因，我们建议不要使用 NULL 密码。
   </para>
<!-- pgdoc-cn_end sig_en=cd66be2544582212736dca5088e7c3b0 -->
  </note>
  </sect2>

  <sect2 id="ssl-client-certificates">
<!-- pgdoc-cn_start sig_en=4c083677a6d3a1b6e4297ab35574e274 sig_cn_org=None source=14.1 
   <title>Using Client Certificates</title>
________________________________________________________-->
   <title>使用客户端证书</title>
<!-- pgdoc-cn_end sig_en=4c083677a6d3a1b6e4297ab35574e274 -->

<!-- pgdoc-cn_start sig_en=edf3b8c723d65858486b72df7e7d267c sig_cn_org=None source=14.1 
  <para>
   To require the client to supply a trusted certificate,
   place certificates of the root certificate authorities
   (<acronym>CA</acronym>s) you trust in a file in the data
   directory, set the parameter <xref linkend="guc-ssl-ca-file"/> in
   <filename>postgresql.conf</filename> to the new file name, and add the
   authentication option <literal>clientcert=verify-ca</literal> or
   <literal>clientcert=verify-full</literal> to the appropriate
   <literal>hostssl</literal> line(s) in <filename>pg_hba.conf</filename>.
   A certificate will then be requested from the client during SSL
   connection startup.  (See <xref linkend="libpq-ssl"/> for a description
   of how to set up certificates on the client.)
  </para>
________________________________________________________-->
  <para>
   要求客户端提供受信任的证书，把你信任的根证书颁发机构（<acronym>CA</acronym>）的证书放置在数据目录文件中。
   并且修改<filename>postgresql.conf</filename>中的参数<xref linkend="guc-ssl-ca-file"/>到新的文件名，
   还要把认证选项 <literal>clientcert=verify-ca</literal>或<literal>clientcert=verify-full</literal>加入到<filename>pg_hba.conf</filename>文件中合适的<literal>hostssl</literal>行上。
   然后将在 SSL 连接启动时从客户端请求该证书（一段对于如何在客户端设置证书的描述请见<xref linkend="libpq-ssl"/>）。
   </para>
<!-- pgdoc-cn_end sig_en=edf3b8c723d65858486b72df7e7d267c -->

<!-- pgdoc-cn_start sig_en=26be4f2c78035845fae3ea18e34468ce sig_cn_org=None source=14.1 
  <para>
   For a <literal>hostssl</literal> entry with
   <literal>clientcert=verify-ca</literal>, the server will verify
   that the client's certificate is signed by one of the trusted
   certificate authorities. If <literal>clientcert=verify-full</literal>
   is specified, the server will not only verify the certificate
   chain, but it will also check whether the username or its mapping
   matches the <literal>cn</literal> (Common Name) of the provided certificate.
   Note that certificate chain validation is always ensured when the
   <literal>cert</literal> authentication method is used
   (see <xref linkend="auth-cert"/>).
  </para>
________________________________________________________-->
  <para>
   对于具有 <literal>clientcert=verify-ca</literal> 的<literal>hostssl</literal>条目，服务器将验证客户端的证书是否由一个受信任的证书颁发机构签署的。
   如果指定了 <literal>clientcert=verify-full</literal>，则服务器不仅将验证证书链，还将检查用户名或其映射是否与所提供的证书的 <literal>cn</literal>（通用名称）相匹配。
   请注意，在使用 <literal>cert</literal> 身份验证方法时，要始终确保证书链验证(参见 <xref linkend="auth-cert"/>)。
   </para>
<!-- pgdoc-cn_end sig_en=26be4f2c78035845fae3ea18e34468ce -->

<!-- pgdoc-cn_start sig_en=3a87d7dee854b9ad35e4cd594992708b sig_cn_org=b9bd48a72287b19d03d0a95df4ac1f06 source=15.7 
  <para>
   Intermediate certificates that chain up to existing root certificates
   can also appear in the <xref linkend="guc-ssl-ca-file"/> file if
   you wish to avoid storing them on clients (assuming the root and
   intermediate certificates were created with <literal>v3_ca</literal>
   extensions).  Certificate Revocation List (CRL) entries are also
   checked if the parameter <xref linkend="guc-ssl-crl-file"/> or
   <xref linkend="guc-ssl-crl-dir"/> is set.
  </para>
________________________________________________________-->
  <para>
   中间证书链到现有根证书，如果您希望避免在客户端上存储它们，也可以出现在<xref linkend="guc-ssl-ca-file"/>文件中
   （假设根证书和中间证书是使用<literal>v3_ca</literal>扩展创建的）。如果设置了参数<xref linkend="guc-ssl-crl-file"/>或
   <xref linkend="guc-ssl-crl-dir"/>，还会检查证书吊销列表（CRL）条目。
</para>
<!-- pgdoc-cn_end sig_en=3a87d7dee854b9ad35e4cd594992708b -->

<!-- pgdoc-cn_start sig_en=62cc62ac1020e68b367994e30f1c559f sig_cn_org=None source=14.1 
  <para>
   The <literal>clientcert</literal> authentication option is available for
   all authentication methods, but only in <filename>pg_hba.conf</filename> lines
   specified as <literal>hostssl</literal>.  When <literal>clientcert</literal> is
   not specified, the server verifies the client certificate against its CA
   file only if a client certificate is presented and the CA is configured.
  </para>
________________________________________________________-->
  <para>
   <literal>clientcert</literal>认证选项适用于所有的认证方法，但仅适用于<filename>pg_hba.conf</filename>中用<literal>hostssl</literal>指定的行。 
   当<literal>clientcert</literal>没有指定，服务器仅在客户端证书存在并且CA被配置的时候，通过客户端的CA文件来查证客户端证书。
  </para>
<!-- pgdoc-cn_end sig_en=62cc62ac1020e68b367994e30f1c559f -->

<!-- pgdoc-cn_start sig_en=b17ba0c46a4e0fcbe63e9be5279b695a sig_cn_org=None source=14.1 
  <para>
   There are two approaches to enforce that users provide a certificate during login.
  </para>
________________________________________________________-->
  <para>
   有两种方法可以强制用户在登录时提供证书。
  </para>
<!-- pgdoc-cn_end sig_en=b17ba0c46a4e0fcbe63e9be5279b695a -->

<!-- pgdoc-cn_start sig_en=58ebe0bbef49cdf3d8bf843754e96cb8 sig_cn_org=None source=14.1 
  <para>
   The first approach makes use of the <literal>cert</literal> authentication
   method for <literal>hostssl</literal> entries in <filename>pg_hba.conf</filename>,
   such that the certificate itself is used for authentication while also
   providing ssl connection security. See <xref linkend="auth-cert"/> for details.
   (It is not necessary to specify any <literal>clientcert</literal> options
   explicitly when using the <literal>cert</literal> authentication method.)
   In this case, the <literal>cn</literal> (Common Name) provided in
   the certificate is checked against the user name or an applicable mapping.
  </para>
________________________________________________________-->
  <para>
   第一种方法是对<filename>pg_hba.conf</filename>文件中的<literal>hostssl</literal>条目使用<literal>cert</literal>身份验证方法，这样证书本身可以用于身份验证，同时提供 ssl 连接安全性。
   详细信息请参阅<xref linkend="auth-cert"/>。（在使用<literal>cert</literal>身份验证方法时，不需要显式指定任何<literal>clientcert</literal>选项。）
   在这种情况下，证书中<literal>cn</literal>（通用名称）将针对用户名或适用的映射进行检查。
  </para>
<!-- pgdoc-cn_end sig_en=58ebe0bbef49cdf3d8bf843754e96cb8 -->

<!-- pgdoc-cn_start sig_en=76ac4c39de04e2a5e7505506031436c0 sig_cn_org=None source=14.1 
  <para>
   The second approach combines any authentication method for <literal>hostssl</literal>
   entries with the verification of client certificates by setting the
   <literal>clientcert</literal> authentication option to <literal>verify-ca</literal>
   or <literal>verify-full</literal>. The former option only enforces that
   the certificate is valid, while the latter also ensures that the
   <literal>cn</literal> (Common Name) in the certificate matches
   the user name or an applicable mapping.
  </para>
________________________________________________________-->
  <para>
   第二种方法是将对<literal>hostssl</literal>条目的任何身份验证方法和客户端证书的验证相结合，通过将<literal>clientcert</literal>身份验证选项设置为<literal>verify-ca</literal> 或 <literal>verify-full</literal>。
   前一个选项仅强制证书有效，而后者还确保证书中的 <literal>cn</literal>（通用名称）匹配用户名或适用的映射。
  </para>
<!-- pgdoc-cn_end sig_en=76ac4c39de04e2a5e7505506031436c0 -->
  </sect2>

  <sect2 id="ssl-server-files">
<!-- pgdoc-cn_start sig_en=18d7ed98ed27c63e4123e58bc49db3e8 sig_cn_org=None source=14.1 
   <title>SSL Server File Usage</title>
________________________________________________________-->
   <title>SSL 服务器文件用法</title>
<!-- pgdoc-cn_end sig_en=18d7ed98ed27c63e4123e58bc49db3e8 -->

<!-- pgdoc-cn_start sig_en=27eb4793ba46415a3d72931ff9fb445a sig_cn_org=None source=14.1 
   <para>
    <xref linkend="ssl-file-usage"/> summarizes the files that are
    relevant to the SSL setup on the server.  (The shown file names are default
    names.  The locally configured names could be different.)
   </para>
________________________________________________________-->
   <para>
    <xref linkend="ssl-file-usage"/>总结了与服务器上 SSL 配置有关的文件（显示的文件名是默认的名称。本地配置的名称可能会不同）。
   </para>
<!-- pgdoc-cn_end sig_en=27eb4793ba46415a3d72931ff9fb445a -->

  <table id="ssl-file-usage">
<!-- pgdoc-cn_start sig_en=18d7ed98ed27c63e4123e58bc49db3e8 sig_cn_org=None source=14.1 
   <title>SSL Server File Usage</title>
________________________________________________________-->
   <title>SSL 服务器文件用法</title>
<!-- pgdoc-cn_end sig_en=18d7ed98ed27c63e4123e58bc49db3e8 -->
   <tgroup cols="3">
    <thead>
<!-- pgdoc-cn_start sig_en=8226177a05f3318d561b773a4dacc434 sig_cn_org=None source=14.1 
     <row>
      <entry>File</entry>
      <entry>Contents</entry>
      <entry>Effect</entry>
     </row>
________________________________________________________-->
     <row>
      <entry>文件</entry>
      <entry>内容</entry>
      <entry>效果</entry>
     </row>
<!-- pgdoc-cn_end sig_en=8226177a05f3318d561b773a4dacc434 -->
    </thead>

    <tbody>

<!-- pgdoc-cn_start sig_en=acb37fa7c15d380a089b4a7d6f635312 sig_cn_org=None source=14.1 
     <row>
      <entry><xref linkend="guc-ssl-cert-file"/> (<filename>$PGDATA/server.crt</filename>)</entry>
      <entry>server certificate</entry>
      <entry>sent to client to indicate server's identity</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><xref linkend="guc-ssl-cert-file"/> (<filename>$PGDATA/server.crt</filename>)</entry>
      <entry>服务器证书</entry>
      <entry>发送给客户端来说明服务器的身份</entry>
     </row>
<!-- pgdoc-cn_end sig_en=acb37fa7c15d380a089b4a7d6f635312 -->

<!-- pgdoc-cn_start sig_en=d17fb1ce6f335812d2dc098ded10da40 sig_cn_org=None source=14.1 
     <row>
      <entry><xref linkend="guc-ssl-key-file"/> (<filename>$PGDATA/server.key</filename>)</entry>
      <entry>server private key</entry>
      <entry>proves server certificate was sent by the owner; does not indicate
      certificate owner is trustworthy</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><xref linkend="guc-ssl-key-file"/> (<filename>$PGDATA/server.key</filename>)</entry>
      <entry>服务器私钥</entry>
      <entry>证明服务器证书是其所有者发送的，并不说明证书所有者是值得信任的</entry>
     </row>
<!-- pgdoc-cn_end sig_en=d17fb1ce6f335812d2dc098ded10da40 -->

<!-- pgdoc-cn_start sig_en=722048019572df2ccbd7197a4202767d sig_cn_org=None source=14.1 
     <row>
      <entry><xref linkend="guc-ssl-ca-file"/></entry>
      <entry>trusted certificate authorities</entry>
      <entry>checks that client certificate is
      signed by a trusted certificate authority</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><xref linkend="guc-ssl-ca-file"/></entry>
      <entry>可信的证书颁发机构</entry>
      <entry>检查客户端证书是由一个可信的证书颁发机构签名的</entry>
     </row>
<!-- pgdoc-cn_end sig_en=722048019572df2ccbd7197a4202767d -->

<!-- pgdoc-cn_start sig_en=d02a45da9cc85e91b663435b30e69f83 sig_cn_org=None source=14.1 
     <row>
      <entry><xref linkend="guc-ssl-crl-file"/></entry>
      <entry>certificates revoked by certificate authorities</entry>
      <entry>client certificate must not be on this list</entry>
     </row>
________________________________________________________-->
     <row>
      <entry><xref linkend="guc-ssl-crl-file"/></entry>
      <entry>被证书授权机构撤销的证书</entry>
      <entry>客户端证书不能出现在这个列表上</entry>
     </row>
<!-- pgdoc-cn_end sig_en=d02a45da9cc85e91b663435b30e69f83 -->

    </tbody>
   </tgroup>
  </table>

<!-- pgdoc-cn_start sig_en=79250d6f5c802dc1005ea9fa7dfa4ee3 sig_cn_org=None source=14.1 
   <para>
    The server reads these files at server start and whenever the server
    configuration is reloaded.  On <systemitem class="osname">Windows</systemitem>
    systems, they are also re-read whenever a new backend process is spawned
    for a new client connection.
   </para>
________________________________________________________-->
   <para>
    服务器在服务器启动时以及服务器配置重新加载时读取这些文件。在<systemitem class="osname">Windows</systemitem>系统上，只要为新客户端连接生成新的后端进程，它们也会重新读取。
   </para>
<!-- pgdoc-cn_end sig_en=79250d6f5c802dc1005ea9fa7dfa4ee3 -->

<!-- pgdoc-cn_start sig_en=e7dc39e2bdf21dcbaabafe2468350fae sig_cn_org=None source=14.1 
   <para>
    If an error in these files is detected at server start, the server will
    refuse to start.  But if an error is detected during a configuration
    reload, the files are ignored and the old SSL configuration continues to
    be used.  On <systemitem class="osname">Windows</systemitem> systems, if an error in
    these files is detected at backend start, that backend will be unable to
    establish an SSL connection.  In all these cases, the error condition is
    reported in the server log.
   </para>
________________________________________________________-->
   <para>
    如果在服务器启动时检测到这些文件中的错误，服务器将拒绝启动。但是，如果在配置重新加载过程中检测到错误，则会忽略这些文件，并继续使用旧的SSL配置。在<systemitem class="osname">Windows</systemitem>系统上，如果在后端启动时检测到这些文件中存在错误，则该后端将无法建立SSL连接。在所有这些情况下，错误情况都会在服务器日志中报告。
   </para>
<!-- pgdoc-cn_end sig_en=e7dc39e2bdf21dcbaabafe2468350fae -->
  </sect2>

  <sect2 id="ssl-certificate-creation">
<!-- pgdoc-cn_start sig_en=6b93e45ff711863e5b24aea6fe18929c sig_cn_org=None source=14.1 
   <title>Creating Certificates</title>
________________________________________________________-->
   <title>创建证书</title>
<!-- pgdoc-cn_end sig_en=6b93e45ff711863e5b24aea6fe18929c -->

<!-- pgdoc-cn_start sig_en=e3135c1b7410435f48b9c8eb963361f6 sig_cn_org=None source=14.1 
   <para>
     To create a simple self-signed certificate for the server, valid for 365
     days, use the following <productname>OpenSSL</productname> command,
     replacing <replaceable>dbhost.yourdomain.com</replaceable> with the
     server's host name:
<programlisting>
openssl req -new -x509 -days 365 -nodes -text -out server.crt \
  -keyout server.key -subj "/CN=<replaceable>dbhost.yourdomain.com</replaceable>"
</programlisting>
    Then do:
<programlisting>
chmod og-rwx server.key
</programlisting>
    because the server will reject the file if its permissions are more
    liberal than this.
    For more details on how to create your server private key and
    certificate, refer to the <productname>OpenSSL</productname> documentation.
   </para>
________________________________________________________-->
   <para>
     要为服务器创建一个有效期为365天的简单自签名证书，可以使用下面的<productname>OpenSSL</productname>命令，将<replaceable>dbhost.yourdomain.com</replaceable>替换为服务器的主机名：
<programlisting>
openssl req -new -x509 -days 365 -nodes -text -out server.crt \
  -keyout server.key -subj "/CN=<replaceable>dbhost.yourdomain.com</replaceable>"
</programlisting>
    然后执行：
<programlisting>
chmod og-rwx server.key
</programlisting>
    如果文件的权限比这个更自由，服务器将拒绝该文件。要了解更多关于如何创建你的服务器私钥和证书的细节， 请参考<productname>OpenSSL</productname>文档。
   </para>
<!-- pgdoc-cn_end sig_en=e3135c1b7410435f48b9c8eb963361f6 -->

<!-- pgdoc-cn_start sig_en=9f1d41b860c7e691e3e2a721203fc421 sig_cn_org=None source=14.1 
   <para>
    While a self-signed certificate can be used for testing, a certificate
    signed by a certificate authority (<acronym>CA</acronym>) (usually an
    enterprise-wide root <acronym>CA</acronym>) should be used in production.
   </para>
________________________________________________________-->
   <para>
    尽管可以使用自签名证书进行测试，但是在生产中应该使用由证书颁发机构（<acronym>CA</acronym>）（通常是企业范围的根<acronym>CA</acronym>）签名的证书。
   </para>
<!-- pgdoc-cn_end sig_en=9f1d41b860c7e691e3e2a721203fc421 -->

<!-- pgdoc-cn_start sig_en=09247fc12f8494fef79d8dfd6c500576 sig_cn_org=None source=14.1 
   <para>
    To create a server certificate whose identity can be validated
    by clients, first create a certificate signing request
    (<acronym>CSR</acronym>) and a public/private key file:
<programlisting>
openssl req -new -nodes -text -out root.csr \
  -keyout root.key -subj "/CN=<replaceable>root.yourdomain.com</replaceable>"
chmod og-rwx root.key
</programlisting>
    Then, sign the request with the key to create a root certificate
    authority (using the default <productname>OpenSSL</productname>
    configuration file location on <productname>Linux</productname>):
<programlisting>
openssl x509 -req -in root.csr -text -days 3650 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -signkey root.key -out root.crt
</programlisting>
    Finally, create a server certificate signed by the new root certificate
    authority:
<programlisting>
openssl req -new -nodes -text -out server.csr \
  -keyout server.key -subj "/CN=<replaceable>dbhost.yourdomain.com</replaceable>"
chmod og-rwx server.key

openssl x509 -req -in server.csr -text -days 365 \
  -CA root.crt -CAkey root.key -CAcreateserial \
  -out server.crt
</programlisting>
    <filename>server.crt</filename> and <filename>server.key</filename>
    should be stored on the server, and <filename>root.crt</filename> should
    be stored on the client so the client can verify that the server's leaf
    certificate was signed by its trusted root certificate.
    <filename>root.key</filename> should be stored offline for use in
    creating future certificates.
   </para>
________________________________________________________-->
   <para>
    要创建其身份可以被客户端验证的服务器证书，请首先创建一个证书签名请求（<acronym>CSR</acronym>）和一个公共/专用密钥文件：
<programlisting>
openssl req -new -nodes -text -out root.csr \
  -keyout root.key -subj "/CN=<replaceable>root.yourdomain.com</replaceable>"
chmod og-rwx root.key
</programlisting>
    然后，使用密钥对请求进行签名以创建根证书颁发机构（使用<productname>Linux</productname>上的默认<productname>OpenSSL</productname>配置文件位置）：
<programlisting>
openssl x509 -req -in root.csr -text -days 3650 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -signkey root.key -out root.crt
</programlisting>
    最后，创建由新的根证书颁发机构签名的服务器证书：
<programlisting>
openssl req -new -nodes -text -out server.csr \
  -keyout server.key -subj "/CN=<replaceable>dbhost.yourdomain.com</replaceable>"
chmod og-rwx server.key

openssl x509 -req -in server.csr -text -days 365 \
  -CA root.crt -CAkey root.key -CAcreateserial \
  -out server.crt
</programlisting>
    <filename>server.crt</filename>和<filename>server.key</filename>应该存储在服务器上，并且<filename>root.crt</filename>应该存储在客户端上，以便客户端可以验证服务器的叶证书已由其受信任的根证书签名。<filename>root.key</filename>应该离线存储以用于创建将来的证书。
    </para>
<!-- pgdoc-cn_end sig_en=09247fc12f8494fef79d8dfd6c500576 -->

<!-- pgdoc-cn_start sig_en=d05337fe14912e69c1903aaf2f1f60f2 sig_cn_org=None source=14.1 
   <para>
    It is also possible to create a chain of trust that includes
    intermediate certificates:
<programlisting>
# root
openssl req -new -nodes -text -out root.csr \
  -keyout root.key -subj "/CN=<replaceable>root.yourdomain.com</replaceable>"
chmod og-rwx root.key
openssl x509 -req -in root.csr -text -days 3650 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -signkey root.key -out root.crt

# intermediate
openssl req -new -nodes -text -out intermediate.csr \
  -keyout intermediate.key -subj "/CN=<replaceable>intermediate.yourdomain.com</replaceable>"
chmod og-rwx intermediate.key
openssl x509 -req -in intermediate.csr -text -days 1825 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -CA root.crt -CAkey root.key -CAcreateserial \
  -out intermediate.crt

# leaf
openssl req -new -nodes -text -out server.csr \
  -keyout server.key -subj "/CN=<replaceable>dbhost.yourdomain.com</replaceable>"
chmod og-rwx server.key
openssl x509 -req -in server.csr -text -days 365 \
  -CA intermediate.crt -CAkey intermediate.key -CAcreateserial \
  -out server.crt
</programlisting>
    <filename>server.crt</filename> and
    <filename>intermediate.crt</filename> should be concatenated
    into a certificate file bundle and stored on the server.
    <filename>server.key</filename> should also be stored on the server.
    <filename>root.crt</filename> should be stored on the client so
    the client can verify that the server's leaf certificate was signed
    by a chain of certificates linked to its trusted root certificate.
    <filename>root.key</filename> and <filename>intermediate.key</filename>
    should be stored offline for use in creating future certificates.
   </para>
________________________________________________________-->
   <para>
    也可以创建一个包括中间证书的信任链：
<programlisting>
# root
openssl req -new -nodes -text -out root.csr \
  -keyout root.key -subj "/CN=<replaceable>root.yourdomain.com</replaceable>"
chmod og-rwx root.key
openssl x509 -req -in root.csr -text -days 3650 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -signkey root.key -out root.crt

# intermediate
openssl req -new -nodes -text -out intermediate.csr \
  -keyout intermediate.key -subj "/CN=<replaceable>intermediate.yourdomain.com</replaceable>"
chmod og-rwx intermediate.key
openssl x509 -req -in intermediate.csr -text -days 1825 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -CA root.crt -CAkey root.key -CAcreateserial \
  -out intermediate.crt

# leaf
openssl req -new -nodes -text -out server.csr \
  -keyout server.key -subj "/CN=<replaceable>dbhost.yourdomain.com</replaceable>"
chmod og-rwx server.key
openssl x509 -req -in server.csr -text -days 365 \
  -CA intermediate.crt -CAkey intermediate.key -CAcreateserial \
  -out server.crt
</programlisting>
    <filename>server.crt</filename>和<filename>intermediate.crt</filename>应连接成一个证书文件包中并存储在服务器上。<filename>server.key</filename>还应该存储在服务器上。<filename>root.crt</filename>应将其存储在客户端上，以便客户端可以验证服务器的叶证书是否已由链接到其受信任根证书的证书链签名。<filename>root.key</filename>和<filename>intermediate.key</filename>应离线存储以用于创建将来的证书。
   </para>
<!-- pgdoc-cn_end sig_en=d05337fe14912e69c1903aaf2f1f60f2 -->
  </sect2>

 </sect1>

 <sect1 id="gssapi-enc">
<!-- pgdoc-cn_start sig_en=9867c70126f5aae4ebac0b91531092d3 sig_cn_org=None source=14.1 
  <title>Secure TCP/IP Connections with GSSAPI Encryption</title>
________________________________________________________-->
  <title>Secure TCP/IP Connections with GSSAPI Encryption</title>
<!-- pgdoc-cn_end sig_en=9867c70126f5aae4ebac0b91531092d3 -->

<!-- pgdoc-cn_start sig_en=97a56e5127b80b9d4d0bcf887c198677 sig_cn_org=None source=14.1 
  <indexterm zone="gssapi-enc">
   <primary>gssapi</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="gssapi-enc">
   <primary>gssapi</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=97a56e5127b80b9d4d0bcf887c198677 -->

<!-- pgdoc-cn_start sig_en=fe117d5ed3e4b52afb6839db4490888c sig_cn_org=None source=14.1 
  <para>
   <productname>PostgreSQL</productname> also has native support for
   using <acronym>GSSAPI</acronym> to encrypt client/server communications for
   increased security.  Support requires that a <acronym>GSSAPI</acronym>
   implementation (such as MIT Kerberos) is installed on both client and server
   systems, and that support in <productname>PostgreSQL</productname> is
   enabled at build time (see <xref linkend="installation"/>).
  </para>
________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>还具有原生支持使用 <acronym>GSSAPI</acronym> 加密客户端/服务器通信以提高安全性。 
   支持要求在客户端和服务器系统上都安装  <acronym>GSSAPI</acronym>实现（例如 MIT Kerberos），并在编译时启用 <productname>PostgreSQL</productname> 中的支持(参见 <xref linkend="installation"/>)。
  </para>
<!-- pgdoc-cn_end sig_en=fe117d5ed3e4b52afb6839db4490888c -->

  <sect2 id="gssapi-setup">
<!-- pgdoc-cn_start sig_en=53a0cd08279ef5a6ae801df170b2c9c2 sig_cn_org=None source=14.1 
   <title>Basic Setup</title>
________________________________________________________-->
   <title>Basic Setup</title>
<!-- pgdoc-cn_end sig_en=53a0cd08279ef5a6ae801df170b2c9c2 -->

<!-- pgdoc-cn_start sig_en=62970e6e0e32977e053d15d4a2e9ef3d sig_cn_org=None source=14.1 
   <para>
    The <productname>PostgreSQL</productname> server will listen for both
    normal and <acronym>GSSAPI</acronym>-encrypted connections on the same TCP
    port, and will negotiate with any connecting client whether to
    use <acronym>GSSAPI</acronym> for encryption (and for authentication).  By
    default, this decision is up to the client (which means it can be
    downgraded by an attacker); see <xref linkend="auth-pg-hba-conf"/> about
    setting up the server to require the use of <acronym>GSSAPI</acronym> for
    some or all connections.
   </para>
________________________________________________________-->
   <para>
    <productname>PostgreSQL</productname> 服务器将侦听同一 TCP 端口上的普通连接和 <acronym>GSSAPI</acronym>-加密连接，并将与任何连接的客户端协商是否使用 <acronym>GSSAPI</acronym> 进行加密（和身份验证）。 
    默认情况下，此决策由客户端决定（这意味着攻击者可以降级）；参见<xref linkend="auth-pg-hba-conf"/> 关于设置服务器对某些或所有连接要求使用 <acronym>GSSAPI</acronym>。
   </para>
<!-- pgdoc-cn_end sig_en=62970e6e0e32977e053d15d4a2e9ef3d -->

<!-- pgdoc-cn_start sig_en=2edf2e162ba8cd5162ca32a992030173 sig_cn_org=None source=14.1 
   <para>
    When using <acronym>GSSAPI</acronym> for encryption, it is common to
    use <acronym>GSSAPI</acronym> for authentication as well, since the
    underlying mechanism will determine both client and server identities
    (according to the <acronym>GSSAPI</acronym> implementation) in any
    case.  But this is not required;
    another <productname>PostgreSQL</productname> authentication method
    can be chosen to perform additional verification.
   </para>
________________________________________________________-->
   <para>
    当使用<acronym>GSSAPI</acronym>加密时，一般也使用<acronym>GSSAPI</acronym>进行身份验证，因为底层机制将确定客户端和服务器身份(根据<acronym>GSSAPI</acronym>实现)，在任何情况下。
    但这不是必需的；可以选择另一种<productname>PostgreSQL</productname>认证方法执行额外的验证。
   </para>
<!-- pgdoc-cn_end sig_en=2edf2e162ba8cd5162ca32a992030173 -->

<!-- pgdoc-cn_start sig_en=89c35bc17ff6c226c619bfa4ec96624c sig_cn_org=None source=14.1 
   <para>
    Other than configuration of the negotiation
    behavior, <acronym>GSSAPI</acronym> encryption requires no setup beyond
    that which is necessary for GSSAPI authentication.  (For more information
    on configuring that, see <xref linkend="gssapi-auth"/>.)
   </para>
________________________________________________________-->
   <para>
    除了协商行为的配置外，<acronym>GSSAPI</acronym>加密不需要GSSAPI认证外的其他设置。 (关于配置的更多信息, 参见 <xref linkend="gssapi-auth"/>。)
   </para>
<!-- pgdoc-cn_end sig_en=89c35bc17ff6c226c619bfa4ec96624c -->
  </sect2>
 </sect1>

 <sect1 id="ssh-tunnels">
<!-- pgdoc-cn_start sig_en=e8e3d7504bd13e392e10151643ab864a sig_cn_org=None source=14.1 
  <title>Secure TCP/IP Connections with <application>SSH</application> Tunnels</title>
________________________________________________________-->
  <title>使用<application>SSH</application>隧道的安全 TCP/IP 连接</title>
<!-- pgdoc-cn_end sig_en=e8e3d7504bd13e392e10151643ab864a -->

<!-- pgdoc-cn_start sig_en=c7074325b9e9f4ec1494054999cc3829 sig_cn_org=None source=14.1 
  <indexterm zone="ssh-tunnels">
   <primary>ssh</primary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="ssh-tunnels">
   <primary>ssh</primary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=c7074325b9e9f4ec1494054999cc3829 -->

<!-- pgdoc-cn_start sig_en=3f39313c7666d479f6edaa696e4cca4f sig_cn_org=None source=14.1 
  <para>
   It is possible to use <application>SSH</application> to encrypt the network
   connection between clients and a
   <productname>PostgreSQL</productname> server. Done properly, this
   provides an adequately secure network connection, even for non-SSL-capable
   clients.
  </para>
________________________________________________________-->
  <para>
   可以使用<application>SSH</application>来加密客户端和<productname>PostgreSQL</productname>服务器之间的网络连接。如果处理得当，这将提供一个足够安全的网络连接，即使是对那些无 SSL 能力的客户端。
  </para>
<!-- pgdoc-cn_end sig_en=3f39313c7666d479f6edaa696e4cca4f -->

<!-- pgdoc-cn_start sig_en=59a9bfbd5d8368dea462391111586470 sig_cn_org=None source=14.1 
  <para>
   First make sure that an <application>SSH</application> server is
   running properly on the same machine as the
   <productname>PostgreSQL</productname> server and that you can log in using
   <command>ssh</command> as some user;  you then can establish a
   secure tunnel to the remote server.  A secure tunnel listens on a
   local port and forwards all traffic to a port on the remote machine.
   Traffic sent to the remote port can arrive on its
   <literal>localhost</literal> address, or different bind
   address if desired;  it does not appear as coming from your
   local machine.  This command creates a secure tunnel from the client
   machine to the remote machine <literal>foo.com</literal>:
<programlisting>
ssh -L 63333:localhost:5432 joe@foo.com
</programlisting>
   The first number in the <option>-L</option> argument, 63333, is the
   local port number of the tunnel; it can be any unused port.  (IANA
   reserves ports 49152 through 65535 for private use.)  The name or IP
   address after this is the remote bind address you are connecting to,
   i.e., <literal>localhost</literal>, which is the default.  The second
   number, 5432, is the remote end of the tunnel, e.g., the port number
   your database server is using.  In order to connect to the database
   server using this tunnel, you connect to port 63333 on the local
   machine:
<programlisting>
psql -h localhost -p 63333 postgres
</programlisting>
   To the database server it will then look as though you are
   user <literal>joe</literal> on host <literal>foo.com</literal>
   connecting to the <literal>localhost</literal> bind address, and it
   will use whatever authentication procedure was configured for
   connections by that user to that bind address.  Note that the server will not
   think the connection is SSL-encrypted, since in fact it is not
   encrypted between the
   <application>SSH</application> server and the
   <productname>PostgreSQL</productname> server.  This should not pose any
   extra security risk because they are on the same machine.
  </para>
________________________________________________________-->
  <para>
   首先确认在<productname>PostgreSQL</productname>服务器的同一台机器上正确运行着一个<application>SSH</application>服务器，并且你可以使用<command>ssh</command>作为某个用户登入；然后，您可以建立到远程服务器的安全隧道。 安全隧道侦听本地端口并将所有流量转发到远程机器上的端口。 发送到远程端口的流量可以到达其 <literal>localhost</literal> 地址，或者如果需要，可以到达不同的绑定地址； 它似乎不是来自您的本地机器。 此命令创建从客户端机器到远程机器 <literal>foo.com</literal> 的安全隧道：
<programlisting>
ssh -L 63333:localhost:5432 joe@foo.com
</programlisting>
   <option>-L</option> 参数中的第一个数字 63333 是隧道的本地端口号； 它可以是任何未使用的端口。 （IANA 保留端口 49152 到 65535 供私人使用。）此后的名称或 IP 地址是您要连接到的远程绑定地址，即 <literal>localhost</literal>，这是默认值。 第二个数字 5432 是隧道的远端，例如，您的数据库服务器正在使用的端口号。 为了使用此隧道连接到数据库服务器，您需要连接到本地机器上的端口 63333：
<programlisting>
psql -h localhost -p 63333 postgres
</programlisting>
   对于数据库服务器，它将把你看做是连接到<literal>localhost</literal>绑定地址的主机<literal>foo.com</literal>上的用户<literal>joe</literal>，并且它将使用为该用户到该绑定地址的连接配置的任何身份验证程序。注意服务器将不会认为连接是 SSL 加密的，因为事实上<application>SSH</application>服务器和<productname>PostgreSQL</productname>服务器之间没有加密。这不应该造成任何额外的安全风险，因为它们在同一台机器上。
  </para>
<!-- pgdoc-cn_end sig_en=59a9bfbd5d8368dea462391111586470 -->

<!-- pgdoc-cn_start sig_en=616660178dbd5f5e1322c113835edd00 sig_cn_org=None source=14.1 
  <para>
   In order for the
   tunnel setup to succeed you must be allowed to connect via
   <command>ssh</command> as <literal>joe@foo.com</literal>, just
   as if you had attempted to use <command>ssh</command> to create a
   terminal session.
  </para>
________________________________________________________-->
  <para>
   为了让隧道设置成功，你必须允许通过<command>ssh</command>作为<literal>joe@foo.com</literal>连接，就像你已经尝试使用<command>ssh</command>来创建一个终端会话。
  </para>
<!-- pgdoc-cn_end sig_en=616660178dbd5f5e1322c113835edd00 -->

<!-- pgdoc-cn_start sig_en=81784590a00ed8d59847efb991f02c97 sig_cn_org=None source=14.1 
  <para>
   You could also have set up port forwarding as
<programlisting>
ssh -L 63333:foo.com:5432 joe@foo.com
</programlisting>
   but then the database server will see the connection as coming in
   on its <literal>foo.com</literal> bind address, which is not opened by
   the default setting <literal>listen_addresses =
   'localhost'</literal>.  This is usually not what you want.
  </para>
________________________________________________________-->
  <para>
   你应当也已经设定好了端口转发：
<programlisting>
ssh -L 63333:foo.com:5432 joe@foo.com
</programlisting>
   但是数据库服务器则将会看到连接从它的<literal>foo.com</literal>绑定地址进来，它没有被默认设置<literal>listen_addresses = 'localhost'</literal>所打开。这通常不是你想要的。
  </para>
<!-- pgdoc-cn_end sig_en=81784590a00ed8d59847efb991f02c97 -->

<!-- pgdoc-cn_start sig_en=a060b92aa4e830718389b39edf6f41c4 sig_cn_org=None source=14.1 
  <para>
   If you have to <quote>hop</quote> to the database server via some
   login host, one possible setup could look like this:
<programlisting>
ssh -L 63333:db.foo.com:5432 joe@shell.foo.com
</programlisting>
   Note that this way the connection
   from <literal>shell.foo.com</literal>
   to <literal>db.foo.com</literal> will not be encrypted by the SSH
   tunnel.
   SSH offers quite a few configuration possibilities when the network
   is restricted in various ways.  Please refer to the SSH
   documentation for details.
  </para>
________________________________________________________-->
  <para>
   如果你必须通过某个登录主机<quote>跳</quote>到数据库服务器，一个可能的设置看起来像：
<programlisting>
ssh -L 63333:db.foo.com:5432 joe@shell.foo.com
</programlisting>
   注意这种从<literal>shell.foo.com</literal>到<literal>db.foo.com</literal>的连接的方法将不会被 SSH 隧道加密。当网络被限制于各种方法时，SSH 提供了相当多的配置可能性。详情请参考 SSH 的文档。
  </para>
<!-- pgdoc-cn_end sig_en=a060b92aa4e830718389b39edf6f41c4 -->

  <tip>
<!-- pgdoc-cn_start sig_en=aeaf784f7584e28aab33b34dbab81d68 sig_cn_org=None source=14.1 
   <para>
    Several other applications exist that can provide secure tunnels using
    a procedure similar in concept to the one just described.
   </para>
________________________________________________________-->
   <para>
    一些其他的应用可以提供安全隧道，它们使用和刚刚描述的 SSH 概念上相似的过程。
   </para>
<!-- pgdoc-cn_end sig_en=aeaf784f7584e28aab33b34dbab81d68 -->
  </tip>

 </sect1>

 <sect1 id="event-log-registration">
<!-- pgdoc-cn_start sig_en=494189ca952c22687e6afbe402f0b1a0 sig_cn_org=None source=14.1 
  <title>Registering <application>Event Log</application> on <systemitem
  class="osname">Windows</systemitem></title>
________________________________________________________-->
  <title>在<systemitem class="osname">Windows</systemitem>上注册<application>事件日志</application></title>
<!-- pgdoc-cn_end sig_en=494189ca952c22687e6afbe402f0b1a0 -->

<!-- pgdoc-cn_start sig_en=b0a9eebdad09454a994d0f325b374705 sig_cn_org=None source=14.1 
  <indexterm zone="event-log-registration">
   <primary>event log</primary>
   <secondary>event log</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm zone="event-log-registration">
   <primary>事件日志</primary>
   <secondary>事件日志</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=b0a9eebdad09454a994d0f325b374705 -->

<!-- pgdoc-cn_start sig_en=8fabdfd7e910fb4e1b829080e0a757de sig_cn_org=None source=14.1 
  <para>
   To register a <systemitem class="osname">Windows</systemitem>
   <application>event log</application> library with the operating system,
   issue this command:
<screen>
<userinput>regsvr32 <replaceable>pgsql_library_directory</replaceable>/pgevent.dll</userinput>
</screen>
   This creates registry entries used by the event viewer, under the default
   event source named <literal>PostgreSQL</literal>.
  </para>
________________________________________________________-->
  <para>
   要为操作系统注册一个<systemitem class="osname">Windows</systemitem> <application>事件日志</application>库，发出这个命令：
<screen>
<userinput>regsvr32 <replaceable>pgsql_library_directory</replaceable>/pgevent.dll</userinput>
</screen>
   这会创建被事件查看器使用的注册表项，默认事件源命名为<literal>PostgreSQL</literal>。
  </para>
<!-- pgdoc-cn_end sig_en=8fabdfd7e910fb4e1b829080e0a757de -->

<!-- pgdoc-cn_start sig_en=e1fbd9093f839a9f3fa7f6df98110e03 sig_cn_org=None source=14.1 
  <para>
   To specify a different event source name (see
   <xref linkend="guc-event-source"/>), use the <literal>/n</literal>
   and <literal>/i</literal> options:
<screen>
<userinput>regsvr32 /n /i:<replaceable>event_source_name</replaceable> <replaceable>pgsql_library_directory</replaceable>/pgevent.dll</userinput>
</screen>
  </para>
________________________________________________________-->
  <para>
   要指定一个不同的事件源名称（见<xref linkend="guc-event-source"/>）。使用<literal>/n</literal>和<literal>/i</literal>选项：
<screen>
<userinput>regsvr32 /n /i:<replaceable>event_source_name</replaceable> <replaceable>pgsql_library_directory</replaceable>/pgevent.dll</userinput>
</screen>
  </para>
<!-- pgdoc-cn_end sig_en=e1fbd9093f839a9f3fa7f6df98110e03 -->

<!-- pgdoc-cn_start sig_en=dd2ca13d307ab0e8284af75f8c628f07 sig_cn_org=None source=14.1 
  <para>
   To unregister the <application>event log</application> library from
   the operating system, issue this command:
<screen>
<userinput>regsvr32 /u [/i:<replaceable>event_source_name</replaceable>] <replaceable>pgsql_library_directory</replaceable>/pgevent.dll</userinput>
</screen>
  </para>
________________________________________________________-->
  <para>
   要从操作系统反注册<application>事件日志</application>库，发出这个命令：
<screen>
<userinput>regsvr32 /u [/i:<replaceable>event_source_name</replaceable>] <replaceable>pgsql_library_directory</replaceable>/pgevent.dll</userinput>
</screen>
  </para>
<!-- pgdoc-cn_end sig_en=dd2ca13d307ab0e8284af75f8c628f07 -->

  <note>
<!-- pgdoc-cn_start sig_en=483ce988083f229ca066842f99c2805d sig_cn_org=None source=14.1 
   <para>
    To enable event logging in the database server, modify
    <xref linkend="guc-log-destination"/> to include
    <literal>eventlog</literal> in <filename>postgresql.conf</filename>.
   </para>
________________________________________________________-->
   <para>
    要启用数据库服务器中的事件日志，在<filename>postgresql.conf</filename>中修改<xref linkend="guc-log-destination"/>来包括<literal>eventlog</literal>。
   </para>
<!-- pgdoc-cn_end sig_en=483ce988083f229ca066842f99c2805d -->
  </note>
 </sect1>

</chapter>
