<!-- doc/src/sgml/amcheck.sgml -->

<sect1 id="amcheck" xreflabel="amcheck">
<!-- pgdoc-cn_start sig_en=0b6b831b489c709d9a5963b62a4255c5 sig_cn_org=None source=14.1 
 <title>amcheck</title>
________________________________________________________-->
 <title>amcheck</title>
<!-- pgdoc-cn_end sig_en=0b6b831b489c709d9a5963b62a4255c5 -->

<!-- pgdoc-cn_start sig_en=66d8698ea3c58d1f33e95f58452b5539 sig_cn_org=None source=14.1 
 <indexterm zone="amcheck">
  <primary>amcheck</primary>
 </indexterm>
________________________________________________________-->
 <indexterm zone="amcheck">
  <primary>amcheck</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=66d8698ea3c58d1f33e95f58452b5539 -->

<!-- pgdoc-cn_start sig_en=148726925f96128df505e801be57c795 sig_cn_org=None source=14.1 
 <para>
  The <filename>amcheck</filename> module provides functions that allow you to
  verify the logical consistency of the structure of relations.
 </para>
________________________________________________________-->
 <para>
  <filename>amcheck</filename> 模块提供的函数让用户能验证关系结构的逻辑一致性。
 </para>
<!-- pgdoc-cn_end sig_en=148726925f96128df505e801be57c795 -->

<!-- pgdoc-cn_start sig_en=01614585837dbefc23491504de20fdd2 sig_cn_org=None source=14.1 
 <para>
  The B-Tree checking functions verify various <emphasis>invariants</emphasis> in the
  structure of the representation of particular relations.  The
  correctness of the access method functions behind index scans and
  other important operations relies on these invariants always
  holding.  For example, certain functions verify, among other things,
  that all B-Tree pages have items in <quote>logical</quote> order (e.g.,
  for B-Tree indexes on <type>text</type>, index tuples should be in
  collated lexical order).  If that particular invariant somehow fails
  to hold, we can expect binary searches on the affected page to
  incorrectly guide index scans, resulting in wrong answers to SQL
  queries.  If the structure appears to be valid, no error is raised.
 </para>
________________________________________________________-->
 <para>
  这些B-Tree检查函数验证特定关系的结构表达中的各种<emphasis>不变条件</emphasis>。
  索引扫描以及其他重要操作背后的访问方法的正确性都要依仗这些不变条件的成立。
  例如，在这些函数中，有一些负责验证所有B树页面中的项都按照<quote>逻辑</quote>顺序（比如，对于<type>text</type>上的B树索引，索引元组应该按照词典顺序排列）摆放。
  如果特定的不变条件由于某种原因无法成立，则我们可以预料受影响页面上的二分搜索将无法正确地引导索引扫描，最终导致SQL查询得到错误的答案。
  如果结构看起来有效，则不会引发错误。
 </para>
<!-- pgdoc-cn_end sig_en=01614585837dbefc23491504de20fdd2 -->
<!-- pgdoc-cn_start sig_en=b20a6dc5e85c38de277fc5d4992d027c sig_cn_org=None source=14.1 
 <para>
  Verification is performed using the same procedures as those used by
  index scans themselves, which may be user-defined operator class
  code.  For example, B-Tree index verification relies on comparisons
  made with one or more B-Tree support function 1 routines.  See <xref
  linkend="xindex-support"/> for details of operator class support
  functions.
 </para>
________________________________________________________-->
 <para>
  验证过程采用索引扫描自身使用的同种过程来执行，这些过程可能是用户定义的操作符类代码。例如，B树索引验证依赖于由一个或者多个B树支持函数1例程构成的比较。操作符类支持函数的详情请见<xref linkend="xindex-support"/>。
 </para>
<!-- pgdoc-cn_end sig_en=b20a6dc5e85c38de277fc5d4992d027c -->
<!-- pgdoc-cn_start sig_en=2a3f8743b9517b4129fa5c03d1fd127f sig_cn_org=None source=14.1 
 <para>
  Unlike the B-Tree checking functions which report corruption by raising
  errors, the heap checking function <function>verify_heapam</function> checks
  a table and attempts to return a set of rows, one row per corruption
  detected.  Despite this, if facilities that
  <function>verify_heapam</function> relies upon are themselves corrupted, the
  function may be unable to continue and may instead raise an error.
 </para>
________________________________________________________-->
 <para>
  不像通过提示错误来报告损坏的B-Tree检查函数，堆检查函数<function>verify_heapam</function>检查表并尝试返回一组行，每次检测到损坏就返回一行。
  尽管如此，如果<function>verify_heapam</function>依赖的工具本身已损坏，则函数可能无法继续，并且可能会引发错误。
 </para>
<!-- pgdoc-cn_end sig_en=2a3f8743b9517b4129fa5c03d1fd127f -->
<!-- pgdoc-cn_start sig_en=6f9ebec094f070d348baa3ade66c1069 sig_cn_org=None source=14.1 
 <para>
  Permission to execute <filename>amcheck</filename> functions may be granted
  to non-superusers, but before granting such permissions careful consideration
  should be given to data security and privacy concerns.  Although the
  corruption reports generated by these functions do not focus on the contents
  of the corrupted data so much as on the structure of that data and the nature
  of the corruptions found, an attacker who gains permission to execute these
  functions, particularly if the attacker can also induce corruption, might be
  able to infer something of the data itself from such messages.
 </para>
________________________________________________________-->
 <para>
  执行<filename>amcheck</filename>函数的权限可以授予非超级用户，但在授予权限之前，应该仔细考虑数据的安全和隐私问题。
  虽然这些函数所产生的破坏报告不关注的破坏数据的内容,而且这些数据的结构和发现破坏的本质,
  获得的权限的攻击者可以执行这些函数,特别是如果攻击者也能导致破坏,也许可以从这些信息中推断出数据本身的某些信息。
 </para>
<!-- pgdoc-cn_end sig_en=6f9ebec094f070d348baa3ade66c1069 -->

 <sect2>
<!-- pgdoc-cn_start sig_en=a75e46b58752dd4a3c18092d0816bc01 sig_cn_org=None source=14.1 
  <title>Functions</title>
________________________________________________________-->
  <title>函数</title>
<!-- pgdoc-cn_end sig_en=a75e46b58752dd4a3c18092d0816bc01 -->

  <variablelist>
   <varlistentry>
<!-- pgdoc-cn_start sig_en=71f35d08dba50747678c82bba2ac0e7f sig_cn_org=None source=14.1 
    <term>
     <function>bt_index_check(index regclass, heapallindexed boolean) returns void</function>
     <indexterm>
      <primary>bt_index_check</primary>
     </indexterm>
    </term>
________________________________________________________-->
    <term>
     <function>bt_index_check(index regclass, heapallindexed boolean) returns void</function>
     <indexterm>
      <primary>bt_index_check</primary>
     </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=71f35d08dba50747678c82bba2ac0e7f -->

    <listitem>
<!-- pgdoc-cn_start sig_en=1dc2b8f6d44f5c63c074646a1a9a5b06 sig_cn_org=None source=14.1 
     <para>
      <function>bt_index_check</function> tests that its target, a
      B-Tree index, respects a variety of invariants.  Example usage:
<screen>
test=# SELECT bt_index_check(index =&gt; c.oid, heapallindexed =&gt; i.indisunique),
               c.relname,
               c.relpages
FROM pg_index i
JOIN pg_opclass op ON i.indclass[0] = op.oid
JOIN pg_am am ON op.opcmethod = am.oid
JOIN pg_class c ON i.indexrelid = c.oid
JOIN pg_namespace n ON c.relnamespace = n.oid
WHERE am.amname = 'btree' AND n.nspname = 'pg_catalog'
-&minus; Don't check temp tables, which may be from another session:
AND c.relpersistence != 't'
-&minus; Function may throw an error when this is omitted:
AND c.relkind = 'i' AND i.indisready AND i.indisvalid
ORDER BY c.relpages DESC LIMIT 10;
 bt_index_check |             relname             | relpages
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;
                | pg_depend_reference_index       |       43
                | pg_depend_depender_index        |       40
                | pg_proc_proname_args_nsp_index  |       31
                | pg_description_o_c_o_index      |       21
                | pg_attribute_relid_attnam_index |       14
                | pg_proc_oid_index               |       10
                | pg_attribute_relid_attnum_index |        9
                | pg_amproc_fam_proc_index        |        5
                | pg_amop_opr_fam_index           |        5
                | pg_amop_fam_strat_index         |        5
(10 rows)
</screen>
      This example shows a session that performs verification of the
      10 largest catalog indexes in the database <quote>test</quote>.
      Verification of the presence of heap tuples as index tuples is
      requested for the subset that are unique indexes.  Since no
      error is raised, all indexes tested appear to be logically
      consistent.  Naturally, this query could easily be changed to
      call <function>bt_index_check</function> for every index in the
      database where verification is supported.
     </para>
________________________________________________________-->
     <para>
      <function>bt_index_check</function>测试一个B树索引，检查各种不变条件。用法实例：
<screen>
test=# SELECT bt_index_check(index =&gt; c.oid, heapallindexed =&gt; i.indisunique),
               c.relname,
               c.relpages
FROM pg_index i
JOIN pg_opclass op ON i.indclass[0] = op.oid
JOIN pg_am am ON op.opcmethod = am.oid
JOIN pg_class c ON i.indexrelid = c.oid
JOIN pg_namespace n ON c.relnamespace = n.oid
WHERE am.amname = 'btree' AND n.nspname = 'pg_catalog'
-- Don't check temp tables, which may be from another session:
AND c.relpersistence != 't'
-- Function may throw an error when this is omitted:
AND c.relkind = 'i' AND i.indisready AND i.indisvalid
ORDER BY c.relpages DESC LIMIT 10;
 bt_index_check |             relname             | relpages
----------------+---------------------------------+----------
                | pg_depend_reference_index       |       43
                | pg_depend_depender_index        |       40
                | pg_proc_proname_args_nsp_index  |       31
                | pg_description_o_c_o_index      |       21
                | pg_attribute_relid_attnam_index |       14
                | pg_proc_oid_index               |       10
                | pg_attribute_relid_attnum_index |        9
                | pg_amproc_fam_proc_index        |        5
                | pg_amop_opr_fam_index           |        5
                | pg_amop_fam_strat_index         |        5
(10 rows)
</screen>
      这个例子中的会话执行对数据库<quote>test</quote>中10个最大目录索引的验证。对于唯一索引会要求验证堆元组是否有对应的索引元组存在。由于没有错误报出，所有的被测索引都处于逻辑一致的状态。自然地，很容易将这个查询改为对支持验证的数据库中的每一个索引调用<function>bt_index_check</function>。
     </para>
<!-- pgdoc-cn_end sig_en=1dc2b8f6d44f5c63c074646a1a9a5b06 -->
<!-- pgdoc-cn_start sig_en=9b2ebf47328dc315fd948eb46bf864aa sig_cn_org=None source=14.1 
     <para>
      <function>bt_index_check</function> acquires an <literal>AccessShareLock</literal>
      on the target index and the heap relation it belongs to. This lock mode
      is the same lock mode acquired on relations by simple
      <literal>SELECT</literal> statements.
      <function>bt_index_check</function> does not verify invariants
      that span child/parent relationships, but will verify the
      presence of all heap tuples as index tuples within the index
      when <parameter>heapallindexed</parameter> is
      <literal>true</literal>.  When a routine, lightweight test for
      corruption is required in a live production environment, using
      <function>bt_index_check</function> often provides the best
      trade-off between thoroughness of verification and limiting the
      impact on application performance and availability.
     </para>
________________________________________________________-->
     <para>
      <function>bt_index_check</function>要求目标索引及其所属的堆关系上的<literal>AccessShareLock</literal>。这种锁模式与简单<literal>SELECT</literal>语句在关系上所要求的锁模式相同。<function>bt_index_check</function>不验证跨越父子关系的不变条件，但是在<parameter>heapallindexed</parameter>为<literal>true</literal>时将验证所有堆元组是否作为索引中的索引元组存在。当在生产环境中要求一个使用<function>bt_index_check</function>的例程进行轻量化损坏测试时，它常常需要在验证彻底性和减小对应用性能及可用性的影响之间做出权衡。
     </para>
<!-- pgdoc-cn_end sig_en=9b2ebf47328dc315fd948eb46bf864aa -->
    </listitem>
   </varlistentry>

   <varlistentry>
<!-- pgdoc-cn_start sig_en=7cc4a9ccb6c6fc5fd15ef4584b613934 sig_cn_org=None source=14.1 
    <term>
     <function>bt_index_parent_check(index regclass, heapallindexed boolean, rootdescend boolean) returns void</function>
     <indexterm>
      <primary>bt_index_parent_check</primary>
     </indexterm>
    </term>
________________________________________________________-->
    <term>
     <function>bt_index_parent_check(index regclass, heapallindexed boolean, rootdescend boolean) returns void</function>
     <indexterm>
      <primary>bt_index_parent_check</primary>
     </indexterm>
    </term>
<!-- pgdoc-cn_end sig_en=7cc4a9ccb6c6fc5fd15ef4584b613934 -->

    <listitem>
<!-- pgdoc-cn_start sig_en=57749801ab283b66732759944ef98e33 sig_cn_org=None source=14.1 
     <para>
      <function>bt_index_parent_check</function> tests that its
      target, a B-Tree index, respects a variety of invariants.
      Optionally, when the <parameter>heapallindexed</parameter>
      argument is <literal>true</literal>, the function verifies the
      presence of all heap tuples that should be found within the
      index.  When the optional <parameter>rootdescend</parameter>
      argument is <literal>true</literal>, verification re-finds
      tuples on the leaf level by performing a new search from the
      root page for each tuple.  The checks that can be performed by
      <function>bt_index_parent_check</function> are a superset of the
      checks that can be performed by <function>bt_index_check</function>.
      <function>bt_index_parent_check</function> can be thought of as
      a more thorough variant of <function>bt_index_check</function>:
      unlike <function>bt_index_check</function>,
      <function>bt_index_parent_check</function> also checks
      invariants that span parent/child relationships, including checking
      that there are no missing downlinks in the index structure.
      <function>bt_index_parent_check</function> follows the general
      convention of raising an error if it finds a logical
      inconsistency or other problem.
     </para>
________________________________________________________-->
     <para>
      <function>bt_index_parent_check</function>测试一个B树索引，检查多种不变条件。
      可选地，当<parameter>heapallindexed</parameter>参数为<literal>true</literal>时，该函数验证所有应该在索引中找到的堆元组的存在。
      当可选参数<parameter>rootdescend</parameter>值为<literal>true</literal>时，对于每个元组，验证程序通过从根页面执行新的搜索来重新查找叶子层级的元组。<function>bt_index_parent_check</function>能够执行的检查是<function>bt_index_check</function>能执行的检查的超集。
      <function>bt_index_parent_check</function>可以被想成是<function>bt_index_check</function>的一种更全面的变体：和<function>bt_index_check</function>不同，<function>bt_index_parent_check</function>还检查跨越父/子关系的不变条件，包括检查索引结构中是否没有缺失的下链。
      如果找到逻辑不一致或者其他问题，<function>bt_index_parent_check</function>遵循通常的报错习惯。
     </para>
<!-- pgdoc-cn_end sig_en=57749801ab283b66732759944ef98e33 -->
<!-- pgdoc-cn_start sig_en=95ef67675a1c27c7f7b1865a91354b32 sig_cn_org=None source=14.1 
     <para>
      A <literal>ShareLock</literal> is required on the target index by
      <function>bt_index_parent_check</function> (a
      <literal>ShareLock</literal> is also acquired on the heap relation).
      These locks prevent concurrent data modification from
      <command>INSERT</command>, <command>UPDATE</command>, and <command>DELETE</command>
      commands.  The locks also prevent the underlying relation from
      being concurrently processed by <command>VACUUM</command>, as well as
      all other utility commands.  Note that the function holds locks
      only while running, not for the entire transaction.
     </para>
________________________________________________________-->
     <para>
      <function>bt_index_parent_check</function>要求目标索引上的一个<literal>ShareLock</literal>（还要求对关系上的一个<literal>ShareLock</literal>）。这些锁阻止来自<command>INSERT</command>、<command>UPDATE</command>以及<command>DELETE</command>命令的并发数据修改。这些锁同时防止底层关系被并发的<command>VACUUM</command>以及其他工具命令处理。注意该函数只在其运行期间而不是整个事务期间持有锁。
     </para>
<!-- pgdoc-cn_end sig_en=95ef67675a1c27c7f7b1865a91354b32 -->
<!-- pgdoc-cn_start sig_en=fd165459cf02c9eaff49bfcb9b16ce9e sig_cn_org=fd165459cf02c9eaff49bfcb9b16ce9e source=15.7 
     <para>
      <function>bt_index_parent_check</function>'s additional
      verification is more likely to detect various pathological
      cases.  These cases may involve an incorrectly implemented
      B-Tree operator class used by the index that is checked, or,
      hypothetically, undiscovered bugs in the underlying B-Tree index
      access method code.  Note that
      <function>bt_index_parent_check</function> cannot be used when
      hot standby mode is enabled (i.e., on read-only physical
      replicas), unlike <function>bt_index_check</function>.
     </para>
________________________________________________________-->
     <para>
      <function>bt_index_parent_check</function>的额外验证更有可能检测到各种病理情况。
      这些情况可能涉及到被检查的索引使用的 B-Tree 操作类的错误实现，或者假设性地底层 B-Tree 索引访问方法代码中未发现的bug。
      请注意，与<function>bt_index_parent_check</function>不同，
      当启用热备模式（即在只读物理副本上）时，不能使用<function>bt_index_check</function>。
     </para>
<!-- pgdoc-cn_end sig_en=fd165459cf02c9eaff49bfcb9b16ce9e -->
    </listitem>
   </varlistentry>
  </variablelist>
  <tip>
<!-- pgdoc-cn_start sig_en=93f925b3bb2a93d4f7acb1a4aac5f47a sig_cn_org=None source=14.1 
   <para>
    <function>bt_index_check</function> and
    <function>bt_index_parent_check</function> both output log
    messages about the verification process at
    <literal>DEBUG1</literal> and <literal>DEBUG2</literal> severity
    levels.  These messages provide detailed information about the
    verification process that may be of interest to
    <productname>PostgreSQL</productname> developers.  Advanced users
    may also find this information helpful, since it provides
    additional context should verification actually detect an
    inconsistency.  Running:
<programlisting>
SET client_min_messages = DEBUG1;
</programlisting>
    in an interactive <application>psql</application> session before
    running a verification query will display messages about the
    progress of verification with a manageable level of detail.
   </para>
________________________________________________________-->
   <para>
    <function>bt_index_check</function> 和 <function>bt_index_parent_check</function> 都输出关于验证过程的日志信息，在<literal>DEBUG1</literal> 和 <literal>DEBUG2</literal> 严重性级别。
    这些消息提供关于验证过程的详细信息，或许对<productname>PostgreSQL</productname>的开发人员有作用。
    高级用户也许会发现这些信息很有帮助，因为它提供了额外的上下文将验证实际检测的不一致。运行：
<programlisting>
SET client_min_messages = DEBUG1;
</programlisting>
    在运行验证查询之前的交互式<application>psql</application>会话中，将显示有关验证进度的消息，并具有可管理级别的详细信息。
   </para>
<!-- pgdoc-cn_end sig_en=93f925b3bb2a93d4f7acb1a4aac5f47a -->
  </tip>

  <variablelist>
   <varlistentry>
    <term>
     <function>
      verify_heapam(relation regclass,
                    on_error_stop boolean,
                    check_toast boolean,
                    skip text,
                    startblock bigint,
                    endblock bigint,
                    blkno OUT bigint,
                    offnum OUT integer,
                    attnum OUT integer,
                    msg OUT text)
      returns setof record
     </function>
    </term>
    <listitem>
<!-- pgdoc-cn_start sig_en=e61d42d351c3b596c688dc4ad56379c9 sig_cn_org=f09a3764fd19915c4f7b2e897a8dbac1 source=15.7 
     <para>
      Checks a table, sequence, or materialized view for structural corruption,
      where pages in the relation contain data that is invalidly formatted, and
      for logical corruption, where pages are structurally valid but
      inconsistent with the rest of the database cluster.
     </para>
________________________________________________________-->
     <para>
      检查表、序列或物化视图的结构损坏，其中关系中的页面包含格式无效的数据，
      以及逻辑损坏，其中页面在结构上有效但与集簇的其余部分不一致。
</para>
<!-- pgdoc-cn_end sig_en=e61d42d351c3b596c688dc4ad56379c9 -->
<!-- pgdoc-cn_start sig_en=5182bd18378f894f8d63b68c7e82018c sig_cn_org=None source=14.1 
     <para>
      The following optional arguments are recognized:
     </para>
________________________________________________________-->
     <para>
      下述可选参数是可见的:
     </para>
<!-- pgdoc-cn_end sig_en=5182bd18378f894f8d63b68c7e82018c -->
     <variablelist>
      <varlistentry>
       <term><literal>on_error_stop</literal></term>
       <listitem>
<!-- pgdoc-cn_start sig_en=53cf2b2a931ca052e038f2f74019d104 sig_cn_org=None source=14.1 
        <para>
         If true, corruption checking stops at the end of the first block in
         which any corruptions are found.
        </para>
________________________________________________________-->
        <para>
         如果为真(true)，则损坏检查将在被发现有任何损坏的第一个块的末尾停止.
        </para>
<!-- pgdoc-cn_end sig_en=53cf2b2a931ca052e038f2f74019d104 -->
<!-- pgdoc-cn_start sig_en=f06a97c02a7c41624ed012a65ec92b43 sig_cn_org=None source=14.1 
        <para>
         Defaults to false.
        </para>
________________________________________________________-->
        <para>
         默认为假(false).
        </para>
<!-- pgdoc-cn_end sig_en=f06a97c02a7c41624ed012a65ec92b43 -->
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>check_toast</literal></term>
       <listitem>
<!-- pgdoc-cn_start sig_en=325c7d5cef022bc94f28f99123aef03c sig_cn_org=None source=14.1 
        <para>
         If true, toasted values are checked against the target relation's
         TOAST table.
        </para>
________________________________________________________-->
        <para>
         如果为真(true)，toasted值根据目标关系的TOAST表进行检查。
        </para>
<!-- pgdoc-cn_end sig_en=325c7d5cef022bc94f28f99123aef03c -->
<!-- pgdoc-cn_start sig_en=67f0c72f24c9000946bd54e61283f1d6 sig_cn_org=None source=14.1 
        <para>
         This option is known to be slow.  Also, if the toast table or its
         index is corrupt, checking it against toast values could conceivably
         crash the server, although in many cases this would just produce an
         error.
        </para>
________________________________________________________-->
        <para>
         这个选项已知是缓慢的。而且，如果toast表或它的索引损坏了，根据toast值检查它可能会使服务器宕机，虽然在一些情况下仅是产生一个错误。
        </para>
<!-- pgdoc-cn_end sig_en=67f0c72f24c9000946bd54e61283f1d6 -->
<!-- pgdoc-cn_start sig_en=f06a97c02a7c41624ed012a65ec92b43 sig_cn_org=None source=14.1 
        <para>
         Defaults to false.
        </para>
________________________________________________________-->
        <para>
         默认为假(false).
        </para>
<!-- pgdoc-cn_end sig_en=f06a97c02a7c41624ed012a65ec92b43 -->
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>skip</literal></term>
       <listitem>
<!-- pgdoc-cn_start sig_en=4d9f0987c6f522e51a6598032fe80165 sig_cn_org=None source=14.1 
        <para>
         If not <literal>none</literal>, corruption checking skips blocks that
         are marked as all-visible or all-frozen, as specified.
         Valid options are <literal>all-visible</literal>,
         <literal>all-frozen</literal> and <literal>none</literal>.
        </para>
________________________________________________________-->
        <para>
         如果不是 <literal>none</literal>,损坏检查会根据规定忽略被标示为全部可见或全部冻结的块。
         有效的选项为<literal>all-visible</literal>,<literal>all-frozen</literal> 和 <literal>none</literal>。
        </para>
<!-- pgdoc-cn_end sig_en=4d9f0987c6f522e51a6598032fe80165 -->
<!-- pgdoc-cn_start sig_en=55502d00fa77e90fd57328721109d2e2 sig_cn_org=None source=14.1 
        <para>
         Defaults to <literal>none</literal>.
        </para>
________________________________________________________-->
        <para>
         默认为 <literal>none</literal>.
        </para>
<!-- pgdoc-cn_end sig_en=55502d00fa77e90fd57328721109d2e2 -->
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>startblock</literal></term>
       <listitem>
<!-- pgdoc-cn_start sig_en=0b8b723dd0ec0836016c9f5de9277263 sig_cn_org=None source=14.1 
        <para>
         If specified, corruption checking begins at the specified block,
         skipping all previous blocks.  It is an error to specify a
         <parameter>startblock</parameter> outside the range of blocks in the
         target table.
        </para>
________________________________________________________-->
        <para>
         如果已指定，则损坏检查从指定的块开始，忽略前面所有的块。指定<parameter>startblock</parameter>超出目标表的块的范围是一个错误。
        </para>
<!-- pgdoc-cn_end sig_en=0b8b723dd0ec0836016c9f5de9277263 -->
<!-- pgdoc-cn_start sig_en=fe796ecf97357ec1eaa01c2848957508 sig_cn_org=None source=14.1 
        <para>
         By default, checking begins at the first block.
        </para>
________________________________________________________-->
        <para>
         默认情况下，检查从第一个块开始。
        </para>
<!-- pgdoc-cn_end sig_en=fe796ecf97357ec1eaa01c2848957508 -->
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>endblock</literal></term>
       <listitem>
<!-- pgdoc-cn_start sig_en=bb5c14ad8e0c9e6226120b7094d72709 sig_cn_org=None source=14.1 
        <para>
         If specified, corruption checking ends at the specified block,
         skipping all remaining blocks.  It is an error to specify an
         <parameter>endblock</parameter> outside the range of blocks in the target
         table.
        </para>
________________________________________________________-->
        <para>
         如果已经指定，损坏检查在指定的块结束，忽略所有剩余的块。指定<parameter>endblock</parameter>超出目标表的块的范围是一个错误。
        </para>
<!-- pgdoc-cn_end sig_en=bb5c14ad8e0c9e6226120b7094d72709 -->
<!-- pgdoc-cn_start sig_en=0337c086720e2b69e5688a6a3831c2c7 sig_cn_org=None source=14.1 
        <para>
         By default, all blocks are checked.
        </para>
________________________________________________________-->
        <para>
         默认情况下，所有的块都被检测。
        </para>
<!-- pgdoc-cn_end sig_en=0337c086720e2b69e5688a6a3831c2c7 -->
       </listitem>
      </varlistentry>
     </variablelist>
<!-- pgdoc-cn_start sig_en=d981b868145a3748c87e8f89f269701d sig_cn_org=None source=14.1 
     <para>
      For each corruption detected, <function>verify_heapam</function> returns
      a row with the following columns:
     </para>
________________________________________________________-->
     <para>
      对所有检测到的损坏情况, <function>verify_heapam</function> 返回一行包含下述列:
     </para>
<!-- pgdoc-cn_end sig_en=d981b868145a3748c87e8f89f269701d -->
     <variablelist>
      <varlistentry>
       <term><literal>blkno</literal></term>
       <listitem>
<!-- pgdoc-cn_start sig_en=cbb0222a5c8cc8fededd78f5fb5462f5 sig_cn_org=None source=14.1 
        <para>
         The number of the block containing the corrupt page.
        </para>
________________________________________________________-->
        <para>
         包含损坏页的块的编号。
        </para>
<!-- pgdoc-cn_end sig_en=cbb0222a5c8cc8fededd78f5fb5462f5 -->
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>offnum</literal></term>
       <listitem>
<!-- pgdoc-cn_start sig_en=f2649b56683dddd3122731feb219f420 sig_cn_org=None source=14.1 
        <para>
         The OffsetNumber of the corrupt tuple.
        </para>
________________________________________________________-->
        <para>
         损坏元组的 OffsetNumber。
        </para>
<!-- pgdoc-cn_end sig_en=f2649b56683dddd3122731feb219f420 -->
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>attnum</literal></term>
       <listitem>
<!-- pgdoc-cn_start sig_en=41c4fa46068c55907ef69762d650359e sig_cn_org=None source=14.1 
        <para>
         The attribute number of the corrupt column in the tuple, if the
         corruption is specific to a column and not the tuple as a whole.
        </para>
________________________________________________________-->
        <para>
         如果损坏是指定到列而不是整个元组，则为元组中损坏列的属性号。
        </para>
<!-- pgdoc-cn_end sig_en=41c4fa46068c55907ef69762d650359e -->
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><literal>msg</literal></term>
       <listitem>
<!-- pgdoc-cn_start sig_en=bf8934d527e89e5ed461b077756402a5 sig_cn_org=None source=14.1 
        <para>
         A message describing the problem detected.
        </para>
________________________________________________________-->
        <para>
         描述检测到的问题的消息。
        </para>
<!-- pgdoc-cn_end sig_en=bf8934d527e89e5ed461b077756402a5 -->
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2>
<!-- pgdoc-cn_start sig_en=0719fa1407fb8b541f5f0ba1f8f12343 sig_cn_org=None source=14.1 
  <title>Optional <parameter>heapallindexed</parameter> Verification</title>
________________________________________________________-->
  <title>可选的<parameter>heapallindexed</parameter>验证</title>
<!-- pgdoc-cn_end sig_en=0719fa1407fb8b541f5f0ba1f8f12343 -->
<!-- pgdoc-cn_start sig_en=83166d3464048256923096e51ef5ae0f sig_cn_org=None source=14.1 
 <para>
  When the <parameter>heapallindexed</parameter> argument to B-Tree
  verification functions is <literal>true</literal>, an additional
  phase of verification is performed against the table associated with
  the target index relation.  This consists of a <quote>dummy</quote>
  <command>CREATE INDEX</command> operation, which checks for the
  presence of all hypothetical new index tuples against a temporary,
  in-memory summarizing structure (this is built when needed during
  the basic first phase of verification).  The summarizing structure
  <quote>fingerprints</quote> every tuple found within the target
  index.  The high level principle behind
  <parameter>heapallindexed</parameter> verification is that a new
  index that is equivalent to the existing, target index must only
  have entries that can be found in the existing structure.
 </para>
________________________________________________________-->
 <para>
  当B-Tree验证函数的<parameter>heapallindexed</parameter>参数为<literal>true</literal>时，会针对与目标索引关系关联的表执行一个额外的验证过程。这种验证由一个<quote>假的</quote><command>CREATE INDEX</command>操作组成，它针对一个临时的、内存中的汇总结构（根据需要在基础的第一阶段验证过程中建立）检查所有假想的新索引元组的存在。这个汇总结构对目标索引中的每一个元组<quote>采集指纹</quote>。<parameter>heapallindexed</parameter>验证背后的高层原则是：等效于现有目标索引的新索引必须仅拥有能在现有结构中找得到的项。
 </para>
<!-- pgdoc-cn_end sig_en=83166d3464048256923096e51ef5ae0f -->
<!-- pgdoc-cn_start sig_en=efa6a4d755c790c62d49d2bc9818a3fa sig_cn_org=None source=14.1 
 <para>
  The additional <parameter>heapallindexed</parameter> phase adds
  significant overhead: verification will typically take several times
  longer.  However, there is no change to the relation-level locks
  acquired when <parameter>heapallindexed</parameter> verification is
  performed.
 </para>
________________________________________________________-->
 <para>
  额外的<parameter>heapallindexed</parameter>阶段会增加明显的开销：验证的时间通常将会延长几倍。不过，在执行<parameter>heapallindexed</parameter>验证时，所要求的关系级锁没有变化。
 </para>
<!-- pgdoc-cn_end sig_en=efa6a4d755c790c62d49d2bc9818a3fa -->
<!-- pgdoc-cn_start sig_en=ead759b6acc9c511f69670e08d1917c4 sig_cn_org=None source=14.1 
 <para>
  The summarizing structure is bound in size by
  <varname>maintenance_work_mem</varname>.  In order to ensure that
  there is no more than a 2% probability of failure to detect an
  inconsistency for each heap tuple that should be represented in the
  index, approximately 2 bytes of memory are needed per tuple.  As
  less memory is made available per tuple, the probability of missing
  an inconsistency slowly increases.  This approach limits the
  overhead of verification significantly, while only slightly reducing
  the probability of detecting a problem, especially for installations
  where verification is treated as a routine maintenance task.  Any
  single absent or malformed tuple has a new opportunity to be
  detected with each new verification attempt.
 </para>
________________________________________________________-->
 <para>
  这一汇总结构的尺寸以<varname>maintenance_work_mem</varname>为界。为了确保对于每个堆元组应该存在于索引中这一检测有不超过2%的失效概率能检测到不一致，每个元组需要大约2个字节的内存。因为每个元组可用的内存变少，错失一处不一致的概率就会慢慢增加。这种方法显著地限制了验证的开销，但仅仅略微降低了检测到问题的概率，对于将验证当作例行维护任务的安装来说更是如此。对于每一次新的验证尝试，任何单一的缺失或者畸形元组都有新的机会被检测到。
 </para>
<!-- pgdoc-cn_end sig_en=ead759b6acc9c511f69670e08d1917c4 -->

 </sect2>

 <sect2>
<!-- pgdoc-cn_start sig_en=e36b1962e576f09f4bdc1696bb1f284c sig_cn_org=None source=14.1 
  <title>Using <filename>amcheck</filename> Effectively</title>
________________________________________________________-->
  <title>有效地使用<filename>amcheck</filename></title>
<!-- pgdoc-cn_end sig_en=e36b1962e576f09f4bdc1696bb1f284c -->

<!-- pgdoc-cn_start sig_en=75e16f10837c7c7b7c6b2cce16ed802a sig_cn_org=None source=14.1 
 <para>
  <filename>amcheck</filename> can be effective at detecting various types of
  failure modes that <link
  linkend="app-initdb-data-checksums"><application>data
  checksums</application></link> will fail to catch.  These include:

  <itemizedlist>
   <listitem>
    <para>
     Structural inconsistencies caused by incorrect operator class
     implementations.
    </para>
    <para>
     This includes issues caused by the comparison rules of operating
     system collations changing. Comparisons of datums of a collatable
     type like <type>text</type> must be immutable (just as all
     comparisons used for B-Tree index scans must be immutable), which
     implies that operating system collation rules must never change.
     Though rare, updates to operating system collation rules can
     cause these issues. More commonly, an inconsistency in the
     collation order between a primary server and a standby server is
     implicated, possibly because the <emphasis>major</emphasis> operating
     system version in use is inconsistent.  Such inconsistencies will
     generally only arise on standby servers, and so can generally
     only be detected on standby servers.
    </para>
    <para>
     If a problem like this arises, it may not affect each individual
     index that is ordered using an affected collation, simply because
     <emphasis>indexed</emphasis> values might happen to have the same
     absolute ordering regardless of the behavioral inconsistency. See
     <xref linkend="locale"/> and <xref linkend="collation"/> for
     further details about how <productname>PostgreSQL</productname> uses
     operating system locales and collations.
    </para>
   </listitem>
   <listitem>
    <para>
     Structural inconsistencies between indexes and the heap relations
     that are indexed (when <parameter>heapallindexed</parameter>
     verification is performed).
    </para>
    <para>
     There is no cross-checking of indexes against their heap relation
     during normal operation.  Symptoms of heap corruption can be subtle.
    </para>
   </listitem>
   <listitem>
    <para>
     Corruption caused by hypothetical undiscovered bugs in the
     underlying <productname>PostgreSQL</productname> access method
     code, sort code, or transaction management code.
    </para>
    <para>
     Automatic verification of the structural integrity of indexes
     plays a role in the general testing of new or proposed
     <productname>PostgreSQL</productname> features that could plausibly allow a
     logical inconsistency to be introduced.  Verification of table
     structure and associated visibility and transaction status
     information plays a similar role.  One obvious testing strategy
     is to call <filename>amcheck</filename> functions continuously
     when running the standard regression tests.  See <xref
     linkend="regress-run"/> for details on running the tests.
    </para>
   </listitem>
   <listitem>
    <para>
     File system or storage subsystem faults where checksums happen to
     simply not be enabled.
    </para>
    <para>
     Note that <filename>amcheck</filename> examines a page as represented in some
     shared memory buffer at the time of verification if there is only a
     shared buffer hit when accessing the block. Consequently,
     <filename>amcheck</filename> does not necessarily examine data read from the
     file system at the time of verification. Note that when checksums are
     enabled, <filename>amcheck</filename> may raise an error due to a checksum
     failure when a corrupt block is read into a buffer.
    </para>
   </listitem>
   <listitem>
    <para>
     Corruption caused by faulty RAM, or the broader memory subsystem.
    </para>
    <para>
     <productname>PostgreSQL</productname> does not protect against correctable
     memory errors and it is assumed you will operate using RAM that
     uses industry standard Error Correcting Codes (ECC) or better
     protection.  However, ECC memory is typically only immune to
     single-bit errors, and should not be assumed to provide
     <emphasis>absolute</emphasis> protection against failures that
     result in memory corruption.
    </para>
    <para>
     When <parameter>heapallindexed</parameter> verification is
     performed, there is generally a greatly increased chance of
     detecting single-bit errors, since strict binary equality is
     tested, and the indexed attributes within the heap are tested.
    </para>
   </listitem>
  </itemizedlist>
 </para>
________________________________________________________-->
 <para>
  <filename>amcheck</filename>对于检测多种<link linkend="app-initdb-data-checksums"><application>数据校验和</application></link>无法捕捉到的失效模式非常有效。包括：

  <itemizedlist>
   <listitem>
    <para>
     由不正确的操作符类实现导致的结构性不一致。
    </para>
    <para>
     这包括操作系统排序规则的比较规则变化导致的问题。
     <type>text</type>之类的可排序类型数据的比较必须是不变的（正如用于B-树索引扫描的所有比较必须不变一样），这意味着操作系统排序规则必须保持不变。
     但是在很少的情况下，操作系统排序规则的更新会导致这些问题。
     更常见的，主服务器和后备服务器之间排序顺序的不一致会相互牵连，这可能是因为使用的<emphasis>主</emphasis>操作系统版本不一致。
     这类不一致通常仅出现在后备服务器上，因此通常也仅能在后备服务器上检测到。
    </para>
    <para>
     如果这类问题出现，则它可能不会影响使用受影响排序规则排序的每一个索引，其原因是<emphasis>被索引</emphasis>值可能正好具有与行为不一致无关的相同的绝对顺序。关于<productname>PostgreSQL</productname>如何使用操作系统locale和排序规则的进一步细节请参考<xref linkend="locale"/>和<xref linkend="collation"/>。
    </para>
   </listitem>
   <listitem>
    <para>
     索引和被索引的对关系之间的结构不一致（在执行<parameter>heapallindexed</parameter>验证时）。
    </para>
    <para>
     在普通操作时没有将索引针对其对关系进行交叉检查。堆损坏的症状可能是很微妙的。
    </para>
   </listitem>
   <listitem>
    <para>
     由于底层<productname>PostgreSQL</productname>访问方法代码、排序代码或者事务管理代码中（假想的）未发现的缺陷导致的损坏。
    </para>
    <para>
     在测试可能引入逻辑不一致的<productname>PostgreSQL</productname>新特性或者被提议的特性时，索引的结构完整性自动验证扮演了重要角色。表结构、相关的可见性和事务状态信息的验证扮演了类似的角色。一种显而易见的测试策略是在运行标准回归测试时持续地调用<filename>amcheck</filename>函数。运行这些测试的详情请参考<xref linkend="regress-run"/>。
    </para>
   </listitem>
   <listitem>
    <para>
     正巧没有开启校验和的文件系统或者存储子系统故障。
    </para>
    <para>
     注意，如果在访问块时仅有一次共享缓存命中，验证时<filename>amcheck</filename>会在检查表示在某个共享内存缓冲区中的页面。因此，<filename>amcheck</filename>没有必要在验证时检查从文件系统读出的数据。注意当校验和被启用时，如果一个损坏的块被读取到缓冲区中，<filename>amcheck</filename>可能会由于校验和失效而产生错误。
    </para>
   </listitem>
   <listitem>
    <para>
     有缺陷的RAM或者内存子系统导致的损坏。
    </para>
    <para>
     <productname>PostgreSQL</productname>无法提供针对可更正内存错误的保护并且它假定用户使用的是具有工业标准纠错码（ECC）或更好保护技术的RAM。不过，ECC内存通常只能免疫单个位错误，并且不应该假定它能提供对导致内存损坏失效的<emphasis>绝对</emphasis>保护。
    </para>
    <para>
     在执行<parameter>heapallindexed</parameter>验证时，通常有大幅增加的机会可以检测单个位错误，因为会测试严格的二元等值并且会在堆中测试被索引属性。
    </para>
   </listitem>
  </itemizedlist>
 </para>
<!-- pgdoc-cn_end sig_en=75e16f10837c7c7b7c6b2cce16ed802a -->

<!-- pgdoc-cn_start sig_en=aa3bffbe43560cb388a979fa840f64a2 sig_cn_org=None source=14.1 
 <para>
  Structural corruption can happen due to faulty storage hardware, or
  relation files being overwritten or modified by unrelated software.
  This kind of corruption can also be detected with
  <link linkend="checksums"><application>data page
  checksums</application></link>.
 </para>
________________________________________________________-->
 <para>
  由于有故障的存储硬件，或者相关文件被不相关的软件覆盖或修改，可能会发生结构损坏。
  这类损坏也可以通过<link linkend="checksums"><application>data page checksums</application></link>来检测。
 </para>
<!-- pgdoc-cn_end sig_en=aa3bffbe43560cb388a979fa840f64a2 -->

<!-- pgdoc-cn_start sig_en=26152e75d7ea0de9afc2697d5beeb990 sig_cn_org=None source=14.1 
 <para>
  Relation pages which are correctly formatted, internally consistent, and
  correct relative to their own internal checksums may still contain
  logical corruption.  As such, this kind of corruption cannot be detected
  with <application>checksums</application>.  Examples include toasted
  values in the main table which lack a corresponding entry in the toast
  table, and tuples in the main table with a Transaction ID that is older
  than the oldest valid Transaction ID in the database or cluster.
 </para>
________________________________________________________-->
 <para>
  格式正确、内部一致并且相对于其内部校验和正确的关系页依然可能包含逻辑损坏。
  因此，这类损坏不能被<application>checksums</application>所检测到。
  例如包括主表中的toasted值在toast表中缺少相应的条目，以及主表中具有比数据库或集群中最古老的有效Transaction ID更旧的Transaction ID的元组。
 </para>
<!-- pgdoc-cn_end sig_en=26152e75d7ea0de9afc2697d5beeb990 -->

<!-- pgdoc-cn_start sig_en=5cb85b2d67e0195c3c059648750f0929 sig_cn_org=None source=14.1 
 <para>
  Multiple causes of logical corruption have been observed in production
  systems, including bugs in the <productname>PostgreSQL</productname>
  server software, faulty and ill-conceived backup and restore tools, and
  user error.
 </para>
________________________________________________________-->
 <para>
  在生产系统中已经观察到多个导致逻辑损坏的原因，包括<productname>PostgreSQL</productname>服务器软件中的缺陷、错误且考虑欠妥的备份和恢复工具，以及用户错误。
 </para>
<!-- pgdoc-cn_end sig_en=5cb85b2d67e0195c3c059648750f0929 -->

<!-- pgdoc-cn_start sig_en=a3536a3846d71bd1400c7b3ee47e5a4c sig_cn_org=None source=14.1 
 <para>
  Corrupt relations are most concerning in live production environments,
  precisely the same environments where high risk activities are least
  welcome.  For this reason, <function>verify_heapam</function> has been
  designed to diagnose corruption without undue risk.  It cannot guard
  against all causes of backend crashes, as even executing the calling
  query could be unsafe on a badly corrupted system.   Access to <link
  linkend="catalogs-overview">catalog tables</link> is performed and could
  be problematic if the catalogs themselves are corrupted.
 </para>
________________________________________________________-->
 <para>
  在实时生产环境中，损坏关系是最令人担忧的，而这样的环境中是最不欢迎高风险活动的。
  基于此原因，设计了<function>verify_heapam</function>以在无过度风险的情况下诊断错误。
  它不能保证防止后端崩溃的所有原因，因为在严重损坏的系统上，即使执行调用查询也可能不安全。
  执行对<link linkend="catalogs-overview">catalog tables</link>的访问，如果编目自身损坏了，也可能会出现问题。
 </para>
<!-- pgdoc-cn_end sig_en=a3536a3846d71bd1400c7b3ee47e5a4c -->

<!-- pgdoc-cn_start sig_en=da72b942c28a46b30d6f0d7e5b99197d sig_cn_org=None source=14.1 
 <para>
  In general, <filename>amcheck</filename> can only prove the presence of
  corruption; it cannot prove its absence.
 </para>
________________________________________________________-->
 <para>
    通常，<filename>amcheck</filename>仅能证明损坏的存在，但它无法证明损坏不存在。
 </para>
<!-- pgdoc-cn_end sig_en=da72b942c28a46b30d6f0d7e5b99197d -->

 </sect2>
 <sect2>
<!-- pgdoc-cn_start sig_en=bd6b75318e86cc99b508939c3dcf4cda sig_cn_org=None source=14.1 
  <title>Repairing Corruption</title>
________________________________________________________-->
  <title>修复损坏</title>
<!-- pgdoc-cn_end sig_en=bd6b75318e86cc99b508939c3dcf4cda -->
<!-- pgdoc-cn_start sig_en=8a1820c49cfa0fd90986bb15198293d5 sig_cn_org=None source=14.1 
 <para>
  No error concerning corruption raised by <filename>amcheck</filename> should
  ever be a false positive.  <filename>amcheck</filename> raises
  errors in the event of conditions that, by definition, should never
  happen, and so careful analysis of <filename>amcheck</filename>
  errors is often required.
 </para>
________________________________________________________-->
 <para>
  <filename>amcheck</filename>没有产生与损坏相关的错误绝不应该被当做假阳性。<filename>amcheck</filename>会在（定义上）应该绝不会发生的情况中抛出错误，因此常常需要对<filename>amcheck</filename>错误进行仔细地分析。
 </para>
<!-- pgdoc-cn_end sig_en=8a1820c49cfa0fd90986bb15198293d5 -->
<!-- pgdoc-cn_start sig_en=3d647d8cfe77fd5555588b87577406c0 sig_cn_org=None source=14.1 
 <para>
  There is no general method of repairing problems that
  <filename>amcheck</filename> detects.  An explanation for the root cause of
  an invariant violation should be sought.  <xref
  linkend="pageinspect"/> may play a useful role in diagnosing
  corruption that <filename>amcheck</filename> detects.  A <command>REINDEX</command>
  may not be effective in repairing corruption.
 </para>
________________________________________________________-->
 <para>
  对于<filename>amcheck</filename>检测到的问题没有一般性的修复方法。应该寻找产生不变条件违背的根本原因。在诊断<filename>amcheck</filename>检测到的损坏时，<xref linkend="pageinspect"/>可能会扮演一个非常有用的角色。<command>REINDEX</command>在修复损坏过程中可能无法起到效果。
 </para>
<!-- pgdoc-cn_end sig_en=3d647d8cfe77fd5555588b87577406c0 -->

 </sect2>

</sect1>
