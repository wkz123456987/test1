<!-- doc/src/sgml/rangetypes.sgml -->

<sect1 id="rangetypes">
<!-- pgdoc-cn_start sig_en=f97cfe418c927a69cf79189a9c2aa9c2 sig_cn_org=None source=14.1 
 <title>Range Types</title>
________________________________________________________-->
 <title>范围类型</title>
<!-- pgdoc-cn_end sig_en=f97cfe418c927a69cf79189a9c2aa9c2 -->

<!-- pgdoc-cn_start sig_en=dddbb9bb0405794f50a95a9fa8015e28 sig_cn_org=None source=14.1 
 <indexterm>
  <primary>range type</primary>
 </indexterm>
________________________________________________________-->
 <indexterm>
  <primary>range type</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=dddbb9bb0405794f50a95a9fa8015e28 -->

<!-- pgdoc-cn_start sig_en=ca1c54e687029c984843597fdb616bef sig_cn_org=None source=14.1 
 <indexterm>
  <primary>multirange type</primary>
 </indexterm>
________________________________________________________-->
 <indexterm>
  <primary>multirange type</primary>
 </indexterm>
<!-- pgdoc-cn_end sig_en=ca1c54e687029c984843597fdb616bef -->

<!-- pgdoc-cn_start sig_en=d76cab44d0f56b132d5d75c8794fb2b1 sig_cn_org=None source=14.1 
 <para>
  Range types are data types representing a range of values of some
  element type (called the range's <firstterm>subtype</firstterm>).
  For instance, ranges
  of <type>timestamp</type> might be used to represent the ranges of
  time that a meeting room is reserved. In this case the data type
  is <type>tsrange</type> (short for <quote>timestamp range</quote>),
  and <type>timestamp</type> is the subtype.  The subtype must have
  a total order so that it is well-defined whether element values are
  within, before, or after a range of values.
 </para>
________________________________________________________-->
 <para>
  范围类型是表达某种元素类型（称为范围的<firstterm>subtype</firstterm>）的一个值的范围的数据类型。例如，<type>timestamp</type>的范围可以被用来表达一个会议室被保留的时间范围。在这种情况下，数据类型是<type>tsrange</type>（<quote>timestamp range</quote>的简写）而<type>timestamp</type>是 subtype。subtype 必须具有一种总体的顺序，这样对于元素值是在一个范围值之内、之前或之后就是界线清楚的。
 </para>
<!-- pgdoc-cn_end sig_en=d76cab44d0f56b132d5d75c8794fb2b1 -->

<!-- pgdoc-cn_start sig_en=143a8d9fda8735b18ba38a0ac12bf3db sig_cn_org=None source=14.1 
 <para>
  Range types are useful because they represent many element values in a
  single range value, and because concepts such as overlapping ranges can
  be expressed clearly. The use of time and date ranges for scheduling
  purposes is the clearest example; but price ranges, measurement
  ranges from an instrument, and so forth can also be useful.
 </para>
________________________________________________________-->
 <para>
  范围类型非常有用，因为它们可以表达一种单一范围值中的多个元素值，并且可以很清晰地表达诸如范围重叠等概念。用于时间安排的时间和日期范围是最清晰的例子；但是价格范围、一种仪器的量程等等也都有用。
 </para>
<!-- pgdoc-cn_end sig_en=143a8d9fda8735b18ba38a0ac12bf3db -->

<!-- pgdoc-cn_start sig_en=09b997396bae4cbf57075610d5fecd15 sig_cn_org=None source=14.1 
 <para>
  Every range type has a corresponding multirange type. A multirange is
  an ordered list of non-contiguous, non-empty, non-null ranges. Most
  range operators also work on multiranges, and they have a few functions
  of their own.
 </para>
________________________________________________________-->
 <para>
   每个范围类型都有对应的多范围类型。多重范围是非连续、非空、非 NULL 范围的有序列表。大多数范围运算符也适用于多个范围并具有一些独特的函数。
  </para>
<!-- pgdoc-cn_end sig_en=09b997396bae4cbf57075610d5fecd15 -->

 <sect2 id="rangetypes-builtin">
<!-- pgdoc-cn_start sig_en=3d2660febb302343126b6a5d26964e3c sig_cn_org=None source=14.1 
  <title>Built-in Range and Multirange Types</title>
________________________________________________________-->
  <title>内建范围类型和多范围类型</title>
<!-- pgdoc-cn_end sig_en=3d2660febb302343126b6a5d26964e3c -->

<!-- pgdoc-cn_start sig_en=3b61fef56a7268b6b3b02d07b32200d2 sig_cn_org=None source=14.1 
 <para>
  PostgreSQL comes with the following built-in range types:
  <itemizedlist>
    <listitem>
      <para>
       <type>int4range</type> &mdash; Range of <type>integer</type>,
       <type>int4multirange</type> &mdash; corresponding Multirange
      </para>
    </listitem>
    <listitem>
      <para>
       <type>int8range</type> &mdash; Range of <type>bigint</type>,
       <type>int8multirange</type> &mdash; corresponding Multirange
      </para>
    </listitem>
    <listitem>
      <para>
       <type>numrange</type> &mdash; Range of <type>numeric</type>,
       <type>nummultirange</type> &mdash; corresponding Multirange
      </para>
    </listitem>
    <listitem>
      <para>
       <type>tsrange</type> &mdash; Range of <type>timestamp without time zone</type>,
       <type>tsmultirange</type> &mdash; corresponding Multirange
      </para>
    </listitem>
    <listitem>
      <para>
       <type>tstzrange</type> &mdash; Range of <type>timestamp with time zone</type>,
       <type>tstzmultirange</type> &mdash; corresponding Multirange
      </para>
    </listitem>
    <listitem>
      <para>
       <type>daterange</type> &mdash; Range of <type>date</type>,
       <type>datemultirange</type> &mdash; corresponding Multirange
      </para>
    </listitem>
  </itemizedlist>
  In addition, you can define your own range types;
  see <xref linkend="sql-createtype"/> for more information.
 </para>
________________________________________________________-->
 <para>
  PostgreSQL 带有下列内建范围类型：
  <itemizedlist>
    <listitem>
      <para>
       <type>int4range</type> &mdash; <type>integer</type>的范围
       <type>int4multirange</type> &mdash; 相应的多重范围
      </para>
    </listitem>
    <listitem>
      <para>
       <type>int8range</type> &mdash; <type>bigint</type>的范围
       <type>int8multirange</type> &mdash; 相应的多重范围
      </para>
    </listitem>
    <listitem>
      <para>
       <type>numrange</type> &mdash; <type>numeric</type>的范围
       <type>nummultirange</type> &mdash; 相应的多重范围
      </para>
    </listitem>
    <listitem>
      <para>
       <type>tsrange</type> &mdash; <type>不带时区的 timestamp</type>的范围
       <type>tsmultirange</type> &mdash; 相应的多重范围
      </para>
    </listitem>
    <listitem>
      <para>
       <type>tstzrange</type> &mdash; <type>带时区的 timestamp</type>的范围
       <type>tstzmultirange</type> &mdash; 相应的多重范围
      </para>
    </listitem>
    <listitem>
      <para>
       <type>daterange</type> &mdash; <type>date</type>的范围
       <type>datemultirange</type> &mdash; 相应的多重范围
      </para>
    </listitem>
  </itemizedlist>
  此外，你可以定义自己的范围类型，详见<xref linkend="sql-createtype"/>。
 </para>
<!-- pgdoc-cn_end sig_en=3b61fef56a7268b6b3b02d07b32200d2 -->
 </sect2>

 <sect2 id="rangetypes-examples">
<!-- pgdoc-cn_start sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d sig_cn_org=None source=14.1 
  <title>Examples</title>
________________________________________________________-->
  <title>例子</title>
<!-- pgdoc-cn_end sig_en=8f24ed0a9e4d47ffa2be9a1f3e09fa6d -->

<!-- pgdoc-cn_start sig_en=7acf80976526325586253604ace12ab7 sig_cn_org=None source=14.1 
  <para>
<programlisting>
CREATE TABLE reservation (room int, during tsrange);
INSERT INTO reservation VALUES
    (1108, '[2010-01-01 14:30, 2010-01-01 15:30)');

-&minus; Containment
SELECT int4range(10, 20) @&gt; 3;

-&minus; Overlaps
SELECT numrange(11.1, 22.2) &amp;&amp; numrange(20.0, 30.0);

-&minus; Extract the upper bound
SELECT upper(int8range(15, 25));

-&minus; Compute the intersection
SELECT int4range(10, 20) * int4range(15, 25);

-&minus; Is the range empty?
SELECT isempty(numrange(1, 5));
</programlisting>

   See <xref linkend="range-operators-table"/>
   and <xref linkend="range-functions-table"/> for complete lists of
   operators and functions on range types.
  </para>
________________________________________________________-->
  <para>
<programlisting>
CREATE TABLE reservation (room int, during tsrange);
INSERT INTO reservation VALUES
    (1108, '[2010-01-01 14:30, 2010-01-01 15:30)');

-- 包含
SELECT int4range(10, 20) @&gt; 3;

-- 重叠
SELECT numrange(11.1, 22.2) &amp;&amp; numrange(20.0, 30.0);

-- 抽取上界
SELECT upper(int8range(15, 25));

-- 计算交集
SELECT int4range(10, 20) * int4range(15, 25);

-- 范围为空吗？
SELECT isempty(numrange(1, 5));
</programlisting>

   范围类型上的操作符和函数的完整列表可见<xref linkend="range-operators-table"/>以及<xref linkend="range-functions-table"/>。
  </para>
<!-- pgdoc-cn_end sig_en=7acf80976526325586253604ace12ab7 -->
 </sect2>

 <sect2 id="rangetypes-inclusivity">
<!-- pgdoc-cn_start sig_en=89cef47d38ef4fd26f984bea3a66cb38 sig_cn_org=None source=14.1 
  <title>Inclusive and Exclusive Bounds</title>
________________________________________________________-->
  <title>包含和排除边界</title>
<!-- pgdoc-cn_end sig_en=89cef47d38ef4fd26f984bea3a66cb38 -->

<!-- pgdoc-cn_start sig_en=d88844353becd0d8947b8d807e406c4a sig_cn_org=None source=14.1 
  <para>
   Every non-empty range has two bounds, the lower bound and the upper
   bound. All points between these values are included in the range. An
   inclusive bound means that the boundary point itself is included in
   the range as well, while an exclusive bound means that the boundary
   point is not included in the range.
  </para>
________________________________________________________-->
  <para>
   每一个非空范围都有两个界限，下界和上界。这些值之间的所有点都被包括在范围内。一个包含界限意味着边界点本身也被包括在范围内，而一个排除边界意味着边界点不被包括在范围内。
  </para>
<!-- pgdoc-cn_end sig_en=d88844353becd0d8947b8d807e406c4a -->

<!-- pgdoc-cn_start sig_en=60d4cb5f240a5989c3258bf9282fd77a sig_cn_org=None source=14.1 
  <para>
   In the text form of a range, an inclusive lower bound is represented by
   <quote><literal>[</literal></quote> while an exclusive lower bound is
   represented by <quote><literal>(</literal></quote>. Likewise, an inclusive upper bound is represented by
   <quote><literal>]</literal></quote>, while an exclusive upper bound is
   represented by <quote><literal>)</literal></quote>.
   (See <xref linkend="rangetypes-io"/> for more details.)
  </para>
________________________________________________________-->
  <para>
   在一个范围的文本形式中，一个包含下界被表达为<quote><literal>[</literal></quote>而一个排除下界被表达为<quote><literal>(</literal></quote>。同样，一个包含上界被表达为<quote><literal>]</literal></quote>而一个排除上界被表达为<quote><literal>)</literal></quote>（详见<xref linkend="rangetypes-io"/>）。
  </para>
<!-- pgdoc-cn_end sig_en=60d4cb5f240a5989c3258bf9282fd77a -->

<!-- pgdoc-cn_start sig_en=71b1160a5a95966de607da61271edf8c sig_cn_org=None source=14.1 
  <para>
   The functions <literal>lower_inc</literal>
   and <literal>upper_inc</literal> test the inclusivity of the lower
   and upper bounds of a range value, respectively.
  </para>
________________________________________________________-->
  <para>
   函数<literal>lower_inc</literal>和<literal>upper_inc</literal>分别测试一个范围值的上下界。
  </para>
<!-- pgdoc-cn_end sig_en=71b1160a5a95966de607da61271edf8c -->
 </sect2>

 <sect2 id="rangetypes-infinite">
<!-- pgdoc-cn_start sig_en=b9b803e6450c6c5b70861274ea18c5e7 sig_cn_org=None source=14.1 
  <title>Infinite (Unbounded) Ranges</title>
________________________________________________________-->
  <title>无限（无界）范围</title>
<!-- pgdoc-cn_end sig_en=b9b803e6450c6c5b70861274ea18c5e7 -->

<!-- pgdoc-cn_start sig_en=4a68671348b6f501f6a51edd53d5b1f5 sig_cn_org=None source=14.1 
  <para>
   The lower bound of a range can be omitted, meaning that all
   values less than the upper bound are included in the range, e.g.,
   <literal>(,3]</literal>. Likewise, if the upper bound of the range
   is omitted, then all values greater than the lower bound are included
   in the range. If both lower and upper bounds are omitted, all values
   of the element type are considered to be in the range.  Specifying a
   missing bound as inclusive is automatically converted to exclusive,
   e.g., <literal>[,]</literal> is converted to <literal>(,)</literal>.
   You can think of these missing values as +/-infinity, but they are
   special range type values and are considered to be beyond any range
   element type's +/-infinity values.
  </para>
________________________________________________________-->
  <para>
   一个范围的下界可以被忽略，意味着所有小于上界的值都被包括在范围中，例如<literal>(,3]</literal>。
   同样，如果范围的上界被忽略，那么所有比上界大的值都被包括在范围中。如果上下界都被忽略，该元素类型的所有值都被认为在该范围中。
   规定缺失的包括界限自动转换为排除，例如，<literal>[,]</literal> 转换为 <literal>(,)</literal>。
   你可以认为这些缺失值为 +/- 无穷大，但它们是特殊范围类型值，并且被视为超出任何范围元素类型的 +/- 无穷大值。
  </para>
<!-- pgdoc-cn_end sig_en=4a68671348b6f501f6a51edd53d5b1f5 -->

<!-- pgdoc-cn_start sig_en=9ae4da9e23111d1b999862b283c4a9b9 sig_cn_org=None source=14.1 
  <para>
   Element types that have the notion of <quote>infinity</quote> can
   use them as explicit bound values.  For example, with timestamp
   ranges, <literal>[today,infinity)</literal> excludes the special
   <type>timestamp</type> value <literal>infinity</literal>,
   while <literal>[today,infinity]</literal> include it, as does
   <literal>[today,)</literal> and <literal>[today,]</literal>.
  </para>
________________________________________________________-->
  <para>
   具有<quote>infinity</quote>概念的元素类型可以用它们作为显式边界值。
   例如，在时间戳范围，<literal>[today,infinity)</literal> 不包括特殊的 <type>timestamp</type> 值 <literal>infinity</literal>,尽管 <literal>[today,infinity]</literal> 包括它, 就好比 <literal>[today,)</literal> 和 <literal>[today,]</literal>.
  </para>
<!-- pgdoc-cn_end sig_en=9ae4da9e23111d1b999862b283c4a9b9 -->

<!-- pgdoc-cn_start sig_en=c63dedb4c45e97258cae63717d0d805b sig_cn_org=None source=14.1 
  <para>
   The functions <literal>lower_inf</literal>
   and <literal>upper_inf</literal> test for infinite lower
   and upper bounds of a range, respectively.
  </para>
________________________________________________________-->
  <para>
   函数<literal>lower_inf</literal>和<literal>upper_inf</literal>分别测试一个范围的无限上下界。
  </para>
<!-- pgdoc-cn_end sig_en=c63dedb4c45e97258cae63717d0d805b -->
 </sect2>

 <sect2 id="rangetypes-io">
<!-- pgdoc-cn_start sig_en=134084fbbeb8938430144333bcb8ef59 sig_cn_org=None source=14.1 
  <title>Range Input/Output</title>
________________________________________________________-->
  <title>范围输入/输出</title>
<!-- pgdoc-cn_end sig_en=134084fbbeb8938430144333bcb8ef59 -->

<!-- pgdoc-cn_start sig_en=3b26428c7371af7ddffd20e368876251 sig_cn_org=None source=14.1 
  <para>
   The input for a range value must follow one of the following patterns:
<synopsis>
(<replaceable>lower-bound</replaceable>,<replaceable>upper-bound</replaceable>)
(<replaceable>lower-bound</replaceable>,<replaceable>upper-bound</replaceable>]
[<replaceable>lower-bound</replaceable>,<replaceable>upper-bound</replaceable>)
[<replaceable>lower-bound</replaceable>,<replaceable>upper-bound</replaceable>]
empty
</synopsis>
   The parentheses or brackets indicate whether the lower and upper bounds
   are exclusive or inclusive, as described previously.
   Notice that the final pattern is <literal>empty</literal>, which
   represents an empty range (a range that contains no points).
  </para>
________________________________________________________-->
  <para>
   一个范围值的输入必须遵循下列模式之一：
<synopsis>
(<replaceable>lower-bound</replaceable>,<replaceable>upper-bound</replaceable>)
(<replaceable>lower-bound</replaceable>,<replaceable>upper-bound</replaceable>]
[<replaceable>lower-bound</replaceable>,<replaceable>upper-bound</replaceable>)
[<replaceable>lower-bound</replaceable>,<replaceable>upper-bound</replaceable>]
empty
</synopsis>
   圆括号或方括号指示上下界是否为排除的或者包含的。注意最后一个模式是<literal>empty</literal>，它表示一个空范围（一个不包含点的范围）。
  </para>
<!-- pgdoc-cn_end sig_en=3b26428c7371af7ddffd20e368876251 -->

<!-- pgdoc-cn_start sig_en=bbf08a5ffca8833be202b2d1bfe430c3 sig_cn_org=None source=14.1 
  <para>
   The <replaceable>lower-bound</replaceable> may be either a string
   that is valid input for the subtype, or empty to indicate no
   lower bound.  Likewise, <replaceable>upper-bound</replaceable> may be
   either a string that is valid input for the subtype, or empty to
   indicate no upper bound.
  </para>
________________________________________________________-->
  <para>
   <replaceable>lower-bound</replaceable>可以是作为 subtype 的合法输入的一个字符串，或者是空表示没有下界。同样，<replaceable>upper-bound</replaceable>可以是作为 subtype 的合法输入的一个字符串，或者是空表示没有上界。
  </para>
<!-- pgdoc-cn_end sig_en=bbf08a5ffca8833be202b2d1bfe430c3 -->

<!-- pgdoc-cn_start sig_en=84bda214726d1eea9aa9270975f00ba0 sig_cn_org=None source=14.1 
  <para>
   Each bound value can be quoted using <literal>"</literal> (double quote)
   characters.  This is necessary if the bound value contains parentheses,
   brackets, commas, double quotes, or backslashes, since these characters
   would otherwise be taken as part of the range syntax.  To put a double
   quote or backslash in a quoted bound value, precede it with a
   backslash. (Also, a pair of double quotes within a double-quoted bound
   value is taken to represent a double quote character, analogously to the
   rules for single quotes in SQL literal strings.) Alternatively, you can
   avoid quoting and use backslash-escaping to protect all data characters
   that would otherwise be taken as range syntax.  Also, to write a bound
   value that is an empty string, write <literal>""</literal>, since writing
   nothing means an infinite bound.
  </para>
________________________________________________________-->
  <para>
   每个界限值可以使用<literal>"</literal>（双引号）字符引用。如果界限值包含圆括号、方括号、逗号、双引号或反斜线时，这样做是必须的，因为否则那些字符会被认作范围语法的一部分。要把一个双引号或反斜线放在一个被引用的界限值中，就在它前面放一个反斜线（还有，在一个双引号引用的界限值中的一对双引号表示一个双引号字符，这与 SQL 字符串中的单引号规则类似）。此外，你可以避免引用并且使用反斜线转义来保护所有数据字符，否则它们会被当做返回语法的一部分。还有，要写一个是空字符串的界限值，则可以写成<literal>""</literal>，因为什么都不写表示一个无限界限。
  </para>
<!-- pgdoc-cn_end sig_en=84bda214726d1eea9aa9270975f00ba0 -->

<!-- pgdoc-cn_start sig_en=fb753961a405310ec34748cb12059999 sig_cn_org=None source=14.1 
  <para>
   Whitespace is allowed before and after the range value, but any whitespace
   between the parentheses or brackets is taken as part of the lower or upper
   bound value.  (Depending on the element type, it might or might not be
   significant.)
  </para>
________________________________________________________-->
  <para>
   范围值前后允许有空格，但是圆括号或方括号之间的任何空格会被当做上下界值的一部分（取决于元素类型，它可能是也可能不是有意义的）。
  </para>
<!-- pgdoc-cn_end sig_en=fb753961a405310ec34748cb12059999 -->

  <note>
<!-- pgdoc-cn_start sig_en=09d3d7437da4cd3429232537dceb9056 sig_cn_org=None source=14.1 
   <para>
    These rules are very similar to those for writing field values in
    composite-type literals.  See <xref linkend="rowtypes-io-syntax"/> for
    additional commentary.
   </para>
________________________________________________________-->
   <para>
    这些规则与组合类型文字中书写域值的规则非常相似。更多注解请见<xref linkend="rowtypes-io-syntax"/>。
   </para>
<!-- pgdoc-cn_end sig_en=09d3d7437da4cd3429232537dceb9056 -->
  </note>

<!-- pgdoc-cn_start sig_en=bcb82eb7f7a721bff9e056dd86015928 sig_cn_org=None source=14.1 
  <para>
  Examples:
<programlisting>
-&minus; includes 3, does not include 7, and does include all points in between
SELECT '[3,7)'::int4range;

-&minus; does not include either 3 or 7, but includes all points in between
SELECT '(3,7)'::int4range;

-&minus; includes only the single point 4
SELECT '[4,4]'::int4range;

-&minus; includes no points (and will be normalized to 'empty')
SELECT '[4,4)'::int4range;
</programlisting>
  </para>
________________________________________________________-->
  <para>
  例子：
<programlisting>
-- 包括 3，不包括 7，并且包括 3 和 7 之间的所有点
SELECT '[3,7)'::int4range;

-- 既不包括 3 也不包括 7，但是包括之间的所有点
SELECT '(3,7)'::int4range;

-- 只包括单独一个点 4
SELECT '[4,4]'::int4range;

-- 不包括点（并且将被标准化为 '空'）
SELECT '[4,4)'::int4range;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=bcb82eb7f7a721bff9e056dd86015928 -->

<!-- pgdoc-cn_start sig_en=d6aa1463ae8fca07d170ee26c215949b sig_cn_org=None source=14.1 
  <para>
   The input for a multirange is curly brackets (<literal>{</literal> and
   <literal>}</literal>) containing zero or more valid ranges,
   separated by commas. Whitespace is permitted around the brackets and
   commas. This is intended to be reminiscent of array syntax, although
   multiranges are much simpler: they have just one dimension and there is
   no need to quote their contents. (The bounds of their ranges may be
   quoted as above however.)
  </para>
________________________________________________________-->
  <para>
   多范围输入是一个大括号 (<literal>{</literal> 和
   <literal>}</literal>) 其中包含零个或多个以逗号分隔的有效范围。括号和逗号周围允许有空格。
   为了使人想起数组语法，但多范围要更简单，只有一个维度，并且不需要在内容周围加上引号 (尽管范围的边界可以用引号引起来)
  </para>
<!-- pgdoc-cn_end sig_en=d6aa1463ae8fca07d170ee26c215949b -->

<!-- pgdoc-cn_start sig_en=548e69a1451234864d3df34067ec8848 sig_cn_org=None source=14.1 
  <para>
  Examples:
<programlisting>
SELECT '{}'::int4multirange;
SELECT '{[3,7)}'::int4multirange;
SELECT '{[3,7), [8,9)}'::int4multirange;
</programlisting>
  </para>
________________________________________________________-->
  <para>
  Examples:
<programlisting>
SELECT '{}'::int4multirange;
SELECT '{[3,7)}'::int4multirange;
SELECT '{[3,7), [8,9)}'::int4multirange;
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=548e69a1451234864d3df34067ec8848 -->

 </sect2>

 <sect2 id="rangetypes-construct">
<!-- pgdoc-cn_start sig_en=d48f44dd62d5be010eaca6e1ef7ecf74 sig_cn_org=None source=14.1 
  <title>Constructing Ranges and Multiranges</title>
________________________________________________________-->
  <title>构造范围和多范围</title>
<!-- pgdoc-cn_end sig_en=d48f44dd62d5be010eaca6e1ef7ecf74 -->

<!-- pgdoc-cn_start sig_en=40f88d646594db748c2cbc19308294e0 sig_cn_org=None source=14.1 
  <para>
   Each range type has a constructor function with the same name as the range
   type.  Using the constructor function is frequently more convenient than
   writing a range literal constant, since it avoids the need for extra
   quoting of the bound values.  The constructor function
   accepts two or three arguments.  The two-argument form constructs a range
   in standard form (lower bound inclusive, upper bound exclusive), while
   the three-argument form constructs a range with bounds of the form
   specified by the third argument.
   The third argument must be one of the strings
   <quote><literal>()</literal></quote>,
   <quote><literal>(]</literal></quote>,
   <quote><literal>[)</literal></quote>, or
   <quote><literal>[]</literal></quote>.
   For example:

<programlisting>
-&minus; The full form is: lower bound, upper bound, and text argument indicating
-&minus; inclusivity/exclusivity of bounds.
SELECT numrange(1.0, 14.0, '(]');

-&minus; If the third argument is omitted, '[)' is assumed.
SELECT numrange(1.0, 14.0);

-&minus; Although '(]' is specified here, on display the value will be converted to
-&minus; canonical form, since int8range is a discrete range type (see below).
SELECT int8range(1, 14, '(]');

-&minus; Using NULL for either bound causes the range to be unbounded on that side.
SELECT numrange(NULL, 2.2);
</programlisting>
  </para>
________________________________________________________-->
  <para>
   每一种范围类型都有一个与其同名的构造器函数。使用构造器函数常常比写一个范围文字常数更方便，因为它避免了对界限值的额外引用。构造器函数接受两个或三个参数。两个参数的形式以标准的形式构造一个范围（下界是包含的，上界是排除的），而三个参数的形式按照第三个参数指定的界限形式构造一个范围。第三个参数必须是下列字符串之一：
   <quote><literal>()</literal></quote>、
   <quote><literal>(]</literal></quote>、
   <quote><literal>[)</literal></quote>或者
   <quote><literal>[]</literal></quote>。
   例如：

<programlisting>
-- 完整形式是：下界、上界以及指示界限包含性/排除性的文本参数。
SELECT numrange(1.0, 14.0, '(]');

-- 如果第三个参数被忽略，则假定为 '[)'。
SELECT numrange(1.0, 14.0);

-- 尽管这里指定了 '(]'，显示时该值将被转换成标准形式，因为 int8range 是一种离散范围类型（见下文）。
SELECT int8range(1, 14, '(]');

-- 为一个界限使用 NULL 导致范围在那一边是无界的。
SELECT numrange(NULL, 2.2);
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=40f88d646594db748c2cbc19308294e0 -->

<!-- pgdoc-cn_start sig_en=4d9f697389c9fd577ca74f7096849b07 sig_cn_org=None source=14.1 
  <para>
   Each range type also has a multirange constructor with the same name as the
   multirange type.  The constructor function takes zero or more arguments
   which are all ranges of the appropriate type.
   For example:

<programlisting>
SELECT nummultirange();
SELECT nummultirange(numrange(1.0, 14.0));
SELECT nummultirange(numrange(1.0, 14.0), numrange(20.0, 25.0));
</programlisting>
  </para>
________________________________________________________-->
  <para>
     每个范围类型还有一个与多范围类型同名的多范围构造函数。构造函数接受零个或多个参数，所有参数都在适当的类型范围内。例如：

  <programlisting>
  SELECT nummultirange();
  SELECT nummultirange(numrange(1.0, 14.0));
  SELECT nummultirange(numrange(1.0, 14.0), numrange(20.0, 25.0));
  </programlisting>
    </para>
<!-- pgdoc-cn_end sig_en=4d9f697389c9fd577ca74f7096849b07 -->
 </sect2>

 <sect2 id="rangetypes-discrete">
<!-- pgdoc-cn_start sig_en=102ab0108e64a8313522deea1165a265 sig_cn_org=None source=14.1 
  <title>Discrete Range Types</title>
________________________________________________________-->
  <title>离散范围类型</title>
<!-- pgdoc-cn_end sig_en=102ab0108e64a8313522deea1165a265 -->

<!-- pgdoc-cn_start sig_en=4707f0b4ccdba86c858622980ce97038 sig_cn_org=None source=14.1 
  <para>
   A discrete range is one whose element type has a well-defined
   <quote>step</quote>, such as <type>integer</type> or <type>date</type>.
   In these types two elements can be said to be adjacent, when there are
   no valid values between them.  This contrasts with continuous ranges,
   where it's always (or almost always) possible to identify other element
   values between two given values.  For example, a range over the
   <type>numeric</type> type is continuous, as is a range over <type>timestamp</type>.
   (Even though <type>timestamp</type> has limited precision, and so could
   theoretically be treated as discrete, it's better to consider it continuous
   since the step size is normally not of interest.)
  </para>
________________________________________________________-->
  <para>
   一种范围的元素类型具有一个良定义的<quote>步长</quote>，例如<type>integer</type>或<type>date</type>。在这些类型中，如果两个元素之间没有合法值，它们可以被说成是相邻。这与连续范围相反，连续范围中总是（或者几乎总是）可以在两个给定值之间标识其他元素值。例如，<type>numeric</type>类型之上的一个范围就是连续的，<type>timestamp</type>上的范围也是（尽管<type>timestamp</type>具有有限的精度，并且在理论上可以被当做离散的，最好认为它是连续的，因为通常并不关心它的步长）。
  </para>
<!-- pgdoc-cn_end sig_en=4707f0b4ccdba86c858622980ce97038 -->

<!-- pgdoc-cn_start sig_en=55e36d567005bd014c923c440a01c80c sig_cn_org=None source=14.1 
  <para>
   Another way to think about a discrete range type is that there is a clear
   idea of a <quote>next</quote> or <quote>previous</quote> value for each element value.
   Knowing that, it is possible to convert between inclusive and exclusive
   representations of a range's bounds, by choosing the next or previous
   element value instead of the one originally given.
   For example, in an integer range type <literal>[4,8]</literal> and
   <literal>(3,9)</literal> denote the same set of values; but this would not be so
   for a range over numeric.
  </para>
________________________________________________________-->
  <para>
   另一种考虑离散范围类型的方法是对每一个元素值都有一种清晰的<quote>下一个</quote>或<quote>上一个</quote>值。了解了这种思想之后，通过选择原来给定的下一个或上一个元素值来取代它，就可以在一个范围界限的包含和排除表达之间转换。例如，在一个整数范围类型中，<literal>[4,8]</literal>和<literal>(3,9)</literal>表示相同的值集合，但是对于 numeric 上的范围就不是这样。
  </para>
<!-- pgdoc-cn_end sig_en=55e36d567005bd014c923c440a01c80c -->

<!-- pgdoc-cn_start sig_en=0e3621fb1f6224959a2ea6c427a9d290 sig_cn_org=None source=14.1 
  <para>
   A discrete range type should have a <firstterm>canonicalization</firstterm>
   function that is aware of the desired step size for the element type.
   The canonicalization function is charged with converting equivalent values
   of the range type to have identical representations, in particular
   consistently inclusive or exclusive bounds.
   If a canonicalization function is not specified, then ranges with different
   formatting will always be treated as unequal, even though they might
   represent the same set of values in reality.
  </para>
________________________________________________________-->
  <para>
   一个离散范围类型应该具有一个<firstterm>正规化</firstterm>函数，它知道元素类型期望的步长。正规化函数负责把范围类型的相等值转换成具有相同的表达，特别是与包含或者排除界限一致。如果没有指定一个正规化函数，那么具有不同格式的范围将总是会被当作不等，即使它们实际上是表达相同的一组值。
  </para>
<!-- pgdoc-cn_end sig_en=0e3621fb1f6224959a2ea6c427a9d290 -->

<!-- pgdoc-cn_start sig_en=29a44f1174d5addb3ac8b2bd402a0d9f sig_cn_org=None source=14.1 
  <para>
   The built-in range types <type>int4range</type>, <type>int8range</type>,
   and <type>daterange</type> all use a canonical form that includes
   the lower bound and excludes the upper bound; that is,
   <literal>[)</literal>. User-defined range types can use other conventions,
   however.
  </para>
________________________________________________________-->
  <para>
   内建的范围类型<type>int4range</type>、<type>int8range</type>和<type>daterange</type>都使用一种正规的形式，该形式包括下界并且排除上界，也就是<literal>[)</literal>。不过，用户定义的范围类型可以使用其他习惯。
  </para>
<!-- pgdoc-cn_end sig_en=29a44f1174d5addb3ac8b2bd402a0d9f -->
 </sect2>

 <sect2 id="rangetypes-defining">
<!-- pgdoc-cn_start sig_en=f20434e89ccfb746fd3c1a5526dbe94c sig_cn_org=None source=14.1 
  <title>Defining New Range Types</title>
________________________________________________________-->
  <title>定义新的范围类型</title>
<!-- pgdoc-cn_end sig_en=f20434e89ccfb746fd3c1a5526dbe94c -->

<!-- pgdoc-cn_start sig_en=8d6eefb7e2aa9e556ad444427758137e sig_cn_org=None source=14.1 
  <para>
   Users can define their own range types. The most common reason to do
   this is to use ranges over subtypes not provided among the built-in
   range types.
   For example, to define a new range type of subtype <type>float8</type>:

<programlisting>
CREATE TYPE floatrange AS RANGE (
    subtype = float8,
    subtype_diff = float8mi
);

SELECT '[1.234, 5.678]'::floatrange;
</programlisting>

   Because <type>float8</type> has no meaningful
   <quote>step</quote>, we do not define a canonicalization
   function in this example.
  </para>
________________________________________________________-->
  <para>
   用户可以定义他们自己的范围类型。这样做最常见的原因是为了使用内建范围类型中没有提供的 subtype 上的范围。例如，要创建一个 subtype <type>float8</type>的范围类型：

<programlisting>
CREATE TYPE floatrange AS RANGE (
    subtype = float8,
    subtype_diff = float8mi
);

SELECT '[1.234, 5.678]'::floatrange;
</programlisting>

   因为<type>float8</type>没有有意义的<quote>步长</quote>，我们在这个例子中没有定义一个正规化函数。
  </para>
<!-- pgdoc-cn_end sig_en=8d6eefb7e2aa9e556ad444427758137e -->

<!-- pgdoc-cn_start sig_en=976542af4e1f1ce9937639d5ecaa05b2 sig_cn_org=None source=14.1 
  <para>
   When you define your own range you automatically get a corresponding
   multirange type.
  </para>
________________________________________________________-->
  <para>
    当您定义自己的范围时，您会自动获得相应的多范围类型。
    </para>
<!-- pgdoc-cn_end sig_en=976542af4e1f1ce9937639d5ecaa05b2 -->

<!-- pgdoc-cn_start sig_en=cb42ee77f2ce0aeec70c39c8771ac723 sig_cn_org=None source=14.1 
  <para>
   Defining your own range type also allows you to specify a different
   subtype B-tree operator class or collation to use, so as to change the sort
   ordering that determines which values fall into a given range.
  </para>
________________________________________________________-->
  <para>
   定义自己的范围类型也允许你指定使用一个不同的子类型 B-树操作符类或者集合，
   以便更改排序顺序来决定哪些值会落入到给定的范围中。
  </para>
<!-- pgdoc-cn_end sig_en=cb42ee77f2ce0aeec70c39c8771ac723 -->

<!-- pgdoc-cn_start sig_en=b8951a34a0c42cac022da780d943ba36 sig_cn_org=None source=14.1 
  <para>
   If the subtype is considered to have discrete rather than continuous
   values, the <command>CREATE TYPE</command> command should specify a
   <literal>canonical</literal> function.
   The canonicalization function takes an input range value, and must return
   an equivalent range value that may have different bounds and formatting.
   The canonical output for two ranges that represent the same set of values,
   for example the integer ranges <literal>[1, 7]</literal> and <literal>[1,
   8)</literal>, must be identical.  It doesn't matter which representation
   you choose to be the canonical one, so long as two equivalent values with
   different formattings are always mapped to the same value with the same
   formatting.  In addition to adjusting the inclusive/exclusive bounds
   format, a canonicalization function might round off boundary values, in
   case the desired step size is larger than what the subtype is capable of
   storing.  For instance, a range type over <type>timestamp</type> could be
   defined to have a step size of an hour, in which case the canonicalization
   function would need to round off bounds that weren't a multiple of an hour,
   or perhaps throw an error instead.
  </para>
________________________________________________________-->
  <para>
   如果 subtype 被认为是具有离散值而不是连续值，<command>CREATE TYPE</command>命令应当指定一个<literal>canonical</literal>函数。正规化函数接收一个输入的范围值，并且必须返回一个可能具有不同界限和格式的等价的范围值。对于两个表示相同值集合的范围（例如<literal>[1, 7]</literal>和<literal>[1, 8)</literal>），正规的输出必须一样。选择哪一种表达作为正规的没有关系，只要两个具有不同格式的等价值总是能被映射到具有相同格式的相同值就行。除了调整包含/排除界限格式外，假使期望的补偿比 subtype 能够存储的要大，一个正规化函数可能会舍入边界值。例如，一个<type>timestamp</type>之上的范围类型可能被定义为具有一个一小时的步长，这样正规化函数可能需要对不是一小时的倍数的界限进行舍入，或者可能直接抛出一个错误。
  </para>
<!-- pgdoc-cn_end sig_en=b8951a34a0c42cac022da780d943ba36 -->

<!-- pgdoc-cn_start sig_en=540fbd59dfe09a79170608c0d812bc4f sig_cn_org=None source=14.1 
  <para>
   In addition, any range type that is meant to be used with GiST or SP-GiST
   indexes should define a subtype difference, or <literal>subtype_diff</literal>,
   function.  (The index will still work without <literal>subtype_diff</literal>,
   but it is likely to be considerably less efficient than if a difference
   function is provided.)  The subtype difference function takes two input
   values of the subtype, and returns their difference
   (i.e., <replaceable>X</replaceable> minus <replaceable>Y</replaceable>) represented as
   a <type>float8</type> value.  In our example above, the
   function <function>float8mi</function> that underlies the regular <type>float8</type>
   minus operator can be used; but for any other subtype, some type
   conversion would be necessary.  Some creative thought about how to
   represent differences as numbers might be needed, too.  To the greatest
   extent possible, the <literal>subtype_diff</literal> function should agree with
   the sort ordering implied by the selected operator class and collation;
   that is, its result should be positive whenever its first argument is
   greater than its second according to the sort ordering.
  </para>
________________________________________________________-->
  <para>
   另外，任何打算要和 GiST 或 SP-GiST 索引一起使用的范围类型应当定一个 subtype 差异或<literal>subtype_diff</literal>函数（没有<literal>subtype_diff</literal>时索引仍然能工作，但是可能效率不如提供了差异函数时高）。subtype 差异函数采用两个 subtype 输入值，并且返回表示为一个<type>float8</type>值的差（即<replaceable>X</replaceable>减<replaceable>Y</replaceable>）。在我们上面的例子中，可以使用常规<type>float8</type>减法操作符之下的函数。但是对于任何其他 subtype，可能需要某种类型转换。还可能需要一些关于如何把差异表达为数字的创新型想法。为了最大的可扩展性，<literal>subtype_diff</literal>函数应该同意选中的操作符类和排序规则所蕴含的排序顺序，也就是说，只要它的第一个参数根据排序顺序大于第二个参数，它的结果就应该是正值。
  </para>
<!-- pgdoc-cn_end sig_en=540fbd59dfe09a79170608c0d812bc4f -->

<!-- pgdoc-cn_start sig_en=3923c8bf524182a87a0132f57d1ba0c0 sig_cn_org=None source=14.1 
  <para>
   A less-oversimplified example of a <literal>subtype_diff</literal> function is:
  </para>
________________________________________________________-->
  <para>
   <literal>subtype_diff</literal>函数的一个不那么过度简化的例子：
  </para>
<!-- pgdoc-cn_end sig_en=3923c8bf524182a87a0132f57d1ba0c0 -->

<!-- pgdoc-cn_start sig_en=125f0b4e2df84bfed500f7994c56c083 sig_cn_org=None source=14.1 
<programlisting>
CREATE FUNCTION time_subtype_diff(x time, y time) RETURNS float8 AS
'SELECT EXTRACT(EPOCH FROM (x - y))' LANGUAGE sql STRICT IMMUTABLE;

CREATE TYPE timerange AS RANGE (
    subtype = time,
    subtype_diff = time_subtype_diff
);

SELECT '[11:10, 23:00]'::timerange;
</programlisting>
________________________________________________________-->
<programlisting>
CREATE FUNCTION time_subtype_diff(x time, y time) RETURNS float8 AS
'SELECT EXTRACT(EPOCH FROM (x - y))' LANGUAGE sql STRICT IMMUTABLE;

CREATE TYPE timerange AS RANGE (
    subtype = time,
    subtype_diff = time_subtype_diff
);

SELECT '[11:10, 23:00]'::timerange;
</programlisting>
<!-- pgdoc-cn_end sig_en=125f0b4e2df84bfed500f7994c56c083 -->

<!-- pgdoc-cn_start sig_en=938344f2d655ec1bb2c5df93c8ede7f8 sig_cn_org=None source=14.1 
  <para>
   See <xref linkend="sql-createtype"/> for more information about creating
   range types.
  </para>
________________________________________________________-->
  <para>
   更多关于创建范围类型的信息请参考<xref linkend="sql-createtype"/>。
  </para>
<!-- pgdoc-cn_end sig_en=938344f2d655ec1bb2c5df93c8ede7f8 -->
 </sect2>

 <sect2 id="rangetypes-indexing">
<!-- pgdoc-cn_start sig_en=b23c3224c154d2e64dacb305e2760085 sig_cn_org=None source=14.1 
  <title>Indexing</title>
________________________________________________________-->
  <title>索引</title>
<!-- pgdoc-cn_end sig_en=b23c3224c154d2e64dacb305e2760085 -->

<!-- pgdoc-cn_start sig_en=82e88b99260867671e0f42dccecbd844 sig_cn_org=None source=14.1 
  <indexterm>
    <primary>range type</primary>
    <secondary>indexes on</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm>
    <primary>range type</primary>
    <secondary>indexes on</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=82e88b99260867671e0f42dccecbd844 -->

<!-- pgdoc-cn_start sig_en=f4b518dad9a337571acaa93d5a263449 sig_cn_org=None source=14.1 
  <para>
   GiST and SP-GiST indexes can be created for table columns of range types.
   GiST indexes can be also created for table columns of multirange types.
   For instance, to create a GiST index:
<programlisting>
CREATE INDEX reservation_idx ON reservation USING GIST (during);
</programlisting>
   A GiST or SP-GiST index on ranges can accelerate queries involving these
   range operators:
   <literal>=</literal>,
   <literal>&amp;&amp;</literal>,
   <literal>&lt;@</literal>,
   <literal>@&gt;</literal>,
   <literal>&lt;&lt;</literal>,
   <literal>&gt;&gt;</literal>,
   <literal>-|-</literal>,
   <literal>&amp;&lt;</literal>, and
   <literal>&amp;&gt;</literal>.
   A GiST index on multiranges can accelerate queries involving the same
   set of multirange operators.
   A GiST index on ranges and GiST index on multiranges can also accelerate
   queries involving these cross-type range to multirange and multirange to
   range operators correspondingly:
   <literal>&amp;&amp;</literal>,
   <literal>&lt;@</literal>,
   <literal>@&gt;</literal>,
   <literal>&lt;&lt;</literal>,
   <literal>&gt;&gt;</literal>,
   <literal>-|-</literal>,
   <literal>&amp;&lt;</literal>, and
   <literal>&amp;&gt;</literal>.
   See <xref linkend="range-operators-table"/> for more information.
  </para>
________________________________________________________-->
  <para>
   可以为范围类型的表列创建 GiST 和 SP-GiST 索引。在多范围类型的列上也可以创建GiST 索引。例如，要创建一个 GiST 索引：
<programlisting>
CREATE INDEX reservation_idx ON reservation USING GIST (during);
</programlisting>
   范围类型上使用 GiST 或 SP-GiST 索引可以加速涉及以下范围操作符的查询：
      <literal>&amp;&amp;</literal>,
      <literal>&lt;@</literal>,
      <literal>@&gt;</literal>,
      <literal>&lt;&lt;</literal>,
      <literal>&gt;&gt;</literal>,
      <literal>-|-</literal>,
      <literal>&amp;&lt;</literal>, 和
      <literal>&amp;&gt;</literal>
   （详见<xref linkend="range-operators-table"/>）。
  </para>
<!-- pgdoc-cn_end sig_en=f4b518dad9a337571acaa93d5a263449 -->

<!-- pgdoc-cn_start sig_en=b022411b5fd8d5ab83a9345139609d9c sig_cn_org=None source=14.1 
  <para>
   In addition, B-tree and hash indexes can be created for table columns of
   range types.  For these index types, basically the only useful range
   operation is equality.  There is a B-tree sort ordering defined for range
   values, with corresponding <literal>&lt;</literal> and <literal>&gt;</literal> operators,
   but the ordering is rather arbitrary and not usually useful in the real
   world.  Range types' B-tree and hash support is primarily meant to
   allow sorting and hashing internally in queries, rather than creation of
   actual indexes.
  </para>
________________________________________________________-->
  <para>
   此外，B-树和哈希索引可以在范围类型的表列上创建。对于这些索引类型，基本上唯一有用的范围操作就是等值。使用相应的<literal>&lt;</literal> 和 <literal>&gt;</literal>操作符，对于范围值定义有一种 B-树排序顺序，但是该顺序相当任意并且在真实世界中通常不怎么有用。范围类型的 B-树和哈希支持主要是为了允许在查询内部进行排序和哈希，而不是创建真正的索引。
  </para>
<!-- pgdoc-cn_end sig_en=b022411b5fd8d5ab83a9345139609d9c -->
 </sect2>

 <sect2 id="rangetypes-constraint">
<!-- pgdoc-cn_start sig_en=0b91dd205a57f1432b046f0c0160afe2 sig_cn_org=None source=14.1 
  <title>Constraints on Ranges</title>
________________________________________________________-->
  <title>范围上的约束</title>
<!-- pgdoc-cn_end sig_en=0b91dd205a57f1432b046f0c0160afe2 -->

<!-- pgdoc-cn_start sig_en=6e85b1979b480ee8c1c4c6b582397135 sig_cn_org=None source=14.1 
  <indexterm>
    <primary>range type</primary>
    <secondary>exclude</secondary>
  </indexterm>
________________________________________________________-->
  <indexterm>
    <primary>range type</primary>
    <secondary>exclude</secondary>
  </indexterm>
<!-- pgdoc-cn_end sig_en=6e85b1979b480ee8c1c4c6b582397135 -->

<!-- pgdoc-cn_start sig_en=804271572e8533906da2f5be024298f1 sig_cn_org=None source=14.1 
  <para>
   While <literal>UNIQUE</literal> is a natural constraint for scalar
   values, it is usually unsuitable for range types. Instead, an
   exclusion constraint is often more appropriate
   (see <link linkend="sql-createtable-exclude">CREATE TABLE
   ... CONSTRAINT ... EXCLUDE</link>). Exclusion constraints allow the
   specification of constraints such as <quote>non-overlapping</quote> on a
   range type. For example:

<programlisting>
CREATE TABLE reservation (
    during tsrange,
    EXCLUDE USING GIST (during WITH &amp;&amp;)
);
</programlisting>

   That constraint will prevent any overlapping values from existing
   in the table at the same time:

<programlisting>
INSERT INTO reservation VALUES
    ('[2010-01-01 11:30, 2010-01-01 15:00)');
INSERT 0 1

INSERT INTO reservation VALUES
    ('[2010-01-01 14:45, 2010-01-01 15:45)');
ERROR:  conflicting key value violates exclusion constraint "reservation_during_excl"
DETAIL:  Key (during)=(["2010-01-01 14:45:00","2010-01-01 15:45:00")) conflicts
with existing key (during)=(["2010-01-01 11:30:00","2010-01-01 15:00:00")).
</programlisting>
  </para>
________________________________________________________-->
  <para>
   虽然<literal>UNIQUE</literal>是标量值的一种自然约束，它通常不适合于范围类型。反而，一种排除约束常常更加适合（见<link linkend="sql-createtable-exclude">CREATE TABLE ... CONSTRAINT ... EXCLUDE</link>）。排除约束允许在一个范围类型上说明诸如<quote>non-overlapping</quote>的约束。例如：

<programlisting>
CREATE TABLE reservation (
    during tsrange,
    EXCLUDE USING GIST (during WITH &amp;&amp;)
);
</programlisting>

   该约束将阻止任何重叠值同时存在于表中：

<programlisting>
INSERT INTO reservation VALUES
    ('[2010-01-01 11:30, 2010-01-01 15:00)');
INSERT 0 1

INSERT INTO reservation VALUES
    ('[2010-01-01 14:45, 2010-01-01 15:45)');
ERROR:  conflicting key value violates exclusion constraint "reservation_during_excl"
DETAIL:  Key (during)=(["2010-01-01 14:45:00","2010-01-01 15:45:00")) conflicts
with existing key (during)=(["2010-01-01 11:30:00","2010-01-01 15:00:00")).
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=804271572e8533906da2f5be024298f1 -->

<!-- pgdoc-cn_start sig_en=34baa8711a8ca5647f12bee4be7850e3 sig_cn_org=None source=14.1 
  <para>
   You can use the <link linkend="btree-gist"><literal>btree_gist</literal></link>
   extension to define exclusion constraints on plain scalar data types, which
   can then be combined with range exclusions for maximum flexibility.  For
   example, after <literal>btree_gist</literal> is installed, the following
   constraint will reject overlapping ranges only if the meeting room numbers
   are equal:

<programlisting>
CREATE EXTENSION btree_gist;
CREATE TABLE room_reservation (
    room text,
    during tsrange,
    EXCLUDE USING GIST (room WITH =, during WITH &amp;&amp;)
);

INSERT INTO room_reservation VALUES
    ('123A', '[2010-01-01 14:00, 2010-01-01 15:00)');
INSERT 0 1

INSERT INTO room_reservation VALUES
    ('123A', '[2010-01-01 14:30, 2010-01-01 15:30)');
ERROR:  conflicting key value violates exclusion constraint "room_reservation_room_during_excl"
DETAIL:  Key (room, during)=(123A, ["2010-01-01 14:30:00","2010-01-01 15:30:00")) conflicts
with existing key (room, during)=(123A, ["2010-01-01 14:00:00","2010-01-01 15:00:00")).

INSERT INTO room_reservation VALUES
    ('123B', '[2010-01-01 14:30, 2010-01-01 15:30)');
INSERT 0 1
</programlisting>
  </para>
________________________________________________________-->
  <para>
   你可以使用<link linkend="btree-gist"><literal>btree_gist</literal></link>扩展来在纯标量数据类型上定义排除约束，然后把它和范围排除结合可以得到最大的灵活性。例如，安装<literal>btree_gist</literal>之后，只有会议室号码相等时，下列约束将拒绝重叠的范围：

<programlisting>
CREATE EXTENSION btree_gist;
CREATE TABLE room_reservation (
    room text,
    during tsrange,
    EXCLUDE USING GIST (room WITH =, during WITH &amp;&amp;)
);

INSERT INTO room_reservation VALUES
    ('123A', '[2010-01-01 14:00, 2010-01-01 15:00)');
INSERT 0 1

INSERT INTO room_reservation VALUES
    ('123A', '[2010-01-01 14:30, 2010-01-01 15:30)');
ERROR:  conflicting key value violates exclusion constraint "room_reservation_room_during_excl"
DETAIL:  Key (room, during)=(123A, ["2010-01-01 14:30:00","2010-01-01 15:30:00")) conflicts
with existing key (room, during)=(123A, ["2010-01-01 14:00:00","2010-01-01 15:00:00")).

INSERT INTO room_reservation VALUES
    ('123B', '[2010-01-01 14:30, 2010-01-01 15:30)');
INSERT 0 1
</programlisting>
  </para>
<!-- pgdoc-cn_end sig_en=34baa8711a8ca5647f12bee4be7850e3 -->
 </sect2>
</sect1>
